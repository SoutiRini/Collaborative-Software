[{"count": 0, "tags": [], "creator": "rogov@devexperts.com", "attachment_id": null, "is_private": false, "id": 123070, "time": "2008-12-04T01:12:15Z", "bug_id": 46336, "creation_time": "2008-12-04T01:12:15Z", "text": "I have a multi-threaded rendering application. It produced this exception:\n\njava.lang.NullPointerException\nat org.apache.fop.fonts.autodetect.FontInfoFinder.find(FontInfoFinder.java:172)\nat org.apache.fop.render.PrintRendererConfigurator.addFontInfoListFromFileList(PrintRendererConfigurator.java:233)\nat org.apache.fop.render.PrintRendererConfigurator.buildFontListFromConfiguration(PrintRendererConfigurator.java:140)\nat org.apache.fop.render.PrintRendererConfigurator.configure(PrintRendererConfigurator.java:95)\nat org.apache.fop.render.pdf.PDFRendererConfigurator.configure(PDFRendererConfigurator.java:71)\nat org.apache.fop.render.RendererFactory.createRenderer(RendererFactory.java:187)\nat org.apache.fop.area.RenderPagesModel.<init>(RenderPagesModel.java:68)\nat org.apache.fop.area.AreaTreeHandler.setupModel(AreaTreeHandler.java:127)\nat org.apache.fop.area.AreaTreeHandler.<init>(AreaTreeHandler.java:102)\nat org.apache.fop.render.RendererFactory.createFOEventHandler(RendererFactory.java:224)\nat org.apache.fop.fo.FOTreeBuilder.<init>(FOTreeBuilder.java:100)\nat org.apache.fop.apps.Fop.createDefaultHandler(Fop.java:100)\nat org.apache.fop.apps.Fop.<init>(Fop.java:78)\nat org.apache.fop.apps.FopFactory.newFop(FopFactory.java:247)\n...\n\n\nI guess the problem is, that you don't synchronize usage of FontCache in this method:\n\n150     public EmbedFontInfo find(URL fontUrl, FontResolver resolver, FontCache fontCache) {\n151         String embedUrl = null;\n152         embedUrl = fontUrl.toExternalForm();\n153         \n154         long fileLastModified = -1;\n155         if (fontCache != null) {\n156             try {\n157                 URLConnection conn = fontUrl.openConnection();\n158                 try {\n159                     fileLastModified = conn.getLastModified();\n160                 } finally {\n161                     //An InputStream is created even if it's not accessed, but we need to close it.\n162                     IOUtils.closeQuietly(conn.getInputStream());\n163                 }\n164             } catch (IOException e) {\n165                 // Should never happen, because URL must be local\n166                 log.debug(\"IOError: \" + e.getMessage());\n167                 fileLastModified = 0;\n168             }\n169             // firstly try and fetch it from cache before loading/parsing the font file\n170             if (fontCache.containsFont(embedUrl)) {\n171                 CachedFontInfo fontInfo = fontCache.getFont(embedUrl);\n172                 if (fontInfo.lastModified() == fileLastModified) {\n173                     return fontInfo;\n174                 } else {\n175                     // out of date cache item\n176                     fontCache.removeFont(embedUrl);\n177                 }\n178             // is this a previously failed parsed font?\n179             } else if (fontCache.isFailedFont(embedUrl, fileLastModified)) {\n180                 if (log.isDebugEnabled()) {\n181                     log.debug(\"Skipping font file that failed to load previously: \" + embedUrl);\n182                 }\n183                 return null;\n184             }\n185         }\n186         \n187         // try to determine triplet information from font file\n188         CustomFont customFont = null;\n189         try {\n190             customFont = FontLoader.loadFont(fontUrl, resolver);\n191         } catch (Exception e) {\n192             //TODO Too verbose (it's an error but we don't care if some fonts can't be loaded)\n193             if (log.isErrorEnabled()) {\n194                 log.error(\"Unable to load font file: \" + embedUrl + \". Reason: \" + e.getMessage());\n195             }\n196             if (fontCache != null) {\n197                 fontCache.registerFailedFont(embedUrl, fileLastModified);\n198             }\n199             return null;\n200         }\n201         return fontInfoFromCustomFont(fontUrl, customFont, fontCache);     \n202     }\n203 }\n204 \n\nWhen thread1 and thread2 both enter IF at line 170, one can remove the font and then the other will get null at line 171."}, {"attachment_id": null, "tags": [], "creator": "adelmelle@apache.org", "text": "\nAre you certain it is a synchronization failure, or did you only draw that conclusion because the app is multi-threaded and the issue does not arise in single-threaded context?\n\nIf I interpret correctly, this points to something other than a synchronization failure...\n\njava.lang.NullPointerException\nat org.apache.fop.fonts.autodetect.FontInfoFinder.find(FontInfoFinder.java:172)\n...\n170             if (fontCache.containsFont(embedUrl)) {\n171                 CachedFontInfo fontInfo = fontCache.getFont(embedUrl);\n172                 if (fontInfo.lastModified() == fileLastModified) {\n\n\nThe NullPointerException must be caused by fontInfo.lastModified(). \nIt therefore appears possible for the FontCache to return true for containsFont(...) and yet return null for getFont(...) with the same URL?\n\nAnyway, I quickly checked the source in FOP Trunk, and getFont() doesn't even exist as a method for FontCache anymore. Can you check if the problem persists if you use trunk instead of 0.95?", "count": 1, "id": 123087, "time": "2008-12-04T10:51:38Z", "bug_id": 46336, "creation_time": "2008-12-04T10:51:38Z", "is_private": false}, {"count": 2, "tags": [], "creator": "rogov@devexperts.com", "attachment_id": null, "text": "unfortunately, i can't check the development trunk. we are already in production and thus we would like to update to somewhat stable releases.\n\nit's obvious to me, that this issue is most probably caused by lack of synchronization, since calling containsFont and getFont is not atomic. and we already had just the same kind of issue within FOP - see bug 46211.\n\nanyway - i can make a workaround for this in my own logic for time being and wait for new stable FOP release.", "id": 123099, "time": "2008-12-04T23:46:27Z", "bug_id": 46336, "creation_time": "2008-12-04T23:46:27Z", "is_private": false}, {"count": 3, "tags": [], "bug_id": 46336, "is_private": false, "text": "(In reply to comment #2)\n> unfortunately, i can't check the development trunk. we are already in\n> production and thus we would like to update to somewhat stable releases.\n> \n> it's obvious to me, that this issue is most probably caused by lack of\n> synchronization, since calling containsFont and getFont is not atomic. and we\n> already had just the same kind of issue within FOP - see bug 46211.\n\nYes, now I see it. If I judge correctly, the problem is still present in FOP Trunk. \nOne thread can call find() (non-synchronized), which calls getFontInfos() (non-synchronized), which could call removeFont(). Only the removal is done in a synchronized block... but another thread could indeed at the same time be querying the cache, which explains this issue.\n\nIn org.apache.fop.fo.properties.PropertyCache (following the example of Java's ConcurrentHashMap), this is solved by performing a get() twice if necessary. Once without synchronization, but if that attempt fails, we still try a second time in a synchronized block. Although here, it seems like the other way around: a check for contains() succeeded, but the font was removed after that call... Not sure what the best solution would be in this case...\n\nConfirms what I already knew to be true: programming with taking multi-threading contexts into account is definitely an Art-form... Even when /everything/ goes right during testing, that does not exclude race-conditions from popping up months after a release.\n\nThanks for the report and the feedback!", "id": 123136, "time": "2008-12-05T10:05:13Z", "creator": "adelmelle@apache.org", "creation_time": "2008-12-05T10:05:13Z", "attachment_id": null}, {"count": 4, "tags": [], "bug_id": 46336, "text": "\nInvestigated this issue closer, and one source of errors seems to be in the silent assumption, in FontInfoFinder.find(), that the fileLastModified variable, set right before containsFont() is called, will always be the same as the cached font file's lastModified() it will be compared to if the call returns true and getFontInfos() is triggered.\nNot even inlining the call to FontCache.getLastModified() will guarantee that, although it would make occurrences far less likely.\nIt is conceivable that another thread, in the time between those two calls, has added a newer version of the file to the cache, which would result in FontCache.getFontInfos() removing that entry and return null... The file corresponding to the newly added entry is then reparsed in the original thread and added again to the map (operation which is thus performed twice, without good reason)\n\nBesides that, as it was pointed out earlier, only the writes to the Map backing FontCache are performed in a synchronized fashion. The reads are not, and so may return results that turn out to be unreliable (i.e. they are guaranteed to be correct only for the duration of the call).\n\nTrying to get my head around what actually happens there, seems to show at least /some/ redundancies...\nFontInfoFinder.find()\n-> fontCache.containsFont()\n  -> fontFileMap.containsKey()\n-> fontCache.getFontInfos()\n  -> fontCache.getFontFile()\n    -> fontCache.containsFont()\n      -> fontFileMap.containsKey()\n    -> fontCache.removeFont()\n      -> fontCache.containsFont()\n        -> fontFileMap.containsKey()\n      -> fontFileMap.remove()\n        -> fontFileMap.containsKey() (?)\n\nOn the other hand, getFontInfos() itself assumes that getFontFile() will always return a non-null result, while the implementation a few lines up shows otherwise.\n\nIMO, to make access by multiple threads easily manageable, FontCache has too many public methods. In fact, almost none is used anywhere outside the class.  removeFont() is one obvious candidate for a change in visibility. As for the interplay between FontInfoFinder and FontCache, it seems that either the one or the other is assuming too much responsibilities. Can't put my finger yet on which of the two is stepping out of bounds (initial guess would be the latter), but I'm definitely going to check if I can clean that up a little.", "id": 123177, "time": "2008-12-08T10:19:35Z", "creator": "adelmelle@apache.org", "creation_time": "2008-12-08T10:19:35Z", "is_private": false, "attachment_id": null}, {"count": 5, "tags": [], "bug_id": 46336, "attachment_id": null, "id": 123230, "time": "2008-12-10T12:23:51Z", "creator": "adelmelle@apache.org", "creation_time": "2008-12-10T12:23:51Z", "is_private": false, "text": "\nI think I found a partial solution to the issue. \"Partial\" means \"safer, but still not ideal\"\n\nExplanation:\nI rewrote FontCache.getFontInfos() to something like:\n\n---\nCachedFontFile cff = getFontFile(embedUrl);\nif (cff != null) {\n  if (cff.lastModified >= lastModified) {\n    return cff.getEmbedFontInfos();\n  }\n  synchronized (changeLock) {\n    //redo the fetch to make sure\n    cff = getFontFile(embedUrl);\n    if (cff != null) {\n      if (cff.lastModified < lastModified) {\n        //outdated entry, and we're the first one here, so...\n        getFontFileMap().remove(embedUrl);\n        changed = true;\n        return null;\n      } else {\n        //another thread already detected this, and reloaded\n        return cff.getEmbedFontInfos();\n      }\n    }\n  }\n}\n\nsynchronized (changeLock) {\n  cff = getFontFile(embedUrl);\n  if (cff != null) {\n    //first fetch returned null, but now we do get one...\n    //for simplicity, assume this entry will do\n    return cff.getEmbedFontInfos();\n  }\n}\n\nreturn null\n---\n\nIn the best case (font present & up-to-date), there's no synchronization overhead. In the worst case, we would perform three fetches: one non-synchronized (returning an outdated entry), a second synchronized (returning null because another thread already removed the font), and a third one returning... what exactly?\n\nNow, it is still not ideal since there is absolutely no guarantee yet that the thread that actually removed the entry will be done with reloading the font (in FontInfoFinder.find()) in time for subsequent threads to obtain the new entry... In theory it is still possible that multiple threads reload the font in parallel, which should actually be avoided, IIC.\nIt does remain safe, since, although multiple threads reload the font, only one of them will actually add the newer entry to the cache. (see FontCache.addFont())"}, {"attachment_id": 23047, "tags": [], "creator": "adelmelle@apache.org", "text": "Created attachment 23047\npatch proposal\n\n\nAnother attempt, slightly better IIC, but still not bullet-proof.\n\nIf getFontInfos() returns an outdated entry, and another thread has already started the removal/readdition, then the thread will wait until it is notified by either addFont() or registerFailedFont().\n\nTricky bits:\n- after the notification, we're still not sure that it stems from the same font we're waiting for... (any addFont() or registerFailedFont() will trigger notifyAll())\n- if the removal/readdition has begun, and one thread is busy reloading the font, getFontInfos() will still return null (parallel loading still remains possible)\n\nRemaining question (not immediately clear to me):\nIs it conceivable that one thread removes the outdated entry, yet neither addFont() nor registerFailedFont() is called later? It didn't seem so, but should that be the case, the wait() method should probably be passed a reasonable maximum duration to avoid eternal sleep.", "count": 6, "id": 123495, "time": "2008-12-22T16:03:38Z", "bug_id": 46336, "creation_time": "2008-12-22T16:03:38Z", "is_private": false}, {"count": 7, "tags": [], "creator": "adelmelle@apache.org", "attachment_id": 23048, "is_private": false, "id": 123496, "time": "2008-12-22T16:49:31Z", "bug_id": 46336, "creation_time": "2008-12-22T16:49:31Z", "text": "Created attachment 23048\nupdated patch\n\n\nSlight improvement over the previous patch:\nAdded a Set of 'changingFonts', to keep track of which fonts are in the process of being reloaded. \nUpon encountering an outdated entry, its embedUrl is added to the Set. Later on, either addFont() or registerFailedFont() will remove it again. Other threads will wait while the font is in transition, and can check the changingFonts set to see if the font corresponding to the embedUrl was already reloaded."}, {"count": 8, "tags": [], "bug_id": 46336, "is_private": false, "text": "Created attachment 23049\ncorrection\n\n\nprevious one still buggy on the transient set...", "id": 123497, "time": "2008-12-22T16:59:40Z", "creator": "adelmelle@apache.org", "creation_time": "2008-12-22T16:59:40Z", "attachment_id": 23049}, {"attachment_id": null, "tags": [], "creator": "gadams@apache.org", "is_private": false, "count": 9, "id": 157403, "time": "2012-04-07T01:42:30Z", "bug_id": 46336, "creation_time": "2012-04-07T01:42:30Z", "text": "resetting P2 open bugs to P3 pending further review"}, {"attachment_id": null, "tags": [], "creator": "gadams@apache.org", "text": "change status from ASSIGNED to NEW for consistency", "count": 10, "id": 157906, "time": "2012-04-11T06:17:24Z", "bug_id": 46336, "creation_time": "2012-04-11T06:17:24Z", "is_private": false}]