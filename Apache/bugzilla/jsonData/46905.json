[{"count": 0, "attachment_id": 23411, "creator": "vhennebert@gmail.com", "is_private": false, "id": 125763, "time": "2009-03-24T08:49:41Z", "bug_id": 46905, "creation_time": "2009-03-24T08:49:41Z", "tags": [], "text": "Created attachment 23411\nStart of an implementation of keep.within-column\n\nAt the moment no distinction is made between keep.within-column and keep.within-page. I've started to hack support for keep.within-column into the Trunk but don't have time to finish the task. Posting my changes here as a patch so that anyone who's interested can take over the job.\n\nThe idea is to make use of the break class of KnuthPenalty (which then becomes a 'keep context'). A keep.within-page will lead to an infinite penalty of class Constants.EN_PAGE. When a break is being considered, the break class will hint at whether it is allowed or not. For example, if the break is not at the last column of the page and the break class is page, the break may be considered.\n\nAt some point the breaking algorithm will run out of nodes because of forbidden page breaks that make the content pile up on the last column of a page. When such a situation is detected, the whole content is deferred to the next page (if that hasn't been already done) and column breaking is re-started. The hope is that a new, blank page will provide enough space to make all the content fit on one page. If it's still not the case, then the page break prohibition will be relieved to allow the content to flow to the next page.\n\nCurrent limitations:\n* keeps have been implemented such that a keep.within-line implies a keep.within-column, which implies a keep.within-page. This is almost always true except if, for example, keep.within-page is set to always and keep.within-column to an integer value. The integer value from the column component will override the always value from the page component, possibly leading to an 'illegal' page break.\n* some javadoc must be updated\n* there are 10 failing test cases in the test suite\n* at the moment no warning is issued when the content is too big to fit on one page alone\n* in PageBreakingAlgorithm, the deferred and overridePageKeep fields need to be reset 'at the right moment'\n* the overridePageKeep mechanism should actually be completely removed; if there's too much content to fit on a page then the usual overflow mechanism should be used instead. I initially set it up because the algorithm was reverting to starting the content on the same page instead of a new blank page. This needs to be investigated\n* the new deferring mechanism clashes with fitRecoveryCounter; both should be merged somehow\n* the deferring mechanism may also conflict with regular node recovery (restarting from the last deactivated/too short/too long node when the number of active nodes falls to zero). See commented out code in BreakingAlgorithm. It's not clear yet what may happen when.\n* the use of break class from KnuthPenalty is very hacky and a new characteristic should probably be defined. Using an infinite penalty with a tweaked break class leads to too many changes at too many places. Maybe it can be done the other way round: use a zero penalty with break class properly set to indicate when this penalty must be considered as infinite (or infinite - 1). \n* at the moment penalties are discarded at page breaks until the end of the keep.within-column zone has been reached. At that point the content may already have been overflowing the last column for a long time. This might lead to performance issues."}, {"attachment_id": null, "tags": [], "bug_id": 46905, "text": "That is a real shame that you will not have time to finish this, certainly looks like really good useful work :).  It will not be easy, but I really hope someone will be able to pick it up where you left off.", "count": 1, "id": 125764, "time": "2009-03-24T09:03:02Z", "creator": "dev@cumiskey.com", "creation_time": "2009-03-24T09:03:02Z", "is_private": false}, {"count": 2, "tags": [], "creator": "adelmelle@apache.org", "is_private": false, "text": "In the meantime, applied the patch locally, and started to look into the failing tests.\n\nFirst observations:\n- Very good starting point: refactoring the keep-logic based on a Keep object in the layoutengine that correlates to the KeepProperty in the FO tree definitely makes things a lot easier to read. The only thing that does not look entirely right IMO, is the addition of the methods to the BlockLevelLM interface. I think we can safely push it up to the LayoutManager interface, since it may prove handy in the longer term to fully implement inline-keeps as well. It is not yet possible, IIC, to keep two fo:inlines together on the same line. I'd make it an 'optional' method, so add an UnsupportedOperationException to the method signature for cases like BlockStackingLayoutManager (using IllegalStateException in the patch)\n- I see only 9 failed tests here at first glance... Could be missing one (?)\n- Re: the remark about the hacky nature of using the break-class of KnuthPenalty: \nHow about creating a set of dedicated subclasses of KnuthPenalty (PageBreakPenalty, ColumnBreakPenalty...), rather than play with the base class member? That way, the parts of the code that use the base class can probably remain largely unaffected by the changes for now. Obviously, where necessary, we will then have to take care to instantiate the correct types of penalty, but it could ultimately lead to code that is easier to read\nThe class hierarchy could reflect the real relationship between the different break-opportunities: \na PageBreakPenalty is a ColumnBreakPenalty, which is a LineBreakPenalty, which is a special type of KnuthPenalty?\n\nOK, enough ranting, back to investigating the failing testcases.", "id": 126303, "time": "2009-04-16T13:42:31Z", "bug_id": 46905, "creation_time": "2009-04-16T13:42:31Z", "attachment_id": null}, {"count": 3, "tags": [], "text": "(In reply to comment #0)\n\n> * the deferring mechanism may also conflict with regular node recovery\n> (restarting from the last deactivated/too short/too long node when the number\n> of active nodes falls to zero). See commented out code in BreakingAlgorithm.\n> It's not clear yet what may happen when.\n\nNot sure if I interpret it entirely correctly, but the effects seemed to show in the (alphabetically) first failing testcase, where the algorithm chooses a layout with less lines, in spite of the fact that the last line is too long.\nSo, I naively tried uncommenting that bit, and that brings the number of failures down to 7. Is that expected?", "attachment_id": null, "id": 126306, "creation_time": "2009-04-16T14:08:24Z", "time": "2009-04-16T14:08:24Z", "creator": "adelmelle@apache.org", "bug_id": 46905, "is_private": false}, {"attachment_id": null, "tags": [], "bug_id": 46905, "is_private": false, "count": 4, "id": 126310, "time": "2009-04-16T15:55:11Z", "creator": "adelmelle@apache.org", "creation_time": "2009-04-16T15:55:11Z", "text": "(In reply to comment #0)\n> * keeps have been implemented such that a keep.within-line implies a\n> keep.within-column, which implies a keep.within-page. This is almost always\n> true except if, for example, keep.within-page is set to always and\n> keep.within-column to an integer value. The integer value from the column\n> component will override the always value from the page component, possibly\n> leading to an 'illegal' page break.\n\nAre you referring to case block_keep-with-next_integers_1 here?\n\nIf so, the most straightforward solution seems to be a change in the implementation of Keep.compare(). First check whether either keep is forced before doing the rest. \nIn the patch, BlockStackingLM.getKeepTogether() will return the parent's keep-together if it has a lower priority. That is definitely incorrect if the child's keep is forced.\n\nRoughly:\n\n        /* check forced keep first, regardless of priority */\n        if (strength == STRENGTH_ALWAYS) {\n            return this;\n        } else if (other.strength == STRENGTH_ALWAYS) {\n            return other;\n        }\n        \n        int pThis = getKeepContextPriority(this.context);\n        int pOther = getKeepContextPriority(other.context);\n\n        /* equal priority: strongest wins */\n        if (pThis == pOther) {\n            return (strength >= other.strength) ? this : other;\n        }\n\n        /* different priority: lowest priority wins \n          * (line wins over column wins over page)\n          */\n        return (pThis < pOther) ? this : other;\n\nwould make only 6 failing tests here (provided the two fixed by the uncommenting weren't a fluke)"}, {"count": 5, "attachment_id": null, "creator": "adelmelle@apache.org", "is_private": false, "id": 126312, "time": "2009-04-16T16:44:19Z", "bug_id": 46905, "creation_time": "2009-04-16T16:44:19Z", "tags": [], "text": "(In reply to comment #4)\n\nPrevious remark was not entirely correct, yet...\n\nFact remains: if the child's keep has a higher strength than the parent keep, it should win. If we have a keep.within-line=\"5\" and a nested keep.within-column=\"10\", the inner keep should 'win'. Following the changes in the patch, we would always get the line-context keep, and won't even consider the other. This is still so after the additional changes I proposed earlier.\n\nIf a line-context keep is specified on a node, a page-context keep, no matter how deeply nested, should still be honored if it is stronger. This is especially the case for forced keeps, but also for integers (see above). I read: keep the inline content together in a line, if possible. If it isn't possible, we may break into multiple lines (since the keep is not absolute), but still there is a higher preference for keeping at least part of the content together within a column. If we insert a line-break somewhere within that part, the break should preferably not be considered as a column-break."}, {"count": 6, "attachment_id": null, "creator": "adelmelle@apache.org", "text": "\nNext batch of 3 failing tests concerns the impact of the changes on the footnote-splitting mechanism. \nThe PageBreakingAlgorithm (PBA) no longer includes the first part on the first page. That is: the break after the line containing the footnote-citation for the footnote that should be split, is no longer considered to be a feasible break. \n\nTaking the first test footnote_changing-page-bpd-2.xml as reference case.\n\nIn the initial pass over the footnote list in PBA.computeDifference(), both PBA.checkCanDeferOldFootnotes() and PBA.newFootnotes evaluate to false, so we do not even try PBA.getFootnoteSplit() to see how many lines of the footnote fit on the first page.\nThe reason for newFootnotes being false (even though there are definitely footnotes):\nBreakingAlgorithm.findBreakingPoints() (line 463) will trigger handleBox() for the last line-box, which will trigger handleFootnotes(), which will set newFootnotes to true. Following that, we have a penalty, which will be considered as a legal break, but elementCanEndLine() returns false. PBA.considerLegalBreak() returns, sets newFootnotes to false, so that when we consider the next, finishing penalty, it will be as if there are no footnotes.\nSince the total of the body content and the entire footnote does not fit into one page, considerLegalBreak() deactivates the node, and the algorithm restarts from that position further on.", "id": 126370, "time": "2009-04-19T15:17:19Z", "bug_id": 46905, "creation_time": "2009-04-19T15:17:19Z", "tags": [], "is_private": false}, {"count": 7, "attachment_id": null, "creator": "vhennebert@gmail.com", "text": "(In reply to comment #3)\n> (In reply to comment #0)\n> \n> > * the deferring mechanism may also conflict with regular node recovery\n> > (restarting from the last deactivated/too short/too long node when the number\n> > of active nodes falls to zero). See commented out code in BreakingAlgorithm.\n> > It's not clear yet what may happen when.\n> \n> Not sure if I interpret it entirely correctly, but the effects seemed to show\n> in the (alphabetically) first failing testcase, where the algorithm chooses a\n> layout with less lines, in spite of the fact that the last line is too long.\n> So, I naively tried uncommenting that bit, and that brings the number of\n> failures down to 7. Is that expected?\n\n(Sorry for the delay.)\n\nI had to comment that part because it was preventing the PageBreakingAlgorithm.recoverFromTooLong method from properly working. Instead of taking as lastTooLong the node that overflows the second column because of page-unbreakable content, it would take the node that overflowed the first column, and that was deactivated following the normal process of the algorithm. That doesn't mean that the first column can't be laid out, just that starting from that node no content could be squeezed into the first column any more. That piece of code needs to be re-enabled and collaborate nicely with recoverFromTooLong.", "id": 126491, "time": "2009-04-24T08:43:40Z", "bug_id": 46905, "creation_time": "2009-04-24T08:43:40Z", "tags": [], "is_private": false}, {"attachment_id": null, "tags": [], "bug_id": 46905, "text": "(In reply to comment #7)\n> (Sorry for the delay.)\n\n(Me too ;-))\n\n> \n> I had to comment that part because it was preventing the\n> PageBreakingAlgorithm.recoverFromTooLong method from properly working. Instead\n> of taking as lastTooLong the node that overflows the second column because of\n> page-unbreakable content, it would take the node that overflowed the first\n> column, and that was deactivated following the normal process of the algorithm.\n> That doesn't mean that the first column can't be laid out, just that starting\n> from that node no content could be squeezed into the first column any more.\n> That piece of code needs to be re-enabled and collaborate nicely with\n> recoverFromTooLong.\n\nSo.. the implementation, without comments, uses the last deactivated node as lastTooLong, but since the (Page)BreakingAlgorithm is actually not breaking pages but columns, this turns out to be the last deactivated column-break node, instead of a page-break node.\n\nMaybe it's a matter of checking the node, before deactivating. IOW: never deactivate column-breaks, so the algorithm always restarts from the last page-break (?)\nThen again, this could get messy, given that changes in BreakingAlgorithm also influence line-breaking, where the distinction is irrelevant. \nThe cleanest solution is probably to override compareNodes() in PageBreakingAlgorithm, so it always returns the last true page-break, rather than the last (plain) break. The default implementation in BreakingAlgorithm simply returns the break with the last position (or the one yielding the best demerits in case of equal position). If overridden, the later break can then be deactivated, but not stored as lastDeactivatedNode.", "count": 8, "id": 126745, "time": "2009-05-03T14:45:03Z", "creator": "adelmelle@apache.org", "creation_time": "2009-05-03T14:45:03Z", "is_private": false}, {"count": 9, "tags": [], "creator": "adelmelle@apache.org", "text": "(OK, finally back in shape to continue working on this, and some progress in the meantime...)\n\nRe: the issue with the failing footnote tests\n\nI have found the cause for those failures. There seems to be a logic error in the subtle change in BreakingAlgorithm.findBreakingPoints(), where penalties are handled: after the change, a penalty is considered as a legal break if the penalty value is lower than INFINITE or it is not of class EN_LINE. \nThis is wrong. Regardless of the break class, a penalty with that value is *never* to be considered as a legal break.\n\nRemoving that part of the condition makes the failing footnote tests pass. I'm just a bit uncertain what the precise motivation was to add that one... so I hope I'm not missing anything here.", "id": 127487, "time": "2009-05-28T13:04:08Z", "bug_id": 46905, "creation_time": "2009-05-28T13:04:08Z", "is_private": false, "attachment_id": null}, {"count": 10, "tags": [], "creator": "adelmelle@apache.org", "attachment_id": null, "text": "(OK, finally back in shape to continue working on this, and some progress in the meantime...)\n\nRe: the issue with the failing footnote tests\n\nI have found the cause for those failures. There seems to be a logic error in the subtle change in BreakingAlgorithm.findBreakingPoints(), where penalties are handled: after the change, a penalty is considered as a legal break if the penalty value is lower than INFINITE or it is not of class EN_LINE. \nThis is wrong. Regardless of the break class, a penalty with that value is *never* to be considered as a legal break.\n\nRemoving that part of the condition makes the failing footnote tests pass. I'm just a bit uncertain what the precise motivation was to add that one... so I hope I'm not missing anything here.", "id": 127488, "time": "2009-05-28T13:04:10Z", "bug_id": 46905, "creation_time": "2009-05-28T13:04:10Z", "is_private": false}, {"count": 11, "tags": [], "bug_id": 46905, "text": "Next failing test was inline_block_nested_6. I have investigated that closer, and after the changes the global element list on the one hand contains more elements than before. On the other hand, the penalties appear earlier in the list. I still have to check whether this has undesired consequences, but it seems like the produced output is identical. This may be a case of having to adapt the testcase, and change the expected results.", "id": 127491, "time": "2009-05-29T00:40:15Z", "creator": "adelmelle@apache.org", "creation_time": "2009-05-29T00:40:15Z", "is_private": false, "attachment_id": null}, {"count": 12, "tags": [], "creator": "adelmelle@apache.org", "attachment_id": null, "is_private": false, "id": 127498, "time": "2009-05-29T08:19:24Z", "bug_id": 46905, "creation_time": "2009-05-29T08:19:24Z", "text": "Remaining failing testcases are related to tables. \nFor table-row_keep-together.xml, the reason is that, before the changes in the patch, we generated one consolidated box for 2 lines (due to the keep). After the changes, we generate two boxes, plus a penalty with break-class EN_PAGE to allow the row to break over multiple columns.\n\nSimilar thing happens for table_keep-together.xml.\n\nStill two hyphenation testcases to look at..."}, {"count": 13, "tags": [], "creator": "vhennebert@gmail.com", "text": "Hi Andreas,\n\n(In reply to comment #10)\n> (OK, finally back in shape to continue working on this, and some progress in\n> the meantime...)\n> \n> Re: the issue with the failing footnote tests\n> \n> I have found the cause for those failures. There seems to be a logic error in\n> the subtle change in BreakingAlgorithm.findBreakingPoints(), where penalties\n> are handled: after the change, a penalty is considered as a legal break if the\n> penalty value is lower than INFINITE or it is not of class EN_LINE. \n> This is wrong. Regardless of the break class, a penalty with that value is\n> *never* to be considered as a legal break.\n> \n> Removing that part of the condition makes the failing footnote tests pass. I'm\n> just a bit uncertain what the precise motivation was to add that one... so I\n> hope I'm not missing anything here.\n\nThe idea was that a penalty of value infinite and class EN_PAGE become a penalty of value 0 when considering a column break. Like I said in my first comment this is very hacky and needs to be improved. All the more than the actual value may not always be zero (e.g. when breaking the column at a hyphenated word).\n\nVincent", "id": 127499, "time": "2009-05-29T10:22:14Z", "bug_id": 46905, "creation_time": "2009-05-29T10:22:14Z", "is_private": false, "attachment_id": null}, {"count": 14, "tags": [], "text": "(In reply to comment #13)\n\nHi Vincent,\n\n> The idea was that a penalty of value infinite and class EN_PAGE become a\n> penalty of value 0 when considering a column break.\n\nAaah... of course, now I get it.\n\nThe general idea is obviously:\nkeep-*.within-line => infinite penalty of class EN_LINE, should result in the break never being considered as a legal break.\nkeep-*.within-column => infinite penalty of class EN_COLUMN, should result in the break being considered as a legal line-break, but not a page- or column-break\nkeep-*.within-page => infinite penalty of class EN_PAGE, should result in the break being considered as line- or column-break, but not as a page-break\n\n> Like I said in my first comment this is very hacky and needs to be improved. \n> All the more than the actual value may not always be zero (e.g. when breaking the \n> column at a hyphenated word).\n\nIndeed. On top of that, there are the 'terminating' sequences of penalty-glue-penalty that we use for the filler space after the last break. Since the breakClass for the first penalty in that sequence remains unset (= -1), it is also considered as a legal break (getBreakClass() != EN_LINE), while it is precisely meant to prevent any break before the filler glue.", "is_private": false, "bug_id": 46905, "id": 127502, "time": "2009-05-29T12:05:18Z", "creator": "adelmelle@apache.org", "creation_time": "2009-05-29T12:05:18Z", "attachment_id": null}, {"attachment_id": null, "tags": [], "bug_id": 46905, "is_private": false, "count": 15, "id": 127526, "time": "2009-05-31T09:10:18Z", "creator": "adelmelle@apache.org", "creation_time": "2009-05-31T09:10:18Z", "text": "(In reply to comment #12)\n> Still two hyphenation testcases to look at...\n\nSpent quite some time today trying to figure out what was causing those to fail. Turned out to have nothing to do with the patch, but with other unrelated changes I had made locally... :/\n\nI have addressed the change mentioned in comment #10 by adding a check for a break-class of -1 to the condition, so such penalties are no more considered as a legal break.\n\nNow that all tests pass, all that's left is to start some improvements and add the testcases. For the moment, the improvements can be kept down to a minimum, since with some minor modifications, it seems to be working nicely already. The only case that is still not correctly processed is the one mentioned in the beginning (see description mentioned by Vincent): if we have a block with keep-together.within-column=\"5\" and a nested block with keep-together.within-page=\"10\", the inner block is still split over multiple pages. Maybe, this situation is solvable by adding 'hinting' penalties (with negative values) before the inner block, which would make a page-break before or after better than a break inside that block. Remains to be seen whether this will work as expected, as I remember a test Luca Furini did once, where he demonstrated that the effect of the penalties' values is marginal on the total demerits, unless the difference is big enough (?)\n\nMore later."}, {"count": 16, "tags": [], "creator": "vhennebert@gmail.com", "attachment_id": null, "is_private": false, "id": 127546, "time": "2009-06-02T02:49:14Z", "bug_id": 46905, "creation_time": "2009-06-02T02:49:14Z", "text": "(In reply to comment #15)\n> (In reply to comment #12)\n> > Still two hyphenation testcases to look at...\n> \n> Spent quite some time today trying to figure out what was causing those to\n> fail. Turned out to have nothing to do with the patch, but with other unrelated\n> changes I had made locally... :/\n> \n> I have addressed the change mentioned in comment #10 by adding a check for a\n> break-class of -1 to the condition, so such penalties are no more considered as\n> a legal break.\n> \n> Now that all tests pass, all that's left is to start some improvements and add\n> the testcases. For the moment, the improvements can be kept down to a minimum,\n> since with some minor modifications, it seems to be working nicely already. The\n> only case that is still not correctly processed is the one mentioned in the\n> beginning (see description mentioned by Vincent): if we have a block with\n> keep-together.within-column=\"5\" and a nested block with\n> keep-together.within-page=\"10\", the inner block is still split over multiple\n> pages. Maybe, this situation is solvable by adding 'hinting' penalties (with\n> negative values) before the inner block, which would make a page-break before\n> or after better than a break inside that block. Remains to be seen whether this\n> will work as expected, as I remember a test Luca Furini did once, where he\n> demonstrated that the effect of the penalties' values is marginal on the total\n> demerits, unless the difference is big enough (?)\n\nThis won't work. If keep-together.within-column=\"1\" and keep-together.within-page=\"always\" then a break must be completely forbidden at a page. Hinting penalties won't prevent that in every case, for example if the only feasible page break is at such a place. In that situation the node recovery mechanism must be launched, and an earlier too-short/long node selected.\n\nVincent"}, {"count": 17, "tags": [], "creator": "adelmelle@apache.org", "text": "(In reply to comment #16)\n> This won't work. If keep-together.within-column=\"1\" and\n> keep-together.within-page=\"always\" then a break must be completely forbidden at\n> a page. Hinting penalties won't prevent that in every case, for example if the\n> only feasible page break is at such a place.\n\nOK, I thought so...\n\nI had this working for strength \"always\", with the modified implementation for Keep.compare() I suggested earlier (comment #4). Anyway, that case is easy. The more complicated case is keep-together.within-column=\"1\" and on a nested block .within-page=\"10\". Both column-breaks and page-breaks are allowed, but the page-breaks should preferably be made before/after the nested block. A page-break in the nested block would be permitted only if its content does not fit into one page.\n\n> In that situation the node recovery mechanism must be launched, \n> and an earlier too-short/long node selected.\n\nAs far as I can tell, we currently only remember the last deactivated node. As soon as we deactivate another node, either it will replace that one (if it produces better demerits) or it is just disregarded completely (after my modifications: if the deactivated node does not end a page, PBA.compareNodes() will return the preceding page-break, so that the column-break node is deactivated but not used as the point from which to restart later on).\n\nIf I interpret that remark correctly, then either we have to remember more deactivated nodes in order to be able to select an earlier one, or we should make sure (somehow?) that the nodes for the breaks before/after the nested block produce better demerits than those corresponding to page-breaks within that block...\n\nAnother question-mark: if the keep-constraints would lead to a break mid-column, would end-users expect column-balancing to be applied to the part before the page-break...? Currently not trivial to implement, if I judge correctly. I'll first see if I can get it working without column-balancing, and add this later.", "id": 127607, "time": "2009-06-03T11:59:59Z", "bug_id": 46905, "creation_time": "2009-06-03T11:59:59Z", "is_private": false, "attachment_id": null}, {"count": 18, "tags": [], "bug_id": 46905, "attachment_id": null, "id": 127624, "time": "2009-06-04T00:37:12Z", "creator": "bowditch_chris@hotmail.com", "creation_time": "2009-06-04T00:37:12Z", "is_private": false, "text": "(In reply to comment #17)\n> (In reply to comment #16)\n> > This won't work. If keep-together.within-column=\"1\" and\n> > keep-together.within-page=\"always\" then a break must be completely forbidden at\n> > a page. Hinting penalties won't prevent that in every case, for example if the\n> > only feasible page break is at such a place.\n> OK, I thought so...\n> I had this working for strength \"always\", with the modified implementation for\n> Keep.compare() I suggested earlier (comment #4). Anyway, that case is easy. The\n> more complicated case is keep-together.within-column=\"1\" and on a nested block\n> .within-page=\"10\". Both column-breaks and page-breaks are allowed, but the\n> page-breaks should preferably be made before/after the nested block. A\n> page-break in the nested block would be permitted only if its content does not\n> fit into one page.\n\nI think it is an acceptable limitation that keep-*.within-column works only for \"always\" It is already a big improvement on the current situation where this is treated as keep-*.within-page.\n\n<snip/>"}, {"count": 19, "tags": [], "bug_id": 46905, "attachment_id": 23799, "id": 127897, "time": "2009-06-11T11:20:41Z", "creator": "adelmelle@apache.org", "creation_time": "2009-06-11T11:20:41Z", "is_private": false, "text": "Created attachment 23799\nsample file; basis for a simple testcase\n\nI have been running some more tests with the attached sample file, relatively simple.\n\nSo far, all seems to work as expected --as long as there are only 2 columns.\nAs soon as I increase it to 3 or more, the algorithm picks the wrong node somehow... currently looking into that.\n\nI will post the changed patch, and attach PDF results for reference shortly."}, {"attachment_id": null, "tags": [], "bug_id": 46905, "is_private": false, "count": 20, "id": 127898, "time": "2009-06-11T11:35:28Z", "creator": "adelmelle@apache.org", "creation_time": "2009-06-11T11:35:28Z", "text": "(In reply to comment #19)\n> Created an attachment (id=23799) [details]\n> So far, all seems to work as expected --as long as there are only 2 columns.\n> As soon as I increase it to 3 or more, the algorithm picks the wrong node\n> somehow... currently looking into that.\n\nA hunch right after posting this, checked PageBreakingAlgorithm.recoverFromTooLong(), and thought I'd change the first while-loop to:\n\nwhile (!pageProvider.startPage(lastTooLong.line))\n\ni.e. do not subtract 1 from the line-number\n\nNow, it already works for three columns, but crashes on four... :-(\n\nSeems to be pointing to an issue when having to restart from the first node (whose previous node is null)"}, {"count": 21, "attachment_id": 23800, "creator": "adelmelle@apache.org", "is_private": false, "id": 127901, "time": "2009-06-11T13:05:29Z", "bug_id": 46905, "creation_time": "2009-06-11T13:05:29Z", "tags": [], "text": "Created attachment 23800\nResult w/ 2columns"}, {"attachment_id": 23801, "tags": [], "bug_id": 46905, "text": "Created attachment 23801\nResult w/ 3 columns", "count": 22, "id": 127902, "time": "2009-06-11T13:06:12Z", "creator": "adelmelle@apache.org", "creation_time": "2009-06-11T13:06:12Z", "is_private": false}, {"count": 23, "tags": [], "creator": "adelmelle@apache.org", "attachment_id": 23802, "is_private": false, "id": 127903, "time": "2009-06-11T13:11:11Z", "bug_id": 46905, "creation_time": "2009-06-11T13:11:11Z", "text": "Created attachment 23802\nResult w/ 4 columns\n\nComparing this to the 3-column version, I shortened block-2 in the example to fit in one column, and then there's no interference/confusion with the normal recovery mechanism."}, {"count": 24, "tags": [], "creator": "adelmelle@apache.org", "is_private": false, "text": "(In reply to comment #20)\n> A hunch right after posting this, checked\n> PageBreakingAlgorithm.recoverFromTooLong(), and thought I'd change the first\n> while-loop to:\n> \n> while (!pageProvider.startPage(lastTooLong.line))\n> \n> i.e. do not subtract 1 from the line-number\n\nUndid this change, for the moment, since it causes more trouble than it solves.\n\nWhile debugging further, I notice it is indeed a problem when the algorithm 5-restarts from the first node.\nApparently, restarting from that first node (way too-short) triggers area-addition for the first line on the first page, then we get an effective page-break, and the rest is rendered as it would otherwise be rendered.\n\nStill looking closer at the trace-logs to try and make sense of it...\n\nMaybe a somewhat exceptional case, but I'd still like to see if I can fix that one before publishing the patch.", "id": 127915, "time": "2009-06-12T07:05:47Z", "bug_id": 46905, "creation_time": "2009-06-12T07:05:47Z", "attachment_id": null}, {"count": 25, "tags": [], "text": "\nSome more progress: the undesired behavior is also eliminated in case all of the columns of the first page are occupied.\nTrying to explain this a bit better, if you look at the sample result with 3 columns, the behavior is triggered because the block with id 'block-1' occupies only 1 column and a part. If we make it 2 columns plus some more, the following block is correctly moved to the next page, where it overflows the first column. In the current state, the column-break nodes will be deactivated, but priority will be given to the first page-break, which is the one that is remembered as the restart point. Strictly speaking not incorrect, but PBA.recoverFromTooLong() creates a node that turns an illegal break (in between two boxes, always to be kept together due to widows/orphans) into a feasible one. Then it appends a few more for the column-break nodes. Commenting out the specialized recoverFromTooLong(), it works neatly for the first case, but still produces incorrect results for the third case (integer keep.within-column with nested forced keep.within-page).", "attachment_id": null, "id": 127917, "creation_time": "2009-06-12T08:02:52Z", "time": "2009-06-12T08:02:52Z", "creator": "adelmelle@apache.org", "bug_id": 46905, "is_private": false}, {"count": 26, "tags": [], "text": "\nClosing in on completing this one. A real challenge, I must say... Just writing out some observations, as it generally helps me get closer to the solution (even if nobody replies ;-))\n\nDiving deeper and deeper into the layout-loop: from the point of view of the page-breaking, the code in BreakingAlgorithm is really, really misleading. considerLegalBreak() contains a loop, but in practice, the body of the outer for-loop is always executed only once. There's a number of those hidden throughout the codebase, IIRC: judging purely from the code, you can hardly keep track of the nesting. When debugging the same code, you suddenly realize that those are all pseudo loops...\nThe difference between startLine and endLine is always exactly one. \nThe basic process seems to be: \n- try adding another line, \n- compute adjustment ratio/difference/demerits, and \n- if the line does not fit, recover by considering the lastTooShort node as the definitive break.\n\nDoes not really sound so 'total-fit' to me. Earlier breaks are never revisited. For the duration of the main loop in findBreakingPoints(), there is always at most one node active. If the last node is too long, it is removed and the recovery mechanism comes into play.\n\nWhat it means in terms of page-keeps nested in column-keeps, is that the node corresponding to the break before the keep-context switch will have been discarded, since it was too-short. There is no way to get that node back, apart from going back to the first preceding penalty in a different keep-context and recreating it. Either that or...\nUsing some additional overrides in PageBreakingAlgorithm to keep track of the keep-context and remember that node brought me very close to a solution, but it still causes unwanted side-effects in other cases.", "attachment_id": null, "id": 128157, "creation_time": "2009-06-22T13:30:03Z", "time": "2009-06-22T13:30:03Z", "creator": "adelmelle@apache.org", "bug_id": 46905, "is_private": false}, {"count": 27, "tags": [], "creator": "adelmelle@apache.org", "attachment_id": 23863, "text": "Created attachment 23863\nsample testcase\n\n\nModified the sample file into a full testcase, checking the simplest cases and some combinations of keep-together with keep-with-previous or -with-next.\n\nCurrently, in my sandbox, the test passes, but the changes still break a few other tests, so first have to find out why exactly...\n\nTogether with this change, I also did quite a bit of restructuring in BreakingAlgorithm, with the benefit of giving subclasses multiple hooks to insert overrides and reducing the 'main loop' in findBreakingPoints() to fit on one screen...", "id": 128220, "time": "2009-06-24T00:33:46Z", "bug_id": 46905, "creation_time": "2009-06-24T00:33:46Z", "is_private": false}, {"count": 28, "tags": [], "creator": "adelmelle@apache.org", "text": "Created attachment 23864\nsample PDF result for the testcase (5 columns)", "id": 128221, "time": "2009-06-24T00:41:33Z", "bug_id": 46905, "creation_time": "2009-06-24T00:41:33Z", "is_private": false, "attachment_id": 23864}, {"attachment_id": 23865, "tags": [], "bug_id": 46905, "is_private": false, "count": 29, "id": 128222, "time": "2009-06-24T01:13:04Z", "creator": "adelmelle@apache.org", "creation_time": "2009-06-24T01:13:04Z", "text": "Created attachment 23865\ndiff of the changes, so far...\n\nAs indicated earlier, the changes in the patch still cause some issues with around 20 testcases. Just thought I'd post it for review to see if everyone is OK with some of the refactoring.\n\nBasically, the most important changes in that respect are localized in BreakingAlgorithm, where I extracted some of the code blocks in the main loop in findBreakingPoints() into protected methods, offering hooks for subclasses to inject custom behavior. An implementation may choose to treat penalties differently than the basic algorithm does; the implementation of handlePenaltyAt() in PageBreakingAlgorithm can serve as an example.\n\nChange with respect to the previous patch: PageBreakingAlgorithm keeps track of the current keep-context, and the last too-short node before the context changed. If the keep-context is not AUTO, then PBA will restart from that too-short node, instead of using the superclass' implementation of recoverFromTooLong(). Then we add nodes after that node, until all the columns in that page are occupied. Since we do not yet implement changing IPD (hence no change in column-count), I have explicitly chosen to defer only the overflowing part to the next page, for the sake of simplicity. The silent assumption is that the next page will have the same number of columns, so deferring the first part as well is pointless... Best case showing that effect is block-4 in the sample: we only defer the content of the block that must be kept within one-page (starting with \"[BOB-4a] ...\")."}, {"count": 30, "tags": [], "bug_id": 46905, "text": "Created attachment 23886\nsample PDF result showing a remaining issue\n\nFurther testing and digging revealed that the last attached FO/PDF sample contains a fluke... \nIf I lengthen the nested block-4a so that it causes a page-level overflow, none of the breaks in the last column will be considered/registered as feasible (page-)breaks. As a consequence, the next restart is triggered from the last column-break. An additional node is inserted to fill the last column, and the remainder is pushed to the next page, while it should actually just overflow the column/page. Since the last part is also run through the column-balancing algorithm, I end up with suboptimal break-decisions...\n\nFor the rest, in the meantime, I have made a few more modifications to the last patch, so am now down to four failing testcases (five, when including the above). Will post an updated patch later today.", "id": 128302, "time": "2009-06-26T01:25:44Z", "creator": "adelmelle@apache.org", "creation_time": "2009-06-26T01:25:44Z", "is_private": false, "attachment_id": 23886}, {"count": 31, "tags": [], "text": "Hi Andreas,\n\n(In reply to comment #29)\n> Created an attachment (id=23865) [details]\n> diff of the changes, so far...\n> \n> As indicated earlier, the changes in the patch still cause some issues with\n> around 20 testcases. Just thought I'd post it for review to see if everyone is\n> OK with some of the refactoring.\n> \n> Basically, the most important changes in that respect are localized in\n> BreakingAlgorithm, where I extracted some of the code blocks in the main loop\n> in findBreakingPoints() into protected methods, offering hooks for subclasses\n> to inject custom behavior. An implementation may choose to treat penalties\n> differently than the basic algorithm does; the implementation of\n> handlePenaltyAt() in PageBreakingAlgorithm can serve as an example.\n> \n> Change with respect to the previous patch: PageBreakingAlgorithm keeps track of\n> the current keep-context, and the last too-short node before the context\n> changed. If the keep-context is not AUTO, then PBA will restart from that\n> too-short node, instead of using the superclass' implementation of\n> recoverFromTooLong(). Then we add nodes after that node, until all the columns\n> in that page are occupied. Since we do not yet implement changing IPD (hence no\n> change in column-count), I have explicitly chosen to defer only the overflowing\n> part to the next page, for the sake of simplicity. The silent assumption is\n> that the next page will have the same number of columns, so deferring the first\n> part as well is pointless... Best case showing that effect is block-4 in the\n> sample: we only defer the content of the block that must be kept within\n> one-page (starting with \"[BOB-4a] ...\").\n\nI've had a quick look at your patch. I have 2 small comments:\n- there are two compilation errors: one in KnuthPenalty about an unknown PENALTY_TYPE constant, one in PageBreaker, l.421, trying to convert a List into a LinkedList (that one is easily fixed).\n- I think you can commit the changes that are clean-up 'only' right now. They are improving the code readability quite a bit.\n\nAnd a bit of nit-picking:\n- in BlockStackingLM: in the getKeep*Property methods, I chose to throw IllegalStateExceptions because the only LMs that don't override those methods are LMs to which keeps don't apply. So calling those methods on such LMs is a genuine programming mistake, and not a TODONotYetImplementedException.\n- there's no reason to make the PageBreakingAlgorithm class public\n- in PageBreakingAlgorithm.createFootnotePages: tmpLength can be declared inside the while loop\n- I see you changed the 'while (iter.hasNext())' loops into 'for (Iterator iter = list.iterator(); iter.hasNext();)' and... I just wanted to say that it's great ;-)\n\nI'll try to have a look at the bigger changes in [Page]BreakingAlgorithm later on.\n\nThanks,\nVincent", "is_private": false, "bug_id": 46905, "id": 128329, "time": "2009-06-26T11:22:22Z", "creator": "vhennebert@gmail.com", "creation_time": "2009-06-26T11:22:22Z", "attachment_id": null}, {"count": 32, "tags": [], "creator": "adelmelle@apache.org", "is_private": false, "text": "(In reply to comment #31)\n\nHi Vincent,\n\n> I've had a quick look at your patch. I have 2 small comments:\n> - there are two compilation errors: one in KnuthPenalty about an unknown\n> PENALTY_TYPE constant, one in PageBreaker, l.421, trying to convert a List into\n> a LinkedList (that one is easily fixed).\n\nHmm, sorry about those... The missing constant was an experiment of mine, to see if we could follow a similar approach as for FONode here. Instead of the fixed isBox(), isGlue() and isPenalty(), we would get something like getElementType() and isElementType(int). Undid this change for the moment, but it seems I forgot to clean up after that. The change would only make sense if we would consider adding new types of elements. In that case, we probably won't want to change KnuthElement every time to add yet another isXXX() method.\nThe latter one I noticed earlier today, too. It was a more general change: if we do not need the LinkedList functionality, we can just as well use the List interface.\n\n> - I think you can commit the changes that are clean-up 'only' right now. They\n> are improving the code readability quite a bit.\n\nGood! That's the intention. Just making sure that future contributors will spend less time trying to understand the code. The goal is to make it (almost) readable by a child. ;-)\n\n> And a bit of nit-picking:\n> - in BlockStackingLM: in the getKeep*Property methods, I chose to throw\n> IllegalStateExceptions because the only LMs that don't override those methods\n> are LMs to which keeps don't apply. So calling those methods on such LMs is a\n> genuine programming mistake, and not a TODONotYetImplementedException.\n\nInitially, I had pushed the getKeep*Property() method up to the LayoutManager interface, and wanted to use a similar pattern as some standard Java interfaces. The subclass can choose to implement it, but if it does not, it is allowed to signal this with an UnsupportedOperationException. It would indeed be a mistake, just like it is a mistake to call remove() on an arbitrary Iterator, because remove() is an optional operation. A concrete iterator is not obliged to implement it, and if it doesn't, it should throw an exception. Whether it's an IllegalStateException or an UnsupportedOperationException is really all the same to me. Both are unchecked runtime exceptions. Just found the latter more appropriate...\n\n> - there's no reason to make the PageBreakingAlgorithm class public\n\nGood catch! A reminder for me to try to get around to finishing the fo:inline-container implementation. The origin of that change is that an InlineContainerBreaker would need to have access to the PBA, from within the layoutmgr.inline package.\n\n> - in PageBreakingAlgorithm.createFootnotePages: tmpLength can be declared\n> inside the while loop\n\nNo idea whether it's still relevant, but I always tend to avoid stuff like:\n\nwhile (someCondition) {\n  int intVar = intValue;\n  ...\n}\n\nInstead, use:\n\nint intVar = -1;\nwhile (someCondition) {\n  intVar = intValue;\n  ...\n}\n\nwhich, I guess, is almost equivalent to:\n\nwhile (someCondition) {\n  final int intVar = intValue;\n  ...\n}\n\napart from the fact that the variable is available outside of the loop.\nIOW: loop only the assignment, not the declaration. There really is no reason to declare (=allocate space for) a new variable on every iteration. Maybe using the final modifier would work here too, since we don't need the variable scoped outside of the loop...\n\n> - I see you changed the 'while (iter.hasNext())' loops into 'for (Iterator iter\n> = list.iterator(); iter.hasNext();)' and... I just wanted to say that it's\n> great ;-)\n\nCool! :-)\n\n> \n> I'll try to have a look at the bigger changes in [Page]BreakingAlgorithm later\n> on.\n\nOK, thanks for the feedback so far!\n\nAndreas", "id": 128331, "time": "2009-06-26T12:40:51Z", "bug_id": 46905, "creation_time": "2009-06-26T12:40:51Z", "attachment_id": null}, {"count": 33, "attachment_id": 23916, "creator": "adelmelle@apache.org", "is_private": false, "id": 128456, "time": "2009-07-01T07:52:21Z", "bug_id": 46905, "creation_time": "2009-07-01T07:52:21Z", "tags": [], "text": "Created attachment 23916\nupdated patch (minus the already committed cleanups)\n\nUpdated patch, as mentioned, without the cleanups already committed in r790142 and r790166.\n\nCurrently, down to one failing testcase (but that's actually two, when taking into account that the added testcase keep_within-column_basic.xml will fail if we make the nested block 4-a overflow the page)."}, {"count": 34, "tags": [], "text": "OK, /almost/ there. All existing testcases pass now. The cause of the last failed testcase (region-body_column-count_3.xml), had something to do with PageBreaker.handleBreakTrait(). \nSince the keep-implementation causes generation of KnuthPenalty elements with a break-class \"auto\", it is now possible for the condition at line 474 to evaluate to true, but then further on, on line 483 the breakVal is not -1 as it used to be, so the check returns false and we generate a new flow for the second column, instead of a whole new page.\n\nWill post the updated patch asap.\n\nAfterwards, I think we may just as well go ahead and commit. After all, the failing added test is not a very common use-case, and could, for the moment, be noted as a known limitation.", "attachment_id": null, "id": 128491, "creation_time": "2009-07-03T12:51:41Z", "time": "2009-07-03T12:51:41Z", "creator": "adelmelle@apache.org", "bug_id": 46905, "is_private": false}, {"attachment_id": null, "tags": [], "bug_id": 46905, "text": "Hi Andreas,\n\n(In reply to comment #32)\n> (In reply to comment #31)\n> \n> Hi Vincent,\n> \n<snip/>\n> > And a bit of nit-picking:\n> > - in BlockStackingLM: in the getKeep*Property methods, I chose to throw\n> > IllegalStateExceptions because the only LMs that don't override those methods\n> > are LMs to which keeps don't apply. So calling those methods on such LMs is a\n> > genuine programming mistake, and not a TODONotYetImplementedException.\n> \n> Initially, I had pushed the getKeep*Property() method up to the LayoutManager\n> interface, and wanted to use a similar pattern as some standard Java\n> interfaces. The subclass can choose to implement it, but if it does not, it is\n> allowed to signal this with an UnsupportedOperationException. It would indeed\n> be a mistake, just like it is a mistake to call remove() on an arbitrary\n> Iterator, because remove() is an optional operation. A concrete iterator is not\n> obliged to implement it, and if it doesn't, it should throw an exception.\n> Whether it's an IllegalStateException or an UnsupportedOperationException is\n> really all the same to me. Both are unchecked runtime exceptions. Just found\n> the latter more appropriate...\n\nThat's two different things. remove() is semantically correct on an Iterator; the fact that some iterators don't support it really is an implementation limitation, and UnsupportedOperationException is applicable here. In the case of LayoutManager, getKeep*Property shouldn't even be defined in that interface, since not all descendants accept keep properties. For example, keeps make no sense on an fo:static-content element. Calling the keep methods on its corresponding StaticContentLayoutManager therefore is an error in the logic, not an implementation limitation issue.\n\nActually, those methods shouldn't even be declared on those layout managers for which they are not applicable. That way it wouldn't even be possible to make a logic error. Unfortunately that implies changes in the class hierarchy that are beyond the scope of this patch.\n\n\n<snip/>\n> > - in PageBreakingAlgorithm.createFootnotePages: tmpLength can be declared\n> > inside the while loop\n> \n> No idea whether it's still relevant, but I always tend to avoid stuff like:\n> \n> while (someCondition) {\n>   int intVar = intValue;\n>   ...\n> }\n> \n> Instead, use:\n> \n> int intVar = -1;\n> while (someCondition) {\n>   intVar = intValue;\n>   ...\n> }\n> \n> which, I guess, is almost equivalent to:\n> \n> while (someCondition) {\n>   final int intVar = intValue;\n>   ...\n> }\n> \n> apart from the fact that the variable is available outside of the loop.\n> IOW: loop only the assignment, not the declaration. There really is no reason\n> to declare (=allocate space for) a new variable on every iteration. Maybe using\n> the final modifier would work here too, since we don't need the variable scoped\n> outside of the loop...\n\nThe 'declaration' only applies at compilation time, and is used to perform type checking. At runtime there is no space allocated whatsoever. A value is simply pushed onto the operand stack [1]. Actually, declaring the variable outside the loop results into more boilerplate bytecode, so technically is less efficient (although very probably unnoticeable). OTOH, declaring the variable inside the loop is cleaner and safer (no risk to mistakenly use it outside the loop).\n\n[1] http://java.sun.com/docs/books/jvms/second_edition/html/Overview.doc.html#28851\n\n\n<snip/>\n\nVincent", "count": 35, "id": 128585, "time": "2009-07-07T04:31:23Z", "creator": "vhennebert@gmail.com", "creation_time": "2009-07-07T04:31:23Z", "is_private": false}, {"count": 36, "tags": [], "creator": "adelmelle@apache.org", "text": "(In reply to comment #35)\n> <snip/>\n> > Whether it's an IllegalStateException or an UnsupportedOperationException is\n> > really all the same to me. Both are unchecked runtime exceptions. Just found\n> > the latter more appropriate...\n> \n> That's two different things. remove() is semantically correct on an Iterator;\n> the fact that some iterators don't support it really is an implementation\n> limitation, and UnsupportedOperationException is applicable here. \n\nI don't see the difference. Seems to be in your head... :-)\n\n> \n> The 'declaration' only applies at compilation time, and is used to perform type\n> checking. At runtime there is no space allocated whatsoever. \n\nOK, good to know. I'll go for the declaration inside the loop, with the final modifier.", "id": 128590, "time": "2009-07-07T06:42:53Z", "bug_id": 46905, "creation_time": "2009-07-07T06:42:53Z", "is_private": false, "attachment_id": null}, {"attachment_id": null, "tags": [], "bug_id": 46905, "text": "(In reply to comment #36)\n> > <snip/>\n> > > Whether it's an IllegalStateException or an UnsupportedOperationException is\n> > > really all the same to me. Both are unchecked runtime exceptions. Just found\n> > > the latter more appropriate...\n> > \n> > That's two different things. remove() is semantically correct on an Iterator;\n> > the fact that some iterators don't support it really is an implementation\n> > limitation, and UnsupportedOperationException is applicable here. \n> \n> I don't see the difference. Seems to be in your head... :-)\n\nThought about it some more, and the above argument is moot. An UnsupportedOperationException does not necessarily mean that it is a limitation, in the sense that the implementation is not complete. For some iterators, for example one over a list returned by Collections.unmodifiableList(), it is an error if it implements the remove() operation.", "count": 37, "id": 128595, "time": "2009-07-07T08:28:19Z", "creator": "adelmelle@apache.org", "creation_time": "2009-07-07T08:28:19Z", "is_private": false}, {"attachment_id": 23990, "tags": [], "bug_id": 46905, "is_private": false, "count": 38, "id": 128891, "time": "2009-07-15T15:19:07Z", "creator": "adelmelle@apache.org", "creation_time": "2009-07-15T15:19:07Z", "text": "Created attachment 23990\nYet another update\n\n\nHad hoped to get to this sooner, but it seems that at some point when getting the existing testcases to succeed, I made a change that, again screwed up the nested column/page keep test in the attachment. Took me a while to track it down.\n\nThe way the algorithm operates, after the changes in the previous patch, is that in block-4 in the sample, we get the effect that the overflow condition for the first page will be detected at the first break after the nested block-4a (mentioned in comment #1 as something to watch out for). This means that my devised strategy of keeping track of the keep-context would not work. The keep context would switch again before we detect the overflow.\nSo I had the idea of making the skip dependent on one more factor: first compute the difference. If that is negative, then we know that there will be an unavoidable column-break somewhere before the current node, so we can already trigger the overflow handling. Seems to work nicely, so far. Still have to complete the testcases: the additional one present in the patch still needs decent checks, and additional tests checking the behavior in tables and lists would also be nice. Maybe it can be done by extending some of the existing testcases. Getting into that right now."}, {"count": 39, "attachment_id": 24015, "creator": "adelmelle@apache.org", "is_private": false, "id": 129020, "time": "2009-07-21T04:36:52Z", "bug_id": 46905, "creation_time": "2009-07-21T04:36:52Z", "tags": [], "text": "Created attachment 24015\nupdated patch\n\nAdded decent checks to the testcase, which uncovered one remaining issue that has also been addressed in the meantime. Still problematic: the fact that block-4a in the testcase renders correctly only if it fits in one page. If not, we will still consider the first too-long page-break (negative difference) within the block, and recover from there, leading to unexpected results.\nStill lacking testcases for tables and lists..."}, {"count": 40, "attachment_id": 24152, "creator": "adelmelle@apache.org", "is_private": false, "id": 129800, "time": "2009-08-19T13:20:20Z", "bug_id": 46905, "creation_time": "2009-08-19T13:20:20Z", "tags": [], "text": "Created attachment 24152\nsmall FO demonstrating the remaining problem\n\n\nAdded this attachment to demonstrate the one remaining issue I was looking into. It is not restricted to the page-keep being nested, but is a general problem with keep-within.page in multi-column flows.\n\nThe changes break no testcases, since our current tests only check for behavior in single column documents, where the issue does not exist. So, it could be argued that the changes are ready to be committed to Trunk, since it does offer increased functionality. \n\nI propose to add the newly attached file as a disabled testcase to remind us of what does not work, but apart from that...? Anyone against?"}, {"count": 41, "tags": [], "creator": "adelmelle@apache.org", "is_private": false, "text": "\nPatch (finally) applied to FOP Trunk with rev807014, with the additional disabled-testcase.", "id": 129859, "time": "2009-08-23T13:34:20Z", "bug_id": 46905, "creation_time": "2009-08-23T13:34:20Z", "attachment_id": null}, {"attachment_id": null, "tags": [], "bug_id": 46905, "text": "batch transition pre-FOP1.0 resolved+fixed bugs to closed+fixed", "count": 42, "id": 156257, "time": "2012-04-01T07:07:10Z", "creator": "gadams@apache.org", "creation_time": "2012-04-01T07:07:10Z", "is_private": false}]