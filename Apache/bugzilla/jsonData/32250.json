[{"count": 0, "tags": [], "bug_id": 32250, "attachment_id": null, "id": 66937, "time": "2004-11-15T18:09:14Z", "creator": "wburrows@e2open.com", "creation_time": "2004-11-15T18:09:14Z", "is_private": false, "text": "I found that when I tried to use the client tx support that the server would \ndeadlock in the db2 store client during the transaction commit phase because \nthe AbstractWebdavMethod.run() method was performing some operations that \nneeded access to the db2 store but the commit operation (a special variation of \nthe UnlockMethod) was running outside of any transaction since it was, \nobviously, committing a transaction and no longer \"enlisting\" operations for \nthat transaction. So after much investigation and experimentation I came to \nrealize that the operations causing the deadlock, a check for the existence of \nthe target for the unlock and a lock cleanup routine should probably not be \nrunning during a commit since all we really want to do in the commit is commit \nwhat we've already done and perform the special unlock that opens our stores to \nnew transactions. So to fix the problem I've made the existence check and lock \ncleanup code in AbstractWebdavMethod.run() conditional upon the current request \nnot being an UnlockMethod that is peforming the commit or abort command. In all \nother cases this code will be executed.\n\nThen I needed to ensure that every method called from the client passes the \ntransaction id from the client to the server so that any store accesses are \nproperly enlisted to a transaction. To that end I added the \ngenerateTransactionHeader() call to the following WebdavResource module methods \nsince they weren't enlisting themselves in the current transaction as required:\n\n\tsubscribeMethod (both of them)\n\tunsubscribeMethod\n\tpollMethod\n\tlockMethod\n\tunlockMethod\n\nBoth the lock and unlock need to be enlisted because of changes that make to \nthe lock store but these particular methods aren't those used to start, commit \nand abort transactions. The transaction support interfaces construct an the \nlock/unlockMethod objects themselves and I haven't called \ngenerateTransactionHeader() for the transaction interfaces.\n\nTest Case:\n\nIt was easy for me to reproduce with a DB2 nodestore and tx filesystem store. \nEnable client side transactions and attempt to lock a collection then create a \nchild collection beneath it and unlock it. From the Slide CLI client the begin \nand commit commands can be used to start/end the transaction."}, {"attachment_id": 13468, "tags": [], "creator": "wburrows@e2open.com", "text": "Created attachment 13468\nCombined patch file containing 4 file patches.\n\nHere are the patches that fix this bug.", "count": 1, "id": 66938, "time": "2004-11-15T18:26:47Z", "bug_id": 32250, "creation_time": "2004-11-15T18:26:47Z", "is_private": false}, {"attachment_id": null, "tags": [], "creator": "ozeigermann@apache.org", "is_private": false, "count": 2, "id": 66951, "time": "2004-11-15T21:01:55Z", "bug_id": 32250, "creation_time": "2004-11-15T21:01:55Z", "text": "I do not understand the changes in the client library subscribeMethod,\nunsubscribeMethod and pollMethod do not access the stores at all, do they?\nlockMethod and unlockMethod should be executed outside of transactions otherwise\nthey would be pretty meaningless, no?"}, {"count": 3, "tags": [], "bug_id": 32250, "is_private": false, "text": "Created attachment 13472\nAlternative patch\n\nThe patch for AbstractWebdavMethod is either too complicated or I missed\nsomething important. Why not just omit the lock check in externally controlled\ntransactions? This will not cause problems with deadlocks and also no problems\nwith commits of deleted locks. I attached the patch. Is it too simple?", "id": 66953, "time": "2004-11-15T21:12:10Z", "creator": "ozeigermann@apache.org", "creation_time": "2004-11-15T21:12:10Z", "attachment_id": 13472}, {"count": 4, "tags": [], "creator": "wburrows@e2open.com", "attachment_id": null, "text": "On the first comment: I added subscribe, unsubscribe and poll for two reasons. \nFirst, they all call the AbstractWebdavMethod.run() which means that they will \nall perform the structure.retrieve() and unlock cleanup code which both go out \nto the store. If they aren't enlisted in a transaction then they lock up the \nDB2 client. Secondly, even if we modified the run() method not to call these \nmethods for subscribe, unsubscribe and poll, could we be sure that these \nmethods will never want to store or fetch data from a nodestore at some time? \nIt is safer to enlist them to the current transaction just to be sure and \nthere's no harm to wrapping them in a transaction.\n\nNow for the Lock and Unlock methods: They both must be enlisted to the current \ntransaction so that the locks will be released on the server if the transaction \nfails. They are like any other method call in that they make modifications to \nthe stores that should only be comitted when the transaction is committed in \nits entirety.\n\nNow given this the server side LockMethod and UnlockMethod do perform the dual \nrole of doing normal resource lock/unlocks as well as implementing transaction-\nbased locking. Transaction based lock method calls cannot be enlisted in the \ncurrent transaction because the startTransaction() can't be nested within \nanother transaction and must be called to create a new transaction. Similarly \nthe commit/abort commands can't be enlisted to the current transaction or the \ncommit will fail noting that the transaction is in an invalid state. I have \ntried a number of variations of enlisting and not enlisting the lock/unlock \nmethods to the current transaction and the above is the only one that works \ncorrectly and makes the most sense given that LockMethod/UnlockMethod on the \nserver perform a dual role of normal resource locking plus a locking role to \ndenote the start/end of a transaction each of which must be treated separately \nas far as their enlistment to the current transaction goes.\n", "id": 66963, "time": "2004-11-15T22:03:03Z", "bug_id": 32250, "creation_time": "2004-11-15T22:03:03Z", "is_private": false}, {"count": 5, "tags": [], "bug_id": 32250, "text": "- Concerning subscribe, unsubscribe and poll: agreed\n- Concerning Lock and Unlock: agreed\n- What about my simplified patch?", "id": 66966, "time": "2004-11-15T22:12:39Z", "creator": "ozeigermann@apache.org", "creation_time": "2004-11-15T22:12:39Z", "is_private": false, "attachment_id": null}, {"count": 6, "tags": [], "bug_id": 32250, "text": "The fix you propose is a little simplistic as it removes the lock check and \ncleanup code for all external transactions and this is not correct. This code \nwas added to the AbstractWebdavMethod so that all methods will run it when they \nare run and all \"internally\" controlled transactions currently do this. The \nsame should be true for external transactions. The only external transaction \nfor which this code should not be run is the UnlockMethod and only when it is \nperforming its role as the transaction committer or aborter -- regardless of \nwhether the tx is internal or external. With the fix I have supplied, which \nchecks for this specific case, both internal and external transactions work as \nthey should. I have tested this with our own client and tested that both tx \ncommits and aborts work correctly. Aborted tx's cleanup any operations in \nprogress including unlocking resources that were locked during the operation \nwhich would not have been possible if the LockMethod and UnlockMethod on the \nclient did not enlist themselves to the transaction too.\n", "id": 66978, "time": "2004-11-15T22:55:25Z", "creator": "wburrows@e2open.com", "creation_time": "2004-11-15T22:55:25Z", "is_private": false, "attachment_id": null}, {"count": 7, "tags": [], "bug_id": 32250, "is_private": false, "text": "OK, so you seem to know what you are doing and I have no further objections. I\nsuggest we wait until you have CVS karma - hopefully soon - so this can be your\nfirst commit :)", "id": 66981, "time": "2004-11-15T23:29:10Z", "creator": "ozeigermann@apache.org", "creation_time": "2004-11-15T23:29:10Z", "attachment_id": null}, {"count": 8, "tags": [], "bug_id": 32250, "text": "Sorry, the patches do not match either CVS head or the release branch. Could you\ncreate new ones to one of these?", "id": 66992, "time": "2004-11-17T00:38:44Z", "creator": "ozeigermann@apache.org", "creation_time": "2004-11-17T00:38:44Z", "is_private": false, "attachment_id": null}, {"count": 9, "tags": [], "bug_id": 32250, "text": "Yes certainly. But I'm actually waiting to get committer access so I can commit \nthis fix and another fix (for defect 32702) myself. I'll assign this defect to \nmyself.", "id": 66993, "time": "2004-11-17T00:49:07Z", "creator": "wburrows@e2open.com", "creation_time": "2004-11-17T00:49:07Z", "is_private": false, "attachment_id": null}, {"attachment_id": 13590, "tags": [], "creator": "wburrows@e2open.com", "text": "Created attachment 13590\nUpdated patch file to reflect CVS changes.\n\nUpdated the patch file for recent CVS submissions. Patch file now matches the\nlastest source on the 2.1 release branch as at 11/29/04.", "count": 10, "id": 67606, "time": "2004-11-30T02:20:37Z", "bug_id": 32250, "creation_time": "2004-11-30T02:20:37Z", "is_private": false}]