[{"count": 0, "tags": [], "creator": "rpluem@apache.org", "is_private": false, "text": "I use mod_jk 1.2.15 in a failover configuration with session stickyness:\n\n# List of available workers\nworker.list=failover\n \n# Master worker\n# Take care that the jvmRoute attribute in the Engine tag is set to master\n# for the Tomcat addressed by MASTER_HOST and MASTER_PORT\nworker.master.port=MASTER_PORT\nworker.master.host=MASTER_HOST\nworker.master.type=ajp13\nworker.master.cachesize=10\nworker.master.cache_timeout=600\nworker.master.socket_keepalive=1\nworker.master.prepost_timeout=300\nworker.master.reply_timeout=120000\nworker.master.recovery_options=3\n# redirect to backup if master fails\nworker.master.redirect=backup\n\n# Backup worker for failover\n# Take care that the jvmRoute attribute in the Engine tag is set to backup\n# for the Tomcat addressed by BACKUP_HOST and BACKUP_PORT\nworker.backup.port=BACKUP_PORT\nworker.backup.host=BACKUP_HOST\nworker.backup.type=ajp13\nworker.backup.cachesize=10\nworker.backup.cache_timeout=600\nworker.backup.socket_keepalive=1\nworker.backup.prepost_timeout=300\nworker.backup.reply_timeout=120000\nworker.backup.recovery_options=3\n# Set worker to disabled. This means it gets only requests in the case that\n# - The session route points to this worker\n# - In the failover case (see redirect setting for master above)\nworker.backup.disabled=1\n\n# Failover worker\nworker.failover.type=lb\nworker.failover.balanced_workers=master, backup\n\nOnce I got a session from the backup worker the session stays on this disabled\nworker which is correct and expected. But if the backup server goes into error\nstate it does not recover from this state as disabled workers are not retried.\nThis is bad in the case that the disabled worker had been choosen because of\nsession stickyness. The attached patch fixes this.", "id": 86297, "time": "2006-02-28T13:02:20Z", "bug_id": 38806, "creation_time": "2006-02-28T13:02:20Z", "attachment_id": null}, {"count": 1, "tags": [], "bug_id": 38806, "text": "Created attachment 17807\nPatch against 1.2.15", "id": 86298, "time": "2006-02-28T13:03:09Z", "creator": "rpluem@apache.org", "creation_time": "2006-02-28T13:03:09Z", "is_private": false, "attachment_id": 17807}, {"count": 2, "tags": [], "text": "Right, it makes sense to retry the disabled worker also.\nTry by changing the \n#define JK_WORKER_IN_ERROR(w) ((w)->in_error_state  && !(w)->is_disabled &&\n!(w)->is_busy)\nto:\n#define JK_WORKER_IN_ERROR(w) ((w)->in_error_state && !(w)->is_busy)\n\nYour patch only addresses the byreq lb methods, while the others should be\ntreated in the same way.", "attachment_id": null, "bug_id": 38806, "id": 86299, "time": "2006-02-28T13:18:22Z", "creator": "mturk@apache.org", "creation_time": "2006-02-28T13:18:22Z", "is_private": false}, {"count": 3, "tags": [], "creator": "rpluem@apache.org", "text": "Ok. I just wasn't sure if adjusting JK_WORKER_IN_ERROR was the right thing to\ndo, so I limited the change to find_bysession_route. Do we really care about\ndisabled workers in find_best_byrequests, find_best_bytraffic and\nget_most_suitable_worker (here only the one worker case)? I don't think so.", "id": 86302, "attachment_id": null, "bug_id": 38806, "creation_time": "2006-02-28T17:05:22Z", "time": "2006-02-28T17:05:22Z", "is_private": false}, {"count": 4, "attachment_id": null, "bug_id": 38806, "text": "Right, we don't care about disabled workers for a single worker\ncause it's an oxymoron.\n\nAnyhow, adjusting JK_WORKER_IN_ERROR should do the trick.\nI really can not remember why I put that check at the first place.", "id": 86304, "time": "2006-02-28T17:57:34Z", "creator": "mturk@apache.org", "creation_time": "2006-02-28T17:57:34Z", "tags": [], "is_private": false}, {"count": 5, "tags": [], "bug_id": 38806, "text": "Fixed in the SVN.\nThanks for spotting that.", "id": 86307, "time": "2006-02-28T18:21:08Z", "creator": "mturk@apache.org", "creation_time": "2006-02-28T18:21:08Z", "is_private": false, "attachment_id": null}]