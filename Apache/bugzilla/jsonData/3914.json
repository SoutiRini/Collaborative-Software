[{"count": 0, "tags": [], "bug_id": 3914, "is_private": false, "text": "Bug\nEncoding declaration is not recognized when document is encoded with UTF-8 BOM.\n\nExample.\n\n<?xml version=\"1.0\" encoding=\"Anything-you-like-without-a-space\"?>\n\npasses validation when saved as UTF-8 With BOM.  The encoding declaration is \nignored.\n\n\nReason and Solution \n\nFirst Issue\n\nThe reason lies mainly within org.apache.xerces.readers.UTF8recognizer and how \nit uses the utils.ChunkyByteArray.\n\nWhen a check for the BOM is done\n\n        if (seeBOM) {\n            // it will have the same content anyway.\n            data.read(fUTF8BOM, 0, 3);\n\nthe data.read moves the fOffset variable of the ChunkyByteArray on 3 places \npast the BOM, as it should.\n\nBut in a further check for the characters \"<?xml\", we are looking directly at \nthe data[][] of ChunkyByteArray.  Here the fOffset variable is NOT taken into \naccount.  This means, if BOM is present, even though we moved the pointer on 3 \nplaces, data.byteAt(0) is ALWAYS going to look at the first byte in the Array, \nnot the first byte+fOffset.\n\nSolution was to create a BOMOffset variable which is initialized to 0. If \n(seeBOM ==true) then BOMOffset = 3;\n\nchecks are then done on data.byteAt(BOMOffset + 0) etc.\n\n\nSecond Issue\n\nif you get past this stage of the code you run into more problems.\n\nWe create an XMLEntityHandler.Entityreader in which we pass in the data \nstream.  Here, the constructor creates a variable fCurrentOffset with an \ninitial value of 0.  There is no way to set this initial value to anything \nother than 0. Then we run into the similar problem as above, where the correct \noffset is not taken into account.\n\nWhat should happen in my view is, a method in the ChunkyByteArray should be \ncreated to return the value of fOffset (the current offset of the byte array).  \nThen in the constructor of the XMLEntityHandler.Entityreader, we set the \nfCurrentOffset to this value.  Then all our problems are solved.\n\nHowever, I created a workaround in the UTF8Recognizer to increase this offset \nto it's correct value with the following code\n\n if (declReader.lookingAtChar((char)fUTF8BOM[0],true))\n\tif(declReader.lookingAtChar((char)fUTF8BOM[1],true))\n\t\tif(declReader.lookingAtChar((char)fUTF8BOM[2],true)){}\n\n\nUnfortunately the lookingAtChar metnod of the XMLEntityHandler.Entityreader \ntakes (char,boolean) as args, EVEN THOUGH within the method we are comparing \nthe first argument with a byte, we have to cast the fUTF8BOM bytes to chars.  \nThen we need to cast the fData.byteAt(fCurrentOffset) to char inside the \nlookingAtChar method of the XMLEntityHandler.Entityreader.\n\nThird Issue\n\nThen, when we think all is save, the method data.rewind() is used before \nreturning the readers.  The intension here is to return the pointer on the \narray back to the start of the array.  Unfortunately, this is just undoing the \nabove code of data.read(fUTF8BOM, 0, 3) which moved the pointer past the BOM.  \nThe data.rewind() is now pointing BEFORE the BOM once again.\n\nThe data.rewind() is not needed at all, as there is no method call in the class \nwhich unduely moves the fOffset past it's correct position. Removing it, \nelimitates the above issue.\n\nBelow is the modified UTF8Recognizer and XMLDeclReader for your review.\n\n==========================\n\npackage org.apache.xerces.readers;\n\nimport org.apache.xerces.framework.XMLErrorReporter;\nimport org.apache.xerces.utils.ChunkyByteArray;\nimport org.apache.xerces.utils.QName;\nimport org.apache.xerces.utils.StringPool;\n\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\n\n/**\n *\n * @version\n */\nfinal class UTF8Recognizer extends XMLDeclRecognizer {\n    private byte[] fUTF8BOM = {(byte)0xEF, (byte)0xBB, (byte)0xBF};\n    //\n    //\n    //\n    public XMLEntityHandler.EntityReader recognize(XMLEntityReaderFactory \nreaderFactory,\n                                                   XMLEntityHandler \nentityHandler,\n                                                   XMLErrorReporter \nerrorReporter,\n                                                   boolean \nsendCharDataAsCharArray,\n                                                   StringPool stringPool,\n                                                   ChunkyByteArray data,\n                                                   boolean xmlDecl,\n                                                   boolean \nallowJavaEncodingName) throws Exception {\n        XMLEntityHandler.EntityReader reader = null;\n\n        //check to see if there is a UTF8 BOM, if see one, skip past it.\n        boolean seeBOM = false;\n        int BOMOffset = 0;\n\n        byte bom0 = data.byteAt(0);\n        if (bom0 == fUTF8BOM[0]) {\n            byte bom1 = data.byteAt(1);\n            if (bom1 == fUTF8BOM[1]) {\n                byte bom2 = data.byteAt(2);\n                if (bom2 == fUTF8BOM[2]) {\n                    seeBOM = true;\n                }\n            }\n        }\n        if (seeBOM) {\n            // it will have the same content anyway.\n            data.read(fUTF8BOM, 0, 3);\n            BOMOffset = 3;\n        }\n\n        byte b0 = data.byteAt(BOMOffset + 0);\n        boolean debug = false;\n\n        if (b0 == '<') {\n            int b1 = data.byteAt(BOMOffset + 1);\n            if (b1 == '?') {\n                if (data.byteAt(BOMOffset + 2) == 'x' && data.byteAt(BOMOffset \n+ 3) == 'm' && data.byteAt(BOMOffset + 4) == 'l') {\n                    int b5 = data.byteAt(BOMOffset + 5);\n                    if (b5 == 0x20 || b5 == 0x09 || b5 == 0x0a || b5 == 0x0d) {\n                        XMLEntityHandler.EntityReader declReader = new \nXMLDeclReader(entityHandler, errorReporter, sendCharDataAsCharArray, data, \nstringPool);\n\n                        //Need to skip past BOM if Present. Method moves the \nfCurrentOffset pointer on the array past the BOM.\n                        //A better way to do this is to expose the fOffset \nvariable in the ChunkyByteArray. Then set the fCurrentOffset\n                        //variable of the XMLEntityHandler.EntityReader to this \nvalue.  At the moment, this variable is set\n                        //to 0, so if BOM is present, encoding cannot be \ndetected. The below 3 lines is just a workaround.\n\n                        if (declReader.lookingAtChar((char)fUTF8BOM[0],true))\n                          if(declReader.lookingAtChar((char)fUTF8BOM[1],true))\n                            if(declReader.lookingAtChar((char)fUTF8BOM[2],true))\n{}\n\n                        // Finished workaround\n\n                        int encoding = prescanXMLDeclOrTextDecl(declReader, \nxmlDecl);\n                        if (encoding != -1) {\n                            String encname = stringPool.orphanString(encoding);\n                            String enc = encname.toUpperCase();\n                            if (\"ISO-10646-UCS-2\".equals(enc)) throw new \nUnsupportedEncodingException(encname);\n                            if (\"ISO-10646-UCS-4\".equals(enc)) throw new \nUnsupportedEncodingException(encname);\n                            if (\"UTF-16\".equals(enc)) throw new \nUnsupportedEncodingException(encname);\n\n                            String javaencname = MIME2Java.convert(enc);\n                            if (null == javaencname) {\n                                // Not supported\n                                if (allowJavaEncodingName) {\n                                    javaencname = encname;\n                                } else {\n                                    throw new UnsupportedEncodingException\n(encname);\n                                }\n                            }\n                            try {\n                                //data.rewind();\n                                if (\"UTF-8\".equalsIgnoreCase(javaencname) \n|| \"UTF8\".equalsIgnoreCase(javaencname)) {\n                                    reader = readerFactory.createUTF8Reader\n(entityHandler, errorReporter, sendCharDataAsCharArray, data, stringPool);\n                                } else {\n                                    reader = readerFactory.createCharReader\n(entityHandler, errorReporter, sendCharDataAsCharArray,\n                                                                            new \nInputStreamReader(data, javaencname), stringPool);\n                                }\n                            } catch (UnsupportedEncodingException e) {\n                                throw new UnsupportedEncodingException(encname);\n                            } catch (Exception e) {\n                                if( debug == true )\n                                   e.printStackTrace();            // Internal \nError\n                            }\n                        } else {\n                            //data.rewind();\n                            reader = readerFactory.createUTF8Reader\n(entityHandler, errorReporter, sendCharDataAsCharArray, data, stringPool);\n                        }\n                    }\n                }\n            }\n        }\n        return reader;\n    }\n\n    final class XMLDeclReader extends XMLEntityReader {\n        //\n        //\n        //\n        private StringPool fStringPool = null;\n        private ChunkyByteArray fData = null;\n        //\n        //\n        //\n        XMLDeclReader(XMLEntityHandler entityHandler, XMLErrorReporter \nerrorReporter, boolean sendCharDataAsCharArray, ChunkyByteArray data, \nStringPool stringPool) {\n            super(entityHandler, errorReporter, sendCharDataAsCharArray);\n            fStringPool = stringPool;\n            fData = data;\n        }\n        //\n        // These methods are used to parse XMLDecl/TextDecl.\n        //\n        public boolean lookingAtChar(char ch, boolean skipPastChar) throws \nIOException {\n            if ((char)fData.byteAt(fCurrentOffset) != ch)\n                return false;\n            if (skipPastChar)\n                fCurrentOffset++;\n            return true;\n        }\n        public boolean lookingAtSpace(boolean skipPastChar) throws IOException {\n            int ch = fData.byteAt(fCurrentOffset) & 0xff;\n            if (ch != 0x20 && ch != 0x09 && ch != 0x0A && ch != 0x0D)\n                return false;\n            if (skipPastChar)\n                fCurrentOffset++;\n            return true;\n        }\n        public void skipPastSpaces() throws IOException {\n            while (true) {\n                int ch = fData.byteAt(fCurrentOffset) & 0xff;\n                if (ch != 0x20 && ch != 0x09 && ch != 0x0A && ch != 0x0D)\n                    return;\n                fCurrentOffset++;\n            }\n        }\n        public boolean skippedString(char[] s) throws IOException {\n            int offset = fCurrentOffset;\n            for (int i = 0; i < s.length; i++) {\n                if (fData.byteAt(offset) != s[i])\n                    return false;\n                offset++;\n            }\n            fCurrentOffset = offset;\n            return true;\n        }\n        public int scanStringLiteral() throws Exception {\n            boolean single;\n            if (!(single = lookingAtChar('\\'', true)) && !lookingAtChar('\\\"', \ntrue)) {\n                return XMLEntityHandler.STRINGLIT_RESULT_QUOTE_REQUIRED;\n            }\n            int offset = fCurrentOffset;\n            char qchar = single ? '\\'' : '\\\"';\n            while (true) {\n                byte b = fData.byteAt(fCurrentOffset);\n                if (b == qchar)\n                    break;\n                if (b == -1)\n                    return XMLEntityHandler.STRINGLIT_RESULT_QUOTE_REQUIRED;\n                fCurrentOffset++;\n            }\n            int length = fCurrentOffset - offset;\n            StringBuffer str = new StringBuffer(length);\n            for (int i = 0; i < length; i++) {\n                str.append((char)fData.byteAt(offset + i));\n            }\n            int stringIndex = fStringPool.addString(str.toString());\n            fCurrentOffset++; // move past qchar\n            return stringIndex;\n        }\n        //\n        // The rest of the methods in XMLReader are not used for parsing \nXMLDecl/TextDecl.\n        //\n        public void append(XMLEntityHandler.CharBuffer charBuffer, int offset, \nint length) {\n            throw new RuntimeException(\"RDR002 cannot happen\");\n        }\n        public int addString(int offset, int length) {\n            throw new RuntimeException(\"RDR002 cannot happen\");\n        }\n        public int addSymbol(int offset, int length) {\n            throw new RuntimeException(\"RDR002 cannot happen\");\n        }\n        public void skipToChar(char ch) throws IOException {\n            throw new IOException(\"RDR002 cannot happen\");\n        }\n        public void skipPastName(char fastcheck) throws IOException {\n            throw new IOException(\"RDR002 cannot happen\");\n        }\n        public void skipPastNmtoken(char fastcheck) throws IOException {\n            throw new IOException(\"RDR002 cannot happen\");\n        }\n        public boolean lookingAtValidChar(boolean skipPastChar) throws \nIOException {\n            throw new IOException(\"RDR002 cannot happen\");\n        }\n        public int scanInvalidChar() throws IOException {\n            throw new IOException(\"RDR002 cannot happen\");\n        }\n        public int scanCharRef(boolean hex) throws IOException {\n            throw new IOException(\"RDR002 cannot happen\");\n        }\n        public int scanAttValue(char qchar, boolean asSymbol) throws \nIOException {\n            throw new IOException(\"RDR002 cannot happen\");\n        }\n        public int scanEntityValue(int qchar, boolean createString) throws \nIOException {\n            throw new IOException(\"RDR002 cannot happen\");\n        }\n        public boolean scanExpectedName(char fastcheck, \nStringPool.CharArrayRange expectedName) throws IOException {\n            throw new IOException(\"RDR002 cannot happen\");\n        }\n        public void scanQName(char fastcheck, QName qname) throws IOException {\n            throw new IOException(\"RDR002 cannot happen\");\n        }\n        public int scanName(char fastcheck) throws IOException {\n            throw new IOException(\"RDR002 cannot happen\");\n        }\n        public int scanContent(QName element) throws IOException {\n            throw new IOException(\"RDR002 cannot happen\");\n        }\n    }\n}", "id": 6258, "time": "2001-10-01T17:58:26Z", "creator": "don.oleary@commerceone.com", "creation_time": "2001-10-01T17:58:26Z", "attachment_id": null}]