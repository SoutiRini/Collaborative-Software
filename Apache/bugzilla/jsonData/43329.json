[{"count": 0, "tags": [], "bug_id": 43329, "attachment_id": null, "id": 107827, "time": "2007-09-07T12:18:53Z", "creator": "Tom.Donovan@acm.org", "creation_time": "2007-09-07T12:18:53Z", "is_private": false, "text": "apr_proc_create now passes zero instead of INVALID_HANDLE_VALUE for STDIN,\nSTDOUT, and STDERR which are zero in the procattr.\n\nThis change was caused by Revision 568819. \n\nSeveral 2rd-party modules (mod_fcgid, mod_fascgi, mod_perl, etc.) test\nexplicitly for INVALID_HANDLE_VALUE and are broken by this behavior change."}, {"count": 1, "tags": [], "creator": "Tom.Donovan@acm.org", "is_private": false, "text": "Created attachment 20780\npatch for threadproc/win32/proc.c bug 43329", "id": 107829, "time": "2007-09-07T12:20:15Z", "bug_id": 43329, "creation_time": "2007-09-07T12:20:15Z", "attachment_id": 20780}, {"count": 2, "tags": [], "text": "The problem is; reverting the behavior is a problem for unix compatibility.\n\nBy default, AUIU, unix passes any open handles for FD 0, 1, 2 always.\n\nI'm not quite clear *which* handles are invalid in the running MPM, we should\nhave a stdin/out/err, no?\n\nMore clarification is needed here.", "attachment_id": null, "id": 107831, "creator": "wrowe@apache.org", "time": "2007-09-07T12:44:46Z", "bug_id": 43329, "creation_time": "2007-09-07T12:44:46Z", "is_private": false}, {"count": 3, "tags": [], "bug_id": 43329, "attachment_id": null, "is_private": false, "id": 107832, "time": "2007-09-07T12:52:54Z", "creator": "wrowe@apache.org", "creation_time": "2007-09-07T12:52:54Z", "text": "Bug one in the proposed patch;\n\n-            si.hStdInput = GetStdHandle(STD_INPUT_HANDLE);\n             if (attr->child_in && attr->child_in->filehand)\n             {\n+                si.hStdInput = GetStdHandle(STD_INPUT_HANDLE);\n\nWith this change, you are requesting that an unset child_in be treated as\nINVALID_HANDLE_VALUE.\n\nThe trouble is, you still leak that std pipe to the child by not unsetting\nthe existing STD_INPUT_HANDLE.  For sake of the 'typical case', any file\nthat has been dup2'ed a valid IN/OUT/ERR file will be left as inherited\n(which more closely resembles the way posix works).\n\n"}, {"count": 4, "tags": [], "text": "I ment to say \"by not un-inheriting\" in my comment above.  Sorry for the confusion. ", "attachment_id": null, "id": 107833, "creator": "wrowe@apache.org", "time": "2007-09-07T12:54:25Z", "bug_id": 43329, "creation_time": "2007-09-07T12:54:25Z", "is_private": false}, {"count": 5, "tags": [], "bug_id": 43329, "attachment_id": null, "is_private": false, "id": 107834, "time": "2007-09-07T13:13:46Z", "creator": "Tom.Donovan@acm.org", "creation_time": "2007-09-07T13:13:46Z", "text": "Handles which are NULL in the attr arg (i.e. attr->child_xxx is NULL) are\n*expected* to have invalid handles in the created process, not zero handles.\n\nMost (all?) Windows fastcgi programs check stdin, stdout, & stderr to recognize\na fastcgi environment on Windows.\n\nUnfortunately, it is not the Apache module which checks this (like mod_fcgid),\nbut the target executable.  FastCGI targets are usually linked with the\nvenerable old FastCGI Development kit (http://www.fastcgi.com/#TheDevKit\nlibfcgi.dll) or similar.  The code to recognize a fastcgi environment is\nunfortunately baked into all the target exe's.\n\nSee http://www.fastcgi.com/cvs/fcgi2/libfcgi/os_win32.c\nline 387 for a typical test:\n\n    if((GetStdHandle(STD_OUTPUT_HANDLE) == INVALID_HANDLE_VALUE) &&\n       (GetStdHandle(STD_ERROR_HANDLE)  == INVALID_HANDLE_VALUE) &&\n       (GetStdHandle(STD_INPUT_HANDLE)  != INVALID_HANDLE_VALUE) ) \n    {\n      ... do the fastcgi Windows pipe stuff ...\n\nNo similar issues on Unix (AFAIK).  stdin/out/err are always 0,1,2 and can be\nused the same whether it is a fastcgi environment or not."}, {"count": 6, "tags": [], "bug_id": 43329, "attachment_id": null, "is_private": false, "id": 107838, "time": "2007-09-07T17:08:54Z", "creator": "wrowe@apache.org", "creation_time": "2007-09-07T17:08:54Z", "text": "\"No similar issues on Unix (AFAIK).\"\n\nUnfortunately not true of APR in general.  We specifically corrected this\nbehavior since launching cmd.exe in particular with 'crippled file handles' \ndefinately does not work correctly - particularly from a service.\n\n\"stdin/out/err are always 0,1,2 and can be used the same whether it is \na fastcgi environment or not.\"\n\nExactly.\n\nAPR is about portability - making things behave the same.\n\nIn any case; I still need to ponder this; we are definately looking at some\naberration.  \n\nIf we should carefully consider how to achieve the same on all platforms,\neven if that means telling APR \"I want NO stdout/stderr\" and having APR\ndo that consistently across platforms.\n\nIf you want to temporarily patch your own copy of apr until this gets worked\nout, as I mention your proposed code has a bug...\n\nthis pattern below would do a better job for you of not leaking the unused\nhandles (and potentially tying up processes forever who's write ends refuse\nto terminate until shutdown).\n\n             si.hStdInput = GetStdHandle(STD_INPUT_HANDLE);\n+            if (GetHandleInformation(si.hStdInput, &stdin_reset)\n+                    && (stdin_reset &= HANDLE_FLAG_INHERIT))\n+                SetHandleInformation(si.hStdInput, HANDLE_FLAG_INHERIT, 0);\n+\n             if (attr->child_in && attr->child_in->filehand)\n             {\n-                if (GetHandleInformation(si.hStdInput,\n-                                         &stdin_reset)\n-                        && (stdin_reset &= HANDLE_FLAG_INHERIT))\n-                    SetHandleInformation(si.hStdInput,\n-                                         HANDLE_FLAG_INHERIT, 0);\n-\n                 si.hStdInput = attr->child_in->filehand;\n                 SetHandleInformation(si.hStdInput, HANDLE_FLAG_INHERIT,\n                                                    HANDLE_FLAG_INHERIT);\n             }\n+            else\n+                si.hStdInput = INVALID_HANDLE_VALUE;\n \n\nHmmm k?"}, {"count": 7, "tags": [], "creator": "Tom.Donovan@acm.org", "is_private": false, "id": 107841, "creation_time": "2007-09-07T20:24:25Z", "time": "2007-09-07T20:24:25Z", "bug_id": 43329, "text": "re: leaking handles - I cannot see any file handle leaks checking with the\n'handle.exe' utility from:\n http://www.microsoft.com/technet/sysinternals/ProcessesAndThreads/Handle.mspx\nIt seems improbable that INVALID_HANDLE_VALUE handles could leak anyway, since\nthey're not real handles.\n\nMaking the std* handles un-inheritable seems to conflict with the notes about\nSTARTF_USESTDHANDLES in:  \n http://msdn2.microsoft.com/en-us/library/ms686331.aspx\nwhich says:\n\"If this flag (STARTF_USESTDHANDLES) is specified when calling one of the\nprocess creation functions, the handles must be inheritable and the function's\nbInheritHandles parameter must be set to TRUE.\"\n\nIt's a shame that the practice of checking specifically for INVALID_HANDLE_VALUE\non Windows ever got started in the first place, but it's a practice that appears\nto go back many years.\n\n-tom-", "attachment_id": null}, {"count": 8, "tags": [], "bug_id": 43329, "attachment_id": null, "id": 107861, "time": "2007-09-08T08:42:08Z", "creator": "wrowe@apache.org", "creation_time": "2007-09-08T08:42:08Z", "is_private": false, "text": "\"It seems improbable that INVALID_HANDLE_VALUE handles could leak anyway, since\nthey're not real handles.\"\n\nThose aren't the handles that are leaking; the issue is that we have the parent's\nthree handles for STDIN/OUT/ERR which if we don't use them (passing INVALID\nhandles instead), the child still inherits all inheritable standard handles.\n\nMy favorite tool for exploring these happens to be sysinternals.com's \nProcessExplorer, which illustrates these nicely with file pipe entries of\napr.{pid}.{#} when you use the logic in the old server or your suggested patch.\n\n\"Making the std* handles un-inheritable seems to conflict with the notes about\nSTARTF_USESTDHANDLES\"\n\nOnly if you pass them.  Your patch proposes to remove them from the list of\nhandles passed to the child, so those parent handles are camped in the child\nprocess without any reference that uses them.  Correct?\n"}, {"count": 9, "tags": [], "creator": "wrowe@apache.org", "is_private": false, "id": 107878, "creation_time": "2007-09-08T15:37:00Z", "time": "2007-09-08T15:37:00Z", "bug_id": 43329, "text": "Comment on attachment 20780\npatch for threadproc/win32/proc.c bug 43329\n\nObsoleting the proposed patch, unfortunately the\nsuggested logic will lead an unindended handle for\nany unused STD handle (e.g. where that attr_child_xxx \nentry is null).", "attachment_id": 20780}, {"count": 10, "tags": [], "text": "Here's one proposal;\n\nif we added a new ***platform independent*** flag to apr_procattr_XXX(?) that\nwould close-on-exec any undesired (null) child handles on unix, while for win32\nwould set the StdHandle value to INVALID_HANDLE_VALUE, I could accept that this\nwould be very useful.\n\nIt's a new-flag because the side effects of changing the unix assumption result\nin a app that opens a file, lets say it lands in fd2, and then the programmer\ndiscovers there is additional garbage in their file emitted from some library\nwhich logged some error condition to stderr.  On windows, some process such as\ncmd.exe would mysteriously fail to start if they didn't exist in a console,\ne.g. when cmd.exe is run in a service context.  Both bugs can be hard to track\ndown for the typical user.\n\nSo it appears that APR 1.2.11 behavior is correct, but confusing to libfcgid\nand a handful of other apps that have exploited the existing error.  We can\nwork around those limited cases.\n\nThe patch on Win32 might look like this;\n\n             si.hStdInput = GetStdHandle(STD_INPUT_HANDLE);\n-            if (attr->child_in && attr->child_in->filehand)\n+            if ((attr->child_in && attr->child_in->filehand)\n+                   || (attr->flags & APR_NO_DEFAULT_CHILD_STDFILES))\n             {\n                 if (GetHandleInformation(si.hStdInput,\n                                          &stdin_reset)\n                         && (stdin_reset &= HANDLE_FLAG_INHERIT))\n                     SetHandleInformation(si.hStdInput,\n                                          HANDLE_FLAG_INHERIT, 0);\n                 si.hStdInput = INVALID_HANDLE_VALUE;\n             }\n+            if ((attr->child_in && attr->child_in->filehand)) {\n                 si.hStdInput = attr->child_in->filehand;\n                 SetHandleInformation(si.hStdInput, HANDLE_FLAG_INHERIT,\n                                                    HANDLE_FLAG_INHERIT);\n             }\n \n\nwhile on Unix, it would look something closer to\n\n         if (attr->child_in) {\n             apr_file_close(attr->parent_in);\n             dup2(attr->child_in->filedes, STDIN_FILENO);\n             apr_file_close(attr->child_in);\n         }\n+        else if (attr->flags & APR_NO_DEFAULT_CHILD_STDFILES) \n+            close(STDIN_FILENO);\n\nDoes this sound like a solution that would restore mod_fcgid without requiring\nextra apr or libfcgid patches, while also permitting cross-platform behavior?\n\nIf you agree it's a solution, we can propose this to the dev@apr list and\npick up the discussion there.\n", "attachment_id": null, "id": 107881, "creator": "wrowe@apache.org", "time": "2007-09-08T16:14:48Z", "bug_id": 43329, "creation_time": "2007-09-08T16:14:48Z", "is_private": false}, {"count": 11, "tags": [], "creator": "wrowe@apache.org", "is_private": false, "id": 107882, "creation_time": "2007-09-08T16:39:59Z", "time": "2007-09-08T16:39:59Z", "bug_id": 43329, "text": "FYI, to actually implement that patch completely\n\n         if ((attr->child_in && attr->child_in->filehand)\n             || (attr->child_out && attr->child_out->filehand)\n-            || (attr->child_err && attr->child_err->filehand))\n+            || (attr->child_err && attr->child_err->filehand)\n+            || (attr->flags & APR_NO_DEFAULT_CHILD_STDFILES))\n\nis also required in a number of places to perform all of the appropriate\nprocessing.\n\nAnother @bug, it would not work on Win9x, but we aren't particularly supporting\nthose anymore as they are entirely abandoned by MS.   Also would not work on\nWinCE which has no 'stdio' construct or inherited std handles.\n\nIt should not be hard to implement on os2, beos or netware.", "attachment_id": null}, {"count": 12, "tags": [], "bug_id": 43329, "attachment_id": null, "is_private": false, "id": 107887, "time": "2007-09-08T19:11:47Z", "creator": "Tom.Donovan@acm.org", "creation_time": "2007-09-08T19:11:47Z", "text": "It might be possible to confine the fix to Windows proc.c with enough\nSetHandleInformation calls.  Since it's entirely a Windows problem, it seems\ndesirable to keep it out of the non-Windows code.\n\nI've discovered a few things:\n\n1. msvcr80 differs from msvcrt if si.hStdError contains INVALID_HANDLE_VALUE\nbut there is another valid stderr handle.  My orig patch didn't work with VS8\nanyway because the new log.c cannot tolerate a missing stderr.  Previously VS8\nbuilds had lots of failed apr calls in log.c because stderr was missing, but\nthey weren't visible (obviously...)  None were fatal.  The new httpd log.c has a\ndup2 call (line 411) which breaks if stderr_log is null.\n\n2. handle inheritance wasn't being reset correctly.  The 2nd arg to\nSetHandleInformation is a mask, so the following doesn't reset the handle to\nun-inheritable if stdin_reset is zero:\n\n  SetHandleInformation(GetStdHandle(STD_INPUT_HANDLE),stdin_reset, stdin_reset);\n\nSetHandleInformation is effectively a no-op when the second arg is zero.\nThat had me confused for a bit when the inheritance changed from call-to-call!  \n\n3. There really is no good way to accommodate both the mpm_winnt child-creation\ncall (all 3 are inheritable but only stdin is passed in attr) and the various\ncombinations of inheritable (stderr can be changed by logging) handles and\nsupplied arguments in attr.  I came up with this rule:\n\n* If 1-or-more attr handles are supplied and all 3 original handles are still\ninheritable - keep them inheritable.  Otherwise, use INVALID_HANDLE_VALUE for\nany missing handles in attr and suppress inheriting the original std* handles.\n\nThis does (I think) what you describe re: not allowing inherited handles in most\ncases.  It does still allow the httpd child proc to inherit all 3 from its\nparent, but once stdout becomes un-inheritable, no unwanted handles should ever\nget to any later created processes.\n\nA cmd.exe process would either need no handles in attr, or else three useable\nhandles.\n\nI'll attach a patch which does all this.  I believe it works as expected for VC6\nand VS8 builds on Win2k and WinXP with mod_perl and mod_fcgid (running\nPHP-FastCGI or a stand-alone test FastCGI program).   I really should get a\nclean copy of the 2.2.6-r2 source, apply the patch, and build & test it all\nagain - but I'll attach the patch now and add a comment if I find I overlooked\nsomething."}, {"count": 13, "tags": [], "creator": "Tom.Donovan@acm.org", "is_private": false, "text": "Created attachment 20782\n2nd patch for threadproc/win32/proc.c bug 43329", "id": 107888, "time": "2007-09-08T19:12:49Z", "bug_id": 43329, "creation_time": "2007-09-08T19:12:49Z", "attachment_id": 20782}, {"count": 14, "tags": [], "bug_id": 43329, "attachment_id": null, "id": 107898, "time": "2007-09-09T02:06:15Z", "creator": "wrowe@apache.org", "creation_time": "2007-09-09T02:06:15Z", "is_private": false, "text": "Going the initial comment and postfix of comment #12 above, please don't worry \nabout totally functional code, as right now we have to pound out some \ntheoreticals.  In fact I *had* prompted the dev@apr list (who's readers include \nsubversion, log4cxx and other apr applications beyond httpd) for any insight \nif the proposed 'fix' in APR 1.2.11 would break things.  This application case \nwas not forseen.\n\nand lastly... \"Since it's entirely a Windows problem, it seems desirable \nto keep it out of the non-Windows code.\" ---\n\nfrom the inception to first release of APR, it was never designed to solve\na per-platform issue, rather address the same computing problem for ALL of\nour platforms.  In fact, it's old behavior definately qualifies as a /bug/\nalthough your program was able to exploit that as a feature :)  So in short,\nI'll definately require a bigger-picture solution to be able to back the\npatch with a +1.  As I mention, the old behavior was a bug, conveinent to\na limited number of cases.\n\nNow, I need to address the specific bullets and your proposed patch and I'll\ndo that in a later comment."}, {"count": 15, "tags": [], "bug_id": 43329, "attachment_id": null, "is_private": false, "id": 107899, "time": "2007-09-09T02:15:12Z", "creator": "wrowe@apache.org", "creation_time": "2007-09-09T02:15:12Z", "text": "I'll address your second bullet first in comment #12 above;\n\n> 2. handle inheritance wasn't being reset correctly.  The 2nd arg to\n> SetHandleInformation is a mask, so the following doesn't reset the handle to\n> un-inheritable if stdin_reset is zero:\n>\n>  SetHandleInformation(GetStdHandle(STD_INPUT_HANDLE),stdin_reset, stdin_reset);\n\nI missed your point as applies to either the current 1.2.11 code, or my\nproposed code fragement above - just above the reset you should find;\n\n            if (stdin_reset)\n                SetHandleInformation(GetStdHandle(STD_INPUT_HANDLE),\n                                     stdin_reset, stdin_reset);\n\nand you are right, stdin_reset will *not* toggle an uninheritable\nhandle to inheritable; we determined stdin_reset from the parent\nprocesses' STD_INPUT_HANDLE current value.  We mask it & INHERIT so\nthat we examine and toggle none of the other possible handle flags.\n\nIf stdin_reset is 0 - there is nothing to set back to INHERITED - then\nthe SetHandleInformation is not called, and the current STD_INPUT_HANDLE\nenters and leaves apr_proc_create unmolested.  Right?\n"}, {"count": 16, "tags": [], "text": "I should have been clearer about #2.  A case is where the parent's\n(non-inheritable) stdin handle is also passed in attr as child_in.  It is set to\ninheritable, but never reset to not-inheritable before leaving apr_proc_create.\nProbably an edge case anyway.\n\nre: \"the larger context\" - Agreed, APR should be as platform-independent and\nconsistent as possible. Alas, FastCGI programs are the real-world issue.  If it\nwas just a matter of updating a few modules like mod_fcgid, mod_fastcgi et. al.\nthis would probably be OK.  The problem is not in these modules, but in all the\ntarget executables which these modules run in external processes.  These target\nexes include common ones like php-cgi.exe (which probably *could* also be\nchanged if necessary) and many one-off or in-house exe's which have been ported\nfrom Unix fastcgi over the years since APR change 63707 in 2002.  These target\nexecutables acquired a built-in dependency on INVALID_HANDLE_VALUE for stdout &\nstderr on Windows.  Finding and re-building all these targets is the painful\npart of accommodating this APR change.\n\nre: \"the old behavior was a bug, conveinent to a limited number of cases\"\nI think some (particularly the fastcgi library developers) interpreted the\nchange to pass INVALID_HANDLE_VALUE as an intentional change, albeit a\nWindows-specific one.\n\nre: \"your program\" - It's ironic!  Many Win/Apache sites depend on some variant\nof fastcgi.  I'm one of the rare ones who don't.  My only affected programs were\nconstructed just for testing this release. I'm just sympathetic to the majority\nwho do need it fixed.\n\nThe comments in my proposed patch are inappropriately httpd-specific for an APR\nfunction and should probably be changed.", "attachment_id": null, "id": 107900, "creator": "Tom.Donovan@acm.org", "time": "2007-09-09T07:26:26Z", "bug_id": 43329, "creation_time": "2007-09-09T07:26:26Z", "is_private": false}, {"count": 17, "tags": [], "bug_id": 43329, "attachment_id": null, "id": 107911, "time": "2007-09-09T12:55:52Z", "creator": "Tom.Donovan@acm.org", "creation_time": "2007-09-09T12:55:52Z", "is_private": false, "text": "I've built the 2nd patch with VC6 and VS8 and tested on Win2k and WinXP.\n\nWhile it does as expected, it will not allow httpd 2.2.6 to run as a Windows\nservice.\n\nserver/log.c has changed for 2.2.6 in a way that is incompatible with fastcgi\nrequirements:\n\n  the mpm_winnt child process is created with child_in as the only handle \n  supplied in attr.\n  log.c now *requires* a valid stderr, so one must be created or inherited.\n  Prior to 2.2.6 it could survive until the parent pipe got set up.\n\n  fastcgi processes are also created with child_in as the only handle \n  supplied in attr.  \n  fastcgi requires that both out & err be INVALID_HANDLE_VALUE\n\nWhen httpd is started as a service, all three handles are zero (and invalid), so\ninheritance can't help.  When started as a normal process, stderr gets inherited\nin APR 1.2.11 (either with or without the patch).  When started as a service, if\nthe patch sets stderr=INVALID_HANDLE_VALUE, this breaks log.c.\n\nIn other words, the rule I proposed (... all 3 original handles are inheritable\n...) won't work for Windows services.\n\nI don't see a way to solve this for both log.c and fastcgi, short of changes to\nboth APR's win proc.c and changes to httpd.   Any ideas?"}, {"count": 18, "tags": [], "bug_id": 43329, "attachment_id": null, "is_private": false, "id": 108050, "time": "2007-09-12T01:10:47Z", "creator": "wrowe@apache.org", "creation_time": "2007-09-12T01:10:47Z", "text": "\"I don't see a way to solve this for both log.c and fastcgi, short of changes to\nboth APR's win proc.c and changes to httpd.   Any ideas?\"\n\nI guess I have to step back and ask a few things.  Typical cgi looks like\n\n  httpd.exe [parent] (happens to set up stdout \\device\\null, stderr to errorlog)\n   \\-- httpd.exe [child] (gets a stdin from parent for passing handles)\n        \\-- prog.exe (stdin/out set up to pipe cgi, errors to errorlog)\n\nThat's simple enough so far.  Now mod_fcgid spawns a long-lived app serving\nprocess, and wants to pass that app no stdout/stderr.\n\nWhat would be wrong with mod_fcgid invoking\n\napr_procattr_io_set(fcgid_procattr, APR_FULL_BLOCK, APR_NO_FILE, APR_NO_FILE);\n\nfor it's procattr structure, and then invoking the fcgi app with those flags?\n\nWhat happens when we add a new flag to win32, at least, is that previous apr\nversions would treat those as APR_FULL_BLOCK, creating pipes that are never\nused.  With the next apr release forward, they would be INVALID_FILE_HANDLE\nnotations to avoid passing the parent's current stdhandles, or any other handle.\n\nTo accomplish the same but using apr_procattr_stdin_set() instead, just first\ncall this;\n\napr_procattr_io_set(fcgid_procattr,  APR_NO_FILE, APR_NO_FILE, APR_NO_FILE);\n\nand it will mark those as not-inherited, although stdin_set would override.\n\nWouldn't this solve the case of using apr file_io?  The compiled modules aren't\nusing apr themselves, are they?  Or if they are, it doesn't matter, since they\naren't being recompiled and they dealt with INVALID_FILE_HANDLES just fine,\nbefore.\n\nI agree we don't want to rebuild every fcgi application out there.  Obviously\nmod_fcgid needs a recompile.  I'm trying to find the shortest path."}, {"count": 19, "tags": [], "bug_id": 43329, "attachment_id": null, "is_private": false, "id": 108098, "time": "2007-09-12T17:13:38Z", "creator": "Tom.Donovan@acm.org", "creation_time": "2007-09-12T17:13:38Z", "text": "Yes, a new flag APR_NO_FILE to trigger INVALID_HANDLE_VALUE in the created\nprocess seems like it would work OK for both mod_fcgid and mod_fastcgi on\nWindows.  These are the two I have tested with, and I suspect they are the two\nmost commonly used fastcgi-launching Apache modules on Windows.\n\nPresumably APR_NO_FILE would be equivalent to APR_NO_PIPE for Unix platforms. \nThis would avoid platform-dependent calls to apr_proc_create (both mod_fcgid and\nmod_fastcgi also run on Unix).\n\nThis is certainly much better than requiring changes to all the target executables.\n\nre: \"The compiled modules aren't using apr themselves, are they?\"\nTypically not, although it's hard to generalize about what all the target\nexecutables do. It seems very unlikely that any would create additional\nprocesses using apr_proc_create and also depend on stderr/stdout being\nINVALID_HANDLE_VALUE.  Not a worry (IMHO)."}, {"count": 20, "tags": [], "text": "Applying the proposed patch from\nhttp://people.apache.org/~wrowe/apr-1.2-win32-nohandle.patch\nto Apache 2.2.6-r2 source on Windows works correctly with mod_fcgid and\nmod_fastcgi when the modules' process creation code is changed like this:\n\n#ifdef APR_NO_FILE\n    /* required for APR 1.2.11+ to pass INVALID_HANDLE_VALUE */\n    if (apr_procattr_io_set(attr,  APR_NO_FILE, APR_NO_FILE, APR_NO_FILE))\n            {...handle errors...};\n#endif\n    if (apr_procattr_child_in_set(procattr, file, NULL))\n            {...handle errors...}; \n{...apr_proc_create...}\n\nTested with VC6 and VC8 on Win2k.\n\nThe mod_fcgid developers have indicated willingness to make the change. I don't\nknow about the mod_fastcgi developers, but I expect they will too eventually.\n\nOne minor nit - in proc.c (lines 802-832) the _reset vars are always set to\n\"inheritable\":\n\n    if (GetHandleInformation(si.hStdOutput,\n                             &stdout_reset)\n            && (stdout_reset &= HANDLE_FLAG_INHERIT))\n\nYou probably meant: (stdout_reset & HANDLE_FLAG_INHERIT) \ninstead of:         (stdout_reset &= HANDLE_FLAG_INHERIT).  \nNot relevant to this bug, but it was the reason the heritability changed between\ncalls.", "attachment_id": null, "id": 108763, "creator": "Tom.Donovan@acm.org", "time": "2007-09-28T09:18:38Z", "bug_id": 43329, "creation_time": "2007-09-28T09:18:38Z", "is_private": false}, {"count": 21, "tags": [], "bug_id": 43329, "attachment_id": null, "id": 108764, "time": "2007-09-28T10:07:36Z", "creator": "wrowe@apache.org", "creation_time": "2007-09-28T10:07:36Z", "is_private": false, "text": "On your comment above;\n> You probably meant: (stdout_reset & HANDLE_FLAG_INHERIT) \n> instead of:         (stdout_reset &= HANDLE_FLAG_INHERIT).  \n\nIt does mean exactly what it states already, an and-mask-assignment;\n\n    if (GetHandleInformation(si.hStdOutput,\n                             &stdout_reset)\n            && (stdout_reset &= HANDLE_FLAG_INHERIT))\n\nshould presently GetHandleInformation(si.hStdOutput, &stdout_reset)\n  assigning the value of the current handle flags to stdout_reset\nand if not 0 (success), \n  stdout_reset contains the handle bits from GetHandleInformation,\n  (stdout_reset &= HANDLE_FLAG_INHERIT)\n    causes stdout_reset to be masked with only the previous inherit bit,\n    resulting in a value of 0 or HANDLE_FLAG_INHERIT based on it's prior value.\nbut if GetHandleInformation returns 0 (failure)\n  stdout_reset is not touched\n  the stdout_reset value is not &= and-mask assigned\n\nNo?\n"}, {"count": 22, "tags": [], "bug_id": 43329, "attachment_id": null, "is_private": false, "id": 108765, "time": "2007-09-28T10:14:16Z", "creator": "wrowe@apache.org", "creation_time": "2007-09-28T10:14:16Z", "text": "Note patch; thank you Tom and Randy for validating this patch!"}, {"count": 23, "tags": [], "bug_id": 43329, "attachment_id": null, "is_private": false, "id": 108769, "time": "2007-09-28T10:22:30Z", "creator": "Tom.Donovan@acm.org", "creation_time": "2007-09-28T10:22:30Z", "text": "re: \"It does mean exactly what it states already ... No?\"\n\nYep, you're right!\nI guess I should stop pondering the set/reset STD inheritance flags any more.  \nI'll stop now :-)"}, {"count": 24, "tags": [], "bug_id": 43329, "attachment_id": null, "is_private": false, "id": 108887, "time": "2007-10-02T04:14:05Z", "creator": "Tom.Donovan@acm.org", "creation_time": "2007-10-02T04:14:05Z", "text": "Proposed an Apache patch instead of an APR patch in bug 43534 to accomplish this\nwithout requiring module changes, and also re-enable mod_perl."}, {"count": 25, "tags": [], "creator": "wrowe@apache.org", "is_private": false, "id": 108908, "creation_time": "2007-10-02T11:11:18Z", "time": "2007-10-02T11:11:18Z", "bug_id": 43329, "text": "FYI The patch to introduce APR_NO_FILE as an apr_procattr_io_set() will be\npresent in apr 0.9.17 + 1.2.12 to reintroduce this desired behavior.\n\nThat flag becomes portable with APR 1.3, and was introduced prematurely\n('violating' our versioning philosophy) for the one platform solution to\nsimultaneously correct portability (new behavior) - and feature set (old\nbehavior/new flag).\n\n\n\n", "attachment_id": null}, {"count": 26, "tags": [], "text": "*** THE FINAL CONCLUSION ***\n\nHere's the upshot, folks.  The fix of APR_NO_FILE is applied for the eventual\nrelease of APR 1.3.0, probably with httpd 2.4.  Your change to test for this\nflag (#ifdef) and use this API for apps which insist on INVALID_HANDLE_VALUE \nwill be a good change, but is not needed for 2.0/2.2.\n\nThe patch introducing APR_NO_FILE as an apr_procattr_io_set() option is reverted,\nthe behavior itself, to inherit the parent's stdio handles if one has been set\nthrough apr_procattr_io_set() or apr_procattr_child_XXX_set(), is also reverted.\nSo APR 1.2.12 will revert in *that* respect to the behavior of 1.2.8, and the\nAPR 0.9.17 behavior will revert in that respect to 0.9.14.\n\nSorry for the hassles introduced by attempting compatibility with the unix\nimplementation, and we look forward to your module running as expected for any\nusers on apr 1.2.x, and encourage you to patch already in order to accommodate\nyour users on apr 1.3.x and later.\n", "attachment_id": null, "id": 109007, "creator": "wrowe@apache.org", "time": "2007-10-04T19:33:41Z", "bug_id": 43329, "creation_time": "2007-10-04T19:33:41Z", "is_private": false}]