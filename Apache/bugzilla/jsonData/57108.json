[{"count": 0, "tags": [], "creator": "quartz12h@yahoo.com", "attachment_id": null, "is_private": false, "id": 178564, "time": "2014-10-17T18:48:04Z", "bug_id": 57108, "creation_time": "2014-10-17T18:48:04Z", "text": "SSL/TLS defines a mechanism for virtual host names on the same ip/port to have distinct server certs (and protocols, and else), avoiding the use of wildcard certs.\n\nWith jdk8, a TLS server can prefetch the ClientHello's server name indication (SNI) extension from the tcp accepted socket inputstream, then create an sslsocket with the new SSLSocketFactory.createSocket(socket, inputstream, autoclose) method (the the inputstream arg is just the replay of the prefetched bytes).\n\nUnfortunately, all socket factories come from a SSLContext already initialized on keymanagers/trustmanagers on key/trust stores. Once a sslsocket is accepted from an sslsocketfactory, the sslcontext/server cert is already chosen.\n\nTo implement this under tomcat, the SSL connectors must only accept tcp connetions, detect the intended hostname, choose the proper sslcontext and then forward to the sslsocketfactory to handshake correctly. This means defining more than one keystore/truststore/params on the unique ssl connector.\n\nOne way to express this potentially large configuration would be to point to a mapping file outside the server.xml, but it should be possible to inline this data section too (some new tag element under the connector, perhaps a collection).\n\nUltimately, the admin should be able to map a hostname to an sslcontext descriptor (which is more than just keystore/truststore, but also versions, protocols, etc...)\n\nBackward compatibility is desirable, so the previous attributes would only be assimilated as a single mapping of all hostnames. In fact, these mapping will require a default when no hostname pattern matches, so it is probably good to plan for a collection of sslcontext mappings plus 1 default sslcontext.\n\nThe jdk8 docs are giving complete examples on the prefectching mecanism and how to use SNI.\n\nhttp://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/JSSERefGuide.html#SNIExamples\n\nParticularly the section \"Working with Virtual Infrastructures\"."}, {"count": 1, "tags": [], "text": "Correct the component - this has nothing to do with the Connectors component which is the web server end of the AJP implementation.\n\nTomcat 8 has to run on a minimum of Java 7 so this is something on the roadmap for Tomcat 9. Leave this in Tomact 8 until work starts on Tomcat 9 and the product exists in Bugzilla.", "attachment_id": null, "bug_id": 57108, "id": 178566, "time": "2014-10-17T19:03:21Z", "creator": "markt@apache.org", "creation_time": "2014-10-17T19:03:21Z", "is_private": false}, {"count": 2, "attachment_id": null, "creator": "chris@christopherschultz.net", "is_private": false, "id": 178570, "time": "2014-10-17T19:50:24Z", "bug_id": 57108, "creation_time": "2014-10-17T19:50:24Z", "tags": [], "text": "This may be an opportunity to fix the inability to respond to HTTP requests on HTTPS endpoints.\n\nWe get complaints every once in a while that if you \"telnet host 443\" against Tomcat, you get a hung connection while with httpd, you get an \"400 Bad Request\" response that actually says \"you are making an HTTP connection to an HTTPS server\". Completely changing the infrastructure and handling of secure sockets isn't justified merely to scratch this itch, but supporting SNI is a much bigger motivating force. Scratching this itch simultaneously would be great."}, {"count": 3, "tags": [], "creator": "hauser@acm.org", "attachment_id": null, "is_private": false, "id": 179824, "time": "2014-12-17T09:36:51Z", "bug_id": 57108, "creation_time": "2014-12-17T09:36:51Z", "text": "see also \nhttp://stackoverflow.com/questions/20190464/howto-setup-tomcat-serving-two-ssl-certificates-using-sni \n\nand \nhttps://en.wikipedia.org/wiki/Server_Name_Indication"}, {"attachment_id": null, "tags": [], "bug_id": 57108, "is_private": false, "count": 4, "id": 180343, "time": "2015-01-17T17:56:47Z", "creator": "markt@apache.org", "creation_time": "2015-01-17T17:56:47Z", "text": "Move to Tomcat 9 now it exists."}, {"count": 5, "tags": [], "bug_id": 57108, "attachment_id": null, "id": 180498, "time": "2015-01-23T08:15:19Z", "creator": "unlogic@unlogic.se", "creation_time": "2015-01-23T08:15:19Z", "is_private": false, "text": "This will surely be a killer function if it makes to Tomcat 9. As the use of Windows XP is fading out the demand for SNI support is increasing by the day."}, {"count": 6, "text": "Proposed configuration vocabulary, which is backward-compatible with existing configurations:\n\n\n   <Connector ...\n      truststoreFile=\"...\" (and other truststore attributes)\n      keystoreFile=\"...\" (and other keystore attributes)\n      >\n     <TLSAlias hostname=\"alternate.hostname\"\n         truststoreFile=\"...\" (and other truststore attributes)\n         keystoreFile=\"...\" (and other keystore attributes)\n         [other allowed configuration attributes]\n         />\n     <TLSAlias hostname=\"alternate.hostname\"\n         truststoreFile=\"...\" (and other truststore attributes)\n         keystoreFile=\"...\" (and other keystore attributes)\n         [other allowed configuration attributes]\n         />\n   </Connector>\n\nThe TLS configuration attributes on the <Connector> will become the default TLS configuration for a request for a hostname that does not match any of the <TLSAlias> elements' hostname fields. Any request that exactly matches a hostname (or, perhaps we can do prefixing, globbing and/or regular expressions if people want to do that kind of thing) will instead use the TLS configuration of its matching <TLSAlias> element.\n\nThere are some configuration elements that are appropriate to allow a <TLSAlias> element to override from the default. Proposed are all but those that appear in the following section.\n\nThere are some attributes that should probably not be overridable in the <TLSAlias> elements, due their effect on all connections. Proposed attributes:\n\n  SSLProtocol\n\nCare must be taken to ensure that subsequent handshakes -- for example, for the purposes of client re-negotiation or cipher-suite-switching -- do not allow a single client to switch from one hostname to another to, for instance, avoid some part of the authentication scheme or take advantage of a faulty configuration in host alias in order to \"upgrade\" to a different host with more stringent requirements.", "bug_id": 57108, "is_private": false, "id": 181838, "time": "2015-03-17T13:25:13Z", "creator": "chris@christopherschultz.net", "creation_time": "2015-03-17T13:25:13Z", "tags": [], "attachment_id": null}, {"count": 7, "tags": [], "text": "I think that sounds like a very good approach which would be easy to add to existing server configurations.\n\nSince a single certificate can contain multiple subject alternative names (http://en.wikipedia.org/wiki/SubjectAltName) which may be very different from each other I would propose to use an approach similar to the way aliases are added to hosts.\n\n   <Connector ...\n      truststoreFile=\"...\" (and other truststore attributes)\n      keystoreFile=\"...\" (and other keystore attributes)\n      >\n     <TLSAlias hostname=\"alternate.hostname\"\n         truststoreFile=\"...\" (and other truststore attributes)\n         keystoreFile=\"...\" (and other keystore attributes)\n         [other allowed configuration attributes]>\n\n         <Alias>somehost.com</Alias>\n         <Alias>anotherhost.com</Alias>\n         <Alias>averydifferenthost.org</Alias>\n    </TLSAlias>\n\n\n     <TLSAlias hostname=\"alternate.hostname\"\n         truststoreFile=\"...\" (and other truststore attributes)\n         keystoreFile=\"...\" (and other keystore attributes)\n         [other allowed configuration attributes]\n         />\n   </Connector", "is_private": false, "bug_id": 57108, "id": 181839, "time": "2015-03-17T13:42:02Z", "creator": "unlogic@unlogic.se", "creation_time": "2015-03-17T13:42:02Z", "attachment_id": null}, {"count": 8, "tags": [], "text": "That sounds reasonable to me. Since the configuration for each hostname would need to be maintained separately, being able to tie several hostnames together would be beneficial.\n\nOn the other hand, if regular expressions are used for hostnames, the complxity can be handled there instead of in a slightly larger look-up table with aliases, etc.\n\nHonestly, even though I mentioned it as a possibility, I think that the use of regular expressions for hostname matching is probably more overhead than anyone wants to perform for every TLS request that comes through the door.", "is_private": false, "bug_id": 57108, "id": 181845, "time": "2015-03-17T15:56:31Z", "creator": "chris@christopherschultz.net", "creation_time": "2015-03-17T15:56:31Z", "attachment_id": null}, {"count": 9, "tags": [], "bug_id": 57108, "attachment_id": null, "id": 181922, "time": "2015-03-20T15:25:45Z", "creator": "chris@christopherschultz.net", "creation_time": "2015-03-20T15:25:45Z", "is_private": false, "text": "I'm starting to re-think the <Connector> configuration because it's starting to look a lot like the <Host> configuration.\n\nWould it make more sense to put the TLS configuration on the <Host> element instead? This would be more in line with Apache httpd, for instance.\n\nThe connector would have to reach-into the <Host> configuration to pick-up all the configuration. I'm not sure if this is a good idea (or even possible), but from a human configuration perspective, I think that using the <Host> as the container for TLS configuration makes more sense than having it on the <Connector>."}, {"count": 10, "tags": [], "creator": "unlogic@unlogic.se", "attachment_id": null, "is_private": false, "id": 182008, "time": "2015-03-23T19:54:44Z", "bug_id": 57108, "creation_time": "2015-03-23T19:54:44Z", "text": "Well this is a bit tricky because there is two sides to this coin.\n\nIn some cases you have a wildcard certificates or subject alternative name certificates the cover lots of domains. In those cases the current connector based approach works fine fine.\n\nBut if you turn things around and have lets say 50 domains all with their own host and certificate and maybe even a few aliases for some hosts that in turn also require separate certificates. In that case the host based approach would make things simpler since you can put everything inside the hosts element.\n\nA trade off between the two solutions could be to define the keystores using a separate element in the config like when you define a connection pool. And then make it possible for both the connectors, hosts and aliases to refer back to the defined keystores depending on the use case.\n\nHere's an example:\n\n   <Keystore\n         name=\"firstKeystore\"\n         truststoreFile=\"...\" (and other truststore attributes)\n         keystoreFile=\"...\" (and other keystore attributes)\n         [other allowed configuration attributes]>\n\n   <Keystore\n         name=\"secondKeystore\"\n         truststoreFile=\"...\" (and other truststore attributes)\n         keystoreFile=\"...\" (and other keystore attributes)\n         [other allowed configuration attributes]>\n\n   <Keystore \n         name=\"thirdKeystore\"\n         truststoreFile=\"...\" (and other truststore attributes)\n         keystoreFile=\"...\" (and other keystore attributes)\n         [other allowed configuration attributes]>\n\n   <Connector ... /> (a generic https connector not bound to any particular keystore that instead looks up the keystore based on the host/alias)\n\n   <Connector keystoreRef=\"firstKeystore\" ... /> (a https connector bound to the specified keystore like current tomcat versions)\n\n   <Host name=\"hostone.com\"... /> (a host not bound to any particular keystore)\n\n   <Host name=\"hosttwo.net\" keystoreRef=\"secondKeystore\" ... />\n\n   <Host name=\"hostthree.net\" keystoreRef=\"secondKeystore\" ...>\n\n       <Alias keystoreRef=\"thirdKeystore\">foo.com</Alias>\n\n       <Alias keystoreRef=\"firstKeystore\">boo.com</Alias>\n\n       <Alias>moo.com</Alias>\n\n   </Host>\n\nI hope that my example makes sense. It would make the keystore/certificate configuration a bit more flexible and support \"both sides of the coin\"."}, {"count": 11, "tags": [], "creator": "chris@christopherschultz.net", "attachment_id": null, "id": 182060, "time": "2015-03-24T14:50:13Z", "bug_id": 57108, "creation_time": "2015-03-24T14:50:13Z", "is_private": false, "text": "(In reply to Unlogic from comment #10)\n> Well this is a bit tricky because there is two sides to this coin.\n> \n> In some cases you have a wildcard certificates or subject alternative name\n> certificates the cover lots of domains. In those cases the current connector\n> based approach works fine fine.\n\nWe have to continue to support the current connector configuration, anyway. I figured that whatever configuration the <Connector> had would be the default for all of the hosts. In that case, you'd probably want to put the wildcard cert, etc. on the <Connector> and do nothing special for each host.\n\n> A trade off between the two solutions could be to define the keystores using\n> a separate element in the config like when you define a connection pool. And\n> then make it possible for both the connectors, hosts and aliases to refer\n> back to the defined keystores depending on the use case.\n> \n> Here's an example:\n> \n>    <Keystore\n>          name=\"firstKeystore\"\n>          truststoreFile=\"...\" (and other truststore attributes)\n>          keystoreFile=\"...\" (and other keystore attributes)\n>          [other allowed configuration attributes]>\n\n\nThis is pretty much what my <TLSAlias> proposal was, except that they would be explicitly-referenced from <Connector> and/or <Host> instead of being nested within."}, {"count": 12, "tags": [], "creator": "markt@apache.org", "attachment_id": null, "id": 182285, "time": "2015-04-09T11:26:02Z", "bug_id": 57108, "creation_time": "2015-04-09T11:26:02Z", "is_private": false, "text": "Keeping the config at the connector level is probably the way to go. There are weird and wonderful configuration possibilities like one Connector on one interface with one set of certs for internal users and another connector on another interface with another set of certs for external users that share the same hosts.\n\nI think we should keep the TLS cert <-> host name mapping completely independent from the Host <-> host name mapping. Most folks will have them aligned but some will want to do soemthign different. Using <Alias>...</Alias> should allow some config copy/paste for those that want to.\n\nSNI is mandatory for HTTP/2 so this has just jumped to the top of my TODO list.\n\nI'm thinking along the lines of the the configuration style in comment#7.\n\nI've also been thinking about trying to merge the JSSE and OpenSSL configuration attributes. I'm not sure if it will work but the idea is to deprecate setting these on the connector and add a defaultTLSAlias=\"\" element to the Connector that references the cert to use if nothing else matches. If the existing configuration attributes are used on the Connector then they are mapped to a TLSAlias element with a pre-defined name (probably default or something similar), along with a deprecated config warning.\n\nI don't know how feasible this merging plan is but if it works, in addition to simpler config, it should allow further simplification of the Http11*Protocol implementations."}, {"count": 13, "tags": [], "text": "I have a few technical heads up.\n\nJDK8 doesn't have a clear way to intercept the SNI before chosign the keystore's alias. This would need some tricks. I'm not completely sure of either, but it's worth discussing I think.\n\na) anonymous SNI matcher leaking server name into threadlocal \"connection context\".\nAs you know, the whole ssl handshake is pretty closed, with a few callbacks. We would need a custom x509extendedkeymanager that allows to chose an alias from a key store (does this mean all keys are in the same keystore?). In order to pick the right alias, such custom key manager would have to consult a threadlocal object \"connection context\" (a new tomcat class to create) where the SNI info from the SNImatcher was populated (leaked). The custom SNI matcher (pretty much always accepts, but act mainly as an observer) would simply leak the server name it received on the threadlocal connection context..\n\nWarning, this is dangerous with NIO where a single thread can perform handshake for many connections (I presume NIO was implemented for TLS, but maybe not; regardless, this is a possibility for the future). Therefore, the connection context must be switched in and out of the thread local in alignement with the socket being worked on obviously. I also presume the SSL engine and SSL socket jdk stuff is not multithreaded in their implementation in order to enable passing information in a threadlocal.\n\n\nb) look ahead of the client hello tls record.\nThis is the process mentioned in the linked article above. It requires implementing solid TLS parsers (including the upcoming TLS 1.3). Once the plain tcp socket is opened, the stream bytes are read and inspected for the SNI, rewound, the ssl context is setup and then the sslsocket is hooked to the stream to handshake and all. It looks a lot cleaner, if not simpler. No sni matcher needed, no custom x509 key namager. Just standard jsse. However, it is expected to be slower too, since the client hello is parsed twice, and it is sensitive to TLS spec changes, instead of counting on the jdk folks.\n\nWhat do you think?", "attachment_id": null, "bug_id": 57108, "id": 182305, "time": "2015-04-10T13:26:58Z", "creator": "quartz12h@yahoo.com", "creation_time": "2015-04-10T13:26:58Z", "is_private": false}, {"count": 14, "text": "I think if you were following the dev list you would have seen that b) has already been implemented for NIO.\n\nSo far, there don't appear to be any changes to the ClientHello in TLS 1.3. We can cross that bridge as and when we come to it.\n\nReal world use cases suggest that only a few hundred bytes need to be processed to extract the SNI information, much of which can simply be skipped once the length is known. Given the overhead of creating a TLS connection, I'm not worried about the overhead this approach adds.", "bug_id": 57108, "is_private": false, "id": 182306, "time": "2015-04-10T13:45:01Z", "creator": "markt@apache.org", "creation_time": "2015-04-10T13:45:01Z", "tags": [], "attachment_id": null}, {"count": 15, "tags": [], "bug_id": 57108, "attachment_id": null, "id": 182314, "time": "2015-04-10T21:32:00Z", "creator": "quartz12h@yahoo.com", "creation_time": "2015-04-10T21:32:00Z", "is_private": false, "text": "nio: ok. Sorry.\n\nAs for TLS parsing, there can be a whole lot of stuff well beyond 100 bytes in client hello, namely yet unknown extensions. TLS records proto msg length is up to 2^14-1 bytes. Not an issue I guess.\n\nAlso, I just read that with a DHE handshake the SNI could come later and encrypted.\nhttps://tools.ietf.org/html/draft-rescorla-tls13-new-flows-01#section-4\n\nSo, if they have it their way, it won't be enough to look ahead the clienthello in 1.3. But I won't bet on that delayed encrypted sni; it is paranoiac protection because the DNS lookup just before is pretty much revealing the same info."}, {"count": 16, "attachment_id": null, "bug_id": 57108, "text": "This is implemented in Tomcat 9 for NIO, NIO2 and APR/native.\n\nNote that the configuration refactoring isn't complete yet but the building blocks are all in place.", "id": 182739, "time": "2015-04-29T21:40:56Z", "creator": "markt@apache.org", "creation_time": "2015-04-29T21:40:56Z", "tags": [], "is_private": false}]