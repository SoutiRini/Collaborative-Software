[{"count": 0, "tags": [], "creator": "rdg12@stanford.edu", "attachment_id": null, "id": 26451, "time": "2002-11-18T06:02:53Z", "bug_id": 14631, "creation_time": "2002-11-18T06:02:53Z", "is_private": false, "text": "I am running a checker over the Apache source tree to look for bugs.  The \nchecker marked the following code as a potential bug.  The\napr_file_read function is used to read data into a buffer buf.  It is my \nunderstanding that apr_file_read does not null terminate the buffer it writes \nto.  This read is then followed by a strstr command which can potentially \nreturn misleading results if the buffer is not terminated (either accidentally \nor maliciously).\n\n[BUG] - I think\n/u1/rdg12/net/httpd-2.0.43/modules/mappers/mod_negotiation.c:813:get_body: \nERROR:USER:808:813:passing unsafe_source data buffer to strstr\n    /* We are at the first character following a body:tag\\n entry \n     * Suck in the body, then backspace to the first char after the \n     * closing tag entry.  If we fail to read, find the tag or back\n     * up then we have a hosed file, so give up already\n     */\nStart --->\n    if (apr_file_read(map, buffer, len) != APR_SUCCESS) {\n        return -1;\n    }\n\n    strncpy(buffer + *len, tag, taglen);\nError --->\n    endbody = strstr(buffer, tag);\n    if (endbody == buffer + *len) {\n        return -1;\n    }"}, {"count": 1, "tags": [], "text": "It is definitely weird code, but the strstr() call does not need a\nterminating '\\0' because it is guaranteed to find the tag before\nthe end of the buffer due to the line right before the call to\nstrstr().\n\nThe strncpy() call right before strstr() puts a copy of the tag \nafter the data read from the file, so strstr() definitely has \nsomething to find.\n\nBut thanks for looking anyway :)  More eyes are always good.\n", "attachment_id": null, "bug_id": 14631, "id": 26468, "time": "2002-11-18T14:09:23Z", "creator": "trawick@apache.org", "creation_time": "2002-11-18T14:09:23Z", "is_private": false}]