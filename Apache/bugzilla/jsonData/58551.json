[{"count": 0, "tags": [], "bug_id": 58551, "attachment_id": null, "id": 185978, "time": "2015-10-26T16:55:29Z", "creator": "rmannibucau@gmail.com", "creation_time": "2015-10-26T16:55:29Z", "is_private": false, "text": "Opened on tomcat 9 but actually this issue targets all supported tomcat versions.\n\nThe idea is to add a kind of wrapper on top of the actual ssl connection to activate or skip ssl for the current request ().\n\nGoal is to avoid to need 2 ports for HTTP transport where a single one is needed.\n\nThis has been done for cassandra (https://issues.apache.org/jira/secure/attachment/12767756/0001-CASSANDRA-8803-Allow-to-serve-plain-and-encrypted-na.patch) and is quite convenient. I think the more and more common \"embedded\" usage would benefit from it a lot."}, {"count": 1, "tags": [], "bug_id": 58551, "attachment_id": null, "id": 185981, "time": "2015-10-26T17:32:18Z", "creator": "remm@apache.org", "creation_time": "2015-10-26T17:32:18Z", "is_private": false, "text": "There has never been any interest in Tomcat to add \"port unification\", and now that unencrypted is going to be on the decline, it is even less likely this feature would be accepted."}, {"count": 2, "tags": [], "text": "Here is the interest then ;)\n\nIn embedded mode it would be very fancy, in particularly since embedded tomcat supports a single port and also cause cloud providers allows most of the time a single port to be exposed.", "attachment_id": null, "bug_id": 58551, "id": 185983, "time": "2015-10-26T17:42:20Z", "creator": "rmannibucau@gmail.com", "creation_time": "2015-10-26T17:42:20Z", "is_private": false}, {"count": 3, "tags": [], "text": "Given that user agents are written on the basis of different default ports for HTTP and HTTP I don't see this causing anything but problems for end users.\n\nRegarding cloud providers I'd be surprised if any were exposing Tomcat directly to the Internet.  I'd expect there to be some form of load balancing to support transparent horizontal scaling.\n\nI'm far from convinced this is a good idea.", "attachment_id": null, "bug_id": 58551, "id": 185984, "time": "2015-10-26T18:00:12Z", "creator": "markt@apache.org", "creation_time": "2015-10-26T18:00:12Z", "is_private": false}, {"count": 4, "tags": [], "bug_id": 58551, "attachment_id": null, "id": 185985, "time": "2015-10-26T18:03:25Z", "creator": "rmannibucau@gmail.com", "creation_time": "2015-10-26T18:03:25Z", "is_private": false, "text": "@Mark: doesnt change the fact you still have a single port to bind and can need both (internal vs external for a trivial sample). Also several cloud providers are exposing tomcat directly whatever you think about that. Finally I dont get the user agent case, more and more instances are not used with browsers today."}, {"count": 5, "tags": [], "text": "This is somewhat related to the long-standing request (can't find the enhancement in BZ at the moment) to emit a plain-text error message from a TLS connector that is contacted by a non-TLS client. This is something that Apache httpd does right now and would be nice to have similar support in Tomcat. Many recent changes in the way that TLS has been implemented in Tomcat make the above possible at this point.\n\nOnce we are able to handle plaintext-over-TLS, it is theoretically possible to be able to use plaintext for the whole conversation.\n\nBut right now, I'd say that I'm -1 on the idea of providing insecure and secure communications over the same channel, excepting the use-case above, which is *very* helpful for clients who are perhaps connecting to non-standard ports.\n\nThe HTTP spec had a recent revision, and nobody seems to have thought of putting dual-use channels into the spec. It's just not that hard to configure two separate ports.", "is_private": false, "bug_id": 58551, "id": 186024, "time": "2015-10-27T19:25:34Z", "creator": "chris@christopherschultz.net", "creation_time": "2015-10-27T19:25:34Z", "attachment_id": null}, {"attachment_id": null, "tags": [], "creator": "rmannibucau@gmail.com", "text": "The \"not that hard\" is really dependent on your environment. Not being in the spec is one thing and you seem to keep speaking of web applications where the most common use case for such a feature is webservices IMO (allowing \"internal\" not secured communication and \"external\" secured communications).\n\nI wouldnt activate it by defaut as well but I would add a flag on the connector to be able to do so (acceptPlain=true on a SSL connector for instance).", "count": 6, "id": 186029, "time": "2015-10-27T20:23:37Z", "bug_id": 58551, "creation_time": "2015-10-27T20:23:37Z", "is_private": false}, {"count": 7, "tags": [], "text": "(In reply to romain.manni-bucau from comment #6)\n> The \"not that hard\" is really dependent on your environment.\n\nFair enough, but you mentioned embedded environment: very easy to add another connector programmatically.\n\n> Not being in\n> the spec is one thing and you seem to keep speaking of web applications\n> where the most common use case for such a feature is webservices\n\nWhat's the difference between a \"web application\" and a \"webservice\"?\n\n> IMO (allowing \"internal\" not secured communication and \"external\"\n> secured communications)\n\nI understand, and I operate such an environment. I also happen to operate in a \"cloud\" environment where I have never had any problems connecting things together, whether using HTTP or HTTPS.\n\n> I wouldn't activate it by default as well but I would add a flag on the\n> connector to be able to do so (acceptPlain=true on a SSL connector for\n> instance).", "attachment_id": null, "id": 186030, "creator": "chris@christopherschultz.net", "time": "2015-10-27T20:42:49Z", "bug_id": 58551, "creation_time": "2015-10-27T20:42:49Z", "is_private": false}, {"count": 8, "tags": [], "text": "A webservice doesnt have all the \"browser\" constraints and defaults (where all comments are right).\n\nI used few providers where you were not able to bind any other port than one in a reliable manner - you can hardcode instead of using the environment variable for such an additional port but then it can be forbidden or already used. Also saw cases on AWS where you can only redirect a single port (using docker as container of your tomcat).", "is_private": false, "id": 186031, "creator": "rmannibucau@gmail.com", "time": "2015-10-27T20:49:04Z", "bug_id": 58551, "creation_time": "2015-10-27T20:49:04Z", "attachment_id": null}, {"count": 9, "tags": [], "text": "(In reply to romain.manni-bucau from comment #8)\n> A webservice doesnt have all the \"browser\" constraints and defaults (where\n> all comments are right).\n\nI think you are introducing a semantic difference where there is none: a web service and a web application are the same thing. The fact that a browser is one kind of client is irrelevant.\n\nThe point Mark was trying to make (if I may be so bold) was that \"the web\" (by whatever definition) already recognizes separate official ports for HTTP and HTTPS, so being able to switch protocols on a single port is inappropriate.\n\nIf you want to multiplex protocols over a single port, use some kind of service out in front of Tomcat that understands how to do that, and leave Tomcat out of it. This is unnecessary complexity for a product like Tomcat.\n\n> I used few providers where you were not able to bind any other port than one\n> in a reliable manner - you can hardcode instead of using the environment\n> variable for such an additional port but then it can be forbidden or already\n> used. Also saw cases on AWS where you can only redirect a single port (using\n> docker as container of your tomcat).\n\nSounds like your suitcase of tools are failing you. AWS itself imposes no such limitations.", "is_private": false, "bug_id": 58551, "id": 186034, "time": "2015-10-28T00:49:00Z", "creator": "chris@christopherschultz.net", "creation_time": "2015-10-28T00:49:00Z", "attachment_id": null}, {"attachment_id": null, "tags": [], "creator": "rmannibucau@gmail.com", "text": "> I think you are introducing a semantic difference where there is none: a web service and a web application are the same thing. The fact that a browser is one kind of client is irrelevant.\n\nOn the technical stack there is none but on the usage there are. You have no standard port in practise for a webservice (very very often in enterprises you dont use 80 and 443).\n\n> If you want to multiplex protocols over a single port, use some kind of service out in front of Tomcat that understands how to do that, and leave Tomcat out of it. This is unnecessary complexity for a product like Tomcat.\n\nWhy Tomcat couldn't get this? The code itself is very limited.\n\n> Sounds like your suitcase of tools are failing you. AWS itself imposes no such limitations.(by whatever definition) already recognizes separate official ports for HTTP and HTTPS, so being able to switch protocols on a single port is inappropriate.\n\nThis is not true when using EB typically.", "count": 10, "id": 186043, "time": "2015-10-28T06:48:44Z", "bug_id": 58551, "creation_time": "2015-10-28T06:48:44Z", "is_private": false}, {"count": 11, "tags": [], "text": "I remain unconvinced that this feature is a) necessary or b) a good idea.\n\n(In reply to romain.manni-bucau from comment #10)\n> Why Tomcat couldn't get this? The code itself is very limited.\n\nImplementing this feature is not as simple as porting the Cassandra patch you referenced. It would require changes all the way through the I/O layers from SocketWrapper all the way up to the Request since whether or not a request is secure and the protocol in use would become a property of the socket rather than the connector.\n\nImplementing this feature would also break the current orthogonality between the secure, protocol and SSLEnabled properties of a connector. The more I think about it, the more this aspect of this proposal concerns me. The current implementation of these features is well understood and offers a great deal of flexibility for a wide range of applications. Adding automatic plaintext/TLS switching would muddy the waters considerably.\n\nIt is also worth noting that there is a standard for this: RFC2817 and that that standard is largely unimplemented by web servers and clients due to numerous issues such as those articulated here:\nhttps://bugzilla.mozilla.org/show_bug.cgi?id=276813#c7\n\nI don't see why adding an additional HTTP connector (given that an HTTPS is going to have to exist to handle the TLS traffoc) is so hard.", "is_private": false, "bug_id": 58551, "id": 186058, "time": "2015-10-28T16:25:36Z", "creator": "markt@apache.org", "creation_time": "2015-10-28T16:25:36Z", "attachment_id": null}, {"count": 12, "text": "@Mark: there is a discussion - think it is on the list - to make connectors easier to impl/extend. For me it should be as easy as wrapping HTTP and HTTPs connectors - = implementing it as a wrapper of both - and just delegating to the desired one once the selection has been done. It looks different from the protocol you mention cause in this cause we would know which protocol to use - we would simply reuse http and https.", "bug_id": 58551, "is_private": false, "id": 186061, "time": "2015-10-28T16:34:56Z", "creator": "rmannibucau@gmail.com", "creation_time": "2015-10-28T16:34:56Z", "tags": [], "attachment_id": null}, {"count": 13, "tags": [], "text": "An extend capability is useless as well. There is no guarantee the connectors design or API will remain stable, so it is just as simple to make whetever necessary changes to Tomcat as part of the build process.\n\nAs for this enhancement, -1 for it as well, besides problems nothing good will come out of it.", "attachment_id": null, "bug_id": 58551, "id": 186062, "time": "2015-10-28T17:06:49Z", "creator": "remm@apache.org", "creation_time": "2015-10-28T17:06:49Z", "is_private": false}, {"count": 14, "text": "Ok, then close the issue.", "bug_id": 58551, "attachment_id": null, "id": 186063, "time": "2015-10-28T17:09:54Z", "creator": "rmannibucau@gmail.com", "creation_time": "2015-10-28T17:09:54Z", "tags": [], "is_private": false}, {"count": 15, "tags": [], "bug_id": 58551, "attachment_id": null, "id": 186065, "time": "2015-10-28T23:38:57Z", "creator": "knst.kolinko@gmail.com", "creation_time": "2015-10-28T23:38:57Z", "is_private": false, "text": "One of widely used technologies of using plaintext vs encrypted communication over the same connection is STARTTLS.\n\nhttps://en.wikipedia.org/wiki/STARTTLS\n\nIt has known weaknesses and I would not recommend it nowadays.\nOne of many articles on the subject:\nhttps://www.agwa.name/blog/post/starttls_considered_harmful\n\nTrying to implement HTTP and HTTPS on the same port would face similar issues.\nAs such, I do not see much worth for investing time in implementing and supporting such a feature."}]