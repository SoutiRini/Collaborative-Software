[{"count": 0, "tags": [], "bug_id": 273, "is_private": false, "text": "I order to be able to launch trigger code, stored procedures and other code that includes delimiters like \";\" into an Oracle database. \r\nThere is a need for another type of delimiter since the sql code otherwise will be executed when hitting the first delimiter.\r\n\r\nI have solved this by modifying the SqlExec task, inventing two new properties,delimiter and delimiter_type\r\n\r\nThe delimiter is used to set the delimiter, that is for instance  \";\" or \"/\" default is \";\".\r\n\r\nThe delimiter type is either \"normal or \"row\"\r\nWith the row delimiter I can use a build file like this \r\n\r\n<sql \r\ndriver=\"${oracle_driver}\" \r\nurl=\"${oracle_service}\" \r\nuserid=\"${db_user}\"\r\npassword=\"${db_passwd}\" \r\nsrc=\"${exec_file}\" \r\nprint=\"yes\" \r\noutput=\"${tmplogfile}\"\r\ndelimiter=\"/\"\r\ndelimiter_type=\"row\"/>\r\n\r\nto launch for instance an sql file like this:\r\n\r\ncreate or replace TRIGGER x_ord_customer before insert or update or delete  \r\non customer\r\nfor each row\r\nbegin\r\n if INSERTING then\r\n    ORD_PAD.ORD_CUSTOMER_INS( :new.id,\r\n                             :new.name,\r\n                             :new.mail_address); \r\n elsif UPDATING then\r\n    ORD_PAD.ORD_CUSTOMER_UPD (:new.id,\r\n                             :new.name,\r\n                              1,\r\n                              :new.mail_address,\r\n                              1);\r\n elsif DELETING then\r\n    ORD_PAD.ORD_CUSTOMER_DEL (:old.id);\r\n end if;\r\nend;\r\n/   \r\n\r\n\r\nIs it of any use for the ant project to add functionallity like this or could you add some functionality to make it possible to lauch code into the database?\r\n\r\nThe modified SqlExec task:\r\n\r\n/*\r\n * The Apache Software License, Version 1.1\r\n *\r\n * Copyright (c) 1999 The Apache Software Foundation.  All rights \r\n * reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions\r\n * are met:\r\n *\r\n * 1. Redistributions of source code must retain the above copyright\r\n *    notice, this list of conditions and the following disclaimer. \r\n *\r\n * 2. Redistributions in binary form must reproduce the above copyright\r\n *    notice, this list of conditions and the following disclaimer in\r\n *    the documentation and/or other materials provided with the\r\n *    distribution.\r\n *\r\n * 3. The end-user documentation included with the redistribution, if\r\n *    any, must include the following acknowlegement:  \r\n *       \"This product includes software developed by the \r\n *        Apache Software Foundation (http://www.apache.org/).\"\r\n *    Alternately, this acknowlegement may appear in the software itself,\r\n *    if and wherever such third-party acknowlegements normally appear.\r\n *\r\n * 4. The names \"The Jakarta Project\", \"Tomcat\", and \"Apache Software\r\n *    Foundation\" must not be used to endorse or promote products derived\r\n *    from this software without prior written permission. For written \r\n *    permission, please contact apache@apache.org.\r\n *\r\n * 5. Products derived from this software may not be called \"Apache\"\r\n *    nor may \"Apache\" appear in their names without prior written\r\n *    permission of the Apache Group.\r\n *\r\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\r\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\r\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\r\n * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\r\n * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\r\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\r\n * SUCH DAMAGE.\r\n * ====================================================================\r\n *\r\n * This software consists of voluntary contributions made by many\r\n * individuals on behalf of the Apache Software Foundation.  For more\r\n * information on the Apache Software Foundation, please see\r\n * <http://www.apache.org/>.\r\n */\r\n\r\npackage org.apache.tools.ant.taskdefs;\r\n\r\nimport org.apache.tools.ant.*;\r\nimport org.apache.tools.ant.types.*;\r\n\r\nimport java.io.*;\r\nimport java.util.Enumeration;\r\nimport java.util.StringTokenizer;\r\nimport java.util.Vector;\r\nimport java.util.Properties;\r\nimport java.util.zip.*;\r\nimport java.sql.*;\r\n\r\n/**\r\n * Reads in a text file containing SQL statements seperated with semicolons\r\n * and executes it in a given db.\r\n * Both -- and // maybe used as comments.\r\n * \r\n * @author <a href=\"mailto:jeff@custommonkey.org\">Jeff Martin</a>\r\n */\r\npublic class SQLExec extends Task {\r\n    \r\n    private int goodSql = 0, totalSql = 0;\r\n\r\n    private Path classpath;\r\n\r\n    private AntClassLoader loader;\r\n\r\n    \r\n    /**\r\n     * SQL delimiter\r\n     * Added 001122\t\t\t\r\n     */\r\n    private String delimiter = \";\";\r\n\r\n    /**\r\n     * SQL delimiter_type\r\n     * Added 001122\r\n     * To swich between a normal delimiter and a row delimiter (\"normal\" or \"row\")\t\t\t\r\n     */ \r\n    private String delimiter_type = \"normal\";\r\n\r\n\r\n\r\n     /**\r\n     * Database connection\r\n     */\r\n    private Connection conn = null;\r\n    \r\n    /**\r\n     * Autocommit flag. Default value is false\r\n     */\r\n    private boolean autocommit=false;\r\n    \r\n    /**\r\n     * SQL statement\r\n     */\r\n    private Statement statement = null;\r\n\r\n    /**\r\n     * DB driver.\r\n     */\r\n    private String driver = null;\r\n\r\n    /**\r\n     * DB url.\r\n     */\r\n    private String url = null;\r\n\r\n    /**\r\n     * User name.\r\n     */\r\n    private String userId = null;\r\n\r\n    /**\r\n     * Password\r\n     */\r\n    private String password = null;\r\n\r\n    /**\r\n     * SQL input file\r\n     */\r\n    private File srcFile = null;\r\n\r\n    /**\r\n     * SQL input command\r\n     */\r\n    private String sqlCommand = \"\";\r\n\r\n    /**\r\n     * SQL transactions to perform\r\n     */\r\n    private Vector transactions = new Vector();\r\n\r\n    /**\r\n     * Print SQL results.\r\n     */\r\n    private boolean print = false;\r\n\r\n    /**\r\n     * Print header columns.\r\n     */\r\n    private boolean showheaders = true;\r\n\r\n    /**\r\n     * Results Output file.\r\n     */\r\n    private File output = null;\r\n\r\n    /**\r\n     * RDBMS Product needed for this SQL.\r\n     **/\r\n    private String rdbms = null;\r\n\r\n    /**\r\n     * RDBMS Version needed for this SQL.\r\n     **/\r\n    private String version = null;\r\n\r\n    /**\r\n     * Action to perform if an error is found\r\n     **/\r\n    private String onError = \"abort\";\r\n\r\n    /**\r\n     * Set the classpath for loading the driver.\r\n     */\r\n    public void setClasspath(Path classpath) {\r\n        if (this.classpath == null) {\r\n            this.classpath = classpath;\r\n        } else {\r\n            this.classpath.append(classpath);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create the classpath for loading the driver.\r\n     */\r\n    public Path createClasspath() {\r\n        if (this.classpath == null) {\r\n            this.classpath = new Path(project);\r\n        }\r\n        return this.classpath.createPath();\r\n    }\r\n\r\n    /**\r\n     * Set the classpath for loading the driver using the classpath reference.\r\n     */\r\n    public void setClasspathRef(Reference r) {\r\n        createClasspath().setRefid(r);\r\n    }\r\n    \r\n    /**\r\n     * Set the name of the sql file to be run.\r\n     */\r\n    public void setSrc(File srcFile) {\r\n        this.srcFile = srcFile;\r\n    }\r\n    \r\n    /**\r\n     * Set the delimiter.\r\n     * Added 001122 \r\n     */\r\n    public void setDelimiter(String delimiter) {\r\n        this.delimiter = delimiter;\r\n    }\r\n\r\n     /**\r\n     * Set the delimiter_type\r\n     * Added 001122 \r\n     */\r\n        public void setDelimiter_type(String delimiter_type) {\r\n        this.delimiter_type = delimiter_type;\r\n    }\r\n\r\n\r\n    /**\r\n     * Set the sql command to execute\r\n     */\r\n    public void addText(String sql) {\r\n        this.sqlCommand += sql;\r\n    }\r\n    \r\n    /**\r\n     * Set the sql command to execute\r\n     */\r\n    public Transaction createTransaction() {\r\n      Transaction t = new Transaction();\r\n      transactions.addElement(t);\r\n      return t;\r\n    }\r\n    \r\n    /**\r\n     * Set the JDBC driver to be used.\r\n     */\r\n    public void setDriver(String driver) {\r\n        this.driver = driver;\r\n    }\r\n    \r\n    /**\r\n     * Set the DB connection url.\r\n     */\r\n    public void setUrl(String url) {\r\n        this.url = url;\r\n    }\r\n    \r\n    /**\r\n     * Set the user name for the DB connection.\r\n     */\r\n    public void setUserid(String userId) {\r\n        this.userId = userId;\r\n    }\r\n    \r\n    /**\r\n     * Set the password for the DB connection.\r\n     */\r\n    public void setPassword(String password) {\r\n        this.password = password;\r\n    }\r\n    \r\n    /**\r\n     * Set the autocommit flag for the DB connection.\r\n     */\r\n    public void setAutocommit(boolean autocommit) {\r\n        this.autocommit = autocommit;\r\n    }\r\n\r\n    /**\r\n     * Set the print flag.\r\n     */\r\n    public void setPrint(boolean print) {\r\n        this.print = print;\r\n    }\r\n    \r\n    /**\r\n     * Set the showheaders flag.\r\n     */\r\n    public void setShowheaders(boolean showheaders) {\r\n        this.showheaders = showheaders;\r\n    }\r\n\r\n    /**\r\n     * Set the output file.\r\n     */\r\n    public void setOutput(File output) {\r\n        this.output = output;\r\n    }\r\n\r\n    /**\r\n     * Set the rdbms required\r\n     */\r\n    public void setRdbms(String vendor) {\r\n        this.rdbms = vendor.toLowerCase();\r\n    }\r\n\r\n    /**\r\n     * Set the version required\r\n     */\r\n    public void setVersion(String version) {\r\n        this.version = version.toLowerCase();\r\n    }\r\n\r\n    /**\r\n     * Set the action to perform onerror\r\n     */\r\n    public void setOnerror(OnError action) {\r\n        this.onError = action.getValue();\r\n    }\r\n\r\n    /**\r\n     * Load the sql file and then execute it\r\n     */\r\n        public void execute() throws BuildException {\r\n        sqlCommand = sqlCommand.trim();\r\n\r\n        if (srcFile == null && sqlCommand.length() == 0) { \r\n            if (transactions.size() == 0) {\r\n                throw new BuildException(\"Source file, transactions or sql statement must be set!\", location);\r\n            }\r\n        } else {\r\n            // Make a transaction group for the outer command\r\n            Transaction t = createTransaction();\r\n            t.setSrc(srcFile);\r\n            t.addText(sqlCommand);\r\n        }\r\n\r\n        if (driver == null) {\r\n            throw new BuildException(\"Driver attribute must be set!\", location);\r\n        }\r\n        if (userId == null) {\r\n            throw new BuildException(\"User Id attribute must be set!\", location);\r\n        }\r\n        if (password == null) {\r\n            throw new BuildException(\"Password attribute must be set!\", location);\r\n        }\r\n        if (url == null) {\r\n            throw new BuildException(\"Url attribute must be set!\", location);\r\n        }\r\n        if (srcFile != null && !srcFile.exists()) {\r\n            throw new BuildException(\"Source file does not exist!\", location);\r\n        }\r\n\r\n\tif ( delimiter_type != null ) {\r\n\t\t\r\n\t    if ( !(delimiter_type.compareTo(\"row\") == 0) && !(delimiter_type.compareTo(\"normal\") == 0))\r\n            throw new BuildException(\"delimiter_type is must be either row or normal! Is now: <\" + delimiter_type + \">\" , location);\r\n\t}//if\r\n\r\n        Driver driverInstance = null;\r\n        // Load the driver using the \r\n        try {\r\n            Class dc;\r\n            if (classpath != null) {\r\n\t\tlog(\"Loading \" + driver + \" using AntClassLoader with classpath \" + classpath, Project.MSG_VERBOSE);\r\n                loader = new AntClassLoader(project, classpath, false);\r\n                dc = loader.loadClass(driver);\r\n            }\r\n            else {\r\n\t\tlog(\"Loading \" + driver + \" using system loader.\", Project.MSG_VERBOSE);\r\n                dc = Class.forName(driver);\r\n            }\r\n            driverInstance = (Driver) dc.newInstance();\r\n        }catch(ClassNotFoundException e){\r\n            throw new BuildException(\"Class Not Found: JDBC driver \" + driver + \" could not be loaded\", location);\r\n        }catch(IllegalAccessException e){\r\n            throw new BuildException(\"Illegal Access: JDBC driver \" + driver + \" could not be loaded\", location);\r\n        }catch(InstantiationException e) {\r\n            throw new BuildException(\"Instantiation Exception: JDBC driver \" + driver + \" could not be loaded\", location);\r\n        }\r\n\r\n        try{\r\n            log(\"connecting to \" + url, Project.MSG_VERBOSE );\r\n            Properties info = new Properties();\r\n            info.put(\"user\", userId);\r\n            info.put(\"password\", password);\r\n            conn = driverInstance.connect(url, info);\r\n\r\n            if (conn == null) {\r\n                // Driver doesn't understand the URL\r\n                throw new SQLException(\"No suitable Driver for \"+url);\r\n            }\r\n\r\n            if (!isValidRdbms(conn)) return;\r\n\r\n            conn.setAutoCommit(autocommit);\r\n\r\n            statement = conn.createStatement();\r\n\r\n            \r\n            PrintStream out = System.out;\r\n            try {\r\n                if (output != null) {\r\n        \t    log(\"Opening PrintStream to output file \" + output, Project.MSG_VERBOSE);\r\n                    out = new PrintStream(new BufferedOutputStream(new FileOutputStream(output)));\r\n                }\r\n                        \r\n                // Process all transactions\r\n                for (Enumeration e = transactions.elements(); \r\n                     e.hasMoreElements();) {\r\n                       \r\n                    ((Transaction) e.nextElement()).runTransaction(out);\r\n                    if (!autocommit) {\r\n                        log(\"Commiting transaction\", Project.MSG_VERBOSE);\r\n                        conn.commit();\r\n                    }\r\n                }\r\n            }\r\n            finally {\r\n                if (out != null && out != System.out) {\r\n                    out.close();\r\n                }\r\n            }\r\n        } catch(IOException e){\r\n            if (!autocommit && conn != null && onError.equals(\"abort\")) {\r\n                try {\r\n                    conn.rollback();\r\n                } catch (SQLException ex) {}\r\n            }\r\n            throw new BuildException(e, location);\r\n        } catch(SQLException e){\r\n            if (!autocommit && conn != null && onError.equals(\"abort\")) {\r\n                try {\r\n                    conn.rollback();\r\n                } catch (SQLException ex) {}\r\n            }\r\n            throw new BuildException(e, location);\r\n        }\r\n        finally {\r\n            try {\r\n                if (statement != null) {\r\n                    statement.close();\r\n                }\r\n                if (conn != null) {\r\n                    conn.close();\r\n                }\r\n            }\r\n            catch (SQLException e) {}\r\n        }\r\n          \r\n        log(goodSql + \" of \" + totalSql + \r\n            \" SQL statements executed successfully\");\r\n    }\r\n\r\n    protected void runStatements(Reader reader, PrintStream out) throws SQLException, IOException {\r\n        String sql = \"\";\r\n        String line = \"\";\r\n \r\n        BufferedReader in = new BufferedReader(reader);\r\n \t\r\n\r\n\r\n\tif ( delimiter_type.compareTo (\"normal\") == 0 ) {\r\n            try{\r\n                while ((line=in.readLine()) != null){\r\n                    if (line.trim().startsWith(\"//\")) continue;\r\n                    if (line.trim().startsWith(\"--\")) continue;\r\n\r\n                    sql += \" \" + line;\r\n                    sql = sql.trim();\r\n\r\n                    // SQL defines \"--\" as a comment to EOL\r\n                    // and in Oracle it may contain a hint\r\n                    // so we cannot just remove it, instead we must end it\r\n                    if (line.indexOf(\"--\") >= 0) sql += \"\\n\";\r\n\r\n                    if (sql.endsWith(delimiter)){\r\n                        log(\"SQL: \" + sql, Project.MSG_VERBOSE);\r\n                        execSQL(sql.substring(0, sql.length()-1), out);\r\n                        sql = \"\";\r\n                    }\r\n                }\r\n \r\n                // Catch any statements not followed by delimiter\r\n                if(!sql.equals(\"\")){\r\n                    execSQL(sql, out);\r\n                }\r\n            }//try\r\n\t    catch(SQLException e){\r\n                throw e;\r\n            }//catch\r\n\t}//if\r\n\r\n\telse if ( delimiter_type.compareTo (\"row\") == 0 ){\r\n\t    try{\r\n                while ((line=in.readLine()) != null){\r\n\t\t    \r\n\t\t    if ( line.trim().compareTo(delimiter) == 0 ){\r\n                        log(\"SQL: \" + sql, Project.MSG_VERBOSE);\r\n                        execSQL(sql, out);\r\n                        sql = \"\";\r\n                    }\r\n\t\t    else {\r\n\t\t\tsql += \" \\n\" + line;\r\n\t            }//else\r\n                }//while\r\n\t    }//try\r\n        \r\n\t    catch(SQLException e){\r\n                throw e;\r\n            }\r\n\t}//else if\r\n    }//runStatements\r\n \r\n\r\n\r\n\r\n    /**\r\n     * Verify if connected to the correct RDBMS\r\n     **/\r\n    protected boolean isValidRdbms(Connection conn) {\r\n        if (rdbms == null && version == null)\r\n            return true;\r\n        \r\n        try {\r\n            DatabaseMetaData dmd = conn.getMetaData();\r\n            \r\n            if (rdbms != null) {\r\n                String theVendor = dmd.getDatabaseProductName().toLowerCase();\r\n                \r\n                log(\"RDBMS = \" + theVendor, Project.MSG_VERBOSE);\r\n                if (theVendor == null || theVendor.indexOf(rdbms) < 0) {\r\n                    log(\"Not the required RDBMS: \"+rdbms, Project.MSG_VERBOSE);\r\n                    return false;\r\n                }\r\n            }\r\n            \r\n            if (version != null) {\r\n                String theVersion = dmd.getDatabaseProductVersion().toLowerCase();\r\n                \r\n                log(\"Version = \" + theVersion, Project.MSG_VERBOSE);\r\n                if (theVersion == null || \r\n                    !(theVersion.startsWith(version) || \r\n                      theVersion.indexOf(\" \" + version) >= 0)) {\r\n                    log(\"Not the required version: \\\"\"+ version +\"\\\"\", Project.MSG_VERBOSE);\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        catch (SQLException e) {\r\n            // Could not get the required information\r\n            log(\"Failed to obtain required RDBMS information\", Project.MSG_ERR);\r\n            return false;\r\n        }\r\n        \r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * Exec the sql statement.\r\n     */\r\n    protected void execSQL(String sql, PrintStream out) throws SQLException {\r\n        // Check and ignore empty statements\r\n        if (\"\".equals(sql.trim())) return;\r\n        \r\n        try {  \r\n            totalSql++;\r\n            if (!statement.execute(sql)) {\r\n                log(statement.getUpdateCount()+\" rows affected\", \r\n                    Project.MSG_VERBOSE);\r\n            }\r\n            \r\n            if (print) {\r\n                printResults(out);\r\n            }\r\n            \r\n            SQLWarning warning = conn.getWarnings();\r\n            while(warning!=null){\r\n                log(warning + \" sql warning\", Project.MSG_VERBOSE);\r\n                warning=warning.getNextWarning();\r\n            }\r\n            conn.clearWarnings();\r\n            goodSql++;\r\n        }\r\n        catch (SQLException e) {\r\n            log(\"Failed to execute: \" + sql, Project.MSG_ERR);\r\n            if (!onError.equals(\"continue\")) throw e;\r\n            log(e.toString(), Project.MSG_ERR);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * print any results in the statement.\r\n     */\r\n    protected void printResults(PrintStream out) throws java.sql.SQLException {\r\n        ResultSet rs = null;\r\n        do {\r\n            rs = statement.getResultSet();\r\n            if (rs != null) {\r\n      \t        log(\"Processing new result set.\", Project.MSG_VERBOSE);\r\n                ResultSetMetaData md = rs.getMetaData();\r\n                int columnCount = md.getColumnCount();\r\n                StringBuffer line = new StringBuffer();\r\n                if (showheaders) {\r\n                    for (int col = 1; col < columnCount; col++) {\r\n                         line.append(md.getColumnName(col));\r\n                         line.append(\",\");\r\n                    }\r\n                    line.append(md.getColumnName(columnCount));\r\n                    out.println(line);\r\n                    line.setLength(0);\r\n                }\r\n                while (rs.next()) {\r\n                    boolean first = true;\r\n                    for (int col = 1; col <= columnCount; col++) {\r\n                        String columnValue = rs.getString(col);\r\n                        if (columnValue != null) {\r\n                            columnValue = columnValue.trim();\r\n                        }\r\n                         \r\n                        if (first) {\r\n                            first = false;\r\n                        }\r\n                        else {\r\n                            line.append(\",\");\r\n                        }\r\n                        line.append(columnValue);\r\n                    }\r\n                    out.println(line);\r\n                    line.setLength(0);\r\n                }\r\n            }\r\n        }\r\n        while (statement.getMoreResults());\r\n        out.println();\r\n    }\r\n\r\n    /**\r\n     * Enumerated attribute with the values \"continue\", \"stop\" and \"abort\"\r\n     * for the onerror attribute.  \r\n     */\r\n    public static class OnError extends EnumeratedAttribute {\r\n        public String[] getValues() {\r\n            return new String[] {\"continue\", \"stop\", \"abort\"};\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Contains the definition of a new transaction element.\r\n     * Transactions allow several files or blocks of statements\r\n     * to be executed using the same JDBC connection and commit\r\n     * operation in between.\r\n     */\r\n    public class Transaction {\r\n        private File tSrcFile = null;\r\n        private String tSqlCommand = \"\";\r\n\r\n        public void setSrc(File src) {\r\n            this.tSrcFile = src;\r\n        }\r\n\r\n        public void addText(String sql) {\r\n            this.tSqlCommand += sql;\r\n        }\r\n\r\n        private void runTransaction(PrintStream out) throws IOException, SQLException {\r\n            if (tSqlCommand.length() != 0) {\r\n                log(\"Executing commands\", Project.MSG_INFO);\r\n                runStatements(new StringReader(tSqlCommand), out);\r\n            }\r\n      \r\n            if (tSrcFile != null) {\r\n                log(\"Executing file: \" + tSrcFile.getAbsolutePath(), \r\n                    Project.MSG_INFO);\r\n                runStatements(new FileReader(tSrcFile), out);\r\n            }\r\n        }\r\n    }\r\n\r\n}  ", "id": 250, "time": "2000-12-04T04:15:48Z", "creator": "dev@tomcat.apache.org", "creation_time": "2000-12-04T04:15:48Z", "attachment_id": null}, {"count": 1, "tags": [], "bug_id": 273, "is_private": false, "text": "I am just looking into this bug report. The delimiter has already been added so\nthe only issue now is the need for delimiter type. Can you just explain the\n\"row\" type to me. From what I can tell, when the delimiter type is set to row,\nthe delimiter must be the only content on the line - i.e. the occurence of\ndelimiters on lines with other content is not treated as delimiters. ", "id": 3472, "time": "2001-07-07T01:00:13Z", "creator": "conor@apache.org", "creation_time": "2001-07-07T01:00:13Z", "attachment_id": null}, {"count": 2, "tags": [], "bug_id": 273, "attachment_id": null, "text": "OK, I went ahead and added the delimiter_type concept although I used a\ndifferent approach to its implementation. Please verify that this works for you.", "id": 3473, "time": "2001-07-07T03:24:04Z", "creator": "conor@apache.org", "creation_time": "2001-07-07T03:24:04Z", "is_private": false}]