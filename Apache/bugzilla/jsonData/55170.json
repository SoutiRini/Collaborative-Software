[{"count": 0, "tags": [], "bug_id": 55170, "text": "Created attachment 30511\nprofiling result screenshot\n\nI have a client which opens websocket connection to the echo server example. \nMy client sends unlimited number of binary messages. At some point, the connection is closed by a network component in the middle (load balancer). I can see exception thrown at the client side and the session is closed (see below <Exception 1>). So far this behaviour seems normal. However, after closing the session, I noticed there is something that uses CPU time, which after some profiling turned out to be a thread that executes CPU extensive code in an endless cycle (see below <Stack trace 1>)\n\n<Exception 1>\nHere is the exception that is thrown when the connection falls apart:\nException is :java.io.IOException: java.util.concurrent.ExecutionException: java.util.concurrent.ExecutionException: java.io.IOException: The specified network name is no longer available.\n\n\tat org.apache.tomcat.websocket.WsRemoteEndpointImplBase.startMessageBlock(WsRemoteEndpointImplBase.java:203)\n\tat org.apache.tomcat.websocket.WsRemoteEndpointImplBase.sendBytes(WsRemoteEndpointImplBase.java:112)\n\tat org.apache.tomcat.websocket.WsRemoteEndpointBasic.sendBinary(WsRemoteEndpointBasic.java:43)\n\tat com.sap.cloud.sample.helloworld.WebsocketsTestManager$TestThread.run(WebsocketsTestManager.java:257)\nCaused by: java.util.concurrent.ExecutionException: java.util.concurrent.ExecutionException: java.io.IOException: The specified network name is no longer available.\n\n\tat org.apache.tomcat.websocket.WsRemoteEndpointImplBase$FutureToSendHandler.get(WsRemoteEndpointImplBase.java:719)\n\tat org.apache.tomcat.websocket.WsRemoteEndpointImplBase.startMessageBlock(WsRemoteEndpointImplBase.java:201)\n\t... 3 more\nCaused by: java.util.concurrent.ExecutionException: java.io.IOException: The specified network name is no longer available.\n\n\tat sun.nio.ch.PendingFuture.get(PendingFuture.java:185)\n\tat org.apache.tomcat.websocket.AsyncChannelWrapperSecure$WriteTask.run(AsyncChannelWrapperSecure.java:209)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n\tat java.lang.Thread.run(Thread.java:722)\nCaused by: java.io.IOException: The specified network name is no longer available.\n\n\tat sun.nio.ch.Iocp.translateErrorToIOException(Iocp.java:309)\n\tat sun.nio.ch.Iocp.access$700(Iocp.java:46)\n\tat sun.nio.ch.Iocp$EventHandlerTask.run(Iocp.java:399)\n\t... 1 more\n\n\n<Stack trace 1>\nHere is the stacktrace of the thread consuming 100% CPU in an endless cycle:\n\nsun.security.ssl.SSLEngineImpl.unwrap(SSLEngineImpl.java:757)\njavax.net.ssl.SSLEngine.unwrap(SSLEngine.java:624)\norg.apache.tomcat.websocket.AsyncChannelWrapperSecure$ReadTask.run(AsyncChannelWrapperSecure.java:264)\njava.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\njava.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\njava.lang.Thread.run(Thread.java:722)", "id": 168174, "time": "2013-07-01T11:14:48Z", "creator": "s.boshev@gmail.com", "creation_time": "2013-07-01T11:14:48Z", "is_private": false, "attachment_id": 30511}, {"count": 1, "tags": [], "bug_id": 55170, "attachment_id": null, "id": 168236, "time": "2013-07-02T15:55:25Z", "creator": "markt@apache.org", "creation_time": "2013-07-02T15:55:25Z", "is_private": false, "text": "I can't reproduce this and trying to match the line numbers with the OpenJDK source doesn't quite line up. There is nothing that jumps out at me as causing this sort of problem. All together this makes it very difficult to figure out what the problem is from source code inspection alone.\n\nAre you able to put together a test client that demonstrates this against the WebSocket examples that ship with Tomcat? Ideally without the proxy closing the connection (killing or shutting down Tomcat should have the same effect)."}, {"count": 2, "tags": [], "bug_id": 55170, "attachment_id": null, "text": "I am using JDK 7 (build 1.7.0_21-b11).\n\nI did some debugging on this problem. It seems the code in AsyncChannelWrapperSecure$ReadTask.run() falls into endless cycle because the returned SSLEngineResult at line 276 is with status Status.BUFFER_OVERFLOW. Also the call to bytesProduced() returns 0 which results in read variable staying with value 0.\nThis leads to endless cycle in method AsyncChannelWrapperSecure$ReadTask.run().", "id": 168293, "time": "2013-07-05T14:35:29Z", "creator": "s.boshev@gmail.com", "creation_time": "2013-07-05T14:35:29Z", "is_private": false}, {"count": 3, "tags": [], "text": "Thanks for doing the extra digging. I can't see how a BufferOverflow is ever recoverable in those circumstances since there is no way to make any more space in the destination buffer.\n\nI've modified trunk to throw an exception in this case.", "attachment_id": null, "bug_id": 55170, "id": 168307, "time": "2013-07-05T18:37:20Z", "creator": "markt@apache.org", "creation_time": "2013-07-05T18:37:20Z", "is_private": false}]