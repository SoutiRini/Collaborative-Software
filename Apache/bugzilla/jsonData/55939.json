[{"count": 0, "tags": [], "text": "Created attachment 31164\nUnit test to replicate the problem\n\nI have a simple servlet which I'm running on Tomcat 8 trunk (1554057) with Java 7.  It's using a non-blocking IO WriteListener to write 8k blocks of static data to the response.  The number of blocks it will write is given as a request parameter.\n\nWhen I start out making individual requests to the server (1-1000 blocks) things are fine and those are handled without a problem.  However once I start to send multiple requests using JMeter, requests begin to fail.  It starts slowly with\nonly a few requests failing and then proceeds to the point where every request fails.  \n\nAt that point, Tomcat will serve JSP pages and Servlets that use blocking IO, but it will not serve any requests that use the non-blocking IO apis (ReadListener / WriteListener).  For example, if I try to hit the byte counter servlet or number writer servlet included in the examples then my browser will timeout or display the error \"java.lang.IllegalStateException: getOutputStream() has already been called for this response\".\n\nI put together a unit test that replicates the async context timeout issue.  Code is attached.  When run, you'll see that it processes some of the requests but fails due to a timeout.  Note 1 out of 5 times on my laptop the attached test will pass, so you may need to run it a couple times to see the issue.\n\nMore details on this email thread:  http://tomcat.markmail.org/message/jcgwqb7i5dgqtcqz\n\nThanks", "is_private": false, "bug_id": 55939, "id": 171954, "time": "2013-12-29T19:40:03Z", "creator": "dmikusa@gopivotal.com", "creation_time": "2013-12-29T19:40:03Z", "attachment_id": 31164}, {"attachment_id": null, "tags": [], "creator": "markt@apache.org", "is_private": false, "count": 1, "id": 171964, "time": "2013-12-30T19:46:18Z", "bug_id": 55939, "creation_time": "2013-12-30T19:46:18Z", "text": "Thanks for the test case. I've figured out what was going wrong and fixed it in trunk.\n\nThe test case is such that occasionally a request will fail. This happens when - for some reason (e.g. a GC pause) - the client stops reading for more than to 100ms timeout or doesn't start reading the response for more than 100ms.\n\nBecause the test case does regularly fail, I have not added it to the unit tests (now the issue is understood it should be possible to write a test case that checks this problem and always passes if and only if the problem is fixed).\n\nThe problem was that some of the flags used to handle non-blocking IO were not reset between requests. Once a request failed, all subsequent requests that used the same response object would also fail because the flags were set to indicate that the socket was registered for write with the Poller when that was not the case.\n\nThis has been fixed in r1554298.\n\nWith the fix in place I still see occasional failures but I only see single failures rather than all subsequent requests failing."}]