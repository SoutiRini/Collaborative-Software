[{"count": 0, "tags": [], "bug_id": 44193, "attachment_id": null, "id": 112709, "time": "2008-01-09T12:26:42Z", "creator": "kmradke@gmail.com", "creation_time": "2008-01-09T12:26:42Z", "is_private": false, "text": "The function apr_file_transfer_contents() called by apr_file_copy() in \nfile_io/unix/copy.c uses the standard BUFSIZ constant as a buffer size to copy \nfile contents.\n\nThis can be very inefficient on large files when done over a network due to \nthe numerous small packets sent.  This standard constant is typically very \nsmall.  (512 is the default on windows.)\n\nIt is suggested to use the existing APR_FILE_BUFSIZE contant which defaults to \na larger value of 4096 on Windows, or create a new constant such as \nAPR_COPY_BUFSIZE which can be configured to an appropriately large size per \nplatform.\n\nUsing a larger buffer can increase copy times of larger files by over 2x when \ndone on a network prototol such as NFS or SMB.\n\nThe performance problem was originally seen when using Subversion.  Some \nbackground discussion is available at these locations:\n\nhttp://subversion.tigris.org/servlets/ReadMsg?listName=dev&msgNo=82087\nhttp://subversion.tigris.org/servlets/ReadMsg?list=dev&msgNo=133582\n\nHere is the suggest patch:\n\n--- copy-old.c  2008-01-09 14:07:51.000068000 -0600\n+++ copy.c      2008-01-09 14:08:25.000121000 -0600\n@@ -54,7 +54,7 @@\n\n     /* Copy bytes till the cows come home. */\n     while (1) {\n-        char buf[BUFSIZ];\n+        char buf[APR_FILE_BUFSIZE];\n         apr_size_t bytes_this_time = sizeof(buf);\n         apr_status_t read_err;\n         apr_status_t write_err;"}, {"count": 1, "tags": [], "bug_id": 44193, "is_private": false, "text": "Fixed in trunk in r651174.", "id": 115828, "time": "2008-04-24T00:03:58Z", "creator": "bojan@rexursive.com", "creation_time": "2008-04-24T00:03:58Z", "attachment_id": null}]