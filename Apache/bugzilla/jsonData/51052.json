[{"count": 0, "tags": [], "bug_id": 51052, "text": "Created attachment 26875\nNullPointerException \n\nThe issue is that a NPE is thrown when a retrieve-marker retrieves a marker with only text content, when the retrieve-marker is a child of a table-cell. The real problem here is that there is no validation done on the retrieve marker to ensure that the markers child is a valid child of the retrieve markers parent (excuse the tongue twister), see XSL section 6.13.5:\n\n\"An fo:marker may contain any formatting objects that are permitted as a replacement of any fo:retrieve-marker or fo:retrieve-table-marker that retrieves the fo:marker's children.\"\n\nThough the spec doesn't specify how to handle this error, I am proposing that rather than throw an NPE, FOP logs a warning and ignores the marker. The spec doesn't specifically suggest that this kind of error is recoverable, but others might agree that throwing an NPE isn't the \"proper\" way to deal with this error.\n\nI've attached an example test FO and I'll attach a patch shortly.", "id": 145718, "time": "2011-04-12T05:09:14Z", "creator": "med1985@gmail.com", "creation_time": "2011-04-12T05:09:14Z", "is_private": false, "attachment_id": 26875}, {"count": 1, "attachment_id": null, "creator": "adelmelle@apache.org", "is_private": false, "id": 145752, "time": "2011-04-13T13:25:05Z", "bug_id": 51052, "creation_time": "2011-04-13T13:25:05Z", "tags": [], "text": "(In reply to comment #0)\n> The issue is that a NPE is thrown when a retrieve-marker retrieves a marker\n> with only text content, when the retrieve-marker is a child of a table-cell.\n> The real problem here is that there is no validation done on the retrieve\n> marker to ensure that the markers child is a valid child of the retrieve\n> markers parent (excuse the tongue twister), see XSL section 6.13.5:\n\nIndeed. Basic validation of child elements (i.e. FONode.validateChildNode()) is skipped when the marker is cloned. That seems like an oversight.\n\n> Though the spec doesn't specify how to handle this error, I am proposing that\n> rather than throw an NPE, FOP logs a warning and ignores the marker. \n\nExactly. That would remain consistent with the behavior during normal FO tree building.\nIf some bare text is entered in a fo:table-cell (or basically any FO that expects block-content), then it will be ignored, rather than reported as an error. To remain consistent, we would have to match this behavior. So, if the child node is a FOText and the retrieve-marker's parent is not a FObjMixed, we should at most issue a warning, and assume 'no content'.\n\n> The spec  doesn't specifically suggest that this kind of error is recoverable, but others\n> might agree that throwing an NPE isn't the \"proper\" way to deal with this\n> error.\n\nDefinitely. Rule of thumb: a NPE is *always* wrong. :-)\n\n> \n> I've attached an example test FO and I'll attach a patch shortly.\n\nThanks!"}, {"count": 2, "tags": [], "bug_id": 51052, "is_private": false, "text": "(In reply to comment #1)\n> ... If some bare text is entered in a fo:table-cell (or basically any FO that\n> expects block-content), then it will be ignored, rather than reported as an\n> error...\n\nNote: obviously only if the table-cell also contains at least an empty block. Otherwise, an error will be thrown, but it will be a complaint about an *empty* table-cell...\n\nThat might complicate matters slightly, as this case will also have to be reported as such if it happens during marker-retrieval.", "id": 145753, "time": "2011-04-13T13:35:07Z", "creator": "adelmelle@apache.org", "creation_time": "2011-04-13T13:35:07Z", "attachment_id": null}, {"count": 3, "attachment_id": null, "creator": "med1985@gmail.com", "is_private": false, "id": 145776, "time": "2011-04-14T04:08:22Z", "bug_id": 51052, "creation_time": "2011-04-14T04:08:22Z", "tags": [], "text": "After further looking into this, it appears as if the validateChildNode() was never intended to validate #PCDATA (or in our its object representation FOText). I say this because (as Andreas eluded to) FObjMixed is the progenitor of all the classes that create FOText. And these are the only objects that can accept #PCDATA as a child, so no validation really needs to be done on FOText, with respect to validateChildNode().\n\nHowever, o.a.f.fo.flow.Marker inherits from FObjMixed, and so when Marker.characters() is called, it blindly creates an FOText object without checking the validity of the #PCDATA. \n\nOne solution would be to store the character array (or as a String) and postpone the creation of the FOText node, until the Marker is retrieved by the retrieve marker, and thus validation can be done. \n\nThe point at which both the marker and the retrieve marker are both accessible seems to be in AbstractPageSequenceLayoutManager.resolveRetrieveMarker(). Arguably, this object shouldn't be responsible for validation, so if we inspect resolveRetrieveMarker(), we find that AbstractRetrieveMarker.bind() is responsible for binding a Marker to a RetrieveMarker. It is possible that, just prior to this, we validate the children of the marker and either invoke the creation of an FOText object or trigger an event to display the error.\n\nI thought this would be a quick fix, but now I'm not so sure. I don't know what the ramifications of postponing the creation of the FOText node will have. Nor if it's possible to postpone the creation since FObjMixed.flushText() seems to be responsible for binding the FOText object to a Block, and it's class private.\n\nI'm afraid I don't have the time at the moment to investigate this further, but if and when I come back to it, or if anyone else want's to take a stab at this, it may save some time."}, {"count": 4, "tags": [], "bug_id": 51052, "attachment_id": null, "id": 145789, "time": "2011-04-14T14:45:35Z", "creator": "adelmelle@apache.org", "creation_time": "2011-04-14T14:45:35Z", "is_private": false, "text": "(In reply to comment #3)\n\n> However, o.a.f.fo.flow.Marker inherits from FObjMixed, and so when\n> Marker.characters() is called, it blindly creates an FOText object without\n> checking the validity of the #PCDATA. \n\nYep, and at that point you cannot judge whether this will be appropriate, or not, in the retrieval context. It could be correct for some pages, but wrong on others, depending on where the retrieve-marker appears.\n\n> One solution would be to store the character array (or as a String) and\n> postpone the creation of the FOText node, until the Marker is retrieved by the\n> retrieve marker, and thus validation can be done. \n\nThat might be an option. Store the char array, and later on, trigger characters() on the retrieve-marker, if appropriate.\nHowever, I believe it is not strictly necessary. Also, the current approach of constructing the FOText early and using clones later, has the convenient side-effect that the text nodes are stored in sequence with the rest of the marker's child nodes.\n\nUltimately, FOText _is_ already basically just a CharBuffer with some extra information.\nThe only real gain would be that the FOText property references can be avoided, so it might still be worthwhile to investigate, but more as a performance enhancement.\n\nAs I see it, what we definitely lack:\n- a good/decent way to detect if a FO can have text children; I do not particularly like 'instanceof FObjMixed', since that does not cover possible extension classes that subclass FObj directly\n- (more general) proper validation of the marker's immediate children against the parent of the retrieve-marker\n\nThe first would solve this particular bug, as it was first reported. The NPE can be avoided simply by ignoring the FOText (see further below).\nThe second would be more comprehensive, to avoid similar issues in the future.\n\n> ... It is possible that, just prior to this, we validate the children of the\n> marker and either invoke the creation of an FOText object or trigger\n> an event to display the error.\n\nYes, and strictly speaking, this only needs to happen for the first level, as the other levels are already taken care of during normal FO tree building. \nThat is, if you have:\n\n<marker>\n  <inline><block>Some text</block></inline>\n</marker>\n\nThe only validation that is not done, is the inline against the parent of the retrieve-marker. The block will have been validated for the parent inline, though, so there is no need to repeat that step for every retrieval.\n\n> I thought this would be a quick fix, but now I'm not so sure.\n\nIf someone really needs a quick fix:\n\n* In AbstractRetrieveMarker cloneSingleNode(), before all else, first check\n\n        if (newParent == this && child instanceof FOText\n                && !(parent instanceof FObjMixed)) {\n            return;\n        }\n\n* and add a similar condition --if (parent instanceof FObjMixed) -- \n   around the call to handleWhiteSpaceFor() in cloneFromMarker().\n\nTested and confirmed that the attachment just renders as a blank page, without any complaints whatsoever. No more NPE, but this does not address the key issues mentioned above... :-/"}, {"count": 5, "attachment_id": null, "creator": "med1985@gmail.com", "is_private": false, "id": 145804, "time": "2011-04-15T04:40:37Z", "bug_id": 51052, "creation_time": "2011-04-15T04:40:37Z", "tags": [], "text": "> That might be an option. Store the char array, and later on, trigger\n> characters() on the retrieve-marker, if appropriate.\n> However, I believe it is not strictly necessary. Also, the current approach of\n> constructing the FOText early and using clones later, has the convenient\n> side-effect that the text nodes are stored in sequence with the rest of the\n> marker's child nodes.\n\nWell, I guess that would depend on how this was implemented. If we were being puritanical, one could argue that if FOText was an object representation of #PCDATA (which I'm pretty sure it is), then by creating a #PCDATA child in the FOTree, we are creating an invalid node. Regardless of whether we address this invalidation later or not, validation should be done before binding nodes to the FOTree; invalid nodes shouldn't be bound to the FOTree in the first place. One way to solve this, is by postponing the creation of the FOText while still keeping the char array. This means that the data is kept, while we're maintaining the validity of the FOTree. Though I appreciate, if we did this, we'd have to maintain the rest of the current behaviour so as not to introduce a regression.\n\n> \n> Ultimately, FOText _is_ already basically just a CharBuffer with some extra\n> information.\n> The only real gain would be that the FOText property references can be avoided,\n> so it might still be worthwhile to investigate, but more as a performance\n> enhancement.\n\nYou may be right, it might be prohibitively complex doing it the way I'm suggesting. It'd have to be investigated, this this is less about a performance enhancement since as you said, the creation of an FOText object is cheap.\n\n> \n> As I see it, what we definitely lack:\n> - a good/decent way to detect if a FO can have text children; I do not\n> particularly like 'instanceof FObjMixed', since that does not cover possible\n> extension classes that subclass FObj directly\n> - (more general) proper validation of the marker's immediate children against\n> the parent of the retrieve-marker\n\nYeah I agree, I was disinclined to use \"instanceof FObjMixed\".\n\n</snip>\n\nThanks for the assistance, but I think we're going to avoid the \"quick fix\". We've been bitten by them before."}, {"count": 6, "tags": [], "creator": "adelmelle@apache.org", "attachment_id": null, "text": "(In reply to comment #5)\n> Well, I guess that would depend on how this was implemented. If we were being\n> puritanical, one could argue that if FOText was an object representation of\n> #PCDATA (which I'm pretty sure it is), then by creating a #PCDATA child in the\n> FOTree, we are creating an invalid node. \n\nNo, we're not. #PCDATA is always a valid child node for a marker (i.e. the content model for a marker is \"(#PCDATA|%inline;|%block;)*\"). \nIt will only, potentially, /become/ invalid in the retrieval context.\n\nIn the same sense, one could reason that the marker's child blocks, tables, lists etc. all should not be created, and we should store the FO source rather than parsing them into FONodes.\nThere might be good points for, but also against.", "id": 145818, "time": "2011-04-16T14:35:44Z", "bug_id": 51052, "creation_time": "2011-04-16T14:35:44Z", "is_private": false}, {"count": 7, "tags": [], "bug_id": 51052, "text": "(In reply to comment #6)\n> In the same sense, one could reason that the marker's child blocks, tables,\n> lists etc. all should not be created, and we should store the FO source rather\n> than parsing them into FONodes.\n> There might be good points for, but also against.\n\nNote: I am not necessarily against this myself. It would be pretty cool, actually, if we were to store only the raw FO source of the marker-subtree, in a CharBuffer, to be parsed later. At first glance, it could turn out to be slightly more efficient in terms of memory footprint. I'd need to see proof to be certain, but it might...", "id": 145819, "time": "2011-04-16T14:54:27Z", "creator": "adelmelle@apache.org", "creation_time": "2011-04-16T14:54:27Z", "is_private": false, "attachment_id": null}, {"count": 8, "tags": [], "creator": "adelmelle@apache.org", "attachment_id": null, "is_private": false, "id": 145820, "time": "2011-04-16T16:06:21Z", "bug_id": 51052, "creation_time": "2011-04-16T16:06:21Z", "text": "(In reply to comment #6)\n> > Well, I guess that would depend on how this was implemented. If we were being\n> > puritanical, one could argue that if FOText was an object representation of\n> > #PCDATA (which I'm pretty sure it is), then by creating a #PCDATA child in the\n> > FOTree, we are creating an invalid node. \n\n> No, we're not. #PCDATA is always a valid child node for a marker (i.e. the\n> content model for a marker is \"(#PCDATA|%inline;|%block;)*\"). \n> It will only, potentially, /become/ invalid in the retrieval context.\n\nI suddenly realize this needs more explanation, as there is obviously the remark about the retrieve-marker's parent...\n\nLooking at it from FOP's perspective, at parse-time (i.e. when the FO tree is built), there is no way to know when --or even if-- a marker will actually be retrieved. Granted, we _could_ decide to throw an error if there is even the smallest probability of a mismatch, but we would never know for certain whether it would actually cause an error. \nI am far from convinced that this justifies the added computational complexity of walking up the tree, and checking all static-contents for a retrieve-marker that _might_ retrieve a particular marker.\n\nWhat I mean is: it is not incorrect/invalid to create the #PCDATA node as a child of the marker. However, to concede to your point, it is definitely incorrect to blindly copy it, and re-bind it to the wrong parent.\n\n(In reply tom comment #7)\n> Note: I am not necessarily against this myself. It would be pretty cool,\n> actually, if we were to store only the raw FO source of the marker-subtree, in\n> a CharBuffer, to be parsed later. At first glance, it could turn out to be\n> slightly more efficient in terms of memory footprint. I'd need to see proof to\n> be certain, but it might...\n\n... and after some tests, I can see that this is definitely not always so cool. ;-)\nA lot depends on the actual structure of the subtree. FO is quite verbose, so even a small table already costs quite some chars, which does not always weigh up to simply instantiating the FONodes to store the data.\n\nIf we're really serious about further optimization, then in terms of footprint, the most optimal situation may just be to create a generic MarkerDescendant node type, and convert those into the proper FONode subclass later, if and when they are actually retrieved.\nThat is: as opposed to the current approach of immediately instantiating the proper type at parse time, and cloning those instances later, when the area tree is built.\n\nStrictly speaking, in the current process, some space is still taken up by the unused references for members in flow.Block, flow.Table, FOText... That space is actually wasted, since the specified properties/attributes are stored in a Map that is associated with the Marker. \nIf we strip the MarkerDescendants to be lean, basic FObj instances, that might save some in larger documents with a lot of markers, especially if only a relatively small amount are actually retrieved."}, {"count": 9, "tags": [], "creator": "med1985@gmail.com", "attachment_id": null, "text": "> I am far from convinced that this justifies the added computational complexity\n> of walking up the tree, and checking all static-contents for a retrieve-marker\n> that _might_ retrieve a particular marker.\n\nI am of the same frame of mind, I think that's neither feasible nor really necessary.\n\n> A lot depends on the actual structure of the subtree. FO is quite verbose, so\n> even a small table already costs quite some chars, which does not always weigh\n> up to simply instantiating the FONodes to store the data.\n> \n> If we're really serious about further optimization, then in terms of footprint,\n> the most optimal situation may just be to create a generic MarkerDescendant\n> node type, and convert those into the proper FONode subclass later, if and when\n> they are actually retrieved.\n> That is: as opposed to the current approach of immediately instantiating the\n> proper type at parse time, and cloning those instances later, when the area\n> tree is built.\n\nI think implementing this would/could get fairly involved. I'm not sure an intermediary object would be the proper approach. If we want the FOTree to be an object manifestation of the FO, adding objects types that aren't a part of the FO spec would break it's adherence with the spec.\n\nI hadn't considered that the markers can have a hierarchy of children, or at least I hadn't considered that this could be several levels deep rather than just #PCDATA or a single-level block or two. That would make postponing instantiating any children unnecessarily difficult. It would also mean that we're parsing FO in the layout manager, which I don't think there's a precedent for, nor is that the duty of the layout manager. I'm beginning to think the initial approach, validating in AbstractRetrieveMarker as it binds objects to itself may be the way to go. We may be forced to do an \"instanceof FObjMixed\", to validate #PCDATA separately.\n\n> \n> Strictly speaking, in the current process, some space is still taken up by the\n> unused references for members in flow.Block, flow.Table, FOText... That space\n> is actually wasted, since the specified properties/attributes are stored in a\n> Map that is associated with the Marker. \n> If we strip the MarkerDescendants to be lean, basic FObj instances, that might\n> save some in larger documents with a lot of markers, especially if only a\n> relatively small amount are actually retrieved.\n\nThat would mean adding an object that wasn't a part of the FO spec into the FOTree. I'm not sure that's a good idea. It would be fairly confusing for anyone looking at this at a later date, they'd see MarkerDescendants, refer to the spec only to find it not there. No amount of commenting code would prevent this.", "id": 145832, "time": "2011-04-18T03:42:47Z", "bug_id": 51052, "creation_time": "2011-04-18T03:42:47Z", "is_private": false}, {"count": 10, "attachment_id": null, "creator": "gadams@apache.org", "text": "resetting P2 open bugs to P3 pending further review", "id": 157340, "time": "2012-04-07T01:41:40Z", "bug_id": 51052, "creation_time": "2012-04-07T01:41:40Z", "tags": [], "is_private": false}, {"count": 11, "attachment_id": null, "creator": "gadams@apache.org", "text": "(In reply to comment #0)\n> I've attached an example test FO and I'll attach a patch shortly.\n\nmehdi, any chance you'll be posting a patch?", "id": 157675, "time": "2012-04-08T08:40:37Z", "bug_id": 51052, "creation_time": "2012-04-08T08:40:37Z", "tags": [], "is_private": false}, {"count": 12, "attachment_id": null, "creator": "med1985@gmail.com", "text": "(In reply to comment #11)\n> (In reply to comment #0)\n> > I've attached an example test FO and I'll attach a patch shortly.\n> \n> mehdi, any chance you'll be posting a patch?\n\nNo patch. I was just posting this as a known bug, quite nuanced, but as always, when I get time, I'll look further into this issue.", "id": 157696, "time": "2012-04-08T09:13:30Z", "bug_id": 51052, "creation_time": "2012-04-08T09:13:30Z", "tags": [], "is_private": false}]