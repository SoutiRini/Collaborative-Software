[{"count": 0, "tags": [], "bug_id": 58023, "text": "Memory leak occur because a reference of entry.manifest is never removed.\n\nProblem:\n1 - ${class}.class.getResource( ${resource.name1} );\n2 - JarFile load a manifest.\n3- resourceEntries put a new ResourceEntry with a manifest reference.\n4 - ${class}.class.getResource( ${resource.name2} );\n5 - resourceEntries put a new ResourceEntry with a manifest reference. Manifest contains ~20MB, but, no problem because the JarFile is the same reference. In other words, only one Manifest in the Heap space.\n6 - wait for 90000 milliseconds.\n7 - ${class}.class.getResource( ${resource.name3} );\n8 - WebappClassLoader.closeJARs because time is elapsed 90000 milliseconds and load a new JarFile instances.\n9 - JarFile load a new manifest.\n10 - resourceEntries put a new ResourceEntry with a new manifest reference.\n11 - wait for 90000 milliseconds\n...\nAnd this will be memory leak in little time (See resourceEntries.png).\nIn attachment, a scenario to simulate this problem.\n\nPS.: A jar file need to be signed for accelerate leak, because of Manifest.entries ~5MB (see manifests.png) retained heap (in test case, but, my real app is ~20MB).\nI attached the heap dump used in this test case (heap.zip).\n\nSolution:\nAlways release the manifest reference.\n\nWorkaround:\npublic class WebappClassLoader\n    extends \n        org.apache.catalina.loader.WebappClassLoader\n{\n    @Override\n    public InputStream getResourceAsStream( String name )\n    {\n        InputStream in = super.getResourceAsStream( name ); \n        \n        ResourceEntry entry = resourceEntries.get( name );\n        \n        if ( entry != null )\n        {\n            // prevent a memory leak\n            entry.manifest = null;\n            entry.certificates = null;\n        }\n        \n        return in;\n    }\n    \n    @Override\n    public URL getResource( String name )\n    {\n        URL url = super.getResource( name );\n        \n        ResourceEntry entry = resourceEntries.get( name );\n        \n        if ( entry != null )\n        {\n            // prevent a memory leak\n            entry.manifest = null;\n            entry.certificates = null;\n        }\n        \n        return url;\n    }\n}", "id": 183461, "time": "2015-06-11T12:59:17Z", "creator": "mn@interact.com.br", "creation_time": "2015-06-11T12:59:17Z", "is_private": false, "attachment_id": null}, {"count": 1, "attachment_id": null, "bug_id": 58023, "text": "Thanks for the report. Strictly I would class this as excessive memory usage rather than a leak since a) there is an upper limit to the memory that will be used and b) the memory will be recovered once the application has been undeployed. Regardless of how it is classified, it is a bug.\n\nI have applied an alternative fix (only request and retain the manifest while loading a class and then drop it) that should achieve the same ends for trunk (9.0.x), 8.0.x (for 8.0.24 onwards) and 7.0.x (for 7.0.63 onwards).", "id": 183565, "time": "2015-06-16T19:25:43Z", "creator": "markt@apache.org", "creation_time": "2015-06-16T19:25:43Z", "tags": [], "is_private": false}]