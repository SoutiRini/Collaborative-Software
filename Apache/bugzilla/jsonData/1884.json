[{"count": 0, "tags": [], "creator": "larrybar@eng.auburn.edu", "is_private": false, "id": 2637, "attachment_id": null, "bug_id": 1884, "creation_time": "2001-05-24T07:22:46Z", "time": "2001-05-24T07:22:46Z", "text": "Using PatternMatcherInput(String input, int begin, int length) with Awk\nrequires  length = length_of_substring + begin  instead of  length_of_substring  \nas the documentation indicates. Also, MatchResult beginOffset(int) and \nendOffset(int) return offsets from  -begin  instead of zero. There is no problem \nwith Perl5.\n\n\n   import org.apache.oro.text.regex.*;\n   import org.apache.oro.text.awk.*;\n\n\n   public class AwkBug {\n      public static void main(String[] args) {\n         for(int begin = 0; begin < 7; begin += 2) {\n            System.out.println(\"\\nbegin: \" + begin);\n            System.out.println(\"   Perl5:\");\n            match(false, false, begin);\n            System.out.println(\"   Awk:\");\n            match(true, false, begin);\n            System.out.println(\"   Awk with work-arounds:\");\n            match(true, true, begin); }\n      }\n   \n   \n      public static void match(boolean awk_pattern, boolean awk_fix,\n      int begin) {\n         Pattern pattern = null;\n         PatternCompiler compiler;\n         if(awk_pattern)\n            compiler = new AwkCompiler();\n         else\n            compiler = new Perl5Compiler();\n         try {\n            pattern = compiler.compile(\"a\", 0); }\n            catch(MalformedPatternException e) {\n               return;\n            }\n      \n         String text = \" a  a   a   a\";\n         PatternMatcherInput input = new PatternMatcherInput(text, begin,\n         text.length() - begin + (awk_fix?begin:0));\n         PatternMatcher matcher;\n         if(awk_pattern)\n            matcher = new AwkMatcher();\n         else\n            matcher = new Perl5Matcher();\n      \n         while(true) {\n            MatchResult mr = null;\n            if(matcher.contains(input, pattern))\n               mr = matcher.getMatch();\n            if(mr == null)\n               break;\n         \n            int groups = mr.groups();\n            for(int i = (groups == 1)?0:1; i < groups; i++)\n               if(mr.beginOffset(i) >= 0) {\n                  System.out.println(\"      match begin \" +\n                     (mr.beginOffset(i) - (awk_fix?begin:0)) +\n                     \"  end \" +\n                     (mr.endOffset(i) - (awk_fix?begin:0)));\n                  break; }\n         }\n      }\n   }"}, {"count": 1, "tags": [], "bug_id": 1884, "text": "This bug was likely caused when the last changes to PatternMatcherInput were\nmade.  Even though Perl5Matcher was updated, AwkMatcher was probably not.\nThe bug is being assigned with the intent of working on it over the weekend\nof 06/16.", "id": 2897, "time": "2001-06-12T19:01:32Z", "creator": "dfs@apache.org", "creation_time": "2001-06-12T19:01:32Z", "is_private": false, "attachment_id": null}, {"count": 2, "tags": [], "bug_id": 1884, "attachment_id": null, "id": 3541, "time": "2001-07-10T05:43:25Z", "creator": "dfs@apache.org", "creation_time": "2001-07-10T05:43:25Z", "is_private": false, "text": "Fixed the problem.  Requesting that the original bug reporter verify the fix\nbefore closing the bug report.  For the benefit of the bug reporter, I am\nincluding the diff.\n\ndfs         01/07/10 05:39:23\n\n  Modified:    src/java/org/apache/oro/text/awk AwkMatcher.java\n  Log:\n  Fixed the following bug reported by larrybar@eng.auburn.edu:\n  \n    Using PatternMatcherInput(String input, int begin, int length) with Awk\n    requires  length = length_of_substring + begin  instead of\n    length_of_substring as the documentation indicates. Also, MatchResult\n    beginOffset(int) and endOffset(int) return offsets from  -begin instead\n    of zero. There is no problem with Perl5.\n  \n  The fix is klugey and indicative of a need to redesign and reimplement\n  the AwkMatcher input representation and traversal system.\n  \n  PR: 1884\n  \n  Revision  Changes    Path\n  1.6       +45 -31   \njakarta-oro/src/java/org/apache/oro/text/awk/AwkMatcher.java\n  \n  Index: AwkMatcher.java\n  ===================================================================\n  RCS file:\n/home/cvs/jakarta-oro/src/java/org/apache/oro/text/awk/AwkMatcher.java,v\n  retrieving revision 1.5\n  retrieving revision 1.6\n  diff -u -r1.5 -r1.6\n  --- AwkMatcher.java\t2001/05/20 23:55:21\t1.5\n  +++ AwkMatcher.java\t2001/07/10 12:39:18\t1.6\n  @@ -58,7 +58,7 @@\n    */\n   \n   /*\n  - * $Id: AwkMatcher.java,v 1.5 2001/05/20 23:55:21 dfs Exp $\n  + * $Id: AwkMatcher.java,v 1.6 2001/07/10 12:39:18 dfs Exp $\n    */\n   import java.io.*;\n   \n  @@ -90,6 +90,15 @@\n     private AwkPattern __awkPattern;\n     private int __offsets[] = new int[2];\n   \n  +  /**\n  +   * A kluge variable to make PatternMatcherInput matches work when\n  +   * their begin offset is non-zero.  This kluge is caused by the\n  +   * misguided notion that AwkStreamInput could be overloaded to do\n  +   * both stream and fixed buffer matches.  The whole input representation\n  +   * scheme has to be scrapped and redone. -- dfs 2001/07/10\n  +   */\n  +  private int __beginOffset;\n  +\n     public AwkMatcher() {\n       __scratchBuffer = new AwkStreamInput();\n       __scratchBuffer._endOfStreamReached = true;\n  @@ -120,7 +129,7 @@\n   \n       __scratchBuffer._buffer       = input;\n       __scratchBuffer._bufferSize   = input.length;\n  -    __scratchBuffer._bufferOffset = 0;\n  +    __scratchBuffer._bufferOffset = __beginOffset = 0;\n       __scratchBuffer._endOfStreamReached = true;\n       __streamSearchBuffer = __scratchBuffer;\n       __offsets[0] = offset;\n  @@ -203,7 +212,7 @@\n   \n       __awkPattern = (AwkPattern)pattern;\n       __scratchBuffer._buffer       = input.getBuffer();\n  -    __scratchBuffer._bufferOffset = input.getBeginOffset();\n  +    __scratchBuffer._bufferOffset = __beginOffset = input.getBeginOffset();\n       __offsets[0] = input.getCurrentOffset();\n   \n       __scratchBuffer._bufferSize   = input.length();\n  @@ -254,7 +263,7 @@\n       __awkPattern = (AwkPattern)pattern;\n       __scratchBuffer._buffer       = input;\n       __scratchBuffer._bufferSize   = input.length;\n  -    __scratchBuffer._bufferOffset = 0;\n  +    __scratchBuffer._bufferOffset = __beginOffset = 0;\n       __scratchBuffer._endOfStreamReached = true;\n       __streamSearchBuffer = __scratchBuffer;\n       __offsets[0] = 0;\n  @@ -331,7 +340,7 @@\n       __awkPattern = (AwkPattern)pattern;\n       __scratchBuffer._buffer       = input.getBuffer();\n       __scratchBuffer._bufferSize   = input.length();\n  -    __scratchBuffer._bufferOffset = input.getBeginOffset();\n  +    __scratchBuffer._bufferOffset = __beginOffset = input.getBeginOffset();\n       __offsets[0] = input.getBeginOffset();\n       __scratchBuffer._endOfStreamReached = true;\n       __streamSearchBuffer = __scratchBuffer;\n  @@ -391,7 +400,7 @@\n   \n       __scratchBuffer._buffer       = input;\n       __scratchBuffer._bufferSize   = input.length;\n  -    __scratchBuffer._bufferOffset = 0;\n  +    __scratchBuffer._bufferOffset = __beginOffset = 0;\n       __scratchBuffer._endOfStreamReached = true;\n       __streamSearchBuffer = __scratchBuffer;\n       __lastMatchedBufferOffset = 0;\n  @@ -499,23 +508,20 @@\n     public boolean contains(PatternMatcherInput input, Pattern pattern) {\n       __awkPattern = (AwkPattern)pattern;\n       __scratchBuffer._buffer       = input.getBuffer();\n  -    __scratchBuffer._bufferOffset = input.getBeginOffset();\n  +    __scratchBuffer._bufferOffset = __beginOffset = input.getBeginOffset();\n       __lastMatchedBufferOffset = input.getCurrentOffset();\n   \n       // Begin anchor requires match occur at beginning of input\n       // No need to adjust current offset if no match found.\n       if(__awkPattern._hasBeginAnchor) {\n  -      int begin;\n  -\n  -      begin = input.getBeginOffset();\n  -      if(begin != __lastMatchedBufferOffset ||\n  -\t !__awkPattern._fastMap[__scratchBuffer._buffer[begin]]) {\n  +      if(__beginOffset != __lastMatchedBufferOffset ||\n  +\t !__awkPattern._fastMap[__scratchBuffer._buffer[__beginOffset]]) {\n   \t__lastMatchResult = null;\n   \treturn false;\n         }\n       }\n   \n  -    __scratchBuffer._bufferSize   = input.length();\n  +    __scratchBuffer._bufferSize = input.length();\n       __scratchBuffer._endOfStreamReached = true;\n       __streamSearchBuffer = __scratchBuffer;\n       try {\n  @@ -612,6 +618,7 @@\n   \n       __lastMatchedBufferOffset = input._currentOffset;\n       __streamSearchBuffer = input;\n  +    __beginOffset = 0;\n       _search();\n       input._currentOffset = __lastMatchedBufferOffset;\n       return (__lastMatchResult != null);\n  @@ -620,13 +627,15 @@\n   \n     private int __streamMatchPrefix() throws IOException {\n       int token, current = AwkPattern._START_STATE, lastState, transition;\n  -    int offset, initialOffset;\n  +    int offset, initialOffset, maxOffset;\n       int lastMatchedOffset = -1;\n       int[] tstateArray;\n   \n       offset = initialOffset = __offsets[0];\n  +    maxOffset = __streamSearchBuffer._bufferSize + __beginOffset;\n  +\n     test:\n  -    while(offset < __streamSearchBuffer._bufferSize) {\n  +    while(offset < maxOffset) {\n         token = __streamSearchBuffer._buffer[offset++];\n   \n         if(current < __awkPattern._numStates) {\n  @@ -638,25 +647,27 @@\n   \t  __awkPattern._createNewState(lastState, token, tstateArray);\n   \t  current = tstateArray[token];\n   \t}\n  +\n   \tif(current == AwkPattern._INVALID_STATE){\n   \t  break test;\n  -\t}\n  -\telse if(__awkPattern._endStates.get(current)){\n  +\t} else if(__awkPattern._endStates.get(current)){\n   \t  lastMatchedOffset = offset;\n   \t}\n  -\tif(offset == __streamSearchBuffer._bufferSize){\n  -\t  offset = __streamSearchBuffer._reallocate(initialOffset);\n   \n  +\tif(offset == maxOffset){\n  +\t  offset =\n  +\t    __streamSearchBuffer._reallocate(initialOffset) + __beginOffset;\n  +\t  \n  +\t  maxOffset = __streamSearchBuffer._bufferSize + __beginOffset;\n  +\n   \t  // If we're at the end of the stream, don't reset values\n  -\t  if(offset != __streamSearchBuffer._bufferSize){\n  +\t  if(offset != maxOffset){\n   \t    if(lastMatchedOffset != -1)\n   \t      lastMatchedOffset-=initialOffset;\n   \t    initialOffset = 0;\n   \t  }\n  -\n   \t}\n  -      }\n  -      else\n  +      } else\n   \tbreak;\n       }\n   \n  @@ -669,7 +680,7 @@\n       // End anchor requires match occur at end of input\n       if(__awkPattern._hasEndAnchor &&\n          (!__streamSearchBuffer._endOfStreamReached ||\n  -\tlastMatchedOffset < __streamSearchBuffer._bufferSize))\n  +\tlastMatchedOffset < __streamSearchBuffer._bufferSize + __beginOffset))\n         return -1;\n   \n       return (lastMatchedOffset - initialOffset);\n  @@ -685,7 +696,8 @@\n       __lastMatchResult = null;\n   \n       while(true){\n  -      if(__lastMatchedBufferOffset >= __streamSearchBuffer._bufferSize){\n  +      if(__lastMatchedBufferOffset >= \n  +\t __streamSearchBuffer._bufferSize + __beginOffset) {\n   \tif(__streamSearchBuffer._endOfStreamReached){\n   \t  // Get rid of reference now that it should no longer be used.\n   \t  __streamSearchBuffer = null;\n  @@ -697,8 +709,8 @@\n   \t}\n         }\n   \n  -      for(position=__lastMatchedBufferOffset;\n  -\t  position < __streamSearchBuffer._bufferSize;\n  +      for(position = __lastMatchedBufferOffset;\n  +\t  position < __streamSearchBuffer._bufferSize + __beginOffset;\n   \t  position = __offsets[0] + 1) {\n   \n   \t__offsets[0] = position;\n  @@ -707,16 +719,14 @@\n   \n   \t  __lastMatchResult  = new AwkMatchResult(\n   \t  new String(__streamSearchBuffer._buffer, __offsets[0],\n  -\t\t     tokensMatched),\n  -\t  __offsets[0] + __streamSearchBuffer._bufferOffset);\n  +\t\t     tokensMatched), __offsets[0]);\n   \n   \t  __lastMatchedBufferOffset =\n   \t    (tokensMatched > 0 ? __offsets[1] + 1 : __offsets[0] + 1);\n   \n   \t  return;\n   \t} else if(__awkPattern._matchesNullString) {\n  -\t  __lastMatchResult  = new AwkMatchResult(new String(),\n  -\t\t\t  position + __streamSearchBuffer._bufferOffset);\n  +\t  __lastMatchResult  = new AwkMatchResult(new String(), position);\n   \n   \t  __lastMatchedBufferOffset = position + 1;\n   \n  @@ -741,3 +751,7 @@\n     public MatchResult getMatch() { return __lastMatchResult; }\n   \n   }\n  +\n  +\n  +\n  +"}, {"count": 3, "tags": [], "text": "Bug was fixed and no one has reported any problems with the fix.  Therefore\nclosing bug report.", "is_private": false, "bug_id": 1884, "id": 5829, "time": "2001-09-20T07:40:16Z", "creator": "dfs@apache.org", "creation_time": "2001-09-20T07:40:16Z", "attachment_id": null}]