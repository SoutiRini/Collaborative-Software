[{"count": 0, "tags": [], "text": "While deploying a complex webapp that took very long to initialize (using Spring, lots of filesystem overhead, don't ask), we found that all user requests got blocked in ApplicationContext.getContext, while trying to determine the current web application via ContainerBase.findChild(). This synchronizes on the HashMap ContainerBase.children, which was being locked by the addChild() method that was doing the webapp deployment:\n\n...\n\t- locked <0x000000055070f778> (a java.util.HashMap)\n\tat org.apache.catalina.core.ContainerBase.access$000(ContainerBase.java:124)\n\tat org.apache.catalina.core.ContainerBase$PrivilegedAddChild.run(ContainerBase.java:146)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:777)\n\tat org.apache.catalina.core.StandardHost.addChild(StandardHost.java:601)\n\tat blackboard.tomcat.servletcontainer.TomcatContainerAdapter.registerWebApp(TomcatContainerAdapter.java:200)\n\nI found that addChild() synchronizes for so long on this collection because it wants to know whether the child container deployed successfully before adding it to the collection, and it checks at the beginning whether it was already in the collection before trying to deploy it. Both of those seem like valid reasons, however it is clearly unacceptable to block the collection (and thus all user requests!) while deploying a new webapp, which can take any amount of time, including hanging on OS/filesystem locks.\n\nHere's what all those other threads looked like:\n<thread details here> waiting for monitor entry [0x0000000058b89000]\n   java.lang.Thread.State: BLOCKED (on object monitor)\n\tat org.apache.catalina.core.ContainerBase.findChild(ContainerBase.java:855)\n\t- waiting to lock <0x000000055070f778> (a java.util.HashMap)\n\tat org.apache.catalina.core.ApplicationContext.getContext(ApplicationContext.java:211)\n\tat sun.reflect.GeneratedMethodAccessor524.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:606)\n\tat org.apache.catalina.core.ApplicationContextFacade$1.run(ApplicationContextFacade.java:456)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat org.apache.catalina.core.ApplicationContextFacade.executeMethod(ApplicationContextFacade.java:454)\n\tat org.apache.catalina.core.ApplicationContextFacade.invokeMethod(ApplicationContextFacade.java:402)\n\tat org.apache.catalina.core.ApplicationContextFacade.doPrivileged(ApplicationContextFacade.java:374)\n\tat org.apache.catalina.core.ApplicationContextFacade.getContext(ApplicationContextFacade.java:122)\n...<varying application code here>...\n\n\nI see two possible approaches to address this:\n\nA) Use a threadsafe ConcurrentHashMap instead of synchronizing on a plain old HashMap. Means we'd need to be sure that the picture of which child contexts are available at a given time doesn't have to always be consistent among all threads. I cannot judge that.\n\nB) Fix addChild to use a flag to mark the child as initializing, and check the flag at the beginning, after verifying that it's not yet in the collection. If it's not there yet, and the flag isn't set yet, set the flag, then try to deploy the webapp. Once that's successful, add it to the collection, then unset the flag. Here we'd need to synchronize on the collection only very briefly - for the check at the start and for the addition at the end. The rest of the code would just need to synchronize on the flag, or on the child object itself, not on the collection, which it is not interacting with in any way while deploying the webapp.", "attachment_id": null, "id": 175916, "creator": "vkleinschmidt@blackboard.com", "time": "2014-06-19T21:24:58Z", "bug_id": 56648, "creation_time": "2014-06-19T21:24:58Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 56648, "text": "Nevermind, grepcode shows that this issue was actually already fixed back in tomcat 7.0.5.\n\nI just haven't seen any reports of it anywhere.", "id": 175936, "time": "2014-06-20T19:14:49Z", "creator": "vkleinschmidt@blackboard.com", "creation_time": "2014-06-20T19:14:49Z", "is_private": false, "attachment_id": null}, {"count": 2, "tags": [], "creator": "markt@apache.org", "attachment_id": null, "id": 176283, "time": "2014-07-07T21:45:56Z", "bug_id": 56648, "creation_time": "2014-07-07T21:45:56Z", "is_private": false, "text": "The 7.0.x fix to be reviewed for backport is http://svn.apache.org/viewvc?view=revision&revision=1036918"}, {"count": 3, "tags": [], "bug_id": 56648, "is_private": false, "id": 176309, "attachment_id": null, "creator": "markt@apache.org", "creation_time": "2014-07-09T11:47:44Z", "time": "2014-07-09T11:47:44Z", "text": "Port of fix proposed for 6.0.x."}, {"count": 4, "attachment_id": null, "bug_id": 56648, "is_private": false, "id": 176744, "time": "2014-07-29T09:13:18Z", "creator": "markt@apache.org", "creation_time": "2014-07-29T09:13:18Z", "tags": [], "text": "This has been fixed in 6.0.x for 6.0.42 onwards."}, {"attachment_id": null, "tags": [], "bug_id": 56648, "is_private": false, "count": 5, "id": 176850, "time": "2014-08-03T02:58:28Z", "creator": "vkleinschmidt@blackboard.com", "creation_time": "2014-08-03T02:58:28Z", "text": "Thanks a bunch!"}]