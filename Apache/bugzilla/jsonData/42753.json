[{"count": 0, "tags": [], "bug_id": 42753, "attachment_id": null, "id": 104760, "time": "2007-06-27T05:21:53Z", "creator": "sebster@sebster.com", "creation_time": "2007-06-27T05:21:53Z", "is_private": false, "text": "Tomcat version: 6.0.13 (no 6.0.13 available in the version field)\n\nWhen trying to process data in CometProcessor.event() either during the BEGIN\nevent or during the READ event, it is impossible to guarantee that all data has\nbeen read before returning (since new data may arrive between the last statement\nbefore the return, and the return statement itself). However, the\nCoyoteProcessor does this check:\n\n } else if (!error && read && request.getAvailable()) {\n    // If this was a read and not all bytes have been read, or if no data\n    // was read from the connector, then it is an error\n    error = true;\n    log.error(sm.getString(\"coyoteAdapter.read\"));\n } \n\ncausing a severe error and the Comet request to break when this race condition\nmanifests itself.\n\nI am using the following code according to the aio.html description to read data\nin my comet event handler:\n\n  while (request.getInputStream().available() > 0) {\n     // read some data\n  }\n  // ***** NO MORE DATA AVAILABLE\n  return;\n\nAnd I am experiencing the error as described in certain conditions (rapid\narrival of fragmented data):\n\nSEVERE: The servlet did not read all available bytes during the processing of\nthe read event"}, {"count": 1, "tags": [], "bug_id": 42753, "attachment_id": null, "id": 104776, "time": "2007-06-27T11:00:55Z", "creator": "remm@apache.org", "creation_time": "2007-06-27T11:00:55Z", "is_private": false, "text": "available() does not make any socket access to see if bytes have arrived, so the\nscenario you describe cannot happen (if available returns 0, it will continue\nreturning 0 until the next read event). If the message you saw is logged,\nCometAdapter.event will return false, which will lead to closing the connection,\nnot causing a loop.\n\nMy only theory is that you're doing asynchronous reads, which is not allowed,\nand you'll need to look into this further.\n\nWhat does \"(no 6.0.13 available in the version field)\" mean ?"}, {"count": 2, "tags": [], "bug_id": 42753, "attachment_id": null, "id": 104781, "time": "2007-06-27T12:35:36Z", "creator": "sebster@sebster.com", "creation_time": "2007-06-27T12:35:36Z", "is_private": false, "text": "I have very explicit logging and I'm 100% certain that I'm not doing any async\nreads. In fact, from the log I sent to the user list before reporting this as a\nbug you can see that everything is happening in 1 thread, namely http-8080-exec-4:\n\n2007-06-26 14:37:08,427 DEBUG [http-8080-exec-4]\ncom.sebster.myservlet.TomcatCometServlet - BEGIN event for request\norg.apache.catalina.connector.RequestFacade@d47c99\n2007-06-26 14:37:08,427 DEBUG [http-8080-exec-4]\ncom.sebster.myservlet.TomcatCometServlet - 127.0.0.1:60578 POST /mycometservlet\n2007-06-26 14:37:08,432 DEBUG [http-8080-exec-4]\ncom.sebster.myservlet.TomcatCometServlet -\n[24224039-a37e-40d0-a076-89d1df363390] read loop in BEGIN event, input stream\ndata available: 1\n2007-06-26 14:37:08,438 DEBUG [http-8080-exec-4]\ncom.sebster.myservlet.TomcatCometServlet -\n[24224039-a37e-40d0-a076-89d1df363390] read loop done, input stream data\navailable: 0\n2007-06-26 2:37:08.MD org.apache.catalina.connector.CoyoteAdapter event\nSEVERE: The servlet did not read all available bytes during the processing of\nthe read event\n\nNote that I'm not implying that available() does a socket access; what I saw was\nthat when the loop I described in the original post ended the condition\n\"available() == 0\" was true, and when it got to CatalinaAdapter the condition\nRequest.getAvailable() was true.\n\nFuthermore, I really am seeing the loop without the connection being closed,\nboth on the windows platform and on the Linux platform. I'm happy to help debug\nthis further, but I'm not making it up: I have a breakpoint in my\nCometProcessor.event() method, I see the Poller thread spin like crazy, and when\nI set a break point in the Poller the CPU load goes away. I can step through it\nand see that the connection stays open, it sets the event type to END on the\ncomet event, but it never reaches my CometProcessor.event() method.\n\nFinally, what I mean with \"no 6.0.13 available in the version field\" is the\ndropdown box in which to mark the Tomcat version in the bugzilla bug form. It\ngoes up to and including 6.0.11.\n\nRegards,\nSebastiaan\n"}, {"count": 3, "tags": [], "creator": "remm@apache.org", "text": "Since you're apparently not willing to write things that make sense, I will\nignore your report.", "id": 104785, "attachment_id": null, "bug_id": 42753, "creation_time": "2007-06-27T14:47:18Z", "time": "2007-06-27T14:47:18Z", "is_private": false}, {"count": 4, "tags": [], "bug_id": 42753, "is_private": false, "id": 104791, "attachment_id": null, "creator": "sebster@sebster.com", "creation_time": "2007-06-27T15:33:55Z", "time": "2007-06-27T15:33:55Z", "text": "(In reply to comment #3)\n> Since you're apparently not willing to write things that make sense, I will\n> ignore your report.\n\nI am getting really exasperated by your replies. You give me no hint at what it\nis you want or what you think is not making sense. I will test your theory more\nby writing a wrapper around the input stream to log the thread of every read\nthat happens just to make sure tomorrow.\n\nIn either case, after I got the error the Poller went into a busy loop. I'm not\nsmoking pot and I saw what I saw. Ok, maybe there's a bug somewhere in my code\nand I'm doing something wrong, I certainly don't want to exclude that\npossibility. But I saw the Poller go into an infinite loop (not caused by the\nNIO bug I was talking about previously (which is Linux only)). It did NOT close\nthe channel. It did NOT call my event method with a READ, ERROR or END event\n(which I know because I have a log.debug on enter, AND a break point set). This\nhappened directly AFTER I got the SEVERE log message. I got this on Windows and\nLinux. Note that I'm not theorizing now, these are the raw observations."}, {"count": 5, "tags": [], "creator": "fhanik@apache.org", "is_private": false, "text": "If you follow the code logic, if the error happens, where available() returns >0\nafter a READ has been invoked, the connection is never marked as a comet, so you\nwill not get the ERROR/END events invoked. so the connection goes into the\npoller for the next request.\nCould you see if you can work up a reproducible scenario, and we can take it\nfrom there.\n\n", "id": 104792, "time": "2007-06-27T16:04:07Z", "bug_id": 42753, "creation_time": "2007-06-27T16:04:07Z", "attachment_id": null}, {"count": 6, "tags": [], "bug_id": 42753, "attachment_id": null, "id": 104808, "time": "2007-06-28T02:47:50Z", "creator": "sebster@sebster.com", "creation_time": "2007-06-28T02:47:50Z", "is_private": false, "text": "(In reply to comment #5)\n> If you follow the code logic, if the error happens, where available() returns >0\n> after a READ has been invoked, the connection is never marked as a comet, so you\n> will not get the ERROR/END events invoked. so the connection goes into the\n> poller for the next request.\n> Could you see if you can work up a reproducible scenario, and we can take it\n> from there.\n\nWhen I look in the code I see the following:\n\n                if (response.isClosed() || !request.isComet()) {\n                    res.action(ActionCode.ACTION_COMET_END, null);\n                } else if (!error && read && request.getAvailable()) {\n                    // If this was a read and not all bytes have been read, or\nif no data\n                    // was read from the connector, then it is an error\n                    error = true;\n                    log.error(sm.getString(\"coyoteAdapter.read\"));\n                }\n                return (!error);\n\nSo when you get the error, the condition response.isClosed() ||\n!request.isComet() must evaluate to false, which means that !response.isClosed()\n&& request.isComet(). So for me to get the error it seems the request must\nalready be marked as a comet request.\n\nI am not able to give you a small test case. The problem is that I have two\ndifferent products that start an embedded tomcat using exactly the same class,\nand in one it consistently works (no errors whatsoever), and in the other it\nconsistently fails. I have not seen this issue before (and I have already done a\nlot of testing in different situations), and I have no idea what the\nprecondition is for this issue to manifest itself.\n\nHowever, I added extra debugging information, and I did find something strange.\nI do the following logging FIRST thing in my Comet processor and I wrapped the\ninput stream to log which thread does the reading:\n\n  final EventType eventType = event.getEventType();\n  if (Debug.ENABLED && logger.isDebugEnabled()) {\n    try {\n      final Field field = request.getClass().getDeclaredField(\"request\");\n//$NON-NLS-1$\n      field.setAccessible(true);\n      final Request internalRequest = (Request) field.get(request);\n      logger.debug(\"{} event for request facade {}, request {}\", new Object[] {\neventType, request, internalRequest }); //$NON-NLS-1$\n    } catch (final Exception e) {\n      logger.debug(\"{} event for request facade {}\", eventType, request);\n//$NON-NLS-1$\n      logger.debug(\"failed to get request\", e); //$NON-NLS-1$\n    }\n  }\n\nI set a breakpoint in the CoyoteAdapter where it gives the SEVERE error, looked\nat the id of the request object, and checked my log what events I got for that\nobject.\n\nMy results where as follows:\n\n2007-06-28 11:16:00,021 DEBUG [http-8080-exec-4]\ncom.sebster.myservlet.MyCometServlet - BEGIN event for request facade\norg.apache.catalina.connector.RequestFacade@1dc696e, request\norg.apache.catalina.connector.Request@18dbef1\n\nThis was the ONLY line in the log with Request@18dbef1. All the reads in this\nBEGIN event happen on the http-8080-exec-4 thread. After returning from the read\n(due to available() == 0), it immediately stops in my breakpoint in\nCoyoteAdapter to log the SEVERE error. Note that I first set the break point to\nfind the id of the Request object to look for in the log.\n\nThe strange thing is, that the breakpoint happens in the http-8080-exec-5\nthread. The comet field in the Request@1dc696e object is set to true, and\nrequest.getAvailable() also returns true.\n\nThese are my observations so far. Note that I am no expert on Tomcat internals,\nbut I am very willing to spend time on this issue to resolve it, so any tips,\nsuggestions, questions, or assignments :-) are welcome!\n\nTo summarize:\n1) I get a BEGIN event for Request@1dc696e in http-8080-exec-4\n2) I read until available() == 0 in http-8080-exec-4\n3) I return from the event() method in http-8080-exec-4\n4) Tomcat logs a SEVERE error stating that I have not read all data\n     * The request object is Request@1dc696e\n     * request.isComet() == true\n     * request.getAvailable() == true\n     * the thread is http-8080-exec-5\n     * at this point there are zero log lines for thread http-8080-exec-5\n\nRegards,\nSebastiaan\n\n\n\n\n\n\n"}, {"count": 7, "tags": [], "creator": "sebster@sebster.com", "attachment_id": null, "text": "I did some additional debugging on the Poller loop that occurs after the SEVERE\nerror. This is what happens:\n\n1) the CoyoteAdapter.event() method gets called.\n2) request.read() returns false\n3) the condition status == SocketStatus.STOP evaluates to true\n4) the following statements are executed\n    request.getEvent().setEventType(CometEvent.EventType.END);\n    request.getEvent().setEventSubType(CometEvent.EventSubType.SERVER_SHUTDOWN);\n5) in the following statement getFirst() returns the \"basic\" field, a\nStandardEngineValve:\n    connector.getContainer().getPipeline().getFirst().event(request, response,\nrequest.getEvent());\n6) my CometProcessor.event() method is NOT called\n7) error = false, and the event() method returns true\n\nThis loop repeats ad infinitum, and consumes 100% CPU. Note that no code of my\nown is called in this sequence.\n\nRegards,\nSebastiaan\n", "id": 104809, "time": "2007-06-28T03:20:08Z", "bug_id": 42753, "creation_time": "2007-06-28T03:20:08Z", "is_private": false}, {"count": 8, "tags": [], "creator": "fhanik@apache.org", "attachment_id": null, "text": "I just wrote a simple test client that doesn't read the contents and I\nexperienced no loop. END nor ERROR got called, so there is a problem here, the\ncontainer should call one of those methods.\nare you able to test your solution against the latest\ntc6.0.x branch as well as the trunk branch?", "id": 104862, "time": "2007-06-28T11:34:50Z", "bug_id": 42753, "creation_time": "2007-06-28T11:34:50Z", "is_private": false}, {"count": 9, "tags": [], "bug_id": 42753, "attachment_id": null, "text": "(In reply to comment #8)\n> I just wrote a simple test client that doesn't read the contents and I\n> experienced no loop. END nor ERROR got called, so there is a problem here, the\n> container should call one of those methods.\n> are you able to test your solution against the latest\n> tc6.0.x branch as well as the trunk branch?\n\nA patch for the END/ERROR never being called has been submitted to both 6.0.x\nand trunk. This should at least give you a chance to cleanup, \n\nyour original problem of available()==0 but there yet being data, causing an\ninfinite loop is to me non reproducible.\n\nI'll wait for your feedback before marking this fixed.\n", "id": 104863, "time": "2007-06-28T11:46:06Z", "creator": "fhanik@apache.org", "creation_time": "2007-06-28T11:46:06Z", "is_private": false}, {"count": 10, "tags": [], "bug_id": 42753, "is_private": false, "id": 104864, "attachment_id": null, "creator": "sebster@sebster.com", "creation_time": "2007-06-28T12:11:47Z", "time": "2007-06-28T12:11:47Z", "text": "(In reply to comment #9)\n\n> A patch for the END/ERROR never being called has been submitted to both 6.0.x\n> and trunk. This should at least give you a chance to cleanup, \n\nThanks :-), I will test this ASAP.\n\n> your original problem of available()==0 but there yet being data, causing an\n> infinite loop is to me non reproducible.\n\nThe main clue (as far as I can tell) of something going wrong is the fact that\nthe BEGIN event + read loop is in 1 thread, and the error in happens another\n(see the summary of comment 6). Do you not agree that this should not happen? If\nyou agree that this is wrong (whatever the cause, Tomcat or my code), I can try\nand debug what causes this to happen.\n\nRegards,\nSebastiaan\n\n"}, {"count": 11, "tags": [], "bug_id": 42753, "attachment_id": null, "id": 104865, "time": "2007-06-28T12:32:50Z", "creator": "fhanik@apache.org", "creation_time": "2007-06-28T12:32:50Z", "is_private": false, "text": "Once the socket goes back to the poller, and the poller dispatches it again,\nthen that can be on a different thread, as tomcat uses a thread pool, so there\nis no guarantee what thread the poller dispatches too"}, {"count": 12, "tags": [], "bug_id": 42753, "text": "(In reply to comment #11)\n> Once the socket goes back to the poller, and the poller dispatches it again,\n> then that can be on a different thread, as tomcat uses a thread pool, so there\n> is no guarantee what thread the poller dispatches too\n\nYes I understand that, but for the specific Request object instance I get only 1\ncomet event, in thread http-8080-exec-4 and the check of Request.getAvailable()\nto see if I read everything happens in http-8080-exec-5 (with no other comet\nevents in between - I ONLY get the BEGIN event for this Request instance). Is\nthis not strange? Should the check not be performed in the same thread before\nthe socket goes back to the poller?", "id": 104866, "attachment_id": null, "creator": "sebster@sebster.com", "creation_time": "2007-06-28T12:56:51Z", "time": "2007-06-28T12:56:51Z", "is_private": false}, {"count": 13, "tags": [], "bug_id": 42753, "attachment_id": null, "text": "not really, getAvailable() is only called if read() returned true.\nin your case, the following might happen\n1. HTTP request comes in, no body\n2. You get BEGIN event, no additional data on the socket\n3. read() returns false, so you dont get an immediate READ event,\n\n\n\n", "id": 104868, "time": "2007-06-28T13:37:57Z", "creator": "fhanik@apache.org", "creation_time": "2007-06-28T13:37:57Z", "is_private": false}, {"count": 14, "tags": [], "creator": "sebster@sebster.com", "attachment_id": null, "is_private": false, "id": 104893, "time": "2007-06-29T03:13:28Z", "bug_id": 42753, "creation_time": "2007-06-29T03:13:28Z", "text": "I have found the cause of the problem.\n\nThe code place where it goes wrong is ApplicationFilterFactory line 126:\n\n            Request req = (Request) request;\n            if (Globals.IS_SECURITY_ENABLED) {\n                // Security: Do not recycle\n                filterChain = new ApplicationFilterChain();\n            } else {\n                filterChain = (ApplicationFilterChain) req.getFilterChain();\n                if (filterChain == null) {\n                    filterChain = new ApplicationFilterChain();\n                    req.setFilterChain(filterChain);\n                }\n            }\n            comet = req.isComet();\n\nWhen a security manager is installed the filter chain is not set on the request.\n\nOn subsequent Comet events, since the filter chain is null, the event is not\nhandled properly and the poller goes into a busy loop.\n\n\n\n"}, {"count": 15, "tags": [], "bug_id": 42753, "attachment_id": null, "id": 104899, "time": "2007-06-29T06:05:37Z", "creator": "fhanik@apache.org", "creation_time": "2007-06-29T06:05:37Z", "is_private": false, "text": "Excellent, we will fix this!"}, {"count": 16, "tags": [], "bug_id": 42753, "attachment_id": null, "id": 104900, "time": "2007-06-29T06:10:40Z", "creator": "remm@apache.org", "creation_time": "2007-06-29T06:10:40Z", "is_private": false, "text": "The \"issue\" in this bug report is that the user claims that the value of\n\"available()\" randomly changes. This minor glitch is unrelated."}, {"count": 17, "tags": [], "text": "(In reply to comment #16)\n> The \"issue\" in this bug report is that the user claims that the value of\n> \"available()\" randomly changes. This minor glitch is unrelated.\n\nThe issue was that Tomcat reported that I had not read all available bytes even\nthough I did. The reason turns out to be because Tomcat was not calling the\nevent method of my comet processor, which entails that indeed bytes were not\nbeing read.\n\nMy original issue is thereby resolved and the summary of this bug turns out to\nbe wrong. It just looked to me like there was a race condition, since I had a\nbreakpoint in event() and it was not being called anymore, so I thought\n(erroneously) that it was complaining at the end of the BEGIN event.\n\nSo, as far as I'm concerned this issue can be closed. I don't care if you mark\nit INVALID if that's what you want because the summary turns out to be\nincorrect; that's fine by me.\n\nI'm happy that the issue is resolved and the bug is fixed. :-)\n", "is_private": false, "id": 104901, "creator": "sebster@sebster.com", "time": "2007-06-29T06:25:25Z", "bug_id": 42753, "creation_time": "2007-06-29T06:25:25Z", "attachment_id": null}, {"count": 18, "tags": [], "creator": "sebster@sebster.com", "text": "(In reply to comment #15)\n> Excellent, we will fix this!\n\nThanks a lot. :-) Sorry for my initially incorrect analysis of the problem. I\nshould stick to reporting observed behavior instead of theorizing.\n", "id": 104902, "attachment_id": null, "bug_id": 42753, "creation_time": "2007-06-29T06:27:07Z", "time": "2007-06-29T06:27:07Z", "is_private": false}]