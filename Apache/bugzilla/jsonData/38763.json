[{"count": 0, "tags": [], "bug_id": 38763, "attachment_id": null, "id": 86126, "time": "2006-02-23T10:51:28Z", "creator": "Oliver.Luik@gmx.de", "creation_time": "2006-02-23T10:51:28Z", "is_private": false, "text": "We get sporadic \"Bad Gateway\" errors from mod_proxy.\nIn the error log we have entries like:\n[Fri Feb 17 17:10:19 2006] [error] [client 192.168.55.72] proxy: error reading \nstatus line from remote server appsrv01i\n\nWe were able to track down the error to situation when the server \nasynchronously closes kept-alive connections and the client sent new requests.\n\nAccording to http://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html the \nfollowing rules must be followed for persistent connections:\n- A client, server, or proxy MAY close the transport connection at any\n  time\n- This means that clients, servers, and proxies MUST be able to recover\n  from asynchronous close events.\n\nWhy are these rules not implemented in mod_proxy?\nI do consider mod_proxy not to be HTTP keep-alive compliant in the current \nimplementation.\nPlease comment."}, {"count": 1, "tags": [], "bug_id": 38763, "text": "I admit that the current behaviour is not convenient, but I see no RFC violation\nhere. Please read the next two sentences in the RFC after\n\n\"This means that clients, servers, and proxies MUST be able to recover from\nasynchronous close events.\"\n\nThe next two sentences say:\n\nClient software SHOULD reopen the transport connection and retransmit the\naborted sequence of requests without user interaction so long as the request\nsequence is idempotent (see section 9.1.2). Non-idempotent methods or sequences\nMUST NOT be automatically retried, although user agents MAY offer a human\noperator the choice of retrying the request(s).\n\nThe proxy can be seen as client in this case. \n1. There is no MUST for the client to retransmit if the request is idempotent.\n2. If the request is not idempotent like POST it MUST NOT retransmit.\n3. There is no definition what \"recover\" means. I see sending a Bad Gateway\nresponse as some sort of recover from this situation.", "id": 86170, "time": "2006-02-23T22:03:41Z", "creator": "rpluem@apache.org", "creation_time": "2006-02-23T22:03:41Z", "is_private": false, "attachment_id": null}, {"count": 2, "tags": [], "bug_id": 38763, "attachment_id": null, "id": 86244, "time": "2006-02-27T10:23:13Z", "creator": "Oliver.Luik@gmx.de", "creation_time": "2006-02-27T10:23:13Z", "is_private": false, "text": "The current implementation with sending \"Bad Gateway\" response back to user \nagent (client) might be RFC compliant (hard to decide), but it is not the \nbehaviour the user expects. For me a reverse proxy is not the client referred \nto in the RFC. The reverse proxy is a transparent intermediate that should only \nsend own error messages back to the client in case of severe errors (ENOMEM, \nEINTERN,..).\nIMO the best solution would be to delegate the async close back to the real \nclient (browser). It already has to handle this situation when connected \ndirectly to the server. It is the only player in the game that can decide \nreliably what to do: retransmit, user interaction, etc\n\n> Client software SHOULD reopen the transport connection and retransmit the\n> aborted sequence of requests without user interaction so long as the request\n> sequence is idempotent\nAccording to RFC 2119 \"SHOULD\" is defined as:\nSHOULD   This word, or the adjective \"RECOMMENDED\", mean that there\n   may exist valid reasons in particular circumstances to ignore a\n   particular item, but the full implications must be understood and\n   carefully weighed before choosing a different course.\n\n\n(In reply to comment #1)\n> I admit that the current behaviour is not convenient, but I see no RFC \nviolation\n> here. Please read the next two sentences in the RFC after\n> \"This means that clients, servers, and proxies MUST be able to recover from\n> asynchronous close events.\"\n> The next two sentences say:\n> Client software SHOULD reopen the transport connection and retransmit the\n> aborted sequence of requests without user interaction so long as the request\n> sequence is idempotent (see section 9.1.2). Non-idempotent methods or \nsequences\n> MUST NOT be automatically retried, although user agents MAY offer a human\n> operator the choice of retrying the request(s).\n> The proxy can be seen as client in this case. \n> 1. There is no MUST for the client to retransmit if the request is idempotent.\n> 2. If the request is not idempotent like POST it MUST NOT retransmit.\n> 3. There is no definition what \"recover\" means. I see sending a Bad Gateway\n> response as some sort of recover from this situation.\n\n(In reply to comment #0)\n> We get sporadic \"Bad Gateway\" errors from mod_proxy.\n> In the error log we have entries like:\n> [Fri Feb 17 17:10:19 2006] [error] [client 192.168.55.72] proxy: error \nreading \n> status line from remote server appsrv01i\n> We were able to track down the error to situation when the server \n> asynchronously closes kept-alive connections and the client sent new requests.\n> According to http://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html the \n> following rules must be followed for persistent connections:\n> - A client, server, or proxy MAY close the transport connection at any\n>   time\n> - This means that clients, servers, and proxies MUST be able to recover\n>   from asynchronous close events.\n> Why are these rules not implemented in mod_proxy?\n> I do consider mod_proxy not to be HTTP keep-alive compliant in the current \n> implementation.\n> Please comment.\n\n(In reply to comment #1)\n> I admit that the current behaviour is not convenient, but I see no RFC \nviolation\n> here. Please read the next two sentences in the RFC after\n> \"This means that clients, servers, and proxies MUST be able to recover from\n> asynchronous close events.\"\n> The next two sentences say:\n> Client software SHOULD reopen the transport connection and retransmit the\n> aborted sequence of requests without user interaction so long as the request\n> sequence is idempotent (see section 9.1.2). Non-idempotent methods or \nsequences\n> MUST NOT be automatically retried, although user agents MAY offer a human\n> operator the choice of retrying the request(s).\n> The proxy can be seen as client in this case. \n> 1. There is no MUST for the client to retransmit if the request is idempotent.\n> 2. If the request is not idempotent like POST it MUST NOT retransmit.\n> 3. There is no definition what \"recover\" means. I see sending a Bad Gateway\n> response as some sort of recover from this situation.\n\n"}, {"count": 3, "tags": [], "bug_id": 38763, "text": "(In reply to comment #0)\n\n> We were able to track down the error to situation when the server \n> asynchronously closes kept-alive connections and the client sent new requests.\n\nCan you clarify the exact sequence?\n\nIs it something like:\n  Proxy successfully handles Request 1\n  Backend closes connection\n  Client sends Request 2 to proxy\n  Proxy tries to use existing connection, but it's closed at the backend\n  Proxy replies with an error?\n\nOr is it more asynchronous than that?\n", "id": 107855, "time": "2007-09-08T06:33:08Z", "creator": "nick@webthing.com", "creation_time": "2007-09-08T06:33:08Z", "is_private": false, "attachment_id": null}, {"count": 4, "tags": [], "bug_id": 38763, "attachment_id": null, "id": 123525, "time": "2008-12-26T10:59:29Z", "creator": "nick@webthing.com", "creation_time": "2008-12-26T10:59:29Z", "is_private": false, "text": "Handling of this case has been significantly updated; assuming fixed.  Please reopen if it persists in 2.2.11."}]