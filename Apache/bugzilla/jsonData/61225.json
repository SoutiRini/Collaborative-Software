[{"count": 0, "tags": [], "bug_id": 61225, "text": "Example 1 (from the doc):\n<Location \"/mirror/foo/\">\n    ProxyPass \"http://backend.example.com/\"\n</Location>\n<Location \"/mirror/foo/i\">\n    ProxyPass \"!\"\n</Location>\nGET /mirror/foo/i => not proxied: OK\n\nExample 1 (from the doc):\nProxyPass \"/mirror/foo/i\" \"!\"\nProxyPass \"/mirror/foo\"   \"http://backend.example.com\"\nGET /mirror/foo/i => not proxied: OK\n\nExample 3:\nProxyPass \"/mirror/foo/i\" \"!\"\n<Location \"/mirror/foo/\">\n    ProxyPass \"http://backend.example.com/\"\n</Location>\nGET /mirror/foo/i => proxied: not OK\n\nIn example 3, we expect mod_proxy to stop processing anything, right?\nIn case we don't have to proxy a location, I think we should completely exit mod_proxy.\nBtw, this would also support the following case, which doesn't work for the moment:\n<Location \"/mirror/foo/i\">\n    ProxyPass \"!\"\n</Location>\n<Location \"/mirror/foo/\">\n    ProxyPass \"http://backend.example.com/\"\n</Location>", "id": 199424, "time": "2017-06-26T13:30:41Z", "creator": "marc.stern@approach.be", "creation_time": "2017-06-26T13:30:41Z", "is_private": false, "attachment_id": null}, {"count": 1, "tags": [], "bug_id": 61225, "is_private": false, "id": 199427, "attachment_id": null, "creator": "covener@gmail.com", "creation_time": "2017-06-26T14:36:59Z", "time": "2017-06-26T14:36:59Z", "text": "There has been some churn in this area, including a bad regression from me in 2.4.24.  \n\nI think Example 3 (not from the docs) didn't work (e.g. in 2.4.23) and it's what I tried to fix but introduced a worse problem.\n\nIn 2.4.26 and later, the guidance should just be to set the no-proxy environment variable.  Maybe we just need yet another <note> that says per-location proxy directives cannot be overridden by non-per-location ! lines.  They can be overridden by the no-proxy envvar.\n\nThe problem with example 3, AIUI, is that the point of putting things inside <Location> is to avoid iterating over many proxypass directives. But if the exception is outside of <Location> you then have to iterate to check for exceptions."}, {"count": 2, "tags": [], "bug_id": 61225, "is_private": false, "id": 199428, "attachment_id": null, "creator": "marc.stern@approach.be", "creation_time": "2017-06-26T14:46:29Z", "time": "2017-06-26T14:46:29Z", "text": "Correct me if I'm wrong, but httpd parses the first all global directives, then the location ones. If we exit mod_proxy as soon as we see a matching \"!\" (global or location, whatever), don't we have a generic solution ?"}, {"count": 3, "tags": [], "bug_id": 61225, "attachment_id": null, "id": 199429, "time": "2017-06-26T14:55:01Z", "creator": "covener@gmail.com", "creation_time": "2017-06-26T14:55:01Z", "is_private": false, "text": "(In reply to Marc Stern from comment #2)\n> Correct me if I'm wrong, but httpd parses the first all global directives,\n> then the location ones. If we exit mod_proxy as soon as we see a matching\n> \"!\" (global or location, whatever), don't we have a generic solution ?\n\nI think by the time mod_proxy is checking at runtime, it has access to an array of global parsed ProxyPass directives, and a single per-location directive that is the result of the pair-wise merging (in this case over-riding) which is why the latter is referred to as the \"quick\" way in the code.\n\nMy chief concern is preserving whatever weird semantics there were in 2.4.23 and earlier.  I think that means per-location cannot be overridden by global directives.\n\nThat's why part of fixing my own regression was just adding an envvar \"no-proxy\" that didn't have the baggage of 2.4.0-2.4.23 and worked a little more intuitively."}, {"count": 4, "tags": [], "creator": "marc.stern@approach.be", "text": "OK, I understand.\nI'll wait for the no-proxy in Redhat :-(", "id": 199430, "time": "2017-06-26T14:58:14Z", "bug_id": 61225, "creation_time": "2017-06-26T14:58:14Z", "is_private": false, "attachment_id": null}, {"count": 5, "tags": [], "bug_id": 61225, "attachment_id": null, "text": "(In reply to Marc Stern from comment #0)\n> Example 1 (from the doc):\n> <Location \"/mirror/foo/\">\n>     ProxyPass \"http://backend.example.com/\"\n> </Location>\n> <Location \"/mirror/foo/i\">\n>     ProxyPass \"!\"\n> </Location>\n> GET /mirror/foo/i => not proxied: OK\n> \n> Example 1 (from the doc):\n> ProxyPass \"/mirror/foo/i\" \"!\"\n> ProxyPass \"/mirror/foo\"   \"http://backend.example.com\"\n> GET /mirror/foo/i => not proxied: OK\n> \n> Example 3:\n> ProxyPass \"/mirror/foo/i\" \"!\"\n> <Location \"/mirror/foo/\">\n>     ProxyPass \"http://backend.example.com/\"\n> </Location>\n> GET /mirror/foo/i => proxied: not OK\n> \n> In example 3, we expect mod_proxy to stop processing anything, right?\n> In case we don't have to proxy a location, I think we should completely exit\n> mod_proxy.\n> Btw, this would also support the following case, which doesn't work for the\n> moment:\n> <Location \"/mirror/foo/i\">\n>     ProxyPass \"!\"\n> </Location>\n> <Location \"/mirror/foo/\">\n>     ProxyPass \"http://backend.example.com/\"\n> </Location>\n\nLocation is defined more global path first, most specific path second.\nProxyPass is defined more specific path first, most global path second.\nLocation has priority for the same \"paths\" over Directory or paths referenced in  virtualhost context.\n\nAs I see it, Example 3 does not apply because whatever you defined in virtualhost context for that path or sub-path will be \"overwritten\" by location that applies to the same path.\n\nAnd about example 4, no, Location does not work that way, when you define two Locations, as in example 1, most global should be defined first, more specific should be defined second, just the opposite to when you define ProxyPass directives.", "id": 199432, "time": "2017-06-26T15:04:35Z", "creator": "dferradal@gmail.com", "creation_time": "2017-06-26T15:04:35Z", "is_private": false}]