[{"count": 0, "tags": [], "bug_id": 37169, "is_private": false, "text": "We are using the <sql> task to read in a .sql file to populate a database.  One\nof the INSERT statements that is used to populate a variable unlimited length\ncolumn (declared as \"TEXT\" for Postgresql) is 1.5 million characters long.\n\nUsing Ant 1.6.5 with JDK 1.4, the task completes in a few seconds.  However,\nusing the same version of Ant with JDK 1.5.0 (build 1.5.0_05-b05), it takes 36\nminutes.\n\nAfter debugging the SQLExec class, it appears that the runStatements method\ncontains an inefficient line of code.  Line 483 contains this code:\n\nif ((delimiterType.equals(DelimiterType.NORMAL)\n                 && sql.toString().endsWith(delimiter))\n\nBy using the buffer's toString(), the entire buffer is getting searched (in\naddition to unneccessarily creating a new string) instead of using the last line\nread to locate the delimiter.\n\nIf you change it to:\n\nif ((delimiterType.equals(DelimiterType.NORMAL) \n                 && line.endsWith(delimiter))\n\nthe problem is fixed.", "id": 81414, "time": "2005-10-19T22:12:27Z", "creator": "david.messina@ieminc.com", "creation_time": "2005-10-19T22:12:27Z", "attachment_id": null}, {"count": 1, "tags": [], "text": "If this statement makes that big a difference, I'd say something is wrong with\nJDK 1.5.0. If a method executes in a few seconds on jdk 1.4 it should not take\n36 minutes on jdk 1.5. Even if the later platform version offers a more\nefficient method.\n\nMaybe the 36 minutes is mainly caused by swapping on the local computer, because\neither the 1.5 vm was loaded adittionally, or just because the 1.5 vm is\nslightly larger?\n\nsql is a StringBuffer(), and afaik not all java versions supported by ant have\nthe  endsWith method on the StringBuffer, therefore we cannot improve the\nefficiency in the propesed way.", "is_private": false, "bug_id": 37169, "id": 81530, "time": "2005-10-21T17:41:07Z", "creator": "jkf@apache.org", "creation_time": "2005-10-21T17:41:07Z", "attachment_id": null}, {"count": 2, "tags": [], "text": "This is actually because the implementation of String/StringBuffer is very \ndifferent between jdk 1.4 and jdk 1.5. \n\nWith jdk 1.4, a StringBuffer.toString() does create a String object but the \ncontent (char array) is just shared (as the string is immutable this a good \noptimization and was introduced in jdk 1.3 if I remember well)\n\nWith jdk 1.5, the content is not shared anymore but copied directly. As you \nhave a huge content, it creates this major bottleneck as memory is copied over \nand over and over.", "is_private": false, "bug_id": 37169, "id": 81531, "time": "2005-10-21T17:53:26Z", "creator": "sbailliez@apache.org", "creation_time": "2005-10-21T17:53:26Z", "attachment_id": null}, {"count": 3, "tags": [], "text": "Dear Mr Kruithof,\n\nI would be hesitant to say something is wrong with JDK 1.5.\nAfter all, the statement does in the case of a SQL that spans HUGE number\nof lines to continuously create large Strings. There is nothing wrong\nin the JDK 1.5 (execution wise), it is doing what it is being asked\nto do. Creating a big number of large strings will take a lot of time.\n\nIn JDK 1.4, the hotspot compiler is probably doing some short circuiting\nto enhance the performance. The hotspot equivalent in JDK 1.5 is still\nimmature in comparison.\n\nAs per your second comment, I would advise that you re-read that gentlemen's\nstatement, and retract yours. He suggested that the \"endsWith()\" method\nshould be performed on \"line\" and not \"sql\". Your statement regarding\nStringBuffer and Java just does not make sense.\n\nReading is fundamental.\n\nThanks,\n\nBoon\n\n\n(In reply to comment #1)\n> If this statement makes that big a difference, I'd say something is wrong with\n> JDK 1.5.0. If a method executes in a few seconds on jdk 1.4 it should not take\n> 36 minutes on jdk 1.5. Even if the later platform version offers a more\n> efficient method.\n> \n> Maybe the 36 minutes is mainly caused by swapping on the local computer, because\n> either the 1.5 vm was loaded adittionally, or just because the 1.5 vm is\n> slightly larger?\n> \n> sql is a StringBuffer(), and afaik not all java versions supported by ant have\n> the  endsWith method on the StringBuffer, therefore we cannot improve the\n> efficiency in the propesed way.", "is_private": false, "bug_id": 37169, "id": 81532, "time": "2005-10-21T18:01:46Z", "creator": "bhtek@yahoo.com", "creation_time": "2005-10-21T18:01:46Z", "attachment_id": null}, {"count": 4, "tags": [], "creator": "sbailliez@apache.org", "attachment_id": null, "id": 81533, "time": "2005-10-21T18:05:34Z", "bug_id": 37169, "creation_time": "2005-10-21T18:05:34Z", "is_private": false, "text": "Actually to be more accurate the 'good optimization' is actually a trade-off \nas this can lead to major memory usage if you are reusing a StringBuffer and \nreusing it via setLength(0).\n\nThe reason is that when the char array is not shared anymore and only belongs \nto the String object..u could actually be sharing an allocated 1000000 char \narray when the string is actually made of only 1 char in this char array.\n\nDo that over a loop and you could very easily  get the gc crawling and end up \nwith in an OOME"}, {"count": 5, "tags": [], "creator": "bhtek@yahoo.com", "text": "Stephane,\n\nThanks for your enlightening post. I guess I should have read the source\nfor the JDK. Like I said, reading is fundamental.\n\nBoon", "id": 81534, "time": "2005-10-21T18:36:26Z", "bug_id": 37169, "creation_time": "2005-10-21T18:36:26Z", "is_private": false, "attachment_id": null}, {"count": 6, "tags": [], "creator": "jkf@apache.org", "attachment_id": null, "text": "Sorry, I do hesitate to call somthing a bug, but changing a method to have a new\nexecution speed orders of magnitude slower as before is generally considered a\nbug, even if the functional behaviour remains the same.\n\nIn case this delay is mainly caused by swapping (because the change in the java\nenvironment memory consumption is slightly up) it need not be a bug, but may be\njust bad luck, an option I left explicitly open.\n\nSun confirmed this bug in JDK 1.5 (see\nhttp://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6219959)\n\nI indeed misread the sql to line change. StringBuffer sql may be appended to\nthough, even after String line is added, so the proposed change is not\nequivalent to the original code. We get quite some proposed fixes/enhancements\nthat use newer java features as available in jdk 1.2\n\nDoes changing the code to\n\nif ((delimiterType.equals(DelimiterType.NORMAL)\n                 && stringBufferEndsWith(sql,delimiter))\n\nand introducing the method\n\n    static boolean stringBufferEndsWith(StringBuffer b, String end)\n    {\n        if (b.length() < end.length()) {\n            return false;\n        }\n\n        return (end.equals(b.substring(b.length()-end.length(),b.length())));\n    }\n\nfix the speed problem on jdk 1.5, yet keep the same behaviour?\n\n(in case it does I'll introduce this change)\n\n", "id": 81546, "time": "2005-10-21T21:20:50Z", "bug_id": 37169, "creation_time": "2005-10-21T21:20:50Z", "is_private": false}, {"id": 81566, "tags": [], "bug_id": 37169, "is_private": false, "count": 7, "text": "Fixed in HEAD.\n\nI introduced a method StringUtils.endsWith(StringBuffer, String) that avoid \nusing any JDK 1.4+ API and workaround any performance issue.\n\nPlease test it confirm that the issue is fixed.", "time": "2005-10-22T19:32:08Z", "creator": "sbailliez@apache.org", "creation_time": "2005-10-22T19:32:08Z", "attachment_id": null}, {"count": 8, "tags": [], "text": "(In reply to comment #7)\n> Please test it confirm that the issue is fixed.\n\nfor what it's worth, this bug has been completely resolved for us in Ant 1.7.0\n(I work for the same company as the original bug submitter).\n\nThank you so much for fixing this!!", "is_private": false, "bug_id": 37169, "id": 97694, "time": "2007-01-05T07:16:35Z", "creator": "brad.cupit@iem.com", "creation_time": "2007-01-05T07:16:35Z", "attachment_id": null}]