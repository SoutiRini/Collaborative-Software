[{"count": 0, "tags": [], "bug_id": 50495, "attachment_id": null, "text": "I use NIO HTTP Tomcat connector org.apache.coyote.Http11NioProtocol to\nimplement Comet streaming to browsers and mobile devices. \nThe application opens 'primary' persistent Comet connection to receive data\nfrom the server. Server sends data to the client periodically.\n\nIt will be possible that one of the clients is \"slow reader\" for various reasons. If I call PrintWriter.print(\"message\") to send data to such client, the message will be queued internally by the Tomcat \"Comet Processor\". If message flow is heavy, the client message queues may become large and Tomcat can run out of memory. I was able to duplicate this quite easily by sending messages in a loop.\n\nIt will be critical to address these issues for any \"production quality\" application.\n\nI would like to request 2 enhancements to address this:\n1) I would like to somehow \"compress\" the pending client's queue. Messages I send are financial market data messages. So if I send message for stock IBM and the message is queued, then when a new message for IBM is generated, I should be able to detect that there is a message in the queue pending to be sent and just replace content of the one already pending instead of queuing a new one.\n\n2) If queue for a client reaches a high water mark, I should be able to detect it, disconnect the client and delete the queue.\n\nThis is how data is sent now with Tomcat Comet:\nPrintWriter out = response.getWriter();\nout.print(\"my message\");\n\n\n\nThis is how I would prefer it to work. This is very rough idea.\n// Comet PrintWriter will be exposed:\nCometPrintWriter out = (CometPrintWriter)response.getWriter();\n\n// detect queue size and disconnect if necessary.\nint queueSize = out.getQueue().size()\n\n// get cached message for the stock symbol\nICometMessage existingMessageForTheSymbol = ...\nif (existingMessageForTheSymbol == null) {\n    ICometMessage newMessage = new MyMessage(...)\n    out.addMessage(newMessage);\n    // cache the newMessage in a Map.\n}\nelse {\n    if (!existingMessageForTheSymbol.replaceMessage(...)) {\n        // message is already sent. need to create a new one:\n        ICometMessage newMessage = new MyMessage(...)\n        out.addMessage(newMessage);\n        // cache the newMessage in a Map.\n    }\n}\n\n// this interface would be a part of Tomcat Comet\ninterface ICometMessage {\n   // called by Tomcat comet before message is sent.\n   void beforeMessageSent();\n\n   // called by Tomcat comet after message is sent.\n   void afterMessageSent();\n}\n\nclass MyMessage implements ICometMessage {\n   ReentrantLock lock = ...;\n   boolean messageSent;\n\n   public void beforeMessageSent() {\n      lock.lock();\n      messageSent = true;\n   }\n\n   public void afterMessageSent() {\n      lock.unlock();\n   }\n\n   public boolean replaceMessage(...) {\n      lock.lock();\n      if (messageSent) {\n         lock.unlock();\n         return false;\n      }\n\n      // replace message data.\n\n      lock.unlock();\n\n      return true;\n   }\n}", "id": 142825, "time": "2010-12-18T00:18:04Z", "creator": "goberman@msn.com", "creation_time": "2010-12-18T00:18:04Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 50495, "attachment_id": null, "text": "This is an enhancement request, not a blocker.\n\nThis enhancement looks like something that is application specific. There are various reasons why a generic solution would be difficult:\n- the Comet API (and all of Tomcat's internals) has no concept of a message\n- bytes written to clients are buffered are various points both under Tomcat's control and completely outside of Tomcat's control\n- the criteria for compressing messages is something that would be very hard to make generic\n\nWith all this in mind, I am resolving this as WONTFIX.\n\nThat said, if there are changes to the Comet API you would like to propose (in the form of a patch) that would make an application level implementation of these features easier, feel free to re-open this issue and attach your proposed patch.", "id": 143050, "time": "2011-01-04T09:42:15Z", "creator": "markt@apache.org", "creation_time": "2011-01-04T09:42:15Z", "is_private": false}, {"count": 2, "tags": [], "bug_id": 50495, "is_private": false, "text": "Mark, \nthis is not application specific. I have no idea when data is written to a socket from Tomcat.\nI need to know when you write messages \"under Tomcat control\" - this is all I need. I am sure you have some concept of \"client message queue\".\nThis is an a enhancement to address a bug in my opinion. As of now, a single client has the ability to deplete resources of the whole server. This makes Tomcat Comet technology a toy for college projects at best. Completely unsuitable for production application.\nI have no choice but to look for alternative implementations.", "id": 143052, "time": "2011-01-04T09:56:22Z", "creator": "goberman@msn.com", "creation_time": "2011-01-04T09:56:22Z", "attachment_id": null}, {"count": 3, "text": "(In reply to comment #2)\n> I have no idea when data is written to a socket from Tomcat.\nThis is open source. You could have looked it up. The users list is always very helpful to folks trying to understand Tomcat's internals and needing a few pointers. The short version is:\n'out' -> 8k buffer -> socket\n\n> I need to know when you write messages \"under Tomcat control\" - this is all I\n> need.\nIt depends. The above buffer is flushed if it is full or if a call is made to out.flush(). Once the buffer is flushed, Tomcat has no control over the data.\n\n> I am sure you have some concept of \"client message queue\".\nAs I said before, Tomcat has no concept of a message so there is no message queue. The bytes are treated as just that - bytes. There is nothing the delimits messages which are an application defined concept. If there are 5,000 bytes to be written the client, Tomcat has no idea if they represent 10*500 byte message or 1000*5 byte messages.\n\n> This is an a enhancement to address a bug in my opinion. As of now, a single\n> client has the ability to deplete resources of the whole server.\nThat shouldn't happen. The NIO connector uses simulated blocking so the call to out.write() should block if the socket send buffer is full. If memory serves me correctly, that is around 30k. If you have a simple test case that demonstrates an OOME then please re-open this issue, attach it and someone will take a look.\n\n> This makes  Tomcat Comet technology a toy for college projects at best.\n> Completely unsuitable for production application.\nThat sort of comment isn't going to encourage any of the folks here (who are all volunteers) to help you.\n\n> I have no choice but to look for alternative implementations.\nYou are, of course, free to do that is you wish.", "creator": "markt@apache.org", "attachment_id": null, "id": 143056, "time": "2011-01-04T10:38:25Z", "bug_id": 50495, "creation_time": "2011-01-04T10:38:25Z", "tags": [], "is_private": false}]