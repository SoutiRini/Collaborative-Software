[{"count": 0, "tags": [], "bug_id": 54852, "text": "Sometimes graceful restart can take up to few minutes here (time between \"Graceful restart requested, doing restart\" and \"resuming normal operations\") when using prefork MPM.\n\nI've tracked this to such scenario:\n\n\n1) main process on gracefull restart calls \n\n/* kill off the idle ones */\nap_mpm_pod_killpg(pod, retained->max_daemons_limit);\n\nand that does dummy_connection() for each pod. This works fast\n(1-2s) in most cases where childrens exist but if children\nare gone then it can take ages. Why children are gone and why it takes ages? Below.\n\n2) children were busy and notice that new generation is starting and\nthus exit themself without any need to dummy_connection to \"ping\" them:\n\n        else if (retained->my_generation !=\n                 ap_scoreboard_image->global->running_generation) { /* \nrestart? */\n            /* yeah, this could be non-graceful restart, in which case the\n             * parent will kill us soon enough, but why bother checking?\n             */\n            die_now = 1;\n        }\n\n3) Now such scenario can happen? Well in my case main process works\nslowly enough that it doesn't finish doing ap_mpm_pod_killpg before\nall children exit like in 2). Basically in middle of ap_mpm_pod_killpg()\nloop all children already exited. The rest of loop takes then long time.\n\n4) so we are ending up in situation where main process is in middle\nof ap_mpm_pod_killpg while all children already exited in 2). Main\nprocess is continuing to do dummy_connection and these connect()s\n+ dummy data send, polling are taking very long time (like 1-2s for each\ndummy_connection * num of these connections). This is the primary reason\nwhy graceful is painfully slow here (1-5 minutes) sometimes.\n\n5) why connect() and socket sending in dummy_connect succeed if there\nare no children? If it failed then ap_mpm_pod_killpg loop would break\nand things would end quite fast.\n\nSince all children exited there is only main process left that still\nholds listening socket and connection go to this socket. But main process\ndoesn't call accept() and these connections are not processed. dummy_donnection\nsending doesn't fail due to the way tcp works. So loop in ap_mpm_pod_killpg\nstill get processed but each step takes 1-2s * 64 or more StartServers setting.\n\nTested the listening vs accept theory by doing external telnet connection\nto the same IP/port dummy_connection is doing - telnet connect() succeeded\nbut telnet data is not processed since main process is not doing accept() etc yet.\n\n6) possible solution - detect that children already exited and stop doing pointless/time consuming dummy_connection queries.\n\nvoid ap_mpm_pod_killpg(ap_pod_t *pod, int num)\n{\n    int i;\n    int max_daemons;\n    apr_status_t rv = APR_SUCCESS;\n\n    sleep(5); // THIS MAKES REPRODUCING THIS PROBLEM VERY EASY THING\n              // SINCE REPRODUCING HEAVILY RELIES ON TIMMING\n\n    /* we don't write anything to the pod here...  we assume\n     * that the would-be reader of the pod has another way to\n     * see that it is time to die once we wake it up\n     *\n     * writing lots of things to the pod at once is very\n     * problematic... we can fill the kernel pipe buffer and\n     * be blocked until somebody consumes some bytes or\n     * we hit a timeout...  if we hit a timeout we can't just\n     * keep trying because maybe we'll never successfully\n     * write again...  but then maybe we'll leave would-be\n     * readers stranded (a number of them could be tied up for\n     * a while serving time-consuming requests)\n     */\n  \n    for (i = 0; i < num && rv == APR_SUCCESS; ++i) {\n        process_score *ps = ap_get_scoreboard_process(i);\n        pid_t pid = ps->pid;\n\n        if (pid == 0) {\n            continue; /* not every scoreboard entry is in use */\n        }\n\n        rv = dummy_connection(pod);\n    }\n\nSomething like this - so basically do dummy_connection() as long as we have childrens living. Unfortunately not sure if this approach is always correct (I'm not sure if scoreboard is updated correctly when children exit in such case).\n\n\n\n7) how to reproduce?\n\nSet StartServers to big number (64 or more), so ap_mpm_pod_killpg will have this number passed in \"num\" parameter and thus will have bigger number of loop iterations to do.\n\nMain process needs to be slown down while doing ap_mpm_pod_killpg(), so that children have a chance to exit in 2) before ap_mpm_pod_killpg finishes. In my production setup this simply happens. Since it's timing dependant it is not always easy to reproduce.\n\nAnyway how we can help it be reproduced:\n- add sleep(5); at beginning of mpm_pod_killpg. This simulates a case when main process does its things in slower way than children exiting\n\nSo:\n- add sleep or slow down main process in some other way (stracing main process in my case was also being enough to slown it down)\n- ab -n 100000 -c 100 http://apache.ip\n- before ab finishes initiate graceful restart\n\nRelevant thread on mailing list\nhttp://mail-archives.apache.org/mod_mbox/httpd-dev/201304.mbox/browser\n(unfortunately not a popular subjects among devs, so creating this bug report,\nso it won't get lost)", "id": 166647, "time": "2013-04-16T08:52:07Z", "creator": "arekm@maven.pl", "creation_time": "2013-04-16T08:52:07Z", "is_private": false, "attachment_id": null}, {"text": "I can confirm this bug.\n\nI\u2019m running apache 2.2.x (24 now) with about 250 connections open all the time. Reloading apache configuration (apachectl graceful) is very slow and takes 1-4 minutes. During that time new connections are established but webpages are not served. Monitoring programs with a timeout will detect this as apache crash and try to restart it which makes situation even more complicated. I\u2019ve seen this issue for years now.\n\nI\u2019ve applied Arkadiusz Miskiewicz patch for 2.2.24 (http://comments.gmane.org/gmane.comp.apache.devel/50249) and it makes quite a difference. Graceful restarts are now executed in 4-12 seconds. I personaly think it is still to long. Webpages on webserver should not be inaccessible due to graceful restart even for 2 seconds. There great is need for better way of reloading configuration and \u201cgraceful\u201d was always quick and very dirty walkaround.", "tags": [], "bug_id": 54852, "is_private": false, "count": 1, "id": 167518, "time": "2013-05-30T18:10:04Z", "creator": "naox@yum.pl", "creation_time": "2013-05-30T18:10:04Z", "attachment_id": null}, {"count": 2, "tags": [], "bug_id": 54852, "attachment_id": null, "text": "Certainly, dummy_connection() setting a 3 *second* timeout is bogus...\n\nWill look...", "id": 171244, "time": "2013-11-15T14:55:34Z", "creator": "jim@apache.org", "creation_time": "2013-11-15T14:55:34Z", "is_private": false}, {"count": 3, "tags": [], "creator": "trawick@apache.org", "attachment_id": null, "id": 171245, "time": "2013-11-15T15:07:32Z", "bug_id": 54852, "creation_time": "2013-11-15T15:07:32Z", "is_private": false, "text": "At least for worker, \"ap_mpm_pod_killpg(pod, ap_daemons_limit, TRUE);\" should probably use the usually-smaller ap_max_daemons_limit.  (That's from looking at 2.2 worker.c recently; I didn't check other MPMs/branches.)  This could help some.\n\nIt is important for users to check the time between these two messages so that it is clear it is the same problem.\n\nSIGUSR1 received.  Doing graceful restart \nApache (Unix) configured -- resuming normal operations"}, {"count": 4, "tags": [], "bug_id": 54852, "attachment_id": 31046, "id": 171248, "creation_time": "2013-11-15T15:30:02Z", "time": "2013-11-15T15:30:02Z", "creator": "jim@apache.org", "text": "Created attachment 31046\nOnly check idle", "is_private": false}, {"count": 5, "tags": [], "bug_id": 54852, "is_private": false, "id": 171250, "creation_time": "2013-11-15T18:39:37Z", "time": "2013-11-15T18:39:37Z", "creator": "jim@apache.org", "text": "Patch in trunk", "attachment_id": null}, {"count": 6, "tags": [], "bug_id": 54852, "text": "To avoid any confusion this is first fixed in 2.4.10.", "id": 191711, "time": "2016-06-16T08:57:45Z", "creator": "dusteland@gmail.com", "creation_time": "2016-06-16T08:57:45Z", "is_private": false, "attachment_id": null}]