[{"count": 0, "tags": [], "bug_id": 16658, "attachment_id": null, "text": "For providers, it seems to me it would make more sense to return an apr_xml_elem\nnode representing the value of the property rather than a textual representation\nof that, given that the store() function is passed an apr_xml_elem. How about\nadding something like:\n\ndav_error *retrieve(dav_db *db, dav_property_name *name, apr_xml_elem **elem)\n\n?", "id": 30447, "time": "2003-01-31T22:42:52Z", "creator": "Christopher.D.Knight@nasa.gov", "creation_time": "2003-01-31T22:42:52Z", "is_private": false}, {"count": 1, "tags": [], "text": "The apr_xml_* structures are used for parsing, rather than as a generic DOM\nmechanism. mod_dav would simply serialize the result anyways. The output_value\nfunction was designed to move the serialization into the provider. This was done\nbecause the provider knows *much* more about how to efficiently serialize the\nresults. In fact, it could be very painful for the provider to construct an\napr_xml_elem structure simply to see mod_dav serialize it for output.\n\nAs an example, mod_dav_fs pre-serializes all properties. When you do a PROPFIND,\nit just yanks them out of the DB and returns them. That's why we do all the\nfunky namespace mapping backflips.\n\nIn a future revision of the API, we'll even eliminate the text stuff, and ask\nthe provider to jam the results directly into an Apache output filter (much like\nhow the reports operate). Then we can see some *real* kickass stuff since\nwriting values into a filter can use zero-copy techniques for high efficiency.\nImagine doing an array-fetch from Oracle, and referring to the output binding\nbuffers with some TRANSIENT buckets, and tossing those into the filter. \n\nI'm closing this enhancement request as WONTFIX.", "attachment_id": null, "id": 38328, "creator": "gstein@gmail.com", "time": "2003-06-04T10:36:01Z", "bug_id": 16658, "creation_time": "2003-06-04T10:36:01Z", "is_private": false}]