[{"count": 0, "tags": [], "bug_id": 47642, "text": "Consider\n\n\n<project default=\"run\">\n    <available property=\"compiled\" file=\"Test.class\"/>\n    <target name=\"compile\" unless=\"compiled\">\n        <echo file=\"Test.java\">\npublic class Test {\n    public static void main(String[] args) {\n        System.out.println(\"out\");\n        System.out.flush();\n        System.err.println(\"err\");\n    }\n}\n        </echo>\n        <javac srcdir=\".\" destdir=\".\" includeantruntime=\"false\" source=\"1.5\" includes=\"Test.java\"/>\n    </target>\n    <target name=\"run\" depends=\"compile\">\n        <java fork=\"true\" classname=\"Test\" classpath=\".\"/>\n    </target>\n</project>\n\n\nYou would expect this program to always print \"out\" followed by \"err\", and when run without Ant it does. When run using Ant, occasionally it prints \"err\" followed by \"out\". This can be made frequent enough to observe by introducing some artificial latency:\n\n\nIndex: src/main/org/apache/tools/ant/taskdefs/StreamPumper.java\n===================================================================\n--- src/main/org/apache/tools/ant/taskdefs/StreamPumper.java\t(revision 799653)\n+++ src/main/org/apache/tools/ant/taskdefs/StreamPumper.java\t(working copy)\n@@ -20,6 +20,7 @@\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n+import java.util.Random;\n import org.apache.tools.ant.util.FileUtils;\n \n /**\n@@ -115,6 +116,11 @@\n         synchronized (this) {\n             started = true;\n         }\n+        if (new Random().nextBoolean()) {\n+            try {\n+                Thread.sleep(1000);\n+            } catch (InterruptedException ex) {}\n+        }\n         finished = false;\n         finish = false;\n \n\nThe trouble is that PumpStreamHandler spawns one copier thread per I/O stream, and there is no guarantee that these threads will not be preempted. \"out\\n\" becomes available on process.inputStream just before \"err\\n\" becomes available on process.errorStream, so only if the stdout StreamPumper is ready to run will it actually run before the stderr StreamPumper. In other words, there is a race condition.\n\nAs for a possible fix, java.nio.channels.Selector should be able to poll all the process I/O streams deterministically. You would still need a separate copier thread, but at least select() should return 1 after out.flush() was called, and selectedKeys() should have stdout only, so the next call to select() would happen only after stdout was processed. At least I think so.\n\n\nOriginal report: http://www.netbeans.org/nonav/issues/show_bug.cgi?id=145980", "id": 129454, "time": "2009-08-04T13:48:30Z", "creator": "jglick@apache.org", "creation_time": "2009-08-04T13:48:30Z", "is_private": false, "attachment_id": null}]