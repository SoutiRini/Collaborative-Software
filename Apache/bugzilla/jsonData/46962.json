[{"count": 0, "tags": [], "creator": "rogov@devexperts.com", "text": "I have a multithreaded rendering application. Shortly after we had migrated to some nice smooth and very fast hardware, we started getting Java deadlocks in FOP code. Stack traces always looked like this one:\n\n\"T4-CFD_MR accId=3065\" prio=10 tid=0x00002aab37aa1400 nid=0x6123 waiting for monitor entry [0x000000004193e000..0x0000000041941ac0]\n   java.lang.Thread.State: BLOCKED (on object monitor)\n        at org.apache.fop.fo.properties.PropertyCache.get(PropertyCache.java:204)\n        - waiting to lock <0x00002aaab388a3f8> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n        at org.apache.fop.fo.properties.PropertyCache.fetch(PropertyCache.java:283)\n        at org.apache.fop.fo.properties.PropertyCache.fetch(PropertyCache.java:301)\n        at org.apache.fop.fo.properties.NumberProperty.getInstance(NumberProperty.java:120)\n        at org.apache.fop.fo.expr.PropertyParser.parsePrimaryExpr(PropertyParser.java:262)\n        at org.apache.fop.fo.expr.PropertyParser.parseUnaryExpr(PropertyParser.java:212)\n        at org.apache.fop.fo.expr.PropertyParser.parseMultiplicativeExpr(PropertyParser.java:177)\n        at org.apache.fop.fo.expr.PropertyParser.parseAdditiveExpr(PropertyParser.java:151)\n        at org.apache.fop.fo.expr.PropertyParser.parseArgs(PropertyParser.java:378)\n        at org.apache.fop.fo.expr.PropertyParser.parsePrimaryExpr(PropertyParser.java:343)\n        at org.apache.fop.fo.expr.PropertyParser.parseUnaryExpr(PropertyParser.java:212)\n        at org.apache.fop.fo.expr.PropertyParser.parseMultiplicativeExpr(PropertyParser.java:177)\n        at org.apache.fop.fo.expr.PropertyParser.parseAdditiveExpr(PropertyParser.java:151)\n        at org.apache.fop.fo.expr.PropertyParser.parseProperty(PropertyParser.java:125)\n\n================================\n\n\"T3-CFD_MR accId=3031\" prio=10 tid=0x00002aab37a68800 nid=0x6122 waiting for monitor entry [0x000000004183c000..0x0000000041840c40]\n   java.lang.Thread.State: BLOCKED (on object monitor)\n        at org.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:226)\n        - waiting to lock <0x00002aaab388a650> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n        at org.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:228)\n        - locked <0x00002aaab388b200> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n        at org.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:228)\n        - locked <0x00002aaab388b228> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n        at org.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:228)\n        - locked <0x00002aaab388b250> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n        at org.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:228)\n        - locked <0x00002aaab388b278> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n        at org.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:228)\n        - locked <0x00002aaab388b2a0> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n        at org.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:228)\n        - locked <0x00002aaab388b368> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n        at org.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:228)\n\n================================\n\n\"T2-CFD_MR accId=2823\" prio=10 tid=0x00002aab37a66c00 nid=0x6121 waiting for monitor entry [0x000000004173c000..0x000000004173fbc0]\n   java.lang.Thread.State: BLOCKED (on object monitor)\n        at org.apache.fop.fo.properties.PropertyCache.cleanSegment(PropertyCache.java:114)\n        - waiting to lock <0x00002aaab38a33b8> (a [Z)\n        at org.apache.fop.fo.properties.PropertyCache.put(PropertyCache.java:176)\n        - locked <0x00002aaab388a650> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n        at org.apache.fop.fo.properties.PropertyCache.fetch(PropertyCache.java:287)\n        at org.apache.fop.fo.properties.PropertyCache.fetch(PropertyCache.java:301)\n        at org.apache.fop.fo.properties.NumberProperty.getInstance(NumberProperty.java:120)\n        at org.apache.fop.fo.expr.PropertyParser.parsePrimaryExpr(PropertyParser.java:262)\n        at org.apache.fop.fo.expr.PropertyParser.parseUnaryExpr(PropertyParser.java:212)\n        at org.apache.fop.fo.expr.PropertyParser.parseMultiplicativeExpr(PropertyParser.java:177)\n        at org.apache.fop.fo.expr.PropertyParser.parseAdditiveExpr(PropertyParser.java:151)\n        at org.apache.fop.fo.expr.PropertyParser.parseArgs(PropertyParser.java:378)\n        at org.apache.fop.fo.expr.PropertyParser.parsePrimaryExpr(PropertyParser.java:343)\n        at org.apache.fop.fo.expr.PropertyParser.parseUnaryExpr(PropertyParser.java:212)\n        at org.apache.fop.fo.expr.PropertyParser.parseMultiplicativeExpr(PropertyParser.java:177)\n\n================================\n\n\"T1-CFD_MR accId=3070\" prio=10 tid=0x00002aab37a5a000 nid=0x6120 waiting for monitor entry [0x000000004163c000..0x000000004163ed40]\n   java.lang.Thread.State: BLOCKED (on object monitor)\n        at org.apache.fop.fo.properties.PropertyCache.cleanSegment(PropertyCache.java:114)\n        - waiting to lock <0x00002aaab38a33b8> (a [Z)\n        at org.apache.fop.fo.properties.PropertyCache.put(PropertyCache.java:176)\n        - locked <0x00002aaab388a330> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n        at org.apache.fop.fo.properties.PropertyCache.fetch(PropertyCache.java:287)\n        at org.apache.fop.fo.properties.PropertyCache.fetch(PropertyCache.java:301)\n        at org.apache.fop.fo.properties.NumberProperty.getInstance(NumberProperty.java:109)\n        at org.apache.fop.fo.expr.PropertyParser.parsePrimaryExpr(PropertyParser.java:258)\n        at org.apache.fop.fo.expr.PropertyParser.parseUnaryExpr(PropertyParser.java:212)\n        at org.apache.fop.fo.expr.PropertyParser.parseMultiplicativeExpr(PropertyParser.java:177)\n        at org.apache.fop.fo.expr.PropertyParser.parseAdditiveExpr(PropertyParser.java:151)\n        at org.apache.fop.fo.expr.PropertyParser.parseProperty(PropertyParser.java:125)\n        at org.apache.fop.fo.expr.PropertyParser.parse(PropertyParser.java:91)\n        at org.apache.fop.fo.properties.PropertyMaker.make(PropertyMaker.java:436)\n        at org.apache.fop.fo.properties.CompoundPropertyMaker.make(CompoundPropertyMaker.java:207)\n\n================================\n\n\"T0-CFD_MR accId=2852\" prio=10 tid=0x00002aab37a59800 nid=0x611f waiting for monitor entry [0x000000004153a000..0x000000004153dcc0]\n   java.lang.Thread.State: BLOCKED (on object monitor)\n        at org.apache.fop.fo.properties.PropertyCache.cleanSegment(PropertyCache.java:114)\n        - waiting to lock <0x00002aaab38a33b8> (a [Z)\n        at org.apache.fop.fo.properties.PropertyCache.put(PropertyCache.java:176)\n        - locked <0x00002aaab388a3f8> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n        at org.apache.fop.fo.properties.PropertyCache.fetch(PropertyCache.java:287)\n        at org.apache.fop.fo.properties.PropertyCache.fetch(PropertyCache.java:301)\n        at org.apache.fop.fo.properties.NumberProperty.getInstance(NumberProperty.java:120)\n        at org.apache.fop.fo.expr.PropertyParser.parsePrimaryExpr(PropertyParser.java:262)\n        at org.apache.fop.fo.expr.PropertyParser.parseUnaryExpr(PropertyParser.java:212)\n        at org.apache.fop.fo.expr.PropertyParser.parseMultiplicativeExpr(PropertyParser.java:177)\n        at org.apache.fop.fo.expr.PropertyParser.parseAdditiveExpr(PropertyParser.java:151)\n        at org.apache.fop.fo.expr.PropertyParser.parseArgs(PropertyParser.java:378)\n        at org.apache.fop.fo.expr.PropertyParser.parsePrimaryExpr(PropertyParser.java:343)\n        at org.apache.fop.fo.expr.PropertyParser.parseUnaryExpr(PropertyParser.java:212)\n        at org.apache.fop.fo.expr.PropertyParser.parseMultiplicativeExpr(PropertyParser.java:177)\n\n================================\nEND OF STACKS\n\n\nwith some combination of get(), put(), cleanSegment() and rehash() methods.\n\nCan you provide any kind of workaround for this that can be done quickly ?? We are in production and suffer from these nasty deadlocks badly, since this application is mostly launched by schedule and we can't monitor it all the time. Is there something that can be done ??", "id": 125976, "time": "2009-04-03T07:33:01Z", "bug_id": 46962, "creation_time": "2009-04-03T07:33:01Z", "is_private": false, "attachment_id": null}, {"text": "\nThanks for the report. We will investigate this closer ASAP. \nFor now, the only immediate relief would be to switch to FOP Trunk, which allows to disable the PropertyCache via a system property \"org.apache.fop.fo.properties.use-cache\". Set it to \"false\" to avoid caching.\nThe drawback is obviously that the processes will all use up more memory (the difference can be quite significant if you have a lot of identical property-specs on a lot of FOs).\n\nFor the rest, it would also be interesting to know more about the environment. \nWhich Java VM (vendor + version) are you using? If it's GNU Classpath, I'd first try if switching to a Sun VM  helps.", "tags": [], "bug_id": 46962, "is_private": false, "count": 1, "id": 125987, "time": "2009-04-03T11:53:01Z", "creator": "adelmelle@apache.org", "creation_time": "2009-04-03T11:53:01Z", "attachment_id": null}, {"count": 2, "attachment_id": null, "creator": "adelmelle@apache.org", "is_private": false, "id": 125988, "time": "2009-04-03T12:20:07Z", "bug_id": 46962, "creation_time": "2009-04-03T12:20:07Z", "tags": [], "text": "(In reply to comment #1)\n\nJust to be complete:\n\n> For now, the only immediate relief would be to switch to FOP Trunk, ...\n\nThe addition of the system property to disable caching of the properties apparently never made it into 0.95, but the required modifications are pretty straightforward:\n- add a 'useCache' member to PropertyCache\n- in the constructor, initialize it to reflect the value of the system property\n- in the generic, private fetch() method, if useCache is \"true\", bypass the entire method body, and simply return the parameter instance\n\nApart from that, no easy solution I'm afraid. It comes down to choosing the lesser of two 'evils': \n* either use the Trunk version, which means, strictly speaking, no guarantees about stability, although there are people who do use it in production environments\n* or modify the sources in the 0.95 branch, which also leaves you with an unofficial version.\n\nAgain, we'll be look into it closer soon, but these types of issues are almost always very difficult to reproduce..."}, {"count": 3, "tags": [], "creator": "alex.giotis@gmail.com", "text": "Deadlocks in o.a.f.fo.properties.PropertyCache still occur in FOP 1.0 with similar stacktraces (see below). By looking into the code and the stacktraces, the deadlock occurs when the map is rehashed. In short, this is a typical case:\n\n* Thread A invokes put() and acquires a lock on segment 1. \n\n* Thread B invokes put() and acquires a lock on segment 2. \n\n* Both threads determine that their segment should be cleared and invoke cleanSegment(). \n\n* Thread A acquires first the lock on votesForRehash, determines that a rehash is required and calls it.\n\n* Thread B holds the lock on segment 2 and waits to acquire the lock on votesForRehash.\n\n* Thread A executes the rehash() method which tries to recursively acquire locks on all segments.\n\n* Thread A and thread B deadlock because neither will release locks that the other wants.\n\n\n\nRelevant stacktraces from a production server:\n\n\"Thread A\" stacktrace:\n\t\torg.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:245)\n\t\torg.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:247)\n\t\torg.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:247)\n\t\torg.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:247)\n\t\torg.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:247)\n\t\torg.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:247)\n\t\torg.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:247)\n\t\torg.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:247)\n\t\torg.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:247)\n\t\torg.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:247)\n\t\torg.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:247)\n\t\torg.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:247)\n\t\torg.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:247)\n\t\torg.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:247)\n\t\torg.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:247)\n\t\torg.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:247)\n\t\torg.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:247)\n\t\torg.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:247)\n\t\torg.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:247)\n\t\torg.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:247)\n\t\torg.apache.fop.fo.properties.PropertyCache.cleanSegment(PropertyCache.java:151)\n\t\torg.apache.fop.fo.properties.PropertyCache.put(PropertyCache.java:195)\n\t\torg.apache.fop.fo.properties.PropertyCache.fetch(PropertyCache.java:317)\n\t\torg.apache.fop.fo.properties.PropertyCache.fetch(PropertyCache.java:331)\n\t\torg.apache.fop.fo.properties.CondLengthProperty.getCondLength(CondLengthProperty.java:161)\n\t\torg.apache.fop.fo.properties.CommonBorderPaddingBackground.initBorderInfo(CommonBorderPaddingBackground.java:400)\n\t\torg.apache.fop.fo.properties.CommonBorderPaddingBackground.<init>(CommonBorderPaddingBackground.java:316)\n\t\torg.apache.fop.fo.properties.CommonBorderPaddingBackground.getInstance(CommonBorderPaddingBackground.java:350)\n\t\torg.apache.fop.fo.PropertyList.getBorderPaddingBackgroundProps(PropertyList.java:576)\n\t\torg.apache.fop.fo.flow.table.TableCell.bind(TableCell.java:77)\n\t\torg.apache.fop.fo.FObj.processNode(FObj.java:123)\n\t\torg.apache.fop.fo.flow.table.TableFObj.processNode(TableFObj.java:233)\n\t\torg.apache.fop.fo.FOTreeBuilder$MainFOHandler.startElement(FOTreeBuilder.java:282)\n\t\torg.apache.fop.fo.FOTreeBuilder.startElement(FOTreeBuilder.java:171)\n\t\torg.xml.sax.helpers.XMLFilterImpl.startElement(XMLFilterImpl.java:527)\n\t\torg.xml.sax.helpers.XMLFilterImpl.startElement(XMLFilterImpl.java:527)\n\t\tcom.idocs.export2.filters.IgnoreThisSectionFilter.startElement(IgnoreThisSectionFilter.java:33)\n\t\torg.apache.xml.serializer.ToXMLSAXHandler.closeStartTag(ToXMLSAXHandler.java:206)\n\t\torg.apache.xml.serializer.ToSAXHandler.flushPending(ToSAXHandler.java:279)\n\t\torg.apache.xml.serializer.ToXMLSAXHandler.startPrefixMapping(ToXMLSAXHandler.java:350)\n\t\torg.apache.xml.serializer.ToXMLSAXHandler.startPrefixMapping(ToXMLSAXHandler.java:320)\n\t\torg.apache.xalan.templates.ElemLiteralResult.execute(ElemLiteralResult.java:1317)\n\t\torg.apache.xalan.transformer.TransformerImpl.executeChildTemplates(TransformerImpl.java:2400)\n\t\torg.apache.xalan.templates.ElemLiteralResult.execute(ElemLiteralResult.java:1376)\n\t\torg.apache.xalan.transformer.TransformerImpl.executeChildTemplates(TransformerImpl.java:2400)\n\t\torg.apache.xalan.templates.ElemLiteralResult.execute(ElemLiteralResult.java:1376)\n\t\torg.apache.xalan.transformer.TransformerImpl.executeChildTemplates(TransformerImpl.java:2400)\n\t\torg.apache.xalan.templates.ElemLiteralResult.execute(ElemLiteralResult.java:1376)\n\t\torg.apache.xalan.transformer.TransformerImpl.executeChildTemplates(TransformerImpl.java:2400)\n\t\torg.apache.xalan.templates.ElemTemplate.execute(ElemTemplate.java:394)\n\t\torg.apache.xalan.templates.ElemCallTemplate.execute(ElemCallTemplate.java:248)\n\t\torg.apache.xalan.transformer.TransformerImpl.executeChildTemplates(TransformerImpl.java:2400)\n\t\torg.apache.xalan.templates.ElemLiteralResult.execute(ElemLiteralResult.java:1376)\n\t\torg.apache.xalan.transformer.TransformerImpl.executeChildTemplates(TransformerImpl.java:2400)\n\t\torg.apache.xalan.templates.ElemLiteralResult.execute(ElemLiteralResult.java:1376)\n\t\torg.apache.xalan.transformer.TransformerImpl.executeChildTemplates(TransformerImpl.java:2400)\n\t\torg.apache.xalan.templates.ElemLiteralResult.execute(ElemLiteralResult.java:1376)\n\t\torg.apache.xalan.transformer.TransformerImpl.executeChildTemplates(TransformerImpl.java:2400)\n\t\torg.apache.xalan.templates.ElemLiteralResult.execute(ElemLiteralResult.java:1376)\n\t\torg.apache.xalan.transformer.TransformerImpl.executeChildTemplates(TransformerImpl.java:2400)\n\t\torg.apache.xalan.transformer.TransformerImpl.applyTemplateToNode(TransformerImpl.java:2270)\n\t\torg.apache.xalan.transformer.TransformerImpl.transformNode(TransformerImpl.java:1356)\n\t\torg.apache.xalan.transformer.TransformerImpl.run(TransformerImpl.java:3447)\n\t\torg.apache.xalan.transformer.TransformerHandlerImpl.endDocument(TransformerHandlerImpl.java:408)\n\t\torg.xml.sax.helpers.XMLFilterImpl.endDocument(XMLFilterImpl.java:473)\n\t\torg.xml.sax.helpers.XMLFilterImpl.endDocument(XMLFilterImpl.java:473)\n\t\tcom.idocs.export2.filters.SplitElementsXMLFilter.endDocument(SplitElementsXMLFilter.java:59)\n\t\torg.xml.sax.helpers.XMLFilterImpl.endDocument(XMLFilterImpl.java:473)\n\t\torg.xml.sax.helpers.XMLFilterImpl.endDocument(XMLFilterImpl.java:473)\n\t\tcom.idocs.export2.filters.SectionSplittingXMLFilter.endSection(SectionSplittingXMLFilter.java:218)\n\t\tcom.idocs.export2.filters.SectionSplittingXMLFilter.startNewSection(SectionSplittingXMLFilter.java:195)\n\t\tcom.idocs.export2.filters.SectionSplittingXMLFilter.findMatchingXslt(SectionSplittingXMLFilter.java:166)\n\t\tcom.idocs.export2.filters.SectionSplittingXMLFilter.startElement(SectionSplittingXMLFilter.java:106)\n\t\torg.xml.sax.helpers.XMLFilterImpl.startElement(XMLFilterImpl.java:527)\n\t\tcom.idocs.export2.filters.XPathMatchingFilter.startElement(XPathMatchingFilter.java:70)\n\t\torg.apache.xerces.parsers.AbstractSAXParser.startElement(Unknown Source)\n\t\torg.apache.xerces.impl.XMLNSDocumentScannerImpl.scanStartElement(Unknown Source)\n\t\torg.apache.xerces.impl.XMLDocumentFragmentScannerImpl$FragmentContentDispatcher.dispatch(Unknown Source)\n\t\torg.apache.xerces.impl.XMLDocumentFragmentScannerImpl.scanDocument(Unknown Source)\n\t\torg.apache.xerces.parsers.XML11Configuration.parse(Unknown Source)\n\t\torg.apache.xerces.parsers.XML11Configuration.parse(Unknown Source)\n\t\torg.apache.xerces.parsers.XMLParser.parse(Unknown Source)\n\t\torg.apache.xerces.parsers.AbstractSAXParser.parse(Unknown Source)\n\t\torg.xml.sax.helpers.XMLFilterImpl.parse(XMLFilterImpl.java:333)\n\t\torg.xml.sax.helpers.XMLFilterImpl.parse(XMLFilterImpl.java:333)\n\t\torg.xml.sax.helpers.XMLFilterImpl.parse(XMLFilterImpl.java:333)\n\t\torg.xml.sax.helpers.XMLFilterImpl.parse(XMLFilterImpl.java:333)\n\t\torg.xml.sax.helpers.XMLFilterImpl.parse(XMLFilterImpl.java:333)\n\t\torg.xml.sax.helpers.XMLFilterImpl.parse(XMLFilterImpl.java:333)\n\t\torg.xml.sax.helpers.XMLFilterImpl.parse(XMLFilterImpl.java:333)\n\t\torg.xml.sax.helpers.XMLFilterImpl.parse(XMLFilterImpl.java:333)\n\t\torg.apache.xalan.transformer.TransformerIdentityImpl.transform(TransformerIdentityImpl.java:485)\n\t\tcom.idocs.export2.filters.FromXmlFilterChain.transformSaxSource(FromXmlFilterChain.java:224)\n\t\tcom.idocs.export2.filters.FromXmlFilterChain.transformToYarEntries(FromXmlFilterChain.java:233)\n\t\tcom.idocs.export2.filters.FromXmlFilterChain.tranform(FromXmlFilterChain.java:93)\n\t\tcom.idocs.export2.SectionsWorker$1.writeContent(SectionsWorker.java:208)\n\t\tcom.idocs.base.document.DirectContentWriter.writeContent(DirectContentWriter.java:96)\n\t\tcom.idocs.base.connection.docrep2.Docrep2Connection.writeContent(Docrep2Connection.java:476)\n\t\tcom.idocs.base.connection.docrep2.Docrep2Connection.insertDocument(Docrep2Connection.java:413)\n\t\tcom.idocs.base.connection.docrep2.Docrep2Connection.insert(Docrep2Connection.java:367)\n\t\tcom.idocs.base.connection.Session.insert(Session.java:539)\n\t\tcom.idocs.export2.SectionsWorker.writeOutputTo(SectionsWorker.java:218)\n\t\tcom.idocs.export2.SectionsWorker.transform(SectionsWorker.java:162)\n\t\tcom.idocs.export2.SectionsWorker.work(SectionsWorker.java:118)\n\t\tcom.idocs.base.worker.WorkerWrapper.invokeInContext(WorkerWrapper.java:87)\n\t\tcom.idocs.base.worker.WorkerWrapper.invoke(WorkerWrapper.java:68)\n\t\tcom.idocs.base.cluster.node.TaskExecutor$WorkerRunnable.executeTask(TaskExecutor.java:289)\n\t\tcom.idocs.base.cluster.node.TaskExecutor$WorkerRunnable.run(TaskExecutor.java:206)\n\t\tjava.util.concurrent.Executors$RunnableAdapter.call(Executors.java:441)\n\t\tjava.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303)\n\t\tjava.util.concurrent.FutureTask.run(FutureTask.java:138)\n\t\tjava.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)\n\t\tjava.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)\n\t\tjava.lang.Thread.run(Thread.java:619)\n\n\n\n\n\n\n\"Thread B\" stacktrace:\n\n\t\torg.apache.fop.fo.properties.PropertyCache.cleanSegment(PropertyCache.java:135)\n\t\torg.apache.fop.fo.properties.PropertyCache.put(PropertyCache.java:195)\n\t\torg.apache.fop.fo.properties.PropertyCache.fetch(PropertyCache.java:317)\n\t\torg.apache.fop.fo.properties.PropertyCache.fetch(PropertyCache.java:331)\n\t\torg.apache.fop.fo.properties.CondLengthProperty.getCondLength(CondLengthProperty.java:161)\n\t\torg.apache.fop.fo.properties.CommonBorderPaddingBackground.initBorderInfo(CommonBorderPaddingBackground.java:400)\n\t\torg.apache.fop.fo.properties.CommonBorderPaddingBackground.<init>(CommonBorderPaddingBackground.java:321)\n\t\torg.apache.fop.fo.properties.CommonBorderPaddingBackground.getInstance(CommonBorderPaddingBackground.java:350)\n\t\torg.apache.fop.fo.PropertyList.getBorderPaddingBackgroundProps(PropertyList.java:576)\n\t\torg.apache.fop.fo.flow.table.TableCell.bind(TableCell.java:77)\n\t\torg.apache.fop.fo.FObj.processNode(FObj.java:123)\n\t\torg.apache.fop.fo.flow.table.TableFObj.processNode(TableFObj.java:233)\n\t\torg.apache.fop.fo.FOTreeBuilder$MainFOHandler.startElement(FOTreeBuilder.java:282)\n\t\torg.apache.fop.fo.FOTreeBuilder.startElement(FOTreeBuilder.java:171)\n\t\torg.xml.sax.helpers.XMLFilterImpl.startElement(XMLFilterImpl.java:527)\n\t\torg.xml.sax.helpers.XMLFilterImpl.startElement(XMLFilterImpl.java:527)\n\t\tcom.idocs.export2.filters.IgnoreThisSectionFilter.startElement(IgnoreThisSectionFilter.java:33)\n\t\torg.apache.xml.serializer.ToXMLSAXHandler.closeStartTag(ToXMLSAXHandler.java:206)\n\t\torg.apache.xml.serializer.ToSAXHandler.flushPending(ToSAXHandler.java:279)\n\t\torg.apache.xml.serializer.ToXMLSAXHandler.startPrefixMapping(ToXMLSAXHandler.java:350)\n\t\torg.apache.xml.serializer.ToXMLSAXHandler.startPrefixMapping(ToXMLSAXHandler.java:320)\n\t\torg.apache.xalan.templates.ElemLiteralResult.execute(ElemLiteralResult.java:1317)\n\t\torg.apache.xalan.transformer.TransformerImpl.executeChildTemplates(TransformerImpl.java:2400)\n\t\torg.apache.xalan.templates.ElemLiteralResult.execute(ElemLiteralResult.java:1376)\n\t\torg.apache.xalan.transformer.TransformerImpl.executeChildTemplates(TransformerImpl.java:2400)\n\t\torg.apache.xalan.templates.ElemLiteralResult.execute(ElemLiteralResult.java:1376)\n\t\torg.apache.xalan.transformer.TransformerImpl.executeChildTemplates(TransformerImpl.java:2400)\n\t\torg.apache.xalan.templates.ElemLiteralResult.execute(ElemLiteralResult.java:1376)\n\t\torg.apache.xalan.templates.ElemApplyTemplates.transformSelectedNodes(ElemApplyTemplates.java:395)\n\t\torg.apache.xalan.templates.ElemApplyTemplates.execute(ElemApplyTemplates.java:178)\n\t\torg.apache.xalan.transformer.TransformerImpl.executeChildTemplates(TransformerImpl.java:2400)\n\t\torg.apache.xalan.templates.ElemLiteralResult.execute(ElemLiteralResult.java:1376)\n\t\torg.apache.xalan.transformer.TransformerImpl.executeChildTemplates(TransformerImpl.java:2400)\n\t\torg.apache.xalan.templates.ElemLiteralResult.execute(ElemLiteralResult.java:1376)\n\t\torg.apache.xalan.transformer.TransformerImpl.executeChildTemplates(TransformerImpl.java:2400)\n\t\torg.apache.xalan.templates.ElemLiteralResult.execute(ElemLiteralResult.java:1376)\n\t\torg.apache.xalan.transformer.TransformerImpl.executeChildTemplates(TransformerImpl.java:2400)\n\t\torg.apache.xalan.templates.ElemLiteralResult.execute(ElemLiteralResult.java:1376)\n\t\torg.apache.xalan.transformer.TransformerImpl.executeChildTemplates(TransformerImpl.java:2400)\n\t\torg.apache.xalan.transformer.TransformerImpl.applyTemplateToNode(TransformerImpl.java:2270)\n\t\torg.apache.xalan.transformer.TransformerImpl.transformNode(TransformerImpl.java:1356)\n\t\torg.apache.xalan.transformer.TransformerImpl.run(TransformerImpl.java:3447)\n\t\torg.apache.xalan.transformer.TransformerHandlerImpl.endDocument(TransformerHandlerImpl.java:408)\n\t\torg.xml.sax.helpers.XMLFilterImpl.endDocument(XMLFilterImpl.java:473)\n\t\torg.xml.sax.helpers.XMLFilterImpl.endDocument(XMLFilterImpl.java:473)\n\t\tcom.idocs.export2.filters.SplitElementsXMLFilter.endDocument(SplitElementsXMLFilter.java:59)\n\t\torg.xml.sax.helpers.XMLFilterImpl.endDocument(XMLFilterImpl.java:473)\n\t\torg.xml.sax.helpers.XMLFilterImpl.endDocument(XMLFilterImpl.java:473)\n\t\tcom.idocs.export2.filters.SectionSplittingXMLFilter.endSection(SectionSplittingXMLFilter.java:218)\n\t\tcom.idocs.export2.filters.SectionSplittingXMLFilter.startNewSection(SectionSplittingXMLFilter.java:195)\n\t\tcom.idocs.export2.filters.SectionSplittingXMLFilter.findMatchingXslt(SectionSplittingXMLFilter.java:166)\n\t\tcom.idocs.export2.filters.SectionSplittingXMLFilter.startElement(SectionSplittingXMLFilter.java:106)\n\t\torg.xml.sax.helpers.XMLFilterImpl.startElement(XMLFilterImpl.java:527)\n\t\tcom.idocs.export2.filters.XPathMatchingFilter.startElement(XPathMatchingFilter.java:70)\n\t\torg.apache.xerces.parsers.AbstractSAXParser.startElement(Unknown Source)\n\t\torg.apache.xerces.impl.XMLNSDocumentScannerImpl.scanStartElement(Unknown Source)\n\t\torg.apache.xerces.impl.XMLDocumentFragmentScannerImpl$FragmentContentDispatcher.dispatch(Unknown Source)\n\t\torg.apache.xerces.impl.XMLDocumentFragmentScannerImpl.scanDocument(Unknown Source)\n\t\torg.apache.xerces.parsers.XML11Configuration.parse(Unknown Source)\n\t\torg.apache.xerces.parsers.XML11Configuration.parse(Unknown Source)\n\t\torg.apache.xerces.parsers.XMLParser.parse(Unknown Source)\n\t\torg.apache.xerces.parsers.AbstractSAXParser.parse(Unknown Source)\n\t\torg.xml.sax.helpers.XMLFilterImpl.parse(XMLFilterImpl.java:333)\n\t\torg.xml.sax.helpers.XMLFilterImpl.parse(XMLFilterImpl.java:333)\n\t\torg.xml.sax.helpers.XMLFilterImpl.parse(XMLFilterImpl.java:333)\n\t\torg.xml.sax.helpers.XMLFilterImpl.parse(XMLFilterImpl.java:333)\n\t\torg.xml.sax.helpers.XMLFilterImpl.parse(XMLFilterImpl.java:333)\n\t\torg.xml.sax.helpers.XMLFilterImpl.parse(XMLFilterImpl.java:333)\n\t\torg.xml.sax.helpers.XMLFilterImpl.parse(XMLFilterImpl.java:333)\n\t\torg.xml.sax.helpers.XMLFilterImpl.parse(XMLFilterImpl.java:333)\n\t\torg.apache.xalan.transformer.TransformerIdentityImpl.transform(TransformerIdentityImpl.java:485)\n\t\tcom.idocs.export2.filters.FromXmlFilterChain.transformSaxSource(FromXmlFilterChain.java:224)\n\t\tcom.idocs.export2.filters.FromXmlFilterChain.transformToYarEntries(FromXmlFilterChain.java:233)\n\t\tcom.idocs.export2.filters.FromXmlFilterChain.tranform(FromXmlFilterChain.java:93)\n\t\tcom.idocs.export2.SectionsWorker$1.writeContent(SectionsWorker.java:208)\n\t\tcom.idocs.base.document.DirectContentWriter.writeContent(DirectContentWriter.java:96)\n\t\tcom.idocs.base.connection.docrep2.Docrep2Connection.writeContent(Docrep2Connection.java:476)\n\t\tcom.idocs.base.connection.docrep2.Docrep2Connection.insertDocument(Docrep2Connection.java:413)\n\t\tcom.idocs.base.connection.docrep2.Docrep2Connection.insert(Docrep2Connection.java:367)\n\t\tcom.idocs.base.connection.Session.insert(Session.java:539)\n\t\tcom.idocs.export2.SectionsWorker.writeOutputTo(SectionsWorker.java:218)\n\t\tcom.idocs.export2.SectionsWorker.transform(SectionsWorker.java:162)\n\t\tcom.idocs.export2.SectionsWorker.work(SectionsWorker.java:118)\n\t\tcom.idocs.base.worker.WorkerWrapper.invokeInContext(WorkerWrapper.java:87)\n\t\tcom.idocs.base.worker.WorkerWrapper.invoke(WorkerWrapper.java:68)\n\t\tcom.idocs.base.cluster.node.TaskExecutor$WorkerRunnable.executeTask(TaskExecutor.java:289)\n\t\tcom.idocs.base.cluster.node.TaskExecutor$WorkerRunnable.run(TaskExecutor.java:206)\n\t\tjava.util.concurrent.Executors$RunnableAdapter.call(Executors.java:441)\n\t\tjava.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303)\n\t\tjava.util.concurrent.FutureTask.run(FutureTask.java:138)\n\t\tjava.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)\n\t\tjava.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)\n\t\tjava.lang.Thread.run(Thread.java:619)\n\n\n\n\n\n\nStacktraces from a test case that reproduces this issue:\n\n\"Thread A\":\n\"pool-1-thread-2\" prio=5 tid=7fe2831a7000 nid=0x11670d000 waiting for monitor entry [11670b000]\n   java.lang.Thread.State: BLOCKED (on object monitor)\n\tat org.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:252)\n\t- waiting to lock <7f333b970> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n\tat org.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:254)\n\t- locked <7f333b960> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n\tat org.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:254)\n\t- locked <7f333b950> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n\tat org.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:254)\n\t- locked <7f333b940> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n\tat org.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:254)\n\t- locked <7f333b930> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n\tat org.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:254)\n\t- locked <7f333b920> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n\tat org.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:254)\n\t- locked <7f333b910> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n\tat org.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:254)\n\t- locked <7f333b900> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n\tat org.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:254)\n\t- locked <7f333b8f0> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n\tat org.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:254)\n\t- locked <7f333b8e0> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n\tat org.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:254)\n\t- locked <7f333b8d0> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n\tat org.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:254)\n\t- locked <7f333b8c0> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n\tat org.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:254)\n\t- locked <7f333b8b0> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n\tat org.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:254)\n\t- locked <7f333b8a0> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n\tat org.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:254)\n\t- locked <7f333b890> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n\tat org.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:254)\n\t- locked <7f333b880> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n\tat org.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:254)\n\t- locked <7f333b870> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n\tat org.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:254)\n\t- locked <7f333b860> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n\tat org.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:254)\n\t- locked <7f333b850> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n\tat org.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:254)\n\t- locked <7f333b840> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n\tat org.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:254)\n\t- locked <7f333b830> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n\tat org.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:254)\n\t- locked <7f333b820> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n\tat org.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:254)\n\t- locked <7f333b810> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n\tat org.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:254)\n\t- locked <7f333b800> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n\tat org.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:254)\n\t- locked <7f333b7f0> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n\tat org.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:254)\n\t- locked <7f333b7e0> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n\tat org.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:254)\n\t- locked <7f333b7d0> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n\tat org.apache.fop.fo.properties.PropertyCache.rehash(PropertyCache.java:254)\n\t- locked <7f333b7c0> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n\tat org.apache.fop.fo.properties.PropertyCache.cleanSegment(PropertyCache.java:156)\n\t- locked <7f333b630> (a [Z)\n\tat org.apache.fop.fo.properties.PropertyCache.put(PropertyCache.java:200)\n\t- locked <7f333b8c0> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n\tat org.apache.fop.fo.properties.PropertyCache.fetch(PropertyCache.java:332)\n\tat org.apache.fop.fo.properties.PropertyCache.fetch(PropertyCache.java:346)\n\tat org.apache.fop.fo.properties.PropertyCacheTest.fillCache(PropertyCacheTest.java:37)\n\tat org.apache.fop.fo.properties.PropertyCacheTest.access$0(PropertyCacheTest.java:33)\n\tat org.apache.fop.fo.properties.PropertyCacheTest$1.call(PropertyCacheTest.java:22)\n\tat java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:138)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)\n\tat java.lang.Thread.run(Thread.java:680)\n\n\n\"Thread B\":\n\"pool-1-thread-1\" prio=5 tid=7fe282236000 nid=0x11660a000 waiting for monitor entry [116609000]\n   java.lang.Thread.State: BLOCKED (on object monitor)\n\tat org.apache.fop.fo.properties.PropertyCache.cleanSegment(PropertyCache.java:140)\n\t- waiting to lock <7f333b630> (a [Z)\n\tat org.apache.fop.fo.properties.PropertyCache.put(PropertyCache.java:200)\n\t- locked <7f333b970> (a org.apache.fop.fo.properties.PropertyCache$CacheSegment)\n\tat org.apache.fop.fo.properties.PropertyCache.fetch(PropertyCache.java:332)\n\tat org.apache.fop.fo.properties.PropertyCache.fetch(PropertyCache.java:346)\n\tat org.apache.fop.fo.properties.PropertyCacheTest.fillCache(PropertyCacheTest.java:37)\n\tat org.apache.fop.fo.properties.PropertyCacheTest.access$0(PropertyCacheTest.java:33)\n\tat org.apache.fop.fo.properties.PropertyCacheTest$1.call(PropertyCacheTest.java:22)\n\tat java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:138)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)\n\tat java.lang.Thread.run(Thread.java:680)", "id": 148339, "time": "2011-08-02T19:37:07Z", "bug_id": 46962, "creation_time": "2011-08-02T19:37:07Z", "is_private": false, "attachment_id": null}, {"count": 4, "tags": [], "creator": "alex.giotis@gmail.com", "text": "Created attachment 27342\nPatch with a unit test to reproduce the deadlock\n\nAttached is a patch that includes a unit test (PropertyCacheTest.java) that almost always reproduces the deadlock using just 2 threads. \n\nThis is not meant to be committed but only as a demonstration of the problem and as a test of next patches that fix it. Except adding the test case, I also needed to add a sleep of 1 second in the rehash() method and implement the equals() and hashcode() of the org.apache.fop.fo.properties.Property class. The Property class was just more easy to instantiate.", "id": 148340, "time": "2011-08-02T19:45:47Z", "bug_id": 46962, "creation_time": "2011-08-02T19:45:47Z", "is_private": false, "attachment_id": 27342}, {"count": 5, "attachment_id": 27343, "creator": "alex.giotis@gmail.com", "is_private": false, "id": 148344, "time": "2011-08-02T22:24:44Z", "bug_id": 46962, "creation_time": "2011-08-02T22:24:44Z", "tags": [], "text": "Created attachment 27343\nPatch fixing PropertyCache issue.\n\nAttached is a proposed patch that fixes this issue with minimal changes. The patch is against the revision 1067783 of PropertyCache in FOP trunk.\n\nOn the other hand, it might better to base the implementation of the PropertyCache on ConcurrentHashMap."}, {"count": 6, "tags": [], "bug_id": 46962, "is_private": false, "id": 148433, "attachment_id": 27357, "creator": "alex.giotis@gmail.com", "creation_time": "2011-08-05T20:21:52Z", "time": "2011-08-05T20:21:52Z", "text": "Created attachment 27357\nConcurrent map based implementation of property cache supporting hashCode collisions"}, {"text": "Created attachment 27358\nPatch with rewritten PropertyCache (trunk revision 1154337)\n\nIn short, the new PropertyCache implementation attached is:\n- Up to 3 times faster (depending on the tests, the -Xmx, and the retention or not of strong refs to he cached entries)\n- 3 times less lines of code\n- Obviously thread-safe\n- Written using JDK5 generics\n- Has similar memory requirements\n\nAdditionally this patch fixes broken hashCode() and equals() methods of classes extending Property (including the patch in bug 51625). Those caused in tests many hashCode collisions.\n\n\n\nIn more detail, I wrote 2 new implementations of PropertyCache (one in this patch and the one in attachment 27357) and tested both against the original one with the fix contained in attachment 27343.\n\nWhen strong references to the cached entries are kept, then the performance of all is similar. When they are not (more common case), the ones based on the concurrent hash map are up to 3 times faster. The tests were allocating 1M (million) Property instances from which 100K were equal (but different instances).  \n\nThe first implementation based on the concurrent map supports caching not-equal objects with the same hashcode but is fairly complex. The one attached in the final patch does not. After some experimentation and tests with large (1000 page) documents hashcode collisions were caused due to buggy hashCode and equal implementations. Handling this case has a performance penalty. In a test that caches 1M entries from which there are only 100 different hashCodes the time to complete was:\n\n52 seconds for the initial implementation\n12 seconds the the concurrent map that can cache not-equal objects with the same hashcode.\n1 second for the concurrent map that keeps the more recent one.\n\nIn other words, in this case (which is due to buggy hashcode()/equals), the cost of creating a new instance and replacing the previously cached one is by far smaller that the one to maintain in memory the different instances.\n\nNote that this implementation does not provide any guarantee related to the uniqueness of equal instances when concurrently executed. Such a guarantee is not only complex to code but also it requires additional locking. In practice, it is not very probable that this will happen, finally there will be only one and of course this should be a tolerable situation. After all, the caching can be globally disabled with the same system property as before.", "tags": [], "bug_id": 46962, "is_private": false, "count": 7, "id": 148434, "time": "2011-08-05T20:31:09Z", "creator": "alex.giotis@gmail.com", "creation_time": "2011-08-05T20:31:09Z", "attachment_id": 27358}, {"count": 8, "attachment_id": 27477, "creator": "alex.giotis@gmail.com", "text": "Created attachment 27477\nUpdated patch with rewritten PropertyCache that fixes more hashCode/equals() problems", "id": 149126, "time": "2011-09-09T16:25:09Z", "bug_id": 46962, "creation_time": "2011-09-09T16:25:09Z", "tags": [], "is_private": false}, {"count": 9, "tags": [], "creator": "med1985@gmail.com", "text": "Created attachment 27495\npropery cache patch\n\nI've made a few changes to this patch a little:\n- Created a static method Property.eq() which tests for object equality (and reference equality for performance reasons)\n- Fixed some checkstyle issues, these were not specific to this patch but rather fixed some issues as I went along\n- Unit tests have been added\n\nSome of the tests added require Mockito, I tried to avoid using mocking as much as possible for the obvious reason that the commiters haven't agreed to add it as a dependency. However, some of these classes were are a nightmare to test without mocking them.\n\nThis patch makes the previous work obsolete, I don't know what the etiquette is when making someone else's work obsolete. I mean no offence.", "id": 149227, "time": "2011-09-14T15:22:44Z", "bug_id": 46962, "creation_time": "2011-09-14T15:22:44Z", "is_private": false, "attachment_id": 27495}, {"count": 10, "tags": [], "creator": "alex.giotis@gmail.com", "text": "Medhi, thanks for checking & fixing checkstyle issues. Using the Property.eq() definitely makes the equals() methods easier to read. I used the eclipse auto generated equals() methods to avoid making any mistake because I did not add the unit tests that you did. \n\nThe only line I would delete is a \n        // TODO Auto-generated method stub\nthat is found in NCnamePropertyTestCase.java\n\n\nI guess the issues related to the usage of Mockito and the etiquette for replacing older work, are not for me to comment. I can only say that I checked your changes over my patch and I find them very good. I have also applied my previous patch on production and it works fine.", "id": 149261, "time": "2011-09-15T12:09:38Z", "bug_id": 46962, "creation_time": "2011-09-15T12:09:38Z", "is_private": false, "attachment_id": null}, {"count": 11, "tags": [], "bug_id": 46962, "is_private": false, "text": "Excellent, thanks for looking over it, I agree, that //TODO shouldn't have gotten through.\n\nThanks again for taking the time to check through it.", "id": 149266, "time": "2011-09-15T13:01:18Z", "creator": "med1985@gmail.com", "creation_time": "2011-09-15T13:01:18Z", "attachment_id": null}, {"count": 12, "tags": [], "bug_id": 46962, "attachment_id": null, "is_private": false, "id": 149801, "time": "2011-09-27T08:25:35Z", "creator": "spepping@apache.org", "creation_time": "2011-09-27T08:25:35Z", "text": "(In reply to comment #9)\n> Some of the tests added require Mockito, I tried to avoid using mocking as much\n> as possible for the obvious reason that the commiters haven't agreed to add it\n> as a dependency. However, some of these classes were are a nightmare to test\n> without mocking them.\n\nI have no problem with the addition of Mickito to FOP's dependencies, since it helps writing true unit tests."}, {"count": 13, "attachment_id": null, "creator": "alex.giotis@gmail.com", "text": "Now that there was a vote and Mockito has been accepted, what about applying the patch ? Is there something holding it ?", "id": 150878, "time": "2011-10-24T16:59:20Z", "bug_id": 46962, "creation_time": "2011-10-24T16:59:20Z", "tags": [], "is_private": false}, {"id": 152188, "tags": [], "bug_id": 46962, "is_private": false, "count": 14, "text": "Hi Medhi,\n\nNow that you are a commiter and mockito is used, is there a reason for not applying this patch ?", "time": "2011-12-15T12:27:57Z", "creator": "alex.giotis@gmail.com", "creation_time": "2011-12-15T12:27:57Z", "attachment_id": null}, {"count": 15, "tags": [], "creator": "alex.giotis@gmail.com", "text": "Created attachment 28412\nPatch update to fix NPE on JDK5\n\nAdded a lock on the PropertyCache that prevents concurrent cleanup of the cached objects. \n\nThere is no reason to concurrently cleanup the cache but most importantly it protects from an NullPointerException occuring on Sun JDK5\n\nhttp://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6312056\n\nThis issue was reported by Vincent. The updated patch does not include the tests added by Mehdi for the following reasons:\n\n- Make clear my contribution.\n- There were some cleanups requested by Vincent that I did not fully understand and I don't wish to delay it's processing.\n- I don't think we get added value by testing the hashCode() & equals() implementations. The tests don't protect from future changes in the tested classes (e.g. adding a new field) and don't protect if in the future another class is added in the cache.\n- To find broken hashCode() implementation of cached instances, the PropertyCache counts the number of collisions and reports it in the log if it exceeds a number.\n\nOf course anyone is welcomed to add tests, if he wishes so. For completeness, below is Vincent's test that reveals the JDK5 bug:\n\n private final PropertyCache<Integer> cache = new PropertyCache<Integer>();\n\n   private class CacheFiller implements Runnable {\n       private final int start;\n       CacheFiller(int start) {\n           this.start = start;\n       }\n       public void run() {\n           for (int i = 0; i < 1000000; i++) {\n               cache.fetch(new Integer(start + i));\n           }\n       }\n   }\n   public void testCleanUp() throws InterruptedException {\n       Thread t1 = new Thread(new CacheFiller(0));\n       Thread t2 = new Thread(new CacheFiller(10000));\n       t1.start();\n       t2.start();\n       t1.join();\n       t2.join();\n   }", "id": 154442, "time": "2012-03-02T16:21:57Z", "bug_id": 46962, "creation_time": "2012-03-02T16:21:57Z", "is_private": false, "attachment_id": 28412}, {"text": "*** Bug 51625 has been marked as a duplicate of this bug. ***", "tags": [], "bug_id": 46962, "is_private": false, "count": 16, "id": 154444, "time": "2012-03-02T16:33:36Z", "creator": "alex.giotis@gmail.com", "creation_time": "2012-03-02T16:33:36Z", "attachment_id": null}, {"count": 17, "tags": [], "bug_id": 46962, "is_private": false, "id": 154722, "attachment_id": null, "creator": "med1985@gmail.com", "creation_time": "2012-03-09T09:12:12Z", "time": "2012-03-09T09:12:12Z", "text": "<snip/>\n\n> - I don't think we get added value by testing the hashCode() & equals()\n> implementations. The tests don't protect from future changes in the tested\n> classes (e.g. adding a new field) and don't protect if in the future another\n> class is added in the cache.\n\nWhile I agree that these tests don't protect from subsequent adding of class members, I couldn't disagree more that they shouldn't be tested! The equals() and hashCode() methods have a contract to Object that they should behave in a certain fashion. If that behaviour is modified, bugs can be hard to track down and difficult to diagnose because they're so widely used in Java collections library.\n\n> - To find broken hashCode() implementation of cached instances, the\n> PropertyCache counts the number of collisions and reports it in the log if it\n> exceeds a number.\n> \n> Of course anyone is welcomed to add tests, if he wishes so. For completeness,\n> below is Vincent's test that reveals the JDK5 bug:\n> \n>  private final PropertyCache<Integer> cache = new PropertyCache<Integer>();\n> \n>    private class CacheFiller implements Runnable {\n>        private final int start;\n>        CacheFiller(int start) {\n>            this.start = start;\n>        }\n>        public void run() {\n>            for (int i = 0; i < 1000000; i++) {\n>                cache.fetch(new Integer(start + i));\n>            }\n>        }\n>    }\n>    public void testCleanUp() throws InterruptedException {\n>        Thread t1 = new Thread(new CacheFiller(0));\n>        Thread t2 = new Thread(new CacheFiller(10000));\n>        t1.start();\n>        t2.start();\n>        t1.join();\n>        t2.join();\n>    }\n\nWhy not just put that in a unit test?? None of this code is tested and a little mistake could have far-reaching ramifications."}, {"count": 18, "tags": [], "bug_id": 46962, "is_private": false, "text": "<snip>\n> Why not just put that in a unit test?? None of this code is tested and a little\n> mistake could have far-reaching ramifications.\n\nBy that I obviously meant the PropertyCache version of this test, however you tested your latest patch in development...", "id": 154723, "time": "2012-03-09T09:15:10Z", "creator": "med1985@gmail.com", "creation_time": "2012-03-09T09:15:10Z", "attachment_id": null}, {"count": 19, "attachment_id": 28447, "creator": "alex.giotis@gmail.com", "is_private": false, "id": 154755, "time": "2012-03-09T16:04:06Z", "bug_id": 46962, "creation_time": "2012-03-09T16:04:06Z", "tags": [], "text": "Created attachment 28447\nPatch update including a PropertyCacheTestCase\n\n* Updated patch against revision 1298724 of trunk\n* Resolved patch merge conflicts introduced by recent commits.\n* Updated code against the latest checkstyle 5.5 \n* Added a PropertyCacheTestCase"}, {"count": 20, "attachment_id": null, "creator": "vhennebert@gmail.com", "is_private": false, "id": 155195, "time": "2012-03-21T20:41:37Z", "bug_id": 46962, "creation_time": "2012-03-21T20:41:37Z", "tags": [], "text": "Thanks for your patch! I have a few questions following a quick review:\n* Why declare the equals and hashCode methods on interfaces (Numeric, PercentBase)? They are defined on Object anyway, and AFAICT declaring them on interfaces wouldn't change anything (that is, force the developer to implement them on sub-classes?).\n* Why define those methods as abstract on Property? What if a sub-class is perfectly happy with the default implementations from Object? Also, it doesn't allow to call super.hashCode or super.equals any more. I'm not sure at all if this is desirable.\n* Why use Double.doubleToLongBits in equals methods to compare doubles (NumericProperty, PercentLength)? Why not just thisDouble == otherDouble? (One could also argue that some epsilon might be necessary, but this is another topic.)\n* shouldn't the specVal field from Property also be tested for equality?\n\nThanks,\nVincent"}, {"count": 21, "tags": [], "bug_id": 46962, "text": "Vincent, thanks for  looking at it.\n\n> * Why declare the equals and hashCode methods on interfaces (Numeric,\n> PercentBase)? They are defined on Object anyway, and AFAICT declaring them on\n> interfaces wouldn't change anything (that is, force the developer to implement\n> them on sub-classes?).\n\nThe definitions of hashcode/equals on the interfaces are not needed. It was helping\nme easily locate which classes implement them. Can be removed.\n\n\n\n\n> * Why define those methods as abstract on Property? What if a sub-class is\n> perfectly happy with the default implementations from Object? Also, it doesn't\n> allow to call super.hashCode or super.equals any more. I'm not sure at all if\n> this is desirable.\n\nThis was for forcing future sub-classes to implement them as it is not obvious\nwhen an implementation is needed.  There are properties like ListProperty\n(a list of Property instances) and classes like the CompoundPropertyMaker which\nuse it. For example, the FontFamilyProperty extends ListProperty and uses the\ncache. If we rely on the implementations from Object, then the caching is simply\nan overhead as the FontFamilyProperty#make method will never create two\nproperties with the same identity (Object#equals uses the == operator).\n\nHaving said that, if this is not desirable, the abstract methods on Property can\nbe removed.  \n\n\n\n\n\n> * Why use Double.doubleToLongBits in equals methods to compare doubles\n> (NumericProperty, PercentLength)? Why not just thisDouble == otherDouble? (One\n> could also argue that some epsilon might be necessary, but this is another\n> topic.)\n\n\nWell, if we forget about the epsilon, the doubleToLongBits is the correct way\nto check for equality two doubles. This is well explained in Effective Java by\nJoshua Bloch, used in Double#compare, Double#equals and by all IDEs that\ngenerate them and libraries like Apache commons-lang EqualsBuilder. Java\nhas double values for both 0.0 and -0.0, as well as the never equal\n\"not a number\" (NaN). Those can't be checked with ==.\nHave a look into the doubleToLongBits source and at the javadoc for Double.equals().\n\n\n\n> * shouldn't the specVal field from Property also be tested for equality?\n\nIt seems that currently this is not needed. The specVal is set by 3 properties,\nthe FontShorthandProperty, the LineHeightProperty and the URIProperty.\nNone of them uses the cache, so currently it is not needed in the equality tests. \n\n\nGenerally, it should be safe to demand from every class using the cache to correctly\nimplement the hashCode/equal methods. Unfortunately, we can not in general \nenforce it. With that view, it could be better to remove the abstract declarations on\nProperty.\n\n\n\nPlease tell me if you expect an updated patch.", "id": 155201, "attachment_id": null, "creator": "alex.giotis@gmail.com", "creation_time": "2012-03-22T02:02:02Z", "time": "2012-03-22T02:02:02Z", "is_private": false}, {"count": 22, "tags": [], "bug_id": 46962, "text": "This patch should also resolve Bug 50703.", "id": 155202, "time": "2012-03-22T02:08:31Z", "creator": "alex.giotis@gmail.com", "creation_time": "2012-03-22T02:08:31Z", "is_private": false, "attachment_id": null}, {"count": 23, "tags": [], "creator": "vhennebert@gmail.com", "text": "Hi Alexios,\n\n(In reply to comment #21)\n> Vincent, thanks for  looking at it.\n> \n> > * Why use Double.doubleToLongBits in equals methods to compare doubles\n> > (NumericProperty, PercentLength)? Why not just thisDouble == otherDouble? (One\n> > could also argue that some epsilon might be necessary, but this is another\n> > topic.)\n> \n> \n> Well, if we forget about the epsilon, the doubleToLongBits is the correct way\n> to check for equality two doubles. This is well explained in Effective Java by\n> Joshua Bloch, used in Double#compare, Double#equals and by all IDEs that\n> generate them and libraries like Apache commons-lang EqualsBuilder. Java\n> has double values for both 0.0 and -0.0, as well as the never equal\n> \"not a number\" (NaN). Those can't be checked with ==.\n> Have a look into the doubleToLongBits source and at the javadoc for\n> Double.equals().\n\nLearning new things every day :-) Thanks for the pointers.\n\n\n> > * shouldn't the specVal field from Property also be tested for equality?\n> \n> It seems that currently this is not needed. The specVal is set by 3 properties,\n> the FontShorthandProperty, the LineHeightProperty and the URIProperty.\n> None of them uses the cache, so currently it is not needed in the equality\n> tests. \n\nOk, make sense. Still I'll modify the implementations of equals and hashCode in the URIProperty class as it makes explicit use of specVal.\n\n\n> Please tell me if you expect an updated patch.\n\nIt's not necessary.\n\n\nThanks,\nVincent", "id": 155239, "time": "2012-03-22T16:54:42Z", "bug_id": 46962, "creation_time": "2012-03-22T16:54:42Z", "is_private": false, "attachment_id": null}, {"count": 24, "attachment_id": null, "creator": "vhennebert@gmail.com", "is_private": false, "id": 155240, "time": "2012-03-22T18:00:46Z", "bug_id": 46962, "creation_time": "2012-03-22T18:00:46Z", "tags": [], "text": "Patch applied in rev. 1303891:\nhttp://svn.apache.org/viewvc?rev=1303891&view=rev\n\nSorry for the delay about this, and thanks for your patience.\n\nI didn't include the test cases. They still require quite some work, which is more than I can allocate on this. But most of all, I'm not quite sure that they represent the right approach to the problem. They use a hell lot of mocking which makes them hard to understand, let alone maintain.\n\nAnd despite that, they probably don't even bring adequate coverage. Many fields are set to a mock of some property (see e.g. EnumLengthTestCase). So the equals method will compare two physically identical instances, which is definitely a narrow use case. We should also test the cases of properties made of physically different but logically identical fields.\n\nLikewise, the tests for not equals should be broader and test different combinations of field values.\n\nImplementing proper coverage would require even more mocking, and things will start to be really unwieldy.\n\nI'm not sure what's the right approach to this. Maybe some helper library like EqualsVerifier?\nhttp://code.google.com/p/equalsverifier/\n\nVincent"}, {"count": 25, "tags": [], "bug_id": 46962, "attachment_id": null, "text": "Thanks for reviewing and applying this patch !\n\nI am happy that the deadlock is gone. I had a 2nd look on the final changes and for me this issue is now resolved. I am leaving this bug open to fix the final declaration of CommonBorderPaddingBackground (mockito can't mock it) and in case somebody wants to add explicit tests for the hashCode/equals methods.", "id": 155244, "time": "2012-03-22T19:20:08Z", "creator": "alex.giotis@gmail.com", "creation_time": "2012-03-22T19:20:08Z", "is_private": false}, {"count": 26, "attachment_id": null, "creator": "med1985@gmail.com", "is_private": false, "id": 155252, "time": "2012-03-22T21:55:19Z", "bug_id": 46962, "creation_time": "2012-03-22T21:55:19Z", "tags": [], "text": "<snip/>\n\n> And despite that, they probably don't even bring adequate coverage. Many fields\n> are set to a mock of some property (see e.g. EnumLengthTestCase). So the equals\n> method will compare two physically identical instances, which is definitely a\n> narrow use case. We should also test the cases of properties made of physically\n> different but logically identical fields.\n> \n> Likewise, the tests for not equals should be broader and test different\n> combinations of field values.\n> \n> Implementing proper coverage would require even more mocking, and things will\n> start to be really unwieldy.\n\nYup, I came to the same conclusion and did what I could in the limited time I had... Not ideal, but better than nothing right?\n\n> \n> I'm not sure what's the right approach to this. Maybe some helper library like\n> EqualsVerifier?\n> http://code.google.com/p/equalsverifier/\n\nI did see this and it'd be great if we used this, and it'd be awesome if we used used a repository management system. But a) it introduces a new version of objenesis (which may or may not cause compatibility issues) b) 2 new compile time dependencies c) who's going to create the documentation.\n\nUsing these new libraries for testing is great, if people know how to use them (and that's a big caveat). Take mocking for example, it's used widely enough in the industry to assume devs either know or can find out how to use the mocking frameworks. I'm not convinced this particular library is widely used enough and if something broke we have to be confident ANYONE can fix the issue.\n\nI should say, I'm not against adding these libraries, I think it's important to take testing seriously, but we have to be aware of the implications of adding dependencies and not just in terms of the classpath."}, {"count": 27, "tags": [], "text": "I uploaded my changes to the test cases in a new Bugzilla entry, see bug #52977.\n\nI'm closing this one as the original problem has been fixed.", "is_private": false, "id": 155259, "creator": "vhennebert@gmail.com", "time": "2012-03-23T11:30:16Z", "bug_id": 46962, "creation_time": "2012-03-23T11:30:16Z", "attachment_id": null}]