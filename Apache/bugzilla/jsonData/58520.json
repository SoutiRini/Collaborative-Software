[{"count": 0, "tags": [], "bug_id": 58520, "attachment_id": null, "id": 185850, "time": "2015-10-22T16:38:03Z", "creator": "jeperjaperjieper@gmail.com", "creation_time": "2015-10-22T16:38:03Z", "is_private": false, "text": "In our websocket implementation, we are sending events through websockets every 250ms to the client.\n\nIt seems that the Future<Void> returned by javax.websocket.Session.getAsyncRemote().sendText(...) always returns true. This makes it impossible to cancel pending outgoing data.\n\nScenario:\n\n1. Server is up and running\n2. Client connects\n3. Server starts sending events every 250ms\n4. All goes well\n5. Client disconnects from the network (for example by unplugging its UTP)\n6. Server keeps sending events; the server has no idea that the client is disconnected (which is OK, on itself)\n7. Twenty seconds later, clients reconnects to network\n8. Clients receives all events from the last 20 seconds (around 80 events)\n\nIdeally, during step 6, the server notices that there is a previous pending event, which can be canceled in favor of the current/new event. With that approach, the client will not receive all past events at step 8."}, {"count": 1, "tags": [], "text": "First of all, a Future<Void> is never going to return true.\n\nYes, it is impossible to cancel those Futures. Once bytes have been written to the network, there is no \"unwrite these bytes\" API so messages cannot be cancelled once started.\n\nIf you use message batching then Tomcat will buffer messages internally.\n\nIf you do not use message batching then the network layer will buffer data in the TCP buffers. If the messages are small 80 of them are not going to fill the TCP buffers. With long timeouts Tomcat isn't going to see any network issues until those TCP buffers are filled.\n\nTomcat has unit tests that check that this behaves correctly. Detecting the failure requires a *lot* of data to be writtem server side before the problem is detected.\n\nGenerally, the behavoiur you describe is a good thing. You want systems to be robust against temporary network glitches.", "is_private": false, "bug_id": 58520, "id": 185907, "time": "2015-10-24T11:16:41Z", "creator": "markt@apache.org", "creation_time": "2015-10-24T11:16:41Z", "attachment_id": null}, {"count": 2, "tags": [], "text": "Hi Mark,\n\nI meant indeed the isDone() operation on the Future.\n\nI agree it is a good thing seen from perspective of the server. However, from perspective of the client, once the client reconnects, it gets overloaded with events. The problem is that when processing event N, he has no idea that event N+1 is still in the pipeline, which means that event N can be discarded.\n\nHow would one cope with this situation, in general? We could add a timestamp to the events, so clients can filter on that, which reduces the processing overhead.", "is_private": false, "id": 185909, "creator": "jeperjaperjieper@gmail.com", "time": "2015-10-24T12:29:29Z", "bug_id": 58520, "creation_time": "2015-10-24T12:29:29Z", "attachment_id": null}, {"count": 3, "tags": [], "text": "Yes, isDone() is always going to be true for the reasons I described previously.\n\nYou can try reducing the write timeout (see the WebSocket How-To in the docs) but you are still going to have the TCP buffer issue. You could reduce the size of those via Connector configuration but that might have a negative performance impact.\n\nAdding an expiry time and filtering based on that on the client is certainly another valid option.\n\nYou'll need to do some testing to figure out which is the best option for your environment.", "is_private": false, "bug_id": 58520, "id": 185910, "time": "2015-10-24T13:52:21Z", "creator": "markt@apache.org", "creation_time": "2015-10-24T13:52:21Z", "attachment_id": null}]