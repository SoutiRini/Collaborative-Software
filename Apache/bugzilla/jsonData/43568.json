[{"count": 0, "tags": [], "creator": "kenny.moens.ext@nsn.com", "attachment_id": null, "text": "- Log4j is configured with a RootLogger and a specific Logger for the package\ncom.siemens, both configured to use the same RollingFileAppender. \n- Thread 1: a class in the package X logs an exception outside the package X\n- Thread 2: a class outside the package X tries to log another message \n\null description of deadlock: \n[T1]: Thread 1 acquires a lock on the specific Logger of package X\n[T1]: As a consequence Thread 1 acquires a lock on the RollingFileAppender \n[T2]: Thread 2 wants to log something and as such acquires a lock on RootLogger.\n[T2]: To perform the logging, Thread 2 waits to get a lock on the\nRollingFileAppender \n[T1]: The logging of the exception in Thread 1 also wants to write stuff to the\nlog and as it is outside the X package wants a lock on the RootLogger which is\nowned by Thread 2 already.\n\nThe problem occured with Apache Axis 1.4 which appearantly shows this behaviour\nof logging during the generation of exception stack traces.", "id": 109108, "time": "2007-10-07T23:20:44Z", "bug_id": 43568, "creation_time": "2007-10-07T23:20:44Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 43568, "is_private": false, "text": "log4j 1.2's architecture is such that any attempt to log from within the scope of a log4j method will \npotentially deadlock.  Eliminating the coarse-grained locking is a design goal for log4j 2.0, but it can't \nbe done in log4j 1.2 without breaking appenders and layouts that depend on the current \nsynchronization model.\n\nThis is typically encountered when the toString() member of the message parameter makes log4j calls.  \nHowever, if an exception parameters printStackTrace(Writer) method makes log4j calls the same type of \ndeadlock situation could arise.\n\nThe only potential remedy would be to prevent this situation from arising.  One way to prevent it would \nbe to create a custom layout that suppresses the stack trace for the problematic exceptions (assuming \nthat you are using a FileAppender or other derived from WriterAppender).  Something like:\n\npublic class MyPatternLayout extends PatternLayout {\n    //\n    //  returning false suppresses the default handling of \n    //    exceptions in WriterAppender\n    public boolean ignoresThrowable() {\n        return false;\n    }\n    private static boolean safeException(ThrowableInformation ti) {\n         if (ti != null) {\n             Throwable t = ti.getThrowable();\n             if (t != null) {\n                  if (t instanceof MyBadException1 ||\n                      t instanceof MyBadException2) {\n                      return false;\n                  }\n            }\n            return true;\n        }\n        return false;\n    }\n\n    public String format(final LoggingEvent event) {\n        String retval = super.format(event);\n        if (safeException(event.getThrowableInfo()) {\n             StringBuffer buf = new StringBuffer(retval);\n             String[] trace = event.getThrowableStrRep();\n             if (trace != null) {\n                  for(int i = 0; i < trace.length; i++) {\n                       buf.append(trace[i]);\n                       buf.append(Layout.LINE_SEP);\n                  }\n             }\n            retval = buf.toString();\n       } else {\n            //  as much info on the bad exception that you can get\n            //     without triggering a log4j call\n       }\n}", "id": 110065, "time": "2007-10-31T09:44:58Z", "creator": "carnold@apache.org", "creation_time": "2007-10-31T09:44:58Z", "attachment_id": null}]