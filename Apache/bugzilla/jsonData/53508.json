[{"count": 0, "tags": [], "creator": "velten@econda.de", "attachment_id": null, "id": 160442, "time": "2012-07-04T08:17:05Z", "bug_id": 53508, "creation_time": "2012-07-04T08:17:05Z", "is_private": false, "text": "We generate large Documents. We found that especially Sheets with String-Cells are very slow. \n\nCPU-Usage was several minutes 100%. Memory footprint rather low.\n(24 Minutes for a Sheet with around 31000 rows) \n\nI take a look in Source code and figured out, that XSSFCell uses shared Strings Method. \n\nI debugged a little trough and found that the generation of the HashKey for the shared Strings seems to be very expensive. (SharedStringsTable.addEntry)\n\nFor me, I solved the problem by using Inline Strings instead of Shared Strings. It is very much faster. (only some seconds now instead of 24 minutes)\n\nBut Api for this is not at top-level. I use this now:\n\nCTCell ctCell = ((XSSFCell)cell).getCTCell();\nctCell.setT(STCellType.INLINE_STR);\nXSSFRichTextString xssfRichTextString = new XSSFRichTextString(value);\nctCell.setIs(xssfRichTextString.getCTRst());"}, {"count": 1, "tags": [], "creator": "yegor@dinom.ru", "attachment_id": null, "id": 160446, "time": "2012-07-04T10:01:10Z", "bug_id": 53508, "creation_time": "2012-07-04T10:01:10Z", "is_private": false, "text": "Can you post sample code that compares two methods and demonstrates that current implementation is slow? \n\nSharedStringsTable.getKey() can be slow, but I'd like to see a proof. Every time a string is added to the SST, SharedStringsTable.getKey() computes its hash code which actually results to invoking xmlBean.toString().hashCode() where xmlBean is the bean holding the string data. \n\nInlining strings has a side effect: it speeds up building of worksheets, but the resulting file can be much bigger and it will take significantly more time to open it in Excel.\n\nMy idea is to tweak SharedStringsTable.getKey() as follows:\n\n    private String getKey(CTRst st) {\n        if(st.sizeOfRArray() == 0) {\n            // for plain text return the text value\n            return st.getT();\n        } else {\n            //  for rich text return xml representation of the CTRst bean\n            return st.xmlText(options); \n        }\n    }\n\nif a string has no rich text runs then we return  its text value, it should be much faster that invoking st.xmlText(options). \n\nIt would be great if you apply this fix , build POI and meausure the performace boost. \n\nYegor"}, {"count": 2, "attachment_id": null, "bug_id": 53508, "is_private": false, "id": 160465, "time": "2012-07-05T11:24:37Z", "creator": "velten@econda.de", "creation_time": "2012-07-05T11:24:37Z", "tags": [], "text": "Hello Yegor\n\nThank you for very fast response!\n\nI must admit, that I tried to create a testcase, but failed. \n\nBut problem on our server persisted.\n\nI recognized that the problem disappeared only with server restart. First I recognized this on our testing server. Then I proofed this a second time at our production server.\n\nI was able to measure the difference: Long running server performance was around 30 times slower than fresh started server. \n\nAfter some over night XMLX-Exports on our production server the performance is down again (perhaps 20 times slower). Test server has had no workload and is unchanged fast.\n\n\nWe figured out only with thread dumps, that the SharedStringsTable Hash Key Generation is perhaps the problem, because threads was hanging in this method very often.\n\nObviously the POI code causes not the 30 times slowdown in performance. Perhaps there is a bad cache implementation or something else in the XML-Beans code?\n\nCurrently I have not tested your code snippet. Surely this could help to speed up POI anyway.\n\nI will try to search something further..   \n\n\nBefore Server restart:\n2012-07-04 16:44:42,423 ERROR table.Table.serializeXLS() (729) - serializeXLS for 31681 rows with 20 columns for user 'XXX' lasted 473392 with an avg of 14.942457624443673 per row\n\nAfter Server restart:\n2012-07-04 18:56:29,686 ERROR table.Table.serializeXLS() (729) - serializeXLS for 31681 rows with 20 columns for user 'XXX' lasted 14919 with an avg of 0.4709131656197721 per row\n\nAfter some over night export workload this morning:\n2012-07-05 10:52:00,446 ERROR table.Table.serializeXLS() (729) - serializeXLS for 31680 rows with 20 columns for user 'XXX' lasted 281254 with an avg of 8.877967171717172 per row\n\n(Each of this durations was stable reproducible over several test export runs)\n\nBest wishes\n\nDaniel"}, {"count": 3, "tags": [], "bug_id": 53508, "attachment_id": null, "text": "I think we have found the real bug.\n\nWith JDK 7 there was implemented a new init method of HashMap and some other Maps.\n\nThis new Init Method used the standard Random-Generator to calculate the hashcode.\n\nBut this Random-Generator is synchronized. Causing problems in multithreaded environment. There is no performance bug, when there is only one Thread. But in multithreaded environment there can be a huge loss in performance.\n\nThis JDK-Bug is fixed with version 1.7.0_40.\n\nAfter update to this version all seem to be fine now.\n\nPlease look at:\n\nhttp://bugs.sun.com/bugdatabase/view_bug.do?bug_id=8006593\n\nhttp://stackoverflow.com/questions/14010906/given-that-hashmaps-in-jdk1-6-and-above-cause-problems-with-multi-threading-how\n\nhttps://blogs.oracle.com/henrik/entry/migrating_from_java_se_6\n\nhttp://java-performance.info/changes-to-string-java-1-7-0_06/", "id": 170267, "time": "2013-09-25T13:25:59Z", "creator": "velten@econda.de", "creation_time": "2013-09-25T13:25:59Z", "is_private": false}, {"count": 4, "tags": [], "text": "Putting perhaps an hint in documentation would be very good.", "attachment_id": null, "id": 170288, "creation_time": "2013-09-26T16:11:16Z", "time": "2013-09-26T16:11:16Z", "creator": "velten@econda.de", "bug_id": 53508, "is_private": false}]