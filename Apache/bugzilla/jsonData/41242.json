[{"count": 0, "tags": [], "creator": "yegor@dinom.ru", "attachment_id": null, "id": 97310, "time": "2006-12-26T02:53:39Z", "bug_id": 41242, "creation_time": "2006-12-26T02:53:39Z", "is_private": false, "text": "Symptoms: After serialization ObjRecord becomes 4 bytes shorter than the\noriginal record.\nAs the result, certain spreadsheets, especially containing cell comments, can be\ncorrupted.\n\nA quick investigation revealed that trailing EndSubRecord is never serialized. \n\nSub-records are read in ObjRecord.fillFields:\n\n    protected void fillFields(RecordInputStream in)\n    {\n        subrecords = new ArrayList();\n        byte[] subRecordData = in.readRemainder();\n        RecordInputStream subRecStream = new RecordInputStream(new\nByteArrayInputStream(subRecordData));\n        while(subRecStream.hasNextRecord()) {\n          subRecStream.nextRecord();\n          Record subRecord = SubRecord.createSubRecord(subRecStream);\n          subrecords.add(subRecord);\n        }\n ....\n    }\n\n\nThe condition to find next record by RecordInputStream does not work for\nEndSubRecord with sid=0.\nI'm not sure which is the best way to fix it. Below are my variants:\n\n (a) change RecordInputStream to correctly process EndSubRecord.\n  RecordInputStream is a core class and changing it just to\n handle a special case is risky.\n\n (b) if ObjRecord ALWAYS has a trailing EndSubRecord we can  manually append it\nin ObjRecord.fillFields:\n\n    protected void fillFields(RecordInputStream in)\n    {\n        subrecords = new ArrayList();\n        byte[] subRecordData = in.readRemainder();\n        RecordInputStream subRecStream = new RecordInputStream(new\nByteArrayInputStream(subRecordData));\n        while(subRecStream.hasNextRecord()) {\n          subRecStream.nextRecord();\n          Record subRecord = SubRecord.createSubRecord(subRecStream);\n          subrecords.add(subRecord);\n        }\n        //EndSubRecord is a special case. Append it manually.  \n        subrecords.add(new EndSubRecord());     \n ....\n    }\n\nI like (b). Any objections to fixing it this way?\nAre there any pitfalls with sub-records?\n\nRegards, \nYegor Kozlov"}, {"count": 1, "tags": [], "bug_id": 41242, "text": "Created attachment 19305\ntest case", "id": 97311, "time": "2006-12-26T02:54:08Z", "creator": "yegor@dinom.ru", "creation_time": "2006-12-26T02:54:08Z", "is_private": false, "attachment_id": 19305}, {"count": 2, "tags": [], "creator": "yegor@dinom.ru", "attachment_id": 19366, "id": 97692, "creation_time": "2007-01-05T07:09:36Z", "time": "2007-01-05T07:09:36Z", "bug_id": 41242, "text": "Created attachment 19366\nthe patch", "is_private": false}, {"count": 3, "tags": [], "bug_id": 41242, "attachment_id": 19367, "id": 97693, "time": "2007-01-05T07:10:18Z", "creator": "yegor@dinom.ru", "creation_time": "2007-01-05T07:10:18Z", "is_private": false, "text": "Created attachment 19367\narchive with new and modified files"}, {"count": 4, "tags": [], "bug_id": 41242, "attachment_id": null, "id": 97695, "time": "2007-01-05T07:17:03Z", "creator": "yegor@dinom.ru", "creation_time": "2007-01-05T07:17:03Z", "is_private": false, "text": "The problem fixed.\n\nI decided not to change RecordInputStream. There is a simpler solution in\nObjRecord.fillFields:\n\nCount the number of bytes read, if there are 4 unread bytes it means\nEndSubRecord has been skipped and needs to be appended explicitly.\n\nP.S. Unit tests for ObjRecord were missing. It's time to add it. \n\nYegor"}, {"count": 5, "tags": [], "bug_id": 41242, "attachment_id": null, "id": 97767, "time": "2007-01-08T00:12:26Z", "creator": "yegor@dinom.ru", "creation_time": "2007-01-08T00:12:26Z", "is_private": false, "text": "Fixed.\n\nYegor"}, {"count": 6, "tags": [], "bug_id": 41242, "attachment_id": null, "id": 98003, "time": "2007-01-12T06:46:44Z", "creator": "yegor@dinom.ru", "creation_time": "2007-01-12T06:46:44Z", "is_private": false, "text": "*** Bug 38607 has been marked as a duplicate of this bug. ***"}]