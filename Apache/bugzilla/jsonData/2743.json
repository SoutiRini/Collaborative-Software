[{"count": 0, "tags": [], "bug_id": 2743, "attachment_id": null, "id": 3925, "time": "2001-07-23T09:30:31Z", "creator": "Jochen.Schwarze@cit.de", "creation_time": "2001-07-23T09:30:31Z", "is_private": false, "text": "To the Ant team:\n\nWhen I read the documents for the Ant2 re-design, I remembered a Perl-based \nmake system named \"cons\", now at <http://www.dsmit.com/cons/>. Like Ant, cons \ntries to be a better make. There are two design decisions or features that make \ncons unique:\n\n1) Cons never calls itself recursively, so it can process the whole dependency \ntree in one pass. Actually, cons parses a hierarchy of declarative \"Construct\" \nfiles and analyses the entire hierarchy before it starts building. This is MUCH \nbetter than the usual make approach with make processes calling themselves \nrecursively, breaking the dependency chain every time.\n\n2) Cons keeps hash keys (MD5 message digests, actually) of all dependencies and \ntargets it has seen and processed (including external influences like the \nsystem environment and compiler flags), so it can detect very reliably if \nanything has changed and needs a rebuild.\n\nExample #1: If you touch a source's modification date, that source will not be \nconsidered as changed as long as the file contents don't change; if you change \na target, that target will be rebuilt if it doesn't fit to the current set of \ndependencies.\n\nExample #2: You compile a subtree or a project with debugging enabled. When you \nre-build the entire project (say, with optimization enabled), cons will re-\ncompile exactly these files that previously have not been compiled with \noptimization enabled, because it records the set of command-line options used \nfor building each target.\n\nI have used cons for years in C/C++ building, and I haven't yet come across a \nbuild system that is nearly as reliable.\n\nAs it is, cons is not very well suited for Java applications. Cons follows a \nstrict dependency hierarchy, where a set of sources always leads to ONE result. \n(Java dependency analysis is more difficult, and the class files that are \ncreated during compilation are -- seen from the outside -- essentially random.)\n\nAnyway, it might be inspiring to look at cons' design from the perspective of \nspecifying Ant2.\n\nBest,\n\n  Jochen"}, {"count": 1, "tags": [], "text": "It's useful to be able to decompose large and complex build systems into smaller units. \n\nBeing \nable to somehow maintain the dependency tree across execution of the <ant> and <antcall> tasks \nwould be of great help when breaking down a single build script into multiple sub-scripts.", "attachment_id": null, "bug_id": 2743, "id": 13189, "time": "2002-04-10T16:06:51Z", "creator": "vaci@karel.demon.co.uk", "creation_time": "2002-04-10T16:06:51Z", "is_private": false}, {"count": 2, "tags": [], "bug_id": 2743, "attachment_id": null, "id": 153022, "time": "2012-01-22T18:47:25Z", "creator": "bruce@callenish.com", "creation_time": "2012-01-22T18:47:25Z", "is_private": false, "text": "These are interesting comments, but the design of Ant seems pretty established now and seems unlikely to change substantially in the near term. Further, the state of build systems has come a long way since 2001 and there are many lessons that have been gathered and learned.\n\nWhile this bug report makes for an interesting historical point, it does not seem to be anything that will be specifically acted upon in the Ant code base."}]