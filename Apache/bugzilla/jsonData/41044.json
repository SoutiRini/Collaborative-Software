[{"attachment_id": null, "tags": [], "bug_id": 41044, "text": "As discussed on the dev list, the fo tree memory usage is somewhat excessive due\nmainly to a large number of properties objects being generated. A number of\npatches should be added here as these issues are slowly addressed.", "count": 0, "id": 96200, "time": "2006-11-27T03:15:02Z", "creator": "richardw@geoquip-rnd.demon.co.uk", "creation_time": "2006-11-27T03:15:02Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 41044, "text": "Created attachment 19176\nReplace EnumProperty and EnumNumber constructors with getInstance()\n\nOn the fo test example I'm using here, this reduces the instance count for\nEnumNumber from ~100,000 to 3 and the instance count for EnumProperty from\n~50000 to ~200.", "id": 96201, "attachment_id": 19176, "creator": "richardw@geoquip-rnd.demon.co.uk", "creation_time": "2006-11-27T03:17:49Z", "time": "2006-11-27T03:17:49Z", "is_private": false}, {"count": 2, "tags": [], "creator": "richardw@geoquip-rnd.demon.co.uk", "is_private": false, "text": "Created attachment 19177\nComment out unused properties.\n\nComments out only those properties whose getters/setters do not form part of\nthe public API. For example Block retains commonAural despite this never being\nused, because it forms part of the API via Block.getCommonAural().", "id": 96202, "time": "2006-11-27T04:44:11Z", "bug_id": 41044, "creation_time": "2006-11-27T04:44:11Z", "attachment_id": 19177}, {"count": 3, "tags": [], "creator": "adelmelle@apache.org", "text": "Richard,\n\nNice job, so far!\n\nBeen pondering a bit more about this myself, and thought up a few things to keep in mind in the \nprocess:\n\n1) In some cases a Maker uses instance methods of the FONode for which the property is being created. \nEven the most trivial FONode.getNameId() can already result in a slightly different Property instance \nbeing created.\n2) Of specific interest are percentages and other relative values. \nTheir specified value --say 70%-- may be the same, but the underlying LengthBase has an FObj \ninstance member that comes into play when resolving that percentage during layout. A Property \ninstance for a percentage value created for one FObj can currently not be re-used for another FObj.\nPercentages need to be excluded, I think, and should always trigger the creation of new instances, \nunless there's also a design-change making it possible to reset the FObj member of a single \nLengthBase.\n\n3) Also of interest: ToBeImplementedProperty. We definitely should check whether we really need \ndifferent instances, or if one instance would be enough. Nothing is done with them anyway. At the very \nleast: one instance per distinct initial value should suffice.\n\n4) A LengthProperty instance for a property with a specified absolute value of \"10pt\" could be re-used \nfor all <length> properties (font-size, line-height, ...). This is what your patch currently demonstrates \nfor the Enums. Again, a very nice proof-of-concept!\n\nJust one tiny question/remark: would it make sense IYO to move the propertyCache to a central \nlocation, say a PropertyPool, sort of a central map structured by the property types, instead of keeping \nthese caches local to the types themselves? Provide two access points --get() and put()-- and keep all \nthe other related logic encapsulated in there...", "id": 96217, "time": "2006-11-27T10:27:15Z", "bug_id": 41044, "creation_time": "2006-11-27T10:27:15Z", "is_private": false, "attachment_id": null}, {"attachment_id": 19220, "tags": [], "bug_id": 41044, "text": "Created attachment 19220\nPatch for a similar optimization in Marker.java\n\nI wonder... especially how this would impact multi-thread processing (see\nsynchronization)\n\nSeems to break nothing, but I currently have no good testcases to be able to\njudge whether this would mean an improvement. Purely from an aesthetical point\nof view, it looks better, though... :)\n\nOpinions?", "count": 4, "id": 96579, "time": "2006-12-06T14:55:04Z", "creator": "adelmelle@apache.org", "creation_time": "2006-12-06T14:55:04Z", "is_private": false}, {"count": 5, "tags": [], "bug_id": 41044, "text": "Created attachment 19221\nCorrection...\n\nJust realized there was still a slight error in the previous patch that kind of\ndefeated the whole purpose... ;)", "id": 96580, "attachment_id": 19221, "creator": "adelmelle@apache.org", "creation_time": "2006-12-06T15:00:35Z", "time": "2006-12-06T15:00:35Z", "is_private": false}, {"count": 6, "tags": [], "bug_id": 41044, "attachment_id": null, "is_private": false, "id": 96629, "time": "2006-12-07T12:33:17Z", "creator": "adelmelle@apache.org", "creation_time": "2006-12-07T12:33:17Z", "text": "\nRichard,\n\n(In reply to comment #1)\n> Created an attachment (id=19176) [edit]\n> Replace EnumProperty and EnumNumber constructors with getInstance()\n\nLooking again at your patch, one more remark: \nThe only thing that doesn't completely sit right with me, is the lookup based on an instance of the class \nin question... This seems to me to defeat the purpose of reducing the instantiation rate. True, the \ninstance's scope remains limited to the getInstance() method, but they're created (and have to be GC'ed) \nanyway :/\n[Compare it to String internalization: I doubt the JVM creates a String instance first and throws it away \nafterwards if an internalized String for that text already exists. I'd think the extra instance is never even \ncreated...?]\n\nSee my proposed change in Marker.java: the MarkerAttribute constructor is called only when no \ncorresponding instance exists in the map yet. I'm still chewing on how to generalize such an approach \nin the properties package. \nIn the meantime, also did something similar for fo.expr.NumericProperty... again nothing broke, but I \nstill have to dig up a testcase, to see how precisely this impacts the resource consumption before \ncommitting such stuff.\n\nExample of the expected results of the change in Marker.java:\nsuppose 200 Markers, one-element subtree with attribute-set of 10 attributes\n\nBEFORE: \n2000 separate MarkerAttribute instances w/ 4 String references each, good for 8000 Strings in toto.\n\nCase 1\n-> recurring identical attribute-set\nAFTER: 1 Map with 10 entries, 10 Strings plus 10 Lists consisting of one MarkerAttribute instance each, \nmakes a total of only 10 instances (40 Strings) and 2000 references to one of those 10 instances.\n\nCase 2\n-> distinct attribute-sets (recurring names, different values)\nNEW: 1 Map with 10 entries, 10 Strings plus 10 Lists consisting of 200 MarkerAttribute instances each... \nSlight drawback because of the added Map + List instances, and the overhead of the lookup.\n\nThe rest lies somewhere in between.\nThe general use-cases would incline towards Case 1 more than Case 2 (or even a case where there are \n200 distinct attribute-sets that have absolutely no common attributes). The more distinct names, the \nlarger the Map, but this is limited to PROPERTY_COUNT keys. The Lists can be expected to remain \nreasonably sized (practical limitations on the number of distinct possible values)\n\nIf the synchronization works out as expected, a generalized approach for all Property subtypes could \nvastly reduce memory usage in multi-thread context (the above figures multiplied by a factor of 15, or \nmore), especially if all the different threads use the same set of templates, generating heaps of identical \nattributes."}, {"attachment_id": null, "tags": [], "bug_id": 41044, "is_private": false, "count": 7, "id": 96669, "time": "2006-12-08T13:14:46Z", "creator": "spepping@apache.org", "creation_time": "2006-12-08T13:14:46Z", "text": "(In reply to comment #6)\n\nI think Richard's approach is OK for read-only properties.\n\nAndreas, why is your valueCache not also a map on the value?\n\nI am not sure that your approach is worth the trouble. An EnumProperty and an\nAttribute object contain only a name and a value, and two more strings in the\nlatter case. It is quite efficient to use that as a key, and creating an object\nfor lookup is not very costly in view of the efficient hash lookup you achieve.\nFirst doing a lookup on name and then on value may cost more than it saves.\n\nOf course a map in which the key and the value are always identical seems\nstrange. I have looked into Set, which guarantees uniqueness of the objects, but\nit does not allow efficient retrieval.\n\nAt first I was wary about Richard's commenting out of properties. In principle\nevery property has an effect on layout and must be looked up. But if we wish to\nrelease a production version, we cannot waste performance on such a principle.\nTherefore I think a careful commenting out of properties not looked up is useful.\n\nRegards, Simon\n\n> Richard,\n> \n> (In reply to comment #1)\n> > Created an attachment (id=19176) [edit] [edit]\n> > Replace EnumProperty and EnumNumber constructors with getInstance()\n> \n> Looking again at your patch, one more remark: \n> The only thing that doesn't completely sit right with me, is the lookup based\non an instance of the class \n> in question... This seems to me to defeat the purpose of reducing the\ninstantiation rate. True, the \n> instance's scope remains limited to the getInstance() method, but they're\ncreated (and have to be GC'ed) \n> anyway :/\n> \n> See my proposed change in Marker.java: the MarkerAttribute constructor is\ncalled only when no \n> corresponding instance exists in the map yet. I'm still chewing on how to\ngeneralize such an approach \n> in the properties package. \n> In the meantime, also did something similar for fo.expr.NumericProperty...\nagain nothing broke, but I \n> still have to dig up a testcase, to see how precisely this impacts the\nresource consumption before \n> committing such stuff.\n"}, {"attachment_id": null, "tags": [], "bug_id": 41044, "is_private": false, "count": 8, "id": 96674, "time": "2006-12-08T14:05:52Z", "creator": "adelmelle@apache.org", "creation_time": "2006-12-08T14:05:52Z", "text": "(In reply to comment #7)\n\n> Andreas, why is your valueCache not also a map on the value?\n\nI thought of that too, but since we're trying to save on resources here I'm a bit wary of the extra objects \na Map generates under-the-hood.\nArrayLists have very low overhead in that respect. Very little more space needed on top of the instances \nit stores. Given that the number of distinct values for one attribute is expected to remain at a \nreasonable level, I'd even go as far as stating that the list iteration will perform roughly the same as a \nmap lookup. All we lose by using a List is the extra space needed for the Map.Entrys...\n\n> I am not sure that your approach is worth the trouble. \n\nIndeed, see also Joerg's response on fop-dev.\nI was not either, but it would get interesting if such an approach could be used on the complex types.\n\nOn the other hand, even if you start from a type containing only two String instance members, having \nthousands of references to one singular instance of that type is mathematically *always* better than \ncreating thousands of instances with the two String references being identical. \nThe benefit of Richard's approach is that it could rather easily be ported to all Property types. My \napproach seems more appropriate for the Attribute type. Looking closer, it would get very difficult to \nport it to the properties.\n\n> An EnumProperty and an Attribute object contain only a name and a value, \n> and two more strings in the latter case. It is quite efficient to use that as a key, \n> and creating an object for lookup is not very costly in view of the efficient hash \n> lookup you achieve.\n> First doing a lookup on name and then on value may cost more than it saves.\n\nCould be... I really should try to measure it.\n\n> Of course a map in which the key and the value are always identical seems\n> strange. I have looked into Set, which guarantees uniqueness of the objects, but\n> it does not allow efficient retrieval.\n\nHence, index-based list-retrieval! 8) \nThe uniqueness follows from the implementation, I think... \nIf the Maps and Lists are properly synchronized, then there will always be only one distinct instance per \nname/value. \nEach get() following the initial put() will return that singular instance.\n\n> At first I was wary about Richard's commenting out of properties. In principle\n> every property has an effect on layout and must be looked up. But if we wish to\n> release a production version, we cannot waste performance on such a principle.\n> Therefore I think a careful commenting out of properties not looked up is useful.\n\nAgreed here. We can always reactivate them later."}, {"count": 9, "tags": [], "creator": "adelmelle@apache.org", "text": "(In reply to comment #8)\n> ... I'd even go as far as stating that the list iteration will perform roughly the same as a \n> map lookup. All we lose by using a List is the extra space needed for the Map.Entrys...\n\nJust FYI:\nFinally got around to performing the measurements, and I was wrong about this. Using Maps is much \nfaster, up to about five times faster with value-lists as small as 10 elements... Richard's is definitely the \nway to go.", "id": 96987, "time": "2006-12-16T14:14:25Z", "bug_id": 41044, "creation_time": "2006-12-16T14:14:25Z", "is_private": false, "attachment_id": null}, {"count": 10, "tags": [], "bug_id": 41044, "attachment_id": null, "text": "(In reply to comment #9)\n> Finally got around to performing the measurements, and I was wrong about this. Using Maps is much \n> faster, up to about five times faster with value-lists as small as 10 elements... Richard's is definitely the \n> way to go.\n\nAs a consequence of these results, I adapted my change in Marker.java to use Maps instead of Lists, and \ncommitted it: http://svn.apache.org/viewvc?view=rev&rev=487972", "id": 96990, "time": "2006-12-17T04:02:16Z", "creator": "adelmelle@apache.org", "creation_time": "2006-12-17T04:02:16Z", "is_private": false}, {"count": 11, "tags": [], "text": "Some notes regarding the comments so far:\n1. An immutable class is guaranteed to be thread safe. I'm aiming at changing\nall property classes to be this way, as I believe they were intended to be.\n2. Constructing lots of short lived objects and comparing them against a few\nlong lived ones is much quicker than than creating lots of long lived objects.\nIf we were writing in C this would not always be the case - there would be no\ntree traversal and an equal number of malloc/frees. Given that this is Java, we\nreduce the number of GC passes and allow the newer collectors to work more\nefficiently.\n3. String.intern() does require an existing String.\n4. The location of PropertyCache and the cached values can be changed later if\nrequired.\n", "is_private": false, "id": 97014, "creator": "richardw@geoquip-rnd.demon.co.uk", "time": "2006-12-18T03:46:23Z", "bug_id": 41044, "creation_time": "2006-12-18T03:46:23Z", "attachment_id": null}, {"count": 12, "tags": [], "bug_id": 41044, "attachment_id": null, "text": "(In reply to comment #11)\n\nThanks for the info, Richard.\n\nJust a minor clarification:\n> 3. String.intern() does require an existing String.\n\nObviously, explicit internalization does, but what I was referring to earlier is the difference between \nexplicit (run-time) and implicit (compile-time) internalization: in the latter case, I'm pretty sure a separate \ninstance never gets created...", "id": 97029, "time": "2006-12-18T09:32:24Z", "creator": "adelmelle@apache.org", "creation_time": "2006-12-18T09:32:24Z", "is_private": false}, {"count": 13, "tags": [], "text": "Created attachment 19289\nMore getInstance() replacements, final property members, etc.\n\nReduces memory usage, but breaks TXTHandler. Covers all properties not\nimplementing CompoundDatatype. Further thought is needed regarding\nCompoundDatatype examples and other performance issues.", "is_private": false, "id": 97082, "creator": "richardw@geoquip-rnd.demon.co.uk", "time": "2006-12-19T08:09:51Z", "bug_id": 41044, "creation_time": "2006-12-19T08:09:51Z", "attachment_id": 19289}, {"count": 14, "tags": [], "creator": "spepping@apache.org", "text": "Comment on attachment 19176\nReplace EnumProperty and EnumNumber constructors with getInstance()\n\nAlso included in the following attachment", "id": 97108, "time": "2006-12-20T00:50:21Z", "bug_id": 41044, "creation_time": "2006-12-20T00:50:21Z", "is_private": false, "attachment_id": 19176}, {"count": 15, "tags": [], "creator": "spepping@apache.org", "is_private": false, "text": "Patch 19177 applied. Thanks.", "id": 97109, "time": "2006-12-20T00:51:07Z", "bug_id": 41044, "creation_time": "2006-12-20T00:51:07Z", "attachment_id": null}, {"attachment_id": 19410, "tags": [], "bug_id": 41044, "text": "Created attachment 19410\nUpdated properties patch\n\nRelative to revision 496642. Includes previous changes and further\nmodifications to CommonXXX and XXXProperty classes. Breaks TXTHandler and will\naffect any other code which relies on Mutable properties. For the most part,\nthe patch consists of adding hashCode() and equals() methods and replacing\nconstructor calls with calls to static getInstance methods.", "count": 16, "id": 98117, "time": "2007-01-16T02:25:15Z", "creator": "richardw@geoquip-rnd.demon.co.uk", "creation_time": "2007-01-16T02:25:15Z", "is_private": false}, {"attachment_id": null, "tags": [], "bug_id": 41044, "is_private": false, "count": 17, "id": 102330, "time": "2007-04-25T07:02:28Z", "creator": "richardw@geoquip-rnd.demon.co.uk", "creation_time": "2007-04-25T07:02:28Z", "text": "See also http://issues.apache.org/bugzilla/show_bug.cgi?id=41656\n"}, {"count": 18, "tags": [], "bug_id": 41044, "attachment_id": 20041, "text": "Created attachment 20041\nUpdated patch against svn head.\n\nThis looks about as good as it's going to get for the moment. The TXTHandler\nissues turned out not to be relevant - nothing seems to be accessing this code\nand simply removing it (as this patch does) affects nothing else insofar as I\ncan tell. I'd be interested in any feedback on this. Unless this patch breaks\nsomething I haven't accounted for, I'd suggest applying it to trunk as-is.", "id": 102360, "time": "2007-04-25T08:35:29Z", "creator": "richardw@geoquip-rnd.demon.co.uk", "creation_time": "2007-04-25T08:35:29Z", "is_private": false}, {"attachment_id": null, "tags": [], "bug_id": 41044, "text": "Hi Richard,\n\nI've finally found some time to finish reviewing your patch, and it looked good at first glance, apart \nfrom some style issues (javadocs, bracing conditional branches even if there's only one statement, \nblabla) and what I take to be some small typos (for example: in CommonHyphenation.equals(), you \ncompared the country, language and script properties to themselves instead of to their counterparts \nfrom the other instance).\n\nUnfortunately, when I ran the junit tests, there seems to be a lot of work before we can apply it as is... I \nget 70 errors. :/ (a lot of them NPEs)\nAm I doing something wrong, or did you skip the testsuite?\n\nThe only thing I really threw out were the deprecated-tags from CompoundDataType and \nLengthRangeProperty. This does need some further thought, nevertheless.\nFor CommonBorderPaddingBackground.setBorderInfo(), I agreed. So much even that I removed \nsetBorderInfo() and setPadding() completely, instead of merely deprecating.\n\nFor now, I'll offer a bit more info on the rationale behind the mutability of compounds, and an idea on \nhow to tackle it.\nCompounds would be tricky in terms of canonicalization, because, in order to judge which compound \ninstance you need, you have to have all the components available (e.g.: for space-before you need \nthe .minimum, .maximum, .optimum, .conditionality and .precedence components).\nThis means that, currently, in order to correctly canonicalize a compound, we would have to wait until \nall attributes for a given FO have been converted to properties. We cannot do so at the time the \ncompound is first created, since it will at that point only have the specified value of /one/ of the \ncomponents (the first one in the list)\n\nThe sole reason why they are mutable is that they are not created in one go, but rather, the base-\nproperty is created once the first component is encountered in the attribute-list. Further on in the \nprocess, as the other components are converted, the PropertyMakers need to be able to change the \nbase-property (through setComponent())\n\nA possible solution I'm thinking of is to rewrite part of the convertAttributeToProperty-loop in \nPropertyList. If we can make sure that compounds are always created as a single compound property \n(instead of the multiple components each setting the component of a base-property), then they would \nnot need to be mutable at all, and the issue is rendered moot. \nFWIW, I've always disliked a bit the fact that the attributes are simply looped over. The hacks a bit \nhigher up, in addAttributesToList(), for extracting column-number and font-size before all others, are \nto me an indication that this should be revisited.\n\nAs I roughly see it ATM, a compound would be made/instantiated using a list of attributes, instead of \nonly one. As soon as one component is encountered, we would immediately scan the Attributes, \nextracting all the other components, and can then pass them all into the compound's PropertyMaker. As \nsuch, there is no more need for the setComponent() methods, since by converting one component's \nattribute, we would immediately convert the whole compound.\n\nWDYT?\n\nAndreas", "count": 19, "id": 104704, "time": "2007-06-25T15:39:44Z", "creator": "adelmelle@apache.org", "creation_time": "2007-06-25T15:39:44Z", "is_private": false}, {"count": 20, "tags": [], "creator": "adelmelle@apache.org", "text": "Status update: something really weird seems to be going on here. \nContinuing the tests with 'block-container_content_size_percentage.xml'.\n\nI placed a breakpoint around where the error originates ( AbstractBaseLM, line 89 ), then on each break \nchecked the call stack, and noticed that for all nested block-containers except the first one, the stack \npoints back to BlockContainerLM line 218, which is inside a conditional block that should only be entered \nif width=\"auto\" (?)\n\nThe search continues...", "id": 104873, "time": "2007-06-28T14:06:31Z", "bug_id": 41044, "creation_time": "2007-06-28T14:06:31Z", "is_private": false, "attachment_id": null}, {"count": 21, "tags": [], "text": "Sorry, the block should precisely only be entered when it is *not* auto.\n\nAnother dead end :(", "is_private": false, "id": 104875, "creator": "adelmelle@apache.org", "time": "2007-06-28T14:23:20Z", "bug_id": 41044, "creation_time": "2007-06-28T14:23:20Z", "attachment_id": null}, {"attachment_id": null, "tags": [], "bug_id": 41044, "is_private": false, "count": 22, "id": 104925, "time": "2007-06-29T11:19:17Z", "creator": "adelmelle@apache.org", "creation_time": "2007-06-29T11:19:17Z", "text": "\nMore info:\nReverting the change in the usage of the PropertyCache by PropertyList solves 11 of the 70 errors I \ninitially encountered. The others are related to the Common* property bundles that include properties \nthat can be percentages (padding, margin...)\n\nThe idea is right, but the implementation is slightly in error. Most likely due to the inherent complexity \nof the properties package...(?)\nOnce you get it, it's really simple actually:\nEvery Property class has its own particular Maker that deals with converting an attribute value to the \ncorrect type of Property instance. FOPropertyMapping initializes a cache of those makers, one for each \nproperty defined in the XSL-FO Rec. (still limited to 1.0)\nThe PropertyList deals with the entire attribute list for a single FO. Given an Attributes instance, it \nextracts a few properties first --font-size, column-number-- because of possible dependencies in \nother properties --em-lengths, from-table-column(). All the others are looped over: fetch Maker and \ncall Maker.make(), basically, which triggers the PropertyParser to parse the expression and return a \ngeneric Property instance, possibly a compound or a list of Property instances...\n\nThinking some more about the general approach, the pseudo-singleton pattern by itself is not enough \nhere (private constructors and a getInstance()).\nI'm thinking of also weaving some of it into the Maker-logic. Have the Makers bear the responsibility \nthat no necessary duplicates are missing (as is the case for the LengthBase of \"50%\" for instance, after \napplying the patch)\nAlso, I'm going to set aside the idea about creating canonical Common* bundles FTM, apart from the \nquite common \"no border, no padding, no background\" scenario. The padding length-conditionals and \nBorderInfos are already difficult enough to handle. If the border, padding and background properties by \nthemselves are guaranteed to be canonical, then a lot of the 'duplicate' bundles will be nothing but \nwrappers around a bunch of references to the very same BorderInfos, absolute padding-widths, etc. \nThat's already bound to save a lot.\n\nThere seems to be an inherent error, not only WRT percentages, but more generally any relative value. If \nI get the drift of the patch correctly, it creates a canonical Property instance for the attribute:\nwidth=\"2em\"\n\nMeaning: for a LengthProperty with an explicitly specified value of \"2em\"...? What if we then later on \nencounter that same attribute value on another, very likely unrelated node?"}, {"count": 23, "tags": [], "bug_id": 41044, "text": "\nSome more brainstorming about correcting the ideas:\n\nMake the PropertyCache more than a simple wrapper around a WeakHashMap, and instead of giving \neach Property type its own cache, make the Map multi-dimensional (or an array of WeakHashMaps?) \nThe base Map would be, for example, a mapping of Class objects to a WeakHashMap, which would then \ncontain the canonical instances for a particular Property type.\n\nSomething like:\n\npublic final class PropertyCache {\n\n    private static Map typeCache = new HashMap();\n    private static Map propCache;\n    \n    \n    /**\n     *  Checks if the given property is present in the cache - if so, returns\n     *  a reference to the cached value. Otherwise the given object is added\n     *  to the cache and returned.\n     *  @param obj\n     *  @return the cached instance\n     */\n    public static synchronized Property fetch(Property prop) {\n        \n        Class propType = prop.getClass();\n        propCache = (Map) typeCache.get(propType);\n        if (propCache == null) {\n            propCache = new WeakHashMap();\n            propCache.put(prop, prop);\n            typeCache.put(propType, propCache);\n            return prop;\n        } else {\n            Property cacheEntry = (Property) propCache.get(prop);\n            if (cacheEntry != null) {\n                return cacheEntry;\n            } else {\n                propCache.put(prop, prop);\n                return prop;\n            }\n        }\n    }\n}\n\nThe PropertyMakers, in their turn, will use this cache whenever they receive a Property from the \nPropertyParser that can be safely canonicalized (absolute lengths, enums, strings, ...). If the Property \nthey receive from the parser is a relative one, they bypass the cache and make sure to return the new \ninstance.", "id": 104952, "attachment_id": null, "creator": "adelmelle@apache.org", "creation_time": "2007-06-30T08:47:56Z", "time": "2007-06-30T08:47:56Z", "is_private": false}, {"attachment_id": null, "tags": [], "bug_id": 41044, "text": "Basics of the patch have been applied, with some modifications:\n\n* removed usage of the cache by the PropertyList and Common*-bundles\n* applied caching to a restricted set of Property types that can be safely canonicalized\n\nsee: http://svn.apache.org/viewvc?view=rev&rev=554251\n\nClosing this one. For any improvements, just create a new report.", "count": 24, "id": 105178, "time": "2007-07-07T13:18:14Z", "creator": "adelmelle@apache.org", "creation_time": "2007-07-07T13:18:14Z", "is_private": false}, {"count": 25, "tags": [], "text": "batch transition pre-FOP1.0 resolved+fixed bugs to closed+fixed", "is_private": false, "id": 156030, "creator": "gadams@apache.org", "time": "2012-04-01T06:54:17Z", "bug_id": 41044, "creation_time": "2012-04-01T06:54:17Z", "attachment_id": null}]