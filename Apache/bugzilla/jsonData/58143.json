[{"count": 0, "tags": [], "bug_id": 58143, "attachment_id": null, "id": 184038, "time": "2015-07-15T16:55:31Z", "creator": "andrei.ivanov@gmail.com", "creation_time": "2015-07-15T16:55:31Z", "is_private": false, "text": "The Spring Framework load time weaving mechanism registers class file transformers when the web app is deployed:\n\nWebappClassLoader(WebappClassLoaderBase).addTransformer(ClassFileTransformer) line: 666\n\tTomcatLoadTimeWeaver.addTransformer(ClassFileTransformer) line: 88\t\n\tDefaultContextLoadTimeWeaver.addTransformer(ClassFileTransformer) line: 143\t\n\tAspectJWeavingEnabler.enableAspectJWeaving(LoadTimeWeaver, ClassLoader) line: 83\t\n\tAspectJWeavingEnabler.postProcessBeanFactory(ConfigurableListableBeanFactory) line: 71\t\n\tPostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(Collection<BeanFactoryPostProcessor>, ConfigurableListableBeanFactory) line: 284\t\n\tPostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory, List<BeanFactoryPostProcessor>) line: 174\t\n\tXmlWebApplicationContext(AbstractApplicationContext).invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory) line: 658\t\n\tXmlWebApplicationContext(AbstractApplicationContext).refresh() line: 504\t\n\tContextLoaderListener(ContextLoader).configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext, ServletContext) line: 446\t\n\tContextLoaderListener(ContextLoader).initWebApplicationContext(ServletContext) line: 328\t\n\tContextLoaderListener.contextInitialized(ServletContextEvent) line: 107\t\n\tStandardContext.listenerStart() line: 4729\t\n\tStandardContext.startInternal() line: 5167\t\n\tStandardContext(LifecycleBase).start() line: 150\t\n\tStandardHost(ContainerBase).addChildInternal(Container) line: 725\t\n\tStandardHost(ContainerBase).addChild(Container) line: 701\t\n\tStandardHost.addChild(Container) line: 717\t\n\tHostConfig.deployWAR(ContextName, File) line: 945\t\n\tHostConfig$DeployWar.run() line: 1768\t\n\tExecutors$RunnableAdapter<T>.call() line: 511\t\n\tFutureTask<V>.run() line: 266\t\n\tThreadPoolExecutor.runWorker(ThreadPoolExecutor$Worker) line: 1142\t\n\tThreadPoolExecutor$Worker.run() line: 617\t\n\tThread.run() line: 745\t\n\nAfter this moment, any classes loaded will be transformed, if necessary.\n\nMy problem is that Tomcat loads some classes before these transformers are registered:\n\tWebappClassLoader(WebappClassLoaderBase).findResourceInternal(String, String, boolean) line: 2639\t\n\tWebappClassLoader(WebappClassLoaderBase).findResource(String) line: 936\t\n\tWebappClassLoader(WebappClassLoaderBase).getResourceAsStream(String) line: 1115\t\n\tContextConfig.populateJavaClassCache(String) line: 2165\t\n\tContextConfig.populateJavaClassCache(String, JavaClass) line: 2155\t\n\tContextConfig.checkHandlesTypes(JavaClass) line: 2060\t\n\tContextConfig.processAnnotationsStream(InputStream, WebXml, boolean) line: 2012\t\n\tContextConfig.processAnnotationsJar(URL, WebXml, boolean) line: 1961\t\n\tContextConfig.processAnnotationsUrl(URL, WebXml, boolean) line: 1936\t\n\tContextConfig.processAnnotations(Set<WebXml>, boolean) line: 1897\t\n\tContextConfig.webConfig() line: 1149\t\n\tContextConfig.configureStart() line: 771\t\n\tContextConfig.lifecycleEvent(LifecycleEvent) line: 305\t\n\tLifecycleSupport.fireLifecycleEvent(String, Object) line: 117\t\n\tStandardContext(LifecycleBase).fireLifecycleEvent(String, Object) line: 90\t\n\tStandardContext.startInternal() line: 5066\t\n\tStandardContext(LifecycleBase).start() line: 150\t\n\tStandardHost(ContainerBase).addChildInternal(Container) line: 725\t\n\tStandardHost(ContainerBase).addChild(Container) line: 701\t\n\tStandardHost.addChild(Container) line: 717\t\n\tHostConfig.deployWAR(ContextName, File) line: 945\t\n\tHostConfig$DeployWar.run() line: 1768\t\n\tExecutors$RunnableAdapter<T>.call() line: 511\t\n\tFutureTask<V>.run() line: 266\t\n\tThreadPoolExecutor.runWorker(ThreadPoolExecutor$Worker) line: 1142\t\n\tThreadPoolExecutor$Worker.run() line: 617\t\n\tThread.run() line: 745\t\n\nThis makes subsequent calls to WebappClassLoaderBase.findResourceInternal to return cached resources:\nResourceEntry entry = resourceEntries.get(path);\nif (entry != null) {\n    return entry;\n}\n\nThese cached resources will not go through the transformers, which are called bellow.\n\nMaybe the resourceEntries cache could be flushed somehow?"}, {"count": 1, "tags": [], "bug_id": 58143, "text": "This started from https://jira.spring.io/browse/SPR-13210", "id": 184039, "time": "2015-07-15T16:56:02Z", "creator": "andrei.ivanov@gmail.com", "creation_time": "2015-07-15T16:56:02Z", "is_private": false, "attachment_id": null}, {"count": 2, "attachment_id": null, "creator": "violetagg@apache.org", "text": "Hi,\n\nHere are my comments:\n\nThe most obvious solution here is to clear WebappClassLoaderBase.resourceEntries when a transformer is added but I have some concerns about it.\n\nWhen you are using TomcatInstrumentableClassLoader it is defined in context.xml and this class loader will be used to load the classes from the very beginning (please correct me if this is not the case from spring point of view)\n\nWhen you are using TomcatLoadTimeWeaver (this bug) the transformer is added on contextInitialed phase which, my opinion, is too late.\nI think that this (TomcatLoadTimeWeaver) should be added on an earlier stage (e.g. the loader created event or configure_start event). Otherwise:\n- ServletContainerInitializers will work with non-transformed classes\n- Annotations scanning will happen on non-transformed classes\n- Depending on ServletContextListeners order, the listeners before Spring's one will work with non-transformed classes\n\nWhy I think that clearing resourceEntries is not a good solution:\n- There might appear ClassCastExceptions between components using non-transformed and transformed classes.\n\nOther solution will be to mark the loader as modified when a transformer is added so that the context will be reloaded (if it supports reloadable).\nThis won't solve the Spring's case because they will add the transformer again on the contextInitialized step and we will enter in never ending cycle.\n\nOther opinions?\n\nRegards,\nVioleta", "id": 184088, "time": "2015-07-20T14:44:53Z", "bug_id": 58143, "creation_time": "2015-07-20T14:44:53Z", "tags": [], "is_private": false}, {"attachment_id": null, "tags": [], "bug_id": 58143, "is_private": false, "count": 3, "id": 184233, "time": "2015-07-30T14:41:08Z", "creator": "markt@apache.org", "creation_time": "2015-07-30T14:41:08Z", "text": "I don't think we can fix this.\n\nThe TomcatLoadTimeWeaver could be configured slightly earlier (in an SCI) but that is the earliest specification defined hook that could be used. This still isn't early enough to catch everything since any classes defined in a HandlesType for an SCI will already have been loaded by this point.\n\nAnything earlier requires Tomcat specific configuration at which point you might as well use the TomcatInstrumentableClassLoader and configure it in a META-INF/context.xml.\n\nI'll bring this to the attention of the Spring folks via $dayjob to see if they can come up with anything better."}, {"count": 4, "attachment_id": null, "creator": "markt@apache.org", "text": "I had some discussions with the Spring folks at $dayjob and they haven't been able to come up with a better solution either.\n\nThe only other option that did come up in the discussion was avoiding the annotation and HandlesType scanning. It should be possible to avoid the annotation scanning by explicit definitions in web.xml. The HandlesType scanning can be disabled but there is no alternative available to replace it.\n\nYou may ned up having to use TomcatInstrumentableClassLoader.", "id": 184895, "time": "2015-09-01T12:30:49Z", "bug_id": 58143, "creation_time": "2015-09-01T12:30:49Z", "tags": [], "is_private": false}, {"count": 5, "attachment_id": null, "creator": "andrei.ivanov@gmail.com", "is_private": false, "id": 184896, "time": "2015-09-01T12:36:09Z", "bug_id": 58143, "creation_time": "2015-09-01T12:36:09Z", "tags": [], "text": "Thanks :-)\nI've managed to activate the TomcatInstrumentableClassLoader, as the context.xml in the WAR was ignored when deploying the app in a virtual host with the context defined there."}, {"count": 6, "tags": [], "text": "As suggested by Mark I have reopened this as an enhancement.\n\nI have also come across this issue. In short registering a transformer in a ServletContextInitializer was too late for classes that are scanned as part of the @HandlesTypes mechanism, they are already loaded and are therefore not transformed.\n\nIt would be great if we could have an alternative mechanism to register transformers before scanning takes place.\n\nIdeally this would be automatic registration rather than requiring the developer to configure anything, thus allowing them to include the library with the transformer in and benefit without referring to installation instructions. This was my original goal of registering the transformer in a ServletContextInitializer.\n\nWith this in mind the ServiceLoader mechanism or something similar could be considered.\n\nLibrary developers would create a resource containing the fully qualified class names of their transformers at:\nMETA-INF/services/java.lang.instrument.ClassFileTransformer\n\nTransformers would be enumerated and registered before scanning takes place.\n \nEven if JDK ServiceLoader implementation is not used, perhaps due to performance, then the mechanism is at least well understood by developers. Instead of having custom config specific to Tomcat the docs can just say that ClassFileTransformers are discovered via ServiceLoader. This raises the chances that other servlet containers would adopt the same approach. \n\nI note that Jetty have an addTransformer method on their classloader as well, but using ServiceLoader would be container independent.", "is_private": false, "id": 184975, "creator": "bryncooke@gmail.com", "time": "2015-09-04T22:15:22Z", "bug_id": 58143, "creation_time": "2015-09-04T22:15:22Z", "attachment_id": null}, {"count": 7, "tags": [], "creator": "markt@apache.org", "text": "*** Bug 58560 has been marked as a duplicate of this bug. ***", "id": 186060, "time": "2015-10-28T16:28:58Z", "bug_id": 58143, "creation_time": "2015-10-28T16:28:58Z", "is_private": false, "attachment_id": null}, {"count": 8, "tags": [], "creator": "andrei.ivanov@gmail.com", "text": "I think this can be closed now that since 8.0.33 the class cache is gone, rendering TomcatInstrumentableClassLoader useless, but making the TomcatLoadTimeWeaver work.", "id": 190065, "time": "2016-04-08T07:52:23Z", "bug_id": 58143, "creation_time": "2016-04-08T07:52:23Z", "is_private": false, "attachment_id": null}, {"count": 9, "attachment_id": null, "creator": "violetagg@apache.org", "text": "Hi,\n\nThis is fixed for 8.0.33 onwards.\n\nRegards,\nVioleta", "id": 190125, "time": "2016-04-11T07:15:01Z", "bug_id": 58143, "creation_time": "2016-04-11T07:15:01Z", "tags": [], "is_private": false}, {"count": 10, "tags": [], "bug_id": 58143, "is_private": false, "text": "Reopening this for TC 7.\n\nMy situation:\n\n- not using Springs TomcatInstrumentableClassLoader  but instead relying on the normal Tomcat WebappClassLoader (and WebappClassLoaderBase) implementing InstrumentableClassLoader\n\n- using Spring load time weaving\n\nThat combination works starting with the implementation of InstrumentableClassLoader in 7.0.64 but is broken again since 7.0.70.\n\nReason is the reorganization of the resourceEntries cache. During context initialization the class which should get woven is loaded two times. Once as a resource (and at a time when the weaver was not yet added to the class loader) and then again as a class with the weaver in place. Starting with 7.0.70 the loading as a resource and as a class use the same key in the resourceEntries cache. Since the weaving does not happen when a class is served from the cache, this breaks it.\n\nIn TC 8, 8.5 and 9 there was a later change in WebappClassLoaderBase which makes it work again. The weaving was moved from close to the place were resources get added to resourceEntries in findResourceInternal() to findClassInternal().\n\nThat change also does quite a few other things, so I isolated it moving the weaver call and tested it in TC 7 with the unit tests. This did not show any problems.\n\nOriginally the problem was observed using Spring 3.0, but the behavior is unchanged for at least of Spring 3.0-4.3.9.\n\nI will attach a suggested patch and also a simple example webapp named \"weave\". Calling the URI /weave/ will respond with \"Hello World!\" if weaving succeeds, and with \"Unwoven\" if not. See the trivial class Greeting, the beans file weave.xml, its declaration in web.xml and the index.jsp, all of which are very small. Unfortunately the war file is 6 MB due to the size of the included Spring jar files.\n\nRegards,\n\nRainer", "id": 203521, "time": "2018-01-28T09:39:25Z", "creator": "rainer.jung@kippdata.de", "creation_time": "2018-01-28T09:39:25Z", "attachment_id": null}, {"count": 11, "tags": [], "creator": "rainer.jung@kippdata.de", "text": "Created attachment 35700\nSuggested patch for TC 7\n\nMinimal patch for TC 7", "id": 203522, "time": "2018-01-28T09:43:24Z", "bug_id": 58143, "creation_time": "2018-01-28T09:43:24Z", "is_private": false, "attachment_id": 35700}, {"count": 12, "tags": [], "text": "The fix for trunk, which was backported to 8.5 and 8 but not to seven was:\n\nr1730946 | markt | 2016-02-17 22:16:40 +0100 (Wed, 17 Feb 2016) | 1 line\n\nRefactor class loading so JAR scanning does not trigger the caching of the byte[] for every scanned class until the class is loaded.", "is_private": false, "id": 203523, "creator": "rainer.jung@kippdata.de", "time": "2018-01-28T09:47:19Z", "bug_id": 58143, "creation_time": "2018-01-28T09:47:19Z", "attachment_id": null}, {"count": 13, "tags": [], "creator": "rainer.jung@kippdata.de", "text": "The example webapp is available at\n\nhttps://gist.github.com/rainerjung/99802d9cf321b9c594665b2933d8ea49", "id": 203524, "time": "2018-01-28T09:57:12Z", "bug_id": 58143, "creation_time": "2018-01-28T09:57:12Z", "is_private": false, "attachment_id": null}, {"count": 14, "tags": [], "bug_id": 58143, "text": "Finally for the sake of completeness the stacks of the two loading calls for the class to get woven.\n\nFirst call (happening before Spring called addTransformer()). Here name=\"de/kippdata/demo/weave/Greeting.class\", path=\"/de/kippdata/demo/weave/Greeting.class\", so the class was loaded as a resource:\n\n        at org.apache.catalina.loader.WebappClassLoaderBase.findResourceInternal(WebappClassLoaderBase.java:3194)\n        at org.apache.catalina.loader.WebappClassLoaderBase.findResource(WebappClassLoaderBase.java:1473)\n        at org.apache.catalina.loader.WebappClassLoaderBase.getResourceAsStream(WebappClassLoaderBase.java:1701)\n        at org.springframework.core.OverridingClassLoader.openStreamForClass(OverridingClassLoader.java:166)\n        at org.springframework.core.OverridingClassLoader.loadBytesForClass(OverridingClassLoader.java:142)\n        at org.springframework.context.support.ContextTypeMatchClassLoader$ContextOverridingClassLoader.loadClassForOverriding(ContextTypeMatchClassLoader.java:111)\n        at org.springframework.core.OverridingClassLoader.loadClass(OverridingClassLoader.java:90)\n        at java.lang.ClassLoader.loadClass(ClassLoader.java:247)\n        at org.springframework.core.OverridingClassLoader.loadClass(OverridingClassLoader.java:84)\n        at org.springframework.context.support.ContextTypeMatchClassLoader.loadClass(ContextTypeMatchClassLoader.java:72)\n        at org.springframework.util.ClassUtils.forName(ClassUtils.java:250)\n        at org.springframework.beans.factory.support.AbstractBeanFactory.doResolveBeanClass(AbstractBeanFactory.java:1429)\n        at org.springframework.beans.factory.support.AbstractBeanFactory.resolveBeanClass(AbstractBeanFactory.java:1377)\n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.determineTargetType(AbstractAutowireCapableBeanFactory.java:641)\n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.predictBeanType(AbstractAutowireCapableBeanFactory.java:609)\n        at org.springframework.beans.factory.support.AbstractBeanFactory.isFactoryBean(AbstractBeanFactory.java:1484)\n        at org.springframework.beans.factory.support.DefaultListableBeanFactory.doGetBeanNamesForType(DefaultListableBeanFactory.java:425)\n        at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanNamesForType(DefaultListableBeanFactory.java:395)\n        at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(PostProcessorRegistrationDelegate.java:81)\n        at org.springframework.context.support.AbstractApplicationContext.invokeBeanFactoryPostProcessors(AbstractApplicationContext.java:687)\n        at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:525)\n        at org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:443)\n        at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:325)\n        at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:107)\n        at org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:5109)\n        at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5632)\n        at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:145)\n        at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:1015)\n        at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:991)\n        at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:652)\n        at org.apache.catalina.startup.HostConfig.deployWAR(HostConfig.java:1127)\n        at org.apache.catalina.startup.HostConfig$DeployWar.run(HostConfig.java:2020)\n        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:439)\n        at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303)\n        at java.util.concurrent.FutureTask.run(FutureTask.java:138)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:895)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:918)\n        at java.lang.Thread.run(Thread.java:662)\n\n\nSecond call, now with transformers in place but with class already cached. Here name=\"de.kippdata.demo.weave.Greeting\", path=\"/de/kippdata/demo/weave/Greeting.class\", so the class was loaded as an actual class:\n\n        at org.apache.catalina.loader.WebappClassLoaderBase.findResourceInternal(WebappClassLoaderBase.java:3194)\n        at org.apache.catalina.loader.WebappClassLoaderBase.findClassInternal(WebappClassLoaderBase.java:3060)\n        at org.apache.catalina.loader.WebappClassLoaderBase.findClass(WebappClassLoaderBase.java:1388)\n        at org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1876)\n        at org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1750)\n        at org.springframework.util.ClassUtils.forName(ClassUtils.java:250)\n        at org.springframework.beans.factory.support.AbstractBeanDefinition.resolveBeanClass(AbstractBeanDefinition.java:401)\n        at org.springframework.beans.factory.support.AbstractBeanFactory.doResolveBeanClass(AbstractBeanFactory.java:1432)\n        at org.springframework.beans.factory.support.AbstractBeanFactory.resolveBeanClass(AbstractBeanFactory.java:1377)\n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.determineTargetType(AbstractAutowireCapableBeanFactory.java:641)\n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.predictBeanType(AbstractAutowireCapableBeanFactory.java:609)\n        at org.springframework.beans.factory.support.AbstractBeanFactory.isFactoryBean(AbstractBeanFactory.java:1484)\n        at org.springframework.beans.factory.support.DefaultListableBeanFactory.doGetBeanNamesForType(DefaultListableBeanFactory.java:425)\n        at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanNamesForType(DefaultListableBeanFactory.java:395)\n        at org.springframework.context.support.DefaultLifecycleProcessor.getLifecycleBeans(DefaultLifecycleProcessor.java:275)\n        at org.springframework.context.support.DefaultLifecycleProcessor.startBeans(DefaultLifecycleProcessor.java:133)\n        at org.springframework.context.support.DefaultLifecycleProcessor.onRefresh(DefaultLifecycleProcessor.java:114)\n        at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:880)\n        at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:546)\n        at org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:443)\n        at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:325)\n        at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:107)\n        at org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:5109)\n        at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5632)\n        at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:145)\n        at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:1015)\n        at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:991)\n        at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:652)\n        at org.apache.catalina.startup.HostConfig.deployWAR(HostConfig.java:1127)\n        at org.apache.catalina.startup.HostConfig$DeployWar.run(HostConfig.java:2020)\n        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:439)\n        at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303)\n        at java.util.concurrent.FutureTask.run(FutureTask.java:138)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:895)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:918)\n        at java.lang.Thread.run(Thread.java:662)\n\n\nBefore 7.0.70, the two calls did not use the same path for resource and class, so they did not share the cache entry. After the optimization in r1745608 they do.", "id": 203525, "time": "2018-01-28T10:09:26Z", "creator": "rainer.jung@kippdata.de", "creation_time": "2018-01-28T10:09:26Z", "is_private": false, "attachment_id": null}]