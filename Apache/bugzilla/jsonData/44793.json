[{"count": 0, "attachment_id": null, "creator": "overcomeunicom@hotmail.com", "is_private": false, "id": 115488, "time": "2008-04-10T01:12:29Z", "bug_id": 44793, "creation_time": "2008-04-10T01:12:29Z", "tags": [], "text": "if the bucket has only one element and the element is not match, cause entry_p is not null and entry_p->te_next_p is null, then the loop is not excuted, then we   get to judge whether we find it. it's a bug,should fix as follow   \n /* look for the entry in this bucket, only check keys of the same size */\n    last_p = NULL;\n    for (entry_p = table_p->ta_buckets[bucket];\n         (entry_p != NULL) && (entry_p->te_next_p != last_p);\n         last_p = entry_p, entry_p = entry_p->te_next_p) {\n        if (entry_p->te_key_size == ksize\n            && memcmp(ENTRY_KEY_BUF(entry_p), key_buf, ksize) == 0)\n            break;\n    }\n    /* did we find it?  then we are in replace mode. */\n    if (entry_p != NULL) {\n\n        /* can we not overwrite existing data? */\n        if (!overwrite_b) {\n            if (key_buf_p != NULL)\n                *key_buf_p = ENTRY_KEY_BUF(entry_p);\n            if (data_buf_p != NULL) {\n                if (entry_p->te_data_size == 0)\n                    *data_buf_p = NULL;\n                else {\n                    if (table_p->ta_data_align == 0)\n                        *data_buf_p = ENTRY_DATA_BUF(table_p, entry_p);\n                    else\n                        *data_buf_p = entry_data_buf(table_p, entry_p);\n                }\n            }\n            return TABLE_ERROR_OVERWRITE;\n        }\n\n////////fix\n/* look for the entry in this bucket, only check keys of the same size */\n    last_p = NULL;\n    for (entry_p = table_p->ta_buckets[bucket];\n         (entry_p != NULL) && (entry_p->te_next_p != last_p);\n         last_p = entry_p, entry_p = entry_p->te_next_p) {\n        if (entry_p->te_key_size == ksize\n            && memcmp(ENTRY_KEY_BUF(entry_p), key_buf, ksize) == 0)\n            break;\n    }\n    /* did we find it?  then we are in replace mode. */\n    // if entry_p != NULL and last_p != NULL, we find the match key\n    // otherwise if entry_p != NULL and last_p == NULL and entry_p is the match key, we also find the match key\n    if (entry_p != NULL && (last_p != NULL || (entry_p->te_key_size == ksize\n            && memcmp(ENTRY_KEY_BUF(entry_p), key_buf, ksize) == 0))) {\n        /* can we not overwrite existing data? */\n        if (!overwrite_b) {\n            if (key_buf_p != NULL)\n                *key_buf_p = ENTRY_KEY_BUF(entry_p);\n            if (data_buf_p != NULL) {\n                if (entry_p->te_data_size == 0)\n                    *data_buf_p = NULL;\n                else {\n                    if (table_p->ta_data_align == 0)\n                        *data_buf_p = ENTRY_DATA_BUF(table_p, entry_p);\n                    else\n                        *data_buf_p = entry_data_buf(table_p, entry_p);\n                }\n            }\n            return TABLE_ERROR_OVERWRITE;\n        }"}, {"count": 1, "tags": [], "bug_id": 44793, "is_private": false, "text": "The ht cache is known to be broken and deprecated. It is no longer present in 2.2.x and up. Please use the cb cache instead.", "id": 115520, "time": "2008-04-10T13:25:18Z", "creator": "rpluem@apache.org", "creation_time": "2008-04-10T13:25:18Z", "attachment_id": null}]