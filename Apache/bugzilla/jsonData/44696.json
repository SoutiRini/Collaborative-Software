[{"count": 0, "tags": [], "creator": "moog@sysdev.oucs.ox.ac.uk", "attachment_id": null, "text": "There appears to be a race condition which can occur when many clients request the same object at once.  If the object is in the cache, but expired, and a newer version is available at the backend, the first client can get served the old content with the timestamp of the new content.\n\nExample: using Apache 2.2.8, with mod_cache and mod_disk_cache, suppose there's a 3300000-byte file at /rand which has been downloaded and cached, but has now expired.  Suppose at Thu, 27 Mar 2008 16:44:40 GMT the file is updated so that it's now 2100000 bytes.\n\nIf a hundred requests are made for the file almost simultaneously:\n\nfor x in $(seq -w 00 99);\ndo (echo -e 'GET /rand HTTP/1.0\\n\\n' | nc localhost 8000 >response.$x &);\ndone\n\nthen the first few responses are:\n\nresponse.00\n--------------------------------------------\nHTTP/1.1 200 OK\nDate: Thu, 27 Mar 2008 16:44:45 GMT\nServer: Apache/2.2.8 (Unix)\nLast-Modified: Thu, 27 Mar 2008 16:44:40 GMT\nETag: \"72c013-200b20-4496de6d7ae00\"\nAccept-Ranges: bytes\nContent-Length: 2100000\nConnection: close\nContent-Type: text/plain\n\n?tuX`i%DJ!X.....\n\n\nresponse.01\n--------------------------------------------\nHTTP/1.1 200 OK\nDate: Thu, 27 Mar 2008 16:44:45 GMT\nServer: Apache/2.2.8 (Unix)\nETag: \"72c013-200b20-4496de6d7ae00\"\nAccept-Ranges: bytes\nContent-Length: 3300000\nLast-Modified: Thu, 27 Mar 2008 16:44:40 GMT\nConnection: close\nContent-Type: text/plain\n\n_qj*mB(3m(f.....\n\n\nresponse.02\n--------------------------------------------\nHTTP/1.1 200 OK\nDate: Thu, 27 Mar 2008 16:44:45 GMT\nServer: Apache/2.2.8 (Unix)\nETag: \"72c013-200b20-4496de6d7ae00\"\nAccept-Ranges: bytes\nContent-Length: 2100000\nLast-Modified: Thu, 27 Mar 2008 16:44:40 GMT\nConnection: close\nContent-Type: text/plain\n\n?tuX`i%DJ!X.....\n\n\nOn this occasion the second request gets handled first (it appears first in the access log) and is served the old 3300000-byte content from the cache, but with the timestamp of the new content.\nThe other 99 requests are served the correct new 2100000-byte content.", "id": 115049, "time": "2008-03-27T14:25:28Z", "bug_id": 44696, "creation_time": "2008-03-27T14:25:28Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 44696, "attachment_id": 22429, "id": 119703, "time": "2008-08-12T03:19:37Z", "creator": "rahul.g.nair@gmail.com", "creation_time": "2008-08-12T03:19:37Z", "is_private": false, "text": "Created attachment 22429\nPatch to store body before headers\n\nThe race condition happens when there are multiple http workers,\nAfter the first request detects that the cache has expired, it tries to update the cache in cache_save_filter.\nHere, the storing of the new data takes place in two steps, first the headers are stored, and then the body.\n\nIf a request comes to a second http worker when the headers are already written but the body is not, the second http-worker assumes that the cached body is valid (since the headers are valid). This causes the second worker to return the stale cache.\n\nThe fix is the switch the order of writing the cache so that body is written first. With this, if there is a second request before headers are stored, the second http-worker only assumes that the cache is stale and fetches it again,\nand overwrites the cache again."}, {"count": 2, "tags": [], "creator": "rpluem@apache.org", "attachment_id": null, "text": "The attached patch does not fix all cases:\n\n1. store_body is no atomic operation. The content of the entity may be split\n   across several brigades. So the race would be only fixed if the headers\n   would be stored *after* a brigade containing an EOS bucket was passed\n   to store_body. Keep in mind that store_body is called at 2 different positions\n   in the CACHE_SAVE filter: One is used during the first pass of the filter and\n   the other one is used during the following passes. But it is not guaranteed \n   that more than one pass ever happens (e.g. if the first brigade already \n   contains the EOS bucket).\n\n2. There is still a second race: Lets assume the entity is still fresh if a \n   request does not contain additional conditions. Now we have a request that\n   requests a fresh response e.g. via max-age=0. Even if the patch works as above\n   there is the possibility that a second client got the old headers decides\n   the entity is fresh enough for him and then tries to fetch the body which\n   is now the new one.", "id": 119707, "time": "2008-08-12T04:36:12Z", "bug_id": 44696, "creation_time": "2008-08-12T04:36:12Z", "is_private": false}, {"count": 3, "tags": [], "bug_id": 44696, "text": "Created attachment 22433\npatch to allow multiple passes\n\nThanks for pointing these out,\nfor the first one, I have modified the patch to look for APR_BUCKET_EOS before\ncommiting the headers. (at both points)\n\nI do not understand the second issue,\n\nif we have a fresh entitiy 1:head/url 1:body/url in our cache,\nand Request A comes in with max-age = 0,\nas it proceeds, the body gets written first, so we now have 1:head/url 2:body/url\n\nNow assuming that at this point Request B comes in, and reads the headers \n1:head/url but since it does not have max-age=0, it decides it can make do\nwith the current body, but the body is 2:body/url\n\nHowever, there is no harm in serving a newer response? we only have a problem\nwith serving stale content, and 2:body/url is not stale.", "id": 119742, "time": "2008-08-12T10:47:43Z", "creator": "rahul.g.nair@gmail.com", "creation_time": "2008-08-12T10:47:43Z", "is_private": false, "attachment_id": 22433}, {"count": 4, "tags": [], "creator": "rahul.g.nair@gmail.com", "attachment_id": 22434, "text": "Created attachment 22434\nbetter comments", "id": 119743, "time": "2008-08-12T10:52:13Z", "bug_id": 44696, "creation_time": "2008-08-12T10:52:13Z", "is_private": false}, {"count": 5, "tags": [], "bug_id": 44696, "text": "(In reply to comment #3)\n> Created an attachment (id=22433) [details]\n> patch to allow multiple passes\n> \n> Thanks for pointing these out,\n> for the first one, I have modified the patch to look for APR_BUCKET_EOS before\n> commiting the headers. (at both points)\n\nThanks for the patch. Some comments:\n\n1. I know that mod_disk_cache does the same, but I am a bit little worried that\n   there might be brigades that contain an EOS bucket which is *not* the last\n   bucket of the brigade. Yes this means we would need to iterate over\n   the whole brigade each time to find out if there is an EOS bucket in the\n   brigade or not. This increases effort and lowers performance.\n\n2. If you move \n\n   cache->info = info;\n\n   before the first \n\n   if (cache->stale_handle) {\n\n   you can merge both \n\n   if (cache->stale_handle) {\n\n   together in one block.\n\n> \n> I do not understand the second issue,\n> \n> if we have a fresh entitiy 1:head/url 1:body/url in our cache,\n> and Request A comes in with max-age = 0,\n> as it proceeds, the body gets written first, so we now have 1:head/url\n> 2:body/url\n> \n> Now assuming that at this point Request B comes in, and reads the headers \n> 1:head/url but since it does not have max-age=0, it decides it can make do\n> with the current body, but the body is 2:body/url\n> \n> However, there is no harm in serving a newer response? we only have a problem\n> with serving stale content, and 2:body/url is not stale.\n> \n\n2:body is not stale, but 1:headers and 2:body might not match together, e.g.\nregarding the Etag or Content-MD5 headers. Also Range requests could deliver\nfalse results in this case.\n\n", "id": 119752, "time": "2008-08-12T12:21:10Z", "creator": "rpluem@apache.org", "creation_time": "2008-08-12T12:21:10Z", "is_private": false, "attachment_id": null}, {"count": 6, "tags": [], "bug_id": 44696, "text": "Created attachment 22441\niterate over buckets in a brigade to find eos\n\nFor the second race condition, Using remove_url the first time in\ncache_store_content should work, but I am concerned that remove_url is not\nlight weight enough. (It deletes the headerfile, datafile and the directories\nif empty, while what I require is to just remove headers before the caching is\nstarted.)\n\nWhat would you suggest? Is there a better way? or would it be better to add a 'remove_headers' method to the cache provider interface?", "id": 119776, "time": "2008-08-13T06:01:10Z", "creator": "rahul.g.nair@gmail.com", "creation_time": "2008-08-13T06:01:10Z", "is_private": false, "attachment_id": 22441}, {"count": 7, "tags": [], "bug_id": 44696, "text": "(In reply to comment #6)\n> Created an attachment (id=22441) [details]\n> iterate over buckets in a brigade to find eos\n\nThanks.\n\n> \n> For the second race condition, Using remove_url the first time in\n> cache_store_content should work, but I am concerned that remove_url is not\n> light weight enough. (It deletes the headerfile, datafile and the directories\n> if empty, while what I require is to just remove headers before the caching is\n> started.)\n> \n> What would you suggest? Is there a better way? or would it be better to add a\n> 'remove_headers' method to the cache provider interface?\n> \n\nI guess I was partly wrong with this race condition. It is not that large as I anticipated first, because during opening the entity in open_entity where the headers are read the fd for the datafile is also opened.\nAs we do a move later on to move the new body from the temporary file to\nthe new datafile location this should not harm. The open fd still references\nto the old body datafile and the old body datafile should be gone after all fds to it should be closed.\nBut of course there is still a possibility that the body file switches when the old headers are read in open_entity and before opening the old datafile.\nI currently have no good idea how to avoid this race.\nCalling remove_url the first time in cache_store_content is IMHO a bad idea as this can have severe performance implication if the delivery of the new content takes a long time for whatever reason (slow client, slow backend). So this is no way to go.\n", "id": 119791, "time": "2008-08-13T08:52:23Z", "creator": "rpluem@apache.org", "creation_time": "2008-08-13T08:52:23Z", "is_private": false, "attachment_id": null}]