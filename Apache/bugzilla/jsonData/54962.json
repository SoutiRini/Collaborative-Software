[{"count": 0, "tags": [], "creator": "Richard_Fliam@cable.comcast.com", "attachment_id": null, "is_private": false, "id": 167184, "time": "2013-05-14T05:57:51Z", "bug_id": 54962, "creation_time": "2013-05-14T05:57:51Z", "text": "We have several files which are moved (renamed) on top of frequently (about every 2 seconds). \n\nA rename or move operation is atomic in the kernel, and thus should not cause issues. However, due to the nature of the way Apache serves these files it will periodically serve an incorrect Content-Length header and a truncated file or not enough bits.\n\nSteps to Reproduce:\nTake a file, perhaps randomly generated.\nMove (mv, or c rename()) a new one of differing size onto it with a relatively high frequency.\n\nCause:\nApache \"stats\" a file on receiving a request. It than opens a file descriptor for that file on line 4314 of core.c, and sets the content length header using `ap_set_content_length(r, r->finfo.size)` on 4328. This is the core of the problem, r->finfo.size is from a `stat()` that may not be the same inode.\n\nThe better (correct?) behavior is to use `fstat()` on the open file descriptor to set the Content-Length header as well as send size for sendfile etc. As file descriptors refer to an inode in most operating systems this prevents the underlying race on files which are being (atomically) updated.\n\nTo be clear this is not the same as having issues reading from a file that is being modified, the file is updated atomically and many other application (such as Python) handle this correctly."}]