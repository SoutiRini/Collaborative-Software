[{"count": 0, "tags": [], "text": "The following block:\n\n      synchronized (this) {\n        //\n        //   if a previous async task is still running\n        //}\n        if (lastRolloverAsyncAction != null) {\n          //\n          //  block until complete\n          //\n          lastRolloverAsyncAction.close();\n\n          //\n          //    or don't block and return to rollover later\n          //\n          //if (!lastRolloverAsyncAction.isComplete()) return false;\n        }\n\nfrom RolingFileAppender.java means that the next LoggingEvent which triggers a TriggerPolicy::isTriggeringEvent after the gzip compression has begun will cause all logging threads to block.\n\nThe:\n\n    if (lastRolloverAsyncAction != null) {\n\ncheck should not be performed until the NEXT rollover is called for.  That is after:\n\n    if (rollover != null) {", "attachment_id": null, "bug_id": 47575, "id": 129133, "time": "2009-07-24T14:54:52Z", "creator": "derek.libby@gmail.com", "creation_time": "2009-07-24T14:54:52Z", "is_private": false}, {"count": 1, "tags": [], "creator": "carnold@apache.org", "attachment_id": null, "id": 129461, "time": "2009-08-04T20:30:44Z", "bug_id": 47575, "creation_time": "2009-08-04T20:30:44Z", "is_private": false, "text": "FYI: This is regarding o.a.l.rolling.RFA in the extras companion,\n\nSeems like it should be very rare for the stock rolling policies to return null for rollover().  Moving the block for completion of async tasks until after if (rollover != null) would seem to insignificantly delay the blocking,\n\nThere is some commented out code indicating a developer considered failing the rollover instead of blocking.  That would seem to be a more desirable approach.  Maybe it could be configurable?\n\nWould appreciate knowing more about your situation and the benefit you saw from changing the location of the block."}, {"count": 2, "tags": [], "bug_id": 47575, "attachment_id": null, "text": "We had accumulated a large log file approximately 10GB in size.  Just using gzip on the (Linux) box in question required about 2 minutes to compress the file.  The rollover check happens then next time a logging event comes in and the check interval has been exceeded which for our purposes meant essentially the next time the check interval was exceeded (1000ms I believe).  All of our threads then blocked until the GZip operation was complete causing the system to stop responding for that interval.\n\nI didn't actually move the block in question, but the only time it makes sense to block on lastRolloverAsyncAction is when its value is about to change which will not be until the next log roll is required which was midnight in our application.", "id": 129462, "time": "2009-08-04T20:50:32Z", "creator": "derek.libby@gmail.com", "creation_time": "2009-08-04T20:50:32Z", "is_private": false}]