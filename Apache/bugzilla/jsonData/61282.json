[{"count": 0, "tags": [], "bug_id": 61282, "attachment_id": null, "id": 199725, "time": "2017-07-11T15:08:00Z", "creator": "94544458@qq.com", "creation_time": "2017-07-11T15:08:00Z", "is_private": false, "text": "the byte array\nbyte[] ab=new byte[4096];\nint len=is.read(ab,0,ab.length);\n\nAfter onDataAvailable returns to container, the content of ab is changed if len==4096, the content of ab is not changed if len!=4096.\n\n\nThe following is the java class I used to do the test. I issue is explained in the onComplete method.\n===========================\n\n\npackage zede.consult.webapp;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.StringWriter;\nimport java.nio.ByteBuffer;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.AsynchronousFileChannel;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.util.Iterator;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport javax.servlet.AsyncContext;\nimport javax.servlet.AsyncEvent;\nimport javax.servlet.ReadListener;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletInputStream;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport zede.util.Util;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport javax.json.Json;\nimport javax.json.stream.JsonGenerator;\nimport javax.servlet.AsyncListener;\n\npublic class BAtest extends HttpServlet {\n\n    static String dirUpload;\n    public static String dirTmp, dirTarget, dirTargetPost;\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n\n        StringWriter sw = new StringWriter();\n        try {\n            JsonGenerator g = Json.createGenerator(sw); //out\n            g.writeStartObject().write(\"idReq\", 0);\n            if (WebApp.writeReason(g, null)) { //no more information\n            }\n            g.writeEnd();\n            g.flush();\n        } catch (Throwable t) {\n            if (WebApp.debug) {\n                t.printStackTrace(WebApp.out);\n                WebApp.out.flush();\n            }\n            try {\n                sw = new StringWriter();\n                JsonGenerator g = Json.createGenerator(sw); //out\n                g.writeStartObject().write(\"idReq\", 0);\n                if (WebApp.writeReason(g, null)) { //no more information\n                }\n                g.writeEnd();\n                g.flush();\n            } catch (Throwable t2) {\n                return;\n            }\n        }\n        try {\n            WebApp.sendRes_json(sw.toString(), response);\n            //os.close(); we do not open it.\n            //PrintWriter out=response.getWriter();\n            //out.print(json);out.flush();\n        } catch (Throwable ex) {\n            //just swallow it //Logger.getLogger(BA.class.getName()).log(Level.SEVERE, null, ex);\n        }\n    }\n\n    @Override\n    protected void doPut(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        AsyncContext ac = request.startAsync();\n        ACHandler_Put h = new ACHandler_Put(ac, request, response);\n        ac.addListener(h);\n        ac.start(h);\n    }\n\n    class ACHandler_Put implements ReadListener, AsyncListener, Runnable {\n\n        ServletInputStream is;\n        int bytesReceived, bytesSaved; //this is different from ut.saved which is got from harddisk, this is instructed to save.\n        int saved, size; //int for length is more than enough.\n        ConcurrentLinkedQueue<DataPiece> q2save = new ConcurrentLinkedQueue<>();\n        public final AsyncContext ac;\n        public final HttpServletRequest request;\n        public final HttpServletResponse response;\n        public int idReq;\n        public Ex_Coded4Web exweb;\n\n        public ACHandler_Put(AsyncContext ac, HttpServletRequest request, HttpServletResponse response) {\n            this.ac = ac;\n            this.request = request;\n            this.response = response;\n        }\n\n        @Override\n        public void run() {\n            try {\n                String slength = request.getHeader(\"Content-Length\");\n                if (slength == null) {\n                    //in this case, because the fault of the client's agent, we should reject it,\n                    //but since we are nice, so we accept it, but the length is the length specified in the UpLoadTask\n                } else {\n                    try {\n                        size = Integer.parseInt(slength);\n                    } catch (Throwable t) {\n                        throw new Ex_Coded4Web(WebApp.Reason_ContentLengthParseFailed, \"Content_Length:\" + slength + \" can not be converted into int\");\n                    }\n                }\n                startRead();\n                return; //we do not call complete at this time point\n            } catch (Ex_Coded4Web e) {\n                exweb = e;\n            } catch (Throwable t) {\n                t.printStackTrace();\n                exweb = new Ex_Coded4Web(WebApp.Reason_UncaughtException, t.getMessage());\n            }\n            complete();\n        }\n\n        void startRead() {\n            File f = new File(\"stream.out\");\n//            System.out.println(f.getAbsolutePath());\n//tomcat home or catalina home\n            f = new File(\"/home/jack/Pictures/stream.out\");\n            try {\n                fos = new FileOutputStream(f);\n            } catch (FileNotFoundException ex) {\n            }\n\n            bytesReceived = bytesSaved = saved;\n            try {\n                is = request.getInputStream();\n//System.out.println(is.getClass().getName());\n//org.apache.catalina.connector.CoyoteInputStream\n            } catch (IOException ex) {\n                exweb = new Ex_Coded4Web(WebApp.Reason_FailedOnReceiving, \"unable get uploading stream:\" + ex.getMessage());\n                complete();\n                return;\n            }\n            //is=java.util.Base64.getDecoder().wrap(is);\n            is.setReadListener(ACHandler_Put.this);\n        }\n\n        @Override\n        public void onDataAvailable() {\n            {\n                int len; //we have to check the bytes saved incase someone attack us.\n                byte[] ab = null;//q4096.poll();\n                if (ab == null) {\n                    ab = new byte[4096];\n                }\n                String msg;\n                while (true) {\n                    try {\n                        if (!is.isReady()) { //this can throw the same EOFException as read.\n                            break;\n                        }\n                        len = is.read(ab, 0, ab.length);\n                    } catch (IOException ex) { //read exception\n                        //this happens usually as a result of user refresh the webpage before uploading completes.\n                        ex.printStackTrace();\n                        msg = \"isread/read:\" + ex.getMessage();\n                        exweb = new Ex_Coded4Web(WebApp.Reason_FailedOnReceiving, msg);\n                        complete();\n                        return;\n                    }\n                    if (-1 == len) {\n                        //this will not happen, or I did not see it happen\n                        //onAllDataRead will be called.\n                        //if this happens, then this should have the same effect as onAllDataRead()\n                        if (WebApp.debug) {\n                            System.out.println(\"put len=-1\");\n\n                        }\n                        return;\n                    }\n//                if(len==0){ //will never happen, otherwise isready is useless\n//                    break;\n//                }\n                    DataPiece dp = new DataPiece(ab, bytesReceived, len); //new DataPiece(ByteBuffer.wrap(ab, 0, len), bytesReceived);\n                    bytesReceived += len;\n                    if (bytesReceived > size) {\n                        msg = \"size \" + bytesReceived + \" is exceeding the inited length:\" + size;\n                        System.out.println(msg);\n                        exweb = new Ex_Coded4Web(WebApp.Reason_SizeExceedDeclaredLength, msg);\n                        try {\n                            is.close();\n                        } catch (Throwable t) { //exweb !=null, so just swallow\n                        }\n                        complete();\n                        return;\n                    }\n                    //System.out.println(\"read data +\" + len + \"=\" + bytesReceived + \"/\" + ut.size + \" saved:\" + bytesSaved);\n                    //I would do this in asynchronous mode, but to show the data is correctly received,\n                    //so we save it with an outputstream, and we can compre the save file and original file\n                    //they are same.\n                    if (fos != null) {\n                        try {\n                            fos.write(ab, 0, len);\n                        } catch (IOException ex) {\n                        }\n                    }\n                    q2save.offer(dp);\n                }\n            }\n        }\n        FileOutputStream fos;\n        MappedByteBuffer bb = null;\n        byte[] bbO;\n        int offset;\n\n        /**\n         * In the current servlet specification, I do not know whether read\n         * returns -1 will happen or not. Since this notification should has the\n         * same effect as read returns -1.\n         *\n         */\n        @Override\n        public void onAllDataRead() {\n            if (WebApp.debug) {\n                System.out.println(\"BA.put onAllDataRead, bytesReceived:\" + bytesReceived + \", size:\" + size);\n            }\n            try {\n                //save();\n                if (bytesReceived < size) {\n                    exweb = new Ex_Coded4Web(WebApp.Reason_SizeLessThanDeclaredLength, \"size \" + bytesReceived + \" is less than the inited length:\" + size);\n                }\n            } catch (Throwable t) {\n                if (WebApp.debug) {\n                    t.printStackTrace();\n\n                }\n            }\n            if (fos != null) {\n                try {\n                    fos.flush();\n                    fos.close();\n                } catch (IOException ex) {\n                }\n            }\n            complete();\n        }\n\n        //of reading from network\n        @Override\n        public void onError(Throwable t) {\n            try {\n                //one case, when uploading is not finished, browser crashed, or refreshed, so the uploading is canceled.\n                System.out.println(\"onError when receiving data from network\");\n                t.printStackTrace();\n\n                exweb = new Ex_Coded4Web(WebApp.Reason_FailedOnReceiving, \"onError when receiving:\" + t.getMessage());\n                //we do not flush here, since q2save might not be empty yet\n                //we just call save instead\n                complete(); //but why onComplete is not called as expected??\n            } catch (Throwable t2) {\n                System.out.println(\"unexpected inside onError\");\n                t2.printStackTrace();\n\n            }\n        }\n\n        //servlet asyncContext complete, onError will also call this?\n        /**\n         * we have two copies of received data: DataPiece.ab and DataPiece.ab2,\n         * we compare them, and we compare them to the original data.\n         * \n         * we can find that the copy returned by ServletInputStream.read is changed\n         * for the len=4096, if the len is not 4096, they are not changed.\n         * \n         * \n         * @param event \n         */\n        @Override\n        public void onComplete(AsyncEvent event) {\n            try { //this is the original file\n                File f = new File(\"/home/jack/Pictures/a.pdf\");\n                FileChannel fc = new FileInputStream(f).getChannel();\n                bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, f.length());\n                /*\n                if (bb.hasArray()) {\n                    System.out.println(\"hasArray:yes!\");\n                    bbO = bb.array();\n                    offset = bb.arrayOffset();\n                } else {\n                    System.out.println(\"hasArray:No!\");\n                }\n                */\n            } catch (IOException ex) {\n                ex.printStackTrace();\n            }\n            Iterator<DataPiece> I = q2save.iterator();\n            while (I.hasNext()) {\n                DataPiece dp = I.next();\n                bb.position(dp.offset);\n                ByteBuffer bb1 = ByteBuffer.wrap(dp.ab, 0, dp.len); //or dp.ab2\n                boolean e1 = Util.equals(bb1, bb);\n                String msg = \"bytesSaved:\" + bytesSaved + \"+\" + dp.len + \" bb1:\" + e1;\n                bb.position(dp.offset);\n                ByteBuffer bb2 = ByteBuffer.wrap(dp.ab2, 0, dp.len); //or dp.ab\n                msg += \" bb2:\" + Util.equals(bb2, bb) + \" ab:ab2\" + Util.equals(dp.ab, 0, dp.len, dp.ab2, 0);\n                System.out.println(msg);\n/*\n * \nI got 9 of bb1:true and 242 bb1:false,\n     251 of bb2:true and 0 bb2:false\n     9 of ab:ab2true and 242 ab:ab2false\n *   if I change the bb1 & bb2, then the result reversed.\n */                \n            }\n        }\n\n        @Override\n        public void onTimeout(AsyncEvent event) throws IOException {\n        }\n\n        @Override\n        public void onError(AsyncEvent event) throws IOException {\n        }\n\n        @Override\n        public void onStartAsync(AsyncEvent event) throws IOException {\n        }\n\n        protected void complete() {\n            StringWriter sw = new StringWriter();\n            try {\n                JsonGenerator g = Json.createGenerator(sw); //out\n                g.writeStartObject().write(\"idReq\", idReq);\n                if (WebApp.writeReason(g, exweb)) { //no more information\n                }\n                g.writeEnd();\n                g.flush();\n            } catch (Throwable t) {\n                try {\n                    sw = new StringWriter();\n                    JsonGenerator g = Json.createGenerator(sw); //out\n                    g.writeStartObject().write(\"idReq\", idReq);\n                    if (WebApp.writeReason(g, exweb)) { //no more information\n                    }\n                    g.writeEnd();\n                    g.flush();\n                } catch (Throwable t2) {\n                    return;\n                }\n            }\n            try {\n                WebApp.sendRes_json(sw.toString(), response);\n                //os.close(); we do not open it.\n                //PrintWriter out=response.getWriter();\n                //out.print(json);out.flush();\n            } catch (Throwable ex) {\n                //just swallow it //Logger.getLogger(BA.class.getName()).log(Level.SEVERE, null, ex);\n            }\n            ac.complete();\n        }\n\n    }\n\n    static class DataPiece {\n\n        //ByteBuffer bb;\n        int offset, len;\n        byte[] ab, ab2;\n\n        DataPiece(byte[] ab, int offset, int len) {\n            this.ab = ab;\n            this.offset = offset;\n            this.len = len;\n            ab2 = new byte[len];\n            System.arraycopy(ab, 0, ab2, 0, len);\n            //bb = ByteBuffer.wrap(ab2, 0, len);\n        }\n    }\n}"}, {"count": 1, "tags": [], "bug_id": 61282, "attachment_id": null, "id": 199729, "time": "2017-07-11T17:47:22Z", "creator": "violetagg@apache.org", "creation_time": "2017-07-11T17:47:22Z", "is_private": false, "text": "Hi,\n\nWhat is the problem that you think there is?\n\n\nRegards,\nVioleta"}, {"count": 2, "tags": [], "bug_id": 61282, "attachment_id": null, "text": "(In reply to Violeta Georgieva from comment #1)\n> What is the problem that you think there is?\nI am sorry, let me state it one more time, I hope I can make it clear this time.\n\nservlet specification support nio, so when a user upload a file to server, at the server side, a servlet does not have to use the inputstream=request.getInputStream() to read the data. Instead, we set a readListener to the inputstream, when data is available, we got notified onDataAvailable(). This is good.\n\nThe problem is that inside onDataAvailable, we read data\nbyte[] ab=new byte[4096];\nint len=is.read(ab,0,ab.length);\n\nwe have to use ab inside onDataAvailable method, once this method returns, the content of ab will be changed for no reason! This is very weird, and should not happen unless the specification indicates the data is only valid inside onDataAvailable method. \n\nso what I do to get around it is to copy the data.\nbyte[] ab2=new byte[len];\nSystem.arraycopy(ab,0,ab2,0,len);\n\nthen the content of ab2 is reliable, even after long time, the content of ab2 is not changed.\n\n\nDid I succeed in explaining this? Let me know if you have any doubt.", "id": 199731, "time": "2017-07-12T05:27:40Z", "creator": "94544458@qq.com", "creation_time": "2017-07-12T05:27:40Z", "is_private": false}, {"count": 3, "tags": [], "bug_id": 61282, "attachment_id": null, "id": 199733, "time": "2017-07-12T07:42:03Z", "creator": "violetagg@apache.org", "creation_time": "2017-07-12T07:42:03Z", "is_private": false, "text": "Hi,\n\n(In reply to Jack from comment #2)\n> (In reply to Violeta Georgieva from comment #1)\n> > What is the problem that you think there is?\n> I am sorry, let me state it one more time, I hope I can make it clear this\n> time.\n> \n> servlet specification support nio, so when a user upload a file to server,\n> at the server side, a servlet does not have to use the\n> inputstream=request.getInputStream() to read the data. Instead, we set a\n> readListener to the inputstream, when data is available, we got notified\n> onDataAvailable(). This is good.\n> \n> The problem is that inside onDataAvailable, we read data\n> byte[] ab=new byte[4096];\n> int len=is.read(ab,0,ab.length);\n>\n\nHow many times the onDataAvailable is invoked in your scenario?\n\n> \n> we have to use ab inside onDataAvailable method, once this method returns,\n> the content of ab will be changed for no reason! This is very weird, and\n> should not happen unless the specification indicates the data is only valid\n> inside onDataAvailable method. \n\nThe container does not have reference to the array that is provided with the read method. However as this is a non blocking read you may expect the following to happen:\n\n- onDataAvailable is invoked by the container as there is data available for reading\n- The code enters in while block, isReady returns true and the code reads the available data\n- on the next iteration isReady returns false and the code exits onDataAvailable method\n- when there is again data available for reading the container will invoke again onDataAvailable\n- on this invocation the code will use the same byte array for reading, so the data in the byte array will be replaced with the new data\n\nAt some point the container will invoke onAllDataRead method in order to indicate that there is no more data for reading. At that point the byte array \"ab\" will contain the data from the last reading.\n\n> \n> so what I do to get around it is to copy the data.\n> byte[] ab2=new byte[len];\n> System.arraycopy(ab,0,ab2,0,len);\n> \n> then the content of ab2 is reliable, even after long time, the content of\n> ab2 is not changed.\n> \n> \n> Did I succeed in explaining this? Let me know if you have any doubt.\n\nRegards,\nVioleta"}, {"count": 4, "tags": [], "creator": "94544458@qq.com", "attachment_id": null, "id": 199734, "time": "2017-07-12T08:05:20Z", "bug_id": 61282, "creation_time": "2017-07-12T08:05:20Z", "is_private": false, "text": "I am very sorry, the byte array is allocated outside while, so it was my mistake! There is no bug here, please close this thread! \n\nVioleta, thank you for your time!"}]