[{"count": 0, "tags": [], "bug_id": 61736, "attachment_id": 35508, "text": "Created attachment 35508\nAn Http Client which is able to send data in controlled packet size and packet interval.\n\nWhen using tomcat in NIO mode as a server to receive files, and if the files are transferred via a non-stable network (there is an obvious interval between neighbor TCP packets), then the traffic always hang for a great while with zero window reported from server. Following are the steps to reproduce the problem.\n\n1. Configure the server tcp receive window size.\n$ cat /proc/sys/net/ipv4/tcp_rmem\n1024\t2048\t8192\n\n2. Put the following JSP into the ROOT project. (in the path $CATALINA_HOME/webapps/ROOT/consume.jsp)\n<%@ page import=\"org.apache.commons.io.IOUtils\" %><%\n    final ServletInputStream inputStream = request.getInputStream();\n    byte[] content = IOUtils.toByteArray(inputStream);\n%>ok\nThe IOUtils is a class from commons-io\n\n3. Start tomcat in NIO mode with the following settings\nServer version:        Apache Tomcat/8.0.46\nServer built:          Aug 10 2017 10:10:31 UTC\nServer number:         8.0.46.0\nOS Name:               Linux\nOS Version:            3.10.0-229.el7.x86_64\nArchitecture:          amd64\nJava Home:             /usr/jdk1.8.0_121/jre\nJVM Version:           1.8.0_121-b13\nJVM Vendor:            Oracle Corporation\nCommand line argument: -Xms256m\nCommand line argument: -Xmx256m\nCommand line argument: -Xmn128m\nCommand line argument: -Xss1m\n\n4. Capture the TCP traffics.\ntcpdump -i any -w tcp.cap port 8080\n\n5. Start a client. sending data with http in chunks with the following settings:\nchunk size                   1024 byte\ntime to rest between chunks  50 ms\nchunk count per request      100\nparallel requests            100\ntotal requests               10000\n\n6. Then we will got a lot of zero window packets, which lasts several seconds.\nNo.     stream     Time               Source              Destination         ack        win        Length Info\n 469817 3201       15:09:04.175309    172.16.1.4          172.16.1.5          1          29696      57     [TCP segment of a reassembled PDU]\n 469904 3201       15:09:04.214945    172.16.1.5          172.16.1.4          4238       1024       54     8080\u219258750 [ACK] Seq=1 Ack=4238 Win=1024 Len=0\n 470091 3201       15:09:04.437137    172.16.1.4          172.16.1.5          1          29696      1078   [TCP Window Full] [TCP segment of a reassembled PDU]\n 470092 3201       15:09:04.437142    172.16.1.5          172.16.1.4          5262       0          54     [TCP ZeroWindow] 8080\u219258750 [ACK] Seq=1 Ack=5262 Win=0 Len=0\n 470334 3201       15:09:04.657120    172.16.1.4          172.16.1.5          1          29696      54     [TCP Keep-Alive] 58750\u21928080 [ACK] Seq=5261 Ack=1 Win=29696 Len=0\n 470335 3201       15:09:04.657123    172.16.1.5          172.16.1.4          5262       0          54     [TCP ZeroWindow] 8080\u219258750 [ACK] Seq=1 Ack=5262 Win=0 Len=0\n 470620 3201       15:09:05.098135    172.16.1.4          172.16.1.5          1          29696      54     [TCP Keep-Alive] 58750\u21928080 [ACK] Seq=5261 Ack=1 Win=29696 Len=0\n 470621 3201       15:09:05.098141    172.16.1.5          172.16.1.4          5262       0          54     [TCP ZeroWindow] 8080\u219258750 [ACK] Seq=1 Ack=5262 Win=0 Len=0\n 471017 3201       15:09:05.979136    172.16.1.4          172.16.1.5          1          29696      54     [TCP Keep-Alive] 58750\u21928080 [ACK] Seq=5261 Ack=1 Win=29696 Len=0\n 471018 3201       15:09:05.979140    172.16.1.5          172.16.1.4          5262       0          54     [TCP ZeroWindow] 8080\u219258750 [ACK] Seq=1 Ack=5262 Win=0 Len=0\n 471619 3201       15:09:07.743148    172.16.1.4          172.16.1.5          1          29696      54     [TCP Keep-Alive] 58750\u21928080 [ACK] Seq=5261 Ack=1 Win=29696 Len=0\n 471620 3201       15:09:07.743151    172.16.1.5          172.16.1.4          5262       0          54     [TCP ZeroWindow] 8080\u219258750 [ACK] Seq=1 Ack=5262 Win=0 Len=0\n 475765 3201       15:09:08.545625    172.16.1.5          172.16.1.4          5262       3072       54     [TCP Window Update] 8080\u219258750 [ACK] Seq=1 Ack=5262 Win=3072 Len=0\n 475781 3201       15:09:08.545815    172.16.1.4          172.16.1.5          1          29696      490    [TCP segment of a reassembled PDU]\n 475782 3201       15:09:08.545821    172.16.1.5          172.16.1.4          5698       3072       54     8080\u219258750 [ACK] Seq=1 Ack=5698 Win=3072 Len=0\n 475784 3201       15:09:08.545825    172.16.1.4          172.16.1.5          1          29696      1514   [TCP segment of a reassembled PDU]\n\n\nAfter a lot of study, I found this is because of a BUG in the BlockPoller, which will slow down the speed of polling cycle a lot.\n\nThe BlockPoller will always try to poll the Runnable event and run it until the events queue is empty. But the RunnableAdd event may wake the Worker thread, and the worker thread may add another more event to the queue. Thus the queue will be hard to shrink, and the events method will be hard to return and will affect the latency the next selection to be performed.\n\n// events() method of the BlockPoller thread\npublic boolean events() {\n    boolean result = false;\n    Runnable r = null;\n    result = (events.size() > 0);\n    while ( (r = events.poll()) != null ) {\n        // running the \"r\" event may cause more events to \n        // be added to the queue. then the queue will be hard \n        // to shrink, and the loop may be hard to finish\n        r.run();\n        result = true;\n    }\n    return result;\n}\n\n// the following e1 and e2 line in the RunnableAdd will wake the worker thread\npublic void run() {\n    SelectionKey sk = ch.keyFor(selector);\n    try {\n        if (sk == null) {\n            sk = ch.register(selector, ops, key);\n            ref.key = sk;\n        } else if (!sk.isValid()) {\n            cancel(sk, key, ops); // <-- e1\n        } else {\n            sk.interestOps(sk.interestOps() | ops);\n        }\n    } catch (CancelledKeyException cx) {\n        cancel(sk, key, ops); // <-- e2\n    } catch (ClosedChannelException cx) {\n        cancel(null, key, ops);\n    }\n}\n\n// when the worker is waken at line L3, it will start the next loop\n// and may add another event at line L2\npublic int read(ByteBuffer buf, NioChannel socket, long readTimeout) throws IOException {\n    SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());\n    if ( key == null ) throw new IOException(\"Key no longer registered\");\n    KeyReference reference = keyReferenceStack.pop();\n    if (reference == null) {\n        reference = new KeyReference();\n    }\n    NioSocketWrapper att = (NioSocketWrapper) key.attachment();\n    int read = 0;\n    boolean timedout = false;\n    int keycount = 1; \n    long time = System.currentTimeMillis(); \n    try {\nL1:     while(!timedout) {\n            if (keycount > 0) {\n                read = socket.read(buf);\n                if (read != 0) {\n                    break;\n                }\n            }\n            try {\n                if ( att.getReadLatch()==null || att.getReadLatch().getCount()==0) att.startReadLatch(1);\nL2:             poller.add(att,SelectionKey.OP_READ, reference);\n                if (readTimeout < 0) {\n                    att.awaitReadLatch(Long.MAX_VALUE, TimeUnit.MILLISECONDS);\n                } else {\nL3:                 att.awaitReadLatch(readTimeout, TimeUnit.MILLISECONDS);\n                }\n            } catch (InterruptedException ignore) {\n                // Ignore\n            }\n            if ( att.getReadLatch()!=null && att.getReadLatch().getCount()> 0) {\n                keycount = 0;\n            }else {\n                keycount = 1;\n                att.resetReadLatch();\n            }\n            if (readTimeout >= 0 && (keycount == 0))\n                timedout = (System.currentTimeMillis() - time) >= readTimeout;\n        } //while\n        if (timedout)\n            throw new SocketTimeoutException();\n    } finally {\n        poller.remove(att,SelectionKey.OP_READ);\n        if (timedout && reference.key!=null) {\n            poller.cancelKey(reference.key);\n        }\n        reference.key = null;\n        keyReferenceStack.push(reference);\n    }\n    return read;\n}\n\nIn fact there is such an occasion where the previous case will happen:\n\n 1. [Worker]: added an event, and wait on the readLatch\n 2. [BlockPoller]: registered operation interest on corresponding SelectionKey\n 3. [BlockPoller]: perform selection\n 4. [BlockPoller]: wake the Worker on the selection result\n 5. [Worker]: wake up, read data success\n 6. [Worker]: add remove event (e1) to the queue, and return from the read method\n 7. [Worker]: Outside call the read method again\n 8. [Worker]: read data and got nothing\n 9. [Worker]: add an event (e2) via the poller.add(att, ops, ref) method\n10. [Worker]: wait on the readLatch\n11. [BlockPoller]: enter next loop, and execute the events() method, polling events from the events queue and run them.\n12. [BlockPoller]: got e1 and run it, the SelectionKey turn invalid (before next selection, the SelectionKey is always invalid)\n13. [BlockPoller]: got e2 and run it, since the SelectionKey is invalid, it will wake the worker thread, and discard the event.\n14. [BlockPoller]: poll other events from the queue, and run them\n15. [Worker]: (before queue empty) waken up, and read again, but got nothing\n16. [Worker]: add another event (e3) via the poller.add(att, ops, ref) method\n17. [Worker]: wait on the readLatch again\n18. [BlockPoller]: got e3 and run it, found it invalid again, wake the worker thread, and discard the event.\n19. [Worker]: being waken up again and add event again...\n\n\nsteps between 11 to 17 will repeat again and again (step 18 and later is a replay of the steps), if each time the event add in step 16 add the event to the queue before the queue is consumed to empty, because the BlockPoller will always try to empty the queue. \n\nThen the BlockPoller and the worker will enter a strange loop, where the BlockPoller will try to empty the queue, while the worker will always add some more events to the queue.\n\nMy solution to prevent this problem, is to prevent the BlockPoller from trying to empty the queue before move to the selection step, instead, make it only handle events in the queue when it starts to handle them, further events added later will not be handled during this BlockPoller loop, but instead delay to the next loop. The selection operation will remove all invalid SelectionKeys, so in the time of the next loop, the problem will not happen again, since the SelectionKeys are all fresh and valid.", "id": 201986, "time": "2017-11-08T12:21:28Z", "creator": "szlon@qq.com", "creation_time": "2017-11-08T12:21:28Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 61736, "text": "See https://github.com/apache/tomcat/pull/81 for a proposed patch.", "id": 201992, "attachment_id": null, "creator": "markt@apache.org", "creation_time": "2017-11-08T14:59:39Z", "time": "2017-11-08T14:59:39Z", "is_private": false}, {"attachment_id": null, "tags": [], "bug_id": 61736, "text": "Thanks for the detailed report. To have such a complicated issue explained so clearly - and with a patch! - is extremely helpful.\n\nI can see how the problem happens and I can also see how your proposed patch addresses it. I'm not concerned about delaying new events to the next loop.\n\nThe events queue is a custom implementation so I want to look to see if that makes an alternative fix possible but I haven't found anything so far (and probably won't).", "count": 2, "id": 201993, "time": "2017-11-08T15:48:47Z", "creator": "markt@apache.org", "creation_time": "2017-11-08T15:48:47Z", "is_private": false}, {"attachment_id": null, "tags": [], "bug_id": 61736, "text": "Yes, the queue is custom implemented, but it still works following the rule of a non-blocking queue. I'm afraid that the problem is not caused by how the queue works, but how we use a queue. \n\nPerhaps a more basic reason for this problem is that, the cancelled keys are still cached. A cancelled key is invalid and cannot be used again, so it should not be cached. If invalid keys are not cached, or they can recover from the invalid state, we may not wake the Worker thread up when handling events, so it's possible to avoid this problem. \n\nHowever how the SelectionKey will behave is controlled in the JDK, out of our control. I didn't find anyway other than performing a selection that can clear the invalid SelectionKey caches. So I think maybe the most effective action to take is to prevent the BlockPoller to cost too much time in the loop polling and handling events, and let the next selection to clear the invalid SelectionKeys as soon as possible.", "count": 3, "id": 202081, "time": "2017-11-12T08:44:25Z", "creator": "szlon@qq.com", "creation_time": "2017-11-12T08:44:25Z", "is_private": false}, {"count": 4, "tags": [], "bug_id": 61736, "attachment_id": null, "text": "My point was not that the queue was the root cause. My point was that because the queue implementation is a custom one it *might* offer a cleaner way to implement the polling of the queue rather than getting the current size and then requesting exactly that many items from the queue.", "id": 202173, "time": "2017-11-16T12:34:17Z", "creator": "markt@apache.org", "creation_time": "2017-11-16T12:34:17Z", "is_private": false}, {"count": 5, "tags": [], "creator": "markt@apache.org", "is_private": false, "id": 202175, "attachment_id": null, "bug_id": 61736, "creation_time": "2017-11-16T13:36:58Z", "time": "2017-11-16T13:36:58Z", "text": "There didn't seem to be any benefit to implementing the limit in the queue rather than getting the size and looping so I went with the patch as proposed.\n\nFixed in:\n- trunk for 9.0.2 onwards\n- 8.5.x for 8.5.24 onwards\n- 8.0.x for 8.0.48 onwardse\n- 7.0.x for 7.0.83 onwards\n\nThanks again for the analysis and the patch."}]