[{"count": 0, "tags": [], "bug_id": 51612, "text": "Created attachment 27347\nSimple code demonstrating the bug\n\nLog4j version: 1.2.16\n\nI have an appender attached to a logger. This appender performs the LoggingEvent processing in a thread other than the thread where the LoggingEvents were generated. Due to that fact that LoggingEvent.threadName is lazily initialized (under certain conditions: there are different constructors and I don't know which one is used when) I'm getting a wrong thread name in the LoggingEvent.\n\nProbably the LoggingEvent.threadName should not be lazily initialized.\n\nIn attachment there is a simple code demonstrating the bug.\n\nIn addition please pay attention that LoggingEvent class is not thread-safe: access to LoggingEvent.threadName is not synchronized. So if in the example above I have several appenders processing LoggingEvents in different threads the actual thread name visible to appenders is unpredictable.", "id": 148375, "time": "2011-08-04T09:03:15Z", "creator": "r_gorbonosov@mail.ru", "creation_time": "2011-08-04T09:03:15Z", "is_private": false, "attachment_id": 27347}, {"count": 1, "tags": [], "creator": "carnold@apache.org", "attachment_id": null, "id": 148471, "time": "2011-08-08T03:18:17Z", "bug_id": 51612, "creation_time": "2011-08-08T03:18:17Z", "is_private": false, "text": "The code is behaving as designed, though it was designed for a far earlier era.  Designing for concurrency is one of the prime motivations for the log4j 2 effort.  Improving concurrency in log4j 1.x is a minefield with ample opportunity for unintended consequences.\n\nThere are (at least were) substantial performance benefits to avoid copying thread state information into the logging event.  The following fragment of AsyncAppender shows how it forces the retrieval of state information so that the logging event has a fixed state before it is made visible to other threads.\n\n\n\n    event.getNDC();\n    event.getThreadName();\n    // Get a copy of this thread's MDC.\n    event.getMDCCopy();\n    if (locationInfo) {\n      event.getLocationInformation();\n    }\n    event.getRenderedMessage();\n    event.getThrowableStrRep();"}, {"count": 2, "tags": [], "text": "Thanks for the answer, Curt.\n\nJust to make sure the solution which is used in AsyncAppender is bullet-proof.\nAs I mentioned, LoggingEvent.threadName is not volatile and access to it is not synchronized. So, where is the guarantee that after being initialized in one thread (with event.getThreadName()) it is visible to other threads as well (dispatcher in case of AsyncAppender)?\nDoes the guarantee come from the piggybacking on synchronization on buffer?", "is_private": false, "bug_id": 51612, "id": 148566, "time": "2011-08-11T14:48:21Z", "creator": "r_gorbonosov@mail.ru", "creation_time": "2011-08-11T14:48:21Z", "attachment_id": null}]