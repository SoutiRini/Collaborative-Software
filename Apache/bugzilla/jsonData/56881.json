[{"count": 0, "tags": [], "creator": "covener@gmail.com", "attachment_id": null, "id": 177318, "time": "2014-08-22T14:46:46Z", "bug_id": 56881, "creation_time": "2014-08-22T14:46:46Z", "is_private": false, "text": "I am seeing that even though this snippet below unsets the conditional headers, something about r->status being 304 at the start of the internal redirect causes the 304 to be returned\n\nI set r->status to 333 as a stupid test right after unsetting conditionals and could see the 333 being traced as a response code in the same path -- so the 304 is not due to the r->headers_in but some lingering r->status.\n\n\n    if (reason && r->status == HTTP_NOT_MODIFIED && cache->stale_handle) {\n\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02473)\n                \"cache: %s responded with an uncacheable 304, \"\n                \"retrying the request. Reason: %s\",\n                r->unparsed_uri, reason);\n\n        /* we've got a cache conditional miss! tell anyone who cares */\n        cache_run_cache_status(cache->handle, r, r->headers_out, AP_CACHE_MISS,\n                apr_psprintf(r->pool,\n                        \"conditional cache miss: 304 was uncacheable, entity removed: %s\",\n                        reason));\n\n        /* remove the cached entity immediately, we might cache it again */\n        ap_remove_output_filter(cache->remove_url_filter);\n        cache_remove_url(cache, r);\n\n        /* let someone else attempt to cache */\n        cache_remove_lock(conf, cache, r, NULL);\n\n        /* remove this filter from the chain */\n        ap_remove_output_filter(f);\n\n        /* retry without the conditionals */\n        apr_table_unset(r->headers_in, \"If-Match\");\n        apr_table_unset(r->headers_in, \"If-Modified-Since\");\n        apr_table_unset(r->headers_in, \"If-None-Match\");\n        apr_table_unset(r->headers_in, \"If-Range\");\n        apr_table_unset(r->headers_in, \"If-Unmodified-Since\");\n\n        ap_internal_redirect(r->unparsed_uri, r);\n\n        return APR_SUCCESS;"}, {"count": 1, "tags": [], "text": "FWIW: In my case the contradiction is intersting too.  \n\nI am caching a recently created static file that gets a weak etag at startup, then when it expires, httpd generates the same etag but without the W/ prefix.", "is_private": false, "bug_id": 56881, "id": 177319, "time": "2014-08-22T14:49:41Z", "creator": "covener@gmail.com", "creation_time": "2014-08-22T14:49:41Z", "attachment_id": null}, {"count": 2, "tags": [], "text": "Created attachment 31937\nloglevel trace8\n\ndebug + a little added trace of the client that gets a 304 to unconditional request.  Before the expiration, the static file got a weak etag, and now it does not have the weak prefix (not traced but clear from logs)", "is_private": false, "id": 177320, "creation_time": "2014-08-22T14:58:55Z", "time": "2014-08-22T14:58:55Z", "creator": "covener@gmail.com", "bug_id": 56881, "attachment_id": 31937}, {"count": 3, "tags": [], "creator": "covener@gmail.com", "attachment_id": null, "id": 177321, "time": "2014-08-22T15:16:53Z", "bug_id": 56881, "creation_time": "2014-08-22T15:16:53Z", "is_private": false, "text": "It looks like r->status = HTTP_OK before the internal redirect does the trick.\n\nI confirmed the internal redirect could actually return different contents then the state cache thing, and even non-success after this, although I still can't see who short-circuits over r->status != HTTP_OK."}, {"count": 4, "tags": [], "bug_id": 56881, "attachment_id": null, "text": "Fixed in 2.4.11 with r1627745.", "id": 180521, "time": "2015-01-23T10:15:17Z", "creator": "ylavic.dev@gmail.com", "creation_time": "2015-01-23T10:15:17Z", "is_private": false}]