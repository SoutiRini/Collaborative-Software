[{"count": 0, "attachment_id": null, "bug_id": 32638, "is_private": false, "id": 68244, "time": "2004-12-10T17:01:11Z", "creator": "ddevienne@lgc.com", "creation_time": "2004-12-10T17:01:11Z", "tags": [], "text": "From the email 'About <macrodef> in the trenches' I sent out today:\n\nThis past two weeks, I've worked on coming up with a generic build file\nfor our multiple projects, which I'd say are 80% to 99% common from one\nproject to the next. Of course, I'm using heavily <import>, target\noverriding, and <macrodef>, but even with these fine features, it's not\nalways easy to accomodate the variations from one build to the next, \nespecially if I want to avoid having to rewrite whole tasks/targets.\n\nTo achieve this maximum reuse, and minimum overriding, i.e. to avoid being\nforced to rewrite whole tasks, I've defined complex macros with built-in\nconditionals, and lots of default attributes. Alas, there's no default\n'value' for macro elements, so providing default tags for a macro element\nis currently not possible. I believe this lack of element default makes\n<macrodef> less powerful that it can be. \n\nSo finally today I had a look at the macrodef code, and tried to understand\nhow things worked under the hood. I was surprised to find out I understood\nthe code ;-) (if I glossed over most of the UE/RC cuisine that is).\n\n  BTW, I'm amazed this can all be implemented in a couple of tasks with no\n  changes to the framework itself. The new fully dynamic nature of Ant 1.6\n  (everything's a UE) is powerful indeed!\n\nI then proceeded to copy MacroDef/MacroInstance to my own antlib, and\namazingly after repackaging and adding a single import, everything worked\nfine. (I duplicate the code because we only use an official Ant release.)\nI then tweaked <macrodef> to add the following features:\n\n1) Everytime a macro attribute or element is explicitly defined in a macro\n   instance (where the macro is used), I define an additional macro attribute\n   (local property in the code) which allows to find out in the macro body\n   whether the attribute or element was explicitly used/specified.\n\n   When an 'foo' attribute is used, I define '@foo?' with value of true.\n   When an 'bar' element is used, I define 'bar?' with value of true\n\n   My macro bodies/impls then do things or not (or differently) based on\n   this info. For example:\n\n     <bm:macrodef name=\"my-copy\">\n      ...\n      <attribute name=\"tos\" default=\"/dev/null\" />\n      <sequential>\n        ...\n        <bm:sequential ifTrue=\"@{@tos?}\">\n          <copy file=\"@{tos}\" tofile=\"...\" />\n        </bm:sequential>\n      </sequential>\n    </bm:macrodef>\n\n    <bm:macrodef name=\"my-module-image\">\n      ...\n      <element name=\"sources\" optional=\"true\" />\n      <sequential>\n        ...\n        <bm:sequential ifTrue=\"@{@sources?}\">\n          <zip destfile=\"@{todir}/sdk/src.zip\">\n            <sources />\n          </zip>\n        </bm:sequential>\n      </sequential>\n    </bm:macrodef>\n\n2) Allow defining an macro element 'default value'. Instead of the default\n   being inside the <macrodef> <element>, its inside the macro <sequential>\n   where the element is used. I did it this way because the implementation\n   was easier, and it makes it easy to read the macro impl, although it\n   could be confusing to some I guess?!\n\n   If a macro element is not explicitly specified in the macro instance,\n   and the element is optional, then the 'default value' from the macro\n   definition is used. If specified, the macro instance value is used as\n   usual otherwise. For example:\n\n    <bm:macrodef name=\"my-register\">\n      ...\n      <element name=\"patterns\" optional=\"true\" />\n      <sequential>\n        <ds:register ...>\n          ...\n          <fileset dir=\"@{dir}\">\n            <patterns>\n              <include name=\"**/*.class\" />\n              <exclude name=\"**/test/*Test.class\" />\n            </patterns>\n          </fileset>\n        </ds:register>\n      </sequential>\n    </bm:macrodef>\n\n    The macro above defaults the patterns element to 1 include + 1 exclude.\n\n3) When coming up with elements a macro could contain, I often end up\n   wanting to contain a classpath macro element that I want to pass in\n   to <java> or another task taking a classpath. If I can't use the single\n   implicit element for some reason, I then have to do something ugly:\n\n   <macrodef name=\"ugly\">\n     ...\n     <element name=\"my-classpath\" optional=\"true\" />\n     <sequential>\n       ...\n       <java ...>\n         <my-classpath />\n       </java>\n     </sequential>\n   </macrodef>\n\n  and I'm forced to use:\n\n  <ugly>\n    <my-classpath>\n      <classpath refid=\"classpath\" />\n    </my-classpath>\n  </ugly>\n\n  If I throw in element defaults from (2), the macro becomes:\n\n   <macrodef name=\"ugly\">\n     ...\n     <element name=\"my-classpath\" optional=\"true\" />\n     <sequential>\n       ...\n       <java ...>\n         <my-classpath>\n           <classpath refid=\"classpath\" />\n         </my-classpath>\n       </java>\n     </sequential>\n   </macrodef>\n\n  To work around this, I added a new useContentOnly attribute to <element>,\n  which defaults to true for BC, but when false, allows to pass in the element\n  itself as-is, as defined in the macro definition or instance. I can now do\n\n   <macrodef name=\"nicer\">\n     ...\n     <element name=\"classpath\" optional=\"true\" useContentOnly=\"false\" />\n     <sequential>\n       ...\n       <java ...>\n         <classpath refid=\"classpath\" />\n       </java>\n     </sequential>\n   </macrodef>\n\n  and I can use it as\n\n  <nicer />\n\n  or\n\n  <nicer>\n    <classpath refid=\"alt.classpath\" />\n  </nicer>\n\n  or \n\n  <nicer>\n    <classpath>\n      <pathelement location=\"...\" />\n      <path refid=\"classpath\" />\n    </classpath>\n  </nicer>\n\n  With (2) + (3), you can take some ant code composed of 3 tasks for example,\n  put it in a macro, and define an optional element for each task with\n  useContentOnly=\"false\", and have the macro user be able to override only\n  one of the macro's task.\n\n  To be truly complete, we'd also need a way to refer to the default content\n  of the element to reuse it in the macro instance itself (i.e super).\n  I haven't done that.\n\n4) Finally, the last thing I did was to allow using the macro attributes\n   in the macro instance, to benefit from the default values computed by\n   the macro. Currently, if one defines:\n\n   <macrodef name=\"macrosub\">\n     <attribute name=\"primary\" default=\"foo\" />\n     <attribute name=\"secondary\" default=\"@{primary}bar\" />\n     <element name=\"nested-elements\" optional=\"true\" implicit=\"true\" />\n     <sequential>\n       <nested-elements />\n     </sequential>\n   </macrodef>\n\n   and does:\n\n   <macrosub>\n     <echo>secondary = @{secondary}</echo>\n   </macrosub>\n\n   One will not get secondary = foobar, because the macro instance does\n   not have access to the macro 'local properties', which includes the\n   computed default attributes. I consider 'secondary' to be part of the\n   macro API, and thus logic that it can be used in the macro instance.\n   Implementation wise, it means using copy() more often.\n\nMy changes are not extensive, and are mostly in MacroInstance#copy and\nthe addition of MacroDef.TemplateElement#setUseContentOnly.\n\nI'd appreciate some feedback on whether these new features are desirable.\nI believe there would be zero BC issues. Thanks, --DD"}, {"attachment_id": 13725, "tags": [], "bug_id": 32638, "is_private": false, "count": 1, "id": 68245, "time": "2004-12-10T17:02:47Z", "creator": "ddevienne@lgc.com", "creation_time": "2004-12-10T17:02:47Z", "text": "Created attachment 13725\nModified Ant 1.6 based MacroDef.java\n\nSimply add the useContentOnly attribute to a macrodef element."}, {"count": 2, "tags": [], "creator": "ddevienne@lgc.com", "text": "Created attachment 13726\nModified Ant 1.6 based MacroInstance.java\n\nModifies execute() and copy() to add all the new <macrodef> features.", "id": 68246, "time": "2004-12-10T17:04:45Z", "bug_id": 32638, "creation_time": "2004-12-10T17:04:45Z", "is_private": false, "attachment_id": 13726}, {"attachment_id": null, "tags": [], "bug_id": 32638, "is_private": false, "count": 3, "id": 68252, "time": "2004-12-10T17:29:18Z", "creator": "peterreilly@apache.org", "creation_time": "2004-12-10T17:29:18Z", "text": "Another idea would be to use local properties to say if an attribute/element\nis set or not, then one could use the usually ant idiom of using the if\nattribute to test for the presence of an attribute/element.\n\n<macrodef name=\"x\">\n   <element name=\"contents\" optional=\"yes\"/>\n   <sequential>\n      <my:sequential if=\"contents.element.set\">\n          <copy ../>\n      </my:seqential>\n   </sequential>\n</macrodef>\n"}, {"count": 4, "tags": [], "creator": "ddevienne@lgc.com", "attachment_id": null, "is_private": false, "id": 68253, "time": "2004-12-10T17:41:21Z", "bug_id": 32638, "creation_time": "2004-12-10T17:41:21Z", "text": "Would that work? There wouldn't be any textual substitution by macroSubs, and \n<my:sequential> would know nothing about contents.element.set since not in the \neral Project properties, and if you did put it in the project properties, then \nwe have the usual tmp/immutable property issue.\n\nThe properly pull it off, you'd need the notion of a proper AntContext, the \nmacro instance one on top of the normal project one, no?\n\nThat's why the ifTrue condition works will in this case, since it sidesteps \nthe issue by letting macrodef do the macroSubs, and evaluate the result as a \nboolean. --DD"}, {"count": 5, "text": "> The properly pull it off, you'd need the notion of a proper AntContext, the \n> macro instance one on top of the normal project one, no?\n\nYes, the previous version of the local-property patch does this, it is a\nlocal-property scope not the ant project context.\n", "creator": "peterreilly@apache.org", "is_private": false, "id": 68254, "time": "2004-12-10T17:46:00Z", "bug_id": 32638, "creation_time": "2004-12-10T17:46:00Z", "tags": [], "attachment_id": null}, {"count": 6, "tags": [], "bug_id": 32638, "text": "Created attachment 22555\npatch to set local macro-properties for defined elements and attributs as described in paragraph 1 of the feature request\n\nHi,\n\nI was looking after a feature like this since I started to use macrodefs in our ant-based build-environment. After a lot of reading through the mailinglists I found this feature request and I implemented the paragraph 1) on current 1.7.1-sources.", "id": 120537, "time": "2008-09-11T07:27:50Z", "creator": "c.dittberner@digitec.de", "creation_time": "2008-09-11T07:27:50Z", "is_private": false, "attachment_id": 22555}, {"count": 7, "tags": [], "creator": "slugfiller@ifireball.dyndns.org", "attachment_id": null, "is_private": false, "id": 128773, "time": "2009-07-12T16:14:39Z", "bug_id": 32638, "creation_time": "2009-07-12T16:14:39Z", "text": "The potential use of an \"if\" construct inside the macrodef could go beyond the capabilities of \"sequencial\". Taking the \"nicer\" example above, supposed you wanted the default classpath element to be no element at all, but wanted to keep the \"nicer\" syntax where it is used.\n\nYou could use:\n  <macrodef name=\"nicer\">\n    ...\n    <element name=\"classpath\" optional=\"true\" useContentOnly=\"false\" />\n    <sequential>\n      ...\n      <java ...>\n        <macroif ifTrue=\"classpath.element.set\">\n          <classpath />\n        </macroif>\n      </java>\n    </sequential>\n  </macrodef>\n\nThat way you can use:\n\n  <nicer />\n  <nicer>\n    <classpath>\n      <pathelement location=\"...\" />\n      <path refid=\"classpath\" />\n    </classpath>\n  </nicer>\n\nWhich expands to:\n\n  <sequential>\n    ...\n    <java ... />\n  </sequential>\n  <sequential>\n    ...\n    <java ...>\n      <classpath>\n        <pathelement location=\"...\" />\n        <path refid=\"classpath\" />\n      </classpath>\n    </java>\n  </sequential>\n\nNote the slight difference between the use of a modified \"sequencial\", and the use of \"marcoif\" - the latter effects the expanding phase and can contain any element, not just tasks.\n\nOne aspect I am slightly worried about is name collision: If you make an additional macro element called classpath, you cannot enter an additional literal classpath element. The usual solution is to use different element names, but this doesn't work, and could become a common problem, if you want to use the useContentOnly feature.\n\nA possible solution is to add a special element namespace which is removed during expansion:\n\n  <macrodef name=\"namespace\">\n    ...\n    <element name=\"include\" namespace=\"element\" useContentOnly=\"false\" />\n    <sequential>\n      ...\n      <java ...>\n        <element:include />\n        <include name=\"src/**/*.java\" />\n      </java>\n    </sequential>\n  </macrodef>\n\nThen you can use:\n\n  <namespace>\n    <include name=\"plugins/**/*.java\" />\n  </namespace>\n\nThis would expand to:\n\n  <sequential>\n    ...\n    <java ...>\n      <include name=\"src/**/*.java\" />\n      <include name=\"plugins/**/*.java\" />\n    </java>\n  </sequential>\n\nNote that the namespace is only used in the macrodef, not the macro instance nor the expansion, otherwise it wouldn't add anything to just using a different name. An alternative to a namespace would be to give an alias which is only used inside the macrodef:\n\n  <macrodef name=\"namespace\">\n    ...\n    <element name=\"include\" alias=\"moreinclude\" useContentOnly=\"false\" />\n    <sequential>\n      ...\n      <java ...>\n        <moreinclude />\n        <include name=\"plugins/**/*.java\" />\n      </java>\n    </sequential>\n  </macrodef>\n\nThe usage and expansion are the same as above. An alternative, more self-explanatory name for the attribute could be \"internally\" or \"internalName\".\nOne could take this one step further by having different element names during macro instance and post expansion, but that might be overkill.\n\nNot sure how useful all of this is, but it would certainly add some nice possibilities."}]