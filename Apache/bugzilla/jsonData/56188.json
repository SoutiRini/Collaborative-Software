[{"count": 0, "attachment_id": null, "bug_id": 56188, "is_private": false, "id": 173473, "time": "2014-02-25T19:15:26Z", "creator": "justine@networkinstruments.com", "creation_time": "2014-02-25T19:15:26Z", "tags": [], "text": "Steps to reproduce:\n1. Send an XHR to a fcgi handler that takes a while to complete\n2. Abort the xhr request\n\nExpected Result:\nmod_proxy_fcgi should send a FCGI_ABOR_REQUEST message, as specified in the fast cgi specification: http://www.fastcgi.com/devkit/doc/fcgi-spec.html#S5.4\n\nActual Result:\nmod_proxy_fcgi ignores client disconnect and attempts to continue processing the response."}, {"count": 1, "attachment_id": 33336, "bug_id": 56188, "text": "Created attachment 33336\nBug fix patch\n\nThe attached patch fixes this bug. We have been shipping a patched version of Apache for nearly two years using this patch.", "id": 186882, "time": "2015-12-10T14:58:46Z", "creator": "jason.michaelson@viavisolutions.com", "creation_time": "2015-12-10T14:58:46Z", "tags": [], "is_private": false}, {"count": 2, "tags": [], "bug_id": 56188, "text": "Created attachment 33433\nUpdated patch\n\nUpdated patch file against 2.4.18.", "id": 187624, "time": "2016-01-13T17:48:50Z", "creator": "jason.michaelson@viavisolutions.com", "creation_time": "2016-01-13T17:48:50Z", "is_private": false, "attachment_id": 33433}, {"count": 3, "attachment_id": null, "bug_id": 56188, "text": "I was able to repro the problem with a simple php script that sleeps for a while, you are definitely right. I checked very quickly the patch and it looks good, but I am not super expert with mod_proxy_fcgi so I'll need to review it more carefully and ask for some advice.\n\nThanks a lot for the patch and the effort!", "id": 192640, "time": "2016-07-26T08:12:04Z", "creator": "toscano.luca@gmail.com", "creation_time": "2016-07-26T08:12:04Z", "tags": [], "is_private": false}, {"count": 4, "tags": [], "bug_id": 56188, "text": "Created attachment 34073\nPrevious patch with comments and rebased for trunk\n\nAdding the same patch provided before but with some comments and a fix for a make error (send_data taking too many arguments).", "id": 192650, "time": "2016-07-26T12:53:33Z", "creator": "toscano.luca@gmail.com", "creation_time": "2016-07-26T12:53:33Z", "is_private": false, "attachment_id": 34073}, {"count": 5, "tags": [], "bug_id": 56188, "text": "Is there any chance of this bug fix getting included in a 2.4 release in the near future?", "id": 194782, "time": "2016-11-02T18:01:03Z", "creator": "jason.michaelson@viavisolutions.com", "creation_time": "2016-11-02T18:01:03Z", "is_private": false, "attachment_id": null}, {"count": 6, "tags": [], "bug_id": 56188, "attachment_id": null, "is_private": false, "id": 195564, "time": "2016-12-19T15:35:03Z", "creator": "jim@apache.org", "creation_time": "2016-12-19T15:35:03Z", "text": "Thanks. Will review. Can anyone confirm that this also affects trunk as well? I see no reason why it would be different, so I assume so.\n\nWill try to recreate."}, {"count": 7, "tags": [], "bug_id": 56188, "is_private": false, "id": 195580, "creation_time": "2016-12-21T11:20:09Z", "time": "2016-12-21T11:20:09Z", "creator": "toscano.luca@gmail.com", "text": "It affects trunk, the patch name was only a way to say that I had to rework a bit Justin's patch to make trunk compile, sorry :)\n\nI got bitten by this issue at work yesterday (long php jobs), in my case (to be verified) even the ProxyTimeout/Timeout settings might trigger this problem (so the FCGI backend will not get notified that httpd timed out the client's request).", "attachment_id": null}, {"count": 8, "tags": [], "bug_id": 56188, "is_private": false, "text": "Another script that illustrates the issue:\n\n<?php\n\n// current time\necho date('h:i:s') . \"\\n\";\n\n// sleep for 10 seconds\nsleep(10);\n\n$myfile = fopen(\"/tmp/timetable\", \"w\") or die(\"Unable to open file!\");\n\nfor ($i=0; $i<1000000; $i++) {\n   $txt = date('h:i:s') . \"\\n\";\n   fwrite($myfile, $txt);\n}\n\nfclose($myfile);\n\n// wake up !\necho date('h:i:s') . \"\\n\";\n\n?>\n\nThe /tmp/timetable will be written every time, even if:\n\n1) Timeout or ProxyTimeout are set to 5 seconds (random number less than 10).\n2) A client disconnects happens during the sleep time.", "id": 195616, "time": "2016-12-22T17:44:51Z", "creator": "toscano.luca@gmail.com", "creation_time": "2016-12-22T17:44:51Z", "attachment_id": null}, {"count": 9, "tags": [], "bug_id": 56188, "is_private": false, "id": 195641, "creation_time": "2016-12-23T17:43:22Z", "time": "2016-12-23T17:43:22Z", "creator": "toscano.luca@gmail.com", "text": "So while reading http://www.mit.edu/~yandros/doc/specs/fcgi-spec.html#S5.4 I came across this:\n\n> A Web server aborts a FastCGI request when an HTTP client closes its transport connection while the FastCGI request is running on behalf of that client. \n\n> The Web server sends a FCGI_ABORT_REQUEST record to abort a request. After receiving {FCGI_ABORT_REQUEST, R}, the application responds as soon as possible with {FCGI_END_REQUEST, R, {FCGI_REQUEST_COMPLETE, appStatus}}. This is truly a response from the application, not a low-level acknowledgement from the FastCGI library.\n\nAs far as I can see the patch breaks out of the main while after sending the FCGI ABORT, not waiting for the FCGI_END_REQUEST response. I tried to change it a bit to allow this flow, but from my test I never get FCGI_END_REQUEST because mod_proxy_fcgi stops before it finding out that the client dropped the connection (probably when it tries to flush the output).\n\nI also didn't manage to see the FCGI backend stopping after the FCGI ABORT is sent, but maybe I am missing something trivial. I'll try to work on this code more during the next days.\n\nJason: just want to make it clear, your patch looks good, I just want to make sure that we don't miss any corner case :)\n\nThanks!", "attachment_id": null}, {"count": 10, "tags": [], "creator": "toscano.luca@gmail.com", "attachment_id": null, "id": 195647, "time": "2016-12-23T21:28:34Z", "bug_id": 56188, "creation_time": "2016-12-23T21:28:34Z", "is_private": false, "text": "Another bit of info:\n\nhttp://php.net/manual/en/function.ignore-user-abort.php\n\n> PHP will not detect that the user has aborted the connection until an attempt is made to send information to the client.\n> Simply using an echo statement does not guarantee that information is sent, see flush().\n\nIn the above example, adding ob_flush() and flush() triggers a stop of the PHP processing right after the curl HTTP request / connection is aborted.\n\nJustin, Jason - would you mind to add a tiny example of your XHR use case and how it fails? Having a good repro will surely help in speeding up this review process (at least for me!).\n\nThanks!"}, {"count": 11, "attachment_id": null, "bug_id": 56188, "is_private": false, "id": 195650, "time": "2016-12-24T12:38:53Z", "creator": "toscano.luca@gmail.com", "creation_time": "2016-12-24T12:38:53Z", "tags": [], "text": "I believe that I have a better understanding of the issue, that can be probably summarized in two things:\n\n1) mod_proxy_fcgi should detect as early as possible that the client connection dropped taking appropriate actions, for example sending FCGI_ABORT to the backend and cleaning its state.\n\n2) The FCGI backend needs to react after receiving a FCGI ABORT appropriately.\n\nAbout 1), I have some ideas still to verify:\n\n- Rather than creating a new apr_pollfd_t, the client aborted use case might be handled by something simpler like the following (missing the FCGI_ABORT bit):\n\nIndex: modules/proxy/mod_proxy_fcgi.c\n===================================================================\n--- modules/proxy/mod_proxy_fcgi.c\t(revision 1775858)\n+++ modules/proxy/mod_proxy_fcgi.c\t(working copy)\n@@ -481,6 +481,12 @@\n          * cause timeout errors. */\n         apr_socket_timeout_get(conn->sock, &timeout);\n\n+        if (r->connection->aborted) {\n+            ap_log_rerror(APLOG_MARK, APLOG_TRACE1, rv, r,\n+                          \"The client aborted the connection.\");\n+            break;\n+        }\n+\n         rv = apr_poll(&pfd, 1, &n, timeout);\n         if (rv != APR_SUCCESS) {\n             if (APR_STATUS_IS_EINTR(rv)) {\n\n- The FCGI specs seems to indicate that after sending a FCGI ABORT, mod_proxy_fcgi should need to wait for a related FCGI_END_REQUEST before wrapping up (we are not doing it in the various patches). \n\nI am going to do some more research during the next days, but if anybody has more knowledge then me related to FCGI please let me know. I am far from a expert in the field and it would be great to deliver this patch as quickly as possible."}, {"count": 12, "attachment_id": 34560, "bug_id": 56188, "text": "Created attachment 34560\nSend FCGI_ABORT to the backend when the client disconnects\n\nUpdated the patch with some trace error messages and a better handling of the response value rv. The 'dispatch' function checks the returned 'rv' value if not different from APR_SUCCESS, so the last one to return shouldn't always be the result of the send_data call for the FCGI_ABORT notification (that most of the times, if the backend is healthy, returns APR_SUCCESS).\n\nRemaining unclear points:\n\n1) A 503 is logged with this patch, meanwhile a 200 was logged for the previous version. What is the best thing to log in case a client connection is aborted?\n\n2) When ProxyTimeout is hit, should we send a FCGI_ABORT notification to the backend?", "id": 195670, "time": "2016-12-27T19:26:35Z", "creator": "toscano.luca@gmail.com", "creation_time": "2016-12-27T19:26:35Z", "tags": [], "is_private": false}, {"count": 13, "tags": [], "creator": "toscano.luca@gmail.com", "attachment_id": null, "id": 195671, "time": "2016-12-27T20:03:18Z", "bug_id": 56188, "creation_time": "2016-12-27T20:03:18Z", "is_private": false, "text": "Auto-answering the following previous point:\n\n> - The FCGI specs seems to indicate that after sending a FCGI ABORT, mod_proxy_fcgi should need to wait for a related FCGI_END_REQUEST before wrapping up (we are not doing it in the various patches). \n\nI haven't found any good implementation/handling of FCGI_ABORT in common fcgi backends, but some ad-hoc ones might want to rely on it. I don't think that httpd needs to strictly follow the protocol specification for this use case (that seems to be waiting for FCGI_END_REQUEST), but I am open to suggestions."}, {"count": 14, "tags": [], "bug_id": 56188, "attachment_id": null, "is_private": false, "id": 195682, "time": "2016-12-28T12:55:54Z", "creator": "toscano.luca@gmail.com", "creation_time": "2016-12-28T12:55:54Z", "text": "To add some references (still to verify):\n\n- https://github.com/facebook/hhvm/blob/HHVM-3.17/hphp/runtime/server/http-request-handler.cpp#L411\n\n- https://github.com/dreamcat4/php-fpm/blob/master/cgi/fastcgi.h#L37\n\nFrom the HHVM commentary:\n\n\"\"\"\n  /* FastCGI ABORT_REQUEST prematurely terminates a request, signaling that\n   * the webserver is no longer interested in processing it. The contentData\n   * for such recoreds is empty. The application server must reply with\n   * an END_REQUEST record to indicate that it has aborted.\n   */\n\"\"\"\n\nSo php-fpm seems not supporting it, meanwhile HHVM returns a 503 by default. These are not the full spectrum of FCGI backends but two famous ones that I know."}, {"count": 15, "tags": [], "creator": "toscano.luca@gmail.com", "is_private": false, "id": 195727, "creation_time": "2016-12-30T19:16:04Z", "time": "2016-12-30T19:16:04Z", "bug_id": 56188, "text": "Created attachment 34572\nSend FCGI_ABORT to the backend when the client disconnects\n\nExplicitly added the code to instruct httpd that the r->connection is aborted. In trunk I can see the following strange log:\n\n[Fri Dec 30 19:08:52.950149 2016] [proxy_fcgi:trace1] [pid 3966:tid 139835091949312] mod_proxy_fcgi.c(597): [client 127.0.0.1:57840] EOF detected from the main client connection.\n[Fri Dec 30 19:08:52.950180 2016] [proxy_fcgi:trace1] [pid 3966:tid 139835091949312] mod_proxy_fcgi.c(893): (70014)End of file found: [client 127.0.0.1:57840] The client aborted the connection.\n[Fri Dec 30 19:08:52.950186 2016] [proxy:debug] [pid 3966:tid 139835091949312] proxy_util.c(2232): AH00943: FCGI: has released connection for (127.0.0.1)\n[Fri Dec 30 19:08:52.950210 2016] [headers:trace2] [pid 3966:tid 139835091949312] mod_headers.c(875): AH01502: headers: ap_headers_output_filter()\n[Fri Dec 30 19:08:52.950242 2016] [http:trace3] [pid 3966:tid 139835091949312] http_filters.c(1034): [client 127.0.0.1:57840] Response sent with status 200, headers:\n[Fri Dec 30 19:08:52.950245 2016] [http:trace5] [pid 3966:tid 139835091949312] http_filters.c(1041): [client 127.0.0.1:57840]   Date: Fri, 30 Dec 2016 19:08:51 GMT\n[Fri Dec 30 19:08:52.950247 2016] [http:trace5] [pid 3966:tid 139835091949312] http_filters.c(1044): [client 127.0.0.1:57840]   Server: Apache/2.5.0-dev (Unix)\n[Fri Dec 30 19:08:52.950253 2016] [http:trace4] [pid 3966:tid 139835091949312] http_filters.c(863): [client 127.0.0.1:57840]   Vary: User-Agent\n[Fri Dec 30 19:08:52.950256 2016] [http:trace4] [pid 3966:tid 139835091949312] http_filters.c(863): [client 127.0.0.1:57840]   Content-Length: 0\n[Fri Dec 30 19:08:52.950257 2016] [http:trace4] [pid 3966:tid 139835091949312] http_filters.c(863): [client 127.0.0.1:57840]   Connection: close\n[Fri Dec 30 19:08:52.950261 2016] [core:trace6] [pid 3966:tid 139835091949312] util_filter.c(803): [client 127.0.0.1:57840] reinstate empty brigade to full brigade in 'req_core' output filter\n[Fri Dec 30 19:08:52.950264 2016] [core:trace8] [pid 3966:tid 139835091949312] util_filter.c(914): [client 127.0.0.1:57840] brigade contains: bytes: 145, non-file bytes: 145, eor buckets: 0, morphing buckets: 0\n[Fri Dec 30 19:08:52.950272 2016] [http:trace3] [pid 3966:tid 139835091949312] http_filters.c(1034): [client 127.0.0.1:57840] Response sent with status 200, headers:\n[Fri Dec 30 19:08:52.950274 2016] [http:trace5] [pid 3966:tid 139835091949312] http_filters.c(1041): [client 127.0.0.1:57840]   Date: Fri, 30 Dec 2016 19:08:51 GMT\n[Fri Dec 30 19:08:52.950276 2016] [http:trace5] [pid 3966:tid 139835091949312] http_filters.c(1044): [client 127.0.0.1:57840]   Server: Apache/2.5.0-dev (Unix)\n[Fri Dec 30 19:08:52.950278 2016] [http:trace4] [pid 3966:tid 139835091949312] http_filters.c(863): [client 127.0.0.1:57840]   Vary: User-Agent\n[Fri Dec 30 19:08:52.950280 2016] [http:trace4] [pid 3966:tid 139835091949312] http_filters.c(863): [client 127.0.0.1:57840]   Content-Length: 0\n[Fri Dec 30 19:08:52.950282 2016] [http:trace4] [pid 3966:tid 139835091949312] http_filters.c(863): [client 127.0.0.1:57840]   Connection: close\n[Fri Dec 30 19:08:52.950284 2016] [core:trace6] [pid 3966:tid 139835091949312] util_filter.c(803): [client 127.0.0.1:57840] reinstate empty brigade to full brigade in 'req_core' output filter\n[Fri Dec 30 19:08:52.950285 2016] [core:trace8] [pid 3966:tid 139835091949312] util_filter.c(914): [client 127.0.0.1:57840] brigade contains: bytes: 145, non-file bytes: 145, eor buckets: 0, morphing buckets: 0\n[Fri Dec 30 19:08:53.895646 2016] [core:trace4] [pid 3964:tid 139835914131200] mpm_common.c(557): mpm child 3966 (gen 0/slot 0) exited\n[Fri Dec 30 19:08:53.895721 2016] [core:trace4] [pid 3964:tid 139835914131200] mpm_common.c(557): mpm child 3969 (gen 0/slot 3) exited\n\nSo there is a double \"HTTP 200 logged\", meanwhile in 2.4.x this issue does not appear (only one 200 logged as expected). I'll try to run gdb to find what is the difference, but from a first glance it seems async conn handling.", "attachment_id": 34572}, {"count": 16, "attachment_id": 34574, "creator": "toscano.luca@gmail.com", "text": "Created attachment 34574\nhttpd-trunk-mod_proxy_fcgi-client_disconnected.patch\n\nAdded comments and renamed the patch since it does not send anymore any FCGI_ABORT.", "id": 195788, "time": "2017-01-02T17:17:42Z", "bug_id": 56188, "creation_time": "2017-01-02T17:17:42Z", "tags": [], "is_private": false}, {"count": 17, "tags": [], "creator": "toscano.luca@gmail.com", "attachment_id": null, "text": "(In reply to Luca Toscano from comment #14)\n> To add some references (still to verify):\n> \n> -\n> https://github.com/facebook/hhvm/blob/HHVM-3.17/hphp/runtime/server/http-\n> request-handler.cpp#L411\n> So php-fpm seems not supporting it, meanwhile HHVM returns a 503 by default.\n> These are not the full spectrum of FCGI backends but two famous ones that I\n> know.\n\nI was probably wrong about HHVM:\n\nhttps://github.com/facebook/hhvm/blob/HHVM-3.17/hphp/runtime/server/fastcgi/fastcgi-session.cpp#L475-L480\n\nvoid FastCGISession::onRecordImpl(const fcgi::abort_record* rec) {\n  if (!m_requestId || rec->requestId != m_requestId) {\n    // Garbage record\n    dropConnection();\n    return;\n  }\n}\n\nIt seems to just drop the connection if an abort is sent. Again, I am not an expert so if anybody has more info please reply :)", "id": 195892, "time": "2017-01-06T16:19:36Z", "bug_id": 56188, "creation_time": "2017-01-06T16:19:36Z", "is_private": false}, {"count": 18, "tags": [], "creator": "toscano.luca@gmail.com", "is_private": false, "id": 196361, "creation_time": "2017-01-24T12:45:19Z", "time": "2017-01-24T12:45:19Z", "bug_id": 56188, "text": "Feedback from the dev@ mailing list, summarized by the words of Jacob Champion:\n\n\"\"\"\nI don't think we should implement FCGI_ABORT until/unless we decide to implement FCGI multiplexing. I understand that the bug's OP is operating happily with an FCGI_ABORT patch, but until they respond to you to clarify what backend they're using, we don't know if their approach is correct even for their own use case.\n\nI don't think we should send FCGI_ABORT and then immediately close the connection without waiting for the client to respond. In my mind, sending FCGI_ABORT is a contract: \"we will accept and discard a reasonable number of messages for the current request ID while we wait for you to send FCGI_END_REQUEST\".\n\nI do think that closing the FCGI connection when the client closes theirs is valuable. Eric's suggestion on #httpd to hide this behind a directive is probably wise; we've broken enough FCGI backends recently...\n\"\"\"\n\nSo the next step is to modify my patch to include a module directive that guards this new behavior.", "attachment_id": null}, {"count": 19, "tags": [], "bug_id": 56188, "text": "Created attachment 34685\nhttpd-trunk-mod_proxy_fcgi-client_disconnected.patch\n\nFirst attempt to implement a conservative ProxyFCGIDetectClientDisconnect (server) directive.", "id": 196502, "time": "2017-01-27T18:44:44Z", "creator": "toscano.luca@gmail.com", "creation_time": "2017-01-27T18:44:44Z", "is_private": false, "attachment_id": 34685}, {"count": 20, "tags": [], "bug_id": 56188, "attachment_id": 34692, "id": 196538, "time": "2017-01-29T09:40:31Z", "creator": "toscano.luca@gmail.com", "creation_time": "2017-01-29T09:40:31Z", "is_private": false, "text": "Created attachment 34692\nhttpd-trunk-mod_proxy_fcgi-client_disconnected.patch\n\nReplaced (apr_socket_t*) ap_get_module_config(r->connection->conn_config, &core_module); with ap_get_conn_socket(r->connection);"}, {"count": 21, "attachment_id": null, "creator": "toscano.luca@gmail.com", "text": "Jacob in #httpd-dev asked two interesting questions:\n\n1) Would we get a EOF even when the client's TCP connection is in a state like half-closed? (So basically doing a correct shutdown).\n\n2) How many times is the POLLIN (registered to on the client's TCP connection to detect disconnects) case executed for a \"typical\" POST request? It seems like that code would get triggered for every incoming group of bytes.", "id": 196539, "time": "2017-01-29T09:48:22Z", "bug_id": 56188, "creation_time": "2017-01-29T09:48:22Z", "tags": [], "is_private": false}, {"count": 22, "tags": [], "creator": "ylavic.dev@gmail.com", "attachment_id": null, "text": "(In reply to Luca Toscano from comment #21)\n> \n> 1) Would we get a EOF even when the client's TCP connection is in a state\n> like half-closed? (So basically doing a correct shutdown).\n\nHalf-closed by whom (and which way)?\n\nA shutdown() for write sends a FIN to the peer, so a poll() there would return with POLLIN and/or POLLHUP (depending on the system), and read()/recv() returns 0 (EOF).\nIt's still possible to poll()/read() an half-closed connection (shut down for write only), hence wait for the peer's data or FIN (read only connection).\n\nA shutdown() for read is not \"visible\" remotely, so it actually has little value (i.e. just stop reading).\n\nBut I don't know how you'd like to use half-closing, so please clarify ;)\n\n> \n> 2) How many times is the POLLIN (registered to on the client's TCP\n> connection to detect disconnects) case executed for a \"typical\" POST\n> request? It seems like that code would get triggered for every incoming\n> group of bytes.\n\nYes, poll() is woken up for each piece of data (or FIN) available in the socket, and until there is nothing more to read immediately (i.e. unless subsequent recv()s empty the socket, poll() won't block).\n\nSo it depends on the size of the buffer used for reading, or if multiple nonblocking reads will empty the queue.", "id": 196546, "time": "2017-01-29T17:30:36Z", "bug_id": 56188, "creation_time": "2017-01-29T17:30:36Z", "is_private": false}, {"count": 23, "tags": [], "bug_id": 56188, "attachment_id": null, "is_private": false, "id": 196556, "time": "2017-01-30T10:42:48Z", "creator": "toscano.luca@gmail.com", "creation_time": "2017-01-30T10:42:48Z", "text": "Hi Yann! \n\nI took some notes in this task without adding too many info, my bad. I am currently trying to understand if the method used to detect a client disconnect (i.e. poll() the client TCP connection for POLLIN events) can lead to bugs or performance regressions. Following up inline:\n\n(In reply to Yann Ylavic from comment #22)\n> (In reply to Luca Toscano from comment #21)\n> > \n> > 1) Would we get a EOF even when the client's TCP connection is in a state\n> > like half-closed? (So basically doing a correct shutdown).\n> \n> Half-closed by whom (and which way)?\n> \n> A shutdown() for write sends a FIN to the peer, so a poll() there would\n> return with POLLIN and/or POLLHUP (depending on the system), and\n> read()/recv() returns 0 (EOF).\n> It's still possible to poll()/read() an half-closed connection (shut down\n> for write only), hence wait for the peer's data or FIN (read only\n> connection).\n> \n> A shutdown() for read is not \"visible\" remotely, so it actually has little\n> value (i.e. just stop reading).\n> \n> But I don't know how you'd like to use half-closing, so please clarify ;)\n\nMy question was if there was any corner case in which if, after a client has initiated a TCP connection close, mod-proxy-fcgi wrongly assume that the connection dropped (because of POLLIN and EOF) taking its own remediation (error logs, etc..).\n\n\n> > \n> > 2) How many times is the POLLIN (registered to on the client's TCP\n> > connection to detect disconnects) case executed for a \"typical\" POST\n> > request? It seems like that code would get triggered for every incoming\n> > group of bytes.\n> \n> Yes, poll() is woken up for each piece of data (or FIN) available in the\n> socket, and until there is nothing more to read immediately (i.e. unless\n> subsequent recv()s empty the socket, poll() won't block).\n> \n> So it depends on the size of the buffer used for reading, or if multiple\n> nonblocking reads will empty the queue.\n\n\nIn this case I am wondering if my patch would introduce a performance regression for use cases like big requests coming in (like POSTs for example). We don't really care about reading those bytes (in the code introduced by my patch) but only to check if the connection with the client is still up, so there might be a better way to approach the issue.\n\nLet me know if my questions are clearer or if you need more info! :)\n(Or if I need to study more the subject!)"}, {"count": 24, "tags": [], "bug_id": 56188, "attachment_id": null, "id": 196569, "time": "2017-01-30T18:13:34Z", "creator": "jchampion@apache.org", "creation_time": "2017-01-30T18:13:34Z", "is_private": false, "text": "(In reply to Luca Toscano from comment #21)\n> 1) Would we get a EOF even when the client's TCP connection is in a state\n> like half-closed? (So basically doing a correct shutdown).\n\nI actually want to semi-retract this question... I don't *think* HTTP has a provision for half-closes since it's not required to be implemented over TCP. At the very least, requests cannot make use of a half-close to delimit the end of a request message body, which was my primary concern."}, {"count": 25, "tags": [], "creator": "toscano.luca@gmail.com", "text": "From a discussion in dev@ about polling the client's TCP connection:\n\n\"\"\"\nIt could be achievable, but not easy, with care taken to pull the\nclient's socket out of the pollset if anything but an error or a\nconnection/TLS close is detected.\nIt probably also shouldn't start before \"last_stdin\" is true.\n\nClient side poll() may return with either:\n1. HTTP data (pipelined) => client still alive, non-empty/meta brigade\n=> don't abort\n2. TCP close or reset => bucket EOS or an APR_E* (though\nspeculative-non-blocking reads won't return EOS, and may turn EOF into\nSUCCESS with empty brigade!) => abort\n3. TLS close notify => EOS/EOF? => abort\n4. TLS renegotiation => rejected by httpd (since initiated by the\nclient) => an APR_E* => abort\nn. ...\n\nProbably not an exhaustive list...\n\"\"\"\n\nSo even if the patch provided by Jason works and looks good, it might introduce some weird corner cases for the general consumption that might create regressions during the next release. This doesn't mean that the patch can't work for specific use cases, but it might not be the best one for all of them.\n\nAnother approach that was proposed by Yann is the following: use non blocking recv while reading from the FCGI backend, and in case of EAGAIN send a FLUSH bucket to the client in order to force ap_pass_brigade to detect if the client aborted the connection.\n\npoll() => POLLIN => read() while data available => EAGAIN => flush => poll()\n\nRemark: The \"read() while data available => EAGAIN\" may be replaced by \"read()\nwhile read buffer is full\" so to avoid a (likely) useless last\nnon-blocking read.\n\nRemark 2: https://httpd.apache.org/docs/2.4/developer/output-filters.html#basics\n\n\"\"\"\nFLUSH buckets are sent when the content generator (or an upstream filter) knows that there may be a delay before more content can be sent. By passing FLUSH buckets down the filter chain immediately, filters ensure that the client is not kept waiting for pending data longer than necessary.\nFilters can create FLUSH buckets and pass these down the filter chain if desired. Generating FLUSH buckets unnecessarily, or too frequently, can harm network utilisation since it may force large numbers of small packets to be sent, rather than a small number of larger packets.\n\"\"\"", "id": 196717, "time": "2017-02-04T15:16:03Z", "bug_id": 56188, "creation_time": "2017-02-04T15:16:03Z", "is_private": false, "attachment_id": null}]