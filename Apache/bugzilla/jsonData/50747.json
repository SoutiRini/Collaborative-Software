[{"count": 0, "tags": [], "bug_id": 50747, "attachment_id": null, "is_private": false, "id": 144104, "time": "2011-02-09T14:16:29Z", "creator": "frank.schroeder@gmail.com", "creation_time": "2011-02-09T14:16:29Z", "text": "I have built a simple Publish/Subscribe servlet using the CometProcessor. When a client connects then the servlet checks in the BEGIN phase whether there are pending events for the client and if not stores the request in a list of pending requests. Later another thread notifies the CometProcessor that data for the user has arrived and the data is pushed through the pending connection. \n\nThe pseudo-code looks like this:\n\npublic class EventService implements CometProcessor {\n    public void event(CometEvent event) {\n        if (event.getType() == CometEvent.BEGIN) {\n            String data = getDataForUser(event);\n            if (data != null) {\n                sendAndClose(data, event);\n            } else {\n                pendingRequests.add(event);\n            }\n        } else {\n            event.close();\n        }\n    }\n\n    public void push(String user, String data) {\n        CometEvent event = findPendingRequest(user);\n        sendAndClose(data, event);\n        pendingRequests.remove(event);\n    }\n\n    public void sendAndClose(String data, CometEvent event) {\n        Writer w = event.request.getWriter();\n        w.write(data);\n        w.flush();\n        event.close();\n    }\n}\n\nThis works as expected as long as I connect with an HTTP/1.1 client. However, when an HTTP/1.0 client connects (e.g. nginx) the connection is not closed immediately. In my case the data is a JSON string which is pushed to the client if the client ends with '\\r\\n' but the connection lingers open. \n\nThis is also reproducible with curl\n\nHTTP/1.1 request\n----------------\n\n# curl -v -XGET -u 'frank:frank' 'http://127.0.0.1:8081/fcc/event?timestamp=1297277309368'; echo \n> GET /fcc/event?timestamp=1297277309368 HTTP/1.1\n> Authorization: Basic xxx\n> User-Agent: curl/7.21.2 ...\n> Host: 127.0.0.1:8081\n> Accept: */*\n> \n< HTTP/1.1 200 OK\n< Server: Apache-Coyote/1.1\n< Content-Type: application/json;charset=ISO-8859-1\n< Transfer-Encoding: chunked\n< Date: Wed, 09 Feb 2011 18:49:45 GMT\n< \n{\"type\":\"settings-changed\",\"timestamp\":1297277385366,\"data\":{\"version\":157}}\n* Connection #0 to host 127.0.0.1 left intact\n* Closing connection #0\n^^^^^^^^^^^^^^^^^^^^^^^\nConnection is closed immediately\n\nHTTP/1.0 request\n----------------\n\n# curl -v -XGET -0  -u 'frank:xxx' 'http://127.0.0.1:8081/fcc/event?timestamp=1297277309368'; echo \n> GET /fcc/event?timestamp=1297277309368 HTTP/1.0\n> Authorization: Basic xxx\n> User-Agent: curl/7.21.2 ...\n> Host: 127.0.0.1:8081\n> Accept: */*\n> \n< HTTP/1.1 200 OK\n< Server: Apache-Coyote/1.1\n< Content-Type: application/json;charset=ISO-8859-1\n< Date: Wed, 09 Feb 2011 18:49:45 GMT\n< Connection: close\n< \n{\"type\":\"settings-changed\",\"timestamp\":1297277385366,\"data\":{\"version\":157}}\n^^^^^^^^^^^^^^^^^^^^^^^\nConnection stays open until timeout occurs"}, {"count": 1, "tags": [], "bug_id": 50747, "text": "I've found the problem. The following sequence works with HTTP/1.1 but not with HTTP/1.0. I guess I've made a classical optimization mistake. This also explains why the content length and encoding headers were never set.\n\n\nString data = \"...\";\nPrintWriter writer = response.getWriter();\nresponse.setStatus(200);\nresponse.setCharacterEncoding(\"UTF-8\");\nresponse.setContentLength(data.length());\nwriter.write(data);\nwriter.flush();\nevent.close();\n\nGetting the Writer *after* setting the response headers makes it all work\n\nString data = \"...\";\nresponse.setStatus(200);\nresponse.setCharacterEncoding(\"UTF-8\");\nresponse.setContentLength(data.length());\nPrintWriter writer = response.getWriter();\nwriter.write(data);\nwriter.flush();\nevent.close();", "id": 144107, "time": "2011-02-09T15:21:54Z", "creator": "frank.schroeder@gmail.com", "creation_time": "2011-02-09T15:21:54Z", "is_private": false, "attachment_id": null}, {"count": 2, "attachment_id": null, "creator": "knst.kolinko@gmail.com", "text": "> String data = \"...\";\n> response.setCharacterEncoding(\"UTF-8\");\n> response.setContentLength(data.length());\n> PrintWriter writer = response.getWriter();\n\nThe above code is wrong, because String.length() is measured in chars, but content-length header is measured in bytes. UTF-8 uses more than 1 byte for characters > 127.", "id": 144108, "time": "2011-02-09T15:39:00Z", "bug_id": 50747, "creation_time": "2011-02-09T15:39:00Z", "tags": [], "is_private": false}, {"count": 3, "tags": [], "text": "Tomcat could be a little smarter here.\n\nWe currently ignore a call to setContentLength() after a call to getWriter(). However, we only have to ignore the content length once bytes have actually been written to the response and a method to determine that is available.\n\nIf I were to patch trunk, could you build 7.0.x from source and give it a try?", "is_private": false, "id": 144109, "creator": "markt@apache.org", "time": "2011-02-09T15:48:04Z", "bug_id": 50747, "creation_time": "2011-02-09T15:48:04Z", "attachment_id": null}, {"count": 4, "tags": [], "creator": "frank.schroeder@gmail.com", "text": "Sure, I can try that. While you're at it you can also check the encoding as it wasn't set as well. The content type was OK. The reason I had this code was because of this:\n\nPrintWriter writer = response.getWriter();\nif (jsonp) {\nString data = ... build jsonp here ...\n  response.setStatus(200);\n  response.setContentType(\"text/javascript\");\n  response.setCharacterEncoding(\"UTF-8\");\n  response.setContentLength(data.length());\n  writer.write(data);\n} else {\n  String data = ... build json here ...\n  response.setStatus(200);\n  response.setContentType(\"application/json\");\n  response.setCharacterEncoding(\"UTF-8\");\n  response.setContentLength(data.length());\n  writer.write(data);\n}\nwriter.flush();\nevent.close();\n\n\nRegarding the content length. So I guess that should be then like this?\n\nresponse.setContentLength(data.getBytes(\"UTF-8\").length);\n\nAs a side node and for completeness: \n\nnginx still hung but turning off proxy buffering with\n\nproxy_buffering off;\n\nfixed that as well.", "id": 144110, "time": "2011-02-09T15:55:29Z", "bug_id": 50747, "creation_time": "2011-02-09T15:55:29Z", "is_private": false, "attachment_id": null}, {"count": 5, "attachment_id": null, "creator": "markt@apache.org", "is_private": false, "id": 144111, "time": "2011-02-09T16:16:04Z", "bug_id": 50747, "creation_time": "2011-02-09T16:16:04Z", "tags": [], "text": "You can't change the encoding once the writer has been obtained since the encoding is used to create the writer."}, {"count": 6, "attachment_id": null, "bug_id": 50747, "is_private": false, "id": 144113, "time": "2011-02-09T16:54:08Z", "creator": "knst.kolinko@gmail.com", "creation_time": "2011-02-09T16:54:08Z", "tags": [], "text": "(In reply to comment #3)\n> Tomcat could be a little smarter here.\n\nFor reference: I filed bug 50748 to deal with setContentLength() improvements.\n\n\n(In reply to comment #4)\n> Regarding the content length. So I guess that should be then like this?\n> response.setContentLength(data.getBytes(\"UTF-8\").length);\n> \n\nIf you already called getBytes() then use byte[] array that it returns and pass to an OutputStream. You won't need a Writer. There is no need to do the double work."}, {"count": 7, "tags": [], "bug_id": 50747, "attachment_id": null, "is_private": false, "id": 144114, "time": "2011-02-09T17:19:51Z", "creator": "markt@apache.org", "creation_time": "2011-02-09T17:19:51Z", "text": "This issue is part useful discussion, part bug.\n\nThe bug part has moved to 50748 and the discussion should move to the users mailing list.\n\n*** This bug has been marked as a duplicate of bug 50748 ***"}, {"count": 8, "tags": [], "bug_id": 50747, "text": "Just for the sake of completeness: I've changed the code to\n\nString data = \"...\";\nbyte[] buf = data.getBytes(charset);\nresponse.setContentLength(buf.length);\nresponse.getOutputStream().write(buf);\nresponse.getOutputStream().flush();\ncometEvent.close();", "id": 144126, "time": "2011-02-10T03:03:12Z", "creator": "frank.schroeder@gmail.com", "creation_time": "2011-02-10T03:03:12Z", "is_private": false, "attachment_id": null}]