[{"count": 0, "tags": [], "creator": "yu.lin.86@gmail.com", "attachment_id": 29021, "id": 160404, "time": "2012-07-02T21:19:45Z", "bug_id": 53498, "creation_time": "2012-07-02T21:19:45Z", "is_private": false, "text": "Created attachment 29021\nThe patch that may fix the atomicity violation bugs.\n\nMy name is Yu Lin. I'm a Ph.D. student in the CS department at\nUIUC. I'm currently doing research on mining Java concurrent library\nmisusages. I found some misusages of ConcurrentHashMap in Tomcat\n7.0.28, which may result in potential atomicity violation bugs or harm\nthe performance.\n\nThe code below is a snapshot of the code in file\njava/org/apache/catalina/core/ApplicationContext.java from line 761 to\n767 and line 1262 to 1266\n\nL761        found = attributes.containsKey(name);\nL762        if (found) {\nL763            value = attributes.get(name);\nL764            attributes.remove(name);\nL765        } else {\nL766            return;\nL767        }\n            ...\nL1262       if (parameters.containsKey(name)) {\nL1263           return false;\nL1264       }\nL1265\nL1266       parameters.put(name, value);\n\nIn the code above, an atomicity violation may occur between lines 762\nand 763. Suppose thread T1 executes line 761 and finds that the\nconcurrent hashmap \"attributes\" contains the key \"name\". Before thread\nT1 executes line 763, another thread T2 removes the \"name\" key from\n\"attributes\". Now thread T1 resumes execution at line 763 and will get\na null value for \"name\". Then the next line will throw a\nNullPointerException when invoking the method on \"name\".\n\nSecond, the snapshot above has another atomicity violation. Let's look\nat lines 1262 and 1266. Suppose a thread T1 executes line 1262 and\nfinds out the concurrent hashmap dose not contain the key\n\"name\". Before it gets to execute line 1266, another thread T2 puts a\npair <name, v> in the concurrent hashmap \"parameters\". Now thread T1\nresumes execution and it will overwrite the value written by thread\nT2. Thus, the code no longer preserves the \"put-if-absent\" semantics.\n\nI found some similar misusages in other files:\n\nIn java/org/apache/catalina/ha/context/ReplicatedContext.java, similar\natomicity violation may occur when another thread T2 remove the key\n\"name\" from concurrent hashmap \"tomcatAttributes\" before thread T1\nexecutes line 172.\n\nIn java/org/apache/catalina/startup/HostConfig.java, suppose thread T1\nexecutes line 1480 and finds out the concurrent hashmap dose not\ncontain the key \"contextName\". Before it executes line 1509, another\nthread T2 puts a pair <contextName, v> in the concurrent hashmap\n\"deployed\". Now thread T1 resumes execution and it will overwrite the\nvalue written by thread T2. Indeed, the putIfAbsent method shoule be\nused rather than put method at line 1509."}, {"count": 1, "tags": [], "bug_id": 53498, "attachment_id": 29021, "id": 160405, "creation_time": "2012-07-02T21:22:31Z", "time": "2012-07-02T21:22:31Z", "creator": "markt@apache.org", "text": "Comment on attachment 29021\nThe patch that may fix the atomicity violation bugs.\n\nFix mime type so patch can be viewed in browser", "is_private": false}, {"count": 2, "tags": [], "bug_id": 53498, "attachment_id": null, "text": "Many thanks for the analysis and patch.\n\nThe first three issues look valid on initial inspection although I suspect a closer analysis will show that not all of them are valid due to broader constraints that mean the code is, in reality, single threaded. Regardless, these three are fixed in trunk and 7.0.x and will be included in 7.0.30 onwards. I used the provided patch as a starting point although I did make some changes to make the code a little cleaner.\n\nThe fourth issue is definitely not valid since a Host will never permit multiple children with the same name. This change was not included in the fix.", "id": 160456, "time": "2012-07-04T21:10:54Z", "creator": "markt@apache.org", "creation_time": "2012-07-04T21:10:54Z", "is_private": false}, {"count": 3, "tags": [], "bug_id": 53498, "text": "Hello,\n\n(In reply to comment #2)\n> Many thanks for the analysis and patch.\n>=\nYou are welcome. \n\n \n> Regardless,\n> these three are fixed in trunk and 7.0.x and will be included in 7.0.30\n> onwards. I used the provided patch as a starting point although I did make\n> some changes to make the code a little cleaner.\n> \nGreat.\n\n> The fourth issue is definitely not valid since a Host will never permit\n> multiple children with the same name. This change was not included in the\n> fix.\n\nI'm not an expert on the domain of Host. Is there some code that creates unique keys \"contextName\" every single time when a thread executes \"manageApp\" method? If not, there could be still an atomicity violation: suppose thread T1 finds that map \"deployed\" doesn't contain key \"contextName\", so it moves to calculate the value \"deployedApp\". Before T1 puts \"deployedApp\" into the map, another thread T2 checks if \"deployed\" map doesn't contain key \"contextName\" and so it moves to create the value \"deployedApp\" and put it into the map. Now thread T1 resumes execution and overwrites what T2 previously put.", "id": 160479, "time": "2012-07-06T22:58:48Z", "creator": "yu.lin.86@gmail.com", "creation_time": "2012-07-06T22:58:48Z", "is_private": false, "attachment_id": null}, {"count": 4, "tags": [], "bug_id": 53498, "attachment_id": null, "text": "probably a nit pick but the declarations really should be for ConcurrentMap not ConcurrentHashMap. There are variants of Concurrenthashmap coming in java8, and it's more correct to declare according to the interface", "id": 161091, "time": "2012-08-03T18:02:06Z", "creator": "mikebell90@yahoo.com", "creation_time": "2012-08-03T18:02:06Z", "is_private": false}]