[{"count": 0, "tags": [], "text": "Created attachment 32424\nXSSF some nonblank cells reporting as blank\n\nMy code just exports the Attributes tab of the attached spreadsheet.\n\nThe problematic cells are:\n\nAttribute Master tab\n\nRow 16 \n\nColumns N and P (values 500 and 10) reported as blank.\n\n\nThere are some others\n\nWhen I open the XLS in LibreOffice, the affected rows are SLIGHTLY thicker vertically than others. Strange.\n\ncode:\n\n  public List<String[]> extractList(XSSFSheet tab, Integer columnWidthLimit, boolean padToWidth, boolean skipHeaderRow)\n  {\n    List<String[]> rows = new ArrayList<>();\n    Iterator<Row> rowIterator = tab.iterator();\n\n    boolean first = true;\n    while (rowIterator.hasNext())\n    {\n      if (skipHeaderRow && first)\n      {\n        first = false;\n        continue;\n      }\n\n      Row row = rowIterator.next();\n      Iterator<Cell> cellIterator = row.cellIterator();\n      int cellCount = 0;\n      List<String> rowData = new ArrayList<>();\n      while (cellIterator.hasNext())\n      {\n        if (columnWidthLimit != null && cellCount >= columnWidthLimit)\n        {\n          break;\n        }\n        Cell cell = cellIterator.next();\n        if (cellCount == 5)\n        {\n          System.out.println(\"\" + rowData.get(4));\n        }\n        if (cellCount > 5)\n        {\n          System.out.print(\"::\" + cellCount + \"::\" + cell.getCellType() + \"::\");\n        }\n        switch (cell.getCellType())\n        {\n          case Cell.CELL_TYPE_BOOLEAN:\n            rowData.add(\"\" + cell.getBooleanCellValue());\n            break;\n          case Cell.CELL_TYPE_NUMERIC:\n            rowData.add(\"\" + cell.getNumericCellValue());\n            break;\n          case Cell.CELL_TYPE_STRING:\n            rowData.add(\"\" + cell.getStringCellValue());\n            break;\n          case Cell.CELL_TYPE_BLANK:\n            rowData.add(\"\");\n            break;\n          case Cell.CELL_TYPE_FORMULA:\n            rowData.add(\"#FORMULA\");\n            break;\n          case Cell.CELL_TYPE_ERROR:\n            rowData.add(\"#ERROR\");\n            break;\n          default:\n            rowData.add(\"#UNKNOWN\");\n            break;\n        }\n        if (cellCount > 5)\n        {\n          System.out.println(rowData.get(rowData.size() - 1));\n        }\n\n        cellCount++;\n      }\n      if (padToWidth && columnWidthLimit != null)\n      {\n        if (cellCount < columnWidthLimit)\n        {\n          for (int i = cellCount; i < columnWidthLimit; i++)\n          {\n            rowData.add(\"\");\n          }\n        }\n      }\n      rows.add(rowData.toArray(new String[rowData.size()]));\n    }\n    return rows;\n  }\n}", "attachment_id": 32424, "id": 180706, "creation_time": "2015-02-02T18:05:24Z", "time": "2015-02-02T18:05:24Z", "creator": "carlemueller@yahoo.com", "bug_id": 57523, "is_private": false}, {"count": 1, "tags": [], "bug_id": 57523, "attachment_id": null, "id": 180961, "time": "2015-02-11T15:56:55Z", "creator": "dominik.stadler@gmx.at", "creation_time": "2015-02-11T15:56:55Z", "is_private": false, "text": "Hmm, the code you pasted is very complicated and I am not sure how it shows the problem.\n\nWhen I do a very simple check, I can read those values just fine:\n\n    @Test\n    public void bug57523() {\n        Workbook wb = XSSFTestDataSamples.openSampleWorkbook(\"57523.xlsx\");\n        Sheet sheet = wb.getSheetAt(1);\n\n        Row row = sheet.getRow(1);\n        Cell cellN = row.getCell(CellReference.convertColStringToIndex(\"N\"));\n        assertEquals(500.0, cellN.getNumericCellValue(), 0.00001);\n        \n        Cell cellP = row.getCell(CellReference.convertColStringToIndex(\"P\"));\n        assertEquals(10.0, cellP.getNumericCellValue(), 0.00001);\n    }\n\n\nBased on that I am closing this as WORKSFORME for now, please work on your code to produce a simplified test-case which allows us to reproduce the problem more easily and then please reopen this bug."}, {"count": 2, "tags": [], "bug_id": 57523, "attachment_id": null, "id": 181441, "time": "2015-03-02T17:46:41Z", "creator": "carlemueller@yahoo.com", "creation_time": "2015-03-02T17:46:41Z", "is_private": false, "text": "You only tested rowindex ONE\n\nMy bug report indicates the SIXTEENTH (maybe 15 if indexing from 0th position) row exhibits the issue.\n\n... I'll make a better test case for you"}, {"count": 3, "tags": [], "text": "Oh, thanks for looking though.", "attachment_id": null, "id": 181442, "creator": "carlemueller@yahoo.com", "time": "2015-03-02T17:47:30Z", "bug_id": 57523, "creation_time": "2015-03-02T17:47:30Z", "is_private": false}, {"count": 4, "tags": [], "bug_id": 57523, "is_private": false, "id": 181448, "creation_time": "2015-03-02T19:02:56Z", "time": "2015-03-02T19:02:56Z", "creator": "carlemueller@yahoo.com", "text": "I'm going to doublecheck for stupidity and off-by-one errors", "attachment_id": null}, {"count": 5, "tags": [], "text": "Moving back to WORKSFORME. See Dominik's unit test in r1749267.\n\nPlease reopen if you provide a simplified test-case that could allow us to reproduce a problem. The while loop and two rowIterator consumers are likely to cause an indexing problem. You should try rewriting your code using the for-each row iterator \"for (Row row : sheet) { }\" for simpler code.", "is_private": false, "id": 191817, "creator": "onealj@apache.org", "time": "2016-06-20T06:31:40Z", "bug_id": 57523, "creation_time": "2016-06-20T06:31:40Z", "attachment_id": null}]