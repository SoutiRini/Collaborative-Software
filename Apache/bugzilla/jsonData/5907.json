[{"count": 0, "tags": [], "text": "Code modified and works below on windows.  Non-OS specific changes.\n\nModified:\n---------\n1. \norg.apache.tools.ant.taskdefs.ExecTask - added setWaitfor()\n\n2. \norg.apache.tools.ant.taskdefs.Execute - added setWaitfor(), enhanced waitFor()\n\n3. \norg.apache.tools.ant.taskdefs.PumpStreamHandler - bug - stop() now stops \ninstead of waiting indefinitely\n\nlook for tag @modification in code.  Submitted on behalf of Charles Hudak \n<CHudak@arrowheadgrp.com> by Kevin Ross <Kevin.Ross@Bredex.com>\n\n==========================\nExecute.java\n==========================\npackage org.apache.tools.ant.taskdefs;\n\nimport org.apache.tools.ant.BuildException;\nimport org.apache.tools.ant.Project;\nimport org.apache.tools.ant.Task;\nimport org.apache.tools.ant.types.Commandline;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.BufferedReader;\nimport java.io.StringReader;\nimport java.io.ByteArrayOutputStream;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Vector;\n\n/**\n * Runs an external program.\n *\n * @author thomas.haas@softwired-inc.com\n * @modification Charles Hudak <CHudak@arrowheadgrp.com> waitFor()\n */\npublic class Execute {\n\n    /** Invalid exit code. **/\n    public final static int INVALID = Integer.MAX_VALUE;\n\n    private String[] cmdl = null;\n    private String[] env = null;\n    private int exitValue = INVALID;\n    private ExecuteStreamHandler streamHandler;\n    private ExecuteWatchdog watchdog;\n    private File workingDirectory = null;\n    private Project project = null;\n    private boolean newEnvironment = false;\n    private boolean waitFor = true;\n    \n\n    /** Controls whether the VM is used to launch commands, where possible */\n    private boolean useVMLauncher = true;    \n    \n    private static String antWorkingDirectory = System.getProperty(\"user.dir\");\n    private static CommandLauncher vmLauncher = null;\n    private static CommandLauncher shellLauncher = null;\n    private static Vector procEnvironment = null;\n\n    /** \n     * Builds a command launcher for the OS and JVM we are running under\n     */\n    static {\n        // Try using a JDK 1.3 launcher\n        try {\n            vmLauncher = new Java13CommandLauncher();\n        }\n        catch ( NoSuchMethodException exc ) {\n            // Ignore and keep try\n        }\n\n        String osname = System.getProperty(\"os.name\").toLowerCase();\n        if ( osname.indexOf(\"mac os\") >= 0 ) {\n            // Mac\n            shellLauncher = new MacCommandLauncher(new CommandLauncher());\n        }\n        else if ( osname.indexOf(\"os/2\") >= 0 ) {\n            // OS/2 - use same mechanism as Windows 2000\n            shellLauncher = new WinNTCommandLauncher(new CommandLauncher());\n        }\n        else if ( osname.indexOf(\"windows\") >= 0 ) {\n            // Windows.  Need to determine which JDK we're running in\n            CommandLauncher baseLauncher;\n            if ( System.getProperty(\"java.version\").startsWith(\"1.1\") ) {\n                // JDK 1.1\n                baseLauncher = new Java11CommandLauncher();\n            }\n            else {\n                // JDK 1.2\n                baseLauncher = new CommandLauncher();\n            }\n\n            // Determine if we're running under 2000/NT or 98/95\n            if ( osname.indexOf(\"nt\") >= 0 || osname.indexOf(\"2000\") >= 0 ) {\n                // Windows 2000/NT\n                shellLauncher = new WinNTCommandLauncher(baseLauncher);\n            }\n            else {\n                // Windows 98/95 - need to use an auxiliary script\n                shellLauncher = new ScriptCommandLauncher(\"bin/antRun.bat\", \nbaseLauncher);\n            }\n        }\n        else {\n            // Generic\n            shellLauncher = new ScriptCommandLauncher(\"bin/antRun\", new \nCommandLauncher());\n        }\n    }\n\n    /**\n     * Find the list of environment variables for this process.\n     */\n    public static synchronized Vector getProcEnvironment() {\n        if (procEnvironment != null) return procEnvironment;\n\n        procEnvironment = new Vector();\n        try {\n            ByteArrayOutputStream out = new ByteArrayOutputStream();\n            Execute exe = new Execute(new PumpStreamHandler(out));\n            exe.setCommandline(getProcEnvCommand());\n            // Make sure we do not recurse forever\n            exe.setNewenvironment(true);\n            int retval = exe.execute();\n            if ( retval != 0 ) {\n                // Just try to use what we got\n            }\n\n            BufferedReader in = \n                new BufferedReader(new StringReader(out.toString()));\n            String var = null;\n            String line, lineSep = System.getProperty(\"line.separator\");\n            while ((line = in.readLine()) != null) {\n                if (line.indexOf('=') == -1) {\n                    // Chunk part of previous env var (UNIX env vars can\n                    // contain embedded new lines).\n                    if (var == null) {\n                        var = lineSep + line;\n                    }\n                    else {\n                        var += lineSep + line;\n                    }\n                }\n                else {\n                    // New env var...append the previous one if we have it.\n                    if (var != null) {\n                        procEnvironment.addElement(var);\n                    }\n                    var = line;\n                }\n            }\n            // Since we \"look ahead\" before adding, there's one last env var.\n            procEnvironment.addElement(var);\n        } \n        catch (java.io.IOException exc) {\n            exc.printStackTrace();\n            // Just try to see how much we got\n        }\n        return procEnvironment;\n    }\n\n    private static String[] getProcEnvCommand() {\n        String osname = System.getProperty(\"os.name\").toLowerCase();\n        if ( osname.indexOf(\"mac os\") >= 0 ) {\n            // Mac\n            // Determine if we are running under OS X\n            try {\n                String version = System.getProperty(\"os.version\");\n                int majorVersion = \n                    Integer.parseInt(version.substring(0, version.indexOf\n('.')));\n\n                if (majorVersion >= 10) {\n                    // OS X - just line UNIX\n                    String[] cmd = {\"/usr/bin/env\"};\n                    return cmd;\n                }\n            } catch (NumberFormatException e) {\n                // fall through to OS 9\n            }\n            // OS 9 and previous\n            // TODO: I have no idea how to get it, someone must fix it\n            String[] cmd = null;\n            return cmd;\n        }\n        else if ( osname.indexOf(\"os/2\") >= 0 ) {\n            // OS/2 - use same mechanism as Windows 2000\n            // Not sure\n            String[] cmd = {\"cmd\", \"/c\", \"set\" };\n            return cmd;\n        }\n        else if ( osname.indexOf(\"indows\") >= 0 ) {\n            // Determine if we're running under 2000/NT or 98/95\n            if ( osname.indexOf(\"nt\") >= 0 || osname.indexOf(\"2000\") >= 0 ) {\n                // Windows 2000/NT\n                String[] cmd = {\"cmd\", \"/c\", \"set\" };\n                return cmd;\n            }\n            else {\n                // Windows 98/95 - need to use an auxiliary script\n                String[] cmd = {\"command.com\", \"/c\", \"set\" };\n                return cmd;\n            }\n        }\n        else {\n            // Generic UNIX\n            // Alternatively one could use: /bin/sh -c env\n            String[] cmd = {\"/usr/bin/env\"};\n            return cmd;\n        }\n    }\n\n    /**\n     * Creates a new execute object using <code>PumpStreamHandler</code> for\n     * stream handling.\n     */\n    public Execute() {\n        this(new PumpStreamHandler(), null);\n    }\n\n\n    /**\n     * Creates a new execute object.\n     *\n     * @param streamHandler the stream handler used to handle the input and\n     *        output streams of the subprocess.\n     */\n    public Execute(ExecuteStreamHandler streamHandler) {\n        this(streamHandler, null);\n    }\n\n    /**\n     * Creates a new execute object.\n     *\n     * @param streamHandler the stream handler used to handle the input and\n     *        output streams of the subprocess.\n     * @param watchdog a watchdog for the subprocess or <code>null</code> to\n     *        to disable a timeout for the subprocess.\n     */\n    public Execute(ExecuteStreamHandler streamHandler, ExecuteWatchdog \nwatchdog) {\n        this.streamHandler = streamHandler;\n        this.watchdog = watchdog;\n    }\n\n\n    /**\n     * Returns the commandline used to create a subprocess.\n     *\n     * @return the commandline used to create a subprocess\n     */\n    public String[] getCommandline() {\n        return cmdl;\n    }\n\n\n    /**\n     * Sets the commandline of the subprocess to launch.\n     *\n     * @param commandline the commandline of the subprocess to launch\n     */\n    public void setCommandline(String[] commandline) {\n        cmdl = commandline;\n    }\n\n    /**\n     * Set whether to propagate the default environment or not.\n     *\n     * @param newenv whether to propagate the process environment.\n     */\n    public void setNewenvironment(boolean newenv) {\n        newEnvironment = newenv;\n    }\n\n    /**\n     * Returns the environment used to create a subprocess.\n     *\n     * @return the environment used to create a subprocess\n     */\n    public String[] getEnvironment() {\n        if (env == null || newEnvironment) return env;\n        return patchEnvironment();\n    }\n\n\n    /**\n     * Sets the environment variables for the subprocess to launch.\n     *\n     * @param commandline array of Strings, each element of which has\n     * an environment variable settings in format <em>key=value</em> \n     */\n    public void setEnvironment(String[] env) {\n        this.env = env;\n    }\n\n    /**\n     * Sets the working directory of the process to execute.\n     *\n     * <p>This is emulated using the antRun scripts unless the OS is\n     * Windows NT in which case a cmd.exe is spawned,\n     * or MRJ and setting user.dir works, or JDK 1.3 and there is\n     * official support in java.lang.Runtime.\n     *\n     * @param wd the working directory of the process.\n     */\n    public void setWorkingDirectory(File wd) {\n        if (wd == null || wd.getAbsolutePath().equals(antWorkingDirectory))\n            workingDirectory = null;\n        else\n            workingDirectory = wd;\n    }\n\n    /**\n     * Set the name of the antRun script using the project's value.\n     *\n     * @param project the current project.\n     */\n    public void setAntRun(Project project) throws BuildException {\n        this.project = project;\n    }\n\n    /**\n     * Launch this execution through the VM, where possible, rather than through\n     * the OS's shell. In some cases and operating systems using the shell will \n     * allow the shell to perform additional processing such as associating an \n     * executable with a script, etc\n     *\n     * @param vmLauncher true if exec should launch through thge VM, \n     *                   false if the shell should be used to launch the \ncommand.\n     */\n    public void setVMLauncher(boolean useVMLauncher) {\n        this.useVMLauncher = useVMLauncher;\n    }\n    \n    /**\n     * Runs a process defined by the command line and returns its exit status.\n     *\n     * @return the exit status of the subprocess or <code>INVALID</code>\n     * @exception java.io.IOExcpetion The exception is thrown, if launching\n     *            of the subprocess failed\n     */\n    public int execute() throws IOException {\n        CommandLauncher launcher = vmLauncher != null ? vmLauncher : \nshellLauncher;\n        if (!useVMLauncher) {\n            launcher = shellLauncher;\n        }\n        \n        final Process process = launcher.exec(project, getCommandline(), \ngetEnvironment(), workingDirectory);\n        try {\n            streamHandler.setProcessInputStream(process.getOutputStream());\n            streamHandler.setProcessOutputStream(process.getInputStream());\n            streamHandler.setProcessErrorStream(process.getErrorStream());\n        } catch (IOException e) {\n            process.destroy();\n            throw e;\n        }\n        streamHandler.start();\n        \n        if (watchdog != null) \n            watchdog.start(process);\n        \n        waitFor(process);\n        \n        if (watchdog != null) \n            watchdog.stop();\n        \n        streamHandler.stop();\n        \n        if (watchdog != null) \n            watchdog.checkException();\n        \n        return getExitValue();\n    }\n\n    /**\n     * @modification Charles Hudak <CHudak@arrowheadgrp.com> \n     */\n    protected void waitFor(Process process) {\n\n        if (waitFor)\n        {\n            try {\n                \n                if(project != null) project.log(\"Execute.waitFor()...\", \nProject.MSG_DEBUG);\n                process.waitFor();\n                if(project != null) project.log(\"Execute.waitFor()...done.\", \nProject.MSG_DEBUG);\n                setExitValue(process.exitValue());\n            } \n            catch (InterruptedException e) {}\n        } \n        else {\n\n            setExitValue(0);\n        }\n    }\n    \n    public void setWaitfor(boolean wait)\n    {\n        this.waitFor = wait;\n    }    \n\n    protected void setExitValue(int value) {\n        exitValue = value;\n    }\n\n    public int getExitValue() {\n        return exitValue;\n    }\n\n    /**\n     * Patch the current environment with the new values from the user.\n     * @return the patched environment\n     */\n    private String[] patchEnvironment() {\n        Vector osEnv = (Vector) getProcEnvironment().clone();\n        for (int i = 0; i < env.length; i++) {\n            int pos = env[i].indexOf('=');\n            // Get key including \"=\"\n            String key = env[i].substring(0, pos+1);\n            int size = osEnv.size();\n            for (int j = 0; j < size; j++) {\n                if (((String)osEnv.elementAt(j)).startsWith(key)) {\n                    osEnv.removeElementAt(j);\n                    break;\n                }\n            }\n            osEnv.addElement(env[i]);\n        }\n        String[] result = new String[osEnv.size()];\n        osEnv.copyInto(result);\n        return result;\n    }\n\n    /**\n     * A utility method that runs an external command.  Writes the output and\n     * error streams of the command to the project log.\n     *\n     * @param task      The task that the command is part of.  Used for logging\n     * @param cmdline   The command to execute.\n     *\n     * @throws BuildException if the command does not return 0.\n     */\n    public static void runCommand(Task task, String[] cmdline) throws \nBuildException\n    {\n        try {\n            task.log(Commandline.toString(cmdline), Project.MSG_VERBOSE);\n            Execute exe = new Execute(new LogStreamHandler(task, \n                                                           Project.MSG_INFO,\n                                                           Project.MSG_ERR));\n            exe.setAntRun(task.getProject());\n            exe.setCommandline(cmdline);\n            int retval = exe.execute();\n            if ( retval != 0 ) {\n                throw new BuildException(cmdline[0] + \" failed with return \ncode \" + retval, task.getLocation());\n            }\n        } \n        catch (java.io.IOException exc) {\n            throw new BuildException(\"Could not launch \" + cmdline[0] + \": \" + \nexc, task.getLocation());\n        }\n    }\n\n    /**\n     * A command launcher for a particular JVM/OS platform.  This class is\n     * a general purpose command launcher which can only launch commands in\n     * the current working directory.\n     */\n    private static class CommandLauncher\n    {\n        /** \n         * Launches the given command in a new process.\n         *\n         * @param project       The project that the command is part of\n         * @param cmd           The command to execute\n         * @param env           The environment for the new process.  If null,\n         *                      the environment of the current proccess is used.\n         */\n        public Process exec(Project project, String[] cmd, String[] env) throws \nIOException\n        {\n            if (project != null) {\n                project.log(\"Execute:CommandLauncher: \" +\n                            Commandline.toString(cmd), Project.MSG_DEBUG);\n            }                            \n            return Runtime.getRuntime().exec(cmd, env);\n        }\n\n        /** \n         * Launches the given command in a new process, in the given working\n         * directory.\n         *\n         * @param project       The project that the command is part of\n         * @param cmd           The command to execute\n         * @param env           The environment for the new process.  If null,\n         *                      the environment of the current proccess is used.\n         * @param workingDir    The directory to start the command in.  If null,\n         *                      the current directory is used\n         */\n        public Process exec(Project project, String[] cmd, String[] env, File \nworkingDir) throws IOException\n        {\n            if ( workingDir == null ) {\n                return exec(project, cmd, env);\n            }\n            throw new IOException(\"Cannot execute a process in different \ndirectory under this JVM\");\n        }\n    }\n\n    /**\n     * A command launcher for JDK/JRE 1.1 under Windows.  Fixes quoting problems\n     * in Runtime.exec().  Can only launch commands in the current working\n     * directory\n     */\n    private static class Java11CommandLauncher extends CommandLauncher\n    {\n        /**\n         * Launches the given command in a new process.  Needs to quote\n         * arguments\n         */\n        public Process exec(Project project, String[] cmd, String[] env) throws \nIOException \n        {\n            // Need to quote arguments with spaces, and to escape quote \ncharacters\n            String[] newcmd = new String[cmd.length];\n            for ( int i = 0; i < cmd.length; i++ ) {\n                newcmd[i] = Commandline.quoteArgument(cmd[i]);\n            }\n            if (project != null) {\n                project.log(\"Execute:Java11CommandLauncher: \" +\n                            Commandline.toString(newcmd), Project.MSG_DEBUG);\n            }                            \n            return Runtime.getRuntime().exec(newcmd, env);\n        }\n    }\n\n    /**\n     * A command launcher for JDK/JRE 1.3 (and higher).  Uses the built-in\n     * Runtime.exec() command\n     */\n    private static class Java13CommandLauncher extends CommandLauncher\n    {\n        public Java13CommandLauncher() throws NoSuchMethodException\n        {\n            // Locate method Runtime.exec(String[] cmdarray, String[] envp, \nFile dir)\n            _execWithCWD = Runtime.class.getMethod(\"exec\", new Class[] {String\n[].class, String[].class, File.class});\n        }\n\n        /** \n         * Launches the given command in a new process, in the given working\n         * directory\n         */\n        public Process exec(Project project, String[] cmd, String[] env, File \nworkingDir) \n            throws IOException\n        {\n            try {\n                if (project != null) {\n                    project.log(\"Execute:Java13CommandLauncher: \" +\n                                Commandline.toString(cmd), Project.MSG_DEBUG);\n                }                                \n                Object[] arguments = { cmd, env, workingDir };\n                return (Process)_execWithCWD.invoke(Runtime.getRuntime(), \narguments);\n            } \n            catch (InvocationTargetException exc) {\n                Throwable realexc = exc.getTargetException();\n                if ( realexc instanceof ThreadDeath ) {\n                    throw (ThreadDeath)realexc;\n                } \n                else if ( realexc instanceof IOException ) {\n                    throw (IOException)realexc;\n                } \n                else {\n                    throw new BuildException(\"Unable to execute command\", \nrealexc);\n                }\n            } \n            catch (Exception exc) {\n                // IllegalAccess, IllegalArgument, ClassCast\n                throw new BuildException(\"Unable to execute command\", exc);\n            }\n        }\n        \n        private Method _execWithCWD;\n    }\n    \n    /**\n     * A command launcher that proxies another command launcher.  \n     *\n     * Sub-classes override exec(args, env, workdir)\n     */\n    private static class CommandLauncherProxy extends CommandLauncher\n    {\n        CommandLauncherProxy(CommandLauncher launcher)\n        {\n            _launcher = launcher;\n        }\n\n        /** \n         * Launches the given command in a new process.  Delegates this\n         * method to the proxied launcher\n         */\n        public Process exec(Project project, String[] cmd, String[] env) throws \nIOException\n        {\n            return _launcher.exec(project, cmd, env);\n        }\n\n        private CommandLauncher _launcher;\n    }\n\n    /**\n     * A command launcher for Windows 2000/NT that uses 'cmd.exe' when\n     * launching commands in directories other than the current working\n     * directory.\n     */\n    private static class WinNTCommandLauncher extends CommandLauncherProxy\n    {\n        WinNTCommandLauncher(CommandLauncher launcher)\n        {\n            super(launcher);\n        }\n\n        /** \n         * Launches the given command in a new process, in the given working\n         * directory.\n         */\n        public Process exec(Project project, String[] cmd, String[] env, File \nworkingDir) throws IOException\n        {\n            File commandDir = workingDir;\n            if ( workingDir == null ) {\n                if ( project != null ) {\n                    commandDir = project.getBaseDir();\n                } else {\n                    return exec(project, cmd, env);\n                }\n            }\n\n            // Use cmd.exe to change to the specified directory before running\n            // the command\n            final int preCmdLength = 6;\n            String[] newcmd = new String[cmd.length + preCmdLength];\n            newcmd[0] = \"cmd\";\n            newcmd[1] = \"/c\";\n            newcmd[2] = \"cd\";\n            newcmd[3] = \"/d\";\n            newcmd[4] = commandDir.getAbsolutePath();\n            newcmd[5] = \"&&\";\n            System.arraycopy(cmd, 0, newcmd, preCmdLength, cmd.length);\n\n            return exec(project, newcmd, env);\n        }\n    }\n\n    /**\n     * A command launcher for Mac that uses a dodgy mechanism to change\n     * working directory before launching commands.\n     */\n    private static class MacCommandLauncher extends CommandLauncherProxy\n    {\n        MacCommandLauncher(CommandLauncher launcher)\n        {\n            super(launcher);\n        }\n\n        /** \n         * Launches the given command in a new process, in the given working\n         * directory\n         */\n        public Process exec(Project project, String[] cmd, String[] env, File \nworkingDir) throws IOException\n        {\n            if ( workingDir == null ) {\n                return exec(project, cmd, env);\n            }\n\n            System.getProperties().put(\"user.dir\", workingDir.getAbsolutePath\n());\n            try {\n                return exec(project, cmd, env);\n            } \n            finally {\n                System.getProperties().put(\"user.dir\", antWorkingDirectory);\n            }\n        }\n    }\n\n    /**\n     * A command launcher that uses an auxiliary script to launch commands\n     * in directories other than the current working directory.\n     */\n    private static class ScriptCommandLauncher extends CommandLauncherProxy\n    {\n        ScriptCommandLauncher(String script, CommandLauncher launcher)\n        {\n            super(launcher);\n            _script = script;\n        }\n\n        /** \n         * Launches the given command in a new process, in the given working\n         * directory\n         */\n        public Process exec(Project project, String[] cmd, String[] env, File \nworkingDir) throws IOException\n        {\n            if ( project == null ) {\n                if ( workingDir == null ) {\n                    return exec(project, cmd, env);\n                }\n                throw new IOException(\"Cannot locate antRun script: No project \nprovided\");\n            }\n            \n            // Locate the auxiliary script\n            String antHome = project.getProperty(\"ant.home\");\n            if ( antHome == null ) {\n                throw new IOException(\"Cannot locate antRun script: \nProperty 'ant.home' not found\");\n            }\n            String antRun = project.resolveFile(antHome + File.separator + \n_script).toString();\n\n            // Build the command\n            File commandDir = workingDir;\n            if ( workingDir == null && project != null ) {\n                commandDir = project.getBaseDir();\n            }\n\n            String[] newcmd = new String[cmd.length + 2];\n            newcmd[0] = antRun;\n            newcmd[1] = commandDir.getAbsolutePath();\n            System.arraycopy(cmd, 0, newcmd, 2, cmd.length);\n            \n            return exec(project, newcmd, env);\n        }\n\n        private String _script;\n    }\n}\n\n\n=================================================\nExecTask.java\n=================================================\n\npackage org.apache.tools.ant.taskdefs;\n\nimport org.apache.tools.ant.*;\nimport org.apache.tools.ant.types.*;\n\nimport java.io.*;\n\n/**\n * Executes a given command if the os platform is appropriate.\n *\n * @author duncan@x180.com\n * @author rubys@us.ibm.com\n * @author thomas.haas@softwired-inc.com\n * @author <a href=\"mailto:stefan.bodewig@epost.de\">Stefan Bodewig</a>\n * @author <a href=\"mailto:mariusz@rakiura.org\">Mariusz Nowostawski</a> \n * @modification Charles Hudak <CHudak@arrowheadgrp.com> setWaitFor()\n */\npublic class ExecTask extends Task {\n\n    private static String lSep = System.getProperty(\"line.separator\");\n\n    private String os;\n    private File out;\n    private File dir;\n    protected boolean failOnError = false;\n    protected boolean newEnvironment = false;\n    private Integer timeout = null;\n    private Environment env = new Environment();\n    protected Commandline cmdl = new Commandline();\n    private FileOutputStream fos = null;\n    private ByteArrayOutputStream baos = null;\n    private String outputprop;\n    private boolean waitFor = true;    \n\n    /** Controls whether the VM (1.3 and above) is used to execute the command \n*/\n    private boolean vmLauncher = true;\n    \n    /**\n     * Controls whether or not to wait for the process to finish.\n     *\n     * @Author Charles Hudak <CHudak@arrowheadgrp.com>\n     */\n    public void setWaitfor(boolean wait)\n    {\n        this.waitFor = wait;\n    }    \n    \n    /**\n     * Timeout in milliseconds after which the process will be killed.\n     */\n    public void setTimeout(Integer value) {\n        timeout = value;\n    }\n\n    /**\n     * The command to execute.\n     */\n    public void setExecutable(String value) {\n        cmdl.setExecutable(value);\n    }\n\n    /**\n     * The working directory of the process\n     */\n    public void setDir(File d) {\n        this.dir = d;\n    }\n\n    /**\n     * Only execute the process if <code>os.name</code> is included in this \nstring.\n     */\n    public void setOs(String os) {\n        this.os = os;\n    }\n\n    /**\n     * The full commandline to execute, executable + arguments.\n     */\n    public void setCommand(Commandline cmdl) {\n        log(\"The command attribute is deprecated. \" +\n            \"Please use the executable attribute and nested arg elements.\",\n            Project.MSG_WARN);\n        this.cmdl = cmdl;\n    }\n\n    /**\n     * File the output of the process is redirected to.\n     */\n    public void setOutput(File out) {\n        this.out = out;\n    }\n\n    /**\n     * Property name whose value should be set to the output of\n     * the process\n     */\n    public void setOutputproperty(String outputprop) {\n\tthis.outputprop = outputprop;\n    }\n\n    /**\n     * Throw a BuildException if process returns non 0.\n     */\n    public void setFailonerror(boolean fail) {\n        failOnError = fail;\n    }\n\n    /**\n     * Use a completely new environment\n     */\n    public void setNewenvironment(boolean newenv) {\n        newEnvironment = newenv;\n    }\n\n    /**\n     * Add a nested env element - an environment variable.\n     */\n    public void addEnv(Environment.Variable var) {\n        env.addVariable(var);\n    }\n\n    /**\n     * Add a nested arg element - a command line argument.\n     */\n    public Commandline.Argument createArg() {\n        return cmdl.createArgument();\n    }\n\n    /**\n     * Do the work.\n     */\n    public void execute() throws BuildException {\n        checkConfiguration();\n        if (isValidOs()) {\n            runExec(prepareExec());\n        }\n    }\n\n    /**\n     * Has the user set all necessary attributes?\n     */\n    protected void checkConfiguration() throws BuildException {\n        if (cmdl.getExecutable() == null) {\n            throw new BuildException(\"no executable specified\", location);\n        }\n        if (dir != null && !dir.exists()) {\n        \tthrow new BuildException(\"The directory you specified does not \nexist\");\n        }\n        if (dir != null && !dir.isDirectory()) {\n        \tthrow new BuildException(\"The directory you specified is not a \ndirectory\");\n        }\n    }\n\n    /**\n     * Is this the OS the user wanted?\n     */\n    protected boolean isValidOs() {\n        // test if os match\n        String myos = System.getProperty(\"os.name\");\n        log(\"Current OS is \" + myos, Project.MSG_VERBOSE);\n        if ((os != null) && (os.indexOf(myos) < 0)){\n            // this command will be executed only on the specified OS\n            log(\"This OS, \" + myos + \" was not found in the specified list of \nvalid OSes: \" + os, Project.MSG_VERBOSE);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Control whether the VM is used to launch the new process or\n     * whether the OS's shell is used.\n     */\n    public void setVMLauncher(boolean vmLauncher) {\n        this.vmLauncher = vmLauncher;\n    }\n    \n    /**\n     * Create an Execute instance with the correct working directory set.\n     * @modification Charles Hudak <CHudak@arrowheadgrp.com> setWaitFor()\n     */\n    protected Execute prepareExec() throws BuildException {\n        // default directory to the project's base directory\n        if (dir == null) dir = project.getBaseDir();\n        // show the command\n        log(cmdl.toString(), Project.MSG_VERBOSE);\n        \n        Execute exe = new Execute(createHandler(), createWatchdog());\n        exe.setAntRun(project);\n        exe.setWorkingDirectory(dir);\n        exe.setVMLauncher(vmLauncher);\n        exe.setWaitfor(this.waitFor);\n        if(this.waitFor){\n         \n            log(\"Waiting for process to complete...\", Project.MSG_INFO);\n        }\n        else{\n            \n            log(\"Spawning process without waiting to complete.\", \nProject.MSG_INFO); \n        }\n        \n        String[] environment = env.getVariables();\n        if (environment != null) {\n            for (int i=0; i<environment.length; i++) {\n                log(\"Setting environment variable: \"+environment[i],\n                    Project.MSG_VERBOSE);\n            }\n        }\n        exe.setNewenvironment(newEnvironment);\n        exe.setEnvironment(environment);\n        return exe;\n    }\n\n    /**\n     * A Utility method for this classes and subclasses to run an Execute \ninstance (an external command).\n     */\n    protected final void runExecute(Execute exe) throws IOException {\n        int err = -1; // assume the worst\n\n        err = exe.execute();\n        if (err != 0) {\n            if (failOnError) {\n                throw new BuildException(taskType + \" returned: \"+err, \nlocation);\n            } else {\n                log(\"Result: \" + err, Project.MSG_ERR);\n            }\n        }\n        if (baos != null) {\n            BufferedReader in = \n                new BufferedReader(new StringReader(baos.toString()));\n            String line = null;\n            StringBuffer val = new StringBuffer();\n            while ((line = in.readLine()) != null) {\n                if (val.length() != 0) {\n                    val.append(lSep);\n                }\n                val.append(line);\n            }\n            project.setProperty(outputprop, val.toString());\n        }\n    }\n    \n    /**\n     * Run the command using the given Execute instance. This may be overidden \nby subclasses\n     */\n    protected void runExec(Execute exe) throws BuildException {\n        exe.setCommandline(cmdl.getCommandline());\n        try {\n            runExecute(exe);\n        } catch (IOException e) {\n            throw new BuildException(\"Execute failed: \" + e, e, location);\n        } finally {\n            // close the output file if required\n            logFlush();\n        }\n    }\n\n    /**\n     * Create the StreamHandler to use with our Execute instance.\n     */\n    protected ExecuteStreamHandler createHandler() throws BuildException {\n        if(out!=null)  {\n            try {\n                fos = new FileOutputStream(out);\n                log(\"Output redirected to \" + out, Project.MSG_VERBOSE);\n                return new PumpStreamHandler(fos);\n            } catch (FileNotFoundException fne) {\n                throw new BuildException(\"Cannot write to \"+out, fne, location);\n            } catch (IOException ioe) {\n                throw new BuildException(\"Cannot write to \"+out, ioe, location);\n            }\n        } else if (outputprop != null) {\n\t    //\t    try {\n\t    baos = new ByteArrayOutputStream();\n\t    log(\"Output redirected to ByteArray\", Project.MSG_VERBOSE);\n\t    return new PumpStreamHandler(baos);\n        } else {\n            return new LogStreamHandler(this,\n                                        Project.MSG_INFO, Project.MSG_WARN);\n        }\n    }\n\n    /**\n     * Create the Watchdog to kill a runaway process.\n     */\n    protected ExecuteWatchdog createWatchdog() throws BuildException {\n        if (timeout == null) return null;\n        return new ExecuteWatchdog(timeout.intValue());\n    }\n\n    /**\n     * Flush the output stream - if there is one.\n     */\n    protected void logFlush() {\n        try {\n            if (fos != null) fos.close();\n            if (baos != null) baos.close();\n        } catch (IOException io) {}\n    }\n\n}\n\n\n=================================================\nPumpStreamHandler.java\n=================================================\n\npackage org.apache.tools.ant.taskdefs;\n\nimport java.io.InputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\n\n/**\n * Copies standard output and error of subprocesses to standard output and\n * error of the parent process.\n *\n * TODO: standard input of the subprocess is not implemented.\n *\n * @author thomas.haas@softwired-inc.com\n * @modification Charles Hudak <CHudak@arrowheadgrp.com> stop()\n */\npublic class PumpStreamHandler implements ExecuteStreamHandler {\n\n    private Thread inputThread;\n    private Thread errorThread;\n\n    private OutputStream out, err;\n\n    public PumpStreamHandler(OutputStream out, OutputStream err) {\n        this.out = out;\n        this.err = err;\n    }\n\n    public PumpStreamHandler(OutputStream outAndErr) {\n        this(outAndErr, outAndErr);\n    }\n\n    public PumpStreamHandler() {\n        this(System.out, System.err);\n    }\n\n    public void setProcessOutputStream(InputStream is) {\n        createProcessOutputPump(is, out);\n    }\n\n\n    public void setProcessErrorStream(InputStream is) {\n        createProcessErrorPump(is, err);\n    }\n\n\n    public void setProcessInputStream(OutputStream os) {\n    }\n\n\n    public void start() {\n        inputThread.start();\n        errorThread.start();\n    }\n\n\n    /**\n     * When stop() is called, stop listening and move on.  Thread.join() will \nwait,\n     *  therefore, put a short timeout on it.\n     *\n     *  @modification Charles Hudak <CHudak@arrowheadgrp.com>\n     */\n    public void stop() {\n        try {\n            inputThread.join(500);\n        } catch(InterruptedException e) {}\n        try {\n            errorThread.join(500);\n        } catch(InterruptedException e) {}\n        try {\n            err.flush();\n        } catch (IOException e) {}\n        try {\n            out.flush();\n        } catch (IOException e) {}\n    }\n    \n    protected OutputStream getErr() {\n        return err;\n    }\n\n    protected OutputStream getOut() {\n        return out;\n    }\n\n    protected void createProcessOutputPump(InputStream is, OutputStream os) {\n        inputThread = createPump(is, os);\n    }\n\n    protected void createProcessErrorPump(InputStream is, OutputStream os) {\n        errorThread = createPump(is, os);\n    }\n\n\n    /**\n     * Creates a stream pumper to copy the given input stream to the given \noutput stream.\n     */\n    protected Thread createPump(InputStream is, OutputStream os) {\n        final Thread result = new Thread(new StreamPumper(is, os));\n        result.setDaemon(true);\n        return result;\n    }\n\n}", "is_private": false, "id": 9709, "creator": "kevin.ross@bredex.com", "time": "2002-01-17T10:52:06Z", "bug_id": 5907, "creation_time": "2002-01-17T10:52:06Z", "attachment_id": null}, {"count": 1, "tags": [], "text": "Created attachment 1027\nExecTask.java", "is_private": false, "id": 9710, "creator": "kevin.ross@bredex.com", "time": "2002-01-17T10:53:20Z", "bug_id": 5907, "creation_time": "2002-01-17T10:53:20Z", "attachment_id": 1027}, {"count": 2, "text": "Created attachment 1028\nExecute.java", "creator": "kevin.ross@bredex.com", "attachment_id": 1028, "id": 9711, "time": "2002-01-17T10:53:41Z", "bug_id": 5907, "creation_time": "2002-01-17T10:53:41Z", "tags": [], "is_private": false}, {"count": 3, "tags": [], "bug_id": 5907, "attachment_id": 1029, "id": 9712, "time": "2002-01-17T10:54:01Z", "creator": "kevin.ross@bredex.com", "creation_time": "2002-01-17T10:54:01Z", "is_private": false, "text": "Created attachment 1029\nPumpStreamHandler.java"}, {"count": 4, "tags": [], "text": "*** Bug 4092 has been marked as a duplicate of this bug. ***", "is_private": false, "id": 29647, "creator": "conor@apache.org", "time": "2003-01-18T14:43:07Z", "bug_id": 5907, "creation_time": "2003-01-18T14:43:07Z", "attachment_id": null}, {"attachment_id": null, "tags": [], "bug_id": 5907, "is_private": false, "count": 5, "id": 37703, "time": "2003-05-23T23:36:21Z", "creator": "briank@iis.com", "creation_time": "2003-05-23T23:36:21Z", "text": "Has any validation of this patch been made yet?  Why is the status still \"NEW\"?"}, {"count": 6, "tags": [], "text": "Has this functionality been incorporated into the mainline code?  It fixes a \nseries of duplicates, which means there are quite a few people who depend on \nthis functionality; and there is already a new PR (18572) which is potentially \na duplicate, as well.\n\nWe've been using this patch for a year; however, we would prefer to move on to \n1.5.x without it because we'd rather not muck around with the core code.", "is_private": false, "id": 38739, "creator": "rblum@bobolink.net", "time": "2003-06-11T23:23:15Z", "bug_id": 5907, "creation_time": "2003-06-11T23:23:15Z", "attachment_id": null}, {"count": 7, "tags": [], "text": "IMO this patch didn\u00b4t get in because no one work with modified Sources. \nAttaching diff against current CVS HEAD, please commit. ", "is_private": false, "id": 38775, "creator": "vanHell@gmx.at", "time": "2003-06-12T19:19:17Z", "bug_id": 5907, "creation_time": "2003-06-12T19:19:17Z", "attachment_id": null}, {"count": 8, "text": "Created attachment 6783\npatch", "creator": "vanHell@gmx.at", "attachment_id": 6783, "id": 38776, "time": "2003-06-12T19:21:27Z", "bug_id": 5907, "creation_time": "2003-06-12T19:21:27Z", "tags": [], "is_private": false}, {"count": 9, "tags": [], "bug_id": 5907, "attachment_id": null, "id": 39505, "time": "2003-06-26T17:57:49Z", "creator": "vanHell@gmx.at", "creation_time": "2003-06-26T17:57:49Z", "is_private": false, "text": "*** Bug 18572 has been marked as a duplicate of this bug. ***"}, {"count": 10, "tags": [], "text": "the patch in this bug report introduces a new attribute waitfor for <exec/>\nthe default is false; if it is set to true ant will not wait for the process to \nfinish.\nComments ?", "is_private": false, "id": 41567, "creator": "antoine@apache.org", "time": "2003-07-26T17:40:28Z", "bug_id": 5907, "creation_time": "2003-07-26T17:40:28Z", "attachment_id": null}, {"count": 11, "text": "hmmm. A lot of people have wanted true spawning, running programs after Ant\nexits. Does this give us that functionality?", "creator": "stevel@apache.org", "attachment_id": null, "id": 41582, "time": "2003-07-27T04:27:06Z", "bug_id": 5907, "creation_time": "2003-07-27T04:27:06Z", "tags": [], "is_private": false}, {"count": 12, "tags": [], "text": "I have prepared something similar to the patch included in this report.\nI have tested on a shell script.\nIt works fine if I add in the script :\n    trap \"\" SIGHUP\nI am calling the new attribute spawn, rather than waitfor. So spawn has the \ndefault false (current behavior); when set to true ant does not wait for the \nprocess to finish, and does not log what the process is doing either.\n\n", "is_private": false, "id": 41589, "creator": "antoine@apache.org", "time": "2003-07-27T16:11:29Z", "bug_id": 5907, "creation_time": "2003-07-27T16:11:29Z", "attachment_id": null}, {"count": 13, "tags": [], "bug_id": 5907, "is_private": false, "id": 41636, "attachment_id": null, "creator": "antoine@apache.org", "creation_time": "2003-07-28T10:49:46Z", "time": "2003-07-28T10:49:46Z", "text": "I have fixed this in CVS.\nThe new attribute is called spawn. When set to true, it means that you want the \nprocess to run independently of ant.\nTo make things simple, I have disconnected completely the spawned process from \nant's stream handlers and logging system.\nI have tested my change on Solaris and on Windows 2000 with a simple script \nwhich does :\n\nrm test.log\nsleep 10\ntouch test.log\n\nthe script is still running after ant is finished and the test.log gets written.\n\nhere is my xml :\n\n<project name=\"exec\" default=\"default\">\n<target name=\"default\">\n<exec executable=\"C:/programme/cygwin/bin/sh.exe\" spawn=\"true\" os=\"Windows \n2000\">\n   <arg value=\"C:/dev/testant/titi.sh\"/>\n</exec>\n<exec executable=\"/usr/bin/sh\" spawn=\"true\" os=\"SunOS\">\n   <arg value=\"titi.sh\"/>\n</exec>\n</target>\n</project>\n"}, {"count": 14, "tags": [], "creator": "ddevienne@lgc.com", "attachment_id": null, "id": 41654, "creation_time": "2003-07-28T14:10:29Z", "time": "2003-07-28T14:10:29Z", "bug_id": 5907, "text": "Could you please test with a program (like java.exe/java) instead of a script \nplease? Also, adding the 'spawn' attribute to <java> would be extremely useful.\n\nThanks, --DD", "is_private": false}, {"count": 15, "tags": [], "bug_id": 5907, "attachment_id": null, "is_private": false, "id": 41659, "time": "2003-07-28T14:43:13Z", "creator": "antoine@apache.org", "creation_time": "2003-07-28T14:43:13Z", "text": "I will test with java.\nAlso concerning adding spawn attribute to the java task, I think someone emailed \nsome code (was it you DD ?). It will help me obviously on this front if there is \na good contribution."}, {"attachment_id": null, "tags": [], "bug_id": 5907, "is_private": false, "count": 16, "id": 41668, "time": "2003-07-28T16:04:24Z", "creator": "antoine@apache.org", "creation_time": "2003-07-28T16:04:24Z", "text": "The spawn attribute is working with Java on Win 2000 and Solaris.\n"}, {"count": 17, "tags": [], "creator": "antoine@apache.org", "attachment_id": null, "id": 41778, "creation_time": "2003-07-30T14:25:21Z", "time": "2003-07-30T14:25:21Z", "bug_id": 5907, "text": "The spawn attribute has been added to the Java task and there is one testcase \ntoo, similar (in java) to the test for <exec spawn=\"true\"> (sleep 4 seconds and \nwrite a temporary file).\n", "is_private": false}, {"attachment_id": null, "tags": [], "bug_id": 5907, "is_private": false, "count": 18, "id": 43013, "time": "2003-08-19T19:07:56Z", "creator": "antoine@apache.org", "creation_time": "2003-08-19T19:07:56Z", "text": "*** Bug 22553 has been marked as a duplicate of this bug. ***"}, {"count": 19, "text": "*** Bug 22710 has been marked as a duplicate of this bug. ***", "creator": "bodewig@apache.org", "attachment_id": null, "id": 43314, "time": "2003-08-26T07:36:59Z", "bug_id": 5907, "creation_time": "2003-08-26T07:36:59Z", "tags": [], "is_private": false}]