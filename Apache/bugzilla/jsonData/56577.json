[{"count": 0, "attachment_id": null, "bug_id": 56577, "text": "The executor service to process SendHandler for sendAsync calls is initialized in WsServerContainer, which is using an unbounded queue. \n\nThus, no more than corePoolSize threads will ever be created. (And the value of the maximumPoolSize therefore doesn't have any effect.)  [1]\n\nThe corePoolSize has a default value to be 1, though it could be changed by context parameter, it's still hard to find an optimized value.\n\nThis will create an issue if using the SendHandler to close the session after sending the last message. An example stack trace is like the following:\n\n\n\"WebSocketServer-/spring-websocket-test-1\" daemon prio=10 tid=0x00007f9f040ec000 nid=0x7499 waiting on condition [0x00007f9f73af8000]\n   java.lang.Thread.State: TIMED_WAITING (parking)\n        at sun.misc.Unsafe.park(Native Method)\n        - parking to wait for  <0x000000075d52f018> (a java.util.concurrent.CountDownLatch$Sync)\n        at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:226)\n        at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedNanos(AbstractQueuedSynchronizer.java:1033)\n        at java.util.concurrent.locks.AbstractQueuedSynchronizer.tryAcquireSharedNanos(AbstractQueuedSynchronizer.java:1326)\n        at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:282)\n        at org.apache.tomcat.websocket.FutureToSendHandler.get(FutureToSendHandler.java:93)\n        at org.apache.tomcat.websocket.WsRemoteEndpointImplBase.startMessageBlock(WsRemoteEndpointImplBase.java:238)\n        at org.apache.tomcat.websocket.WsSession.sendCloseMessage(WsSession.java:487)\n        at org.apache.tomcat.websocket.WsSession.doClose(WsSession.java:418)\n        - locked <0x000000075d7dc388> (a java.lang.Object)\n        at org.apache.tomcat.websocket.WsSession.close(WsSession.java:395)\n        at org.apache.tomcat.websocket.WsSession.close(WsSession.java:389)\n        at com.tango.test.spring.test.service.DefaultSessionManager$CloseSessionHandler.onResult(DefaultSessionManager.java:133)\n        at org.apache.tomcat.websocket.WsRemoteEndpointImplBase$StateUpdateSendHandler.onResult(WsRemoteEndpointImplBase.java:1083)\n        at org.apache.tomcat.websocket.WsRemoteEndpointImplBase.endMessage(WsRemoteEndpointImplBase.java:320)\n        at org.apache.tomcat.websocket.WsRemoteEndpointImplBase$EndMessageHandler.onResult(WsRemoteEndpointImplBase.java:468)\n        at org.apache.tomcat.websocket.server.WsRemoteEndpointImplServer$OnResultRunnable.run(WsRemoteEndpointImplServer.java:234)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n        at java.lang.Thread.run(Thread.java:745)\n\n\n\nIf all the threads are in this state, there will be no available threads to clear any SendHandler and all Remote.send methods would throw TimeoutException though actually the clients could receive the messages.\n\n\n[1] http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ThreadPoolExecutor.html", "id": 175548, "time": "2014-05-29T19:17:17Z", "creator": "li.changgeng@gmail.com", "creation_time": "2014-05-29T19:17:17Z", "tags": [], "is_private": false}, {"count": 1, "tags": [], "creator": "markt@apache.org", "attachment_id": null, "id": 175687, "time": "2014-06-05T20:32:02Z", "bug_id": 56577, "creation_time": "2014-06-05T20:32:02Z", "is_private": false, "text": "Thanks for the report. I've had a long hard think about the desired behaviour and reconfigured the executor accordingly. The fix is in 8.0.x for 8.0.9 onwards and in 7.0.x for 7.0.55 onwards.\n\nThe short version is:\n- Core size is configurable but defaults to 0.\n- Threads die after 60s of inactivity\n- Thread pool grows unbounded if a new task is added and no thread is available to service it"}]