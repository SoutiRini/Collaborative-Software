[{"count": 0, "tags": [], "creator": "niklas+apache@appli.se", "attachment_id": null, "is_private": false, "id": 178445, "time": "2014-10-14T13:27:57Z", "bug_id": 57091, "creation_time": "2014-10-14T13:27:57Z", "text": "When using the Tomcat8 Websockets implementation in a Windows JRE 1.7.0_67 applet environment an AccessControlException occurs even though a policy allowing everything is in charge.\n\nException in thread \"anInnocuousThread\" java.security.AccessControlException: access denied (\"java.lang.RuntimePermission\" \"setContextClassLoader\")\n\tat java.security.AccessControlContext.checkPermission(Unknown Source)\n\tat java.security.AccessController.checkPermission(Unknown Source)\n\tat java.lang.SecurityManager.checkPermission(Unknown Source)\n\tat sun.plugin2.applet.AWTAppletSecurityManager.checkPermission(Unknown Source)\n\tat java.lang.Thread.setContextClassLoader(Unknown Source)\n\tat org.apache.tomcat.websocket.AsyncChannelGroupUtil$AsyncIOThreadFactory.newThread(AsyncChannelGroupUtil.java:112)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.<init>(Unknown Source)\n\tat java.util.concurrent.ThreadPoolExecutor.addWorker(Unknown Source)\n\tat java.util.concurrent.ThreadPoolExecutor.execute(Unknown Source)\n\tat org.apache.tomcat.util.threads.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:161)\n\tat org.apache.tomcat.util.threads.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:141)\n\tat sun.nio.ch.AsynchronousChannelGroupImpl.executeOnPooledThread(Unknown Source)\n\tat sun.nio.ch.Invoker.invokeIndirectly(Unknown Source)\n\tat sun.nio.ch.Invoker.invoke(Unknown Source)\n\tat sun.nio.ch.Invoker.invoke(Unknown Source)\n\tat sun.nio.ch.WindowsAsynchronousSocketChannelImpl$ReadTask.completed(Unknown Source)\n\tat sun.nio.ch.Iocp$EventHandlerTask.run(Unknown Source)\n\tat java.lang.Thread.run(Unknown Source)\n\tat sun.misc.InnocuousThread.run(Unknown Source)\n\nThe problem is actually in the JVM which installs a null protection domain which fails every access checked operation.  Apparantly Oracle won't fix this, according to https://issues.apache.org/jira/browse/SSHD-332, but there is a workaround which is fairly easy.  It is modelled after the fix to the SSHD one found in the link above.\n\nIndex: /d/sd0h/h/niklas/java/workspace-1/Tomcat8/java/org/apache/tomcat/websocket/AsyncChannelGroupUtil.java\n===================================================================\n--- /d/sd0h/h/niklas/java/workspace-1/Tomcat8/java/org/apache/tomcat/websocket/AsyncChannelGroupUtil.java\t(revision 1630809)\n+++ /d/sd0h/h/niklas/java/workspace-1/Tomcat8/java/org/apache/tomcat/websocket/AsyncChannelGroupUtil.java\t(working copy)\n@@ -18,6 +18,8 @@\n \n import java.io.IOException;\n import java.nio.channels.AsynchronousChannelGroup;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.SynchronousQueue;\n import java.util.concurrent.ThreadFactory;\n@@ -106,12 +108,16 @@\n         private AtomicInteger count = new AtomicInteger(0);\n \n         @Override\n-        public Thread newThread(Runnable r) {\n-            Thread t = new Thread(r);\n-            t.setName(\"WebSocketClient-AsyncIO-\" + count.incrementAndGet());\n-            t.setContextClassLoader(this.getClass().getClassLoader());\n-            t.setDaemon(true);\n-            return t;\n+        public Thread newThread(final Runnable r) {\n+            return (Thread)AccessController.doPrivileged(new PrivilegedAction<Object>() {\n+        \tpublic Object run() {\n+        \t    Thread t = new Thread(r);\n+        \t    t.setName(\"WebSocketClient-AsyncIO-\" + count.incrementAndGet());\n+        \t    t.setContextClassLoader(this.getClass().getClassLoader());\n+        \t    t.setDaemon(true);\n+        \t    return t;\n+        \t}\n+            });\n         }\n     }\n }"}, {"text": "Does this still work if you narrow the doPrivileged() block to just the setContextClassLoader() call? If so provide an updated patch and I'll apply it. If not, why not?", "tags": [], "creator": "markt@apache.org", "attachment_id": null, "count": 1, "id": 178456, "time": "2014-10-14T19:26:50Z", "bug_id": 57091, "creation_time": "2014-10-14T19:26:50Z", "is_private": false}, {"count": 2, "tags": [], "bug_id": 57091, "attachment_id": null, "id": 178464, "time": "2014-10-14T22:16:33Z", "creator": "niklas+apache@appli.se", "creation_time": "2014-10-14T22:16:33Z", "is_private": false, "text": "(In reply to Mark Thomas from comment #1)\n> Does this still work if you narrow the doPrivileged() block to just the\n> setContextClassLoader() call? If so provide an updated patch and I'll apply\n> it. If not, why not?\n\nActually I haven't tested that, I may do that toorrow localtime (UTC+2).\nBut... I know for a fact that the AccessController failed other operations before that, inside the Thread constructor, but the exceptions were masked by inner try-clauses.\nIn a normal AccessController setup they wouldn't have failed, which is why I covered the whole thing in the doPrivileged.\n\nAs the problem is really that the method is called with the wrong AccessController setup established for all of the duraton, I thought it most safe to actually cover all of the code, even if not strictly required at this moment.\n\nBut as I said, I may do the tests tomorrow.\n\nI have a testcase btw, but in order to run it you need to sign the code and trust the ceritifcate in the browser which will run the test.  If you want it I can make a package."}, {"count": 3, "tags": [], "text": "A test case would be helpful, thank you.", "is_private": false, "id": 178480, "creator": "markt@apache.org", "time": "2014-10-15T12:46:37Z", "bug_id": 57091, "creation_time": "2014-10-15T12:46:37Z", "attachment_id": null}, {"count": 4, "tags": [], "text": "Created attachment 32117\nA simple websocket client\n\nA simple websocket client test.\nName it se/appli/test/WebsocketClientTest.java\nCompile, put in a jar, sign, call it test-signed.jar.\nInstall it somewhere in a web-catalog along with an html-file like:\n\n<html>\n  <head><title>WebsocketClientTest</title></head>\n  <body>\n    <object type=\"application/x-java-applet\" width=\"800\" height=\"600\">\n      <param name=\"code\" value=\"se.appli.test.WebsocketClientTest\"/>\n      <param name=\"archive\" value=\"test-signed.jar,websocket-api.jar,tomcat-websocket.jar,tomcat-util.jar,tomcat-juli.jar\"/>\n      <param name=\"uri\" value=\"ws://tomcat8.appli.se:8080/websocket/test\"/>\n    </object>\n  </body>\n</html>\n\nAlter the uri-parameter to somewhere a websocket will reply.\nAny websocket service that provides a greeting (e.g. an hello world websocket test) will suffice.\n\nAlso install the foloowing jar files in there:\n\nwebsocket-api.jar\ntomcat-websocket.jar\ntomcat-util.jar\ntomcat-juli.jar\n\nFire up a browser on a MS Windows box with a JRE7 installed, whcih is trusting the key you signed the applet with.\nLoad the HTML file.  Watch the AccessControlException come up in the console.", "is_private": false, "id": 178510, "creator": "niklas+apache@appli.se", "time": "2014-10-16T14:45:47Z", "bug_id": 57091, "creation_time": "2014-10-16T14:45:47Z", "attachment_id": 32117}, {"count": 5, "tags": [], "bug_id": 57091, "attachment_id": null, "id": 178682, "time": "2014-10-22T16:06:51Z", "creator": "markt@apache.org", "creation_time": "2014-10-22T16:06:51Z", "is_private": false, "text": "A note for folks trying to reproduce this, the Tomcat JARs need to be signed as well."}, {"count": 6, "tags": [], "bug_id": 57091, "attachment_id": null, "id": 178683, "time": "2014-10-22T19:33:35Z", "creator": "markt@apache.org", "creation_time": "2014-10-22T19:33:35Z", "is_private": false, "text": "Thanks for the test case. Very helpful.\n\nI can repeat this issue with Java 8 and Java 7 and I have applied your suggested patch to 8.0.x for 8.0.15 onwards and 7.0.x for 7.0.57 onwards.\n\nOn a related topic, would it be helpful at all if the Tomcat JARs were signed by the ASF (we recently started to use Symantec's code signing service). If this would be useful, please open a new enhancement request and we'll figure out how to fit JSAR signing into the build process."}, {"id": 178686, "tags": [], "creator": "niklas+apache@appli.se", "attachment_id": null, "count": 7, "text": "(In reply to Mark Thomas from comment #6)\n> Thanks for the test case. Very helpful.\n> \n> I can repeat this issue with Java 8 and Java 7 and I have applied your\n> suggested patch to 8.0.x for 8.0.15 onwards and 7.0.x for 7.0.57 onwards.\n> \n> On a related topic, would it be helpful at all if the Tomcat JARs were\n> signed by the ASF (we recently started to use Symantec's code signing\n> service). If this would be useful, please open a new enhancement request and\n> we'll figure out how to fit JSAR signing into the build process.\n\nSorry I forgot to tell the tomcat jars needed to be signed as well.\n\nI am not sure it will be helpful, maybe it will now, but at least at some point in time, mixed signers were not working too well in our applet setups, so we decided sign all jars ourselves, 3rd party or not, with our own certificate as a standard practice these days.  Of course we would have the potential to verify the jars' origin if they were signed, but we would still overwrite the signature with our own before deployment.\n\nThanks for including the fix, this way I don't need to have a customized tomcat version for our needs.", "time": "2014-10-22T21:29:26Z", "bug_id": 57091, "creation_time": "2014-10-22T21:29:26Z", "is_private": false}]