[{"count": 0, "tags": [], "creator": "patrickl@ihm.gov.mo", "attachment_id": null, "text": "Hi all,\nI have made some modifications on BoundSheetRecord.java (an ugly one\nthough) to support unicode(Chinese in my case) in sheetname.  Could\nsomebody review it, please.  I am willing to modify and/or refactor it.\n\nFor read in unicode support, this patch extends  protected void\nfillFields(byte [] data, short size, int offset) so that it will interpret BIFF8\nstructure as needed.  It 'REUSEs' the SSTDeserializer.manufactureStrings() as it\ncorrectly interpret the BIFF8  structure.\n\n'setSheetname' also modified to set the field4_compressed_unicode_flag\ndepending on whether sheetname is 16bit encoding string.\n\nTo write out unicode string,     public int serialize(int offset, byte []data)\nis extended.\n\nAttached below is the code.\n\nThanks\nPatrick Lee\n\n\n? unicodeSheetname.patch\nIndex: src/java/org/apache/poi/hssf/record/BoundSheetRecord.java\n===================================================================\nRCS file:\n/home/cvspublic/jakarta-poi/src/java/org/apache/poi/hssf/record/BoundSheetRecord.java,v\nretrieving revision 1.4\ndiff -u -r1.4 BoundSheetRecord.java\n--- src/java/org/apache/poi/hssf/record/BoundSheetRecord.java\t1 Mar 2002 13:27:10 -0000\t1.4\n+++ src/java/org/apache/poi/hssf/record/BoundSheetRecord.java\t8 Jul 2002 09:01:22 -0000\n@@ -54,7 +54,7 @@\n  */\n \n package org.apache.poi.hssf.record;\n-\n+import org.apache.poi.util.BinaryTree;\n import org.apache.poi.util.LittleEndian;\n import org.apache.poi.util.StringUtil;\n \n@@ -117,6 +117,16 @@\n         }\n     }\n \n+    /**\n+     *  lifted from SSTDeserializer\n+     */\n+\n+    private void arraycopy( byte[] src, int src_position,\n+                            byte[] dst, int dst_position,\n+                            int length )\n+    {\n+        System.arraycopy( src, src_position, dst, dst_position, length );\n+    }\n     protected void fillFields(byte [] data, short size, int offset)\n     {\n         field_1_position_of_BOF         = LittleEndian.getInt(data,\n@@ -125,8 +135,28 @@\n                 4 + offset);\n         field_3_sheetname_length        = data[ 6 + offset ];\n         field_4_compressed_unicode_flag = data[ 7 + offset ];\n-        field_5_sheetname               = new String(data, 8 + offset,\n-                LittleEndian.ubyteToInt( field_3_sheetname_length));\n+        //field_5_sheetname               = new String(data, 8 + offset,\n+        //        LittleEndian.ubyteToInt( field_3_sheetname_length));\n+        BinaryTree tempBT = new BinaryTree();\n+        SSTDeserializer deserializer;\n+        deserializer = new SSTDeserializer(        tempBT);\n+        int length = LittleEndian.ubyteToInt( field_3_sheetname_length);\n+        if ((field_4_compressed_unicode_flag & 0x01)==1) {\n+          byte [] newData = new byte[length*2 +3];\n+          arraycopy(data,7+offset,newData,2,length*2+1);\n+          LittleEndian.putShort(newData,0,(short)data[6+offset]);\n+//          System.out.println(\"calling manufactureStrings!\");\n+          deserializer.manufactureStrings(newData,0, (short)(length *2+3));\n+//          System.out.println(\"returned from manufactureStrings!\");\n+          field_5_sheetname = ((UnicodeString)tempBT.get(new\nInteger(0))).getString();\n+\n+          tempBT=null;\n+        }\n+        else {\n+          field_5_sheetname =   new String(data, 8 + offset,\n+              LittleEndian.ubyteToInt( field_3_sheetname_length));\n+        }\n+//        System.out.println(\"f_5_sn is \"+field_5_sheetname);\n     }\n \n     /**\n@@ -175,13 +205,39 @@\n     }\n \n     /**\n+     * Check if String use 16-bit encoding character\n+     * Lifted from SSTRecord.addString\n+     */\n+    public boolean is16bitString(String string)\n+    {\n+            // scan for characters greater than 255 ... if any are\n+            // present, we have to use 16-bit encoding. Otherwise, we\n+            // can use 8-bit encoding\n+            boolean useUTF16 = false;\n+            int strlen = string.length();\n+\n+            for ( int j = 0; j < strlen; j++ )\n+            {\n+                if ( string.charAt( j ) > 255 )\n+                {\n+                    useUTF16 = true;\n+                    break;\n+                }\n+            }\n+            return useUTF16 ;\n+   }\n+    /**\n      * Set the sheetname for this sheet.  (this appears in the tabs at the bottom)\n      * @param sheetname the name of the sheet\n      */\n \n     public void setSheetname(String sheetname)\n     {\n+        boolean is16bit = is16bitString(sheetname);\n+        setSheetnameLength((byte) sheetname.length() );\n+        setCompressedUnicodeFlag((byte ) (is16bit?1:0));\n         field_5_sheetname = sheetname;\n+\n     }\n \n     /**\n@@ -263,20 +319,34 @@\n     {\n         LittleEndian.putShort(data, 0 + offset, sid);\n         LittleEndian.putShort(data, 2 + offset,\n-                              ( short ) (0x08 + getSheetnameLength()));\n+                              ( short ) (0x08 + getSheetnameLength()*\n(getCompressedUnicodeFlag()==0?1:2)));\n         LittleEndian.putInt(data, 4 + offset, getPositionOfBof());\n         LittleEndian.putShort(data, 8 + offset, getOptionFlags());\n         data[ 10 + offset ] = getSheetnameLength();\n         data[ 11 + offset ] = getCompressedUnicodeFlag();\n \n-        // we assume compressed unicode (bein the dern americans we are ;-p)\n-        StringUtil.putCompressedUnicode(getSheetname(), data, 12 + offset);\n+        if (getCompressedUnicodeFlag()==0){\n+          // we assume compressed unicode (bein the dern americans we are ;-p)\n+          StringUtil.putCompressedUnicode(getSheetname(), data, 12 + offset);\n+        }\n+        else {\n+          try {\n+            StringUtil.putUncompressedUnicode(getSheetname(), data, 12 + offset);\n+  //          String unicodeString = new\nString(getSheetname().getBytes(\"Unicode\"),\"Unicode\");\n+  //          StringUtil.putUncompressedUnicode(unicodeString, data, 12 + offset);\n+          }\n+          catch (Exception e){\n+            System.out.println(\"encoding exception in\nBoundSheetRecord.serialize!\");\n+          }\n+\n+\n+        }\n         return getRecordSize();\n     }\n \n     public int getRecordSize()\n     {\n-        return 12 + getSheetnameLength();\n+        return 12 + getSheetnameLength()* (getCompressedUnicodeFlag()==0?1:2);\n     }\n \n     public short getSid()", "id": 19108, "time": "2002-07-08T09:14:59Z", "bug_id": 10548, "creation_time": "2002-07-08T09:14:59Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 10548, "text": "Created attachment 2331\nunicode name deserializing offered by Patrick Lee", "id": 19420, "time": "2002-07-12T16:19:59Z", "creator": "sergeikozello@mail.ru", "creation_time": "2002-07-12T16:19:59Z", "is_private": false, "attachment_id": 2331}, {"count": 2, "tags": [], "creator": "sergeikozello@mail.ru", "attachment_id": 2332, "text": "Created attachment 2332\nLet user to choose Unicode or no himself", "id": 19421, "time": "2002-07-12T16:20:58Z", "bug_id": 10548, "creation_time": "2002-07-12T16:20:58Z", "is_private": false}, {"count": 3, "tags": [], "creator": "sergeikozello@mail.ru", "attachment_id": 2333, "text": "Created attachment 2333\nAllowing lowlevel to choose Unicode or not", "id": 19422, "time": "2002-07-12T16:21:40Z", "bug_id": 10548, "creation_time": "2002-07-12T16:21:40Z", "is_private": false}, {"count": 4, "tags": [], "bug_id": 10548, "attachment_id": null, "id": 19424, "time": "2002-07-12T16:24:40Z", "creator": "sergeikozello@mail.ru", "creation_time": "2002-07-12T16:24:40Z", "is_private": false, "text": "Alowing User to choose if the sheet name will be Unicode or Compressed\nSo he can use it in usermodel as\nhssfWorkbook.setSheetName(0, \"UnicodeName\", HSSFWorkbook.ENCODING_UTF_16 );\nor\nhssfWorkbook.setSheetName(0, \"NotUnicodeName\", \nHSSFWorkbook.ENCODING_COMPRESSED_UNICODE );\n"}, {"count": 5, "tags": [], "bug_id": 10548, "text": "The getting and putting Unicode string now is simple.\nCheck it and use it. ;)\n\n\nIndex: src/java/org/apache/poi/hssf/record/BoundSheetRecord.java\n===================================================================\nRCS file: /home/cvspublic/jakarta-\npoi/src/java/org/apache/poi/hssf/record/BoundSheetRecord.java,v\nretrieving revision 1.4\ndiff -r1.4 BoundSheetRecord.java\n57a58,61\n> import java.io.*;\n> import java.io.UnsupportedEncodingException;\n> \n> import org.apache.poi.util.BinaryTree;\n59a64\n> import sun.awt.image.ByteInterleavedRaster;\n118a124,134\n>     \n>     /**\n>      *  UTF8:\n>      *\tsid + len + bof + flags + len(str) + unicode +   str\n> \t *\t 2  +  2  +  4  +   2   +    1     +    1    + len(str)\n> \t * \n> \t * \tUNICODE:\n>      *\tsid + len + bof + flags + len(str) + unicode +   str\n> \t *\t 2  +  2  +  4  +   2   +    1     +    1    + 2 * len(str)\n> \t * \n>      */\n122,130c138,150\n<         field_1_position_of_BOF         = LittleEndian.getInt(data,\n<                 0 + offset);\n<         field_2_option_flags            = LittleEndian.getShort(data,\n<                 4 + offset);\n<         field_3_sheetname_length        = data[ 6 + offset ];\n<         field_4_compressed_unicode_flag = data[ 7 + offset ];\n<         field_5_sheetname               = new String(data, 8 + offset,\n<                 LittleEndian.ubyteToInt( field_3_sheetname_length));\n<     }\n---\n>         field_1_position_of_BOF         = LittleEndian.getInt(data, 0 + \noffset);\t// bof\n>         field_2_option_flags            = LittleEndian.getShort(data, 4 + \noffset);\t// flags\n>         field_3_sheetname_length        = data[ 6 + offset ];\t\t\t\n\t\t\t// len(str)\n>         field_4_compressed_unicode_flag = data[ 7 + offset ];\t\t\t\n\t\t\t// unicode\n> \n> \t\tint nameLength = LittleEndian.ubyteToInt( \nfield_3_sheetname_length );\n>         if ( ( field_4_compressed_unicode_flag & 0x01 ) == 1 ) {\n> \t\t\tfield_5_sheetname = StringUtil.getFromUnicode( data, 8 \n+ offset, nameLength );\n>         }\n>         else {\n> \t\t\tfield_5_sheetname = new String( data, 8 + offset, \nnameLength );\n>         }\n> \t}\n172c192\n<     public void setCompressedUnicodeFlag(byte flag)\n---\n>     public void setCompressedUnicodeFlag( byte flag )\n181,182c201,202\n< \n<     public void setSheetname(String sheetname)\n---\n>     \n>     public void setSheetname( String sheetname )\n218c238,252\n<         return field_3_sheetname_length;\n---\n> \t\treturn field_3_sheetname_length;\n>     }\n> \n>     /**\n>      * get the length of the raw sheetname in characters\n>      * the length depends on the unicode flag\n>      * \n>      * @return number of characters in the raw sheet name\n>      */\n> \n>     public byte getRawSheetnameLength()\n>     {\n> \t\treturn (byte)( ( ( field_4_compressed_unicode_flag & 0x01 ) == \n1 )\n> \t\t\t\t\t\t? 2 * field_3_sheetname_length\n> \t\t\t\t\t\t: field_3_sheetname_length );\n265,266c299\n<         LittleEndian.putShort(data, 2 + offset,\n<                               ( short ) (0x08 + getSheetnameLength()));\n---\n>         LittleEndian.putShort( data, 2 + offset, (short)( 8 + \ngetRawSheetnameLength() ) );\n269c302\n<         data[ 10 + offset ] = getSheetnameLength();\n---\n>         data[ 10 + offset ] = (byte)( getSheetnameLength() );\n270a304,309\n>         \n>         if ( ( field_4_compressed_unicode_flag & 0x01 ) == 1 )\n> \t        StringUtil.putUncompressedUnicode( getSheetname(), data, 12 + \noffset );\n> \t    else\n> \t        StringUtil.putCompressedUnicode( getSheetname(), data, 12 + \noffset );\n> \t\t\n272,273d310\n<         // we assume compressed unicode (bein the dern americans we are ;-p)\n<         StringUtil.putCompressedUnicode(getSheetname(), data, 12 + offset);\n274a312,332\n>         \n> \t\t/*\n> \t\tbyte[] fake = new byte[] {\t(byte)0x85, 0x00, \t\t\n\t// sid\n> \t\t    \t\t\t\t\t\t\t0x1a, \n0x00, \t\t\t// length\n> \t\t    \t\t\t\t\t\t\t0x3C, \n0x09, 0x00, 0x00, // bof\n> \t\t    \t\t\t\t\t\t\t0x00, \n0x00, \t\t\t// flags\n> \t\t    \t\t\t\t\t\t\t0x09, \t\n\t\t\t\t// len( str )\n> \t\t    \t\t\t\t\t\t\t0x01, \t\n\t\t\t\t// unicode\n> \t\t    \t\t\t\t\t\t\t// <str>\n> \t\t    \t\t\t\t\t\t\t0x21, \n0x04, 0x42, 0x04, 0x40, 0x04, 0x30, 0x04, 0x3D, \n> \t\t    \t\t\t\t\t\t\t0x04, \n0x38, 0x04, 0x47, 0x04, 0x3A, 0x04, 0x30, 0x04   \n> \t\t    \t\t\t\t\t\t\t// \n</str>\n> \t\t    \t\t\t\t\t\t};\n> \t\t    \t\t\t\t\t\t\n> \t\t    \t\t\t\t\t\tsid + len + bof \n+ flags + len(str) + unicode +   str\n> \t\t    \t\t\t\t\t\t 2  +  2  +  4  \n+   2   +    1     +    1    + len(str)\n> \t\t\n> \t\tSystem.arraycopy( fake, 0, data, offset, fake.length );\n> \t\t\n> \t\treturn fake.length;\n> \t\t*/\n279,280c337,339\n<         return 12 + getSheetnameLength();\n<     }\n---\n>         // return 30;\n>         return 12 + getRawSheetnameLength();\n> \t}\n", "id": 19482, "time": "2002-07-13T19:53:27Z", "creator": "sergeikozello@mail.ru", "creation_time": "2002-07-13T19:53:27Z", "is_private": false, "attachment_id": null}, {"count": 6, "tags": [], "bug_id": 10548, "text": "Thank you ever so much for this patch.  In the future please create a single\npatch file if possible (makes it easier to apply and inspect), and add yourself\nto the @author tags of any class you modify (share the credit, share the blame). \n\nI attempted to apply the patch however I recieved the following unit test error\nafter applying the patch:\n\ntestSheetFunctionsErrorN/A\n\njava.lang.NullPointerException\nat\norg.apache.poi.hssf.usermodel.TestFormulas.testSheetFunctions(TestFormulas.java:782)\n0.090\n\nPlease try running the \"./build.sh clean compile test\"  -- this will do a clean\nbuild and execute the unit tests.  Let me know if you cannot replicate the problem.\n\nThanks, -Andy", "id": 19521, "time": "2002-07-15T01:52:29Z", "creator": "poi-support@buni.org", "creation_time": "2002-07-15T01:52:29Z", "is_private": false, "attachment_id": null}, {"count": 7, "tags": [], "bug_id": 10548, "text": "Created attachment 2422\nThe code for fixing unicode sheet name and unittests for it.", "id": 19899, "time": "2002-07-20T22:42:37Z", "creator": "sergeikozello@mail.ru", "creation_time": "2002-07-20T22:42:37Z", "is_private": false, "attachment_id": 2422}, {"count": 8, "tags": [], "creator": "sergeikozello@mail.ru", "attachment_id": 2423, "text": "Created attachment 2423\nUnit test for testing BoundSheetRecord", "id": 19900, "time": "2002-07-20T22:45:28Z", "bug_id": 10548, "creation_time": "2002-07-20T22:45:28Z", "is_private": false}, {"count": 9, "tags": [], "creator": "sergeikozello@mail.ru", "attachment_id": 2424, "text": "Created attachment 2424\nTool file for BoundSheetRecordTest", "id": 19901, "time": "2002-07-20T22:47:20Z", "bug_id": 10548, "creation_time": "2002-07-20T22:47:20Z", "is_private": false}, {"count": 10, "tags": [], "creator": "sergeikozello@mail.ru", "attachment_id": null, "text": "In the attaches: patches for the StringUtil and BoundSheetRecord with the unit \ntests for them.", "id": 19902, "time": "2002-07-20T22:49:29Z", "bug_id": 10548, "creation_time": "2002-07-20T22:49:29Z", "is_private": false}, {"count": 11, "tags": [], "bug_id": 10548, "text": "so I applied (new) #1 but not #2 and #3 yet.  \n\nA few issues:\n\n1. I'm not sure we want individual listeners to wrap the records.  I'm asking\nglen for his opinon.  It does not seem like a bad idea to me, but its 11:14p so\nmaybe I'm just tired :-)\n\n2. Regardles of that I don't like NameListener as the name because there is a\nNameRecord and pleanty of other things like it.  \"SheetNameListener\" strikes me\nas less ambiguous (confusing).\n\n3. The Unit test should be either rewritten or moved/renamed.  It tests the\nNameListener not the BoundSheetRecord.  Meaning there should be a test that\ndirectly tests the bound sheet.  We have a few unit tests that test\nmeta-functionality (like \"Does POI support formulas and specific ones\") for\nentire subsystems, but the rest are 1-1 with the class they test.\n\nThanks for your work.  I'll let you know what Glen and Avik think on #1 (I'll\nask avik on the list or maybe he'll see this).  \n\n-Andy", "id": 19905, "time": "2002-07-21T03:18:35Z", "creator": "poi-support@buni.org", "creation_time": "2002-07-21T03:18:35Z", "is_private": false, "attachment_id": null}, {"count": 12, "tags": [], "text": "*** Bug 10777 has been marked as a duplicate of this bug. ***", "attachment_id": null, "id": 19924, "creator": "poi-support@buni.org", "time": "2002-07-21T13:11:57Z", "bug_id": 10548, "creation_time": "2002-07-21T13:11:57Z", "is_private": false}, {"count": 13, "tags": [], "text": "Hi all\n\nI have refined the Unicode support for sheetname patch.  Including in this patch\nare refactoring of  SSTDeserializer & UnicodeString class to bring more code\nrelating to BIFF8 format from the former class to the latter class where it\nshould belong to. Please review it and consider for inclusion into the project\n\nThanks\nPatrick Lee\n\nNote: I have wrongly resubmit this as bug 10976", "attachment_id": null, "bug_id": 10548, "id": 19944, "time": "2002-07-22T03:24:51Z", "creator": "patrickl@ihm.gov.mo", "creation_time": "2002-07-22T03:24:51Z", "is_private": false}, {"count": 14, "tags": [], "text": "Created attachment 2430\nattachment of Unicode for sheetname & the refactored  SSTDeserializer & UnicodeString class", "attachment_id": 2430, "id": 19945, "creator": "patrickl@ihm.gov.mo", "time": "2002-07-22T03:28:39Z", "bug_id": 10548, "creation_time": "2002-07-22T03:28:39Z", "is_private": false}, {"count": 15, "tags": [], "creator": "poi-support@buni.org", "attachment_id": null, "text": "I had to back out this code, it is the cause of the current (suspected) size\nproblems.  To replicate run the HSSF test pattern\n\n(java org.apache.poi.hssf.dev.HSSF /tmp/outputfile.xls write)\n\nthen \n\n(java org.apache.poi.hssf.dev.BiffViewer /tmp/outputfile.xls) \n\nor write any file out and then read it.  POI throws some Record Format\nexceptions/etc.\n\n", "id": 20334, "time": "2002-07-28T22:44:28Z", "bug_id": 10548, "creation_time": "2002-07-28T22:44:28Z", "is_private": false}, {"count": 16, "tags": [], "bug_id": 10548, "text": "I had to back out this code, it is the cause of the current (suspected) getSize()\nproblems (http://nagoya.apache.org/bugzilla/show_bug.cgi?id=10393).  To\nreplicate run the HSSF test pattern\n\n(java org.apache.poi.hssf.dev.HSSF /tmp/outputfile.xls write)\n\nthen \n\n(java org.apache.poi.hssf.dev.BiffViewer /tmp/outputfile.xls) \n\nor write any file out and then read it.  POI throws some Record Format\nexceptions/etc.", "id": 20335, "time": "2002-07-28T22:47:11Z", "creator": "poi-support@buni.org", "creation_time": "2002-07-28T22:47:11Z", "is_private": false, "attachment_id": null}]