[{"count": 0, "tags": [], "creator": "apache@hrunting.org", "attachment_id": null, "is_private": false, "id": 36724, "time": "2003-05-05T21:44:39Z", "bug_id": 19685, "creation_time": "2003-05-05T21:44:39Z", "text": "I have a simple long-running CGI script.  When the browser user presses the \nstop button, the script under FreeBSD isn't receiving a TERM signal indicating \nthe connection has been closed.  Why?"}, {"count": 1, "tags": [], "text": "Please check some CGI FAQs; you'll find that there is no way to know that the\nclient is gone until the CGI tries to write some stuff to the client.", "is_private": false, "bug_id": 19685, "id": 37732, "time": "2003-05-24T17:25:12Z", "creator": "slive@apache.org", "creation_time": "2003-05-24T17:25:12Z", "attachment_id": null}, {"count": 2, "tags": [], "text": "Let me be a bit more specific.  I know that according to the CGI specification,\nthe server doesn't know the client has disconnected until the script writes\ndata.  However, when the script writes data to the closed socket (via STDOUT),\nthe server will normally terminate the script.  I've verified this under Solaris\nand Linux.  Under FreeBSD, this is not the case.  The same script under FreeBSD\n(a traceroute dump, in this case) just keeps going and going until completion. \nI can check myself for the status of my write, but I shouldn't have to.\n\nCan you confirm that?  FreeBSD in question is 4.6-STABLE.", "attachment_id": null, "bug_id": 19685, "id": 37739, "time": "2003-05-24T17:44:21Z", "creator": "apache@hrunting.org", "creation_time": "2003-05-24T17:44:21Z", "is_private": false}, {"count": 3, "tags": [], "creator": "james@squish.net", "attachment_id": null, "is_private": false, "id": 37781, "time": "2003-05-25T15:20:17Z", "bug_id": 19685, "creation_time": "2003-05-25T15:20:17Z", "text": "Why do you believe you should get a SIGTERM?  Do you mean a SIGPIPE?\n\nYour operating system should return EPIPE on a write() call where the other end \nhas gone, and if you haven't masked off the signal, a SIGPIPE.  You haven't \nsaid what language you're using, but you should check what the default signals \nare set to.  Perhaps under FreeBSD your language X is compiled in such a way \nthat SIGPIPE is ignored by default.  Try setting up a signal handler for \nSIGPIPE.\n\nAlternatively, perhaps you are writing to a buffered stream rather than using \nwrite() directly, and due to buffer sizes or default buffering schemes the \nlanguage you're using on FreeBSD is not actually trying to send the data yet.\n\nwrite(2) man page:\n\n       EPIPE  fd  is  connected to a pipe or socket whose reading\n              end is closed.  When this happens the writing  pro\u00ad\n              cess  will receive a SIGPIPE signal; if it catches,\n              blocks or ignores this the error EPIPE is returned.\n"}]