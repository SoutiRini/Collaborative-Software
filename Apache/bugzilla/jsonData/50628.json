[{"id": 143537, "tags": [], "bug_id": 50628, "is_private": false, "count": 0, "text": "Hi All,\n\nBelow issue i am facing:\nCore dump happens with Apache 2.2.15 using openssl 0.9.8n in stress test. Problem is happening under stress condition of normal http requests along with the additional condition of insecure client renegotiation requests generated. For insecure client renegotiation requests, \"SSLInsecureRenegotiation\" option is already set in the apache configuration.\n\nFollowing is the core trace:\n\n#0  0xc000000000203010:0 in memmove+0x350 ()\n     from /mnt1/4624XXXXXX/4624461128/packcore/libc.so.1\n  #1  0xc000000000a23a80:0 in buffer_write () at bf_buff.c:212\n  #2  0xc000000000947760:0 in BIO_write () at bio_lib.c:247\n  #3  0xc000000000a29cb0:0 in ssl3_write_pending () at s3_pkt.c:757\n  #4  0xc000000000a295e0:0 in do_ssl3_write () at s3_pkt.c:723\n  #5  0xc000000000a28e60:0 in ssl3_write_bytes () at s3_pkt.c:552\n  #6  0xc000000000a28ba0:0 in ssl3_do_write () at s3_both.c:132\n  #7  0xc000000000a2a380:0 in ssl3_send_server_hello () at\n  s3_srvr.c:1213\n  #8  0xc000000000a27410:0 in ssl3_accept () at s3_srvr.c:302\n  #9  0xc000000000a8d160:0 in SSL_accept () at ssl_lib.c:870\n  #10 0xc000000000ac2710:0 in ssl23_get_client_hello () at\n  s23_srvr.c:583\n  #11 0xc000000000ac24e0:0 in ssl23_accept () at s23_srvr.c:189\n  #12 0xc000000000a8d160:0 in SSL_accept () at ssl_lib.c:870\n  #13 0xc000000001108180:0 in <unknown_procedure> + 0x1a0 ()\n     from /mnt1/4624XXXXXX/4624461128/packcore/mod_ssl.so\n  #14 0xc0000000011093e0:0 in <unknown_procedure> + 0x120 ()\n     from /mnt1/4624XXXXXX/4624461128/packcore/mod_ssl.so\n  #15 0x40000000000c50d0:0 in ap_get_brigade () at util_filter.c:489\n  #16 0x4000000000075060:0 in ap_rgetline_core () at protocol.c:231\n  #17 0x4000000000076280:0 in read_request_line () at protocol.c:596\n  #18 0x40000000000778f0:0 in ap_read_request () at protocol.c:891\n  #19 0x40000000000c6900:0 in ap_process_http_connection () at\n  http_core.c:183\n  ---Type <return> to continue, or q <return> to quit---\n  #20 0x40000000000b9ba0:0 in ap_process_connection () at\n  connection.c:189\n  #21 0x40000000000debe0:0 in process_socket () at worker.c:590\n  #22 0x40000000000dffd0:0 in worker_thread () at worker.c:974\n  #23 0xc0000000005da320:0 in dummy_worker () at\n  threadproc/unix/thread.c:160\n  #24 0xc0000000000ea0e0:0 in __pthread_bound_body ()\n      at /ux/core/libs/threadslibs/src/common/pthreads/pthread.c:4612\n\nFurther to my problem mentioned below, I found possible flaw in Apache 2.2.15, which is mentioned below:\n \nIt is found with gdb that it is getting SIGSEGV as a result of accessing memory that is already free()ed.\n \nAfter looking at the source code, possible root cause is mentioned below:\n\nHere is the stack trace of free()ing the memoroy:\n \nBreakpoint 1, 0x9fffffffef6c0b60:0 in free+0x10 ()\n   from /usr/lib/hpux64/libdmalloc.so\n$308 = 0x60000000002b1d00\n#0  0x9fffffffef6c0b60:0 in free+0x10 () from /usr/lib/hpux64/libdmalloc.so\n#1  0x9fffffffeeeb3230:0 in CRYPTO_free (str=0x60000000002b1d00) at mem.c:402\n#2  0x9fffffffeef85200:0 in BIO_free (a=0x60000000002b1d00) at bio_lib.c:137\n#3  0x9fffffffeef86e20:0 in BIO_free_all (bio=0x0) at bio_lib.c:516\n#4  0x9fffffffeee8c670:0 in SSL_free (s=0x60000000000ab800) at ssl_lib.c:491\n#5  0x9fffffffef0cf450:0 in ssl_filter_io_shutdown (\n    filter_ctx=0x60000000002adaa0, c=0x60000000002ad1f8, abortive=1)\n    at ssl_engine_io.c:1001\n#6  0x9fffffffef0d0060:0 in ssl_io_filter_connect (\n    filter_ctx=0x60000000002adaa0) at ssl_engine_io.c:1160\n#7  0x9fffffffef0d1280:0 in ssl_io_filter_output (f=0x60000000002adad8,\n    bb=0x600000000019a210) at ssl_engine_io.c:1429\n#8  0x40000000000bfeb0:0 in ap_pass_brigade (next=0x60000000002adad8,\n    bb=0x600000000019a210) at util_filter.c:526\n#9  0x40000000000b5760:0 in ap_flush_conn (c=0x60000000002ad1f8)\n    at connection.c:84\n#10 0x40000000000b5870:0 in ap_lingering_close (c=0x60000000002ad1f8)\n    at connection.c:123\n#11 0x4000000000131e90:0 in process_socket (p=0x60000000002ad028,\n    sock=0x60000000002ad0a0, my_child_num=0, my_thread_num=0,\n    bucket_alloc=0x60000000002af028) at worker.c:545\n#12 0x4000000000133650:0 in worker_thread (thd=0x60000000000fec70,\n    dummy=0x600000000006fab0) at worker.c:894\n#13 0x9fffffffef72e740:0 in dummy_worker (opaque=0x60000000000fec70)\n    at threadproc/unix/thread.c:142\n#14 0x9fffffffef3ccc00:0 in __pthread_bound_body+0x190 ()\n   from /usr/lib/hpux64/libpthread.so.1\n \n \nThis is free()ing the address 0x60000000002b1d00.\n \nAnd then it is accessing this address again and getting SIGSEGV:\n \nProgram received signal SIGSEGV, Segmentation fault\n  si_code: 1 - SEGV_MAPERR - Address not mapped to object.\n0x9fffffffef0ccef0:0 in bio_filter_out_flush (bio=0x60000000002b1d00)\n    at ssl_engine_io.c:138\n138         if (!(outctx->blen || outctx->length)) {\n(gdb) bt\n#0  0x9fffffffef0ccef0:0 in bio_filter_out_flush (bio=0x60000000002b1d00)\n    at ssl_engine_io.c:138\n#1  0x9fffffffef0d1390:0 in ssl_io_filter_output (f=0x60000000002adad8,\n    bb=0x600000000019a210) at ssl_engine_io.c:1440\n#2  0x40000000000bfeb0:0 in ap_pass_brigade (next=0x60000000002adad8,\n    bb=0x600000000019a210) at util_filter.c:526\n#3  0x40000000000b5760:0 in ap_flush_conn (c=0x60000000002ad1f8)\n    at connection.c:84\n#4  0x40000000000b5870:0 in ap_lingering_close (c=0x60000000002ad1f8)\n    at connection.c:123\n#5  0x4000000000131e90:0 in process_socket (p=0x60000000002ad028,\n    sock=0x60000000002ad0a0, my_child_num=0, my_thread_num=0,\n    bucket_alloc=0x60000000002af028) at worker.c:545\n#6  0x4000000000133650:0 in worker_thread (thd=0x60000000000fec70,\n    dummy=0x600000000006fab0) at worker.c:894\n#7  0x9fffffffef72e740:0 in dummy_worker (opaque=0x60000000000fec70)\n    at threadproc/unix/thread.c:142\n#8  0x9fffffffef3ccc00:0 in __pthread_bound_body+0x190 ()\n   from /usr/lib/hpux64/libpthread.so.1\n \nHere is the explanation about my root cause analysis.\n \nWhen freeing(), ssl_filter_io_shutdown() calls SSL_free()\nand setting filter_ctx->pssl == NULL.\n \n=====\n    :\n    /* deallocate the SSL connection */\n    if (sslconn->client_cert) {\n        X509_free(sslconn->client_cert);\n        sslconn->client_cert = NULL;\n    }\n    SSL_free(ssl);\n    sslconn->ssl = NULL;\n    filter_ctx->pssl = NULL; /* so filters know we've been shutdown */\n    :\n    return APR_SUCCESS;\n=====\n \nHere seems to be the place where ssl_io_filter_connect()\nand bio_filter_out_flush() are called within ssl_io_filter_output:\n \n=====\n                :\n    if ((status = ssl_io_filter_connect(filter_ctx)) != APR_SUCCESS) {\n        return ssl_io_filter_error(f, bb, status);\n    }\n \n    while (!APR_BRIGADE_EMPTY(bb)) {\n        apr_bucket *bucket = APR_BRIGADE_FIRST(bb);\n \n        /* If it is a flush or EOS, we need to pass this down.\n         * These types do not require translation by OpenSSL.\n         */\n        if (APR_BUCKET_IS_EOS(bucket) || APR_BUCKET_IS_FLUSH(bucket)) {\n            if (bio_filter_out_flush(filter_ctx->pbioWrite) < 0) {\n                status = outctx->rc;\n                break;\n            }\n                :\n=====\n \nAt ssl_io_filter_connect() filter_ctx->pssl is already free()ed\nbut it is accessing it again at bio_filter_out_flush().\n \nThinking about the case for calling ssl_filter_io_shutdown(),I think it is terminating the connection so I think some error has happened.\nSo, I wonder ssl_io_filter_connect() should return error when it called ssl_filter_io_shutdown().\n \nLooking at the source around here....\n \n \n=====\n                :\nstatic int ssl_io_filter_connect(ssl_filter_ctx_t *filter_ctx)\n{\n                :\n    if ((n = SSL_accept(filter_ctx->pssl)) <= 0) {\n                :\n        return ssl_filter_io_shutdown(filter_ctx, c, 1);\n    }\n \n    if ((verify_result != X509_V_OK) ||\n        sslconn->verify_error)\n    {\n                :\n            ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, c,\n                         \"SSL client authentication failed: %s\",\n                         error ? error : \"unknown\");\n            ssl_log_ssl_error(APLOG_MARK, APLOG_INFO, c->base_server);\n \n            return ssl_filter_io_shutdown(filter_ctx, c, 1);\n        }\n    }\n \n \n                :\n \n    if ((sc->server->auth.verify_mode == SSL_CVERIFY_REQUIRE) &&\n        !sslconn->client_cert)\n    {\n        ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, c,\n                      \"No acceptable peer certificate available\");\n \n        return ssl_filter_io_shutdown(filter_ctx, c, 1);\n    }\n return APR_SUCCESS;\n}\n                :\n=====\n \nIn any case, it is just forwarding the return value of ssl_filter_io_shutdown() but I think we should return the error value after calling ssl_filter_io_shutdown().\nOtherwise, ssl_filter_io_shutdown() will return APR_SUCCESS when it was successfully shutdown the ssl connection.\n \nSo, the fix will be returning appropriate error code after calling ssl_filter_io_shutdown() in ssl_io_filter_connect().\n \nHow do you think about this analysis?\n \nIf you agree with this analysis, please implement the fix ASAP in Apache.\n\nConsidering the error code to be returned after calling\nssl_filter_io_shutdown\u2026\n \n        if (inctx->rc == APR_SUCCESS) {\n            inctx->rc = APR_EGENERAL;\n        }\n \n        return ssl_filter_io_shutdown(filter_ctx, c, 1);\n    }\n \nThis will be:\n \n        if (inctx->rc == APR_SUCCESS) {\n            inctx->rc = APR_EGENERAL;\n        }\n \n        ssl_filter_io_shutdown(filter_ctx, c, 1);\n       return ssl_err; /* set by SSL_get_error(). */\n    }\n \nFor this part:\n \n        else {\n            const char *error = sslconn->verify_error ?\n                sslconn->verify_error :\n                X509_verify_cert_error_string(verify_result);\n \n            ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, c,\n                         \"SSL client authentication failed: %s\",\n                         error ? error : \"unknown\");\n            ssl_log_ssl_error(APLOG_MARK, APLOG_INFO, c->base_server);\n \n            return ssl_filter_io_shutdown(filter_ctx, c, 1);\n        }\n \n \nthis will be:\n \n        else {\n            const char *error = sslconn->verify_error ?\n                sslconn->verify_error :\n                X509_verify_cert_error_string(verify_result);\n \n            ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, c,\n                         \"SSL client authentication failed: %s\",\n                         error ? error : \"unknown\");\n            ssl_log_ssl_error(APLOG_MARK, APLOG_INFO, c->base_server);\n \n            ssl_filter_io_shutdown(filter_ctx, c, 1);\n           return (verify_result?verify_result:SSL_ERROR_SSL);\n        }\n \nFor this:\n \n    if ((sc->server->auth.verify_mode == SSL_CVERIFY_REQUIRE) &&\n        !sslconn->client_cert)\n    {\n        ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, c,\n                      \"No acceptable peer certificate available\");\n \n        return ssl_filter_io_shutdown(filter_ctx, c, 1);\n    }\n \nwe may modify like:\n \n    if ((sc->server->auth.verify_mode == SSL_CVERIFY_REQUIRE) &&\n        !sslconn->client_cert)\n    {\n        ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, c,\n                      \"No acceptable peer certificate available\");\n \n        ssl_filter_io_shutdown(filter_ctx, c, 1);\n       return SSL_ERROR_SSL;\n    }\n \nAt least we can avoid the crash with above change because it won\u2019t return APR_SUCCESS.\n \nI just looked at Apache 2.2.8 as well as Apache 2.0.63 code and code is same as that of Apache 2.2.15 for ssl_filter_io_shutdown regarding returning APR_SUCCESS.\nSo just wondering how come no user has encountered this problem till now after using Apache 2.0.x and Apache 2.2.x after so many years.\n\n \nExpecting early reply to my analysis above.\n\nWe need to know whether this is a known issue with Apache 2.2.15 with openssl 0.9.8n  and any workaround available for this.", "time": "2011-01-21T00:52:18Z", "creator": "matty.roland1@gmail.com", "creation_time": "2011-01-21T00:52:18Z", "attachment_id": null}, {"count": 1, "tags": [], "bug_id": 50628, "attachment_id": null, "id": 195645, "creation_time": "2016-12-23T19:56:09Z", "time": "2016-12-23T19:56:09Z", "creator": "wrowe@apache.org", "text": "Since 0.9.8* release are long-since unsupported by the OpenSSL project,\ncan you reproduce under OpenSSL 1.0.1 or later and reopen, please?", "is_private": false}]