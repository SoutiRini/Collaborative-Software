[{"count": 0, "tags": [], "bug_id": 48895, "attachment_id": null, "is_private": false, "id": 135289, "time": "2010-03-11T22:20:01Z", "creator": "slaurent@apache.org", "creation_time": "2010-03-11T22:20:01Z", "text": "I think that the memory leak protection of WebAppClassLoader.clearReferencesThreadLocals() which detects and clears ThreadLocals that would prevent GC the WebAppClassLoader instance has issues regarding concurrency :\n\n- It enumerates Threads and looks into internal structures of the Thread class, but there are no \"memory barrier\" that would ensure a consistent state of the ThreadLocalMap being examined.\nSo, it is theoretically possible that a ThreadLocal in Thread A was properly cleaned up by the application, but the current thread B (that is undeploying the application) does not see the up to date state because there's no synchronization between those threads.\n\n- Much more severe : after detecting such a leak, it invokes java.lang.ThreadLocal.ThreadLocalMap.remove(ThreadLocal) on Thread A's ThreadLocalMap instance but the invocation is done by Thread B (the thread that undeploys the app). The remove() method is not thread safe at all, and nor is the expungeStaleEntries() method which may also be invoked in clearThreadLocalMap().\nSo, if a webapp is being undeployed while other applications continue to receive a heavy load of requests, this could corrupt the internal structures of the ThreadLocalMap instance !\n\nI propose to keep the detection of leaks as it is, but to make the actual clearing optional (and disabled by default) to avoid encountering big problems in production.\n\nIdea to improve the clearing in a safe way : if the thread that is \"provoking\" the leak is one of tomcat's worker threads, we could mark it as \"dirty\", and then have a background task that would end such threads (renew those threads in the pool)."}, {"count": 1, "tags": [], "bug_id": 48895, "attachment_id": null, "id": 135762, "time": "2010-03-29T15:04:58Z", "creator": "markt@apache.org", "creation_time": "2010-03-29T15:04:58Z", "is_private": false, "text": "This has been fixed in trunk and proposed for 6.0.x"}, {"count": 2, "text": "Thanks for the change.\nSo, I guess now we can safely clean thread locals only in threads controlled by tomcat (i.e. worker threads) and by one of these 2 methods :\n- either renew threads in the pool\n- cleanup all threadlocals after each request when the thread is returned to the pool (during the call to ThreadPoolExecutor.afterExecute() )", "creator": "slaurent@apache.org", "attachment_id": null, "id": 135764, "time": "2010-03-29T17:09:43Z", "bug_id": 48895, "creation_time": "2010-03-29T17:09:43Z", "tags": [], "is_private": false}, {"count": 3, "tags": [], "bug_id": 48895, "attachment_id": null, "id": 136275, "time": "2010-04-20T13:31:23Z", "creator": "markt@apache.org", "creation_time": "2010-04-20T13:31:23Z", "is_private": false, "text": "This has been made optional in 6.0.x and will be included in 6.0.27 onwards.\n\nI'll create a new BZ enhancement for Tomcat 7 to track the better ways of doing this."}, {"count": 4, "tags": [], "text": "If the only threads accessing the instances of a context are the connector's threads, and if you kill those threads when you remove a context, then you cannot have a leak.\n\nSadly, tomcat is ass backwards and has a pool of thread per connectors owned by the service instead of owned by the context. Thus you cannot destroy threads without destroying all context under all hosts under all engines under the service.\n\nSolution: destroying a context must mark a thread that visited it for termination, asap.\n\nThat means the thread would not return in the pool, and the pool would create a replacement thread.\n\nThat is subpar for other ctx/host/engine that would loose the threadlocal-cached values, but it is not a requirement for j2ee to be efficient under such operation, and the app is still supposed to work as it should expect a threadlocal to be null at any time.", "attachment_id": null, "id": 141105, "creator": "quartz12h@yahoo.com", "time": "2010-10-27T15:32:18Z", "bug_id": 48895, "creation_time": "2010-10-27T15:32:18Z", "is_private": false}]