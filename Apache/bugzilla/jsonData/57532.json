[{"count": 0, "attachment_id": null, "bug_id": 57532, "is_private": false, "id": 180745, "time": "2015-02-04T00:23:56Z", "creator": "andrew.jardine@jardineworks.com", "creation_time": "2015-02-04T00:23:56Z", "tags": [], "text": "Hi, - I suppose whether or not this is a bug depends on how you interpret it. I am using Tomcat 7.0.42 but I have also tried building all the way up to Tomcat 7.0.57 to see if any changes were made but to date nothing has. \n\nMy cluster configuration using the DeltaManager for session replication. I am using a multi-cast configuration rather than fixed nodes. My manager is configured as follows --\n\n<Manager className=\"org.apache.catalina.ha.session.DeltaManager\"\n                     expireSessionsOnShutdown=\"false\"\n                     notifyListenersOnReplication=\"true\"\n                />\n\n.. the most important being that I don't want sessions to expire on shutdown. My interpretation of this is that in a controlled shut down scenario whereby I initiate a proper shutdown of Node A in an A, B, C cluster, that the server will be shut down and the sessions on A retained on B and C. This works as expected for any session that is not marked as Primary on the node that is being shut down. Primary flagged sessions however are causing a message to be sent to all nodes in the cluster causing the sessions to be lost. If the server (process) is killed no sessions are lost. \n\nI traced this issue back to the following scenario.\n\nIn the StandardManager when a shutdown event occurs it is calling a session.expire(true). Since we have configured the DeltaSession as our implementation class I logically went there. the expire( boolean ) method in that class simply makes a call to an overloaded expire( boolean, boolean ) version where the second argument is statically passed as true. The second argument in the overloaded method is used as a flag to determine whether or not to notifyCluster.\n\nI forked the project (Tomcat 7.0.57 branch) and update the DeltaSession.expire( boolean ) method to use the following logic instead --\n\n   /**\n     * Perform the internal processing required to invalidate this session,\n     * without triggering an exception if the session has already expired.\n     *\n     * @param notify\n     *            Should we notify listeners about the demise of this session?\n     */\n    @Override\n    public void expire(boolean notify) {\n\n        boolean notifyCluster = true;\n\n        if ( manager instanceof DeltaManager ) \n            notifyCluster = ((DeltaManager)manager).isExpireSessionsOnShutdown();\n\n  \n        expire( notify, notifyCluster );\n\n    }\n\n.. which allows me to preserve the same configuration for all Session managers except the Delta configuration. I built this code and replaced my binaries and have confirmed that with this logic, session expire is not communicated during shutdown events to the cluster. \n\nTo me this seems like a defect which is why I am submitting this as an issue."}, {"count": 1, "attachment_id": null, "bug_id": 57532, "is_private": false, "id": 180755, "time": "2015-02-04T19:37:08Z", "creator": "markt@apache.org", "creation_time": "2015-02-04T19:37:08Z", "tags": [], "text": "StandardManager should be irrelevant since it isn't used for clustered web applications. The web application should be using DeltaManager.\n\nOn shutdown DeltaManager calls to two argument version of Session.expire() with the second argument set depending on expireSessionsOnShutdown.\n\nI'd like to see a stack trace that shows where the call to DeltaSession.expire() is coming from."}, {"count": 2, "attachment_id": null, "bug_id": 57532, "text": "Hey Mark,\n\nI'll try to grab those details for you. All I can say for the moment is that if I set a breakpoint in the DeltaManager class for the expire(boolean) method, then during shutdown it hits. The only way I was able to preserve my session replication was to modify that method. Perhaps I have configured my cluster incorrectly? -- here is my configuration. I'll try to find some time this weekend to get a thread dump for you. \n\n\nserver.xml --\n\n<Cluster className=\"org.apache.catalina.ha.tcp.SimpleTcpCluster\" channelSendOptions=\"6\">\n<Manager className=\"org.apache.catalina.ha.session.DeltaManager\"\n                  expireSessionsOnShutdown=\"false\"\n                  notifyListenersOnReplication=\"true\"/>\n      <Channel className=\"org.apache.catalina.tribes.group.GroupChannel\">\n            <Membership className=\"org.apache.catalina.tribes.membership.McastService\"\n                                   address=\"224.5.0.1\"\n                                   port=\"45564\"\n                                   frequency=\"500\"\n                                   dropTime=\"3000\"/>\n           <Receiver className=\"org.apache.catalina.tribes.transport.nio.NioReceiver\"\n                            address=\"auto\"\n                            port=\"4000\"\n                            selectorTimeout=\"5000\"\n                            maxThreads=\"25\"/>\n           <Sender className=\"org.apache.catalina.tribes.transport.ReplicationTransmitter\">\n                 <Transport className=\"org.apache.catalina.tribes.transport.nio.PooledParallelSender\"/>\n           </Sender>\n           <Interceptor className=\"org.apache.catalina.tribes.group.interceptors.TcpFailureDetector\"/>\n           <Interceptor className=\"org.apache.catalina.tribes.group.interceptors.MessageDispatch15Interceptor\"/>\n           <Interceptor className=\"org.apache.catalina.tribes.group.interceptors.ThroughputInterceptor\"/>\n</Channel>\n<ClusterListener className=\"org.apache.catalina.ha.session.ClusterSessionListener\"/>\n</Cluster>", "id": 180819, "time": "2015-02-06T02:48:51Z", "creator": "andrew.jardine@jardineworks.com", "creation_time": "2015-02-06T02:48:51Z", "tags": [], "is_private": false}, {"count": 3, "tags": [], "text": "(In reply to andrew jardine from comment #2)\n> Perhaps I have configured my cluster incorrectly? -- here is my configuration.\n>\n> [snip]\n\nYou need N > 0 nodes to make a cluster. Are they all configured identically? Maybe you have one of them still running BackupManager.", "attachment_id": null, "id": 180820, "creator": "chris@christopherschultz.net", "time": "2015-02-06T03:28:27Z", "bug_id": 57532, "creation_time": "2015-02-06T03:28:27Z", "is_private": false}, {"count": 4, "tags": [], "bug_id": 57532, "is_private": false, "id": 180829, "attachment_id": null, "creator": "andrew.jardine@jardineworks.com", "creation_time": "2015-02-06T14:50:14Z", "time": "2015-02-06T14:50:14Z", "text": "I have tried this with 2 nodes all the way up to 5 nodes -- all configured the same, all the same results. The odd thing is that it only seems to affect sessions that are marked as Primary on the node that is being shut down. For example.\n\nNode A                         Node B\nsession 1 (primary)            session 1\nsession 2                      session 2 (primary)\nsession 3                      session 3 (primary)\nsession 4 (primary)            session 4 \nsession 5 (primary)            session 5\n\n\nIf at this point I shutdown Node B, then session 2 and session 3 on Node A will be destroyed leaving me with -\n\nNode A                         Node B\nsession 1 (primary)            \nsession 4 (primary)            \nsession 5 (primary)            \n\n... but all nodes that were not primary do not appear to be sending the \"SESSION EXPIRE\" message to the cluster. \n\nI'll try to get that thread dump for you when I get a bit of breathing room at work."}, {"count": 5, "tags": [], "text": "You are missing:\n\n<ClusterListener className=\"org.apache.catalina.ha.session.JvmRouteSessionIDBinderListener\">\n\nI've just confirmed with my 4-node test cluster and the latest 7.0.x code that - providing this is present - the sessions fail over correctly when the current primary node is shutdown gracefully.", "attachment_id": null, "id": 180979, "creator": "markt@apache.org", "time": "2015-02-11T21:21:24Z", "bug_id": 57532, "creation_time": "2015-02-11T21:21:24Z", "is_private": false}, {"count": 6, "tags": [], "bug_id": 57532, "attachment_id": null, "id": 181605, "creation_time": "2015-03-09T13:59:29Z", "time": "2015-03-09T13:59:29Z", "creator": "andrew.jardine@jardineworks.com", "text": "Hey Mark,\n\nSorry for the delay -- other priorities came up. I'm trying this again right now, though I think I tried that as well already. Could be though that I did not have the session replication configured correctly when I tried it. If memory serves, this is what we found (though I am double checking this morning)\n\n1. We set the jvmRoute attribute on the <Engine /> envelope. Node 01 had a value of jvmRoute=\"01\", Node 02, a value of jvmRoute=\"02\" etc.\n\n2. We configured Apache to use a sticky session based on the jSessionID.\n\n3. This worked and my first request when to Node 01 so I ended up with a session id similar to :: ABCD1234567890-01\n\n4. All my subsequent traffic was routed to the 01 server.\n\n5. Shutdown 01.\n\n6. Apache started directing my requests to 02 -- but my jSessionID was now post-fixing the 02 jvmRoute value so I had -- ABCD1234567890-02 \n\n7. Node 02 did not find a session with that ID, so it was creating a new session. \n\n-- again, I could have not had the replication working properly perhaps so I'll do some more testing today and update this ticket with anything I find.", "is_private": false}, {"count": 7, "tags": [], "bug_id": 57532, "attachment_id": null, "id": 181606, "time": "2015-03-09T14:59:15Z", "creator": "andrew.jardine@jardineworks.com", "creation_time": "2015-03-09T14:59:15Z", "is_private": false, "text": "Hey Mark,\n\nUPDATE:\n\nI am seeing the same behaviour, even with the JvmRouteBinderValve. At first I enabled the jvmRoute, but that was problematic because, as previusly mentioned, the route was post fixed to the sessionid. I removed the jvmRoute, but LEFT the JvmRouteBinderValve and restarted everything.\n\nSession replication works. I have my 3 nodes behind an apache proxy that does RR load balancing to each of the nodes. When I shut down a node from the cluster, sometimes the session remains, other times it is lost. It appears, again, as though the primary node shut down is the problem.\n\nFor my requirements, the only time I would want a session expiration to be broadcast across the cluster is when a user logs out. The application handles this for me already so for Tomcat, the application server need only kill its own list of sessions on shut down. Perhaps my scenario is something that is outside the norm of what others/tomcat expects. Either way, the only solution I have found to date is to modify that method so that it does not default to broadcasting across the cluster."}]