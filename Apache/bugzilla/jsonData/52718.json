[{"count": 0, "tags": [], "creator": "lianggt08@sei.pku.edu.cn", "attachment_id": null, "id": 153962, "time": "2012-02-21T09:28:44Z", "bug_id": 52718, "creation_time": "2012-02-21T09:28:44Z", "is_private": false, "text": "The fix revision 424429 was aimed to remove an resource leak bug on the  SocketChannelobject   \"channel\"  in the method \"findJarServiceProvider\" of the file \n\n\"/tomcat/tc6.0.x/trunk/java/org/apache/tomcat/util/net/NioEndpoint.java\" , but it is incomplete. \n\nWhen the statements at lines 1142-1153 or line 1162 throw any eception, the object \"channel\" can not be closed as expected. The best way to close such resource object is putting such close operations in the finally block.\n\nThis problem is not handled in the head revision of tomcat 6.0 and also tomcat 7.0. \n\nThe code in the head revision needing to be inspected is as bellow: \n\npublic void run() {\n\n            // Loop until we receive a shutdown command\n            while (running) {\n                // Loop if endpoint is paused\n                while (paused) {\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e) {\n                        // Ignore\n                    }\n                }\n                boolean hasEvents = false;\n\n                hasEvents = (hasEvents | events());\n                // Time to terminate?\n                if (close) return;\n\n                int keyCount = 0;\n                try {\n                    keyCount = selector.select(selectorTimeout);\n                } catch (Throwable x) {\n                    log.error(\"\",x);\n                    continue;\n                }\n\n                //either we timed out or we woke up, process events first\n                if ( keyCount == 0 ) hasEvents = (hasEvents | events());\n\n                //if (keyCount == 0) continue;\n\n                Iterator iterator = keyCount > 0 ? selector.selectedKeys().iterator() : null;\n                // Walk through the collection of ready keys and dispatch\n                // any active event.\n                while (iterator != null && iterator.hasNext()) {\n                    SelectionKey sk = (SelectionKey) iterator.next();\n                    iterator.remove();\n                    KeyAttachment attachment = (KeyAttachment)sk.attachment();\n                    try {\n                        if ( sk.isValid() ) {\n                            if(attachment == null) attachment = new KeyAttachment();\n                            attachment.access();\n                            sk.attach(attachment);\n                            int readyOps = sk.readyOps();\n                            sk.interestOps(sk.interestOps() & ~readyOps);\n                            SocketChannel channel = (SocketChannel)sk.channel();\n [1142]                           boolean read = sk.isReadable();\n                            if (read) {\n                                if ( attachment.getWakeUp() ) {\n                                    attachment.setWakeUp(false);\n                                    synchronized (attachment.getMutex()) {attachment.getMutex().notifyAll();}\n                                } else if ( attachment.getComet() ) {\n                                    if (!processSocket(channel,false)) processSocket(channel,true);\n                                } else {\n                                    boolean close = (!processSocket(channel));\n                                    if ( close ) {\n                                        channel.socket().close();\n \u30101154\u3011                               channel.close();\n                                    }\n                                }\n                            }\n                        } else {\n                            //invalid key\n                            cancelledKey(sk);\n                        }\n                    } catch ( CancelledKeyException ckx ) {\n[1162]                        if (attachment!=null && attachment.getComet()) processSocket( (SocketChannel) sk.channel(), true);\n                        try {\n                            sk.channel().close();\n                        }catch ( Exception ignore){}\n                    } catch (Throwable t) {\n                        log.error(\"\",t);\n                    }\n                }//while\n                //process timeouts\n                timeout(keyCount,hasEvents);\n            }//while\n            synchronized (this) {\n                this.notifyAll();\n            }\n\n        }"}, {"count": 1, "tags": [], "bug_id": 52718, "attachment_id": null, "text": "r424429 was not targeted at a resource leak.\n\nThere is no method \"findJarServiceProvider\"\n\nThe code quoted doesn't appear in 6.0.x trunk, 7.0.x trunk or trunk.", "id": 154655, "time": "2012-03-07T21:33:11Z", "creator": "markt@apache.org", "creation_time": "2012-03-07T21:33:11Z", "is_private": false}, {"count": 2, "tags": [], "bug_id": 52718, "attachment_id": null, "text": "Sorry for my typo. \nThe method should be \"run()\", not \"findJarServiceProvider\". \n\nThe resource leak bug could happen on the SocketChannelobject   \"channel\"  in the method \"run()\" of the\nfile \"/tomcat/tc6.0.x/trunk/java/org/apache/tomcat/util/net/NioEndpoint.java\". \n\nThis problem is not handled in the head revision of tomcat 6.0 and also tomcat 7.0.\n\nPlease reconsider this problem.", "id": 154669, "time": "2012-03-08T02:00:03Z", "creator": "lianggt08@sei.pku.edu.cn", "creation_time": "2012-03-08T02:00:03Z", "is_private": false}, {"count": 3, "tags": [], "bug_id": 52718, "attachment_id": null, "text": "There are multiple run() methods in various classes in that file and none match the quoted above in 6.0.x, 7.0.x or trunk.", "id": 154764, "time": "2012-03-09T19:47:19Z", "creator": "markt@apache.org", "creation_time": "2012-03-09T19:47:19Z", "is_private": false}]