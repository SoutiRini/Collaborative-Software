[{"count": 0, "tags": [], "creator": "hornyakl@rootshell.be", "attachment_id": null, "id": 26064, "time": "2002-11-11T13:28:41Z", "bug_id": 14444, "creation_time": "2002-11-11T13:28:41Z", "is_private": false, "text": "Using stringbuffer for dynamicaly created string appendation may be faster.\npls mail me if you like patches like this. I could send lots.\n\nthx."}, {"count": 1, "tags": [], "bug_id": 14444, "is_private": false, "text": "Please check that diff again. It seems to have a bug:\nStringBuffer buf = new StrinfgBuffer();\n\nPlease run the compiler and test before submitting the patch. But yes, this \nkind of patch is interesting for us, especially because it's for the redesign.\nThanks.", "id": 26066, "time": "2002-11-11T13:43:18Z", "creator": "jeremias.maerki@outline.ch", "creation_time": "2002-11-11T13:43:18Z", "attachment_id": null}, {"count": 2, "tags": [], "bug_id": 14444, "attachment_id": null, "id": 26103, "creation_time": "2002-11-11T21:58:17Z", "time": "2002-11-11T21:58:17Z", "creator": "kevin@rocketred.com.au", "text": "Sorry if this seems hard but this is the sort of performance enhancement\nI was talking about yesterday. If people are going to do these sorts of\n\"enhancements\" then they should be aware of the effects.\n\nIt's always easier to work with examples.\n\npublic class StringTest\n{\n    // String Buffer\n    public String testStringBufferStraightCall()\n    {\n        StringBuffer sb = new StringBuffer();\n        \n        sb.append(\"this \");\n        sb.append(makeString(\"is \"));\n        sb.append(\"a \");\n        sb.append(makeString(\"test\"));\n\n        return sb.toString();\n    }\n\n    public String testStringBufferChained()\n    {\n        StringBuffer sb = new StringBuffer();\n\n        sb.append(\"this \")\n            .append(makeString(\"is \"))\n            .append(\"a \")\n            .append(makeString(\"test\"));\n\n        return sb.toString();\n    }\n\n    public String testStringAdd()\n    {\n        return\n            \"this \"\n            + makeString(\"is \")\n            + \"a \"\n            + makeString(\"test\");\n    }\n\n    public String testIncrement()\n    {\n        String result = \"this \";\n        result += makeString(\"is \");\n        result += \"a \";\n        result += makeString(\"test.\");\n\n        return result;\n    }\n\n    private String makeString(String testString)\n    {\n        return testString;\n    }\n}\n\nWhich of the above is faster?\n\nA simple timer test will show that testStringAdd() is the fastest,\nfollowed closely by testStringBufferChained(). For the reason why, lets\nlook at the byte-code.\n\nMethod java.lang.String testStringBufferStraightCall()\n   0 new #2 <Class java.lang.StringBuffer>\n   3 dup\n   4 invokespecial #3 <Method java.lang.StringBuffer()>\n   7 astore_1\n   8 aload_1\n   9 ldc #4 <String \"this \">\n  11 invokevirtual #5 <Method java.lang.StringBuffer\nappend(java.lang.String)>\n  14 pop\n  15 aload_1\n  16 aload_0\n  17 ldc #6 <String \"is \">\n  19 invokespecial #7 <Method java.lang.String\nmakeString(java.lang.String)>\n  22 invokevirtual #5 <Method java.lang.StringBuffer\nappend(java.lang.String)>\n  25 pop\n  26 aload_1\n  27 ldc #8 <String \"a \">\n  29 invokevirtual #5 <Method java.lang.StringBuffer\nappend(java.lang.String)>\n  32 pop\n  33 aload_1\n  34 aload_0\n  35 ldc #9 <String \"test\">\n  37 invokespecial #7 <Method java.lang.String\nmakeString(java.lang.String)>\n  40 invokevirtual #5 <Method java.lang.StringBuffer\nappend(java.lang.String)>\n  43 pop\n  44 aload_1\n  45 invokevirtual #10 <Method java.lang.String toString()>\n  48 areturn\n\nMethod java.lang.String testStringBufferChained()\n   0 new #2 <Class java.lang.StringBuffer>\n   3 dup\n   4 invokespecial #3 <Method java.lang.StringBuffer()>\n   7 astore_1\n   8 aload_1\n   9 ldc #4 <String \"this \">\n  11 invokevirtual #5 <Method java.lang.StringBuffer\nappend(java.lang.String)>\n  14 aload_0\n  15 ldc #6 <String \"is \">\n  17 invokespecial #7 <Method java.lang.String\nmakeString(java.lang.String)>\n  20 invokevirtual #5 <Method java.lang.StringBuffer\nappend(java.lang.String)>\n  23 ldc #8 <String \"a \">\n  25 invokevirtual #5 <Method java.lang.StringBuffer\nappend(java.lang.String)>\n  28 aload_0\n  29 ldc #9 <String \"test\">\n  31 invokespecial #7 <Method java.lang.String\nmakeString(java.lang.String)>\n  34 invokevirtual #5 <Method java.lang.StringBuffer\nappend(java.lang.String)>\n  37 pop\n  38 aload_1\n  39 invokevirtual #10 <Method java.lang.String toString()>\n  42 areturn\n\nMethod java.lang.String testStringAdd()\n   0 new #2 <Class java.lang.StringBuffer>\n   3 dup\n   4 invokespecial #3 <Method java.lang.StringBuffer()>\n   7 ldc #4 <String \"this \">\n   9 invokevirtual #5 <Method java.lang.StringBuffer\nappend(java.lang.String)>\n  12 aload_0\n  13 ldc #6 <String \"is \">\n  15 invokespecial #7 <Method java.lang.String\nmakeString(java.lang.String)>\n  18 invokevirtual #5 <Method java.lang.StringBuffer\nappend(java.lang.String)>\n  21 ldc #8 <String \"a \">\n  23 invokevirtual #5 <Method java.lang.StringBuffer\nappend(java.lang.String)>\n  26 aload_0\n  27 ldc #9 <String \"test\">\n  29 invokespecial #7 <Method java.lang.String\nmakeString(java.lang.String)>\n  32 invokevirtual #5 <Method java.lang.StringBuffer\nappend(java.lang.String)>\n  35 invokevirtual #10 <Method java.lang.String toString()>\n  38 areturn\n\nMethod java.lang.String testIncrement()\n   0 ldc #4 <String \"this \">\n   2 astore_1\n   3 new #2 <Class java.lang.StringBuffer>\n   6 dup\n   7 invokespecial #3 <Method java.lang.StringBuffer()>\n  10 aload_1\n  11 invokevirtual #5 <Method java.lang.StringBuffer\nappend(java.lang.String)>\n  14 aload_0\n  15 ldc #6 <String \"is \">\n  17 invokespecial #7 <Method java.lang.String\nmakeString(java.lang.String)>\n  20 invokevirtual #5 <Method java.lang.StringBuffer\nappend(java.lang.String)>\n  23 invokevirtual #10 <Method java.lang.String toString()>\n  26 astore_1\n  27 new #2 <Class java.lang.StringBuffer>\n  30 dup\n  31 invokespecial #3 <Method java.lang.StringBuffer()>\n  34 aload_1\n  35 invokevirtual #5 <Method java.lang.StringBuffer\nappend(java.lang.String)>\n  38 ldc #8 <String \"a \">\n  40 invokevirtual #5 <Method java.lang.StringBuffer\nappend(java.lang.String)>\n  43 invokevirtual #10 <Method java.lang.String toString()>\n  46 astore_1\n  47 new #2 <Class java.lang.StringBuffer>\n  50 dup\n  51 invokespecial #3 <Method java.lang.StringBuffer()>\n  54 aload_1\n  55 invokevirtual #5 <Method java.lang.StringBuffer\nappend(java.lang.String)>\n  58 aload_0\n  59 ldc #11 <String \"test.\">\n  61 invokespecial #7 <Method java.lang.String\nmakeString(java.lang.String)>\n  64 invokevirtual #5 <Method java.lang.StringBuffer\nappend(java.lang.String)>\n  67 invokevirtual #10 <Method java.lang.String toString()>\n  70 astore_1\n  71 aload_1\n  72 areturn\n\nSo the answer is the compiler converts String additions to\nStringBuffer.append(). Because it's done at the compiler level it can\nalso do optimizations that can't be done at the java code level (look at\nthe number of loads and pops). Quoting from the StringBuffer javadoc.\n\nString buffers are used by the compiler to implement the binary string\nconcatenation operator +. For example, the code:\n\n     x = \"a\" + 4 + \"c\"\n \n\nis compiled to the equivalent of:\n\n     x = new StringBuffer().append(\"a\").append(4).append(\"c\")\n                           .toString()\n \n\nSo the first recommendation is to use String \"+\" for this type of\nmethod, it's easier to read and runs faster.\n\nSo why would you use StringBuffer at all? Notice that the String\nconcatenation calls the no argument constructor for StringBuffer. On my\nvm this means that a 16 char StringBuffer is allocated, this means in\nthe sample above it will grow at least once creating garbage and\nallocating memory, both can be slow operations. So for large String\nconcatenation in PERFORMANCE SENSITIVE areas, create a StringBuffer of\nat least the size you need by calling StringBuffer(SIZE) and use chained\nStringBuffer calls. StringBuffers can carry a single instance through\nloops, String concatenation can't.\n\nNote: The hotspot vms are very hard to profile, especially in server\nsituations. You'll need to warm the code to ensure that hotspot has had\na chance to apply its optimizations.\n\nThis is in an area of code that is run once per invocation of the PDF\nwriter, there is no way this would show up as a hot spot in a profile.\nIt is better than += but it's harder to read. If these sort of\n\"optimizations\" are going to be done, then they should be done in an\ninformed manor and using an understanding of the effect to create truly\noptimized code rather than a sort of optimized mess. My opinion in this\ncase would be to convert it to use the \"+\" operator. It's not a\nperformance critical area, '\"foo\" + \"bar\"' is easier to read than\nsb.append(\"foo\").append(\"bar\") and lastly the next version of the\ncompiler may have some new optimizations that take care of the sizing\nissue.", "is_private": false}, {"count": 3, "tags": [], "text": "Kevin,\nThe original code was lots of string += operations, which is simple but slow.\nThe patch replaces it with StringBuffer operations.\n\nnotes:\n1. It didn`t became more difficult, did it?\n2. It became faster. 14% with my test, but if you write your own test, it wont\nbe slower then before.\n3. Yes, it is still not optimal. Maybe public \"void toPDF(OutputStream)\" could\nbe a more optimal solution.\n\nOh my god, it is sooo f*cking simple...", "is_private": false, "id": 26130, "creator": "hornyakl@rootshell.be", "time": "2002-11-12T12:20:10Z", "bug_id": 14444, "creation_time": "2002-11-12T12:20:10Z", "attachment_id": null}, {"count": 4, "tags": [], "text": "So, what should we do? Laszlo, can you please fix your diff as Jeremias suggested?", "attachment_id": null, "id": 27257, "creator": "oleg@tkachenko.com", "time": "2002-12-02T16:06:39Z", "bug_id": 14444, "creation_time": "2002-12-02T16:06:39Z", "is_private": false}, {"count": 5, "tags": [], "bug_id": 14444, "attachment_id": null, "text": "*** Bug 15022 has been marked as a duplicate of this bug. ***", "id": 27337, "time": "2002-12-03T17:00:52Z", "creator": "oleg@tkachenko.com", "creation_time": "2002-12-03T17:00:52Z", "is_private": false}, {"count": 6, "attachment_id": null, "creator": "oleg@tkachenko.com", "is_private": false, "id": 27338, "time": "2002-12-03T17:01:50Z", "bug_id": 14444, "creation_time": "2002-12-03T17:01:50Z", "tags": [], "text": "See resubmitted patch in bug #15022."}, {"count": 7, "tags": [], "bug_id": 14444, "attachment_id": null, "is_private": false, "id": 37160, "time": "2003-05-14T08:29:52Z", "creator": "jeremias@apache.org", "creation_time": "2003-05-14T08:29:52Z", "text": "The URL is not valid anymore and there have been discussions about the pros \nand cons of these optimizations. So we'll just leave it at that for the \nmoment. More pressing matters to follow. Closing entry..."}, {"count": 8, "tags": [], "text": "batch transition to closed remaining pre-FOP1.0 resolved bugs", "is_private": false, "id": 156754, "creator": "gadams@apache.org", "time": "2012-04-01T13:52:14Z", "bug_id": 14444, "creation_time": "2012-04-01T13:52:14Z", "attachment_id": null}]