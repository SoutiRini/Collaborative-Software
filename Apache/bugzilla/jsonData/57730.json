[{"count": 0, "tags": [], "bug_id": 57730, "text": "Created attachment 32588\nthe gui design for my pacingtimer plugin.\n\nWith parent mode on TransactionCotroller. \nThe isTransactionSampleEvent() on SampleEvent object always returns \"false\" even with TransactionSampler. \nPlease make it return \"TRUE\" with TransactionSampler not only \u201cnon parent mode\u201d but also \u201cparent mode\u201d\n\nReason) I am trying the develop the PacingTimer(similar functionality which is provided by commercial testing tools), and i want to define the target mode of \u201cIteration\u201d, \u201cTransaction\u201d and \u201cSampler\u201d to which applying the pacing time since many of people is familiar with Transaction pacing and Iteration pacing too. To implement this \u201cTransaction mode\u201d requirement, I need a way to say whether it is parent mode or not. \nI could modify the JmeterThread codes as below, however I never wants to touch the JMeter released build. \n\nHere what I tested for my requset, I had to change couple of code of JmeterThread.java\n<<<original>>>>\n(method : process_sampler)\nif(transactionSampler != null) {\n\t:\nnotifyListeners(transactionPack.getSampleListeners(), transactionResult);\n:\n}\n(mdthod notifyListeners)\nSampleEvent event = new SampleEvent(result, threadGroup.getName(), threadVars);\nnotifier.notifyListeners(event, listeners);\n\n    private void notifyListeners(List<SampleListener> listeners, SampleResult result, boolean isTransactionSampleEvent) {\n        SampleEvent event = new SampleEvent(result, threadGroup.getName(), threadVars,isTransactionSampleEvent);\n        notifier.notifyListeners(event, listeners);\n\n    }\n<<<<<changes .... >>>>\n(method : process_sampler)\nif(transactionSampler != null) {\n\t:\nnotifyListeners(transactionPack.getSampleListeners(), transactionResult, true);  //add parameter for transaction sampler\n:\n}\n (mdthod notifyListeners  )\nprivate void notifyListeners(List<SampleListener> listeners, SampleResult result) {\n    \tnotifyListeners(listeners,result,false);\n    }\n\nprivate void notifyListeners(List<SampleListener> listeners, SampleResult result, boolean isTransactionSampleEvent) {\n      SampleEvent event = new SampleEvent(result, threadGroup.getName(), threadVars,isTransactionSampleEvent);\n      notifier.notifyListeners(event, listeners);\n    }\n\n\n\nbest regards\nmyoung", "id": 181918, "time": "2015-03-20T05:49:14Z", "creator": "myoung@jadecross.com", "creation_time": "2015-03-20T05:49:14Z", "is_private": false, "attachment_id": 32588}, {"count": 1, "tags": [], "bug_id": 57730, "text": "Hello,\nThanks for your report, but it is not clear for me.\nCould you provide a patch ?\nAlso I am requalifying it as enhancement as it is related to a potential new feature.\nMaybe it would be better to rename it and provide the full patch for Pacing Timer.\n\nThanks\nRegards", "id": 181958, "time": "2015-03-22T18:13:50Z", "creator": "p.mouawad@ubik-ingenierie.com", "creation_time": "2015-03-22T18:13:50Z", "is_private": false, "attachment_id": null}, {"count": 2, "attachment_id": null, "creator": "myoung@jadecross.com", "text": "I have pasted the codes for my plugin(dynamic pacing time), at the moment this one works fine with 2.12 and 2.13 (excep the transaction parent mode). \n\nAm i attached the patch as  you asked? If not please let me know\n\nbest regards\nmyoung\n<--- timer code.---------------->\npackage myoung.jmeter.timer;\n\n\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nimport org.apache.jmeter.engine.event.LoopIterationEvent;\nimport org.apache.jmeter.engine.event.LoopIterationListener;\nimport org.apache.jmeter.testbeans.TestBean;\nimport org.apache.jmeter.testelement.AbstractTestElement;\nimport org.apache.jmeter.testelement.TestStateListener;\nimport org.apache.jmeter.testelement.property.JMeterProperty;\nimport org.apache.jmeter.timers.Timer;\nimport org.apache.jorphan.logging.LoggingManager;\nimport org.apache.log.Logger;\nimport org.apache.soap.providers.com.Log;\nimport org.apache.jmeter.threads.JMeterContextService;\nimport org.apache.jmeter.threads.JMeterVariables;\nimport org.apache.jmeter.control.TransactionSampler;\nimport org.apache.jmeter.samplers.SampleEvent;\nimport org.apache.jmeter.samplers.SampleResult;\nimport org.apache.jmeter.samplers.Sampler;\nimport org.apache.jmeter.samplers.SampleListener;\n\n\npublic class DynamicPacingTimer extends AbstractTestElement implements Timer, TestBean, SampleListener, LoopIterationListener {\n// Timer excluded\n//public class DynamicPacingTimer extends AbstractTestElement implements TestBean, SampleListener, LoopIterationListener {\n\n\tprivate static final long serialVersionUID = 7750524238843015040L;\n\tprivate static final Logger log = LoggingManager.getLoggerForClass();\n    private long previousTime =0;//??double -> long\n    private boolean isFirstIteration = true;\n    private boolean isRandomMaxSet = false;\n    // to calculate random timer\n\tprivate int randomMax; //will be used to calculate max\n\tprivate long pacingtimemin; //\n\tprivate java.util.Random randomgen = new java.util.Random();\n\t    \n    private boolean delaySamploccured = false; \n    \n    \n    // fields on the gui\n    private long pacingtime;\n\tprivate double percentmin;\n\tprivate double percentmax;\n    private PacingMode  pacingmode; // = PacingMode.modeIteration; \n    public enum PacingMode {\n        modeSampler(\"Pacingmode.1\"),\n        modeTransaction(\"Pacingmode.2\"),\n        modeIteration(\"Pacingmode.3\"),\n        ;\n        private final String propertyName; \n        \n        PacingMode(String  propertyName) {\n        \tthis.propertyName = propertyName;\n        }\n\n\n        public String toString() {\n            return propertyName;\n        }\n    }\t//end of PacingMode\n\n    \n\tpublic void setPacingtime(long pacingtime) {\n\t\tthis.pacingtime = pacingtime;\n\t\n\t\n\t}\n\t\n\tpublic long  getPacingtime() {\n    \treturn pacingtime;\n\t}    \n\n\t    \n\tpublic void setPercentmin(double percentmin) {\n\t\tthis.percentmin = percentmin;\n\t\n\t}\n\t\n\tpublic double getPercentmin() {\n    \treturn percentmin;\n\t}    \n\n\tpublic void setPercentmax(double percentmax) {\n\t\tthis.percentmax = percentmax;\n\t\t\n\t\tif (! isRandomMaxSet) { //this logic must be stay on the last \n\t\t\tthis.pacingtimemin = this.pacingtime;\n\t\t\tdouble pacingtimemax = this.pacingtime;\n\t\t\t\n\t\t\tdouble tmpDouble; \n\t\t\tif (this.percentmin > 0 ) { \n\t\t\t\ttmpDouble =   this.pacingtime * ((100.0 - this.percentmin) / 100.0);\n\t\t\t\tthis.pacingtimemin = (long)tmpDouble; \n\t\t\t}\n\t\t\tif (this.percentmax > 0 )  {    \n\t\t\t\tpacingtimemax =  this.pacingtime * ((100.0 + this.percentmax) / 100.0);\n\t\t\t}\n\t\t\tthis.randomMax = (int)( pacingtimemax - this.pacingtimemin);\t\n\t\t\t\n\t\t\tlog.debug(\"(pacingtime)\"+ this.pacingtime +  \" pacingmin:\"+pacingtimemin + \" randommax:\" +this.randomMax );\n\t\t\tisRandomMaxSet = true;\n\t\t}\n\t}\n\t\n\t\n\tpublic double getPercentmax() {\n    \treturn percentmax;\n\t}    \n\n\tpublic int getPacingmode() {\n         return pacingmode.ordinal();\n     }\n\n     public void setPacingmode(int pacingmode) {\n         this.pacingmode = PacingMode.values()[pacingmode];\n     }\n\n/*\n *     public int getCalcMode() {\n        return mode.ordinal();\n    }\n\n    public void setCalcMode(int mode) {\n        this.mode = Mode.values()[mode];\n    }\n * \n * */    \n    \n    public DynamicPacingTimer() {\n    \t\n    }\n\n    public long delay() {\n        switch (pacingmode) {\n        case modeSampler: //\n        \t\tcalculateNdelay(JMeterContextService.getContext().getCurrentSampler().getName());//calculateNdelay( );\n        default: \n            break;\n        }\t    \t\n\n    \treturn 0;\n    \n    }\n    private void calculateNdelay() {\n    \tcalculateNdelay(\"\");\n    }\n    \n    private void calculateNdelay(String label) {\n    \tlong delay = 0 ;\n    \tlong currentTime = System.currentTimeMillis();\n\n    \t//---- for debug\n       // int minutes;\n//    \tjava.util.Calendar cal; \n//        String currTimeString = \"\";\n//        String prevTimeString = \"\";\n//        cal = java.util.Calendar.getInstance();\n//\n//    \tcal.setTimeInMillis(currentTime);     \t//minutes = cal.get(java.util.Calendar.MINUTE);\n//     \tcurrTimeString =    new java.text.SimpleDateFormat(\"mm:ss.SSS\").format(cal.getTime());\n//        cal.setTimeInMillis(previousTime);     \t//minutes = cal.get(java.util.Calendar.MINUTE);\n//     \tprevTimeString =    new java.text.SimpleDateFormat(\"mm:ss.SSS\").format(cal.getTime());\n     \t//--- for debug (end)\n     \tlong tmppacingtime = pacingtimemin;\n     \tif (randomMax > 0 ) {tmppacingtime = randomgen.nextInt(randomMax) + pacingtimemin;} \n     \t\n        long currentTarget = previousTime + tmppacingtime;\n        if (currentTarget < currentTime  ) { \n            previousTime = currentTime; //no delay : // We're behind schedule\n            delay = 0;\n        } else {// response time is in the target time\n        \tpreviousTime = currentTarget; // calculate delay\n        \tdelay = currentTarget - currentTime;\n        }\n                   \n        //log.debug(\"   (__calculeateNdelay)prev:\"  + prevTimeString + \" now:\"  + currTimeString + \"  delay:\" + delay  + \"  pacing:\" + tmppacingtime   + \" :::\" +currSampler.getName());    \n        log.debug(\"   (__calculeateNdelay):\"  + previousTime + \" now:\"  + currentTime + \"  delay:\" + delay  + \"  pacing:\" + tmppacingtime   + \" :::\" + label);    \n        try { Thread.sleep(delay);  } catch (InterruptedException e) { }\n        //return delay;\n\n    \t/*\n\n        log.debug(Thread.currentThread().getStackTrace()[1].getMethodName()  +\n        \t\t\" curr:\" +  currSampler.getClass() +\"_\"+ currSampler.getName() );\n        //log.debug(Thread.currentThread().getStackTrace()[1].getMethodName()  + \" prev:\" +  currSampler.getClass() +\"_\"+ currSampler.getName() );\n    \tSystem.out.println(\"    \" + Thread.currentThread().getStackTrace()[1].getMethodName()  +  \" curr:\" +  currSampler.getClass() +\"_\"+ currSampler.getName());\n        if ((currSampler instanceof TransactionSampler)) {\n        } else {\n        \t//System.out.println (\"         Not Transaction Sampler :\" + prevSampler.getClass() +\"_\"+ currSampler.getClass()) ;\n        }\n    \t\n    \t\n    \tlong currentTime = System.currentTimeMillis();\n        long currentTarget = previousTime;\n        if (currentTime > currentTarget) {\n            // We're behind schedule -- try to catch up:\n            previousTime = currentTime; // assume the sample will run immediately\n            return 0;\n        }\n        previousTime = currentTarget; // assume the sample will run as soon as the delay has expired\n        //System.out.println(previousTime+ \" \" + currentTime + \" \" + (currentTarget - currentTime));\n        return (long)(currentTarget - currentTime);\n        */\n    }\n    \n    \n    private void reset() {\n        previousTime = 0;\n    }\n\n    \n    public String toString() {\n        return \"\";\n    }\n\n    @Override\n    public void setProperty(JMeterProperty property) {\n        super.setProperty(property);\n    }\n    \n  //---- LoopIterationListener : when iterartion(per thread group started)\n    public void iterationStart(LoopIterationEvent iterEvent) {\n    \tif (isFirstIteration){\n        \tpreviousTime = System.currentTimeMillis();\n    \t\tisFirstIteration = false; \n    \t}\n        log.debug(Thread.currentThread().getStackTrace()[1].getMethodName()  \n        \t\t+ \"------------> ITERATION\"\n\t\t      //+\" lastSample:\"+  JMeterContextService.getContext().getVariables().get(\"JMeterThread.last_sample_ok\")\n        \t\t+ \"_\"+ iterEvent.getSource().getName()  + \"  count:\" +  iterEvent.getIteration());\n        switch (pacingmode) {\n        case modeIteration: // Total number of threads\n        \tcalculateNdelay(iterEvent.getSource().getName() );//calculateNdelay( );\n        \t\n            break;\n        default: \n            break;\n        }\t\t\n    \t\n    }\n    \n    \n\n    @Override\n    // !! Transaction Parent mode: it is not invoked with samplers with non-partnet mode of transaction\n    public void sampleOccurred(SampleEvent se) {\n        //log.debug(Thread.currentThread().getStackTrace()[1].getMethodName() \n        //\t\t+ \"*isTranSampleEvent:\" + se.isTransactionSampleEvent()//+ \"_sampleDepth:\" +  travleSampleEvent(se)\n        //\t\t\t);    \t\n        switch (pacingmode) {\n        case modeTransaction: // It does not work with Transaction Parent mode\n           \tif (se.isTransactionSampleEvent() ) {\n        \t\tcalculateNdelay(se.getResult().getSampleLabel()); //calculateNdelay( );\n        \t}\n        case modeIteration: \n    \t\tbreak;\n        default: \n            break;\n        }\t    \t\n    \t\n\n    }\n\n    @Override\n    public void sampleStarted(SampleEvent e) {\n        log.debug(Thread.currentThread().getStackTrace()[1].getMethodName());\n    }\n\n    @Override\n    public void sampleStopped(SampleEvent e) {\n        if (e.isTransactionSampleEvent() ) {\n            log.debug(Thread.currentThread().getStackTrace()[1].getMethodName() + \" TRANSACTION SAMPLE\" );\n        } else {\n        \tlog.debug(Thread.currentThread().getStackTrace()[1].getMethodName() + \"             SAMPLE\" );\n        }\n    \t\n    }\n   \n}", "id": 181990, "time": "2015-03-23T09:55:12Z", "bug_id": 57730, "creation_time": "2015-03-23T09:55:12Z", "tags": [], "is_private": false}]