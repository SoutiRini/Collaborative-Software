[{"count": 0, "tags": [], "text": "I have a web application that uses form based authentication.\n\nif I go to a protected page for example:\nhttp://myhost/myapp/index.html\nthen I get the authentication form:\nhttp://myhost/myapp/login.jsp\nI fill it up, and submit and I get authenticated and the page\nhttp://myhost/myapp/index.html\nis properly shown.\n\n\nHowever, if instead of trying to go to a protected resource, I try to go \ndirectly to the login.jsp page, and that is pretty common since some people \nlike to bookmark the login page, then this is what happens:\n\nI go to the login page:\nhttp://myhost/myapp/login.jsp\n\nthe login page gets displayed properly. but if I fill it up and submit, the \nbrowser gets redirected to this address:\n\nhttp://myhost/myapp/null\nand the following error is shown on the browser:\nHTTP Status 404 - /null\nThe requested resource (/null) is not available. \n\nThe behavior that I would like to see is that the default page for the web \napplication be shown.\n\nI think this is what is happening:\nif I go to a protected resource the url gets saved somewhere in the session\nthen after I submit the login information, the server redirects the browers to \nthe saved location.\n\nBut if I go directly to the login page, then there is no url that failed the \nsecurity constraints, and nothing is saved. After I submit, it tries to go to \nwhatever is saved (null in this case) and since there is no page named null an \nerror is shown. What is needed is an extra check somewhere that says: if the \nsaved location is null, then go to the default webapp page.", "is_private": false, "id": 6055, "creator": "paul.pacheco@wavecode.com", "time": "2001-09-26T09:13:50Z", "bug_id": 3839, "creation_time": "2001-09-26T09:13:50Z", "attachment_id": null}, {"count": 1, "tags": [], "creator": "craig.mcclanahan@sun.com", "attachment_id": null, "is_private": false, "id": 6326, "time": "2001-10-03T11:15:48Z", "bug_id": 3839, "creation_time": "2001-10-03T11:15:48Z", "text": "It is not valid to bookmark the form-based login page.  You should consider that\npage to be part of the *container*, not part of the *application*.\n\nUsers should be trained to bookmark the page they really want to see -- exactly\nas if you were using BASIC authentication instead.  The login page will be\npresented by the container if necessary (i.e. if the user is not currently\nauthenticated).\n\nEven if you figure out a way to do this that works in one servlet container, it\nis pretty much guaranteed not to be portable to any other.\n"}, {"count": 2, "tags": [], "creator": "paul.pacheco@wavecode.com", "attachment_id": null, "id": 6330, "time": "2001-10-03T14:11:04Z", "bug_id": 3839, "creation_time": "2001-10-03T14:11:04Z", "is_private": false, "text": "ohh, come on, you are saying \"the solution is to fix the people who use your web application\". What am I supposed to do, put in the login page something like this:\"Do not bookmark this page, consider it a part of the *container*, not part of the *application*\" Some of the users don't even know there is such thing as a container, and I don't see a reason why they should know.I don't see why the users should be instructed at all.Well, that really does not make it transparent for the users. I used to use weblogic and they had the same problem. They did change it to go to the default page in the web application after we contacted support.Plus the page IS part of the application, it has to be placed inside the war file, it is different for every web application, it has to be specified inside web.xml which is part of the standard. Exactly what part of the servlet standard is broken by fixing this?What good is the default page for the web application if it doesn't get shown by default?????"}, {"count": 3, "tags": [], "bug_id": 3839, "attachment_id": null, "id": 6339, "time": "2001-10-03T15:23:08Z", "creator": "craig.mcclanahan@sun.com", "creation_time": "2001-10-03T15:23:08Z", "is_private": false, "text": "The fact that you hd the same problems under WebLogic also should have given you\na hint that you might be mis-using this functionality :-).\n\nAlthough the form login page (and form error page) are physically contained in\nyour web application archive, they should not be hyperlinked to by any of your\napp's pages.  Most particularly, it should *not* be your welcome page.\n\nIf you (temporarily) switch your app to use BASIC authentication instead, it\nshould still work correctly - and there is no possibility to bookmark the login\npage because there is no such thing.  If your app doesn't work in this scenario,\nthen you should modify it so that it can.\n\nIf you don't, then you're going to be dependent on non-portable behavior of\nwhatever container vendor happens to allow this technique to work - the spec \ndoesn't require it.\n"}, {"count": 4, "tags": [], "text": "*** Bug 4104 has been marked as a duplicate of this bug. ***", "attachment_id": null, "bug_id": 3839, "id": 6596, "time": "2001-10-11T09:06:18Z", "creator": "remm@apache.org", "creation_time": "2001-10-11T09:06:18Z", "is_private": false}, {"count": 5, "tags": [], "bug_id": 3839, "is_private": false, "text": "I still think this is a bug.  If it is not allowable for the user to bookmark\nthe login page then the container should never expose that login url to the\nuser.  In other words, Tomcat should not issue a browser redirect to the login\nurl but instead should do the equivalent of a jsp forward and after\nauthentication do a redirect back to the original url.  Thus there is no\npossibility for the user to bookmark the page and get an ugly 400 error.\n\n", "id": 17615, "time": "2002-06-11T19:40:48Z", "creator": "cpjunk@yeroc.ca", "creation_time": "2002-06-11T19:40:48Z", "attachment_id": null}, {"count": 6, "tags": [], "bug_id": 3839, "attachment_id": null, "id": 17619, "time": "2002-06-11T20:06:56Z", "creator": "pier@betaversion.org", "creation_time": "2002-06-11T20:06:56Z", "is_private": false, "text": "Add this to the beginning of your login page:\n\n<% \n  if (request.getHeader(\"Referer\") == null) {\n    response.sendRedirect(\"index.jsp\");\n  }\n%>\n\nReplacing \"index.jsp\" with whatever URL you feel you want\nto have your connection redirected to...\n\nFor example, if \"index.jsp\" is one of several \"protected\" resources,\nthen if your users bookmark the login page, what will happen is\nthat when your users use the bookmark, they won't have a referer,\nnot having a referer they will be redirected to what you think it is\ntheir \"default\" page (after they have logged in), this (since they're not\nlogged in) will trigger a redirect again to the login page...\n"}, {"count": 7, "tags": [], "text": "That looks like a valid WORKAROUND but I believe this is something that I as a\ndeveloper shouldn't have to handle.  This should all be handled seemlessly by\nthe container.", "is_private": false, "bug_id": 3839, "id": 17664, "time": "2002-06-12T14:13:34Z", "creator": "cpjunk@yeroc.ca", "creation_time": "2002-06-12T14:13:34Z", "attachment_id": null}, {"count": 8, "tags": [], "creator": "lvl@bvdep.com", "attachment_id": null, "is_private": false, "id": 17779, "time": "2002-06-14T07:51:04Z", "bug_id": 3839, "creation_time": "2002-06-14T07:51:04Z", "text": "That workaround is dangerous.\nIn some browsers (like Opera) referrer logging can be disabled, in which case\nyou have an endless loop...\n\nTwo other suggestions for a workaround (but probably non-portable):\n- Test isNew() on the Session object. For form-based login, the container needs\nto store the context of the original call somewhere.  I pretty sure that tomcat\nuses the session object for this (though it will be hidden from the webapp)\n- Put the login page itself in the protected area.  I believe Tomcat 4 allows\nthis.  In the login page you can then put code to test if the user is already\nlogged in.  If he is, he got there because he bookmarked the login page, got the\n'container' login page, logged in and was redirected to the 'application' page\n(that happens to be the same).  In that case, redirect to the application\ndefault page."}, {"count": 9, "tags": [], "text": "Yes I just discovered this myself: Mozilla 1.0 does not seem to send a referer\non a redirect so I got an infinite loop.  Furthermore some proxies can be set to\nstrip out the referer.", "is_private": false, "id": 17799, "creator": "cpjunk@yeroc.ca", "time": "2002-06-14T15:10:43Z", "bug_id": 3839, "creation_time": "2002-06-14T15:10:43Z", "attachment_id": null}, {"count": 10, "tags": [], "bug_id": 3839, "is_private": false, "text": "*** Bug 8976 has been marked as a duplicate of this bug. ***", "id": 36605, "time": "2003-05-02T17:25:02Z", "creator": "remm@apache.org", "creation_time": "2003-05-02T17:25:02Z", "attachment_id": null}, {"count": 11, "tags": [], "text": "\nThere is a dirty hack way of solving this in TC4. I should probably be flogged in public for posting \nsuch a filthy hack, but anyway... I suspect it is not very portable.\n\nIn web.xml define an error page for 400 such as 'error400.jsp':\nIn that page do something along the lines of:\n\n<%\nString requestURI = (String)request.getAttribute( \"javax.servlet.error.request_uri\" );\nboolean isLogin = requestURI.indexOf( \"j_security_check\" ) >= 0;\n\nif ( isLogin ) {\n    String username = request.getParameter( \"j_username\" );\n    String password = request.getParameter( \"j_password\" );\n\n    session.setAttribute( \"j_username\", username );\n    session.setAttribute( \"j_password\", password );    \n\n    response.sendRedirect( \"/some/protected/resource\" );\n    return;\n}\n%>\n// display error message.\n\n\n\n\nIn the form based login page do something like:\n\n<%\n  // j_username and j_password may be set in the error400.jsp page on a \n  // direct reference to the j_security_check page.\n  String username = (String)session.getAttribute( \"j_username\" );\n  String password = (String)session.getAttribute( \"j_password\" );\n\n  boolean autoLogin = username != null && password != null;\n\n  if ( autoLogin ) {\n    session.removeAttribute( \"j_username\" );\n    session.removeAttribute( \"j_password\" );\n%>\n\n  <form name=\"login\" method=\"POST\" action=\"j_security_check\">\n    <input type=\"hidden\" name=\"j_username\" value=\"<%=username%>\"/>\n    <input type=\"hidden\" name=\"j_password\" value=\"<%=password%>\"/>\n  </form>\n\n  <script language=\"JavaScript\">\n    document.login.submit();\n  </script>\n\n%>\n    // now let the browser auto submit the login.\n    return\n  }\n%>\n\n//  Display your normal  login page.\n", "attachment_id": null, "bug_id": 3839, "id": 43444, "time": "2003-08-28T17:54:51Z", "creator": "puckman@taglab.com", "creation_time": "2003-08-28T17:54:51Z", "is_private": false}, {"count": 12, "tags": [], "text": "First of all, I know that this FORM based authentication problem has been raised\nmany times, but I really think that I have come up with a solution that would\nnot violate the sun spec.\n\nThe key to solving this problem is not to expose the login page URL to the user\nso it can't be bookmarked (the same goes for the error page URL).\n\nFirst the current flow with form based authentication:\n1. Call the protected resource. (this is where the user context is saved)\n2. Automatic outer forward to the custom login page. (this is the place where\nthe users bookmark it)\n3. Submit the login via j_security_check. (lets say the password was incorrect)\n4. Automatic outer forward to the custom error page. (this page can also be\nbookmarked)(the steps 3 and 4 can be repeated many times).\n5. Submit the login via j_security_check. (lets say that everything was OK)\n6. Restore the original URL, delete the user context and do an aotomatic outer\nforward.\n\nAs everybody can see the problem lies in the outer forwards to the \"must be\nhidden\" login and error page.\n\nNow concider the next flow that uses inner forwards instead.\n1. Call the protected resource. (this is where the user context is saved)\n2. Inner forward to the custom login page so the original URL stays in the browser.\n3. Submit the login via j_security_check. (lets say the password was incorrect\nin which case we will save a marker to know that there was an error)\n4. Now temporary recreate the original URL and do an automatic outer forward to\nit. As we saved a marker we won't do an inner forward to the login page anymore\nbut to the error page. Additionally we delete the marker so that no other\nrequest gets it.\n5. Submit the login via j_security_check. (lets say that everything was OK)\n6. Restore the original URL, delete the user context and do an aotomatic outer\nforward.\n\nThis new proposed solution has only two weak spots but these are unsignificant ones.\n1. If the user happens to preform another separate call to the same protected\nresource in between the marker saveing and automatic outer forward returning\nthen the error page will go to the wrong window. I also think it's impossible to\nhappen in a real case.\n2. The second problem is a bit bigger one. If the user will do a refresh to the\nlogin error page he will be taken to the login page instead. Now this behaviour\nwould disturb me a lot if it weren't for the fact that usually you can't refresh\nform submits either plus this kind of action could also be concidered as a new\nrequest for the protected resource that it really is.\n\nAs I know you all are a bit like me and won't accept the second point too easely\nbecause the fact remains that a refresh changes the users page. In that case\nit's possible to leave the error page logic like it works right now and hope\nthat users don't want to bookmark error pages ;) (I myself think the refresh\nproblem to be to small to allow users to bookmark wrong pages).\n\nNow I have just two more things to say.\n1. If anybody thinks the marker can be preserved longer to fix the second\nproblem please stop. Because a new horrible problem will arise when the user\nleaves our application without authorizeing and returns later to find an error\npage staring in his face (sessions, with the help of cokies, last a long time).\n2. If anybody finds error in my reasoning please let me know but I'm sure that\nTomcat can be the first web container to resolv this problem gracefully.", "attachment_id": null, "bug_id": 3839, "id": 58810, "time": "2004-06-06T12:57:30Z", "creator": "kahroo@hot.ee", "creation_time": "2004-06-06T12:57:30Z", "is_private": false}, {"count": 13, "tags": [], "bug_id": 3839, "attachment_id": null, "text": "As has alreday been stated in this report, tomcat is spec compliant in this \nregard so I am marking this report as an enhancement request.\n\nGiven the lack of movement on this bug since it was raised, it is unlikely \nthat anything will be done to address this enhancement unless someone wants to \nprovide a patch.\n\nI have also corrected a few other parameters on the original report.", "id": 68968, "time": "2004-12-24T18:00:36Z", "creator": "markt@apache.org", "creation_time": "2004-12-24T18:00:36Z", "is_private": false}, {"count": 14, "tags": [], "text": "I've been tracing through the Tomcat source code because of an \"Invalid direct reference to form login page\" error our customers frequently get and here is what was found (for Tomcat 5 and 6):\n\nWhen you retrieve the login page for the first time, Tomcat initializes a field that is needed for the actual login (a session.note entry). Unfortunately that field is wiped out after the session expires or the server is rebooted. Also Tomcat confuses the get request for http://<server>/j_security_check with the actual login action (see further down for an explanation in extreme detail).\n\nAs a workaround for this error, we implemented the following at the end of our login module (posted with permission from Organizational Strategies Inc):\n\n    org.apache.catalina.connector.RequestFacade requestFacade = (RequestFacade)request;\n    org.apache.catalina.connector.Request tomcatRequest = org.apache.catalina.connector.TomcatRequestFacadeAccessor.extractRequest(requestFacade);\n    org.apache.catalina.Session tomcatSession = tomcatRequest.getSessionInternal(false);\n    org.apache.catalina.authenticator.SavedRequest saved = (SavedRequest) tomcatSession.getNote(org.apache.catalina.authenticator.Constants.FORM_REQUEST_NOTE);\n    if(saved==null){\n        saved = new SavedRequest();\n        saved.setRequestURI(\"/your/path/here\");\n        tomcatSession.setNote(Constants.FORM_REQUEST_NOTE, saved);\n    }\n\n    You will also need to make a TomcatRequestFacadeAccessor class (in package org.apache.catalina.connector), jar it up and add that jar to Tomcat's classpath. That class contains this method\n\n    public static org.apache.catalina.connector.Request extractRequest(RequestFacade facade){\n        return facade.request;\n    }\n\n\nThe above is just a quickly put-together workaround for the error.  We're hoping someone will implement a permanent solution into the Tomcat codebase to address this issue.  To assist with that below is an explanation of the error in extreme detail\n\n\n1) After rebooting everything and going to the login page for the first time, the following code in org.apache.catalina.authenticator.FormAuthenticator.authenticate() gets executed:\n\n            if (!loginAction) {\n                session = request.getSessionInternal(true);\n                if (log.isDebugEnabled())\n                    log.debug(\"Save request in session '\" + session.getIdInternal() + \"'\");\n                try {\n                    saveRequest(request, session);\n                } catch (IOException ioe) {\n                    log.debug(\"Request body too big to save during authentication\");\n                    response.sendError(HttpServletResponse.SC_FORBIDDEN,\n                            sm.getString(\"authenticator.requestBodyTooBig\"));\n                    return (false);\n                }\n                forwardToLoginPage(request, response, config);\n                return (false);\n            }\n\n            The loginAction flag is true when you press the login button; however, the retrieving of the login page is NOT a loginAction so the above block executes\n\n2)  In that block of code, the call to saveRequest(request, session) eventually executes the following line:\n             session.setNote(Constants.FORM_REQUEST_NOTE, saved);\n\n3) Later on when you press the login button, this code in FormAuthenticator.java tries to use that session.note value:\n            requestURI = savedRequestURL(session);\n            and savedRequestURL returns the session.note value set when the login page was originally retrieved:\n                session.getNote(Constants.FORM_REQUEST_NOTE);\n\n4) Unfortunately if the block of code from 1) is not executed, then the session.note value won't be set, requestURI will be null and this will run, giving you the \"Invalid direct reference to form login page\" error:\n            requestURI = savedRequestURL(session);\n                if (requestURI == null)\n                    response.sendError(HttpServletResponse.SC_BAD_REQUEST,\n                                       sm.getString(\"authenticator.formlogin\"));\n\n5) The block of code from 1) won't execute and you'll get the \"Invalid direct reference to form login page\" error in the following conditions:\n        a) If the server is rebooted and the user already has a login window open\n        b) If the user's session times out and they already have a login window open\n        c) If they go directly to URL http://<yourserver>/your/path/here/j_security_check (many users may have this bookmarked because it's the browser URL you see after invalid logins)\n                The reason this URL doesn't work is because the loginAction flag toggling the block of code from 1) is set like this:\n                    boolean loginAction =\n                        requestURI.startsWith(contextPath) &&\n                        requestURI.endsWith(Constants.FORM_ACTION);   //this is \"/j_security_check\"\n                and going to http://<yourserver>/your/path/here/j_security_check will set loginAction to true (Tomcat thinks you clicked the login button) - one way to fix this is to make loginAction false for GET requests\n\n\nMany thanks in advance for whoever makes the FormAuthenticator changes to fix this.\n\nThanks,\nMark Morris.", "attachment_id": null, "bug_id": 3839, "id": 140520, "time": "2010-10-06T15:29:58Z", "creator": "mmorris@orgstrategies.com", "creation_time": "2010-10-06T15:29:58Z", "is_private": false}, {"count": 15, "tags": [], "bug_id": 3839, "is_private": false, "text": "I have implemented a work-around for this issue for Tomcat7 and it will be in 7.0.5 onwards.\n\nIt is unlikely to be back-ported to earlier versions.\n\nThe solution is based on Mark Morris's suggestion. It adds a landingPage attribute to the FormAuthenticatorValve that can be used to define where to send the user if they request the login page directly or take so long to log in the session expires.", "id": 140868, "time": "2010-10-20T17:57:59Z", "creator": "markt@apache.org", "creation_time": "2010-10-20T17:57:59Z", "attachment_id": null}]