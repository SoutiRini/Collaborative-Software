[{"count": 0, "tags": [], "bug_id": 46984, "text": "I managed to send a corrupt data stream to Tomcat.  The result was that the method name turned out to be '0\\n\\n0\\n\\n0\\n\\nPOST'.  This was actually the method name that was returned to the servlet's .service(request, response) method by Tomcat.  The error message returned back to the client was:\n\n java.io.IOException: Server returned HTTP response code: 501 for URL: http://localhost/method-bug/bug\n\tat sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1305)\n\tat sun.net.www.protocol.http.HttpURLConnection.getHeaderFields(HttpURLConnection.java:2187)\n\n\nThe 501 error indicates that the method is not implemented or not supported.  While this is somewhat true, there is a more applicable error message.  The 501 error is confusing, in that it indicates a valid method name was received.  In this case, the method name was formed with invalid characters (numbers and carriage returns). \n\nThe correct behavior is that Tomcat should detect the bad/invalid/malformed method name and throw a 400 error, bad request.  \n\nThe offending code is in org.apache.coyote.http11.InternalInputBuffer.\n\nThe parseRequestLine code is naive.  It starts by skipping blank lines, then puts EVERYTHING up until the next 'space' character into the method name, including carriage returns, special characters, numbers, etc.  \n\nCorrect behavior is that it should detect an invalid method name (according to the spec) at this point, and throw error 400 (I think 400 is correct).\n\n    public void parseRequestLine() throws IOException {\n        int start = 0;\n        //\n        // Skipping blank lines\n        //\n        byte chr = 0;\n        do {\n            // Read new bytes if needed\n            if (pos >= lastValid) {\n                if (!fill())\n                    throw new EOFException(sm.getString(\"iib.eof.error\"));\n            }\n            chr = buf[pos++];\n        } while ((chr == Constants.CR) || (chr == Constants.LF));\n        pos--;\n        // Mark the current buffer position\n        start = pos;\n         //\n        // Reading the method name\n        // Method name is always US-ASCII\n        //\n        boolean space = false;\n        while (!space) {\n            // Read new bytes if needed\n            if (pos >= lastValid) {\n                if (!fill())\n                    throw new EOFException(sm.getString(\"iib.eof.error\"));\n            }\n            ascbuf[pos] = (char) buf[pos];\n            // Spec says single SP but it also says be tolerant of HT\n            if (buf[pos] == Constants.SP || buf[pos] == Constants.HT) {\n                space = true;\n                request.method().setChars(ascbuf, start, pos - start);\n            }\n            pos++;\n        }", "id": 126042, "time": "2009-04-07T07:44:46Z", "creator": "jsmith@infotrustgroup.com", "creation_time": "2009-04-07T07:44:46Z", "is_private": false, "attachment_id": null}, {"count": 1, "tags": [], "bug_id": 46984, "text": "This has been fixed in trunk and proposed for 6.0.x and 5.5.x.", "id": 126159, "time": "2009-04-09T07:03:21Z", "creator": "markt@apache.org", "creation_time": "2009-04-09T07:03:21Z", "is_private": false, "attachment_id": null}, {"count": 2, "tags": [], "creator": "markt@apache.org", "text": "This has been fixed in 6.0.x and will be included in 6.0.20 onwards.", "id": 126735, "attachment_id": null, "bug_id": 46984, "creation_time": "2009-05-02T18:29:41Z", "time": "2009-05-02T18:29:41Z", "is_private": false}, {"count": 3, "tags": [], "bug_id": 46984, "text": "This has been fixed in 5.5.x and will be included in 5.5.28 onwards.", "id": 127644, "time": "2009-06-04T07:58:44Z", "creator": "markt@apache.org", "creation_time": "2009-06-04T07:58:44Z", "is_private": false, "attachment_id": null}]