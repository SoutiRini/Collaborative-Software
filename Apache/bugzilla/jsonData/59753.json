[{"count": 0, "tags": [], "creator": "mford@wombatsecurity.com", "is_private": false, "text": "Created attachment 33986\ntest.png\n\nIf I do the following:\n  Workbook workbook = new XSSFWorkbook();\n  Sheet sheet = workbook.createSheet();\n  byte[] imageBytes = org.apache.commons.io.IOUtils.toByteArray(new FileInputStream(test.png));\n  Drawing drawing = sheet.createDrawingPatriarch();\n  int pictureIdx = workbook.addPicture(imageBytes, Workbook.PICTURE_TYPE_PNG);\n  CreationHelper helper = workbook.getCreationHelper();\n  ClientAnchor anchor = helper.createClientAnchor();\n  anchor.setCol1(0); // Not needed, but let's make sure we are in the upper left\n  anchor.setRow1(0); // corner of the spreadsheet.\n  Picture pict = drawing.createPicture(anchor, pictureIdx);\n\n  anchor.pict.getPreferredSize();  //This will return 1 and 1 for col2/row2\n  pict.resize(0.75);  //This will return 0 and 0 for col2/row2\n\n  int lastColumn = anchor.getCol2();\n  int lastRow = anchor.getRow2();\n\nThe last row and column are useful for placing other data below or beside the image.  The byte array is used to get an image stored in memory and not on the file system.\n\nImageUtils.setPreferredSize snippet for col2:\n        // in pixel\n        Dimension imgSize = getImageDimension(new ByteArrayInputStream(data.getData()), data.getPictureType());\n        // in emus\n        Dimension anchorSize = ImageUtils.getDimensionFromAnchor(picture);\n        final double scaledWidth = (scaleX == Double.MAX_VALUE)\n            ? imgSize.getWidth() : anchorSize.getWidth()/EMU_PER_PIXEL * scaleX;\n        final double scaledHeight = (scaleY == Double.MAX_VALUE)\n            ? imgSize.getHeight() : anchorSize.getHeight()/EMU_PER_PIXEL * scaleY;\n\n        double w = 0;\n        int col2 = anchor.getCol1();\n        int dx2 = 0;\n\n        //space in the leftmost cell\n        w = sheet.getColumnWidthInPixels(col2++);\n        if (isHSSF) {\n            w *= 1d - anchor.getDx1()/1024d;\n        } else {\n            w -= anchor.getDx1()/(double)EMU_PER_PIXEL;\n        }\n        \n        while(w < scaledWidth){\n            w += sheet.getColumnWidthInPixels(col2++);\n        }\n        \n        if(w > scaledWidth) {\n            //calculate dx2, offset in the rightmost cell\n            double cw = sheet.getColumnWidthInPixels(--col2);\n            double delta = w - scaledWidth;\n            if (isHSSF) {\n                dx2 = (int)((cw-delta)/cw*1024);\n            } else {\n                dx2 = (int)((cw-delta)*EMU_PER_PIXEL);\n            }\n            if (dx2 < 0) dx2 = 0;\n        }\n        anchor.setCol2(col2);\n        anchor.setDx2(dx2);\n\nThis is the snippet from XSSFPicture.getPreferredSize in 3.8:\n        XSSFClientAnchor anchor = (XSSFClientAnchor)getAnchor();\n\n        XSSFPictureData data = getPictureData();\n        Dimension size = getImageDimension(data.getPackagePart(), data.getPictureType());\n        double scaledWidth = size.getWidth() * scale;\n        double scaledHeight = size.getHeight() * scale;\n\n        float w = 0;\n        int col2 = anchor.getCol1();\n        int dx2 = 0;\n\n        for (;;) {\n            w += getColumnWidthInPixels(col2);\n            if(w > scaledWidth) break;\n            col2++;\n        }\n\n        if(w > scaledWidth) {\n            double cw = getColumnWidthInPixels(col2 );\n            double delta = w - scaledWidth;\n            dx2 = (int)(EMU_PER_PIXEL*(cw-delta));\n        }\n        anchor.setCol2(col2);\n        anchor.setDx2(dx2);\n\n        double h = 0;\n        int row2 = anchor.getRow1();\n        int dy2 = 0;\n\n        for (;;) {\n            h += getRowHeightInPixels(row2);\n            if(h > scaledHeight) break;\n            row2++;\n        }\n\n        if(h > scaledHeight) {\n            double ch = getRowHeightInPixels(row2);\n            double delta = h - scaledHeight;\n            dy2 = (int)(EMU_PER_PIXEL*(ch-delta));\n        }\n        anchor.setRow2(row2);\n        anchor.setDy2(dy2);\nAlso please note as you debug that the scaledWidth and scaledHeight in 3.14 end up being almost identical to the value returned from columnWidthInPixels.  The columnWidthInPixels is ~6 pixels smaller that the 3.8 version.  The 3.8 version increments the columns with a check of w against the number of pixels in the width of the picture.  So you end up with an image that is always squeezed into a single cell.", "id": 191939, "time": "2016-06-24T17:57:57Z", "bug_id": 59753, "creation_time": "2016-06-24T17:57:57Z", "attachment_id": 33986}, {"count": 1, "attachment_id": null, "bug_id": 59753, "text": "You end up with a single cell in 3.14 and a correct image in 3.8.", "id": 191940, "time": "2016-06-24T18:00:35Z", "creator": "mford@wombatsecurity.com", "creation_time": "2016-06-24T18:00:35Z", "tags": [], "is_private": false}, {"count": 2, "attachment_id": null, "bug_id": 59753, "text": "I did some tests on my machine and found this worked as late as 3.10-FINAL, but was broken in the 3.11 release.  Interestingly 3.11, 12, and 13 return col2 as 1 and row2 as 0.  3.14 has both col2 and row2  as 0.", "id": 192005, "time": "2016-06-28T17:05:05Z", "creator": "mford@wombatsecurity.com", "creation_time": "2016-06-28T17:05:05Z", "tags": [], "is_private": false}]