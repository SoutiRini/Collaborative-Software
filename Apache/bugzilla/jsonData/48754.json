[{"count": 0, "tags": [], "bug_id": 48754, "attachment_id": null, "text": "Suppose you have a master build file and a bunch of subdirectories\nthat represent sub-projects, each with their own build.xml file.\nFurther, suppose you wish to avoid all use of recursive tags such as \n<subant>, because recursive builds inherently break the dependency DAG,\nand therefore require hand-maintenance of dependency relationships\n(c.f.: \"Recursive Make Considered Harmful\"). Instead, it would be nice\nif you could rely entirely upon the <import> tag, and have a predictable\nstatic dependencies within a single DAG, and be confident that the\nmeaning of the names in the depends=\"...\" attribute can be understood\nlocally.  In other words, you don't want the addition of seemingly \nunrelated sub-projects to change the dependency logic of \"innocent bystander\"\nsub-projects.  Currently, Ant has some major problems with that,\nbut fortunately it's rather easy to correct.\n\nAside:  I was able to create a workaround without modifying Ant's source,\nbut it imposes some constraints upon each build.xml that should really be unnecessary.  \n\nOk, consider the following:\n\nIn the file system, we might have something like this:\n \n <basedir>/build.xml   (imports project/xxx/build.xml and project/yyy/build.xml)\n <basedir>/project/xxx/build.xml           (imports ../../project/yyy.build.xml)\n <basedir>/project/yyy/build.xml       \n\n\nWithin project/yyy/build.xml let's say we see the following snippet:\n\n  <target name=\"moo\">               ... </target>\n  <target name=\"cow\" depends=\"moo\"> ... </target>\n\nIt's tempting to think that cow in project yyy depends on moo in project yyy,\nbut if you're running from the top-level build.xml file, 'moo'\ncould easily be hijacked if *either* the top-level build file happened\nto define a target named 'moo' or  project/xxx/build.xml happened to define\na target named 'moo'.  Why?  Because names are not resolved according to \ntheir lexical scope in Ant, but  rather in terms of the runtime order\nin which they were encountered.  If the master build.xml file imported\nproject/xxx/build.xml before project/yyy/build.xml then within \nproject/yyy/build.xml 'moo'  really means xxx.moo,  not yyy.moo.\n\nNow consider the chaos of a master build with N sub-projects where N \nstarts to get large, and sub-projects have interdependencies....  This \nmeans the only safe way you can currently refer to the target 'moo' \nin project yyy is by giving the full/ugly name  (i.e:  depends=\"yyy.moo\").\nThat's really unfortunate.  It gets worse though:   because Ant does not\ncreate top-level  <projectName>.<targetName> aliases for targets \nthat are in the build.xml file given on the command line,  you've now\nlost the ability to invoke Ant conveniently from the project/yyy directory.\nAnt will say \"Huh? what's the yyy.moo target?  Never heard of it!\"\n\nThe seriousness of this problem becomes apparent as soon as \neach sub-project wants to claim natural sounding target names\nlike \"compile\".\n\n\nThe solution to this problem is rather simple:\n\n(1) \nImmediately prior to the topological dependency sort of targets\nre-write all target names mentioned in depends=\"...\" \nby converting them into absolute form ( <projectName>.<targetName>).\nThus our original example is transformed  **as if** we'd written:\n\n  <target name=\"moo\">               ... </target>\n  <target name=\"cow\" depends=\"yyy.moo\"> ... </target>\n\n\n(2) Ensure that Ant creates top-level <projectName>.<targetName> aliases\nfor all targets, not just targets discovered via <import>.\n\n\nTogether, (1) and (2) allow you to have natural target names in each\nbuild.xml file, and run Ant from either the master build file \n(in which case you could say  'ant yyy.compile')  or from the \nproject/yyy/  directory (where you could just say 'ant compile').\n\nIncidentally, I've made an number of other enhancements \nthat allow you to avoid mentioning the name of the current\ntarget (following the 'do not repeat yourself' principle).\nI've got a rather nice setup now, and would be happy to share\nit and/or discuss some of this stuff with folks who are already \ncontributors to this project.  \n\nFeel free to drop me an email.\n\n\n     Cheers,\n     -Jon\n\n\nAside:\nWhen are people typically on ##ant -- nobody seems to be logged on\nwhenever I check.", "id": 134576, "time": "2010-02-16T22:18:26Z", "creator": "jcox-dated-1266352898.9c8d3f@experiments.com", "creation_time": "2010-02-16T22:18:26Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 48754, "attachment_id": null, "text": "What you describe sounds a lot like <include> of Ant 1.8.0, please take a look at it, it might be all you need.\n\nWRT #ant - I didn't even know it existed.  It's likely that there are not too many IRC users around Ant.", "id": 134597, "time": "2010-02-17T13:34:33Z", "creator": "bodewig@apache.org", "creation_time": "2010-02-17T13:34:33Z", "is_private": false}, {"count": 2, "tags": [], "bug_id": 48754, "attachment_id": null, "text": "(In reply to comment #1)\n> What you describe sounds a lot like <include> of Ant 1.8.0, please take a look\n> at it, it might be all you need.\n> \n> WRT #ant - I didn't even know it existed.  It's likely that there are not too\n> many IRC users around Ant.\n\n\nThe new <include> tag looks promising -- I'll check it out.\n\nHere are some other things I did that would be nice to have in \"standard ant\":\n\nI created some magical properties that are static with respect to \nthe context in which they're evaluated (but implemented dynamically).\nThe net effect is that I've faked a static \"scoped\" definition for \nthe following magical properties.  \n\nProps related to targets/projects/tasks:\n  *  ${this.target}              the current target name (e.g.: 'javac')\n  *  ${this.target.description}  target description text (possibly undefined) \n  *  ${this.project}             the current project name (e.g.: 'myproj')\n  *  ${this.task}                the current task name (e.g.: 'javac-project')\n\nProps related to current build file dir:\n  *  ${this.dir}           full dir parent pathname containing this build file\n  *  ${this.dir.name}      leaf name of parent dir containing this build file\n\nProps related to current build file name:\n  *  ${this.file}          full pathname of this build file\n  *  ${this.file.name}     leaf name of this build file (typically, \"build.xml\")\n  *  ${this.file.basename} basename of this build file (typically, \"build\").\n\n\nThis ends up being enormously useful because it means you can\ncut/paste snippets of ant without modification.  Critically, \nbecause the interpolation of ${this.target}  and ${this.project}\nis done immediately prior to the topological sort of targets,\nall dependencies remain entirely *static*  the other this.XXX\nvariables are updated via a BuildListener  \n\nConsider the following snippet from a sub-project in my build.\nI can have the exact same blob of XML in project \"moo\" and \"cow\":\n\n    <target name=\"javac-test\"\n            depends=\"javac\"\n            description=\"Compile Java 'test' classes in this subproject\">\n        <javac-project\n            name=\"${this.project}\" \n            src=\"test\"/>\n    </target>\n\n\nNow my <javac-project> macro is fed  name=\"moo\"  \nwhen the blob of XML above is in the moo project,\nand name=\"cow\" when it's in the cow project!\n\nTherefore, because I never end up repeating names\nof things that can be known statically prior to \nthe topological sort, my XML ends up being a lot\nmore reusable / cut-and-paste-able.  Extremely nice!\n\n\nLet me know what you think.\n\n            Cheers,\n            -Jon\n\n\nSide note:  it would be highly desirable if Ant gave the build listener \na special event signifying that the topological dependency sort is\nis about to happen... I had to kludge around that one.  Another nasty\nbit was that the \"dependencies\" field in Target is private, yet there's\nno way to remove dependencies (just add them).  That means that if you\nwant to do a  custom fixup of dependencies, you've got to resort to\nintrospection and the ugly field.setAccessible(true) trick.  It works,\nbut it's icky.", "id": 134930, "time": "2010-02-26T18:16:19Z", "creator": "jcox-dated-1266352898.9c8d3f@experiments.com", "creation_time": "2010-02-26T18:16:19Z", "is_private": false}]