[{"count": 0, "tags": [], "bug_id": 55533, "text": "This looks to be a repeat of bug #24588, from some time ago...\n\nI am actually able to reproduce this same issue consistently on tomcat 7.0.41 whenever I make a request on a reloaded context.\n\n1) Deploy war (unpacked) onto tomcat (embedded, org.apache.catalina.startup.Tomcat) with context set to reloadable\n2) Make requests to webapp, works fine\n3) Recompile war to trigger context reload\n4) Each request to webapp gives this stacktrace\n\n2013-09-06 22:32:35,093 [http-nio-8080-exec-8] ERROR org.apache.coyote.http11.Http11NioProcessor - Error processing request\njava.lang.NullPointerException\n    at org.apache.naming.resources.ProxyDirContext.cacheLoad(ProxyDirContext.java:1660)\n    at org.apache.naming.resources.ProxyDirContext.cacheLookup(ProxyDirContext.java:1536)\n    at org.apache.naming.resources.ProxyDirContext.lookup(ProxyDirContext.java:297)\n    at org.apache.tomcat.util.http.mapper.Mapper.internalMapWrapper(Mapper.java:1009)\n    at org.apache.tomcat.util.http.mapper.Mapper.internalMap(Mapper.java:821)\n    at org.apache.tomcat.util.http.mapper.Mapper.map(Mapper.java:684)\n    at org.apache.catalina.connector.CoyoteAdapter.postParseRequest(CoyoteAdapter.java:647)\n    at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:403)\n    at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1023)\n    at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:589)\n    at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1686)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n    at java.lang.Thread.run(Thread.java:722)\n\nChecked, and it is failing on the same line:\n  int n = is.read(b, pos, length - pos);", "id": 169951, "time": "2013-09-07T05:43:52Z", "creator": "matthauck@gmail.com", "creation_time": "2013-09-07T05:43:52Z", "is_private": false, "attachment_id": null}, {"count": 1, "tags": [], "creator": "markt@apache.org", "attachment_id": null, "id": 169988, "time": "2013-09-09T14:28:42Z", "bug_id": 55533, "creation_time": "2013-09-09T14:28:42Z", "is_private": false, "text": "I can't repeat this with the latest 7.0.x code and the examples web application.\n\nPlease provide the exact steps to reproduce this from a clean install of the latest 7.0.x embedded distribution and the examples web application.\n\nIf it is not possible to reproduce this with the examples web application then please provide the simplest possible web application necessary to recreate the issue."}, {"count": 2, "tags": [], "bug_id": 55533, "attachment_id": null, "text": "I have no idea how to whittle it down to the simplest possible webapp that reproduces the problem. (And the webapp I'm working on is unfortunately far from simple.) I have zero experience with tomcat internals; Do you have any guidance on directions I can look into?", "id": 169990, "time": "2013-09-09T16:33:08Z", "creator": "matthauck@gmail.com", "creation_time": "2013-09-09T16:33:08Z", "is_private": false}, {"count": 3, "tags": [], "bug_id": 55533, "attachment_id": null, "text": "So, it turns out there were some memory leak issues when stopping the tomcat container. These would appear whenever I called tomcat.stop() or context.reload(). I started to tackle these and, after doing, this problem appears to have gone away. \n\nHere were the memory leak issues I had:\n- log4j 1.2 AsyncAppender which I did not explicitly `close()`\n- an ExecutorService that I did not `shutdown()`\n- a ScheduledThreadPoolExecutor that I did not `shutdown()`\n\nAfter fixing these three things, I do not see this issue anymore. Not sure if that helps track down the issue or not...", "id": 169991, "time": "2013-09-09T18:26:07Z", "creator": "matthauck@gmail.com", "creation_time": "2013-09-09T18:26:07Z", "is_private": false}, {"count": 4, "tags": [], "creator": "markt@apache.org", "text": "The resource lookups go via JNDI and that uses the thread context class loader to identify the correct resource set. My best guess is that a thread in the executor was retaining a reference to the old class loader and that was messing up the JNDI lookup.\n\nI don't think there is anything that could be done in Tomcat to fix this. It is a useful data point for folks that see similar issues in the future. Thanks for doing the research and reporting back your findings.", "id": 169995, "time": "2013-09-09T20:35:27Z", "bug_id": 55533, "creation_time": "2013-09-09T20:35:27Z", "is_private": false, "attachment_id": null}]