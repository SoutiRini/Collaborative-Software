[{"count": 0, "tags": [], "bug_id": 56725, "attachment_id": null, "id": 176406, "time": "2014-07-15T16:40:55Z", "creator": "mardkrause@hotmail.com", "creation_time": "2014-07-15T16:40:55Z", "is_private": false, "text": "When streaming a large file a ScoketException is thrown in an embedded server.\nLikely source of issue: tomcat-embed-core-8.0.9\n\nUsing an embedded server to send/stream files to another embedded server works correctly until the file is large (we used byte[8192]) and then the following exception is thrown on the sending server:\njava.net.SocketException: Connection reset by peer: socket write error\n\tat java.net.SocketOutputStream.socketWrite0(Native Method)\n\tat java.net.SocketOutputStream.socketWrite(SocketOutputStream.java:113)\n\tat java.net.SocketOutputStream.write(SocketOutputStream.java:159)\n\tat org.apache.http.impl.io.AbstractSessionOutputBuffer.write(AbstractSessionOutputBuffer.java:181)\n\tat org.apache.http.impl.io.ContentLengthOutputStream.write(ContentLengthOutputStream.java:115)\n\tat org.apache.http.entity.ByteArrayEntity.writeTo(ByteArrayEntity.java:112)\n\tat org.apache.http.entity.HttpEntityWrapper.writeTo(HttpEntityWrapper.java:89)\n\tat org.apache.http.impl.client.EntityEnclosingRequestWrapper$EntityWrapper.writeTo(EntityEnclosingRequestWrapper.java:108)\n\tat org.apache.http.impl.entity.EntitySerializer.serialize(EntitySerializer.java:117)\n\tat org.apache.http.impl.AbstractHttpClientConnection.sendRequestEntity(AbstractHttpClientConnection.java:265)\n\tat org.apache.http.impl.conn.ManagedClientConnectionImpl.sendRequestEntity(ManagedClientConnectionImpl.java:203)\n\tat org.apache.http.protocol.HttpRequestExecutor.doSendRequest(HttpRequestExecutor.java:236)\n\tat org.apache.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:121)\n\tat org.apache.http.impl.client.DefaultRequestDirector.tryExecute(DefaultRequestDirector.java:685)\n\tat org.apache.http.impl.client.DefaultRequestDirector.execute(DefaultRequestDirector.java:487)\n\tat org.apache.http.impl.client.AbstractHttpClient.doExecute(AbstractHttpClient.java:863)\n\tat org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:82)\n\tat org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:57)\n\nNothing appears in the logs on the receiving server.\n\nThe same test works with older 8.0.* releases (e.g. tomcat-embed-core-8.0.8), however when we updated to 8.0.9 we started seeing this exception.  We tried using tomcat-catalina-8.0.9 with the tomcat-embed-core-8.0.8 and it seemed to work as expected so it lead us to believe it was on issue with tomcat-embed-core-8.0.9."}, {"count": 1, "tags": [], "text": "So an 8k file is considered \"large\" these days?\n\nThe stack trace you have here looks like you are the client. Do you have any information about any exception thrown on the server? Is the server running Tomcat?\n\nCan you provide any other information about this situation?", "attachment_id": null, "id": 176408, "creator": "chris@christopherschultz.net", "time": "2014-07-15T19:22:01Z", "bug_id": 56725, "creation_time": "2014-07-15T19:22:01Z", "is_private": false}, {"count": 2, "tags": [], "bug_id": 56725, "attachment_id": null, "id": 176410, "time": "2014-07-16T01:11:48Z", "creator": "mardkrause@hotmail.com", "creation_time": "2014-07-16T01:11:48Z", "is_private": false, "text": "Haha, oops.  The \"large\" file is a 1GB file, FILE_SIZE = (int) Math.pow(2, 30).  The 8KB file was actually the stream which was successful every time.\n\nWhat we are doing is having one server call, via REST, another server and streaming the files across.  So yes, one is a client/sending server.  Both servers are running embedded Tomcat servers.  For each test they are running the same version.  So either both 8.0.9 or both 8.0.8.\n\nThe server receiving the streams does not show any errors in the log.  Only the client server has the exception.\n\nI'm wondering if it's something to do with the HttpClient (4.3.4) which might be used when running on 8.0.9.  I noticed that version when attempting to do a little debugging, although we do specify 4.3.3 in one of our gradle files.\n\nThe only changes we made between the successful test and the failing one where in our gradle file for the servers.\n--Passing--\n[group: 'org.apache.tomcat', name: 'tomcat-catalina', version: '8.0.8'],\n[group: 'org.apache.tomcat.embed', name: 'tomcat-embed-core', version: '8.0.8'],\n[group: 'org.apache.tomcat.embed', name: 'tomcat-embed-jasper', version: '8.0.8']\n--failing--\n[group: 'org.apache.tomcat', name: 'tomcat-catalina', version: '8.0.9'],\n[group: 'org.apache.tomcat.embed', name: 'tomcat-embed-core', version: '8.0.9'],\n[group: 'org.apache.tomcat.embed', name: 'tomcat-embed-jasper', version: '8.0.9']"}, {"count": 3, "attachment_id": null, "bug_id": 56725, "is_private": false, "id": 176412, "time": "2014-07-16T04:24:20Z", "creator": "knst.kolinko@gmail.com", "creation_time": "2014-07-16T04:24:20Z", "tags": [], "text": "If I understand you correctly, you are uploading a 1Gb file using HttpClient (4.3.4).\n\nThe stack trace is from HttpClient that uploads the file. There are no Tomcat lines there.\n\n\n> Nothing appears in the logs on the receiving server.\n\nHave you configured AccessLogValve on the receiving server? If you have not, configure it.\nWhat HTTP status code is logged in access log for this aborted request?\n\n\nThere are two notable changes in 8.0.9, mentioned in the change log:\n1). When an error occurs after the response has been committed close the connection immediately rather than attempting to finish the response to make it easier for the client to differentiate between a complete response and one that failed part way though.\n2). Add a new limit, defaulting to 2MB, for the amount of data Tomcat will swallow for an aborted upload.\n\nThe HTTP status code is needed to guess what happened here."}, {"text": "I received more information form the author of the test, added more logging, and am including more of the client-server log (minus a few of our custom classes).\n\nThe test acts does the following:\n1. send a new file\n  a. HEAD check if already exists - 404 (Not found)\n  b. PUT initial small file - 201 (Created)\n2. start sending/updating 1GB file (on thread-x with a new HttpClient instance built with same user setup)\n  a. HEAD check if already exisits - 200 (OK)\n  b. PUT large file\n3. attempt to delete the file a few seconds after step 2 starts (on thread-y with a new HttpClient instance built with same user setup)\n  a. DELETE file\n\nWe expect (and experience with 8.0.8) that step 3 returns with 409 (Conflict) and step 2 returns with 200 (OK).  However, we are experiencing with 8.0.9 that step 2 gets cut off and can't complete.\n\n\n----receiving server's access logs----\n127.0.0.1 - - [16/Jul/2014:13:50:33 +0000] \"HEAD /management/api/storage/fileManagement/article/conflictApp/a57f597a-bb7f-4221-8097-e4d9222c61cd HTTP/1.1\" 401 -\n127.0.0.1 - - [16/Jul/2014:13:50:33 +0000] \"HEAD /management/api/storage/fileManagement/article/conflictApp/a57f597a-bb7f-4221-8097-e4d9222c61cd HTTP/1.1\" 404 -\n127.0.0.1 - - [16/Jul/2014:13:50:33 +0000] \"PUT /management/api/storage/fileManagement/article/conflictApp/a57f597a-bb7f-4221-8097-e4d9222c61cd HTTP/1.1\" 401 1114\n127.0.0.1 - - [16/Jul/2014:13:50:33 +0000] \"PUT /management/api/storage/fileManagement/article/conflictApp/a57f597a-bb7f-4221-8097-e4d9222c61cd HTTP/1.1\" 201 -\n127.0.0.1 - - [16/Jul/2014:13:50:39 +0000] \"HEAD /management/api/storage/fileManagement/article/conflictApp/a57f597a-bb7f-4221-8097-e4d9222c61cd HTTP/1.1\" 401 -\n127.0.0.1 - - [16/Jul/2014:13:50:39 +0000] \"HEAD /management/api/storage/fileManagement/article/conflictApp/a57f597a-bb7f-4221-8097-e4d9222c61cd HTTP/1.1\" 200 -\n127.0.0.1 - - [16/Jul/2014:13:50:51 +0000] \"DELETE /management/api/storage/fileManagement/article/conflictApp/a57f597a-bb7f-4221-8097-e4d9222c61cd HTTP/1.1\" 401 1114\n127.0.0.1 - - [16/Jul/2014:13:50:51 +0000] \"DELETE /management/api/storage/fileManagement/article/conflictApp/a57f597a-bb7f-4221-8097-e4d9222c61cd HTTP/1.1\" 204 -\n127.0.0.1 - - [16/Jul/2014:13:50:54 +0000] \"PUT /management/api/storage/fileManagement/article/conflictApp/a57f597a-bb7f-4221-8097-e4d9222c61cd HTTP/1.1\" 401 1114\n127.0.0.1 - - [16/Jul/2014:13:50:55 +0000] \"PUT /management/api/storage/fileManagement/article/conflictApp/a57f597a-bb7f-4221-8097-e4d9222c61cd HTTP/1.1\" 401 1114\n127.0.0.1 - - [16/Jul/2014:13:50:56 +0000] \"PUT /management/api/storage/fileManagement/article/conflictApp/a57f597a-bb7f-4221-8097-e4d9222c61cd HTTP/1.1\" 401 1114\n127.0.0.1 - - [16/Jul/2014:13:50:57 +0000] \"PUT /management/api/storage/fileManagement/article/conflictApp/a57f597a-bb7f-4221-8097-e4d9222c61cd HTTP/1.1\" 401 1114\n\n\n----cleint server's logs----\n13:50:33.443 INFO  http-nio-8710-exec-2 Logger.info - Before request [method=PUT;server=http://localhost:8710;uri=/application/api/file/conflictApp/files/a57f597a-bb7f-4221-8097-e4d9222c61cd?null;client=127.0.0.1]\n13:50:33.625 WARN  http-nio-8710-exec-2 RestTemplate.handleResponseError - HEAD request for \"http://localhost:8700/management/api/storage/fileManagement/article/conflictApp/a57f597a-bb7f-4221-8097-e4d9222c61cd\" resulted in 404 (Not Found); invoking error handler\n13:50:33.931 INFO  http-nio-8710-exec-2 Logger.info - After request [method=PUT;server=http://localhost:8710;uri=/application/api/file/conflictApp/files/a57f597a-bb7f-4221-8097-e4d9222c61cd?null;client=127.0.0.1]\n13:50:39.184 INFO  http-nio-8710-exec-3 Logger.info - Before request [method=PUT;server=http://localhost:8710;uri=/application/api/file/conflictApp/files/a57f597a-bb7f-4221-8097-e4d9222c61cd?null;client=127.0.0.1]\n13:50:51.072 INFO  http-nio-8710-exec-4 Logger.info - Before request [method=DELETE;server=http://localhost:8710;uri=/application/api/file/conflictApp/files/a57f597a-bb7f-4221-8097-e4d9222c61cd?null;client=127.0.0.1]\n13:50:51.199 INFO  http-nio-8710-exec-4 Logger.info - After request [method=DELETE;server=http://localhost:8710;uri=/application/api/file/conflictApp/files/a57f597a-bb7f-4221-8097-e4d9222c61cd?null;client=127.0.0.1]\n13:50:55.518 INFO  http-nio-8710-exec-3 DefaultRequestDirector.tryExecute - I/O exception (java.net.SocketException) caught when processing request to {}->http://localhost:8700: Connection reset by peer: socket write error\n13:50:55.521 INFO  http-nio-8710-exec-3 DefaultRequestDirector.tryExecute - Retrying request to {}->http://localhost:8700\n13:50:56.524 INFO  http-nio-8710-exec-3 DefaultRequestDirector.tryExecute - I/O exception (java.net.SocketException) caught when processing request to {}->http://localhost:8700: Connection reset by peer: socket write error\n13:50:56.527 INFO  http-nio-8710-exec-3 DefaultRequestDirector.tryExecute - Retrying request to {}->http://localhost:8700\n13:50:57.530 INFO  http-nio-8710-exec-3 DefaultRequestDirector.tryExecute - I/O exception (java.net.SocketException) caught when processing request to {}->http://localhost:8700: Connection reset by peer: socket write error\n13:50:57.533 INFO  http-nio-8710-exec-3 DefaultRequestDirector.tryExecute - Retrying request to {}->http://localhost:8700\n13:50:58.538 INFO  http-nio-8710-exec-3 Logger.info - After request [method=PUT;server=http://localhost:8710;uri=/application/api/file/conflictApp/files/a57f597a-bb7f-4221-8097-e4d9222c61cd?null;client=127.0.0.1]\nJul 16, 2014 1:50:58 PM org.apache.catalina.core.StandardWrapperValve invoke\nSEVERE: Servlet.service() for servlet [ourServlet] in context with path [/application] threw exception [Request processing failed; nested exception is org.springframework.web.client.ResourceAccessException: I/O error on PUT request for \"http://localhost:8700/management/api/storage/article/aApp/c47a43b3-88a8-474b-a532-99efc3baa68a\": Connection reset by peer: socket write error; nested exception is java.net.SocketException: Connection reset by peer: socket write error] with root cause\njava.net.SocketException: Connection reset by peer: socket write error\t\n\tjava.net.SocketException: Connection reset by peer: socket write error\n\tat java.net.SocketOutputStream.socketWrite0(Native Method)\n\tat java.net.SocketOutputStream.socketWrite(SocketOutputStream.java:113)\n\tat java.net.SocketOutputStream.write(SocketOutputStream.java:159)\n\tat org.apache.http.impl.io.AbstractSessionOutputBuffer.write(AbstractSessionOutputBuffer.java:181)\n\tat org.apache.http.impl.io.ContentLengthOutputStream.write(ContentLengthOutputStream.java:115)\n\tat org.apache.http.entity.ByteArrayEntity.writeTo(ByteArrayEntity.java:112)\n\tat org.apache.http.entity.HttpEntityWrapper.writeTo(HttpEntityWrapper.java:89)\n\tat org.apache.http.impl.client.EntityEnclosingRequestWrapper$EntityWrapper.writeTo(EntityEnclosingRequestWrapper.java:108)\n\tat org.apache.http.impl.entity.EntitySerializer.serialize(EntitySerializer.java:117)\n\tat org.apache.http.impl.AbstractHttpClientConnection.sendRequestEntity(AbstractHttpClientConnection.java:265)\n\tat org.apache.http.impl.conn.ManagedClientConnectionImpl.sendRequestEntity(ManagedClientConnectionImpl.java:203)\n\tat org.apache.http.protocol.HttpRequestExecutor.doSendRequest(HttpRequestExecutor.java:236)\n\tat org.apache.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:121)\n\tat org.apache.http.impl.client.DefaultRequestDirector.tryExecute(DefaultRequestDirector.java:685)\n\tat org.apache.http.impl.client.DefaultRequestDirector.execute(DefaultRequestDirector.java:487)\n\tat org.apache.http.impl.client.AbstractHttpClient.doExecute(AbstractHttpClient.java:863)\n\tat org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:82)\n\tat org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:57)\n\tat --custom class--\n\tat org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:49)\n\tat org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:510)\n\tat org.springframework.web.client.RestTemplate.execute(RestTemplate.java:486)\n\tat org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:437)\n\tat org.springframework.web.client.RestTemplate$$FastClassBySpringCGLIB$$aa4e9ed0.invoke(<generated>)\n\tat org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204)\n\tat org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:700)\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:150)\n\tat --custom class--\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)\n\tat org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:633)\n\tat org.springframework.web.client.RestTemplate$$EnhancerBySpringCGLIB$$ecebfda9.exchange(<generated>)\n\tat --custom class--\n\tat org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204)\n\tat org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:700)\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:150)\n\tat org.springframework.security.access.intercept.aopalliance.MethodSecurityInterceptor.invoke(MethodSecurityInterceptor.java:64)\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)\n\tat org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:633)\n\tat --custom class--\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:606)\n\tat org.springframework.web.method.support.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:215)\n\tat org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:132)\n\tat org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:104)\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandleMethod(RequestMappingHandlerAdapter.java:745)\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:685)\n\tat org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:80)\n\tat org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:919)\n\tat org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:851)\n\tat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:953)\n\tat org.springframework.web.servlet.FrameworkServlet.doPut(FrameworkServlet.java:866)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:647)\n\tat org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:829)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:725)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:291)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330)\n\tat org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:118)\n\tat org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:84)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n\tat org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:113)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n\tat org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:103)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n\tat org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:154)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n\tat org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:45)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n\tat org.springframework.security.web.authentication.www.BasicAuthenticationFilter.doFilter(BasicAuthenticationFilter.java:201)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n\tat org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:50)\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:106)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n\tat org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:87)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n\tat org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:192)\n\tat org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:160)\n\tat org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:343)\n\tat org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:260)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)\n\tat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:219)\n\tat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:106)\n\tat org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:503)\n\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:136)\n\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:79)\n\tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:88)\n\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:526)\n\tat org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1078)\n\tat org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:655)\n\tat org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.process(Http11NioProtocol.java:222)\n\tat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1566)\n\tat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1523)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n\tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\n\tat java.lang.Thread.run(Thread.java:744)", "tags": [], "creator": "mardkrause@hotmail.com", "is_private": false, "count": 4, "id": 176423, "time": "2014-07-16T14:42:57Z", "bug_id": 56725, "creation_time": "2014-07-16T14:42:57Z", "attachment_id": null}, {"count": 5, "tags": [], "text": "56693 ?", "is_private": false, "id": 176430, "creator": "remm@apache.org", "time": "2014-07-16T15:05:46Z", "bug_id": 56725, "creation_time": "2014-07-16T15:05:46Z", "attachment_id": null}, {"count": 6, "tags": [], "text": "(In reply to mardkrause from comment #4)\n> I received more information form the author of the test, added more logging,\n> and am including more of the client-server log (minus a few of our custom\n> classes).\n> \n> The test acts does the following:\n> 1. send a new file\n>   a. HEAD check if already exists - 404 (Not found)\n>   b. PUT initial small file - 201 (Created)\n> 2. start sending/updating 1GB file (on thread-x with a new HttpClient\n> instance built with same user setup)\n>   a. HEAD check if already exists - 200 (OK)\n>   b. PUT large file\n\nWhat code handles the PUT to these URLs? Are you using Tomcat's WebDAV servlet, or something else? If it's something else, then you might want to take a look at that code.\n\n> 3. attempt to delete the file a few seconds after step 2 starts (on thread-y\n> with a new HttpClient instance built with same user setup)\n>   a. DELETE file\n\nAre you issuing the DELETE request before step 2b has completed? It shouldn't matter -- most OSs will let you write to a deleted file as long as the file handle was valid when it was opened -- but I'm curious.\n\n> We expect (and experience with 8.0.8) that step 3 returns with 409\n> (Conflict) and step 2 returns with 200 (OK).  However, we are experiencing\n> with 8.0.9 that step 2 gets cut off and can't complete.\n\nIs the exception shown here from the \"client server\" or the \"server server\"? I only ask because the log mysteriously changes date formats between the INFO and the SEVERE log messages.\n\nI also notice that every request gets a 401 (Unauthorized) response. Are you checking for that and stopping?\n\nRead Konstantin's comment #3 about aborted uploads: if you get a 401 response, you are probably going to hit that limit with a \"large\" file and find your connection forcibly closed.\n\nI think your test isn't providing correct credentials, and I think it's not checking HTTP status codes when executing a PUT. ;)", "is_private": false, "id": 176439, "creator": "chris@christopherschultz.net", "time": "2014-07-16T20:53:58Z", "bug_id": 56725, "creation_time": "2014-07-16T20:53:58Z", "attachment_id": null}, {"count": 7, "tags": [], "text": "> 127.0.0.1 - - [16/Jul/2014:13:50:39 +0000] \"HEAD /management/api/storage/fileManagement/article/conflictApp/a57f597a-bb7f-4221-8097-e4d9222c61cd HTTP/1.1\" 401 -\n> 127.0.0.1 - - [16/Jul/2014:13:50:39 +0000] \"HEAD /management/api/storage/fileManagement/article/conflictApp/a57f597a-bb7f-4221-8097-e4d9222c61cd HTTP/1.1\" 200 -\n\n\nThe above means that the request is sent twice. The first request fails and asks for authentication.\n\nTo upload an 1Gb file you have to to configure your HTTP Client to either preemptively send correct credentials with the first request, or use Expect: 100-continue header.\n\nIf you have not done either of the above options, the fallback behaviour is to upload the same file twice. Tomcat 8.0.9 protects from such wasting of bandwidth and aborts connection. The size limit is configurable on <Connector> if one really wants it.\n\n\nSee also bug 56693 for a known WebDAV / resource cache issue.", "attachment_id": null, "id": 176453, "creator": "knst.kolinko@gmail.com", "time": "2014-07-17T11:36:00Z", "bug_id": 56725, "creation_time": "2014-07-17T11:36:00Z", "is_private": false}, {"count": 8, "tags": [], "bug_id": 56725, "text": "(In reply to Christopher Schultz from comment #6)\n> What code handles the PUT to these URLs? Are you using Tomcat's WebDAV\n> servlet, or something else? If it's something else, then you might want to\n> take a look at that code.\n> \nWe use org.springframework.web.client.RestOperations to send the requests and Spring controllers to handle all incoming requests.\n\n\n> Are you issuing the DELETE request before step 2b has completed? It\n> shouldn't matter -- most OSs will let you write to a deleted file as long as\n> the file handle was valid when it was opened -- but I'm curious.\n> \nYes, the DELETE happens during the 2b.  We use two java.util.concurrent.Callable to start 2b and then 3a a few seconds later.\n\n\n> Is the exception shown here from the \"client server\" or the \"server server\"?\n> I only ask because the log mysteriously changes date formats between the\n> INFO and the SEVERE log messages.\n> \nThe first set of logs are the access logs (via configuring the AccessLogValve) on the \"server server\" aka \"receiving server\".  These were requested by Konstantin Kolinko.\nThe second set of logs are the normal console logs from the \"client server\".\n\n\n> I also notice that every request gets a 401 (Unauthorized) response. Are you\n> checking for that and stopping?\n> \nWe are aware of the double request.  The RestOperations is handling is.  It seems to first send a request and when 401 is returned it then adds the authorization portion to the request and tries again.\n\n\n> Read Konstantin's comment #3 about aborted uploads: if you get a 401\n> response, you are probably going to hit that limit with a \"large\" file and\n> find your connection forcibly closed.\n> \nIs this something new with 8.0.9?  Because again, that version is the only difference between a successful test run and one that fails.\n\n\n> I think your test isn't providing correct credentials, and I think it's not\n> checking HTTP status codes when executing a PUT. ;)\n>\nIt does provide correct credentials.  If it didn't the test would fail every time, not just when running with 8.0.9.", "id": 176455, "time": "2014-07-17T12:44:39Z", "creator": "mardkrause@hotmail.com", "creation_time": "2014-07-17T12:44:39Z", "is_private": false, "attachment_id": null}, {"count": 9, "tags": [], "bug_id": 56725, "text": "(In reply to mardkrause from comment #8)\n> The first set of logs are the access logs (via configuring the\n> AccessLogValve) on the \"server server\" aka \"receiving server\".  These were\n> requested by Konstantin Kolinko.\n> The second set of logs are the normal console logs from the \"client server\".\n\nI was referring to the discontinuity observed between these two lines of the \"client server\" logs:\n\nRetrying request to {}->http://localhost:8700\n13:50:58.538 INFO  http-nio-8710-exec-3 Logger.info - After request [method=PUT;server=http://localhost:8710;uri=/application/api/file/conflictApp/files/a57f597a-bb7f-4221-8097-e4d9222c61cd?null;client=127.0.0.1]\nJul 16, 2014 1:50:58 PM org.apache.catalina.core.StandardWrapperValve invoke\n\nSEVERE: Servlet.service() for servlet [ourServlet] in context with path [/application] threw exception [Request processing failed; nested exception is org.springframework.web.client.ResourceAccessException: I/O error on PUT request for \"http://localhost:8700/management/api/storage/article/aApp/c47a43b3-88a8-474b-a532-99efc3baa68a\": Connection reset by peer: socket write error; nested exception is java.net.SocketException: Connection reset by peer: socket write error] with root cause\n\n> > I also notice that every request gets a 401 (Unauthorized) response. Are you\n> > checking for that and stopping?\n>\n> We are aware of the double request.  The RestOperations is handling is.  It\n> seems to first send a request and when 401 is returned it then adds the\n> authorization portion to the request and tries again.\n\nSorry, I didn't notice the 201s in that sea of 401s.\n\nWeird. Do you know if \"Expect\" is sent along with either or both requests?\n\n> > Read Konstantin's comment #3 about aborted uploads: if you get a 401\n> > response, you are probably going to hit that limit with a \"large\" file and\n> > find your connection forcibly closed.\n>\n> Is this something new with 8.0.9?  Because again, that version is the only\n> difference between a successful test run and one that fails.\n\nYes, it's new. See the last item under the \"coyote\" section here:\nhttp://tomcat.apache.org/tomcat-8.0-doc/changelog.html\n\nBut note that it's not a limit on legitimate file uploads: instead, its a limit on how much data Tomcat will \"swallow\" if it's going to reject the request. Tomcat used to swallow essentially unlimited data but now it will fail after 2MiB by default by forcibly closing the connection.", "id": 176458, "time": "2014-07-17T14:46:01Z", "creator": "chris@christopherschultz.net", "creation_time": "2014-07-17T14:46:01Z", "is_private": false, "attachment_id": null}, {"count": 10, "tags": [], "creator": "mardkrause@hotmail.com", "attachment_id": null, "text": "(In reply to Christopher Schultz from comment #9)\n> I was referring to the discontinuity observed between these two lines of the\n> \"client server\" logs:\n> \n\nYes, it was an exception on the \"client server\".  We have some inconsistent logging formats, sorry.\n\n\n> Weird. Do you know if \"Expect\" is sent along with either or both requests?\n> \n\nI am not aware if it is or not.  We are not explicitly sending it.\n\n\n> But note that it's not a limit on legitimate file uploads: instead, its a\n> limit on how much data Tomcat will \"swallow\" if it's going to reject the\n> request. Tomcat used to swallow essentially unlimited data but now it will\n> fail after 2MiB by default by forcibly closing the connection.\n\nOk, but this is considered a legitimate file upload.  The large file should continue to upload successfully.", "id": 176465, "time": "2014-07-17T20:22:57Z", "bug_id": 56725, "creation_time": "2014-07-17T20:22:57Z", "is_private": false}]