[{"attachment_id": 29380, "tags": [], "bug_id": 53877, "is_private": false, "count": 0, "id": 162194, "time": "2012-09-15T16:15:09Z", "creator": "everymoment@comcast.net", "creation_time": "2012-09-15T16:15:09Z", "text": "Created attachment 29380\nDemonstrates an error, possibly in HSSFrow.moveCell()\n\nThe attached java file POI_error_in_column_deletes.java attempts to demonstrate one way to program column deletes in POI 3.8. This java program does the following: \n  - creates a new workbook\n  - creates 10 rows each containing 10 empty cells\n  - fills in range A3:E3 with \"A\", \"B\", \"C\", \"D\", and \"E\"\n  - runs code designed to delete columns B and C,\n      but instead of getting ADE in the third row it gets ACE\n  - outputs a workbook testDeleteColumns.xls\n\nIt get the same incorrect result in POI 3.8 and in the poi-3.9-beta1-20120915.jar nightly.\n\nThe inner loop of deleting columns, which contains the error, is the method deleteColumnFromRow:\n\n\n/** Removes a cell at START_COL and shifts remainder of row to the left by one.\n * @param row row from which to delete and shift cells\n * @param START_COL index of cell to remove\n */\nprivate static void deleteColumnFromRow(HSSFRow row, final int START_COL){\n    if(START_COL >= COLS){\n        return;\n    }\n    HSSFCell check = row.getCell(START_COL);\n    if(null!=check){\n        row.removeCell(check);\n    }\n    System.err.println(\n        \"        deleteColumnFromRow: row = \"+\n        row.getRowNum());\n    HSSFCell cell = null;\n    for(int col = START_COL+1; col < COLS; col++){\n        int source = col;\n        int destination = col-1;\n        cell = row.getCell(source);\n        if(null != row.getCell(destination)){\n            row.removeCell(row.getCell(destination));\n            // Because the API says the destination cannot exist,\n            // the destination has been deleted. The API reference is\n            // poi.apache.org/apidocs/org/apache/poi/hssf/usermodel/HSSFRow.html\n        }\n        if(null != cell){\n            // I THINK THE ERROR MIGHT BE IN moveCell().\n            row.moveCell(cell,(short)(destination));\n        }\n    }\n}"}, {"count": 1, "tags": [], "text": "I've also had difficulty getting a working 'deleteColumns()' method, and would very much like to know if a solution is on offer.", "is_private": false, "id": 167157, "creator": "monzarc@gmail.com", "time": "2013-05-12T23:11:26Z", "bug_id": 53877, "creation_time": "2013-05-12T23:11:26Z", "attachment_id": null}, {"count": 2, "tags": [], "bug_id": 53877, "attachment_id": null, "is_private": false, "id": 169744, "time": "2013-08-27T20:05:04Z", "creator": "dominik.stadler@gmx.at", "creation_time": "2013-08-27T20:05:04Z", "text": "When I run your test-program with the latest trunk-version of poi I get A D E correctly, it seems the bug was fixed at some point. Please reopen or report a new bug with updated information if there is still a problem for you with snapshot builds or the next upcoming release (likely 3.10)."}, {"count": 3, "tags": [], "text": "This bug recurs in 3.12.\n\nUsing the previously-attached POI_error_in_column_deletes class, I created a batch file comprising the following commands:\n\nset c1=poi-3.12-20150511.jar\nset c2=POI_error_in_column_deletes\ndel %c2%.class\ndel testDeleteColumns.xls\njavac -cp %c1% %c2%.java\njava -cp %c1%; %c2%\n\nThe result is a new .xls file whose columns read 'ACE', instead of the proper output of 'ADE'.\n\nThe java version running is 1.8.0_60. The POI version is 3.12-20150511.", "is_private": false, "id": 185216, "creator": "monzarc@gmail.com", "time": "2015-09-14T01:51:00Z", "bug_id": 53877, "creation_time": "2015-09-14T01:51:00Z", "attachment_id": null}, {"attachment_id": null, "tags": [], "bug_id": 53877, "is_private": false, "count": 4, "id": 188511, "time": "2016-02-17T18:36:03Z", "creator": "dominik.stadler@gmx.at", "creation_time": "2016-02-17T18:36:03Z", "text": "I tried it again at it does work for me, not sure where the difference is to what you see. Please use the following unit test and show how it needs to be adjusted to cause the problem if this is really still a problem for you.\n\nThis test verifies that \"A\", \"D\", \"E\" end up in the columns, but I also checked with LibreOffice (sorry, no MS Office on this machine)\n\n    private static final int ROWS = 10;\n    private static final int COLS = 10;\n\n    @Test\n    public void test_deleteColumns() throws IOException {\n        HSSFWorkbook wb = new HSSFWorkbook();\n        HSSFSheet sh = wb.createSheet(\"sheet1\");\n        HSSFRow r = null;\n        for (int row = 0; row < ROWS; row++) {\n            r = sh.createRow(row);\n            for (int col = 0; col < COLS; col++) {\n                r.createCell(col);\n            }\n        }\n        sh.getRow(2).getCell(0).setCellValue(\"A\");\n        sh.getRow(2).getCell(1).setCellValue(\"B\");\n        sh.getRow(2).getCell(2).setCellValue(\"C\");\n        sh.getRow(2).getCell(3).setCellValue(\"D\");\n        sh.getRow(2).getCell(4).setCellValue(\"E\");\n        // Put in ABCDE into consecutive cells;\n        // deletion should have gotten ADE but got ACE instead.\n        for (int deleteIndex = 0; deleteIndex < 2; deleteIndex++) {\n            HSSFRow row = sh.getRow(2);\n            if (null != row) {\n                deleteColumnFromRow(row, 1);\n            }\n        }\n        \n        assertEquals(\"A\", sh.getRow(2).getCell(0).getStringCellValue());\n        assertEquals(\"D\", sh.getRow(2).getCell(1).getStringCellValue());\n        assertEquals(\"E\", sh.getRow(2).getCell(2).getStringCellValue());\n        \n        wb.close();\n    }\n\n\n    private void deleteColumnFromRow(HSSFRow row, final int START_COL) {\n        if (START_COL >= COLS) {\n            return;\n        }\n        HSSFCell check = row.getCell(START_COL);\n        if (null != check) {\n            row.removeCell(check);\n        }\n        System.err.println(\n                \"        deleteColumnFromRow: row = \" + row.getRowNum());\n        HSSFCell cell = null;\n        for (int col = START_COL + 1; col < COLS; col++) {\n            int source = col;\n            int destination = col - 1;\n            cell = row.getCell(source);\n            if (null != row.getCell(destination)) {\n                row.removeCell(row.getCell(destination));\n                // Because the API says the destination cannot exist,\n                // the destination has been deleted. The API reference is\n                // poi.apache.org/apidocs/org/apache/poi/hssf/usermodel/HSSFRow.html\n            }\n            if (null != cell) {\n                // moveCell is most likely where the error occurs.\n                row.moveCell(cell, (short) (destination));\n            }\n        }\n    }"}]