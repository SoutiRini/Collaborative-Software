[{"count": 0, "attachment_id": null, "bug_id": 58321, "text": "Reported by RV-Predict (a dynamic race detector) when running against the test suite:\n\nData race on field javax.crypto.Cipher.initialized: {{{\nConcurrent read in thread T46 (locks held: {})\n ---->  at javax.crypto.Cipher.checkCipherState(Cipher.java:1749)\n        at javax.crypto.Cipher.update(Cipher.java:1932)\n        at javax.net.ssl.SSLEngine.unwrap(SSLEngine.java:624)\n        at org.apache.tomcat.util.net.SecureNio2Channel$3.completed(SecureNio2Channel.java:746)\n        at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\n    T46 is created by T44\n        at java.util.concurrent.ThreadPoolExecutor.addWorker(ThreadPoolExecutor.java:1010)\n\nConcurrent write in thread T55 (locks held: {})\n ---->  at javax.crypto.Cipher.init(Cipher.java:1399)\n        at javax.net.ssl.SSLEngine.unwrap(SSLEngine.java:624)\n        at org.apache.tomcat.util.net.SecureNio2Channel$3.completed(SecureNio2Channel.java:746)\n        at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\n    T55 is created by T40\n        at java.util.concurrent.ThreadPoolExecutor.addWorker(ThreadPoolExecutor.java:1010)\n}}} \n\nData race on field javax.crypto.Cipher.opmode: {{{\nConcurrent read in thread T46 (locks held: {})\n ---->  at javax.crypto.Cipher.checkCipherState(Cipher.java:1752)\n        at javax.crypto.Cipher.update(Cipher.java:1932)\n        at javax.net.ssl.SSLEngine.unwrap(SSLEngine.java:624)\n        at org.apache.tomcat.util.net.SecureNio2Channel$3.completed(SecureNio2Channel.java:746)\n        at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\n    T46 is created by T44\n        at java.util.concurrent.ThreadPoolExecutor.addWorker(ThreadPoolExecutor.java:1010)\n\nConcurrent write in thread T55 (locks held: {})\n ---->  at javax.crypto.Cipher.init(Cipher.java:1400)\n        at javax.net.ssl.SSLEngine.unwrap(SSLEngine.java:624)\n        at org.apache.tomcat.util.net.SecureNio2Channel$3.completed(SecureNio2Channel.java:746)\n        at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\n    T55 is created by T40\n        at java.util.concurrent.ThreadPoolExecutor.addWorker(ThreadPoolExecutor.java:1010)\n}}} \n\nData race on field javax.crypto.Cipher.spi: {{{\nConcurrent read in thread T46 (locks held: {})\n ---->  at javax.crypto.Cipher.chooseFirstProvider(Cipher.java:717)\n        at javax.crypto.Cipher.getBlockSize(Cipher.java:929)\n        at javax.net.ssl.SSLEngine.unwrap(SSLEngine.java:624)\n        at org.apache.tomcat.util.net.SecureNio2Channel$3.completed(SecureNio2Channel.java:746)\n        at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\n    T46 is created by T44\n        at java.util.concurrent.ThreadPoolExecutor.addWorker(ThreadPoolExecutor.java:1010)\n\nConcurrent write in thread T55 (locks held: {Monitor@618773ae})\n ---->  at javax.crypto.Cipher.chooseProvider(Cipher.java:867)\n        - locked Monitor@618773ae at javax.crypto.Cipher.chooseProvider(Cipher.java:825)\n        at javax.crypto.Cipher.init(Cipher.java:1396)\n        at javax.net.ssl.SSLEngine.unwrap(SSLEngine.java:624)\n        at org.apache.tomcat.util.net.SecureNio2Channel$3.completed(SecureNio2Channel.java:746)\n        at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\n    T55 is created by T40\n        at java.util.concurrent.ThreadPoolExecutor.addWorker(ThreadPoolExecutor.java:1010)\n}}} \n\nLooks like the root cause is that SSLEngine.unwrap is called by multiple threads concurrently? The Javadoc of SSLEngine (http://docs.oracle.com/javase/8/docs/api/javax/net/ssl/SSLEngine.html) mentions this situation in the Concurrency Notes section.", "id": 184926, "time": "2015-09-03T11:46:17Z", "creator": "yilong.li@runtimeverification.com", "creation_time": "2015-09-03T11:46:17Z", "tags": [], "is_private": false}, {"count": 1, "attachment_id": null, "bug_id": 58321, "text": "This looks invalid as the IO operations are protected by pending flags and/or semaphores. I get it your tool seems to use (sub)classes independently, which is not the case here.", "id": 184927, "time": "2015-09-03T11:59:13Z", "creator": "remm@apache.org", "creation_time": "2015-09-03T11:59:13Z", "tags": [], "is_private": false}, {"count": 2, "tags": [], "bug_id": 58321, "attachment_id": null, "text": "(In reply to Remy Maucherat from comment #1)\n> This looks invalid as the IO operations are protected by pending flags\n> and/or semaphores. I get it your tool seems to use (sub)classes\n> independently, which is not the case here.\n\nHi Remy, thanks for your quick response. Can you please be more specific about the synchronization mechanism applied here? For example, which pending flags, semaphores, futures are functioning in this case? The thing is that, ideally, our tool should have zero false positive and we take false positive very seriously. I would like to understand the problem and fix it. Thanks again!", "id": 184928, "time": "2015-09-03T12:16:31Z", "creator": "yilong.li@runtimeverification.com", "creation_time": "2015-09-03T12:16:31Z", "is_private": false}, {"count": 3, "tags": [], "creator": "remm@apache.org", "attachment_id": null, "id": 184936, "time": "2015-09-03T14:04:46Z", "bug_id": 58321, "creation_time": "2015-09-03T14:04:46Z", "is_private": false, "text": "No idea, it sounds too specific to the NIO2 behavior. Sure the completion handler is going to be called directly by the main thread pool, but only once per IO operation, and since a read cannot occur until the previous one is done it's fine as is."}, {"count": 4, "tags": [], "bug_id": 58321, "attachment_id": null, "text": "Given bug 57799 which suggests that there might be a concurrency issue with NIO2 and TLS it might be worth taking a closer look at the stack traces in this report to see if they offer any clues.", "id": 184937, "time": "2015-09-03T14:07:47Z", "creator": "markt@apache.org", "creation_time": "2015-09-03T14:07:47Z", "is_private": false}, {"text": "Yes, but I don't see how a concurrent read is possible, and this is a \"non blocking\" read, that other bug is supposed to be using blocking IO.", "tags": [], "bug_id": 58321, "is_private": false, "count": 5, "id": 184939, "time": "2015-09-03T14:42:59Z", "creator": "remm@apache.org", "creation_time": "2015-09-03T14:42:59Z", "attachment_id": null}, {"id": 184942, "tags": [], "bug_id": 58321, "is_private": false, "count": 6, "text": "(In reply to Remy Maucherat from comment #3)\n> No idea, it sounds too specific to the NIO2 behavior. Sure the completion\n> handler is going to be called directly by the main thread pool, but only\n> once per IO operation, and since a read cannot occur until the previous one\n> is done it's fine as is.\n\nThank you, that's what I need to know. I will fix the tool to handle the happens-before relationship imposed by java.nio.channels.AsynchronousSocketChannel properly.", "time": "2015-09-03T16:18:53Z", "creator": "yilong.li@runtimeverification.com", "creation_time": "2015-09-03T16:18:53Z", "attachment_id": null}, {"count": 7, "tags": [], "creator": "yilong.li@runtimeverification.com", "attachment_id": null, "id": 184943, "time": "2015-09-03T16:58:06Z", "bug_id": 58321, "creation_time": "2015-09-03T16:58:06Z", "is_private": false, "text": "(In reply to Remy Maucherat from comment #3)\n> No idea, it sounds too specific to the NIO2 behavior. Sure the completion\n> handler is going to be called directly by the main thread pool, but only\n> once per IO operation, and since a read cannot occur until the previous one\n> is done it's fine as is.\n\nSorry, I think I misunderstood your reply in my previous message. So you are saying that the completion handler cannot be called concurrently, right? Why is that? Or more precisely, what makes sure that \"a read cannot occur until the previous one is done\"? AsynchronousSocketChannel? CompletionHandler? Also, what do you mean by \"a read is done\"? After the \"readCompletionHandler\" in \"sc.read(netInBuffer, timeout, unit, attachment, readCompletionHandler);\" (https://github.com/apache/tomcat80/blob/TOMCAT_8_0_24/java/org/apache/tomcat/util/net/SecureNio2Channel.java#L792) is called? Sorry for the many questions because I am not familiar enough with the source code."}, {"count": 8, "tags": [], "bug_id": 58321, "text": "Yes, I think that's too many questions for BZ. NIO2 does not allow concurrency, and in addition to the SSL engine, concurrency would also corrupt all the buffers used. The socket wrapper ensures that doesn't happen.", "id": 184965, "time": "2015-09-04T11:37:32Z", "creator": "remm@apache.org", "creation_time": "2015-09-04T11:37:32Z", "is_private": false, "attachment_id": null}, {"count": 9, "tags": [], "bug_id": 58321, "is_private": false, "text": "I'm trying to reproduce these results. Could you share how you configured the tests to run with RV-Predict.", "id": 185087, "time": "2015-09-10T18:11:24Z", "creator": "markt@apache.org", "creation_time": "2015-09-10T18:11:24Z", "attachment_id": null}, {"count": 10, "tags": [], "creator": "yilong.li@runtimeverification.com", "attachment_id": null, "text": "(In reply to Mark Thomas from comment #9)\n> I'm trying to reproduce these results. Could you share how you configured\n> the tests to run with RV-Predict.\n\nThe general instructions to run RV-Predict as a Java agent can be found here: https://runtimeverification.com/predict/1.6/docs/quickstart/#as-an-agent.\n\nIn short, to run RV-Predict against Tomcat's test suite, I add the following lines to the JUnit configuration in build.xml:\n\n<jvmarg value=\"-Xbootclasspath/a:<rvpath>/lib/rv-predict.jar\" />\n<jvmarg value=\"-javaagent:<rvpath>/lib/rv-predict.jar=--stacks\" />\n<jvmarg value=\"-XX:hashCode=1\"/>\n\nwhere <rvpath> is the installation path of RV-Predict.\n\nIf you are on Linux/OSX machine, you also have to do `source <rvpath>/lib/setenv` to add z3 native library to environment variable LD_LIBRARY_PATH.\n\nRegarding this bug report, it could be a false positive due to incorrect handling of java.nio.ch.* in RV-Predict. I haven't got a chance to investigate it further.", "id": 185103, "time": "2015-09-11T07:31:35Z", "bug_id": 58321, "creation_time": "2015-09-11T07:31:35Z", "is_private": false}, {"id": 185104, "tags": [], "bug_id": 58321, "is_private": false, "count": 11, "text": "(In reply to Yilong Li from comment #10)\n> (In reply to Mark Thomas from comment #9)\n> > I'm trying to reproduce these results. Could you share how you configured\n> > the tests to run with RV-Predict.\n> \n> The general instructions to run RV-Predict as a Java agent can be found\n> here:\n> https://runtimeverification.com/predict/1.6/docs/quickstart/#as-an-agent.\n> \n> In short, to run RV-Predict against Tomcat's test suite, I add the following\n> lines to the JUnit configuration in build.xml:\n> \n> <jvmarg value=\"-Xbootclasspath/a:<rvpath>/lib/rv-predict.jar\" />\n> <jvmarg value=\"-javaagent:<rvpath>/lib/rv-predict.jar=--stacks\" />\n> <jvmarg value=\"-XX:hashCode=1\"/>\n> \n> where <rvpath> is the installation path of RV-Predict.\n> \n> If you are on Linux/OSX machine, you also have to do `source\n> <rvpath>/lib/setenv` to add z3 native library to environment variable\n> LD_LIBRARY_PATH.\n> \n> Regarding this bug report, it could be a false positive due to incorrect\n> handling of java.nio.ch.* in RV-Predict. I haven't got a chance to\n> investigate it further.\n\nOops, I forgot to mention that I add those lines to build.xml before line#1427.", "time": "2015-09-11T07:34:22Z", "creator": "yilong.li@runtimeverification.com", "creation_time": "2015-09-11T07:34:22Z", "attachment_id": null}]