[{"count": 0, "attachment_id": null, "creator": "vmahajan@amberpoint.com", "text": "On debugging I found that the problem occurs due to the keysSigning and\nkeysVerify ThreadLocal members of the SignatureAlgorithm class.\n\nEven if we may be working with two completely different documents to be verified\nin the same thread, and both contain say the same certificate inside the\nKeyInfo, somehow Java returns the same public key instance in both the cases and\nin the latter case the signature/verification is not initialized properly (an\nerror message is thrown by Java).", "id": 112754, "time": "2008-01-10T21:51:55Z", "bug_id": 44204, "creation_time": "2008-01-10T21:51:55Z", "tags": [], "is_private": false}, {"count": 1, "tags": [], "creator": "raul-info@r-bg.com", "attachment_id": null, "text": "Please can you post the exception. And if you can an small program that stress\nthe bug. Anyway It is a little strange as this is the normal use case and I have\ntested thousands of times (reuse the digester if they use the same key with just\na reset)", "id": 112760, "time": "2008-01-11T01:47:24Z", "bug_id": 44204, "creation_time": "2008-01-11T01:47:24Z", "is_private": false}, {"count": 2, "tags": [], "bug_id": 44204, "attachment_id": null, "id": 112793, "time": "2008-01-14T00:19:48Z", "creator": "vmahajan@amberpoint.com", "creation_time": "2008-01-14T00:19:48Z", "is_private": false, "text": "Below is the stack trace. I am also going to attach a test case for the same. I\nhave to admit though that it might not be a very common use case.\n\njava.lang.RuntimeException:\norg.apache.xml.security.signature.XMLSignatureException: object not initialized\nfor signature or verification\nOriginal Exception was java.security.SignatureException: object not initialized\nfor signature or verification\n\tat\norg.apache.xml.security.utils.SignerOutputStream.write(SignerOutputStream.java:66)\n\tat\norg.apache.xml.security.utils.UnsyncBufferedOutputStream.flushBuffer(UnsyncBufferedOutputStream.java:69)\n\tat\norg.apache.xml.security.utils.UnsyncBufferedOutputStream.flush(UnsyncBufferedOutputStream.java:85)\n\tat\norg.apache.xml.security.utils.UnsyncBufferedOutputStream.close(UnsyncBufferedOutputStream.java:91)\n\tat\norg.apache.xml.security.c14n.implementations.CanonicalizerBase.engineCanonicalizeSubTree(CanonicalizerBase.java:207)\n\tat\norg.apache.xml.security.c14n.implementations.CanonicalizerBase.engineCanonicalizeSubTree(CanonicalizerBase.java:121)\n\tat\norg.apache.xml.security.c14n.Canonicalizer.canonicalizeSubtree(Canonicalizer.java:242)\n\tat\norg.apache.xml.security.signature.SignedInfo.signInOctectStream(SignedInfo.java:280)\n\tat\norg.apache.xml.security.signature.XMLSignature.checkSignatureValue(XMLSignature.java:620)\n\tat TestSigAlg.main(TestSigAlg.java:105)\n\n"}, {"count": 3, "attachment_id": 21381, "creator": "vmahajan@amberpoint.com", "text": "Created attachment 21381\nReproducible test case for the bug", "id": 112794, "time": "2008-01-14T00:21:56Z", "bug_id": 44204, "creation_time": "2008-01-14T00:21:56Z", "tags": [], "is_private": false}, {"count": 4, "tags": [], "bug_id": 44204, "text": "I spent some time diagnosing this, as it was also reported by one of our\nproject's users.\n\nThis is occurring when, for the first signature, you use the same XMLSignature\ninstance to both sign and then verify the signature.  If you create a new\nXMLSignature instance around the Signature element and verify using that, the\nproblem does not occur.  So I guess that's the workaround.  I know using the\nsame instance for both has been discouraged on the list before.\n\nThe explanation: this is occurring because of how the ThreadLocal instances* and\nkeys* caches in SignatureAlgorithm are being used.  What happens is:\n\n1) sign document.  The instancesSigning and keysSigning caches are populated\nwith the SignatureAlgorithmSpi instance and key reference as expected.\n\n2) Call checkSignatureValue() with same XMLSignaure.  Note the same\nSignatureAlgorithm instance is being used, with an already populated instance of\nSignatureAlgorithmSpi.\n\n3) When initVerify() is now called, the initializeAlgorithm() is a no-op,\nbecause the underlying SignatureAlgorithmSpi on that instance is already there.\n However the keysVerify map does *not* contain the entry for that\nalgorithmURI->key, so that is added and the Spi engine is (re)-initialized for\n*verifying*.\n\n4) verification is successful.  Note at this point that you have entries in both\nkeysSigning and keysVerify for that key, but only one Spi instance, cached in\ninstancesSigning (but left in a state initialized for *verifying* with that key!)\n\n5) now verify a new signature with the same algorithmURI and key instance.  New\nXMLSignature instance is created, with new underlying SignatureAlgorithm instance.\n\n6) checkSignatureValue() calls initVerify().  Here's where the (evil) magic\nhappens.  initializeAlgorithm() has to obtain the right SignatureAlgorithmSpi\ninstance.  There is *not* one in instancesVerify (b/c the previous verification\nused the one which was cached in instancesSigning).  So it creates a new one and\nstores in the cache.  However, because the last key used for that algorithmURI\nfor verification, as cached by keysVerify, is the same key, it does *not* call\nthe Spi's engineInitVerify().  So the underlying java.security.Signature/Mac\ninstance is never initialized, resulting in the java.security.SignatureException\nwhen it is actually used.\n\nNote also that if the next attempt to *sign* something with that algorithmURI\nwere with the same key, I believe you'd get a similar error.  The cached\ninstance of the Spi in instancesSigning wouldn't get reinitialized because of\nthe optimization.  And since it was last initialized for *verifying* not\nsigning, I assume that causes Bad Things to happen.\n\nNote this is similar to the bug I analyzed in:\nhttp://issues.apache.org/bugzilla/show_bug.cgi?id=44335\n\nIt's coming from the fact that the optimization in SignatureAlgorithm#initVerify\n(and also #initSign) assumes that if the last key used per algorithm is the same\nas the current one, then the engine is already in a known good \"ready\" state and\ndoesn't need to be reinitialized.\n\nAssuming the optimizations are maintained, I think a good possible solution for\nboth is for the Spi to expose state as to whether: 1) it is in the \"ready\" state\n2) whether it is currently initialized for signing or verifying.  This would\nallow the SignatureAlgorithm init methods to always do the right thing\n(reinitialize the Spi engine) when necessary.", "id": 113553, "time": "2008-02-07T15:41:49Z", "creator": "putmanb@georgetown.edu", "creation_time": "2008-02-07T15:41:49Z", "is_private": false, "attachment_id": null}, {"count": 5, "attachment_id": null, "creator": "coheigea@apache.org", "text": "\nThis bug is a duplicate of 47097:\n\nhttps://issues.apache.org/bugzilla/show_bug.cgi?id=47097\n\n\"Reusing XMLSignature for signing and verifying fails on same thread\"\n\nwhich has been fixed on HEAD. I tried the test-case and it works fine now, so closing this bug.\n\nColm.\n\n*** This bug has been marked as a duplicate of bug 47097 ***", "id": 128044, "time": "2009-06-18T03:45:07Z", "bug_id": 44204, "creation_time": "2009-06-18T03:45:07Z", "tags": [], "is_private": false}]