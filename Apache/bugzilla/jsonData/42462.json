[{"count": 0, "tags": [], "creator": "fabio.gavilondo@gmail.com", "text": "The ClearCase optional tasks\n(http://ant.apache.org/manual/OptionalTasks/clearcase.html) don't offer support\nfor merge operations.\n\nI have written a 'CCFindmerge' task that inherits from\norg.apache.tools.ant.taskdefs.optional.clearcase.ClearCase, pretty much in the\nsame vain as the other cc tasks.\n\nPerforming a 'findmerge' from your Ant build file is quite useful in situations\nwhere a view/branch needs to be up-to-date with another view/branch ( e.g. the\nmainline) before the build can proceed. If a merge is necessary, this command\nwill fail the build (i.e. throw a BuildException).\n\nI thought that maybe other Ant/ClearCase users out there could use this task\ntoo, so I would like to contribute CCFindmerge to the Apache Ant codebase. I\nhave done a svn diff. Please find the patch below.\n\nRegards and many thanks for your continuing support of Ant.\n\nIndex:\n/ant-trunk/src/main/org/apache/tools/ant/taskdefs/optional/clearcase/CCFindmerge.java\n===================================================================\n---\n/ant-trunk/src/main/org/apache/tools/ant/taskdefs/optional/clearcase/CCFindmerge.java\n(revision 0)\n+++\n/ant-trunk/src/main/org/apache/tools/ant/taskdefs/optional/clearcase/CCFindmerge.java\n(revision 0)\n@@ -0,0 +1,384 @@\n+/*\n+ * Copyright  2000-2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.apache.tools.ant.taskdefs.optional.clearcase;\n+\n+import org.apache.tools.ant.BuildException;\n+import org.apache.tools.ant.Project;\n+import org.apache.tools.ant.types.Commandline;\n+\n+/**\n+ * Performs a ClearCase findmerge.\n+ * \n+ * The command will not actually merge anything, just fail the build if a merge\nis necessary. This check is quite useful\n+ * in situations where a view/branch needs to be up-to-date with another\nview/branch (e.g. main) before running build\n+ * can be run.\n+ * \n+ * <p>\n+ * The following attributes are interpreted:\n+ * \n+ * <table border=\"1\">\n+ * <tr>\n+ * <th>Attribute</th>\n+ * <th>Values</th>\n+ * <th>Required</th>\n+ * </tr>\n+ * <tr>\n+ * <td>viewpath</td>\n+ * <td>Path to the ClearCase view file or directory that the command will\noperate on</td>\n+ * <td>No</td>\n+ * </tr>\n+ * <tr>\n+ * <td>viewtag</td>\n+ * <td>view-tag. Compare the version selected by your view with the version\nselected by the view specified by view-tag.\n+ * view-tag may not specify a snapshot view. A version of the same element is\nalways used, even if the version has a\n+ * different name in the other view.</td>\n+ * <td>No</td>\n+ * </tr>\n+ * <tr>\n+ * <td>version</td>\n+ * <td>version-selector. Compare with the version specified by the\nversion-selector. A version selector involving a\n+ * branch type, for example /main/LATEST or .../branch1/LATEST, is optimized\nfor selecting the set of versions to\n+ * consider and performs better than other types of queries. If the branch\nexists only on a relatively small number of\n+ * versions in the VOB, this option performs much better than other types of\nqueries.</td>\n+ * <td>No</td>\n+ * </tr>\n+ * <tr>\n+ * <td>latest</td>\n+ * <td>(Consider only versions that are currently checked out.) Compare with\nthe most recent version on the branch from\n+ * which your version was checked out. This option is useful with versions for\nwhich you have unreserved checkouts: if\n+ * one or more new versions have been checked in by other users, you must merge\nthe most recent one into your\n+ * checked-out version before you can perform a checkin.</td>\n+ * <td>No</td>\n+ * </tr>\n+ * <tr>\n+ * <td>depth</td>\n+ * <td>Causes directory entries to be processed before the directory itself.</td>\n+ * <td>No</td>\n+ * </tr>\n+ * <tr>\n+ * <td>nrecurse</td>\n+ * <td>For each directory version, considers the file and directory versions\nwithin it, but does not descend into its\n+ * subdirectories.</td>\n+ * <td>No</td>\n+ * </tr>\n+ * <tr>\n+ * <td>directory</td>\n+ * <td>For each directory, considers only the directory itself, not the\ndirectory or file versions, or VOB symbolic\n+ * links it catalogs.</td>\n+ * <td>No</td>\n+ * </tr>\n+ * <tr>\n+ * <td>follow</td>\n+ * <td>Causes VOB symbolic links to be traversed.</td>\n+ * <td>No</td>\n+ * </tr>\n+ * <tr>\n+ * <td>nzero</td>\n+ * <td>Does not perform a merge if the from-contributor is version 0 on its\nbranch. This gives you the opportunity to\n+ * delete the empty branch, and then perform a merge from the version at which\nthe branch was created.</td>\n+ * <td>No</td>\n+ * </tr>\n+ * <tr>\n+ * <td>nback</td>\n+ * <td>Does not perform the merge in the case described earlier. It may be\nappropriate to simulate the merge by moving\n+ * the version label down to the from-version. Note, however, that this\nalternative leaves the version without a\n+ * subbranch, which may or may not be desirable.</td>\n+ * <td>No</td>\n+ * </tr>\n+ * <tr>\n+ * <td>whynot</td>\n+ * <td>For each version that does not require a merge, displays a message\nexplaining the reason. This is especially\n+ * useful when you are merging between views whose namespaces differ\nsignificantly.</td>\n+ * <td>No</td>\n+ * </tr>\n+ * <tr>\n+ * <td>visible</td>\n+ * <td>Suppresses the warning messages for versions that are not visible in the\ncurrent view.</td>\n+ * <td>No</td>\n+ * </tr>\n+ * <tr>\n+ * <tr>\n+ * <td>log</td>\n+ * <td>pname. Creates pname as the merge log file, instead of selecting a name\nautomatically. To suppress creation of a\n+ * merge log file, use \u2013log /dev/null (UNIX) or \u2013log NUL (Windows)</td>\n+ * <td>No</td>\n+ * </tr>\n+ * <tr>\n+ * <td>failonerr</td>\n+ * <td>Throw an exception if the command fails. Default is true.</td>\n+ * <td>No</td>\n+ * </tr>\n+ * </table>\n+ * \n+ * @author Fabio Gavilondo\n+ */\n+public class CCFindmerge extends ClearCase {\n+    public static final String COMMAND_FINDMERGE = \"findmerge\";\n+\n+    private static final String FLAG_VIEWTAG = \"-ftag\";\n+\n+    private static final String FLAG_VERSION = \"-fversion\";\n+\n+    private static final String FLAG_LATEST = \"-flatest\";\n+\n+    private static final String FLAG_DEPTH = \"-depth\";\n+\n+    private static final String FLAG_NRECURSE = \"-nrecurse\";\n+\n+    private static final String FLAG_DIRECTORY = \"-directory\";\n+\n+    private static final String FLAG_FOLLOW = \"-follow\";\n+\n+    private static final String FLAG_VISIBLE = \"-visible\";\n+\n+    private static final String FLAG_NZERO = \"-nzero\";\n+\n+    private static final String FLAG_NBACK = \"-nback\";\n+\n+    private static final String FLAG_WHYNOT = \"-whynot\";\n+\n+    private static final String FLAG_LOG = \"-log\";\n+\n+    private static final String FLAG_PRINT = \"-print\";\n+\n+    private String viewtag = null;\n+\n+    private String version = null;\n+\n+    private boolean latest = false;\n+\n+    private boolean depth = false;\n+\n+    private boolean nrecurse = false;\n+\n+    private boolean directory = false;\n+\n+    private boolean follow = false;\n+\n+    private boolean visible = false;\n+\n+    private boolean nzero = false;\n+\n+    private boolean nback = false;\n+\n+    private boolean whynot = false;\n+\n+    private String log = null;\n+\n+    public boolean getDepth() {\n+        return depth;\n+    }\n+\n+    public void setDepth(boolean depth) {\n+        this.depth = depth;\n+    }\n+\n+    public boolean getDirectory() {\n+        return directory;\n+    }\n+\n+    public void setDirectory(boolean directory) {\n+        this.directory = directory;\n+    }\n+\n+    public boolean getFollow() {\n+        return follow;\n+    }\n+\n+    public void setFollow(boolean follow) {\n+        this.follow = follow;\n+    }\n+\n+    public boolean getLatest() {\n+        return latest;\n+    }\n+\n+    public void setLatest(boolean latest) {\n+        this.latest = latest;\n+    }\n+\n+    public String getLog() {\n+        return log;\n+    }\n+\n+    public void setLog(String log) {\n+        this.log = log;\n+    }\n+\n+    public boolean getNback() {\n+        return nback;\n+    }\n+\n+    public void setNback(boolean nback) {\n+        this.nback = nback;\n+    }\n+\n+    public boolean getNrecurse() {\n+        return nrecurse;\n+    }\n+\n+    public void setNrecurse(boolean nrecurse) {\n+        this.nrecurse = nrecurse;\n+    }\n+\n+    public boolean getNzero() {\n+        return nzero;\n+    }\n+\n+    public void setNzero(boolean nzero) {\n+        this.nzero = nzero;\n+    }\n+\n+    public String getVersion() {\n+        return version;\n+    }\n+\n+    public void setVersion(String version) {\n+        this.version = version;\n+    }\n+\n+    public String getViewtag() {\n+        return viewtag;\n+    }\n+\n+    public void setViewtag(String viewtag) {\n+        this.viewtag = viewtag;\n+    }\n+\n+    public boolean getVisible() {\n+        return visible;\n+    }\n+\n+    public void setVisible(boolean visible) {\n+        this.visible = visible;\n+    }\n+\n+    public boolean getWhynot() {\n+        return whynot;\n+    }\n+\n+    public void setWhynot(boolean whynot) {\n+        this.whynot = whynot;\n+    }\n+\n+    public void execute() throws BuildException {\n+        Commandline commandLine = new Commandline();\n+        Project aProj = getProject();\n+\n+        // Default the viewpath to basedir if it is not specified\n+        if (getViewPath() == null) {\n+            setViewPath(aProj.getBaseDir().getPath());\n+        }\n+\n+        commandLine.setExecutable(getClearToolCommand());\n+        commandLine.createArgument().setValue(COMMAND_FINDMERGE);\n+\n+        // Check the command line options\n+        checkOptions(commandLine);\n+\n+        // For debugging\n+        getProject().log(commandLine.toString(), Project.MSG_DEBUG);\n+\n+        if (!getFailOnErr()) {\n+            getProject().log(\"Ignoring any errors that occur for: \" +\ngetViewPathBasename(), Project.MSG_VERBOSE);\n+        }\n+\n+        getProject().log(\"running command line: \" + commandLine.toString(),\nProject.MSG_VERBOSE);\n+        String result = runS(commandLine);\n+        getProject().log(\"findmerge result: \" + result, Project.MSG_VERBOSE);\n+\n+        if (getFailOnErr() && isCleartoolErrorOutput(result)) {\n+            String msg = \"Failed executing: \\\"\" + commandLine.toString() + \"\\\".\nReason: \" + result;\n+            throw new BuildException(msg, getLocation());\n+        }\n+\n+        if (result.contains(\"Needs Merge\")) {\n+            String msg = \"Path: \" + getViewPath() + \" needs merge from \" +\ngetMergeSourceDescription();\n+            throw new BuildException(msg, getLocation());\n+        }\n+    }\n+\n+    private boolean isCleartoolErrorOutput(String output) {\n+        return output.contains(\"cleartool: Error:\");\n+    }\n+\n+    private String getMergeSourceDescription() {\n+        if (getViewtag() != null) {\n+            return \"view \" + getViewtag();\n+        } else if (getVersion() != null) {\n+            return \"version \" + getVersion();\n+        } else {\n+            return \"latest from branch\";\n+        }\n+    }\n+\n+    /**\n+     * Check the command line options.\n+     */\n+    private void checkOptions(Commandline cmd) {\n+        cmd.createArgument().setValue(getViewPath());\n+\n+        if (getViewtag() != null) {\n+            createArgumentWithValue(cmd, FLAG_VIEWTAG, getViewtag());\n+        } else if (getVersion() != null) {\n+            createArgumentWithValue(cmd, FLAG_VERSION, getVersion());\n+        } else if (getLatest()) {\n+            cmd.createArgument().setValue(FLAG_LATEST);\n+        }\n+\n+        if (getDepth()) {\n+            cmd.createArgument().setValue(FLAG_DEPTH);\n+        }\n+        if (getNrecurse()) {\n+            cmd.createArgument().setValue(FLAG_NRECURSE);\n+        }\n+        if (getDirectory()) {\n+            cmd.createArgument().setValue(FLAG_DIRECTORY);\n+        }\n+        if (getFollow()) {\n+            cmd.createArgument().setValue(FLAG_FOLLOW);\n+        }\n+        if (getVisible()) {\n+            cmd.createArgument().setValue(FLAG_VISIBLE);\n+        }\n+        if (getNzero()) {\n+            cmd.createArgument().setValue(FLAG_NZERO);\n+        }\n+        if (getNback()) {\n+            cmd.createArgument().setValue(FLAG_NBACK);\n+        }\n+        if (getWhynot()) {\n+            cmd.createArgument().setValue(FLAG_WHYNOT);\n+        }\n+\n+        if (getLog() != null) {\n+            createArgumentWithValue(cmd, FLAG_LOG, getLog());\n+        }\n+\n+        cmd.createArgument().setValue(FLAG_PRINT);\n+    }\n+\n+    private static void createArgumentWithValue(Commandline cmd, String\nargument, String value) {\n+        /*\n+         * Had to make two separate commands here because if a space is\ninserted between the flag and the value, it is\n+         * treated as a Windows filename with a space and it is enclosed in\ndouble quotes (\"). This breaks clearcase.\n+         */\n+        cmd.createArgument().setValue(argument);\n+        cmd.createArgument().setValue(value);\n+    }\n+}", "id": 103384, "attachment_id": null, "bug_id": 42462, "creation_time": "2007-05-20T08:02:59Z", "time": "2007-05-20T08:02:59Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 42462, "text": "Created attachment 20221\nsvn patch for org.apache.tools.ant.taskdefs.optional.clearcase.CCFindmerge", "id": 103385, "time": "2007-05-20T08:05:40Z", "creator": "fabio.gavilondo@gmail.com", "creation_time": "2007-05-20T08:05:40Z", "is_private": false, "attachment_id": 20221}]