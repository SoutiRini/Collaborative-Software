[{"count": 0, "tags": [], "text": "When evaluating a single rule defined over a series of disjoint cell ranges using a comparison to a relative cell reference, POI gets confused about what applies where and the reference shifting needed to evaluate the rule in the context of cells not in the top left of the range.", "is_private": false, "id": 202133, "creator": "gwoolsey@apache.org", "time": "2017-11-15T00:28:12Z", "bug_id": 61764, "creation_time": "2017-11-15T00:28:12Z", "attachment_id": null}, {"count": 1, "tags": [], "text": "It turns out Excel evaluates relative references in the conditional formula relative to the range the formula applies to by treating the top left cell of the applicable range as \"A1\".  POI code currently shifts those references by starting from the formula-referenced cell and adding the current range cell's offsets.  \n\nSo offsets need to change to be \n\nformula ref + range top-left + current cell range offset \n\nrather than the current\n\nformula ref + current cell range offset", "is_private": false, "id": 202134, "creator": "gwoolsey@apache.org", "time": "2017-11-15T02:24:50Z", "bug_id": 61764, "creation_time": "2017-11-15T02:24:50Z", "attachment_id": null}, {"count": 2, "tags": [], "bug_id": 61764, "text": "Turns out this logic doesn't work for the formulas generated internally by Excel for string comparison rules.  Different logic for adjusting the relative references in that case.  Fortunately HSSF doesn't implement these types of rules, and XSSF has a \"text\" attribute that is the text to key the condition by.  Using that also avoids some formula evaluation, which saves time.\n\nInteresting Excel conditional formatting twist: I tried a \"contains text\" rule on cells with numbers.\n\nWhen looking for values containing \"0\".  Regardless of display formatting, Excel matched cells with significant zeros only.  i.e. a cell with a value of 424 and a currency format that displays as \"$424.00\" does not match the rule, but a value of \"$424.01\" does.  \"$424.10\" also does not match.\n\nSimilarly looking for a period (\".\") matches cells with fractional values only.  This implies the matching is likely using the value stored in the OOXML which uses the canonical decimal separator.\n\nThe evaluation logic will need to support this via a double to String conversion that doesn't fall into scientific notation or include extraneous trailing zeros or periods.  This rules out:\n\n* direct Double.toString() (trailing \".0\" for integers)\n* BigDecimal.toPlainString() (converts the full floating point representation of double values, which doesn't match expected values)\n* String.format() (have to hard-code decimal precision)\n\nleaving us with:\n\nDecimalFormat df = new DecimalFormat(\"0\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\ndf.setMaximumFractionDigits(DecimalFormat.DOUBLE_FRACTION_DIGITS);\n\nsince POI rule objects are assumed not thread safe, an instance field scoped format instance in EvaluationConditionalFormatRule is a decent place to cache a DecimalFormat instance for balancing performance and memory.  Most workbooks won't have very many rule definitions, and this way it is kept close to it's callers.", "id": 202137, "time": "2017-11-15T07:39:23Z", "creator": "gwoolsey@apache.org", "creation_time": "2017-11-15T07:39:23Z", "is_private": false, "attachment_id": null}, {"count": 3, "attachment_id": null, "bug_id": 61764, "text": "Fixed in r1815298", "id": 202138, "time": "2017-11-15T08:40:53Z", "creator": "gwoolsey@apache.org", "creation_time": "2017-11-15T08:40:53Z", "tags": [], "is_private": false}]