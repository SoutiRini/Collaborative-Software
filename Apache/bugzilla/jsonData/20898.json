[{"count": 0, "attachment_id": null, "bug_id": 20898, "text": "Create a form with more than 4096 of data and POST it to a CGI on an https \nport.  The CGI hangs.  It appears to get the first 4096 bytes, then gets \nstuck.  The same POST works on a non-SSL port.\n\nNote: this may be related to a similar bug reported in the squid development \ngroup, where they report: \"The problem lies in squid's select() logic. SSL \nbuffers decrypted bytes, so SSL_pending() will show there are more bytes to \nread in the SSL stream, but select() on the filehandle will never return after \nthe client write the last (encrypted) byte.\"", "id": 39074, "time": "2003-06-19T03:00:44Z", "creator": "cjames53@yahoo.com", "creation_time": "2003-06-19T03:00:44Z", "tags": [], "is_private": false}, {"count": 1, "tags": [], "creator": "trawick@apache.org", "text": "what OS?\n\nare you sure that the CGI is stuck reading stdin?  if the CGI start writing\nstuff to stdout and stderr before reading all of stding, it can get stuck on output\n", "id": 39306, "time": "2003-06-23T23:08:39Z", "bug_id": 20898, "creation_time": "2003-06-23T23:08:39Z", "is_private": false, "attachment_id": null}, {"count": 2, "tags": [], "bug_id": 20898, "attachment_id": null, "text": "You're right, if I read everything from stdin to EOF *before* I start writing to\nstdout, it works.  So I guess the bug is that http and https protocols work\ndifferently.  I suppose if I dig into the CGI spec I'll find somewhere that this\nis a requirement (read first then write), but I've done a lot of work with\nApache and never seen this before.  Anyway, thanks for your help.", "id": 39390, "time": "2003-06-25T07:10:54Z", "creator": "cjames53@yahoo.com", "creation_time": "2003-06-25T07:10:54Z", "is_private": false}]