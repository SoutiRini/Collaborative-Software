[{"attachment_id": 21651, "tags": [], "creator": "Tom.Donovan@acm.org", "text": "Created attachment 21651\nhttpd trunk (r628393) patch - also applies to 2.2.8 cleanly\n\nIt is a frequent problem that mod_authn_dbd cannot be used with existing SQL databases because passwords are not stored in one of the Apache formats: {$apr1$}, {SHA}, crypt (Unix), or plaintext (Windows/Netware).\n\nThis proposal is for an optional 2nd 'VALIDATE' argument to the AuthDBDUserPWQuery directive which lets the database determine whether the password is valid without relying on the APR password hashing functions.\n\nThe VALIDATE argument indicates that the plaintext password is passed as the first query parameter and the username is passed as the second parameter.\n\nWhen the first column of the first returned row is a non-zero number or \"T\" or \"TRUE\" (case insensitive), the password is accepted - otherwise the password is rejected.\n\nNote that when no rows are returned, mod_authn_dbd already reports AUTH_USER_NOT_FOUND.\n\nA common example is when passwords are stored using the database provider's MD5 function which is incompatible with Apache encrypted password formats:\n\nMySQL or PostgreSQL:\n  AuthDBDUserPWQuery \\\n  \"SELECT (password = MD5(%s)) FROM users WHERE username = %s\"  \\\n  VALIDATE\n\nSQLServer:\n  AuthDBDUserPWQuery \\\n  \"SELECT CASE password WHEN HashBytes('MD5', %s) THEN 1 ELSE 0 END \\\n  FROM users WHERE username = %s\" \\\n  VALIDATE\n\nOracle 10g:\n  AuthDBDUserPWQuery \\\n  \"SELECT CASE WHEN DBMS_CRYPTO.HASH(RAWTOHEX(%s),2) = password THEN 1 ELSE 0 END \\\n  FROM users WHERE username = %s\"  \\\n  VALIDATE\n\nThe password is passed as the 1st parameter and the username as the 2nd parameter because this order makes constructing the SQL statement considerably easier, since the username is almost always used in a SQL predicate clause.\n\nAll SQL databases which support boolean values cast them to strings as \"0\" or \"1\"; \"t\" or \"f\"; or \"TRUE\" or \"FALSE\".\n\nThis option is not useful for digest authentication because Apache does not have the plaintext password when digest authentication is used.\n\nIt may be good to note in the documentation that the security of the database connection and database SQL logging should be considered when a plaintext password is passed to the database using the VALIDATE option.", "count": 0, "id": 114488, "time": "2008-03-11T08:13:55Z", "bug_id": 44578, "creation_time": "2008-03-11T08:13:55Z", "is_private": false}, {"count": 1, "tags": [], "creator": "Tom.Donovan@acm.org", "attachment_id": null, "is_private": false, "id": 114493, "time": "2008-03-11T09:23:31Z", "bug_id": 44578, "creation_time": "2008-03-11T09:23:31Z", "text": "Just noticed that it is redundant to check if the first character is \"T\", then check for the string \"TRUE\":\n\n>+        /* any non-zero number or \"T\" or \"TRUE\" (case-insensitive) for OK */\n>+        return (   *dbd_password == 't' || *dbd_password == 'T'\n>+                ||  atoi(dbd_password)\n>+                || !apr_strnatcasecmp(dbd_password, \"TRUE\") \n>+                ) ? AUTH_GRANTED : AUTH_DENIED;\n\nwould be better as:\n\n>+        /* any non-zero number or \"T\" or \"TRUE\" (case-insensitive) for OK */\n>+        return ( atoi(dbd_password)\n>+                 || !apr_strnatcasecmp(dbd_password, \"T\") \n>+                 || !apr_strnatcasecmp(dbd_password, \"TRUE\") \n>+                ) ? AUTH_GRANTED : AUTH_DENIED;\n"}, {"count": 2, "tags": [], "bug_id": 44578, "text": "this issue still persists with recent apache versions. I am not sure if this is a bug per se or a design flaw. either way a fix would be great as the current implementation requires users to maintain multiple password hashes in the database for different systems.", "id": 192025, "time": "2016-06-29T21:37:23Z", "creator": "christof.schulze@gmx.net", "creation_time": "2016-06-29T21:37:23Z", "is_private": false, "attachment_id": null}]