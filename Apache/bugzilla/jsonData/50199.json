[{"count": 0, "tags": [], "bug_id": 50199, "attachment_id": null, "id": 141339, "time": "2010-11-02T09:02:31Z", "creator": "nick@webthing.com", "creation_time": "2010-11-02T09:02:31Z", "is_private": false, "text": "Several coadvisor tests fail due to quoted strings being mis-parsed as cache-control directives in ap_cache_liststr.  These MUST be ignored (rfc2616#14.9.6).\n\nReplacing ap_cache_liststr with ap_find_list_item almost fixes it, but can't return a token's value as required by mod_cache.  Some rationalisation of this nearly-duplicated functionality would probably be a good idea.\n\nhttp://coad.measurement-factory.com/cgi-bin/coad/GraseInfoCgi?info_id=test_clause/rfc2616/ccExtension"}, {"count": 1, "tags": [], "text": "The following patch fixes this issue, however waiting to find out whether this functions belongs in mod_cache, or in APR.\n\nIndex: modules/cache/cache_util.c\n===================================================================\n--- modules/cache/cache_util.c\t(revision 1069969)\n+++ modules/cache/cache_util.c\t(working copy)\n@@ -27,6 +27,8 @@\n \n extern module AP_MODULE_DECLARE_DATA cache_module;\n \n+#define CACHE_SEPARATOR \",   \"\n+\n /* Determine if \"url\" matches the hostname, scheme and port and path\n  * in \"filter\". All but the path comparisons are case-insensitive.\n  */\n@@ -1022,6 +1024,74 @@\n }\n \n /**\n+ * String tokenizer that ignores separator characters within quoted strings\n+ * and escaped characters, as per RFC2616 section 2.2.\n+ */\n+static char *cache_strqtok(char *str, const char *sep, char **last)\n+{\n+    char *token;\n+    int quoted = 0;\n+\n+    if (!str) {         /* subsequent call */\n+        str = *last;    /* start where we left off */\n+    }\n+\n+    /* skip characters in sep (will terminate at '\\0') */\n+    while (*str && strchr(sep, *str)) {\n+        ++str;\n+    }\n+\n+    if (!*str) {        /* no more tokens */\n+        return NULL;\n+    }\n+\n+    token = str;\n+\n+    /* skip valid token characters to terminate token and\n+     * prepare for the next call (will terminate at '\\0)\n+     * on the way, ignore all quoted strings, and within\n+     * quoted strings, escaped characters.\n+     */\n+    *last = token + 1;\n+    while (**last) {\n+        if (!quoted) {\n+            if (**last == '\\\"') {\n+                quoted = 1;\n+                ++*last;\n+            }\n+            else if (!strchr(sep, **last)) {\n+                ++*last;\n+            }\n+            else {\n+                break;\n+            }\n+        }\n+        else {\n+            if (**last == '\\\"') {\n+                quoted = 0;\n+                ++*last;\n+            }\n+            else if (**last == '\\\\') {\n+                ++*last;\n+                if (**last) {\n+                    ++*last;\n+                }\n+            }\n+            else {\n+                ++*last;\n+            }\n+        }\n+    }\n+\n+    if (**last) {\n+        **last = '\\0';\n+        ++*last;\n+    }\n+\n+    return token;\n+}\n+\n+/**\n  * Parse the Cache-Control and Pragma headers in one go, marking\n  * which tokens appear within the header. Populate the structure\n  * passed in.\n@@ -1043,7 +1113,7 @@\n \n     if (pragma_header) {\n         char *header = apr_pstrdup(r->pool, pragma_header);\n-        const char *token = apr_strtok(header, \", \", &last);\n+        const char *token = cache_strqtok(header, CACHE_SEPARATOR, &last);\n         while (token) {\n             /* handle most common quickest case... */\n             if (!strcmp(token, \"no-cache\")) {\n@@ -1053,14 +1123,14 @@\n             else if (!strcasecmp(token, \"no-cache\")) {\n                 cc->no_cache = 1;\n             }\n-            token = apr_strtok(NULL, \", \", &last);\n+            token = cache_strqtok(NULL, CACHE_SEPARATOR, &last);\n         }\n         cc->pragma = 1;\n     }\n \n     if (cc_header) {\n         char *header = apr_pstrdup(r->pool, cc_header);\n-        const char *token = apr_strtok(header, \", \", &last);\n+        const char *token = cache_strqtok(header, CACHE_SEPARATOR, &last);\n         while (token) {\n             switch (token[0]) {\n             case 'n':\n@@ -1178,7 +1248,7 @@\n                 break;\n             }\n             }\n-            token = apr_strtok(NULL, \", \", &last);\n+            token = cache_strqtok(NULL, CACHE_SEPARATOR, &last);\n         }\n         cc->cache_control = 1;\n     }", "is_private": false, "id": 144210, "creator": "minfrin@sharp.fm", "time": "2011-02-11T18:00:56Z", "bug_id": 50199, "creation_time": "2011-02-11T18:00:56Z", "attachment_id": null}, {"count": 2, "tags": [], "creator": "minfrin@sharp.fm", "text": "Committing to httpd-trunk, we can worry about apr_strqtok at a future date as an optimisation.\n\nFixed in r1070075.", "id": 144217, "time": "2011-02-12T08:10:51Z", "bug_id": 50199, "creation_time": "2011-02-12T08:10:51Z", "is_private": false, "attachment_id": null}]