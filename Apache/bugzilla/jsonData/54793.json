[{"count": 0, "tags": [], "bug_id": 54793, "text": "When issuing a PUT request for a non-existent resource, the upload will eventually return \"201 - Created\". However, if this upload is paused, or the cable is \"cut\", the socket will remain open. \n\nNow, if another PUT request is then issued against the same resource, it can upload a new file, but will get a \"204 - No Content\" response. Issuing a PROPFIND will show the file, and issuing a GET will download the file. All good. \n\nBut when the original request times out, it will delete the file on the server!\n\nThis happens in production, because some German DSL subscribers have their lines reset at least every 24-hours. When this happens, every socket is immediately discovered as disconnected by the client, but the server only notices absence of data. When the client retries the upload, it can succeed (with a 204) and later disappear. If the file is large enough, the timeout occurs during the second upload and the server responds \"500 - Internal Error\" (not as bad, as the client knows it failed).\n\nThere may be similar side-effects with existing files.\n\nThe only issue I have found that appear somewhat related is #39815.", "id": 166347, "time": "2013-04-03T06:30:50Z", "creator": "kenneth@hexad.dk", "creation_time": "2013-04-03T06:30:50Z", "is_private": false, "attachment_id": null}, {"count": 1, "attachment_id": null, "creator": "sensille@gmx.net", "is_private": false, "id": 166995, "time": "2013-05-02T07:41:41Z", "bug_id": 54793, "creation_time": "2013-05-02T07:41:41Z", "tags": [], "text": "This is by design, see dav_fs_close_stream in modules/dav/fs/repos.c. In case of error, the commit parameter is 0, leading to a call to apr_file_remove.\nWhat do you propose should happen in case of error instead?"}, {"count": 2, "attachment_id": null, "creator": "kenneth@hexad.dk", "text": "I expect commands to be atomic.\n\nThat is, until the file is uploaded successfully, it does not exist.\nThus a failed upload does not require a delete of the target file (but maybe a temp file).\n\nIf two connections are uploading the same file, the current approach would mess things up too?\n\nIf you upload the file to a temporary location, and move into the right spot on completion, you would never have this problem. Two simultaneous uploads would also work with \"last to finish completely replaces original\".\n\nAnother approach, which is simpler to implement, is to lock the file while uploading, so you cannot have competing uploads. In this case, the client would at least get an error message while the other upload is \"in progress\".", "id": 166997, "time": "2013-05-02T09:41:09Z", "bug_id": 54793, "creation_time": "2013-05-02T09:41:09Z", "tags": [], "is_private": false}]