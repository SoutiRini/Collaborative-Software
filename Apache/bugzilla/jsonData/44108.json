[{"count": 0, "tags": [], "creator": "daniel.armbrust.list@gmail.com", "attachment_id": null, "id": 111926, "time": "2007-12-19T14:13:31Z", "bug_id": 44108, "creation_time": "2007-12-19T14:13:31Z", "is_private": false, "text": "Using the newest 1.2 log4j, the TelnetAppender has an implementation mis-design\nwhich causes it to not write messages to telnet sessions to random telnet\nsessions after another telnet session has disconnected.\n\nHere is the offending code:\n\n    /** sends a message to each of the clients in telnet-friendly output. */\n    public void send(String message) {\n      Enumeration ce = connections.elements();\n      for(Enumeration e = writers.elements();e.hasMoreElements();) {\n        Socket sock = (Socket)ce.nextElement();\n        PrintWriter writer = (PrintWriter)e.nextElement();\n        writer.print(message);\n        if(writer.checkError()) {\n          // The client has closed the connection, remove it from our list:\n          connections.remove(sock);\n          writers.remove(writer);\n        }\n      }\n    }\n\nIt is not safe to do a remove from a vector while you have an enumeration open\non it!  It results in the enumeration missing a valid element for each time you\ncall remove on the vector.\n\nFor example:\n\npublic static void main(String[] args) throws SocketException,\nInterruptedException, URISyntaxException\n{\n        Vector temp = new Vector();\n        temp.add(\"1\");\n\ttemp.add(\"2\");\n\ttemp.add(\"3\");\n\ttemp.add(\"4\");\n\tEnumeration e = temp.elements();\n\tSystem.out.println(e.nextElement());\n\tObject o = e.nextElement();\n\tSystem.out.println(o);\n\ttemp.remove(o);\n\tSystem.out.println(e.nextElement());\n\tSystem.out.println(e.nextElement());\n}\n\nThe TelnetAppender code makes the assumption that this would print 1, 2, 3, and\n4 to the console.  In fact, it prints 1, 2, 4 (and then takes and out of bounds\nexception)"}, {"count": 1, "tags": [], "bug_id": 44108, "attachment_id": null, "text": "Here is a refactored and bug fixed version of the 2nd half of this class - the\nSocketHandler part.\n\nThis corrects the bug that causes it to miss messages, cleans up some areas of\nthe code where the print writers were not closed properly, and makes the code\nsafe for multi-threaded operation - the previous code was not safe, because it\nwas using two vectors that were assumed to be the same size - but in reality,\nthey could be different sizes depending on how the threads stop and start.\n\nYou may need to remove the generics, if you still need to support 1.4.\n\n\n\n// ---------------------------------------------------------- SocketHandler:\n\n\t/**\n\t * The SocketHandler class is used to accept connections from clients. It is\n\t * threaded so that clients can connect/disconnect asynchronously.\n\t */\n\tprotected class SocketHandler extends Thread\n\t{\n\t\tprivate Vector<TelnetClient> connections = new Vector<TelnetClient>();\n\t\tprivate ServerSocket serverSocket;\n\t\tprivate int MAX_CONNECTIONS = 20;\n\n\t\tpublic void finalize()\n\t\t{\n\t\t\tclose();\n\t\t}\n\n\t\t/**\n\t\t * make sure we close all network connections when this handler is\n\t\t * destroyed.\n\t\t * \n\t\t * @since 1.2.15\n\t\t */\n\t\tpublic void close()\n\t\t{\n\t\t\tfor (Enumeration<TelnetClient> e = connections.elements(); e.hasMoreElements();)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\te.nextElement().close();\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tserverSocket.close();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t}\n\t\t}\n\n\t\t/** sends a message to each of the clients in telnet-friendly output. */\n\t\tpublic void send(String message)\n\t\t{\n\t\t\tVector<TelnetClient> lostClients = new Vector<TelnetClient>();\n\t\t\tfor (Enumeration<TelnetClient> e = connections.elements(); e.hasMoreElements();)\n\t\t\t{\n\t\t\t\tTelnetClient tc = e.nextElement();\n\t\t\t\ttc.writer.print(message);\n\t\t\t\tif (tc.writer.checkError())\n\t\t\t\t{\n\t\t\t\t\t// The client has closed the connection, remove it from our list:\n\t\t\t\t\tlostClients.add(tc);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (Enumeration<TelnetClient> e = lostClients.elements(); e.hasMoreElements();)\n\t\t\t{\n\t\t\t\tTelnetClient tc = e.nextElement();\n\t\t\t\ttc.close();\n\t\t\t\tconnections.remove(tc);\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\t/**\n\t\t * Continually accepts client connections. Client connections are\n\t\t * refused when MAX_CONNECTIONS is reached.\n\t\t */\n\t\tpublic void run()\n\t\t{\n\t\t\twhile (!serverSocket.isClosed())\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tSocket newClient = serverSocket.accept();\n\t\t\t\t\tTelnetClient tc = new TelnetClient(newClient);\n\t\t\t\t\tif (connections.size() < MAX_CONNECTIONS)\n\t\t\t\t\t{\n\t\t\t\t\t\tconnections.addElement(tc);\n\t\t\t\t\t\ttc.writer.println(\"TelnetAppender v1.0 (\" + connections.size() + \" active\nconnections)\");\n\t\t\t\t\t\ttc.writer.println();\n\t\t\t\t\t\ttc.writer.flush();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttc.writer.println(\"Too many connections.\");\n\t\t\t\t\t\ttc.writer.flush();\n\t\t\t\t\t\ttc.close();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{\n\t\t\t\t\tif (!serverSocket.isClosed())\n\t\t\t\t\t{\n\t\t\t\t\t\tLogLog.error(\"Encountered error while in SocketHandler loop.\", e);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tserverSocket.close();\n\t\t\t}\n\t\t\tcatch (IOException ex)\n\t\t\t{\n\t\t\t}\n\t\t}\n\n\t\tpublic SocketHandler(int port) throws IOException\n\t\t{\n\t\t\tserverSocket = new ServerSocket(port);\n\t\t\tsetName(\"TelnetAppender-\" + getName() + \"-\" + port);\n\t\t}\n\n\t}\n\n\tprotected class TelnetClient\n\t{\n\t\tprivate PrintWriter writer;\n\t\tprivate Socket connection;\n\n\t\tprotected TelnetClient(Socket socket) throws IOException\n\t\t{\n\t\t\tconnection = socket;\n\t\t\twriter = new PrintWriter(connection.getOutputStream());\n\t\t}\n\n\t\tprotected void close()\n\t\t{\n\t\t\tif (writer != null)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\twriter.flush();\n\t\t\t\t\twriter.close();\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{\n\t\t\t\t\t// noop\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (connection != null)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tconnection.close();\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{\n\t\t\t\t\t// noop\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "id": 111929, "time": "2007-12-19T15:33:44Z", "creator": "daniel.armbrust.list@gmail.com", "creation_time": "2007-12-19T15:33:44Z", "is_private": false}, {"count": 2, "tags": [], "creator": "daniel.armbrust.list@gmail.com", "text": "1 more issue regarding line feeds - one in my new code, one in the other\nexisting code.\n\nMy code posted above needs this replacement (I was using system line feeds, and\nnot the line feeds called out in the telnet RFC):\n\nif (connections.size() < MAX_CONNECTIONS)\n\t\t\t\t\t{\n\t\t\t\t\t\tconnections.addElement(tc);\n\t\t\t\t\t\ttc.writer.print(\"TelnetAppender v1.0 (\" + connections.size() + \" active\nconnections)\\r\\n\\r\\n\");\n\t\t\t\t\t\ttc.writer.flush();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttc.writer.print(\"Too many connections.\\r\\n\");\n\t\t\t\t\t\ttc.writer.flush();\n\t\t\t\t\t\ttc.close();\n\t\t\t\t\t}\n\n\n\nFinally, the append method should have this in it:\n\nfor (int i = 0; i < len; i++)\n{\n\tsh.send(s[i] + \"\\r\\n\");\n}\n\nThe existing code uses the system line feed character instead of the correct\ntelnet line feed.", "id": 111930, "time": "2007-12-19T15:56:16Z", "bug_id": 44108, "creation_time": "2007-12-19T15:56:16Z", "is_private": false, "attachment_id": null}, {"count": 3, "tags": [], "text": "Thanks for the bug report and patches.  log4j 1.2.x targets JDK 1.2 and later, so can't use generics in its \ncode.  Will likely not get attention until after Christmas, sorry.", "attachment_id": null, "bug_id": 44108, "id": 111931, "time": "2007-12-19T17:12:56Z", "creator": "carnold@apache.org", "creation_time": "2007-12-19T17:12:56Z", "is_private": false}, {"count": 4, "tags": [], "creator": "carnold@apache.org", "text": "Committed a change in rev 612959 that should address the same issues with less code changes.\n\n JDK 1.2 added Iterator as a replacement for Enumerator and Iterator.remove() can safely remove an \nelement while iterating.  So SocketHandler.send was rewritten using Iterator. \n\nThe occasions that writers and connections could get out of sync would be when a connection is being \naccepted while a message is being sent.  I've added sync blocks so that any access to connections or \nwriters must have a lock of SocketHandler.  You could rewrite everything so that you could safely \naccept a connection while messages were being sent, but that seems to be overkill.\n\nThe Telnet RFC does require CRLF's.  The main message requires that you specify the layout including \nthe line feed, so you should not use %n in a layout with TelnetAppender.  It would be possible to fix \nthis after the fact, but I haven't attempted that.  I did change the EOL's used in the exception messages.", "id": 112970, "time": "2008-01-17T12:27:32Z", "bug_id": 44108, "creation_time": "2008-01-17T12:27:32Z", "is_private": false, "attachment_id": null}, {"attachment_id": null, "tags": [], "bug_id": 44108, "text": "Changes look good to me.", "count": 5, "id": 112988, "time": "2008-01-18T07:17:33Z", "creator": "daniel.armbrust.list@gmail.com", "creation_time": "2008-01-18T07:17:33Z", "is_private": false}]