[{"count": 0, "attachment_id": null, "bug_id": 45395, "is_private": false, "id": 118663, "time": "2008-07-14T17:00:52Z", "creator": "sparr@lotame.com", "creation_time": "2008-07-14T17:00:52Z", "tags": [], "text": "In org.apache.jk.common.MsgAjp, the dump method is a debug utility to provide debug output of the buffer contents when errors occur.  It uses the \"len\" variable to control this output.  This probably works fine in the case of a packet read.  But in the case of a packet write, the \"len\" variable is not set until then \"end\" method is called once the packet is complete.  In the case of an error during the generation of the packet to be written (such as a buffer overflow in our case), the code such as cpBytes calls \"dump\" to display the contents of the buffer.  Since \"end\" has not been called, \"len\" still equals 4 and so only the first 8 bytes of the buffer are dumped followed by blank hex lines for the rest of the buffer up to the pos/max limit.  Obviously, this would be more useful if the \"len\" was ignored and \"pos\" was used instead.  Or \"cpBytes\" could call the \"end\" method before calling \"dump\" to set the \"len\" value.  I'm sure there are a couple of ways to fix this and I am not familiar enough with the code to pick the best fix."}, {"count": 1, "attachment_id": null, "bug_id": 45395, "text": "I don't understand your explanation.\n\nThe output would contain the bigger of len+4 and pos limited to 1000 bytes. So if pos were bigger than 8, you would see more characters. It is more likely, that cpBytes() had the problem, that the packet was empty, but more data than would fit into it were supposed to be copied in (something like that).\n\nFeel free to reopen, if you can provide additional evidence what to improve here.\n\nRegards,\n\nRainer", "id": 150911, "time": "2011-10-25T18:48:04Z", "creator": "rainer.jung@kippdata.de", "creation_time": "2011-10-25T18:48:04Z", "tags": [], "is_private": false}]