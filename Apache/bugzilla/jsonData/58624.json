[{"count": 0, "tags": [], "bug_id": 58624, "text": "- Tomcat 8.0.24\n- APR connector disabled, using the NIO connector\n- SSL is on\n- Encoder is of type Encoder.Text<Object>\n\nWe found this during load tests, it only happened to one message out of millions but there is nothing special about that message.\n\nWe have a class that wraps javax.websocket.RemoteEndpoint.Basic to ensure that it's thread-safe - so messages are never sent from multiple threads on one socket.\n\nThe FutureToSendHandler gets stuck waiting for the call to onResult. Looking at the code, logically sendStringByCompletion(msg, completion) (WsRemoteEndpoint.java:573) must not call the onResult for some code path. I am trying to figure out where but no luck so far.\n\nThis is the first time we have seen this problem over many load tests so unfortunately we can't try to replicate on the latest at the moment.\n\n\"defaultEventExecutorGroup-3-18\" - Thread t@61\n   java.lang.Thread.State: WAITING\n\tat sun.misc.Unsafe.park(Native Method)\n\t- parking to wait for <2fcb7fa> (a java.util.concurrent.CountDownLatch$Sync)\n\tat java.util.concurrent.locks.LockSupport.park(Unknown Source)\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(Unknown Source)\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(Unknown Source)\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(Unknown Source)\n\tat java.util.concurrent.CountDownLatch.await(Unknown Source)\n\tat org.apache.tomcat.websocket.FutureToSendHandler.get(FutureToSendHandler.java:76)\n\tat org.apache.tomcat.websocket.FutureToSendHandler.get(FutureToSendHandler.java:31)\n\tat org.apache.tomcat.websocket.WsRemoteEndpointImplBase.sendObject(WsRemoteEndpointImplBase.java:521)\n\tat org.apache.tomcat.websocket.WsRemoteEndpointBasic.sendObject(WsRemoteEndpointBasic.java:74)\n        ...", "id": 186430, "time": "2015-11-18T12:16:29Z", "creator": "b.coughlan2@gmail.com", "creation_time": "2015-11-18T12:16:29Z", "is_private": false, "attachment_id": null}, {"count": 1, "tags": [], "text": "I mistakenly thought that packets sent with getBasicRemote() were sent on the same thread.\n\nTo add, all of the threads for sending messages are in the state of waiting for tasks - none of them are blocked:\n\n\"WebSocketServer-localhost-/MyApp-1453\" - Thread t@13892\n   java.lang.Thread.State: TIMED_WAITING\n\tat sun.misc.Unsafe.park(Native Method)\n\t- parking to wait for <785b947d> (a java.util.concurrent.SynchronousQueue$TransferStack)\n\tat java.util.concurrent.locks.LockSupport.parkNanos(Unknown Source)\n\tat java.util.concurrent.SynchronousQueue$TransferStack.awaitFulfill(Unknown Source)\n\tat java.util.concurrent.SynchronousQueue$TransferStack.transfer(Unknown Source)\n\tat java.util.concurrent.SynchronousQueue.poll(Unknown Source)\n\tat java.util.concurrent.ThreadPoolExecutor.getTask(Unknown Source)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)\n\tat java.lang.Thread.run(Unknown Source)\n\n   Locked ownable synchronizers:\n\t- None\n\nSome other things that might be relevant from looking at the code:\n- We don't call the sendPing() or sendText() methods, only sendObject().\n- We don't use partial message decoding/encoding.\n- Batching is not enabled.\n- Looking at a heap dump, the only reference to the FutureSendHandler from the stuck thread is in the ConcurrentHashMap in org.apache.tomcat.websocket.WsSession.futures", "attachment_id": null, "bug_id": 58624, "id": 186435, "time": "2015-11-18T15:41:37Z", "creator": "b.coughlan2@gmail.com", "creation_time": "2015-11-18T15:41:37Z", "is_private": false}, {"count": 2, "tags": [], "creator": "b.coughlan2@gmail.com", "text": "Sorry for all the noise.\n\nIf I understand correctly, the flow of sending messages goes like this:\n\nWsRemoteEndpointImplBase.startMessage -> messaged dispatched to WsServerContainer.executor -> calls WsRemoteEndpointImplBase.endMessage on completion (via EndMessageHandler).\n\nI'm wondering if there could be an exception in the executor callback. For example, there are some exceptions thrown in writeMessagePart (called by endMessage). If an exception was thrown there it would be thrown all the way up to the executor and not logged. Am I correct in saying that exceptions in executor tasks would not produce exceptions in the Tomcat logs? ThreadPoolExecutor doesn't log them to the console by (http://stackoverflow.com/q/2248131/281469)\n\n\nMy current working theory for what's happening is as follows: \n- Server starts sending a message\n- The client closes the connection before the executor finishes the message, which causes WsRemoteEndpointImplBase.closed to be set to true.\n- Server finishes sending the message, calls endMessage, which calls writeMessagePart which throws an IllegalStateException because closed=true.\n- Because of the exception the future never completes and the exception doesn't get logged.\n\nAt first I thought the synchronized (messagePartLock) block would protect against this. However it can still occur:\n- The executor task finishes and endMessage() reaches the end of the synchronized block (but before calling writeMessagePart).\n- The client close enters and exits the synchronized block in startMessage(). Calls writeMessagePart(), sets closed=true.\n- The executor task calls writeMessagePart().\n\nIf this is a race condition it is a very rare one - it occurred once in sending ~5 million messages during a soak test.", "id": 186436, "time": "2015-11-18T18:12:27Z", "bug_id": 58624, "creation_time": "2015-11-18T18:12:27Z", "is_private": false, "attachment_id": null}, {"count": 3, "tags": [], "creator": "chris@christopherschultz.net", "is_private": false, "text": "(In reply to Barry Coughlan from comment #2)\n> My current working theory for what's happening is as follows: \n> - Server starts sending a message\n> - The client closes the connection before the executor finishes the message,\n> which causes WsRemoteEndpointImplBase.closed to be set to true.\n> - Server finishes sending the message, calls endMessage, which calls\n> writeMessagePart which throws an IllegalStateException because closed=true.\n> - Because of the exception the future never completes and the exception\n> doesn't get logged.\n\nI'm no expert, but what about this:\n\nThe Future won't complete, but it should probably throw ExecutionException if you call one of the \"get\" methods. You can unwrap that and see the exception that caused the operation to fail.", "id": 186439, "time": "2015-11-18T20:34:47Z", "bug_id": 58624, "creation_time": "2015-11-18T20:34:47Z", "attachment_id": null}, {"count": 4, "tags": [], "bug_id": 58624, "attachment_id": null, "id": 186440, "time": "2015-11-19T00:25:49Z", "creator": "b.coughlan2@gmail.com", "creation_time": "2015-11-19T00:25:49Z", "is_private": false, "text": "(In reply to Christopher Schultz from comment #3)\n> (In reply to Barry Coughlan from comment #2)\n> > My current working theory for what's happening is as follows: \n> > - Server starts sending a message\n> > - The client closes the connection before the executor finishes the message,\n> > which causes WsRemoteEndpointImplBase.closed to be set to true.\n> > - Server finishes sending the message, calls endMessage, which calls\n> > writeMessagePart which throws an IllegalStateException because closed=true.\n> > - Because of the exception the future never completes and the exception\n> > doesn't get logged.\n> \n> I'm no expert, but what about this:\n> \n> The Future won't complete, but it should probably throw ExecutionException\n> if you call one of the \"get\" methods. You can unwrap that and see the\n> exception that caused the operation to fail.\n\nThe getBasicRemote().sendObject() calls the Future.get() on our behalf (see the stack trace in the first post). The .get() never returns because the onResult of the FutureToSendHandler never gets called."}, {"count": 5, "tags": [], "bug_id": 58624, "attachment_id": null, "text": "The race condition I was talking about was incorrect, as the if (!close) in endMessage() takes care of it. Also the exceptions are logged because the executor is called with execute() instead of submit().\n\nSo I'm back to square one :)", "id": 186443, "time": "2015-11-19T10:47:56Z", "creator": "b.coughlan2@gmail.com", "creation_time": "2015-11-19T10:47:56Z", "is_private": false}, {"count": 6, "tags": [], "text": "Thanks for all the work on this.\n\nIt is worth updating to the latest 8.0.x in case one of the I/O or concurrency updates has improved this.\n\nI'm switching this to NEEDINFO. Ideally we need a test case but that is not essential. If you believe you have found a code path that could trigger this let us know and we'll take a look. As long as we can confirm the code path is theoretically possible, we'll be happy to fix it.", "is_private": false, "bug_id": 58624, "id": 186445, "time": "2015-11-19T14:52:56Z", "creator": "markt@apache.org", "creation_time": "2015-11-19T14:52:56Z", "attachment_id": null}, {"count": 7, "tags": [], "text": "(In reply to Mark Thomas from comment #6)\n> Thanks for all the work on this.\n> \n> It is worth updating to the latest 8.0.x in case one of the I/O or\n> concurrency updates has improved this.\n> \n> I'm switching this to NEEDINFO. Ideally we need a test case but that is not\n> essential. If you believe you have found a code path that could trigger this\n> let us know and we'll take a look. As long as we can confirm the code path\n> is theoretically possible, we'll be happy to fix it.\n\nHi Mark,\n\nI managed to replicate this on 8.0.24 and 8.0.28. I don't think I could automate a test to replicate this, but it can be shown with a simple example by setting breakpoints.\n\n============================================================\n\nSample server endpoint:\n\n------------------------\n\npackage tomcatbug58624;\n\nimport javax.websocket.EncodeException;\nimport javax.websocket.Encoder;\nimport javax.websocket.EndpointConfig;\n\npublic class WsEncoder implements Encoder.Text<Object> {\n\n    @Override\n    public void destroy() {\n    }\n\n    @Override\n    public void init(EndpointConfig endpointConfig) {\n    }\n\n    @Override\n    public String encode(Object object) throws EncodeException {\n        return (String) object;\n    }\n\n}\n\n------------------------\n\npackage tomcatbug58624;\n\nimport java.io.IOException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\nimport javax.websocket.CloseReason;\nimport javax.websocket.EncodeException;\nimport javax.websocket.OnClose;\nimport javax.websocket.OnError;\nimport javax.websocket.OnMessage;\nimport javax.websocket.OnOpen;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\n\n@ServerEndpoint(value = \"/bug58624\", encoders = WsEncoder.class)\npublic class WsEndpoint {\n\n    public static class SendWsMessage implements Runnable {\n        private Session session;\n\n        public SendWsMessage(Session session) {\n            this.session = session;\n        }\n\n        @Override\n        public void run() {\n            try {\n                session.getBasicRemote().sendObject(\"test\");\n            } catch (IOException | EncodeException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n    private static final ExecutorService ex = Executors.newFixedThreadPool(1);\n\n    @OnOpen\n    public void onOpen(Session session) throws IOException {\n        ex.submit(new SendWsMessage(session));\n    }\n\n    @OnMessage\n    public void onMessage(String message) {\n        System.out.println(\"OnMessage: \" + message);\n    }\n\n    @OnError\n    public void onError(Throwable t) {\n        System.err.println(\"OnError:\");\n        t.printStackTrace();\n    }\n\n    @OnClose\n    public void onClose(Session session, CloseReason cr) {\n        System.out.println(\"Closed \" + cr);\n    }\n}\n\n-----------------------------\n\nSet breakpoint on WsEndpoint$SendWsMessage:29 (The .sendObject() line)\nSet breakpoint on WsRemoteEndpointImplServer:76 (start of doWrite())\n\n- Open websocket\n  - Thread 1 breaks on sendObject()\n- Close websocket from client side (I just did Ctrl+C with Tyrus CLI)\n   - Thread 2 breaks on doWrite()\n- Continue Thread 1 so that the message gets queued to send\n- Continue Thread 2\n\nsendObject() waits indefinitely for Future.get(). The reason is that doWrite is not set to true in endMessage() because closed = true.\n\nThis would happen any time a message is queued to be sent while a close is in progress.\n\nI\u2019m not familiar enough with the codebase to submit a patch, but it looks to me like if closed==true in endMessage(), it should call sendResult with an exception for any messages still in the queue.", "is_private": false, "id": 186477, "creator": "b.coughlan2@gmail.com", "time": "2015-11-22T04:12:19Z", "bug_id": 58624, "creation_time": "2015-11-22T04:12:19Z", "attachment_id": null}, {"count": 8, "tags": [], "creator": "markt@apache.org", "attachment_id": null, "text": "Thanks for the analysis. I'll take a look.", "id": 186521, "time": "2015-11-24T11:19:39Z", "bug_id": 58624, "creation_time": "2015-11-24T11:19:39Z", "is_private": false}, {"count": 9, "tags": [], "creator": "markt@apache.org", "text": "Thanks for the great analysis and test case. I've fixed this in 9.0.x for 9.0.0.M2. There has been some refactoring of the relevant code so a back-port may take a little longer than usual.", "id": 186527, "time": "2015-11-24T22:20:31Z", "bug_id": 58624, "creation_time": "2015-11-24T22:20:31Z", "is_private": false, "attachment_id": null}, {"count": 10, "tags": [], "text": "(In reply to Mark Thomas from comment #9)\n> Thanks for the great analysis and test case. I've fixed this in 9.0.x for\n> 9.0.0.M2. There has been some refactoring of the relevant code so a\n> back-port may take a little longer than usual.\n\nThanks a lot for the speedy fix Mark.\n\nFor future readers, we currently work around this in Tomcat 8 by replicating the behaviour of getBasicRemote().sendObject() but with a timeout on the future, so that at least our application can recover: \n\nFuture<Void> f = session.getAsyncRemote().sendObject(...)        \ntry {\n    f.get(10, TimeUnit.SECONDS);\n} catch (InterruptedException e) {\n    throw new IOException(e);\n} catch (ExecutionException e) {\n    Throwable cause = e.getCause();\n    if (cause instanceof IOException) {\n        throw (IOException) cause;\n    } else if (cause instanceof EncodeException) {\n        throw (EncodeException) cause;\n    } else {\n        throw new IOException(e);\n    }\n} catch (TimeoutException e) {\n    throw new IOException(e);\n}", "is_private": false, "bug_id": 58624, "id": 186533, "time": "2015-11-25T00:00:51Z", "creator": "b.coughlan2@gmail.com", "creation_time": "2015-11-25T00:00:51Z", "attachment_id": null}, {"count": 11, "tags": [], "creator": "markt@apache.org", "text": "I've back-ported the fix to 8.0.x for 8.0.30 onwards and to 7.0.x for 7.0.66 onwards.", "id": 186544, "time": "2015-11-25T11:45:30Z", "bug_id": 58624, "creation_time": "2015-11-25T11:45:30Z", "is_private": false, "attachment_id": null}, {"attachment_id": 33320, "tags": [], "bug_id": 58624, "is_private": false, "count": 12, "id": 186748, "time": "2015-12-02T16:50:59Z", "creator": "b.coughlan2@gmail.com", "creation_time": "2015-12-02T16:50:59Z", "text": "Created attachment 33320\nTest to check that session.close() does not call OnError"}, {"attachment_id": null, "tags": [], "bug_id": 58624, "text": "Hi Mark,\n\nI was writing a test case for bug57489 and came across a problem with session.close() that I think is related to this fix. Since session.close() sets state = State.CLOSING the block in registerFuture() fails. See test case attached.\n\n\n\n02-Dec-2015 16:49:33.351 FINE [main] org.apache.tomcat.websocket.WsSession.sendCloseMessage Failed to send close message for session [0] to remote endpoint\n java.io.IOException: java.util.concurrent.ExecutionException: java.io.IOException: Unable to write the complete message as the WebSocket connection has been closed\n\tat org.apache.tomcat.websocket.WsRemoteEndpointImplBase.startMessageBlock(WsRemoteEndpointImplBase.java:282)\n\tat org.apache.tomcat.websocket.WsSession.sendCloseMessage(WsSession.java:584)\n\tat org.apache.tomcat.websocket.WsSession.doClose(WsSession.java:488)\n\tat org.apache.tomcat.websocket.WsSession.close(WsSession.java:455)\n\tat org.apache.tomcat.websocket.WsSession.close(WsSession.java:449)\n\tat org.apache.tomcat.websocket.server.TestCleanClose.testOnErrorNotCalledWhenClosingConnection(TestCleanClose.java:46)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:483)\n\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)\n\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)\n\tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n\tat org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.rules.TestWatcher$1.evaluate(TestWatcher.java:55)\n\tat org.junit.rules.RunRules.evaluate(RunRules.java:20)\n\tat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:675)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\nCaused by: java.util.concurrent.ExecutionException: java.io.IOException: Unable to write the complete message as the WebSocket connection has been closed\n\tat org.apache.tomcat.websocket.FutureToSendHandler.get(FutureToSendHandler.java:102)\n\tat org.apache.tomcat.websocket.WsRemoteEndpointImplBase.startMessageBlock(WsRemoteEndpointImplBase.java:275)\n\t... 34 more\nCaused by: java.io.IOException: Unable to write the complete message as the WebSocket connection has been closed\n\tat org.apache.tomcat.websocket.WsSession.registerFuture(WsSession.java:658)\n\tat org.apache.tomcat.websocket.FutureToSendHandler.get(FutureToSendHandler.java:92)\n\t... 35 more", "count": 13, "id": 186749, "time": "2015-12-02T16:53:17Z", "creator": "b.coughlan2@gmail.com", "creation_time": "2015-12-02T16:53:17Z", "is_private": false}, {"count": 14, "tags": [], "text": "Should I change this to reopened just so this isn't forgotten about?", "attachment_id": null, "bug_id": 58624, "id": 186853, "time": "2015-12-09T09:53:18Z", "creator": "b.coughlan2@gmail.com", "creation_time": "2015-12-09T09:53:18Z", "is_private": false}, {"count": 15, "tags": [], "creator": "sebastian.herold@immobilienscout24.de", "is_private": false, "text": "+1 for reopening the case or creating a new bug, if this (java.io.IOException: Unable to write the complete message as the WebSocket connection has been closed) is not related to the existing bug.\n\nSpring also recreated the error in one of their tests and had to ignore it until Tomcat is fixed: https://jira.spring.io/browse/INT-3909", "id": 187401, "time": "2016-01-05T21:17:32Z", "bug_id": 58624, "creation_time": "2016-01-05T21:17:32Z", "attachment_id": null}, {"count": 16, "tags": [], "creator": "markt@apache.org", "text": "This new issue is being tracked under bug 59014", "id": 188712, "time": "2016-02-23T13:44:53Z", "bug_id": 58624, "creation_time": "2016-02-23T13:44:53Z", "is_private": false, "attachment_id": null}]