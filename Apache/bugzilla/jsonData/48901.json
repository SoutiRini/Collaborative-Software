[{"count": 0, "tags": [], "creator": "joychester@gmail.com", "attachment_id": null, "text": "All the threads will perform endless wait by adding Synchronizing Timer.\n\nThis issue is much easier reproduced under a heavy load. I was using 100 threads to a simple HTTP request sampler with adding a Synchronizing Timer, Groupsize set to 100 as well.\n\nplease see the attachment which is the stack trace of 100 threads doing a endless wait.\n\nSome initial invstigation for this issue:\n\nHere is the current source code:\n\npublic long delay() {\n        synchronized (sync) {\n            timerCounter[0]++;\n            final int groupSz = getGroupSize();\n            final int count = timerCounter[0];\n            if (\n                (groupSz == 0 && count >= JMeterContextService.getNumberOfThreads())\n                ||\n                (groupSz > 0 && count >= groupSz)\n                ) {\n                sync.notifyAll();\n            } else {\n                try {\n                    sync.wait();\n                } catch (InterruptedException e) {\n                    log.warn(e.getLocalizedMessage());\n                }\n            }\n            timerCounter[0]=0; // Reset for next time\n        }\n        return 0;\n    }\n\nThe main problem from my perspective is after one thread call sync.notifyAll(); ,which means after the lock has been released,it will execute timerCounter[0]=0;(correct me if i am wrong)\n\nAfter chaning the code as following(move \"timerCounter[0]=0;\" in front of \"sync.notifyAll();\", it does not impact any business impact, but make more sense to me), and the issue disappear:\npublic long delay() {\n        synchronized (sync) {\n            timerCounter[0]++;\n            final int groupSz = getGroupSize();\n            final int count = timerCounter[0];\n            if (\n                (groupSz == 0 && count >= JMeterContextService.getNumberOfThreads())\n                ||\n                (groupSz > 0 && count >= groupSz)\n                ) {\n                timerCounter[0]=0; // Reset for next time\n                sync.notifyAll();\n            } else {\n                try {\n                    sync.wait();\n                } catch (InterruptedException e) {\n                    log.warn(e.getLocalizedMessage());\n                }\n            }\n        }\n        return 0;\n    }\n\nPlease review the code and make according changes with this issue. BTW,It can be reproduced on 2.3.4 release as well.\nHope this helps!", "id": 135306, "time": "2010-03-12T17:34:59Z", "bug_id": 48901, "creation_time": "2010-03-12T17:34:59Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 48901, "attachment_id": 25120, "id": 135307, "time": "2010-03-12T17:36:44Z", "creator": "joychester@gmail.com", "creation_time": "2010-03-12T17:36:44Z", "is_private": false, "text": "Created attachment 25120\nStack trace of 100 threads which is performing endless wait"}, {"count": 2, "tags": [], "bug_id": 48901, "attachment_id": null, "is_private": false, "id": 135363, "time": "2010-03-15T18:23:24Z", "creator": "sebb@apache.org", "creation_time": "2010-03-15T18:23:24Z", "text": "Thanks for the report and suggested fix.\n\nApplied in SVN:\n\nURL: http://svn.apache.org/viewvc?rev=923374&view=rev\nLog:\nBug 48901 - Endless wait by adding Synchronizing Timer\n\nModified:\n   jakarta/jmeter/trunk/src/components/org/apache/jmeter/timers/SyncTimer.java\n   jakarta/jmeter/trunk/xdocs/changes.xml"}]