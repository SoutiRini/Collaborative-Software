[{"count": 0, "tags": [], "bug_id": 6099, "attachment_id": null, "text": "In the \"Writing Applications\" FAQ, under the question \"How do I read data from a\nstream as it arrives?\" it is suggested that an instance of\norg.apache.xerces.readers.StreamingCharReader be used to parse a document as it\narrives over a socket.\n\nHowever, that class always reads ahead one character, so that even at the end of\nan XML document, it will block, waiting for more input. In addition, it attempts\nto read two characters at a time (to do some CR LF processing, though it appears\nthe behavior is identical if only one of those characters is available at a\ntime). This means that in a stream with multiple XML documents, it will always\nconsume one character that might belong to the next document, and may consume up\nto two.", "id": 10013, "time": "2002-01-29T14:59:01Z", "creator": "tterribe@argoneng.com", "creation_time": "2002-01-29T14:59:01Z", "is_private": false}, {"attachment_id": null, "tags": [], "bug_id": 6099, "text": "Actually, you should always wrap a stream with multiple documents on it with \n\"substreams\" that end the stream at the end of each document.  Since the parser \nhas no way of knowing when one document ends and another begins, you have to \nkeep some additional knowledge in the multi-document stream anyway.  This is \nbecause a document is not defined to end when the end tag of the root element \nhas been parsed, as there could be comments and processing instructions after \nthe end tag that are part of the same document.  A parser would always need to \nread ahead into the next document, and since the following document could also \nbegin with comments and processing instructions, how could you know which were \npart of which document?\n", "count": 1, "id": 10016, "time": "2002-01-29T15:46:41Z", "creator": "gmarcy@us.ibm.com", "creation_time": "2002-01-29T15:46:41Z", "is_private": false}, {"count": 2, "tags": [], "text": "In the general case, what you say is true. If, however, you know you are in an\nenvironment where comments can be ignored, and processing instructions other\nthan <?xml ?> are not needed, you can guarantee that the useful contents of the\ndocument end at the end of the root tag. This appears to be the case that the\nanswer in the FAQ was addressing, judging by their suggestion of throwing an\nexception when this occurs to terminate the parse. It is also the case I am\ninterested in.", "attachment_id": null, "bug_id": 6099, "id": 10018, "time": "2002-01-29T15:59:05Z", "creator": "tterribe@argoneng.com", "creation_time": "2002-01-29T15:59:05Z", "is_private": false}, {"count": 3, "tags": [], "bug_id": 6099, "attachment_id": 1091, "text": "Created attachment 1091\ndiff against v1.5 of against org.apache.xerces.readers.StreamingCharReader", "id": 10033, "time": "2002-01-29T19:24:41Z", "creator": "tterribe@argoneng.com", "creation_time": "2002-01-29T19:24:41Z", "is_private": false}, {"count": 4, "tags": [], "creator": "tterribe@argoneng.com", "attachment_id": null, "id": 10039, "time": "2002-01-29T19:45:18Z", "bug_id": 6099, "creation_time": "2002-01-29T19:45:18Z", "is_private": false, "text": "I've submitted a proposed patch for this bug. This modifies StreamingCharReader\nso that it does not attempt to read the next character in the stream until it is\nready to process it. The main changes were:\n\nWhere loadNextChar()'s return value was not used, it was replaced with a call to\na new consumeChar() method. This method advances the current index, but does not\nload the next character.\n\nfMostRecentChar was replaced with a getMostRecentChar() method, which checks\nwhether or not the current character has been loaded before returning it.\n\nAn extra call to getMostRecentChar() was added before the one call to atEOF()\nwhich did not already get the most recent character (so that fLength is correct).\n\nloadFirstChar() was replaced with a prepareChunk() method which does not\nactually load the first character.\n\nloadMoreChars() was modified to only read one character at a time.\n\nThe result is that the reader will never block waiting for input or consume\nextra input that it does not need to parse the current entity."}]