[{"count": 0, "tags": [], "creator": "grave@gmx.de", "is_private": false, "text": "Hi.\n\nI'm using log4j 1.2.16 with the companion/extras 1.1 package to allow rolling files based on time (at midnight) and perform gz compression. I also use an non-blocking AsyncAppender that delegates to SMTPAppender, and FileAppender.\n\nSystem:\n- Quadcore Xeon 2,33 Ghz\n- JDK 1.5.0_15\n- about 20 custom parallel working threads\n- about 800-1000mb log file per day\n\nI encountered a strange behavior on that system, that compression sometimes isn't performed. The file is renamed correctly though (from mylog.log to mylog.log.yyyy-MM-dd).\n\nI looked at the asynchronous GZCompressionAction and its superclass \nActionBase. ActionBase calls execute() on the subclass when run() is invoked.\nBut I found out, that sometimes execute() isn't called due to this code:\n\n    public synchronized void run()\n    {\n        if(!interrupted)\n        {\n\nInterrupted is set by the close() method. So looking for an invocation of close() I came across RollingFileAppender:\n\nhttp://grepcode.com/file/repo1.maven.org/maven2/log4j/apache-log4j-extras/1.1/org/apache/log4j/rolling/RollingFileAppender.java/\n\nHere's where the race condition seems to happen. Debugging revealed, that in that special case close() is invoked BEFORE run() is called - interrupting the compression before it has even started.\n\nLooking at:\n\n...\n313: if (rollover.getAsynchronous() != null) {\n314:    lastRolloverAsyncAction = rollover.getAsynchronous();\n315:    new Thread(lastRolloverAsyncAction).start();\n316: }\n...\n\nwhich is protected by a synchronized block, starts a new Thread (GZCompressionAction). But start()ing doesn't neccessarily mean that\nrun() is invoked immediately! So when the synchronized block is left, lastRolloverAsyncAction is open to be interrupted by a parallel close() call done by this code earlier:\n\n224: synchronized (this) {\n225:   //\n226:   //   if a previous async task is still running\n227:   //}\n228:   if (lastRolloverAsyncAction != null) {\n229:     //\n230:     //  block until complete\n231:     //\n232:     lastRolloverAsyncAction.close();\n...\n\nSo at this point, before run() even gets invoked by the JVM, close() has \"interrupted\" the GZCompressAction (more specific the ActionBase).\n\nI hope somebody could follow me and can confirm this.\n\nI tried to create a test case but it seems really hard to reproduce this.\nAs soon as I have one, I'll let you know.\n\nIn the meantime, maybe someone can take a look at this.\n\nThanks.", "id": 146130, "time": "2011-05-04T22:30:06Z", "bug_id": 51152, "creation_time": "2011-05-04T22:30:06Z", "attachment_id": null}, {"count": 1, "tags": [], "bug_id": 51152, "attachment_id": null, "text": "Hi,\n\nI'm also using log4j 1.2.16 with the companion/extras 1.1 package to allow rolling\nfiles based on time (at midnight).\n\nmy log4j.properties file\n\n#log4j.rootLogger=debug, stdout, file\nlog4j.rootLogger=off\n\n# Logging to both stdout and a file\nlog4j.logger.com.cymfony=debug, stdout, file\n\n# Logging to the file only. This should be production configuration\n# to avoid overflowing stdout.log file.\n#log4j.logger.com.cymfony=info, file\n\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern=%d{HH:mm:ss} [%p] %c{1}| %m%n\n\n# NOTE: DO NOT change this appender' class, it is referenced in code\n# to generate unique log files for retriever by inserting the\n# provider and client into the file name.\nlog4j.appender.file=org.apache.log4j.rolling.RollingFileAppender\nlog4j.appender.file.File=logs/crs.log\nlog4j.appender.file.RollingPolicy=org.apache.log4j.rolling.TimeBasedRollingPolicy\nlog4j.appender.file.RollingPolicy.FileNamePattern=logs/crs.log.%d{yyyy-MM-dd}\nlog4j.appender.file.layout=org.apache.log4j.TTCCLayout\nlog4j.appender.file.layout.DateFormat=DATE\n\nRun this through VNC Viewer, Rolling files based on midnight is working fine.\n\nIf i schedule through cron, Rolling files some time it's not happening.\n\nkindly help me to find the solution.", "id": 146206, "time": "2011-05-09T12:27:34Z", "creator": "godsondavid.j@gmail.com", "creation_time": "2011-05-09T12:27:34Z", "is_private": false}, {"count": 2, "attachment_id": null, "bug_id": 51152, "is_private": false, "id": 147321, "time": "2011-06-21T12:55:22Z", "creator": "godsondavid.j@gmail.com", "creation_time": "2011-06-21T12:55:22Z", "tags": [], "text": "It is not a issue... if 2 instance at the same time involved to create log file at 0 sec(while putting the cron schedule) Rolling files failure should happen, so we need to change cron schedule time 0sec is not at all preferred one(while putting the cron schedule)."}, {"count": 3, "tags": [], "creator": "grave@gmx.de", "is_private": false, "text": "Any news on this?\n\nMy workaround is, to clone the GZCompressAction as a custom GZCompressAction and overwrite the run() method from ActionBase to _always_ call execute, not checking \"interrupted\" variable anymore.\n\nThat seems to work - but isn't really nice.", "id": 148570, "time": "2011-08-11T18:19:46Z", "bug_id": 51152, "creation_time": "2011-08-11T18:19:46Z", "attachment_id": null}, {"count": 4, "tags": [], "text": "*** Bug 53417 has been marked as a duplicate of this bug. ***", "is_private": false, "bug_id": 51152, "id": 167237, "time": "2013-05-16T09:23:17Z", "creator": "grobmeier@gmail.com", "creation_time": "2013-05-16T09:23:17Z", "attachment_id": null}]