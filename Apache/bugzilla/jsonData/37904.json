[{"count": 0, "tags": [], "bug_id": 37904, "attachment_id": null, "id": 83642, "time": "2005-12-14T12:50:14Z", "creator": "jan.kronquist@jayway.se", "creation_time": "2005-12-14T12:50:14Z", "is_private": false, "text": "When the BoundedFIFO is full the AsynchAppender will wait for ever for the\nDispatcher to remove an element from the buffer. This might seem reasonable as\nthis will not happen very often, but the following problem occurred in our\nproduction environment:\n\nWe wanted to send a mail for certain exceptions. However, the SMTP server was\nincorrectly configured which caused the Dispatcher thread to hang for several\nminutes for each event. The buffer quickly filled up and then the AsynchAppender\nalso waited several minutes until all exceptions had been processed.\n\nThis was quite difficult to debug since the server seemed to work fine and only\nslowed down a while after the error occurred and the file logging worked fine.\nWe did not realize that the fact that we did not get the email was related to\nthe server slowing down or hanging. As the server only hang during a couple of\nminutes it took a while until we managed to get a thread dump.\n\nThe purpose of using AsynchAppender is to avoid blocking the current thread,\ntherefore I think that the AsynchAppender should handle the buffer full\nsituation better.\n\nTwo different solution proposals:\n1) Log something when the buffer is full. This will make this condition easier\nto find and will probably only occur in exceptional cases.\n2) Limit the time to wait on the buffer. Log and give up when this limit is\nexceeded. This will have some extra overhead, but the server will not be blocked\nbecause of incorrect configuration. The timeout should be possible to configure.  \n\n1) Log something when the buffer is full:\n      while (bf.isFull()) {\n        try {\n          LogLog.warn(\"AsynchAppender buffer is full!!\");\n          bf.wait();\n\n2) Limit the time to wait on the buffer: \n      long before = System.currentTimeMillis();\n      while (bf.isFull()) {\n        try {\n          //LogLog.debug(\"Waiting for free space in buffer, \"+bf.length());\n          bf.wait(this.bufferTimeout);\n          if (System.currentTimeMillis()-before >= this.bufferTimeout) {\n             LogLog.error(\"AsynchAppender failed to log event within specified\ntimeout. event=\" + event);\n\t     return;\n          }\n\n\n(The same problem exists in 1.3)"}, {"count": 1, "tags": [], "bug_id": 37904, "attachment_id": null, "text": "AsyncAppender has been rewritten recently to address a large number of issues that we reported against \nit which were rolled into bug 38137 which I'm marking this bug as a duplicate.  In the SVN source for log4j \n1.2 and 1.3, AsyncAppender now has a blocking property that when set to false will cause the appender \nnot to block when the queue is full but count and discard messages and to produce a summary when the \nbacklog is cleared.  I expect to have new releases with the updated code real-soon-now, but it would be \nmost helpful if you could confirm that the new code addresses your concerns before the release.\n\n*** This bug has been marked as a duplicate of 38137 ***", "id": 92826, "time": "2006-08-31T21:12:39Z", "creator": "carnold@apache.org", "creation_time": "2006-08-31T21:12:39Z", "is_private": false}]