[{"count": 0, "attachment_id": null, "creator": "Wolfgang.Jakel@lutzwolf.de", "is_private": false, "id": 12125, "time": "2002-03-21T13:32:56Z", "bug_id": 7320, "creation_time": "2002-03-21T13:32:56Z", "tags": [], "text": "The ant 'replace' built-in-task supports multiple <replacefilters>, but I see \nno way to define the tokens outside the build.xml. Especially I have the task \nto read a property file with each key interpreted as token and replace the key \nwith his value in a number of files. \nIt is convenient to indroduce a new attribute 'replaceFilterFile' reading a \nvalid property file and create for each key-value pair internally a \n<replacefilter>.\nI modified the file /src/main/org/apache/tools/ant/taskdefs/Replace.java.\nSee the code below and look at the variable replaceFilterFile to see what I \ndid. I think this feature is of some general interest. \nAnyway, the modification works fine for my purposes.  \n\n\n/*\n * The Apache Software License, Version 1.1\n *\n * Copyright (c) 1999 The Apache Software Foundation.  All rights \n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * 3. The end-user documentation included with the redistribution, if\n *    any, must include the following acknowlegement:  \n *       \"This product includes software developed by the \n *        Apache Software Foundation (http://www.apache.org/).\"\n *    Alternately, this acknowlegement may appear in the software itself,\n *    if and wherever such third-party acknowlegements normally appear.\n *\n * 4. The names \"The Jakarta Project\", \"Ant\", and \"Apache Software\n *    Foundation\" must not be used to endorse or promote products derived\n *    from this software without prior written permission. For written \n *    permission, please contact apache@apache.org.\n *\n * 5. Products derived from this software may not be called \"Apache\"\n *    nor may \"Apache\" appear in their names without prior written\n *    permission of the Apache Group.\n *\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n * ====================================================================\n *\n * This software consists of voluntary contributions made by many\n * individuals on behalf of the Apache Software Foundation.  For more\n * information on the Apache Software Foundation, please see\n * <http://www.apache.org/>.\n */\n\npackage org.apache.tools.ant.taskdefs;\n\nimport org.apache.tools.ant.*;\nimport org.apache.tools.ant.taskdefs.*;\nimport java.io.*;\nimport java.util.*;\n\n/**\n * Replaces all occurrences of one or more string tokens with given\n * values in the indicated files. Each value can be either a string \n * or the value of a property available in a designated property file.\n *\n * @author Stefano Mazzocchi <a \nhref=\"mailto:stefano@apache.org\">stefano@apache.org</a>\n * @author <a href=\"mailto:erik@desknetinc.com\">Erik Langenbach</a>\n */\npublic class Replace extends MatchingTask {\n    \n    private File src = null;\n    private NestedString token = null;\n    private NestedString value = new NestedString();\n\n    private File propertyFile = null;\n    private File replaceFilterFile = null;\n    private Properties properties = null;\n    private Vector replacefilters = new Vector();\n\n    private File dir = null;\n\n    private int fileCount;\n    private int replaceCount;    \n    private boolean summary = false;\n    \n    //Inner class\n    public class NestedString {\n\n        private StringBuffer buf = new StringBuffer();\n\n        public void addText(String val) {\n            buf.append(val);\n        }\n\n        public String getText() {\n            return buf.toString();\n        }\n    }\n\n    //Inner class\n    public class Replacefilter\n    {\n        private String token;\n        private String value;\n        private String property;\n\n        public void validate() throws BuildException {\n            //Validate mandatory attributes\n            if (token == null) {\n                String message = \"token is a mandatory attribute \" + \"of \nreplacefilter.\";\n                throw new BuildException(message);\n            }\n\n            if (\"\".equals(token)) {\n                String message =\"The token attribute must not be an empty \nstring.\";\n                throw new BuildException(message);\n            }\n\n            //value and property are mutually exclusive attributes\n            if ((value != null) && (property != null)) {\n                String message = \"Either value or property \" + \"can be \nspecified, but a replacefilter \" + \"element cannot have both.\";\n                throw new BuildException(message);\n            }\n\n            if ((property != null)) {\n                //the property attribute must have access to a property file\n                if (propertyFile == null) {\n                    String message = \"The replacefilter's property attribute \" \n+ \"can only be used with the replacetask's \" + \"propertyFile attribute.\";\n                    throw new BuildException(message);\n                }\n\n                //Make sure property exists in property file\n                if (properties == null ||\n                        properties.getProperty(property) == null) {\n                    String message = \"property \\\"\" + property + \"\\\" was not \nfound in \" + propertyFile.getPath();\n                    throw new BuildException(message);\n                }\n            }\n        }\n\n        public String getReplaceValue()\n        {\n            if (property != null) {\n                return (String)properties.getProperty(property);\n            }\n            else if (value != null) {\n                return value;\n            }\n            else if (Replace.this.value != null) {\n                return Replace.this.value.getText();\n            }\n            else {\n                //Default is empty string\n                return new String(\"\");\n            }\n        }\n\n        public void setToken(String token) {\n            this.token = token;\n        }\n\n        public String getToken() {\n            return token;\n        }\n\n        public void setValue(String value) {\n            this.value = value;\n        }\n\n        public String getValue() {\n            return value;\n        }\n\n        public void setProperty(String property) {\n            this.property = property;\n        }\n\n        public String getProperty() {\n            return property;\n        }\n    }\n\n    /**\n     * Do the execution.\n     */\n    public void execute() throws BuildException {\n\n        if (replaceFilterFile != null) {\n            Properties properties = getProperties(replaceFilterFile);\n            Enumeration enum = properties.keys();\n            while(enum.hasMoreElements()){\n               String token =  enum.nextElement().toString();\n               Replacefilter replaceFilter = createReplacefilter();\n               replaceFilter.setToken(token);\n               replaceFilter.setValue(properties.getProperty(token));\n            }\n        }\n\n        validateAttributes();\n\n        if (propertyFile != null) {\n            properties = getProperties(propertyFile);\n        }\n\n\n        validateReplacefilters();\n        fileCount = 0;\n        replaceCount = 0;\n\n        if (src != null) {\n            processFile(src);\n        }\n\n        if (dir != null) {\n            DirectoryScanner ds = super.getDirectoryScanner(dir);\n            String[] srcs = ds.getIncludedFiles();\n\n            for(int i=0; i<srcs.length; i++) {\n                File file = new File(dir,srcs[i]);\n                processFile(file);\n            }\n        }\n        \n        if (summary) {\n            log(\"Replaced \" + replaceCount + \" occurrences in \" + fileCount + \" \nfiles.\", Project.MSG_INFO);\n        }\n    }\n    \n    /**\n     * Validate attributes provided for this task in .xml build file.\n     *\n     * @exception BuildException if any supplied attribute is invalid or any\n     * mandatory attribute is missing\n     */\n    public void validateAttributes() throws BuildException {\n        if (src == null && dir == null) {\n            String message = \"Either the file or the dir attribute \" + \"must be \nspecified\";\n            throw new BuildException(message, location);\n        }\n        if (propertyFile != null && !propertyFile.exists()) {\n            String message = \"Property file \" + propertyFile.getPath() + \" does \nnot exist.\";\n            throw new BuildException(message, location);\n        }\n        if (token == null && replacefilters.size() == 0) {\n            String message = \"Either token or a nested replacefilter \"\n                + \"must be specified\";\n            throw new BuildException(message, location);\n        }\n        if (token != null && \"\".equals(token.getText())) {\n            String message =\"The token attribute must not be an empty string.\";\n            throw new BuildException(message, location);\n        }\n    }\n\n    /**\n     * Validate nested elements.\n     *\n     * @exception BuildException if any supplied attribute is invalid or any\n     * mandatory attribute is missing\n     */\n    public void validateReplacefilters()\n            throws BuildException {\n        for (int i = 0; i < replacefilters.size(); i++) {\n            Replacefilter element = (Replacefilter) replacefilters.elementAt(i);\n            element.validate();\n        }\n    }\n\n    public Properties getProperties(File propertyFile) throws BuildException {\n        Properties properties = new Properties();\n\n        try {\n            properties.load(new FileInputStream(propertyFile));\n        }\n        catch (FileNotFoundException e) {\n            String message = \"Property file (\" + propertyFile.getPath() + \") \nnot found.\";\n            throw new BuildException(message);\n        }\n        catch (IOException e) {\n            String message = \"Property file (\" + propertyFile.getPath() + \") \ncannot be loaded.\";\n            throw new BuildException(message);\n        }\n\n        return properties;\n    }\n\n    /**\n     * Perform the replacement on the given file.\n     *\n     * The replacement is performed on a temporary file which then\n     * replaces the original file.\n     *\n     * @param src the source file\n     */\n    private void processFile(File src) throws BuildException {\n        if (!src.exists()) {\n            throw new BuildException(\"Replace: source file \" + src.getPath() \n+ \" doesn't exist\", location);\n        }\n\n        File temp = new File(src.getPath() + \".temp\");\n\n        if (temp.exists()) {\n            throw new BuildException(\"Replace: temporary file \" + temp.getPath\n() + \" already exists\", location);\n        }\n\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(src));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(temp));\n\n            // read the entire file into a StringBuffer\n            //   size of work buffer may be bigger than needed\n            //   when multibyte characters exist in the source file\n            //   but then again, it might be smaller than needed on\n            //   platforms like Windows where length can't be trusted\n            int fileLengthInBytes = (int)(src.length());\n            StringBuffer tmpBuf = new StringBuffer(fileLengthInBytes);\n            int readChar = 0;\n            int totread = 0;\n            while (true) {\n                readChar = br.read();\n                if (readChar < 0) { break; }\n                tmpBuf.append((char)readChar);\n                totread++;\n            }\n\n            // create a String so we can use indexOf\n            String buf = tmpBuf.toString();\n\n            //Preserve original string (buf) so we can compare the result\n            String newString = new String(buf);\n\n            if (token != null)\n            {\n                // line separators in values and tokens are \"\\n\"\n                // in order to compare with the file contents, replace them\n                // as needed\n                String linesep = System.getProperty(\"line.separator\");\n                String val = stringReplace(value.getText(), \"\\n\", linesep);\n                String tok = stringReplace(token.getText(), \"\\n\", linesep);\n\n                // for each found token, replace with value\n                log(\"Replacing in \" + src.getPath() + \": \" + token.getText() \n+ \" --> \" + value.getText(), Project.MSG_VERBOSE);\n                newString = stringReplace(newString, tok, val);\n            }\n\n            if (replacefilters.size() > 0) {\n                newString = processReplacefilters(newString, src.getPath());\n            }\n\n            boolean changes = !newString.equals(buf);\n            if (changes) {\n                bw.write(newString,0,newString.length());\n                bw.flush();\n            }\n\n            // cleanup\n            bw.close();\n            br.close();\n\n            // If there were changes, move the new one to the old one;\n            // otherwise, delete the new one\n            if (changes) {\n                ++fileCount;\n                src.delete();\n                temp.renameTo(src);\n            } else {\n                temp.delete();\n            }\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n            throw new BuildException(ioe, location);\n        }\n    }\n\n    private String processReplacefilters(String buffer, String filename) {\n        String newString = new String(buffer);\n\n        for (int i = 0; i < replacefilters.size(); i++) {\n            Replacefilter filter = (Replacefilter) replacefilters.elementAt(i);\n\n            //for each found token, replace with value\n            log(\"Replacing in \" + filename + \": \" + filter.getToken() + \" --> \" \n+ filter.getReplaceValue(), Project.MSG_VERBOSE);\n            newString = stringReplace(newString, filter.getToken(), \nfilter.getReplaceValue());\n        }\n\n        return newString;\n    }\n\n\n    /**\n     * Set the source file.\n     */\n    public void setFile(File file) {\n        this.src = file;\n    }\n\n    /**\n     * Request a summary\n     *\n     * @param summary true if you would like a summary logged of the replace \noperation\n     */\n    public void setSummary(boolean summary) {\n        this.summary = summary;\n    }\n    \n    \n    /**\n     * Set the source files path when using matching tasks.\n     */\n    public void setDir(File dir) {\n        this.dir = dir;\n    }\n\n    /**\n     * Set the string token to replace.\n     */\n    public void setToken(String token) {\n        createReplaceToken().addText(token);\n    }\n\n    /**\n     * Set the string value to use as token replacement.\n     */\n    public void setValue(String value) {\n        createReplaceValue().addText(value);\n    }\n\n    /**\n     * Nested <replacetoken> element.\n     */\n    public NestedString createReplaceToken() {\n        if (token == null) {\n            token = new NestedString();\n        }\n        return token;\n    }\n\n    /**\n     * Nested <replacevalue> element.\n     */\n    public NestedString createReplaceValue() {\n        return value;\n    }\n\n    /**\n     * Sets a file to be searched for property values.\n     */\n    public void setPropertyFile(File filename) {\n        propertyFile = filename;\n    }\n\n    /**\n     * Sets a file to be searched for property values.\n     */\n    public void setReplaceFilterFile(File filename) {\n        replaceFilterFile = filename;\n    }\n\n\n\n    /**\n     * Add nested <replacefilter> element.\n     */\n    public Replacefilter createReplacefilter() {\n        Replacefilter filter = new Replacefilter();\n        replacefilters.addElement(filter);\n        return filter;\n    }\n\n    /**\n     * Replace occurrences of str1 in string str with str2\n     */    \n    private String stringReplace(String str, String str1, String str2) {\n        StringBuffer ret = new StringBuffer();\n        int start = 0;\n        int found = str.indexOf(str1);\n        while (found >= 0) {\n            // write everything up to the found str1\n            if (found > start) {\n                ret.append(str.substring(start, found));\n            }\n\n            // write the replacement str2\n            if (str2 != null) {\n                ret.append(str2);\n            }\n\n            // search again\n            start = found + str1.length();\n            found = str.indexOf(str1,start);\n            ++replaceCount;\n        }\n\n        // write the remaining characters\n        if (str.length() > start) {\n            ret.append(str.substring(start, str.length()));\n        }\n\n        return ret.toString();\n    }\n\n}"}, {"count": 1, "tags": [], "bug_id": 7320, "is_private": false, "text": "<replace> supports a propertyfile attribute that you can use together with a\nproperty attribute on the nested <replacefilter> elements.  What you suggest\nsounds almost the same, only that you want to define all properties in that\nfile as tokens - can you patch the current code to optionally enable such an\n\"all properties are replacefilters\" behavior?\n\nPlease use diff -u instead of pasting the complete file 8-)\n\nThe propertyFile attribute has been introduced 2001-01-15, it is even part of\nAnt 1.3.", "id": 12740, "time": "2002-04-03T12:23:18Z", "creator": "bodewig@apache.org", "creation_time": "2002-04-03T12:23:18Z", "attachment_id": null}, {"count": 2, "tags": [], "bug_id": 7320, "text": "Created attachment 1468\nSupposed changes at Replace.java (nightly build 03-Apr-2002)", "id": 12759, "time": "2002-04-03T14:39:32Z", "creator": "Wolfgang.Jakel@lutzwolf.de", "creation_time": "2002-04-03T14:39:32Z", "is_private": false, "attachment_id": 1468}, {"count": 3, "tags": [], "bug_id": 7320, "is_private": false, "text": "committed, now we only need a documentation patch 8-)", "id": 12797, "time": "2002-04-04T10:44:24Z", "creator": "bodewig@apache.org", "creation_time": "2002-04-04T10:44:24Z", "attachment_id": null}, {"count": 4, "tags": [], "bug_id": 7320, "text": "*** Bug 5146 has been marked as a duplicate of this bug. ***", "id": 12859, "time": "2002-04-05T14:30:42Z", "creator": "bodewig@apache.org", "creation_time": "2002-04-05T14:30:42Z", "is_private": false, "attachment_id": null}, {"count": 5, "tags": [], "bug_id": 7320, "text": "*** Bug 3751 has been marked as a duplicate of this bug. ***", "id": 12862, "time": "2002-04-05T14:38:02Z", "creator": "bodewig@apache.org", "creation_time": "2002-04-05T14:38:02Z", "is_private": false, "attachment_id": null}, {"attachment_id": null, "tags": [], "creator": "bodewig@apache.org", "is_private": false, "count": 6, "id": 13347, "time": "2002-04-12T11:10:14Z", "bug_id": 7320, "creation_time": "2002-04-12T11:10:14Z", "text": "documented in nightly build 2002-04-13."}]