[{"count": 0, "tags": [], "creator": "lec@uniquare.com", "is_private": false, "id": 10535, "creation_time": "2002-02-11T08:18:06Z", "time": "2002-02-11T08:18:06Z", "bug_id": 6360, "text": "In some circumstances a call of request.getSession() may return null. Earlier \ntomcat versions throwed internal exceptions in such cases, version 3.3 returns \nnull instead.\nSuch error-situations can be recreated easily by using a set of multiple (e.g. \n5) frames and JSP's connected to a workerbean. If multiple requests are \narriving simultaneously the problem occurs very often. Multiple page-reloads \nare likely resolving the error until a next frameset has to be processed.\n\nOur used W2K test-server also uses 2 processors, which may have some impact to \nthe behavior.", "attachment_id": null}, {"count": 1, "tags": [], "creator": "lec@uniquare.com", "is_private": false, "id": 10547, "creation_time": "2002-02-11T15:25:16Z", "time": "2002-02-11T15:25:16Z", "bug_id": 6360, "text": "Obviously request.getSession(true) can be used to re-create the bug, so that \nthe \"create\"-flag does not have any real effect.", "attachment_id": null}, {"count": 2, "attachment_id": null, "bug_id": 6360, "text": "For our environment I've found a fix to resolve the problem:\n+ use a dispatcher-servlet\n  (servlets are do not have the encountered problem)\n+ synchronize the processed request to the session-object\n  (required to ensure that only one resource-request\n  is performed simultaneously)\n+ include the specified resource\n  (a forward to the resource would create a new thread and the\n  request would be de-synchronized again)\nThis solution is quite slower than the original implementation, but does never \nfail - independent how many frames are used.\nFurther tests indicated that the HttpServletRequest seems to be re-initialized \nafter a parallel request within the session has been finished. The re-\ninitialisation is indicated by loss of the associated session. This applies at \nleast to Tomcat versions 3.1 and 3.3!", "id": 10577, "time": "2002-02-12T12:05:00Z", "creator": "lec@uniquare.com", "creation_time": "2002-02-12T12:05:00Z", "tags": [], "is_private": false}, {"count": 3, "tags": [], "creator": "lec@uniquare.com", "is_private": false, "id": 10682, "creation_time": "2002-02-14T08:21:16Z", "time": "2002-02-14T08:21:16Z", "bug_id": 6360, "text": "Excerpt from the Servlet 2.2 spec:\n\nUsing a Request Dispatcher\n\nTo use a request dispatcher, a developer needs to call either the include or \nforward method of the RequestDispatcher interface using the request and \nresponse arguments that were passed in via the service method of the Servlet \ninterface.\nThe Container Provider must ensure that the dispatch to a target servlet occurs \nin the same thread of the same VM as the original request.\n\n-> current Tomcat 3.3 implementation seems to forward the request in a new \nthread, which causes additional problems (that's why I needed to use \"include\" \nfor my workaround, which is quite different with new side-effects - but runs in \nthe same thread)", "attachment_id": null}, {"count": 4, "tags": [], "creator": "william.barker@wilshire.com", "attachment_id": null, "id": 10717, "time": "2002-02-14T19:37:10Z", "bug_id": 6360, "creation_time": "2002-02-14T19:37:10Z", "is_private": false, "text": "AFAIK the only way that request.getSession(true) can return null is if the \nnumber of active sessions exceeds maxActiveSessions.  Also, rd.forward is \nexecuted in the same thread as the original request.  \n\nThis looks very much like a common programmer error when using frames.  The \nbrowser will usually request the frames in parallel, so that each one ends up \ngetting its own session.  The fix is to do:\n<frame src=\"<%= response.encodeURL(\"/frame1.jsp\") %>\" ...\n\nSince I can't reproduce this, I'm marking it as invalid.  Feel free to re-open \nwith a test case that reproduces this.\n\n"}]