[{"count": 0, "tags": [], "text": "Due to beginning and ongoing discussions on both logging mailing lists I thougt\nit is good to provide some example how near a possible solution is.\nThe code below does not solve any of the problems in JCL regarding ClassLoading\nand dynamic lookup.\n\nThe idea is to ship an possible integration of Jakarta Commons Logging (JCL) and\nthe new Log4j Logging Wrapper UGLI. I can offer to make this part \"production\nready\" (Solid order of methods, JavaDoc, packaging...) if current project\nleaders give a \"go\".\n\nThis is just demo code, it is placed in ASF Bugzilla to make it easy to find.\n\nBelow:\n1) modified interface ULogger\n2) modified SimpleLogger\n3) modified NOPLogger\n4) modified JDK14Logger\n\nMissing\n5) modified org.apache.log4j.Logger (just 4 methods, but the code\nbelow shows how easy integration is...)\n\n\npackage org.apache.ugli;\n\n/**\n * \n * The main user inteface to logging. It is expected that logging takes places\n * through concerete implemetations of the ULogger interface.\n * \n * \n * @author Ceki G&uuml;lc&uuml;\n */\npublic interface ULogger extends org.apache.commons.logging.Log {\n\n\tpublic void trace(Object parameterizedMsg, Object param1);\n\n\tpublic void trace(Object parameterizedMsg, Object param1, Object param2);\n\t\n\t\n\t/**\n\t * Log a parameterized message object at the DEBUG level.\n\t * \n\t * <p>\n\t * This form is useful in avoiding the superflous object creation problem\n\t * when invoking this method while it is disabled.\n\t * </p>\n\t * \n\t * @param parameterizedMsg -\n\t *            the parameterized message object\n\t * @param param1 -\n\t *            the parameter\n\t */\n\tpublic void debug(Object parameterizedMsg, Object param1);\n\n\t/**\n\t * Log a parameterized message object at the DEBUG level.\n\t * \n\t * <p>\n\t * This form is useful in avoiding the superflous object creation problem\n\t * when invoking this method while it is disabled.\n\t * </p>\n\t * \n\t * @param parameterizedMsg -\n\t *            the parameterized message object\n\t * @param param1 -\n\t *            the first parameter\n\t * @param param2 -\n\t *            the second parameter\n\t */\n\tpublic void debug(Object parameterizedMsg, Object param1, Object param2);\n\t\n\tpublic void info(Object parameterizedMsg, Object param1);\n\n\tpublic void info(Object parameterizedMsg, Object param1, Object param2);\n\n\tpublic void warn(Object parameterizedMsg, Object param1);\n\n\tpublic void warn(Object parameterizedMsg, Object param1, Object param2);\n\n\tpublic void error(Object parameterizedMsg, Object param1);\n\n\tpublic void error(Object parameterizedMsg, Object param1, Object param2);\n\n\tpublic void fatal(Object parameterizedMsg, Object param1);\n\n\tpublic void fatal(Object parameterizedMsg, Object param1, Object param2);\n\n\t\n}\n//End of class ULogger\n\n\npackage org.apache.ugli.impl;\n\nimport org.apache.ugli.ULogger;\n\n/**\n * A no operation (NOP) implementation of {@link ULogger}.\n * \n * @author Ceki G&uuml;lc&uuml;\n */\npublic class NOPLogger implements ULogger {\n\n\t/**\n\t * The unique instance of NOPLogger.\n\t */\n\tpublic final static NOPLogger NOP_LOGGER = new NOPLogger();\n\n\t/**\n\t * There is no point in people creating multiple instances of NullLogger.\n\t * Hence, the private access modifier.\n\t */\n\tprivate NOPLogger() {\n\t}\n\n\t/*\n\t * Always returns false.\n\t * \n\t * @see org.apache.ugli.Logger#isDebugEnabled()\n\t */\n\tpublic boolean isDebugEnabled() {\n\t\treturn false;\n\t}\n\n\t/*\n\t * A NOP implementation.\n\t * \n\t * @see org.apache.ugli.Logger#debug(java.lang.Object)\n\t */\n\tpublic void debug(Object msg) {\n\t\t// NOP\n\t}\n\n\t/*\n\t * A NOP implementation.\n\t * \n\t * @see org.apache.ugli.Logger#debug(java.lang.Object, java.lang.Object,\n\t *      java.lang.Object)\n\t */\n\tpublic void debug(Object parameterizedMsg, Object param1, Object param2) {\n\t\t// NOP\n\t}\n\n\t/*\n\t * A NOP implementation.\n\t * \n\t * @see org.apache.ugli.Logger#debug(java.lang.Object, java.lang.Throwable)\n\t */\n\tpublic void debug(Object msg, Throwable t) {\n\t\t// NOP\n\t}\n\n\t/*\n\t * Always returns false.\n\t * \n\t * @see org.apache.ugli.Logger#isInfoEnabled()\n\t */\n\tpublic boolean isInfoEnabled() {\n\t\t// NOP\n\t\treturn false;\n\t}\n\n\t/*\n\t * A NOP implementation.\n\t * \n\t * @see org.apache.ugli.Logger#info(java.lang.Object)\n\t */\n\tpublic void info(Object msg) {\n\t\t// NOP\n\t}\n\n\t/*\n\t * A NOP implementation.\n\t * \n\t * @see org.apache.ugli.Logger#info(java.lang.Object, java.lang.Object,\n\t *      java.lang.Object)\n\t */\n\tpublic void info(String parameterizedMsg, Object param1, Object param2) {\n\t\t// NOP\n\t}\n\n\t/*\n\t * A NOP implementation.\n\t * \n\t * @see org.apache.ugli.Logger#info(java.lang.Object, java.lang.Throwable)\n\t */\n\tpublic void info(Object msg, Throwable t) {\n\t\t// NOP\n\t}\n\n\t/*\n\t * Always returns false.\n\t * \n\t * @see org.apache.ugli.Logger#isWarnEnabled()\n\t */\n\tpublic boolean isWarnEnabled() {\n\t\treturn false;\n\t}\n\n\t/*\n\t * A NOP implementation.\n\t * \n\t * @see org.apache.ugli.Logger#warn(java.lang.Object)\n\t */\n\tpublic void warn(Object msg) {\n\t\t// NOP\n\t}\n\n\t/*\n\t * A NOP implementation.\n\t * \n\t * @see org.apache.ugli.Logger#warn(java.lang.Object, java.lang.Object,\n\t *      java.lang.Object)\n\t */\n\tpublic void warn(String parameterizedMsg, Object param1, Object param2) {\n\t\t// NOP\n\t}\n\n\t/*\n\t * A NOP implementation.\n\t * \n\t * @see org.apache.ugli.Logger#warn(java.lang.Object, java.lang.Throwable)\n\t */\n\tpublic void warn(Object msg, Throwable t) {\n\t\t// NOP\n\t}\n\n\t/*\n\t * Always returns false.\n\t * \n\t * @see org.apache.ugli.Logger#isErrorEnabled()\n\t */\n\tpublic boolean isErrorEnabled() {\n\t\treturn false;\n\t}\n\n\t/*\n\t * A NOP implementation.\n\t * \n\t * @see org.apache.ugli.Logger#error(java.lang.Object)\n\t */\n\tpublic void error(Object msg) {\n\t\t// NOP\n\t}\n\n\t/*\n\t * A NOP implementation.\n\t * \n\t * @see org.apache.ugli.Logger#error(java.lang.Object, java.lang.Object,\n\t *      java.lang.Object)\n\t */\n\tpublic void error(String parameterizedMsg, Object param1, Object param2) {\n\t\t// NOP\n\t}\n\n\t/*\n\t * A NOP implementation.\n\t * \n\t * @see org.apache.ugli.Logger#error(java.lang.Object, java.lang.Throwable)\n\t */\n\tpublic void error(Object msg, Throwable t) {\n\t\t// NOP\n\t}\n\n\t/*\n\t * A NOP implementation.\n\t * \n\t * @see org.apache.ugli.ULogger#debug(java.lang.String, java.lang.Object)\n\t */\n\tpublic void debug(Object parameterizedMsg, Object param1) {\n\t\t// NOP\n\n\t}\n\n\t/*\n\t * A NOP implementation.\n\t * \n\t * @see org.apache.ugli.ULogger#error(java.lang.String, java.lang.Object)\n\t */\n\tpublic void error(Object parameterizedMsg, Object param1) {\n\t\t// NOP\n\n\t}\n\n\t/*\n\t * A NOP implementation.\n\t * \n\t * @see org.apache.ugli.ULogger#fatal(java.lang.String, java.lang.Object,\n\t *      java.lang.Object)\n\t */\n\tpublic void fatal(Object parameterizedMsg, Object param1, Object param2) {\n\t\t// NOP\n\n\t}\n\n\t/*\n\t * A NOP implementation.\n\t * \n\t * @see org.apache.ugli.ULogger#fatal(java.lang.String, java.lang.Object)\n\t */\n\tpublic void fatal(Object parameterizedMsg, Object param1) {\n\t\t// NOP\n\n\t}\n\n\t/*\n\t * A NOP implementation.\n\t * \n\t * @see org.apache.ugli.ULogger#info(java.lang.String, java.lang.Object)\n\t */\n\tpublic void info(Object parameterizedMsg, Object param1) {\n\t\t// NOP\n\n\t}\n\n\t/*\n\t * A NOP implementation.\n\t * \n\t * @see org.apache.ugli.ULogger#trace(java.lang.String, java.lang.Object,\n\t *      java.lang.Object)\n\t */\n\tpublic void trace(Object parameterizedMsg, Object param1, Object param2) {\n\t\t// NOP\n\t}\n\n\t/*\n\t * A NOP implementation.\n\t * \n\t * @see org.apache.ugli.ULogger#trace(java.lang.String, java.lang.Object)\n\t */\n\tpublic void trace(Object parameterizedMsg, Object param1) {\n\t\t// NOP\n\t}\n\n\t/*\n\t * A NOP implementation.\n\t * \n\t * @see org.apache.ugli.ULogger#warn(java.lang.String, java.lang.Object)\n\t */\n\tpublic void warn(Object parameterizedMsg, Object param1) {\n\t\t// NOP\n\n\t}\n\n\t/*\n\t * A NOP implementation.\n\t * \n\t * @see org.apache.commons.logging.Log#fatal(java.lang.Object,\n\t *      java.lang.Throwable)\n\t */\n\tpublic void fatal(Object message, Throwable t) {\n\t\t// NOP\n\n\t}\n\n\t/*\n\t * A NOP implementation.\n\t * \n\t * @see org.apache.commons.logging.Log#fatal(java.lang.Object)\n\t */\n\tpublic void fatal(Object message) {\n\t\t// NOP\n\n\t}\n\n\t/*\n\t * Always returns false.\n\t * \n\t * @see org.apache.commons.logging.Log#isFatalEnabled()\n\t */\n\tpublic boolean isFatalEnabled() {\n\t\treturn false;\n\t}\n\n\t/*\n\t * Always returns false.\n\t * \n\t * @see org.apache.commons.logging.Log#isTraceEnabled()\n\t */\n\tpublic boolean isTraceEnabled() {\n\t\treturn false;\n\t}\n\n\t/*\n\t * A NOP implementation.\n\t * \n\t * @see org.apache.commons.logging.Log#trace(java.lang.Object,\n\t *      java.lang.Throwable)\n\t */\n\tpublic void trace(Object message, Throwable t) {\n\t\t// NOP\n\n\t}\n\n\t/*\n\t * A NOP implementation.\n\t * \n\t * @see org.apache.commons.logging.Log#trace(java.lang.Object)\n\t */\n\tpublic void trace(Object message) {\n\t\t// NOP\n\t}\n\n\t/**\n\t * A NOP implementation.\n\t * \n\t * @see org.apache.ugli.ULogger#error(java.lang.Object, java.lang.Object,\n\t *      java.lang.Object)\n\t */\n\tpublic void error(Object parameterizedMsg, Object param1, Object param2) {\n\t\t// NOP\n\n\t}\n\n\t/**\n\t * A NOP implementation.\n\t * \n\t * @see org.apache.ugli.ULogger#info(java.lang.Object, java.lang.Object,\n\t *      java.lang.Object)\n\t */\n\tpublic void info(Object parameterizedMsg, Object param1, Object param2) {\n\t\t// NOP\n\n\t}\n\n\t/**\n\t * A NOP implementation.\n\t * \n\t * @see org.apache.ugli.ULogger#warn(java.lang.Object, java.lang.Object,\n\t *      java.lang.Object)\n\t */\n\tpublic void warn(Object parameterizedMsg, Object param1, Object param2) {\n\t\t// NOP\n\n\t}\n\n}\n//End of class NOPLogger\n\n\nimport org.apache.ugli.ULogger;\n\n/**\n * A simple implementation that logs messages of level INFO or higher on the\n * console (<code>System.out<code>). \n * <p>\n * The output includes the relative time in milliseconds, thread name, the level,  \n * logger name, and the message followed by the line separator for the host. \n * In log4j terms it amounts to the \"%r  [%t] %level %logger - %m%n\" pattern.\n * <pre>\n * \n *           \n *   176 [main] INFO examples.Sort - Populating an array of 2 elements in\nreverse order.\n *   225 [main] INFO examples.SortAlgo - Entered the sort method.\n *   304 [main] INFO SortAlgo.DUMP - Dump of interger array:\n *   317 [main] INFO SortAlgo.DUMP - Element [0] = 0\n *   331 [main] INFO SortAlgo.DUMP - Element [1] = 1\n *   343 [main] INFO examples.Sort - The next log statement should be an error\nmessage.\n *   346 [main] ERROR SortAlgo.DUMP - Tried to dump an uninitialized array.\n *   at org.log4j.examples.SortAlgo.dump(SortAlgo.java:58)\n *   at org.log4j.examples.Sort.main(Sort.java:64)\n *   467 [main] INFO  examples.Sort - Exiting main method.\n *            \n *   \n *  \n * </pre>\n * \n * @author Ceki G&uuml;lc&uuml;\n */\npublic class SimpleLogger implements ULogger {\n\n\tString loggerName;\n\n\t/**\n\t * Mark the time when this class gets loaded into memory.\n\t */\n\tstatic private long startTime = System.currentTimeMillis();\n\n\tpublic static final String LINE_SEPARATOR = System\n\t\t\t.getProperty(\"line.separator\");\n\n\tstatic private String INFO_STR = \"INFO\";\n\n\tstatic private String WARN_STR = \"WARN\";\n\n\tstatic private String ERROR_STR = \"ERROR\";\n\n\t/**\n\t * Package access allows only {@link SimpleLoggerFA} to instantiate\n\t * SimpleLogger instances.\n\t */\n\tSimpleLogger(String name) {\n\t\tthis.loggerName = name;\n\t}\n\n\t/**\n\t * This is our internal implementation for logging regular\n\t * (non-parameterized) log messages.\n\t * \n\t * @param level\n\t * @param message\n\t * @param t\n\t */\n\tprivate void log(String level, String message, Throwable t) {\n\t\tStringBuffer buf = new StringBuffer();\n\n\t\tlong millis = System.currentTimeMillis();\n\t\tbuf.append(millis - startTime);\n\n\t\tbuf.append(\" [\");\n\t\tbuf.append(Thread.currentThread().getName());\n\t\tbuf.append(\"] \");\n\n\t\tbuf.append(level);\n\t\tbuf.append(\" \");\n\n\t\tbuf.append(loggerName);\n\t\tbuf.append(\" - \");\n\n\t\tbuf.append(message);\n\n\t\tbuf.append(LINE_SEPARATOR);\n\n\t\tSystem.out.print(buf.toString());\n\t\tif (t != null) {\n\t\t\tt.printStackTrace(System.out);\n\t\t}\n\t\tSystem.out.flush();\n\t}\n\tprivate String formatObject(Object parameterizedMsg, Object param1,\n\t\t\tObject param2) {\n\t\tString formatedString = null;\n\t\tif (parameterizedMsg instanceof String) {\n\t\t\ttry {\n\t\t\t\tString msgStr = (String) parameterizedMsg;\n\t\t\t\tmsgStr = MessageFormatter.format(msgStr, param1, param2);\n\t\t\t} catch (RuntimeException e) {\n\t\t\t\tformatedString = improveFormatObject(parameterizedMsg, param1,\n\t\t\t\t\t\tparam2);\n\t\t\t}\n\n\t\t} else {\n\t\t\t// To be failsafe, we handle the case where 'messagePattern' is\n\t\t\t// not a valid String. Unless the user makes a mistake, this should\n\t\t\t// not happen.\n\t\t\tformatedString = improveFormatObject(parameterizedMsg, param1,\n\t\t\t\t\tparam2);\n\t\t}\n\t\treturn formatedString;\n\t}\n\n\tprivate String improveFormatObject(Object parameterizedMsg,\n\t\t\tObject param1, Object param2) {\n\t\tStringBuffer myBuf = new StringBuffer(String.valueOf(parameterizedMsg));\n\t\tmyBuf.append(\"[\");\n\t\tmyBuf.append(param1);\n\t\tmyBuf.append(\"]\");\n\t\tif (param2 != null) {\n\t\t\tmyBuf.append(\"[\");\n\t\t\tmyBuf.append(param2);\n\t\t\tmyBuf.append(\"]\");\n\t\t}\n\t\treturn myBuf.toString();\n\t}\n\t/**\n\t * For parameterized messages, first substitute parameters and then log.\n\t * \n\t * @param level\n\t * @param parameterizedMsg\n\t * @param param1\n\t * @param param2\n\t */\n\tprivate void parameterizedLog(String level, Object parameterizedMsg,\n\t\t\tObject param1, Object param2) {\n\t\tString msgString = formatObject(parameterizedMsg, param1, param2);\t\n\t\tlog(level, msgString, null);\n\t}\n\n\t/*\n\t * A NOP implementation.\n\t * \n\t * @see org.apache.commons.logging.Log#debug(java.lang.Object,\n\t *      java.lang.Throwable)\n\t */\n\tpublic void debug(Object message, Throwable t) {\n\t\t// NOP\n\n\t}\n\n\t/*\n\t * A NOP implementation.\n\t * \n\t * @see org.apache.commons.logging.Log#debug(java.lang.Object)\n\t */\n\tpublic void debug(Object message) {\n\t\t// NOP\n\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.apache.commons.logging.Log#error(java.lang.Object,\n\t *      java.lang.Throwable)\n\t */\n\tpublic void error(Object message, Throwable t) {\n\t\tlog(ERROR_STR, String.valueOf(message), t);\n\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.apache.commons.logging.Log#error(java.lang.Object)\n\t */\n\tpublic void error(Object message) {\n\t\tlog(ERROR_STR, String.valueOf(message), null);\n\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.apache.commons.logging.Log#fatal(java.lang.Object,\n\t *      java.lang.Throwable)\n\t */\n\tpublic void fatal(Object message, Throwable t) {\n\t\tlog(ERROR_STR, String.valueOf(message), t);\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.apache.commons.logging.Log#fatal(java.lang.Object)\n\t */\n\tpublic void fatal(Object message) {\n\t\tlog(ERROR_STR, String.valueOf(message), null);\n\n\t}\n\n\t/*\n\t * @see org.apache.commons.logging.Log#info(java.lang.Object,\n\t *      java.lang.Throwable)\n\t */\n\tpublic void info(Object message, Throwable t) {\n\t\tlog(INFO_STR, String.valueOf(message), t);\n\n\t}\n\n\t/*\n\t * @see org.apache.commons.logging.Log#info(java.lang.Object)\n\t */\n\tpublic void info(Object message) {\n\t\tlog(INFO_STR, String.valueOf(message), null);\n\n\t}\n\n\t/*\n\t * Always returns false.\n\t * \n\t * @see org.apache.commons.logging.Log#isDebugEnabled()\n\t */\n\tpublic boolean isDebugEnabled() {\n\t\treturn false;\n\t}\n\n\t/*\n\t * Always returns true.\n\t * \n\t * @see org.apache.commons.logging.Log#isErrorEnabled()\n\t */\n\tpublic boolean isErrorEnabled() {\n\t\treturn true;\n\t}\n\n\t/*\n\t * Always returns true.\n\t * \n\t * @see org.apache.commons.logging.Log#isFatalEnabled()\n\t */\n\tpublic boolean isFatalEnabled() {\n\t\treturn true;\n\t}\n\n\t/*\n\t * Always returns true.\n\t * \n\t * @see org.apache.commons.logging.Log#isInfoEnabled()\n\t */\n\tpublic boolean isInfoEnabled() {\n\t\treturn true;\n\t}\n\n\t/*\n\t * Always returns false.\n\t * \n\t * @see org.apache.commons.logging.Log#isTraceEnabled()\n\t */\n\tpublic boolean isTraceEnabled() {\n\t\treturn false;\n\t}\n\n\t/*\n\t * Always returns true.\n\t * \n\t * @see org.apache.commons.logging.Log#isWarnEnabled()\n\t */\n\tpublic boolean isWarnEnabled() {\n\t\treturn true;\n\t}\n\n\t/*\n\t * A NOP implementation.\n\t * \n\t * @see org.apache.commons.logging.Log#trace(java.lang.Object,\n\t *      java.lang.Throwable)\n\t */\n\tpublic void trace(Object message, Throwable t) {\n\t\t// NOP\n\n\t}\n\n\t/*\n\t * A NOP implementation.\n\t * \n\t * @see org.apache.commons.logging.Log#trace(java.lang.Object)\n\t */\n\tpublic void trace(Object message) {\n\t\t// NOP\n\n\t}\n\n\t/*\n\t * @see org.apache.commons.logging.Log#warn(java.lang.Object,\n\t *      java.lang.Throwable)\n\t */\n\tpublic void warn(Object message, Throwable t) {\n\t\tlog(ERROR_STR, String.valueOf(message), t);\n\n\t}\n\n\t/*\n\t * @see org.apache.commons.logging.Log#warn(java.lang.Object)\n\t */\n\tpublic void warn(Object message) {\n\t\tlog(WARN_STR, String.valueOf(message), null);\n\n\t}\n\n\t/*\n\t * @see org.apache.ugli.ULogger#debug(java.lang.String, java.lang.Object,\n\t *      java.lang.Object)\n\t */\n\tpublic void debug(Object parameterizedMsg, Object param1, Object param2) {\n\t\t// NOP\n\n\t}\n\n\t/*\n\t * @see org.apache.ugli.ULogger#debug(java.lang.String, java.lang.Object)\n\t */\n\tpublic void debug(Object parameterizedMsg, Object param1) {\n\t\t// NOP\n\n\t}\n\n\t/*\n\t * @see org.apache.ugli.ULogger#error(java.lang.String, java.lang.Object,\n\t *      java.lang.Object)\n\t */\n\tpublic void error(Object parameterizedMsg, Object param1, Object param2) {\n\t\tparameterizedLog(ERROR_STR, parameterizedMsg, param1, param2);\n\n\t}\n\n\t/*\n\t * @see org.apache.ugli.ULogger#error(java.lang.String, java.lang.Object)\n\t */\n\tpublic void error(Object parameterizedMsg, Object param1) {\n\t\tparameterizedLog(ERROR_STR, parameterizedMsg, param1, null);\n\n\t}\n\n\t/*\n\t * @see org.apache.ugli.ULogger#fatal(java.lang.String, java.lang.Object,\n\t *      java.lang.Object)\n\t */\n\tpublic void fatal(Object parameterizedMsg, Object param1, Object param2) {\n\t\tparameterizedLog(ERROR_STR, parameterizedMsg, param1, param2);\n\n\t}\n\n\t/*\n\t * @see org.apache.ugli.ULogger#fatal(java.lang.String, java.lang.Object)\n\t */\n\tpublic void fatal(Object parameterizedMsg, Object param1) {\n\t\tparameterizedLog(ERROR_STR, parameterizedMsg, param1, null);\n\n\t}\n\n\t/*\n\t * @see org.apache.ugli.ULogger#info(java.lang.String, java.lang.Object,\n\t *      java.lang.Object)\n\t */\n\tpublic void info(Object parameterizedMsg, Object param1, Object param2) {\n\t\tparameterizedLog(INFO_STR, parameterizedMsg, param1, param2);\n\n\t}\n\n\t/*\n\t * @see org.apache.ugli.ULogger#info(java.lang.String, java.lang.Object)\n\t */\n\tpublic void info(Object parameterizedMsg, Object param1) {\n\t\tparameterizedLog(INFO_STR, parameterizedMsg, param1, null);\n\n\t}\n\n\t/*\n\t * A NOP implementation.\n\t * \n\t * @see org.apache.ugli.ULogger#trace(java.lang.String, java.lang.Object,\n\t *      java.lang.Object)\n\t */\n\tpublic void trace(Object parameterizedMsg, Object param1, Object param2) {\n\t\t// NOP\n\n\t}\n\n\t/*\n\t * A NOP implementation.\n\t * \n\t * @see org.apache.ugli.ULogger#trace(java.lang.String, java.lang.Object)\n\t */\n\tpublic void trace(Object parameterizedMsg, Object param1) {\n\t\t// NOP\n\t}\n\n\t/*\n\t * @see org.apache.ugli.ULogger#warn(java.lang.String, java.lang.Object,\n\t *      java.lang.Object)\n\t */\n\tpublic void warn(Object parameterizedMsg, Object param1, Object param2) {\n\t\tparameterizedLog(WARN_STR, parameterizedMsg, param1, param2);\n\n\t}\n\n\t/*\n\t * @see org.apache.ugli.ULogger#warn(java.lang.String, java.lang.Object)\n\t */\n\tpublic void warn(Object parameterizedMsg, Object param1) {\n\t\tparameterizedLog(WARN_STR, parameterizedMsg, param1, null);\n\n\t}\n\n}\n//End of class SimpleLogger\n\nimport org.apache.ugli.ULogger;\n\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * A wrapper over\n * \n * @{link java.utill.Logger} which conforms to the {@link ULogger} interface.\n * \n * @author Ceki G&uuml;lc&uuml;\n */\npublic class JDK14Logger implements ULogger {\n\tfinal Logger logger;\n\n\t// WARN: JDK14Logger constructor should have only package access so that\n\t// only JDK14LoggerFA be able to create one.\n\tJDK14Logger(Logger logger) {\n\t\tthis.logger = logger;\n\t}\n\n\tprivate String formatObject(Object parameterizedMsg, Object param1,\n\t\t\tObject param2) {\n\t\tString formatedString = null;\n\t\tif (parameterizedMsg instanceof String) {\n\t\t\ttry {\n\t\t\t\tString msgStr = (String) parameterizedMsg;\n\t\t\t\tmsgStr = MessageFormatter.format(msgStr, param1, param2);\n\t\t\t} catch (RuntimeException e) {\n\t\t\t\tformatedString = improveFormatObject(parameterizedMsg, param1,\n\t\t\t\t\t\tparam2);\n\t\t\t}\n\n\t\t} else {\n\t\t\t// To be failsafe, we handle the case where 'messagePattern' is\n\t\t\t// not a valid String. Unless the user makes a mistake, this should\n\t\t\t// not happen.\n\t\t\tformatedString = improveFormatObject(parameterizedMsg, param1,\n\t\t\t\t\tparam2);\n\t\t}\n\t\treturn formatedString;\n\t}\n\n\tprivate String improveFormatObject(Object parameterizedMsg,\n\t\t\tObject param1, Object param2) {\n\t\tStringBuffer myBuf = new StringBuffer(String.valueOf(parameterizedMsg));\n\t\tmyBuf.append(\"[\");\n\t\tmyBuf.append(param1);\n\t\tmyBuf.append(\"]\");\n\t\tif (param2 != null) {\n\t\t\tmyBuf.append(\"[\");\n\t\t\tmyBuf.append(param2);\n\t\t\tmyBuf.append(\"]\");\n\t\t}\n\t\treturn myBuf.toString();\n\t}\n\n\tpublic void trace(Object parameterizedMsg, Object param1) {\n\t\tif (logger.isLoggable(Level.FINEST)) {\n\t\t\tString msgStr = formatObject(parameterizedMsg, param1, null);\n\t\t\tlogger.finest(msgStr);\n\t\t}\n\t}\n\n\tpublic void trace(Object parameterizedMsg, Object param1, Object param2) {\n\t\tString msgStr = formatObject(parameterizedMsg, param1, param2);\n\t\tlogger.finest(msgStr);\n\t}\n\n\tpublic void debug(Object parameterizedMsg, Object param1) {\n\t\tif (logger.isLoggable(Level.FINE)) {\n\t\t\tString msgStr = formatObject(parameterizedMsg, param1, null);\n\t\t\tlogger.fine(msgStr);\n\t\t}\n\t}\n\n\tpublic void debug(Object parameterizedMsg, Object param1, Object param2) {\n\t\tString msgStr = formatObject(parameterizedMsg, param1, param2);\n\t\tlogger.fine(msgStr);\n\t}\n\n\tpublic void info(Object parameterizedMsg, Object param1) {\n\t\tif (logger.isLoggable(Level.INFO)) {\n\t\t\tString msgStr = (String) parameterizedMsg;\n\t\t\tmsgStr = MessageFormatter.format(msgStr, param1);\n\t\t\tlogger.info(msgStr);\n\t\t}\n\t}\n\n\tpublic void info(Object parameterizedMsg, Object param1, Object param2) {\n\t\tString msgStr = formatObject(parameterizedMsg, param1, param2);\n\t\tlogger.info(msgStr);\n\t}\n\n\tpublic void warn(Object parameterizedMsg, Object param1) {\n\t\tif (logger.isLoggable(Level.WARNING)) {\n\t\t\tString msgStr = formatObject(parameterizedMsg, param1, null);\n\t\t\tlogger.warning(msgStr);\n\t\t}\n\t}\n\n\tpublic void warn(Object parameterizedMsg, Object param1, Object param2) {\n\t\tString msgStr = formatObject(parameterizedMsg, param1, param2);\n\t\tlogger.warning(msgStr);\n\t}\n\n\tpublic void error(Object parameterizedMsg, Object param1) {\n\t\tif (logger.isLoggable(Level.SEVERE)) {\n\t\t\tString msgStr = formatObject(parameterizedMsg, param1, null);\n\t\t\tlogger.severe(msgStr);\n\t\t}\n\t}\n\n\tpublic void error(Object parameterizedMsg, Object param1, Object param2) {\n\t\tString msgStr = formatObject(parameterizedMsg, param1, param2);\n\t\tlogger.severe(msgStr);\n\t}\n\n\tpublic void fatal(Object parameterizedMsg, Object param1) {\n\t\tif (logger.isLoggable(Level.SEVERE)) {\n\t\t\tString msgStr = formatObject(parameterizedMsg, param1, null);\n\t\t\tlogger.severe(msgStr);\n\t\t}\n\t}\n\n\tpublic void fatal(Object parameterizedMsg, Object param1, Object param2) {\n\t\tString msgStr = formatObject(parameterizedMsg, param1, param2);\n\t\tlogger.severe(msgStr);\n\t}\n\n\tpublic boolean isDebugEnabled() {\n\t\treturn logger.isLoggable(Level.FINE);\n\t}\n\n\tpublic boolean isErrorEnabled() {\n\t\treturn logger.isLoggable(Level.SEVERE);\n\t}\n\n\tpublic boolean isFatalEnabled() {\n\t\treturn logger.isLoggable(Level.SEVERE);\n\t}\n\n\tpublic boolean isInfoEnabled() {\n\t\treturn logger.isLoggable(Level.INFO);\n\t}\n\n\tpublic boolean isTraceEnabled() {\n\t\treturn logger.isLoggable(Level.FINEST);\n\t}\n\n\tpublic boolean isWarnEnabled() {\n\t\treturn logger.isLoggable(Level.WARNING);\n\t}\n\n\tpublic void trace(Object message) {\n\t\tlogger.finest(String.valueOf(message));\n\t}\n\n\tpublic void trace(Object message, Throwable t) {\n\t\tlogger.log(Level.FINEST, String.valueOf(message), t);\n\t}\n\n\tpublic void debug(Object message) {\n\t\tlogger.fine(String.valueOf(message));\n\n\t}\n\n\tpublic void debug(Object message, Throwable t) {\n\t\tlogger.log(Level.FINE, String.valueOf(message), t);\n\n\t}\n\n\tpublic void info(Object message) {\n\t\tlogger.info(String.valueOf(message));\n\n\t}\n\n\tpublic void info(Object message, Throwable t) {\n\t\tlogger.log(Level.INFO, String.valueOf(message), t);\n\n\t}\n\n\tpublic void warn(Object message) {\n\t\tlogger.warning(String.valueOf(message));\n\n\t}\n\n\tpublic void warn(Object message, Throwable t) {\n\t\tlogger.log(Level.WARNING, String.valueOf(message), t);\n\n\t}\n\n\tpublic void error(Object message) {\n\t\tlogger.severe(String.valueOf(message));\n\n\t}\n\n\tpublic void error(Object message, Throwable t) {\n\t\tlogger.log(Level.SEVERE, String.valueOf(message), t);\n\t}\n\n\tpublic void fatal(Object message) {\n\t\tlogger.severe(String.valueOf(message));\n\n\t}\n\n\tpublic void fatal(Object message, Throwable t) {\n\t\tlogger.log(Level.SEVERE, String.valueOf(message), t);\n\n\t}\n\n}\n//End of class JDK14Logger", "attachment_id": null, "bug_id": 34185, "id": 72872, "time": "2005-03-25T22:06:27Z", "creator": "boris.unckel.mlg@gmx.net", "creation_time": "2005-03-25T22:06:27Z", "is_private": false}, {"count": 1, "text": "I dislike the word \"requirement\" in a Bugzilla issue ;(", "bug_id": 34185, "attachment_id": null, "id": 72873, "time": "2005-03-25T22:14:21Z", "creator": "yoavs@computer.org", "creation_time": "2005-03-25T22:14:21Z", "tags": [], "is_private": false}, {"count": 2, "tags": [], "creator": "rdonkin@apache.org", "attachment_id": null, "id": 72875, "time": "2005-03-25T22:40:54Z", "bug_id": 34185, "creation_time": "2005-03-25T22:40:54Z", "is_private": false, "text": "FWIW issues like this have been discussed at length on the jakarta commons list.\nI thought it might save a little time if I were to point out the tricky bit of\nany JCL redesign.\n\nThe key design mistake made when JCL was created was not the much-malined\ndynamic discovery mechanism, it was the fact that LogFactory is too tightly\ncoupled to the discovery mechanism. It would be possible to extract an interface\nmodelled as an abstract superclass containing the user-facing API from\nLogFactory and retrofit a minimal implementation lookup mechanism with no\ncomplex discovery. This would allow refitting of new binding mechanisms whilst\nmaintaining backwards compatibility. \n\nHad the storm not blown up about the current JCL implementation, this was the\ndirection which the JCL2 codebase would have taken. "}, {"count": 3, "text": "Hmmm....\n\nI mentioned something very similar, only exactly opposite, in my email response\nto Simon Kitching.\n\nThis...\npublic interface ULogger extends org.apache.commons.logging.Log\n\nBecomes this...\npublic interface org.apache.commons.logging.Log extends ULogger\n\n\nIt doesn't make sense for a logging implementation which commons-logging wraps,\nsuch as Log4j, to have a dependency on commons-logging itself, which it would by\nits implementation of UGLI.  Having commons-logging implement UGLI (or whatever\nname it ends up as) also solves an issue with coordination of projects.  Simon\nKitching mentioned that it will be 2 or 3 months before JCL 2.0 becomes more\nthan an idea.  UGLI exists now, Log4j implements it, and Log4j-1.3 is\ntentatively scheduled to be released around the time where JCL 2.0 will be just\ngetting off the ground.  The JCL team also has requirements such as backward\ncompatibility and the extension of their own API with new functionality.  If we\ncan all agree on a base logging API, then everyone can simply agree to implement\nit and take as much time as they want.  Existing API's shouldn't have to change\nmuch (if at all) and extention of the API's can be done at will.\n\nA change like this would allow commons-logging users the option to either\ncontinue to use the JCL API or move to the UGLI API.  In the case where they\nchoose the UGLI API, they can choose any implementation that implements the UGLI\nAPI, including Log4j, JCL, NOP, Simple, and even choose an UGLI wrapper such as\nthe UGLI JUL wrapper implementation.  All API's become compatible and users can\nchoose which implementation of UGLI meets their needs the best.  I don't think\nanyone loses here.\n\nUGLI can stay \"UGLI\" or become something like \"Apache Logging API, or \"ALAPI\". \nWhatever name is chosen, the point is that its interface becomes the standard\nfor everyone.\n\nThoughts?\n\n\nJake", "bug_id": 34185, "attachment_id": null, "id": 72884, "time": "2005-03-26T05:43:45Z", "creator": "hoju@visi.com", "creation_time": "2005-03-26T05:43:45Z", "tags": [], "is_private": false}, {"count": 4, "tags": [], "text": "(In reply to comment #3)\n> I mentioned something very similar, only exactly opposite, in my email response\n> to Simon Kitching.\nYes, I have read that mail.\n> This...\n> public interface ULogger extends org.apache.commons.logging.Log\n> \n> Becomes this...\n> public interface org.apache.commons.logging.Log extends ULogger\n> \n> \n> It doesn't make sense for a logging implementation which commons-logging wraps,\n> such as Log4j, to have a dependency on commons-logging itself, which it would by\n> its implementation of UGLI.  \nI think one has to small steps, even for getting acceptance. UGLI is out as\nalpha. UGLI (or better log4j 1.3) introduce multiple jars (I know that solves\nproblems and is a good idea, but for users this is a eye-catching change), and\nusers have to code different to use it. I think it should be no problem to\npackage the interface (not the whole JCL) with log4j. \nFor me UGLI is an wrapper, and it will be wide spread due to the popularity of\nlog4j. Once introduced it will be hard to change.\nTo have an interim solution JCL's Factory could be changed to the static binding\nand an configuration only (without classloading isues) lookup.\n\n\n\n>Having commons-logging implement UGLI (or whatever\n> name it ends up as) also solves an issue with coordination of projects.  \nSounds not like a win-win to me. \n> Simon\n> Kitching mentioned that it will be 2 or 3 months before JCL 2.0 becomes more\n> than an idea.  \nWhat kind of feature should JCL 2.0 offer, if it is done like you described?\nJust my first impression, I still want to disuss factually: JCL==YAUGLI, yet\nanother...\n> UGLI exists now, Log4j implements it, and Log4j-1.3 is\nJCL exists now, Wrappers are existing, major applications use it.\n\n> tentatively scheduled to be released around the time where JCL 2.0 will be just\n> getting off the ground.  \nYes, correct, so we there is a need to get ideas to solve this time gap.\n> The JCL team also has requirements such as backward\n> compatibility and the extension of their own API with new functionality.  \nUGLI has no backward compatibility issues and contains new functionality.\n> If we\n> can all agree on a base logging API, then everyone can simply agree to implement\n> it and take as much time as they want.  Existing API's shouldn't have to change\n> much (if at all) and extention of the API's can be done at will.\n\n\n\n> A change like this would allow commons-logging users the option to either\nSorry, maybe I am not wide awake - what is \"this\"? Your proposal or the demo code?\n\n> continue to use the JCL API or move to the UGLI API.  In the case where they\n> choose the UGLI API, they can choose any implementation that implements the UGLI\n> API, including Log4j, JCL, NOP, Simple, and even choose an UGLI wrapper such as\n> the UGLI JUL wrapper implementation.  \nThe idea of wrapping and having the choice is the major goal of JCL and main\nsuccesing feature.\n\nThe demo code should just show how less change in UGLI is necessary to become an\nintegration of JCL. Next changes have to be done in JCL.\n\n\nBoris", "attachment_id": null, "bug_id": 34185, "id": 72886, "time": "2005-03-26T08:21:56Z", "creator": "boris.unckel.mlg@gmx.net", "creation_time": "2005-03-26T08:21:56Z", "is_private": false}, {"count": 5, "tags": [], "creator": "boris.unckel.mlg@gmx.net", "attachment_id": 14568, "id": 72892, "time": "2005-03-26T11:09:08Z", "bug_id": 34185, "creation_time": "2005-03-26T11:09:08Z", "is_private": false, "text": "Created attachment 14568\nUgliFactory extends org.apache.commons.logging.LogFactory.LogFactory\n\nThis factory whould implement a backward compatible version of the JCL\nLogFactory.\nIf one is convinced this could be the default Factory for JCL. All\nconfiguration issues would occur at Ugli. This also could be a migration path.\n\nIt depends on ULogger extends org.apache.commons.logging.Log as published in\nthis Bugzilla.\n\nComments?"}, {"count": 6, "tags": [], "creator": "rdonkin@apache.org", "text": "FWIW \n\nI've analysed these issues in depth and believe that subclassing will not prove\neffective due to the coupling problems I indicated above. A better path would be\nto extract an abstract superclass as part of JCL and subclass that instead. JCL\nwill probably go down this route in any case. \n\n\n", "id": 72893, "attachment_id": null, "bug_id": 34185, "creation_time": "2005-03-26T11:19:46Z", "time": "2005-03-26T11:19:46Z", "is_private": false}, {"count": 7, "text": "I thought an example would be useful :)\n\nSo, I've create a branch in jakarta/commons/logging called DON_QUIXOTE and added\nsome example code into their. This lifts off a superclass called LogManager (for\nno very good reason) from LogFactory. The most common user method (getLog) is\nrewired so that it first calls the superclass. When LogFactory is in the same\nclassloader (ideally in the same jar) as LogManager, the call will be routed\nthrough LogFactory. This preserves backwards compatibility.\n\nThis is the way that Richard and I saw JCL2 proceeding.\n\nAn option which you may want to consider is compile-time statically binding an\nalternative LogManager implementation to UGLI. This (I believe) would in line\nwith the spirit of the UGLI way whilst also ensure no actual core dependencies\neither way.\n\nIf anyone feels this sounds like a reasonable approach and would like to take a\nlook at creating some experimental implementation code along those lines, I'd be\nglad to review it for possible inclusion in the branch. \n\nI'm don't intend to particularly push this solution (UGLI is the responsibility\nof others) but I think it's important that all possible solutions are considered.\n\nRobert", "bug_id": 34185, "is_private": false, "id": 73160, "time": "2005-03-31T22:44:18Z", "creator": "rdonkin@apache.org", "creation_time": "2005-03-31T22:44:18Z", "tags": [], "attachment_id": null}, {"count": 8, "tags": [], "text": "UGLI development has been moved to http://www.slf4j.org.", "is_private": false, "bug_id": 34185, "id": 74763, "time": "2005-05-12T06:04:49Z", "creator": "carnold@apache.org", "creation_time": "2005-05-12T06:04:49Z", "attachment_id": null}]