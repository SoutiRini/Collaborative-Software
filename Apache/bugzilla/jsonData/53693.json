[{"count": 0, "tags": [], "creator": "xyntrix@bitz.org", "text": "https://gist.github.com/3318709\n\n\nI wrote a simple PHP script to simulate activity (sleep for 500ms).  I set up a vhost to handle PHP requests via mod_fcgid. I \n- used PHP5.2, PHP5.3, PHP5.4 -- doesn't seem to matter. \n- used the latest trunk snapshot of mod_fcgid (2.3.8), and that didn't change behavior \n- used Apache 2.2.22 (and 2.2.17) with both worker and prefork mpms\n- httpd is configured with 512 StartServers and at least 1024 MaxClients\n\nTrying to figure out how to prevent serialized blocking of requests  in mod_fcgid.\n\nWhat seems to happen is mod_fcgid on initial process spin-up won't tune the number of available of child processes to handle the concurrent request load..  there is a serialization that occurs.  I have tried turning a number of the spawn parameters to try to spin up more at once.. and I can't seem to make it happen.\n\nSo here's an extreme case of 100 concurrent clients with 1 requests to be made, each:\n\nConcurrency Level:      100\nTime taken for tests:   5.672 seconds\nComplete requests:      100\nFailed requests:        0\nWrite errors:           0\nTotal transferred:      15600 bytes\nHTML transferred:       0 bytes\nRequests per second:    17.63 [#/sec] (mean)\nTime per request:       5671.918 [ms] (mean)\nTime per request:       56.719 [ms] (mean, across all concurrent requests)\nTransfer rate:          2.69 [Kbytes/sec] received\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        4    8   2.1      8      10\nProcessing:   614 2956 1604.2   2665    5661\nWaiting:      614 2956 1604.2   2664    5661\nTotal:        618 2963 1604.1   2674    5671\n\nPercentage of the requests served within a certain time (ms)\n  50%   2674\n  66%   3612\n  75%   4540\n  80%   4627\n  90%   5633\n  95%   5634\n  98%   5668\n  99%   5671\n 100%   5671 (longest request)\n\n\nThe process spin up for this over time looks like:\nFri Aug 10 16:37:19 MST 2012\nUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\napache    3571  0.0  0.3  57004  8040 ?        R    16:37   0:00 /usr/bin/php-cgi\napache    3572  0.0  0.4  57132  8412 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3573  0.0  0.4  57132  8412 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3574  0.0  0.4  57132  8412 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3575  0.0  0.3  56872  7928 ?        R    16:37   0:00 /usr/bin/php-cgi\napache    3576  0.0  0.3  56872  7832 ?        R    16:37   0:00 /usr/bin/php-cgi\napache    3577  0.0  0.3  56872  7868 ?        R    16:37   0:00 /usr/bin/php-cgi\napache    3578  0.0  0.3  56744  7808 ?        R    16:37   0:00 /usr/bin/php-cgi\napache    3580  0.0  0.0   8112   384 ?        R    16:37   0:00 /usr/bin/php-cgi\n10\nFri Aug 10 16:37:19 MST 2012\nFri Aug 10 16:37:19 MST 2012\nUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\napache    3571  6.0  0.4  57132  8412 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3572  5.0  0.4  57132  8412 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3573  6.0  0.4  57132  8412 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3574  5.0  0.4  57132  8412 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3575  6.0  0.4  57132  8412 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3576  6.0  0.4  57132  8416 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3577  6.0  0.4  57132  8412 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3578  6.0  0.4  57132  8416 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3580  6.0  0.4  57132  8416 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3582  5.0  0.4  57132  8408 ?        S    16:37   0:00 /usr/bin/php-cgi\n10\nFri Aug 10 16:37:19 MST 2012\nFri Aug 10 16:37:19 MST 2012\nUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\napache    3571  6.0  0.4  57132  8412 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3572  5.0  0.4  57132  8412 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3573  6.0  0.4  57132  8412 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3574  5.0  0.4  57132  8412 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3575  6.0  0.4  57132  8412 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3576  6.0  0.4  57132  8416 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3577  6.0  0.4  57132  8412 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3578  6.0  0.4  57132  8416 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3580  6.0  0.4  57132  8416 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3582  5.0  0.4  57132  8408 ?        S    16:37   0:00 /usr/bin/php-cgi\n10\nFri Aug 10 16:37:19 MST 2012\nFri Aug 10 16:37:19 MST 2012\nUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\napache    3571  6.0  0.4  57132  8412 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3572  5.0  0.4  57132  8412 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3573  6.0  0.4  57132  8412 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3574  5.0  0.4  57132  8412 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3575  6.0  0.4  57132  8412 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3576  6.0  0.4  57132  8416 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3577  6.0  0.4  57132  8412 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3578  6.0  0.4  57132  8416 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3580  6.0  0.4  57132  8416 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3582  5.0  0.4  57132  8408 ?        S    16:37   0:00 /usr/bin/php-cgi\n10\nFri Aug 10 16:37:19 MST 2012\n...\nFri Aug 10 16:37:23 MST 2012\nUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\napache    3571  1.2  0.4  57132  8480 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3572  1.0  0.4  57132  8480 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3573  1.2  0.4  57132  8480 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3574  1.2  0.4  57132  8480 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3575  1.2  0.4  57132  8480 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3576  1.2  0.4  57132  8484 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3577  1.2  0.4  57132  8480 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3578  1.2  0.4  57132  8484 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3580  1.2  0.4  57132  8484 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3582  1.0  0.4  57132  8476 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3657  1.5  0.4  57132  8484 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3706  2.0  0.4  57132  8480 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3760  3.5  0.4  57132  8480 ?        S    16:37   0:00 /usr/bin/php-cgi\napache    3816  6.0  0.4  57132  8408 ?        S    16:37   0:00 /usr/bin/php-cgi\n14\n\nIt takes at least 4 seconds to spin up to 14 processes (well under our concurrent connection limit). \n\nOn a very small scale, I ran some tests to simulate this:\n\ntest.php script:\n\nusleep(500000);\necho $_SERVER['SCRIPT_FILENAME'].\" :: \".$_SERVER['SERVER_NAME'];\n\nWith this script, each run should take ~500ms plus some very minor overhead.\n\no Loaded Apache with the worker MPM.. Used ab concurrency level of 2, feeding 10 requests, we see a bottleneck due to this serialization:\n\nConcurrency Level:      2\nTime taken for tests:   3.116 seconds\nComplete requests:      10\nFailed requests:        0\nWrite errors:           0\nTotal transferred:      1560 bytes\nHTML transferred:       0 bytes\nRequests per second:    3.21 [#/sec] (mean)\nTime per request:       623.257 [ms] (mean)\nTime per request:       311.628 [ms] (mean, across all concurrent requests)\nTransfer rate:          0.49 [Kbytes/sec] received\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        3    3   0.2      3       3\nProcessing:   504  619 336.6    505    1574\nWaiting:      504  619 336.6    505    1574\nTotal:        507  622 336.6    508    1577\n\nPercentage of the requests served within a certain time (ms)\n  50%    508\n  66%    508\n  75%    508\n  80%    577\n  90%   1577\n  95%   1577\n  98%   1577\n  99%   1577\n 100%   1577 (longest request)\n\no Once the processes are spun up however, we see 500ms (+~10ms overhead) for all requests as long as our concurrency does not exceed the number of child processes available\n\nUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\napache   30209  0.0  0.4  57132  8488 ?        S    15:30   0:00 /usr/bin/php-cgi\napache   30214  0.0  0.4  57132  8480 ?        S    15:30   0:00 /usr/bin/php-cgi\n\n\nConcurrency Level:      2\nTime taken for tests:   2.546 seconds\nComplete requests:      10\nFailed requests:        0\nWrite errors:           0\nTotal transferred:      1560 bytes\nHTML transferred:       0 bytes\nRequests per second:    3.93 [#/sec] (mean)\nTime per request:       509.200 [ms] (mean)\nTime per request:       254.600 [ms] (mean, across all concurrent requests)\nTransfer rate:          0.60 [Kbytes/sec] received\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        3    3   0.1      3       3\nProcessing:   504  506   1.7    505     509\nWaiting:      504  506   1.7    505     509\nTotal:        507  508   1.7    508     512\n\nPercentage of the requests served within a certain time (ms)\n  50%    508\n  66%    509\n  75%    509\n  80%    511\n  90%    512\n  95%    512\n  98%    512\n  99%    512\n 100%    512 (longest request)\n\no Adding +1 concurrency level (taking concurrency to 3), we produce a serializing bottleneck again:\n\nUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\napache   30209  0.0  0.4  57132  8488 ?        S    15:30   0:00 /usr/bin/php-cgi\napache   30214  0.0  0.4  57132  8484 ?        S    15:30   0:00 /usr/bin/php-cgi\napache   31866  1.2  0.4  57132  8488 ?        S    15:34   0:00 /usr/bin/php-cgi\n\nConcurrency Level:      3\nTime taken for tests:   2.083 seconds\nComplete requests:      10\nFailed requests:        0\nWrite errors:           0\nTotal transferred:      1560 bytes\nHTML transferred:       0 bytes\nRequests per second:    4.80 [#/sec] (mean)\nTime per request:       625.025 [ms] (mean)\nTime per request:       208.342 [ms] (mean, across all concurrent requests)\nTransfer rate:          0.73 [Kbytes/sec] received\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        3    3   0.2      3       3\nProcessing:   504  612 337.9    505    1573\nWaiting:      504  612 337.9    505    1573\nTotal:        507  615 337.9    508    1576\n\nPercentage of the requests served within a certain time (ms)\n  50%    508\n  66%    508\n  75%    508\n  80%    509\n  90%   1576\n  95%   1576\n  98%   1576\n  99%   1576\n 100%   1576 (longest request)\n\no And again, at 3 concurrency since 3 already spun up processes, no bottleneck:\n\nUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\napache   30209  0.0  0.4  57132  8488 ?        S    15:30   0:00 /usr/bin/php-cgi\napache   30214  0.0  0.4  57132  8484 ?        S    15:30   0:00 /usr/bin/php-cgi\napache   31866  1.2  0.4  57132  8488 ?        S    15:34   0:00 /usr/bin/php-cgi\n\n\nConcurrency Level:      3\nTime taken for tests:   2.032 seconds\nComplete requests:      10\nFailed requests:        0\nWrite errors:           0\nTotal transferred:      1716 bytes\nHTML transferred:       0 bytes\nRequests per second:    4.92 [#/sec] (mean)\nTime per request:       609.480 [ms] (mean)\nTime per request:       203.160 [ms] (mean, across all concurrent requests)\nTransfer rate:          0.82 [Kbytes/sec] received\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        3    3   0.2      3       3\nProcessing:   504  505   0.5    505     506\nWaiting:      504  505   0.5    505     506\nTotal:        507  508   0.5    508     508\n\nPercentage of the requests served within a certain time (ms)\n  50%    508\n  66%    508\n  75%    508\n  80%    508\n  90%    508\n  95%    508\n  98%    508\n  99%    508\n 100%    508 (longest request)", "id": 161248, "time": "2012-08-10T23:47:40Z", "bug_id": 53693, "creation_time": "2012-08-10T23:47:40Z", "is_private": false, "attachment_id": null}, {"count": 1, "tags": [], "bug_id": 53693, "attachment_id": null, "id": 161385, "time": "2012-08-14T17:44:48Z", "creator": "xyntrix@bitz.org", "creation_time": "2012-08-14T17:44:48Z", "is_private": false, "text": "This might be related to enhancement submission:\n\nhttps://issues.apache.org/bugzilla/show_bug.cgi?id=52174"}, {"count": 2, "tags": [], "creator": "xyntrix@bitz.org", "attachment_id": null, "text": "I tried changing in modules/fcgid/fcgid_bridge.c,\n\n\n           /* Avoid sleeping the very first time through if there are no\n               busy processes; the problem is just that we haven't spawned\n               anything yet, so waiting is pointless */\n            if (i > 0 || j > 0 || count_busy_processes(r, &fcgi_request)) {\n                apr_sleep(apr_time_from_sec(1));\n\n\nto\n\n\n           if (i > 0 || j > 0 || count_busy_processes(r, &fcgi_request)) {\n                apr_sleep(apr_time_from_sec(0));\n\n\nand the serialization block seems to have stopped.\n\nIs this meant to just be an artificial anti-thrashing mechanism? \n\nIf so, is there a better way I can prevent too many processes for trying to spin up concurrently, than adding in this 1s time delay?  The 1s delay totally kills concurrent requests.", "id": 161394, "time": "2012-08-14T19:51:07Z", "bug_id": 53693, "creation_time": "2012-08-14T19:51:07Z", "is_private": false}, {"count": 3, "tags": [], "creator": "dominic.benson@thirdlight.com", "attachment_id": 29233, "text": "Created attachment 29233\nSpawn faster under low process count\n\nThe principle of not rushing into trying to spawn new processes is good: indeed in the case that we're running at max processes per class, it is the only thing that gives time to try to handle the actual requests (rather than spinning on the server). However, 1s is a very long time, and we're doing it if *any* process is currently busy. As a minimum, FcgidMinProcessesPerClass should be considered - under that level, we should be perfectly happy to launch a new process to handle a request. \nAlso, if launching another process is a plausible thing to do (i.e. we're below the limit), we shouldn't wait 1s before re-checking: requests should be being handled a lot more quickly than that. So instead, wait 250ms by default.\nThis patch is based in principle around high/low water marks for process count; at this point, these are just min and max processes per class. Picking figures between these would be better, but these should probably be configurable.", "id": 161399, "time": "2012-08-14T21:44:46Z", "bug_id": 53693, "creation_time": "2012-08-14T21:44:46Z", "is_private": false}, {"count": 4, "tags": [], "bug_id": 53693, "attachment_id": null, "id": 161412, "time": "2012-08-15T08:55:31Z", "creator": "dominic.benson@thirdlight.com", "creation_time": "2012-08-15T08:55:31Z", "is_private": false, "text": "Adjusted title slightly to reflect what the OP correctly noted: that the problem is that requests that can't immediately be handled be an existing process are delayed by 1s (excepting when there are no busy processes at all).\n\nSee also the comments in my patch: ultimately, additional tunables are called for, but adding options isn't something to be done lightly (given the doc impact), and certainly warrants some thought. Possibly explicit high/low, or a target process count, and possibly a configurable delay could be used - or some/all of these values could be generated at startup based on the bounds specified by existing options."}, {"count": 5, "tags": [], "text": "a fix is commited to trunk r1377398\nNew protocol to avoid too much sleep, improve performance while stress testing\n1. procmgr_send_spawn_cmd() now return a status code from PM, so process handler now know the spawn request is denyed or not.\n2. if a new process is created, no sleep is needed.\n3. if no process is created, sleep a while", "attachment_id": null, "bug_id": 53693, "id": 161704, "time": "2012-08-26T09:36:17Z", "creator": "panqingfeng@gmail.com", "creation_time": "2012-08-26T09:36:17Z", "is_private": false}, {"count": 6, "tags": [], "creator": "trawick@apache.org", "attachment_id": null, "text": "Ryan Pan's fix for this bug (and a couple of follow-on fixes) was reverted with http://svn.apache.org/r1529061 due to issues encountered with testing the proposal for mod_fcgid 2.3.8, which could not be released.\n\nRelated discussion is in this mailing list thread:\n\nhttp://mail-archives.apache.org/mod_mbox/httpd-dev/201309.mbox/browser\n\nNote that at the same time a separate Windows-specific bug could result in more processes than necessary.  That didn't affect other platforms and didn't explain all the bad symptoms encountered in Steffen's Windows setup.", "id": 170483, "time": "2013-10-08T11:23:18Z", "bug_id": 53693, "creation_time": "2013-10-08T11:23:18Z", "is_private": false}, {"count": 7, "tags": [], "bug_id": 53693, "text": "Any news on this bug?\n\nWhy is lowering the sleep from 1s to f.e. 50ms not a solution?", "id": 180031, "time": "2014-12-26T20:53:21Z", "creator": "stefan@priebe.ws", "creation_time": "2014-12-26T20:53:21Z", "is_private": false, "attachment_id": null}, {"count": 8, "tags": [], "text": "Created attachment 35611\nRewrite handle_request in fcgid_bridge.c to fix 1sec delay\n\nI rewrote the handle_request in fcgid_bridge.c to fix 1 sec delay issue.\nThe original situation would wait 1 second before trying to aquire a process and then spawn one.\n\nThis has the drawback of creating 'sluggisch' feel on low traffic sites which make use of ajax calls (parrallel requests). If there is only one process available the parallel ajax request will be delayed by a second. After the second that one process will be probably free, so the request will be handled and no new process will be spawned. As a result the next request will behave exactly the same, with the same 1 sec delay because it takes more requests to actually spawn a new process.\n\nThis rewrite will throw the one second delay out of the window. It will check more often if a process is available and it will try less often to spawn a new process.\n\nThe original code would take 64 seconds of trying before it gave up and a HTTP_SERVICE_UNAVAILABLE was returned. My new code takes 60.8 seconds for this to happen, but what happens during this time is much different.\n\nOriginal:\n64000ms (64x spawn attempts, 128 process apply attempts)\n\nNew:\n60800ms (8x spawn attempts, 148 process apply attempts)\n\nBut where the old code was linear, it would just check every second, the new code is not.\nThis table will show the spawn attempts and the process apply attempts. There are 8 spawn attempts. and for each spawn attempt a number of process apply attempts is done. The time between these attempts also differs, small waits at the beginning (and end) and long waits in the middle.\n\n           0) 2  x  50ms =   100ms\n           1) 8  x 200ms =  1600ms\n           2) 14 x 350ms =  4900ms\n           3) 20 x 500ms = 10000ms\n           4) 26 x 650ms = 16900ms\n           5) 26 x 500ms = 13000ms\n           6) 26 x 350ms =  9100ms\n           7) 26 x 200ms =  5200ms\n\nShortening the waits at the end will prevent long waiting requests to starve and hopefully allow less HTTP_SERVICE_UNAVAILABLE when there is a short peak/overload on the server.\n\nWe are using this patch in production for two months now after a three month test period. Both on servers with single high load sites and with low load small sites.", "attachment_id": 35611, "bug_id": 53693, "id": 202777, "time": "2017-12-14T11:29:34Z", "creator": "merijnvdk@apache.org", "creation_time": "2017-12-14T11:29:34Z", "is_private": false}, {"attachment_id": null, "tags": [], "bug_id": 53693, "is_private": false, "count": 9, "id": 202779, "time": "2017-12-14T11:40:48Z", "creator": "merijnvdk@apache.org", "creation_time": "2017-12-14T11:40:48Z", "text": "*** Bug 56308 has been marked as a duplicate of this bug. ***"}, {"count": 10, "tags": [], "text": "*** Bug 56719 has been marked as a duplicate of this bug. ***", "attachment_id": null, "bug_id": 53693, "id": 202781, "time": "2017-12-14T11:42:51Z", "creator": "merijnvdk@apache.org", "creation_time": "2017-12-14T11:42:51Z", "is_private": false}]