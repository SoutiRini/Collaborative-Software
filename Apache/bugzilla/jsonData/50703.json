[{"count": 0, "text": "Created attachment 26590\nproposed patch\n\nAttached patch parametrizes fop.fo.properties.PropertyCache.\nAs a result, all the different public fetch() overloads can be rolled into one, and suddenly this class seems to have the potential for more general usage. Any class offering reliable implementations for equals() and hashCode() is now a candidate to store its canonical instances in the cache.\n\nThe idiom becomes:\n\nPropertyCache<Type> cache = new PropertyCache<Type>(Type.class);\n\nThe constructor parameter is still needed, as I could not immediately find a way to derive the class name (for debugging) from the type parameter. Don't know if there even is one... At any rate, the correspondence between constructor and type parameter is enforced by the constructor, so it would not be possible to write:\n\nnew PropertyCache<TypeA>(TypeB.class)\n\nnot even if TypeB is a subclass of TypeA.\n\nIf I judge correctly, applying this patch by itself should, at worst, cause a few unchecked warnings to pop up in the fo.properties package. Locally, I have already adapted all the properties that use it (and added a few new classes), but I kept these changes out of the patch for now, to focus on the main change.\n\nSuggestions welcome. Would it be useful outside of the fo.properties package as well? Could it migrate to fop.util?", "bug_id": 50703, "is_private": false, "id": 143873, "time": "2011-02-01T16:49:55Z", "creator": "adelmelle@apache.org", "creation_time": "2011-02-01T16:49:55Z", "tags": [], "attachment_id": 26590}, {"count": 1, "tags": [], "bug_id": 50703, "is_private": false, "text": "Makes sense.\n\nNot sure that's what you're looking for but you can add this to PropertyCache:\n\n    public static <T> PropertyCache<T> createFor(Class<T> c) {\n        return new PropertyCache<T>(c);\n    }\n\nThen later:\n\n    private static final PropertyCache<FontFamilyProperty> CACHE\n        = PropertyCache.createFor(FontFamilyProperty.class);\n\nI don't think it makes sense to move out PropertyCache just yet. I wouldn't do this before we have another use case outside that package.", "id": 143887, "time": "2011-02-02T03:20:24Z", "creator": "jeremias@apache.org", "creation_time": "2011-02-02T03:20:24Z", "attachment_id": null}, {"count": 2, "tags": [], "bug_id": 50703, "attachment_id": null, "is_private": false, "id": 143927, "time": "2011-02-02T15:58:50Z", "creator": "adelmelle@apache.org", "creation_time": "2011-02-02T15:58:50Z", "text": "\n> Not sure that's what you're looking for but you can add this to PropertyCache:\n> \n>     public static <T> PropertyCache<T> createFor(Class<T> c) {\n>         return new PropertyCache<T>(c);\n>     }\n\nGood suggestion. That would at least slightly shorten the creation statements in the various property classes.\n\nComes very close, but what I was actually looking for was a way to leave out the constructor parameter completely, and in the constructor, infer the Class from the type parameter T, so something in the direction of\n\n  this.runtimeType = T.class;\n\nQuite impossible, obviously, given the implementation of generics. In the end, T only exists for the compiler...\n\nThe idiom would then just be very standard:\n  PropertyCache<FontFamilyProperty> CACHE\n    = new PropertyCache<FontFamilyProperty>();\n\n(and as of Java 7, IIC, even more concise:\n  PropertyCache<FontFamilyProperty> CACHE = new PropertyCache<>();\n)\n\nThe more I think about it, the more I am tempted to go for just dropping the parameter, or maybe providing it only as an alternate constructor. Ultimately, it's only use is for debugging. I had added this, but must admit, I have never really used it..."}, {"count": 3, "tags": [], "bug_id": 50703, "attachment_id": null, "text": "This suggested change on PropertyCache was included in #46962\nhttp://svn.apache.org/viewvc?rev=1303891&view=rev", "id": 155242, "time": "2012-03-22T18:44:59Z", "creator": "alex.giotis@gmail.com", "creation_time": "2012-03-22T18:44:59Z", "is_private": false}]