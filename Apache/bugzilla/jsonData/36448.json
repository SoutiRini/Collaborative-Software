[{"count": 0, "tags": [], "bug_id": 36448, "attachment_id": null, "id": 79249, "time": "2005-08-31T21:01:29Z", "creator": "vahe.khachikyan@siemens.com", "creation_time": "2005-08-31T21:01:29Z", "is_private": false, "text": "In reverse proxy configuration mod_proxy hangs if it encounters a buggy backend\nwhich sends a 100 Continue header after an 200 OK or some other response other\nthan 100. There is some versions of IIS which send 100 Continue after they\nsuccessfully sent the 200 OK with content. The 100 Continue header field hangs\nthen around somewhere in TCP stack. \n\nDuring next request if Keep-Alive is used, mod_proxy tries to reuse the socket,\nand tries to ensure that the socket can be reused. For this it tries to read one\nbyte from the socket and checks the return status to see if it was EOS.\n\nHmmm. what happens with the buggy IIS servers behaving as described above is\nfollowing: \nOne byte read returns really one byte 'H' from HTTP/1.1 100 Continue and the\nrest \"TTP/1.1 100 Continue\" stays in the TCP stack. Now mod_proxy reuses the\nsocket and sends new request. When it tries to read the response \"TTP/1.1 100\nContinue\" is read and the rest of processing goes foo bar. Finally it hangs then\nsomewhere in the poll untill the poll returns with timeout. After coming back\nfrom timeout (approx 2 minutes) it packs the rest of the response headers as a\ncontent and sends it to client browser/(upper proxy in the chain).\n\nBelow is a patch which seams to solve this problem.\n*** proxy_http.c_orig   Wed Aug 31 19:46:59 2005\n--- proxy_http.c        Wed Aug 31 19:52:26 2005\n***************\n*** 298,306 ****\n          socket_status = apr_recv(p_conn->sock, test_buffer, &buffer_len);\n          /* put back old timeout */\n          apr_socket_timeout_set(p_conn->sock, current_timeout);\n!         if ( APR_STATUS_IS_EOF(socket_status) ) {\n              ap_log_error(APLOG_MARK, APLOG_INFO, 0, NULL,\n!                          \"proxy: previous connection is closed, creating a new\nconnection.\");\n              new = 1;\n          }\n      }\n--- 298,306 ----\n          socket_status = apr_recv(p_conn->sock, test_buffer, &buffer_len);\n          /* put back old timeout */\n          apr_socket_timeout_set(p_conn->sock, current_timeout);\n!         if ( APR_STATUS_IS_EOF(socket_status) || buffer_len >0) {\n              ap_log_error(APLOG_MARK, APLOG_INFO, 0, NULL,\n!                          \"proxy: previous connection is closed or broken,\ncreating a new connection.\");\n              new = 1;\n          }\n      }"}, {"count": 1, "tags": [], "text": "\n \"There is some versions of IIS which send 100 Continue after they successfully \n  sent the 200 OK with content.\"\n\n Well, no pity for wholy violating the RFC; however I have to 100% agree with\n your patch since it adds further possible identification of proxy response\n splitting and other RFC violations(!)", "is_private": false, "id": 79470, "creator": "wrowe@apache.org", "time": "2005-09-07T01:56:58Z", "bug_id": 36448, "creation_time": "2005-09-07T01:56:58Z", "attachment_id": null}, {"count": 2, "text": "It's not *after* the last request, it's *before* the next request; it is \nlegitimate behaviour, try this patch:\n\nhttp://people.apache.org/~jorton/ap_proxy100.patch\n\n*** This bug has been marked as a duplicate of 16518 ***", "creator": "jorton@redhat.com", "is_private": false, "id": 79504, "time": "2005-09-07T11:59:19Z", "bug_id": 36448, "creation_time": "2005-09-07T11:59:19Z", "tags": [], "attachment_id": null}, {"count": 3, "tags": [], "bug_id": 36448, "attachment_id": null, "id": 79517, "time": "2005-09-07T13:46:34Z", "creator": "vahe.khachikyan@siemens.com", "creation_time": "2005-09-07T13:46:34Z", "is_private": false, "text": "(In reply to comment #2)\n> It's not *after* the last request, it's *before* the next request; it is \n> legitimate behaviour, try this patch:\n> \nI hope here is no missunderstanding, cause IMHO \"after\" or \"before\" it \ndoesn't metter! The same thing will hapen even if we imagine it is before.\nI say imagine because my ktrace shows exactly that the \"HTTP 100 Continue\"\nis in TCP stack before we even perform the write for next \"GET /blah blah...\"\n\n> http://people.apache.org/~jorton/ap_proxy100.patch\nI'll try your patch but I am afraid it can't solve this problem!\nTake a look at this snippest of ktrace\n-------------\n...\n 71228 httpd    CALL  read(0x18,0xbfbfe7af,0x1)\n 71228 httpd    GIO   fd 24 read 1 byte\n       \"H\"\n 71228 httpd    RET   read 1\n 71228 httpd    CALL  writev(0x18,0xbfbfe610,0x3)\n 71228 httpd    GIO   fd 24 wrote 1550 bytes\n       \"POST /Blah/blah.asmx HTTP/1.1\\r\n        Host: hostname.com\\r\n...\n...\n...\n 71228 httpd    RET   writev 1550/0x60e\n 71228 httpd    CALL  writev(0x18,0xbfbfe610,0x1)\n 71228 httpd    GIO   fd 24 wrote 429 bytes\n       \"<soap:Envelope xmlns:soap=\"\n....\n....\n....\n 71228 httpd    RET   writev 429/0x1ad\n 71228 httpd    CALL  read(0x18,0x81f6028,0x1f40)\n 71228 httpd    GIO   fd 24 read 24 bytes\n       \"TTP/1.1 100 Continue\\r\n        \\r\n       \"\n 71228 httpd    RET   read 24/0x18\n...\n----------------\nAnd the result of this last read \"TTP/1.1 100 Continue\" is what we later pass to \napr_date_checkmask() (code below and line numbers are from proxy_http.c 2.0.54)\n\n710       /* Is it an HTTP/1 response?\n711        * This is buggy if we ever see an HTTP/1.10\n712        */\n713        if (apr_date_checkmask(buffer, \"HTTP/#.# ###*\")) {\n...\nWe never come in to this if block! Instead we will land here which is \nplain wrong!\n...\n807        } else {\n808            /* an http/0.9 response */\n809            backasswards = 1;\n810            r->status = 200;\n811            r->status_line = \"200 OK\";\n812            p_conn->close += 1;\n813        }"}, {"count": 4, "tags": [], "bug_id": 36448, "attachment_id": null, "is_private": false, "id": 79518, "time": "2005-09-07T14:02:43Z", "creator": "jorton@redhat.com", "creation_time": "2005-09-07T14:02:43Z", "text": "That's interesting but not conclusive; it could just mean the proxy has failed\nto consume multiple 100 responses from the previous request on that connection\n(also quite valid).  ethereal/tcpdump (with -s0!) captures for both client/proxy\nand proxy/backend connection would be useful if you're sure that the server is\nreally issuing a 100 *after* a non-1xx response."}, {"count": 5, "tags": [], "text": "(In reply to comment #4)\n> That's interesting but not conclusive; it could just mean the proxy has failed\n> to consume multiple 100 responses from the previous request on that connection\n> (also quite valid).  ethereal/tcpdump (with -s0!) captures for both client/proxy\nAh OK that trace has surely also an earlier phase which looks like\n\n 71228 httpd    CALL  read(0x18,0x81f4028,0x1f40)\n 71228 httpd    GIO   fd 24 read 1658 bytes\n       \"HTTP/1.1 200 OK\\r\n...\n...\n 71228 httpd    RET   read 1658/0x67a\n\nthis is the last response from backend before the next POST mentioned\nin the trace in previous comment. I think there is no way of leaving \nsome content selectively in the TCP stack. And there is only one \nplace in the code proxy_http.c where one byte read is performed...\n\n> and proxy/backend connection would be useful if you're sure that the server is\n> really issuing a 100 *after* a non-1xx response.\nI am quite sure that the server does this! I had also the tcpdump traces for\nthis scenario. Reproducing this problem again is a quite time consuming task,\nhowever I'll attach the trace results when I come up with this test.\n", "is_private": false, "id": 79522, "creator": "vahe.khachikyan@siemens.com", "time": "2005-09-07T15:05:39Z", "bug_id": 36448, "creation_time": "2005-09-07T15:05:39Z", "attachment_id": null}, {"count": 6, "tags": [], "text": "> this is the last response from backend before the next POST mentioned\n> in the trace in previous comment. \nAnd I forgot to mention that this is the last read on fd 24 before the \nread which returns that one byte with \"H\"\n\n", "is_private": false, "id": 79523, "creator": "vahe.khachikyan@siemens.com", "time": "2005-09-07T15:14:05Z", "bug_id": 36448, "creation_time": "2005-09-07T15:14:05Z", "attachment_id": null}, {"count": 7, "tags": [], "creator": "wrowe@apache.org", "attachment_id": null, "text": "\n  Joe saiz \"It's not *after* the last request, it's *before* the next request; \n  it is legitimate behaviour...\"\n\n  Ah ha :)  However; it's invalid prior to a REQUEST being sent to the origin\n  server, no?  It would only be valid after the 2nd request was submitted\n  (e.g. HEAD - test resource, POST - transmit resource).\n\n  So if we did a look-ahead for any bytes to be read from the backend stream\n  before we sent the subsequent request, and saw lingering bytes (other than\n  perhaps redundant CR/LF pairs), then we could safely terminate the backend\n  proxy, presume it is poisioned, and begin the next request on another, new\n  connection.  If there were no bytes to be read from the backend, after we\n  consume a few extra/redundant CR/LF gaps, then we would trust the backend\n  had not split a response.\n\n  The 100 responses are only valid between the moment a request received, \n  and the final result code has been sent.  So Joe's right, it could be this\n  'extra' 100 continue is in response to the subsequent request.  But it's\n  altogether invalid as a 'keepalive indicator' between requests.\n", "id": 79561, "time": "2005-09-07T17:50:41Z", "bug_id": 36448, "creation_time": "2005-09-07T17:50:41Z", "is_private": false}, {"text": "> So Joe's right, it could be this\n>   'extra' 100 continue is in response to the subsequent request.  But it's\n>   altogether invalid as a 'keepalive indicator' between requests.\n\nYep! The 1xx is valid between the response and the final request but ^not^ after\nfinal response and ^before^ the subsequent request. At least this is my\nunderstanding of section 10.1 in rfc 2616.\n\nI am just wondering if there is a better way to check whether the socket\ncommunication is still alive without trying to read at least one byte from the\nsocket? IMHO there is no way of doing this at least not for the portable code?!\n\nAnother solution to this problem could be let say trying to read a byte and if\nit is read and is not EOS someway hand it over to the processing module, which\nwill assemble it together with the bytes read later. The advantage will be that\nwe will ^probably^ be able to reuse a keep-alive connection. Well but this\nadvantage seams to have a quite high price! I would vote for closing the\npoisoned socket and open a new one...", "tags": [], "creator": "vahe.khachikyan@siemens.com", "is_private": false, "count": 8, "id": 79580, "time": "2005-09-07T20:39:42Z", "bug_id": 36448, "creation_time": "2005-09-07T20:39:42Z", "attachment_id": null}, {"count": 9, "tags": [], "text": "Does this still happen in 2.2.8?", "is_private": false, "id": 112785, "creator": "nick@webthing.com", "time": "2008-01-12T12:08:27Z", "bug_id": 36448, "creation_time": "2008-01-12T12:08:27Z", "attachment_id": null}, {"count": 10, "tags": [], "text": "Assuming fixed in recent 2.2 versions.  Please reopen if I'm wrong.", "is_private": false, "id": 123526, "creator": "nick@webthing.com", "time": "2008-12-26T11:10:02Z", "bug_id": 36448, "creation_time": "2008-12-26T11:10:02Z", "attachment_id": null}]