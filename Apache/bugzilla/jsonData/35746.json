[{"count": 0, "tags": [], "bug_id": 35746, "attachment_id": null, "is_private": false, "id": 77310, "time": "2005-07-14T21:56:37Z", "creator": "quartz12h@yahoo.com", "creation_time": "2005-07-14T21:56:37Z", "text": "Hi,\nThe session manager should be able to age session by age, not by comparison to\nsystem time stamp.\n\nHere is a simple and working time tracker immune to time shifts.\nIt 'knows' it waited some amount of milliseconds. This cannot be hacked on any\nOS. Given that, the time arrow is maintained and session can be aged normally,\neven if system time changes on the server, which is more than probable on\nappliances and embed system.\n \nThat would prevent http session to expire and logout user prematurely.\nNote that upon the receiver update, 't2' is always the current time (now) and\n't1' is usually the last 't2' is no shift was detected.\n\n\npublic void run() {\n\tlong t1 = -1;\n\twhile(true) {\n\t\ttry {\n\t\t\tlong t2 = System.currentTimeMillis();\n\n\t\t\t//------ time shifting detection --------\n\t\t\tlong shift = 0;\n\t\t\tif(t1>0) { //if not first loop\n\t\t\t\tlong expected = t1+intervalMillis;\n\t\t\t\tshift = t2-expected;\n\t\t\t\tif(shift > timePositiveShiftTolerance) {\n\t\t\t\t\tvlogger.warn(\"Time shifted in future by more than positive tolerance:\nshift=\"+shift+\" ms, tolerance=\"+timePositiveShiftTolerance);\n\t\t\t\t\t//fireTimeDriftEvent(expected, drift);\n\t\t\t\t\tt1 = t2-intervalMillis;\n\n\t\t\t\t} else if(shift < timeNegativeShiftTolerance) {\n\t\t\t\t\tvlogger.warn(\"Time shifted in past by more than negative tolerance:\nshift=\"+shift+\" ms, tolerance=\"+timeNegativeShiftTolerance);\n\t\t\t\t\t//fireTimeDriftEvent(expected, drift);\n\t\t\t\t\tt1 = t2-intervalMillis;\n\n\t\t\t\t} else {\n\t\t\t\t\tshift = 0;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t///////////////\n\t\t\t//someReceiver.update(t1, t2, shift);\n\t\t\t///////////////\n\n\t\t\tt1 = t2;\n\t\t\tThread.sleep(intervalMillis);\n\n\t\t} catch(IllegalArgumentException e) {\n\t\t\tvlogger.warn(\"\",e);\n\t\t\t//no break.\n\t\t} catch(InterruptedException e) {\n\t\t\tbreak;\n\t\t} catch(Exception e) {\n\t\t\tvlogger.error(\"\",e);\n\t\t}\n\t}\n}"}, {"count": 1, "tags": [], "bug_id": 35746, "attachment_id": null, "is_private": false, "id": 77560, "time": "2005-07-22T15:25:26Z", "creator": "yoavs@computer.org", "creation_time": "2005-07-22T15:25:26Z", "text": "Please submit a patch to the SessionManager using your time tracker, instead of\na generic piece of time tracking code..."}, {"count": 2, "tags": [], "bug_id": 35746, "text": "Hello,\n\nI try to provide solutions/proof of concepts and I rely on knowledgable coders\nwho can sift the good ideas from the bad ideas and ensure a patch doesn't risk\ndozens of rejections because of various pickyness. I consider myself a\nconsultant and I'm open to questions but I cannot always write code for all\nopensource projects I contribute to.\n\nIf the official team of developers cannot appreciate anything else than working\ncode, then the useful knowledge of the community is censored and cannot benefit\nthis project.\n\nThank you for your comprehension.\n", "id": 83653, "time": "2005-12-14T16:25:33Z", "creator": "quartz12h@yahoo.com", "creation_time": "2005-12-14T16:25:33Z", "is_private": false, "attachment_id": null}, {"count": 3, "tags": [], "text": "This is an enhancement rather than a bug (so marking it as such).\n\nI doubt there will be much (any?) interest to create a patch for this since any\nwell managed server would use NTP or equivalent making this enhancement unecessary.", "attachment_id": null, "id": 94298, "creator": "markt@apache.org", "time": "2006-09-29T19:41:48Z", "bug_id": 35746, "creation_time": "2006-09-29T19:41:48Z", "is_private": false}, {"count": 4, "tags": [], "bug_id": 35746, "attachment_id": null, "is_private": false, "id": 94324, "time": "2006-09-30T16:12:37Z", "creator": "quartz12h@yahoo.com", "creation_time": "2006-09-30T16:12:37Z", "text": "Let's not be narrow minded and let's not suggest tomcat is only good for http\nservicing on server farms.\n\nTomcat can be deployed on embeded devices or appliance of all sorts that may not\nhave the luxury, the capacity or the access right to poll a ntp server.\n\nWhenever a user (or the ntp update agent/service/deamon) sets the date/time,\nsessions may be lost.\n\nThe only feed I can provide, which is sufficient for any willing tomcat\ndeveloper, is some design sketches.\n\n1-Thread.sleep(n) or Object.wait(n) will always delay by the given time even if\nsystem time changes (without interrupt() and notify[All]() interferences)\n\n1-whenever a session is refreshed, instead of renewing (pushing in the future)\nits expiration time, the code should simply reset to 0 the session 'age'.\n\n2-whenever the session manager check (60 seconds is the default I think), it\nshould simply age the session (here age+=60000;) and assert its validity as\nexpected.\n\nIt's that simple."}, {"count": 5, "tags": [], "creator": "darryl@darrylmiles.org", "is_private": false, "text": "While I agree with the general centiment that if an alternative algorithm works\nin more cases with no loss of performance that your idea maybe sound.\n\n\nBut the following statement demonstrates your limited knowledge of what NTP\ngoals are.\n\n(In reply to comment #4)\n> Whenever a user (or the ntp update agent/service/deamon) sets the date/time,\n> sessions may be lost.\n\nAn NTP client does not reset the clock when it computes a variation.  It makes\nthe system clock tick faster or slower to narrow that variation over time.  If\nits too far out NTP will not function and abort.  Since TC is not a realtime\napplication and runs largely on a multitaking OS a faster/slower clock is not\nordinarly detectable by an appliction.  Which is the point of running NTP.\n\n\nI'm a great believer that just as time never goes backwards that clock slew is\nnot something that an application programmer has to deal with.  This is one\ncertainty of the universe for which computer concepts live within so as such its\nan underpins everything.\n\nIf you want to change the time then do so in the BIOS before the operating\nsystem boots up, of the user changes the time force a device reboot.  If the\napplication of the device means you dont want this then you've going to have to\nlook at NTP anyway.\n\nSome would argue that short sighted embeded device creators didn't provision an\nadequate mechanism to change the clock or keep it up-to-date.  Since its a given\nthat the accuracy of the clock source in the device while good isn't perfect\n(like most things) and the device's software relies heavily on absolute time to\nfunction.\n\n\nOne question on your algorithm, is it written in the Java specification for the\nThread.sleep() function that this has to be implmented in a way impervious to\nclock slew ?  Or does that claim come from your experiments with a particular\nJVM implementation on the particular embeded device you have to hand ?  It is no\ngood building castles in the sand.\n", "id": 94326, "time": "2006-10-01T00:41:58Z", "bug_id": 35746, "creation_time": "2006-10-01T00:41:58Z", "attachment_id": null}, {"count": 6, "tags": [], "creator": "quartz12h@yahoo.com", "is_private": false, "text": "The point is not about NTP. The point is that on systems where time can be set\nby the user, sessions could be lost. Going into the bios is not an option for\nservers in a remote datacenter. Embeded systems and appliance do not expose the\nboot swequence nor the bios. Assume the system we are talking about here is\noffering the user the option to set time.\n\nI just wanted to share my experience and provide a resilient session expiration\nmecanism.\n\n- - -\n\nNotes on ntp:\n\nNTP agents can either accellerate, decellerate or set the clock, depending on\nhow you configure it. If you try to rewind time by an hour, it would take\nminimum 1 hour assuming the clock can literally stop. In most case this is not\nacceptable. If you wanted to advance clock by 1 hour while time could accelerate\nto 2x, you would still need 1 hour to do so, and the device would be taxed by\nhaving to do all its scheduled jobs twice as much with the same hardware. From\nan other angle, the hardware is effectively 2x slower. For example, thinks about\nbackups, scheduled purges, mailouts, etc...\n\nI know very well the effect of time \"warping\", we wrote a kernel module to\nsimulate weeks of uptime in a few hours (ex: for 100x speed, simply add 100\njiffies instead of 1). Note that this does shorten the actual duration of\nsleep() and wait(), which is why it worked for our long uptime simulations (the\nentire linux kernel relies on that time we tweak).\n\nHowever, I don't know if NTP updates are playing with jiffies or if the\nsleep()/wait() would be unaffected.\n\nWhat I do know, is that you can write a simple java program that just\nsleep(60000) and while it sleeps, you can set (not drift) the time all you want,\nthere is no forcing sleep() to last shorter nor longer.", "id": 94329, "time": "2006-10-01T05:42:22Z", "bug_id": 35746, "creation_time": "2006-10-01T05:42:22Z", "attachment_id": null}, {"count": 7, "tags": [], "bug_id": 35746, "attachment_id": null, "id": 94330, "time": "2006-10-01T07:42:50Z", "creator": "darryl@darrylmiles.org", "creation_time": "2006-10-01T07:42:50Z", "is_private": false, "text": "(In reply to comment #6)\n> What I do know, is that you can write a simple java program that just\n> sleep(60000) and while it sleeps, you can set (not drift) the time all you want,\n> there is no forcing sleep() to last shorter nor longer.\n\nTo reconfirm my opening comment, if your proposal makes thing work in more cases\nwithout any side-effects or performance impact I can't see any objection for it.\n Maybe you could confirm this is the case once you work out a patch.\n\nBut to be clear you're not able to cite any contractual Java API requirement\nthat Thread.sleep() must always work the way you describe on all JVMs on all\noperating systems.  You can only say it works in the case you tested.\n\nThe bigger question here is that you are fixing only one issue where comparisons\nto absolute system time are being made, how many other parts of the code are\naffected to.  Should a complex application (like TC) be expected to deal with\ntime going backwards (it is a given that applications can already deal\ngracefully with time going forwards).\n\n\nThinking down the road towards a solution:\n\nLet suppose you were able to detect a slew occur, and calculate how much slew\noccured.\nThe session expiry may not be the only place affected, you might also need to\nmodify the code which accesses a session (if that code is doing an expiry check\non every access).  Everytime a session is accessed a clock slew detection\nalgorithm would need to detect slew.  if(currentTime < session.lastAccessedTime\n|| currentTime > (session.lastAccessedTime + expiryIntervalTime +\nminiLatencyMargin)) { sessionFixSlew(); }  Maybe that works providing the\nexpiryIntervalTime is less than half the session timeout.  Maybe that works\nproviding you dont care about slew of less than expiryIntervalTime not being\ndetectable.\nMaybe the solution calls for a custom StandardSession implementation.\n\n\nAs for your other comments..\n\nI disagree with your x0.5 through x2 values, sure its theoretically possible to\ndo but who is doing it ?  Maybe x0.98 to x1.02 is more realistic value to cite.\n\nI disagree with your datacentre argument, on some unix the \"clock\" tool allow\nsetting of BIOS clock without needing to go into the BIOS.  It pretty obvious to\nme how the construct a mechanism in an embeded device to change the clock you\neither do it last thing just before issuing a hardware reset (as part of the\nprocedure to change the clock) or you store a +/- modification value in some\nnon-volatile place and just as the OS boots up it make the correction.  A bit\nlike the old /etc/ntp.drift file.\n\nImplementing RTC updating, kernel adjtimex support and a basic NTP client are\nsubstantially less work than implementing a JVM and if an embeded device has\nresources to run a JVM (and tomcat inside that) then we're not talking about no\nmicroPU for a washing machine are we.\n"}, {"count": 8, "tags": [], "creator": "edward.kuns@aspect.com", "attachment_id": null, "text": "(In reply to comment #5)\n> But the following statement demonstrates your limited knowledge of what NTP\n> goals are.\n> \n> An NTP client does not reset the clock when it computes a variation.  It makes\n> the system clock tick faster or slower to narrow that variation over time.  If\n> its too far out NTP will not function and abort.  \n\nSince you know so much about how all implementations of NTP operate, perhaps you\ncan explain to me how a datacenter I know of had all of their clocks jump\nforward by five minutes, then a couple hours later jump backwards by five\nminutes, and then repeat a couple more times over the next few days.  This was\nunder Windows, and was caused by a malfunction of their primary NTP server. \nSomehow, the primary NTP server jumping its clock caused all of the clients to\njump their clocks, despite your knowledige of how NTP operates.\n\nThe truth is that implementations of NTP can and do jump the clock, depending on\nhow they are implemented and how large the time difference is.  A well-mannered\nimplementation of NTP operates exactly as you say.  Not all implementations of\nNTP are well-mannered.", "id": 94331, "time": "2006-10-01T07:56:59Z", "bug_id": 35746, "creation_time": "2006-10-01T07:56:59Z", "is_private": false}, {"count": 9, "tags": [], "bug_id": 35746, "attachment_id": null, "is_private": false, "id": 94336, "time": "2006-10-01T13:44:39Z", "creator": "quartz12h@yahoo.com", "creation_time": "2006-10-01T13:44:39Z", "text": "Just to clarify, I proposed 2 ways of avoiding unexpected session expiration.\n\na) on the looping/sleeping thread, detect time shifts and pass it along the\nstackframes to whichever class wants to know. This is when the looping code know\nto few about the task to perform, for example if the looping thread doesn't know\nthe job is to assert/expire sessions, but it can pass its knowledge of time and\ntime shifts. That's the piece of code.\n\nb) the looping/sleeping thread knows it has to age sessions. Valves or filters\n(whatever on service()) simply resets the age to 0.\n\n\nNote that if the duration of a sleep/wait could be affected by a system time\nchange, rolling back time 1 hour could lock up a thread for 1 more hour. The old\nway of expiring session would be just as affected because which ever thread\nchecks for session expiration, it also calls wait/sleep. There is no other jvm\nprimitive to perform such pause. Therefore, the implementation would be just as\nflawed in the worst case, and fairly expiring session in the best case.\n\n- - -\n\nAs for wait()/sleep() JLS specs (JVM spec doesn't mention it):\n\nhttp://java.sun.com/docs/books/jls/third_edition/html/memory.html#17.8.1\n\"If this is a timed wait, an internal action removing t from m's wait set that\noccurs after at least millisecs milliseconds plus nanosecs nanoseconds elapse\nsince the beginning of this wait action.\"\n\nhttp://java.sun.com/docs/books/jls/third_edition/html/memory.html#17.9\n\"Thread.sleep causes the currently executing thread to sleep (temporarily cease\nexecution) for the specified duration, subject to the precision and accuracy of\nsystem timers and schedulers.\""}, {"count": 10, "tags": [], "bug_id": 35746, "attachment_id": null, "id": 100866, "time": "2007-03-25T07:50:32Z", "creator": "yoavs@computer.org", "creation_time": "2007-03-25T07:50:32Z", "is_private": false, "text": "This seems like a nice academic and theoretical argument to me.  I too\ncontribute to a lot of open-source projects, and I do so with specific patch to\nthem: general discussions of how something might be done are nice, but useless.\n As you can see from the votes for this item and the lack of complaints about\nit, ever, on any Tomcat mailing list, no one cares."}]