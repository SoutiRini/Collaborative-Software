[{"count": 0, "tags": [], "bug_id": 57779, "attachment_id": null, "id": 182182, "time": "2015-03-30T12:22:29Z", "creator": "Bock.Michael@telekom.de", "creation_time": "2015-03-30T12:22:29Z", "is_private": false, "text": "If using a separate (non-container) thread to write to a ServletOutputStream, a deadlock can occur, if an io-error occurs during write. For example, if the client drops the connection.\nThis is caused by a synchronized operation on the the underlying socket-object.\n\nThe servlet handling thread is blocked, while waiting for the end of output from the separate thread, and holds a lock on the socket-object:\n\n\"http-bio-25030-exec-10\" daemon prio=10 tid=0x0000000001804800 nid=0x3fd0 waiting on condition [0x00007f767aeeb000]\n   java.lang.Thread.State: WAITING (parking)\n        at sun.misc.Unsafe.park(Native Method)\n        - parking to wait for  <0x00000000c3b273b8> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)\n ...\n at org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:314)\n        - locked <0x00000000c38ef6d8> (a org.apache.tomcat.util.net.SocketWrapper)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n        at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\n        at java.lang.Thread.run(Thread.java:745)\n\n\nThe separate thread trys to write, but an io-error occurs:\n\n\"Thread-13\" daemon prio=10 tid=0x00007f767c5c8000 nid=0x3fda waiting for monitor entry [0x00007f767a4e2000]\n   java.lang.Thread.State: BLOCKED (on object monitor)\n        at org.apache.tomcat.util.net.JIoEndpoint.processSocketAsync(JIoEndpoint.java:560)\n        - waiting to lock <0x00000000c38ef6d8> (a org.apache.tomcat.util.net.SocketWrapper)\n        at org.apache.coyote.AbstractProcessor.setErrorState(AbstractProcessor.java:84)\n        at org.apache.coyote.http11.AbstractHttp11Processor.action(AbstractHttp11Processor.java:802)\n        at org.apache.coyote.Response.action(Response.java:172)\n        at org.apache.catalina.connector.OutputBuffer.doFlush(OutputBuffer.java:363)\n        at org.apache.catalina.connector.OutputBuffer.flush(OutputBuffer.java:331)\n        at org.apache.catalina.connector.CoyoteOutputStream.flush(CoyoteOutputStream.java:101)\n\nNow it trys to get a lock on the socket-object and both threads are blocked forever.\n\nIn the former tomcat version we used (7.0.53) this was not an issue. I had a look in the source code and saw that the failing code was invented later."}, {"attachment_id": null, "tags": [], "bug_id": 57779, "is_private": false, "count": 1, "id": 182202, "time": "2015-03-31T17:24:59Z", "creator": "markt@apache.org", "creation_time": "2015-03-31T17:24:59Z", "text": "Full stack traces of both threads please.\n\nAs an aside, using the blocking IO connector with the non-blocking API is pointless. Depending on what the stack traces show, this may end up as WONTFIX."}, {"count": 2, "tags": [], "bug_id": 57779, "attachment_id": null, "text": "We are not using the tomcat non blocking io. We simply hand over the ServletOutputStream to another thread. Here are the complete stacktraces:\n\n\n\"http-bio-25030-exec-10\" daemon prio=10 tid=0x0000000001804800 nid=0x3fd0 waiting on condition [0x00007f767aeeb000]\n   java.lang.Thread.State: WAITING (parking)\n        at sun.misc.Unsafe.park(Native Method)\n        - parking to wait for  <0x00000000c3b273b8> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)\n        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:186)\n        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2043)\n        at com.qivicon.backend.camera.proxy.ClientInfo.waitForEndOfStream(ClientInfo.java:138)\n        at com.qivicon.backend.camera.servlet.StreamServlet.handleRequest(StreamServlet.java:83)\n        at sun.reflect.GeneratedMethodAccessor32.invoke(Unknown Source)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n        at java.lang.reflect.Method.invoke(Method.java:606)\n        at org.springframework.web.method.support.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:219)\n        at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:132)\n        at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:104)\n        at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandleMethod(RequestMappingHandlerAdapter.java:745)\n        at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:686)\n        at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:80)\n        at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:925)\n        at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:856)\n        at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:936)\n        at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:827)\n        at javax.servlet.http.HttpServlet.service(HttpServlet.java:620)\n        at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:812)\n        at javax.servlet.http.HttpServlet.service(HttpServlet.java:727)\n        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:303)\n        at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)\n        at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)\n        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)\n        at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)\n        at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330)\n        at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:118)\n        at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:84)\n        at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n        at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:113)\n        at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n        at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:113)\n        at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n        at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:154)\n        at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n        at org.springframework.security.web.authentication.www.BasicAuthenticationFilter.doFilter(BasicAuthenticationFilter.java:150)\n        at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n        at org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:155)\n        at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n        at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:199)\n        at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n        at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:110)\n        at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n        at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:50)\n        at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)\n        at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n        at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:87)\n        at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n        at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:192)\n        at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:160)\n        at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:343)\n        at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:260)\n        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)\n        at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)\n        at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:220)\n        at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:122)\n        at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:504)\n        at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:170)\n        at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:103)\n        at org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:950)\n        at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:116)\n        at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:421)\n        at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1074)\n        at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:611)\n        at org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:314)\n        - locked <0x00000000c38ef6d8> (a org.apache.tomcat.util.net.SocketWrapper)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n        at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\n        at java.lang.Thread.run(Thread.java:745)\n\n\n\"Thread-13\" daemon prio=10 tid=0x00007f767c5c8000 nid=0x3fda waiting for monitor entry [0x00007f767a4e2000]\n   java.lang.Thread.State: BLOCKED (on object monitor)\n        at org.apache.tomcat.util.net.JIoEndpoint.processSocketAsync(JIoEndpoint.java:560)\n        - waiting to lock <0x00000000c38ef6d8> (a org.apache.tomcat.util.net.SocketWrapper)\n        at org.apache.coyote.AbstractProcessor.setErrorState(AbstractProcessor.java:84)\n        at org.apache.coyote.http11.AbstractHttp11Processor.action(AbstractHttp11Processor.java:802)\n        at org.apache.coyote.Response.action(Response.java:172)\n        at org.apache.catalina.connector.OutputBuffer.doFlush(OutputBuffer.java:363)\n        at org.apache.catalina.connector.OutputBuffer.flush(OutputBuffer.java:331)\n        at org.apache.catalina.connector.CoyoteOutputStream.flush(CoyoteOutputStream.java:101)\n        at com.qivicon.backend.camera.proxy.ClientInfo.write(ClientInfo.java:100)\n        at com.qivicon.backend.camera.proxy.WebSocketServerHandler.handleWebSocketFrame(WebSocketServerHandler.java:273)\n        at com.qivicon.backend.camera.proxy.WebSocketServerHandler.channelRead0(WebSocketServerHandler.java:99)\n        at io.netty.channel.SimpleChannelInboundHandler.channelRead(SimpleChannelInboundHandler.java:105)\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:333)\n        at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:319)\n        at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:163)\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:333)\n        at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:319)\n        at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:787)\n        at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:125)\n        at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:511)\n        at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:468)\n        at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:382)\n        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:354)\n        at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:116)\n        at java.lang.Thread.run(Thread.java:745)", "id": 182207, "time": "2015-04-01T07:17:21Z", "creator": "Bock.Michael@telekom.de", "creation_time": "2015-04-01T07:17:21Z", "is_private": false}, {"count": 3, "tags": [], "bug_id": 57779, "attachment_id": null, "id": 182208, "time": "2015-04-01T08:10:24Z", "creator": "remm@apache.org", "creation_time": "2015-04-01T08:10:24Z", "is_private": false, "text": "Ok, but your: parking to wait for  <0x00000000c3b273b8> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)\ndoes not seem to be related to Tomcat.\n\nThe lock on the socket is unavoidable when doing processing, so there won't be any fix in that area."}, {"count": 4, "tags": [], "bug_id": 57779, "attachment_id": null, "text": "We must block the servlet thread to wait for the output from the other thread to be completed. \nIn consequence to the changes in 7.0.54 it is generally not possible anymore to use a separate thread to write to the servlet outputstream.\nIs this restriction intended?", "id": 182209, "time": "2015-04-01T08:30:00Z", "creator": "Bock.Michael@telekom.de", "creation_time": "2015-04-01T08:30:00Z", "is_private": false}, {"count": 5, "tags": [], "bug_id": 57779, "attachment_id": null, "id": 182210, "time": "2015-04-01T09:21:18Z", "creator": "remm@apache.org", "creation_time": "2015-04-01T09:21:18Z", "is_private": false, "text": "In your trace the deadlock is caused by the lock on <0x00000000c3b273b8> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject) but it only appears once in your stack, we don't see where it is locked.\n\nI note that 53 works and not 54, but there are no apparently relevant changes. In 55, the error processing was updated to be done in a container thread (the only solution really) and that's where the socket locking is done. This seems legitimate and unavoidable as any async closing attempt is 100% broken."}, {"count": 6, "tags": [], "text": "We lock the servlet thread with our own lock, which is normally released by the worker thread as soon as the output is processed. \nBut this case the worker thread has no chance to release the lock, because it's locked itself in tomcat code.", "is_private": false, "bug_id": 57779, "id": 182211, "time": "2015-04-01T09:31:07Z", "creator": "Bock.Michael@telekom.de", "creation_time": "2015-04-01T09:31:07Z", "attachment_id": null}, {"count": 7, "tags": [], "bug_id": 57779, "text": "Are you using Servlet 3 async processing at all? Or is this all custom async code written on top of - effectively - servlet 2.5?", "id": 182212, "time": "2015-04-01T11:21:14Z", "creator": "markt@apache.org", "creation_time": "2015-04-01T11:21:14Z", "is_private": false, "attachment_id": null}, {"count": 8, "tags": [], "creator": "Bock.Michael@telekom.de", "attachment_id": null, "text": "This is custom async code written on top of servlet 2.5.\n\nWe're now switched the http-connector to Http11NioProtocol. In a first try the lock didn't occur anymore.", "id": 182213, "time": "2015-04-01T11:34:27Z", "bug_id": 57779, "creation_time": "2015-04-01T11:34:27Z", "is_private": false}, {"count": 9, "tags": [], "bug_id": 57779, "text": "OK. I've stopped Tomcat doing the dispatch to another thread unless Servlet 3+ async is being used. This should enable your code to work with BIO again.\n\nThe fix has been made to trunk, 8.0.x (for 8.0.22 onwards) and 7.0.x (for 7.0.62 onwards).\n\nSwitching to NIO will avoid the issue since NIO actually does a dispatch to a new thread (which then blocks waiting for the lock) whereas BIo does it in-line.", "id": 182215, "time": "2015-04-01T13:01:57Z", "creator": "markt@apache.org", "creation_time": "2015-04-01T13:01:57Z", "is_private": false, "attachment_id": null}]