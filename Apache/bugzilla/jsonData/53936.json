[{"count": 0, "tags": [], "text": "MemoryLeakProtection in the Tomcat wiki says: \"Sun bug 6916498 - An exception can keep a classloader in memory if the stack trace that was recorded when it was created contains a reference to one of its classes.\" This bug may be considered an acceptable performance tradeoff, so detection and mitigation in the meantime is in my opinion desirable.\n\nThe leak is caused by a reference cycle that is only partially visible to the garbage collector. The method fillInStackTrace() can be called on an Exception object to alter its stacktrace, but to effectively break the cycle the method call chain up to that point must be clean of any classes that shouldn't be retained.\n\nThe attached test code contains two versions of the algorithm, for Java 1.6 and 1.7. The 1.6 version is intended to be effective only when loaded by a shared classloader, the 1.7 version should be effective even if loaded by a webapp classloader.\n\nThe methods are intended to be called before or during webapp unloading/reloading on Exception objects stored in static variables.\n\nPlease review to see if I've made any mistakes and consider for enhancement :)", "is_private": false, "id": 162419, "creator": "timo.kinnunen@gmail.com", "time": "2012-09-26T15:22:17Z", "bug_id": 53936, "creation_time": "2012-09-26T15:22:17Z", "attachment_id": null}, {"count": 1, "tags": [], "text": "Created attachment 29421\nCleaning Exception stacktrace by carefully calling fillInStackTrace", "attachment_id": 29421, "id": 162420, "creator": "timo.kinnunen@gmail.com", "time": "2012-09-26T15:23:53Z", "bug_id": 53936, "creation_time": "2012-09-26T15:23:53Z", "is_private": false}, {"count": 2, "tags": [], "bug_id": 53936, "attachment_id": null, "id": 162473, "time": "2012-09-30T17:40:52Z", "creator": "knst.kolinko@gmail.com", "creation_time": "2012-09-30T17:40:52Z", "is_private": false, "text": "(In reply to comment #0)\n> The attached test code contains two versions of the algorithm, for Java 1.6\n> and 1.7.\n\n1. It is a bit hard to see, but looks that\n \n1.6 version is \"containerOnlyFill(Throwable)\"\n1.7 version is \"bootclassLoaderOnlyFill(Throwable)\"\n\nWhy are you using Throwable[]? It would make sense if you were returning a different value than passing it, but you are not.  Just a simple\n\n  public static void containerOnlyFill(final Throwable throwable) {\n    try {\n      Runnable target = new Runnable() {\n        @Override public void run() {\n          throwable.fillInStackTrace();\n        }\n      };\n(...)\n  }\n\nwould suffice.\n\n\n2. What is the intended use of this code?\n\nIn those several cases when Tomcat creates and holds an exception, we already solved the issue by implementing the fillInStackTrace() method as a NOOP.\n\nSee e.g. o.a.naming.resources.ImmutableNameNotFoundException."}, {"count": 3, "tags": [], "bug_id": 53936, "is_private": false, "text": "1) Yes, this is correct. containerOnlyFill(Throwable) is a straight-up Java 1.6 port of the Java 1.7 bootclassLoaderOnlyFill(Throwable) method. \n\nThe 1.6 version could be simplified for production use in Tomcat. Please note, however, that the same simplification couldn't be applied to the 1.7 version, because the classes created by java.lang.invoke.MethodHandles can remain in memory for a long time. An array is used to prevent these classes from holding a direct reference to the Throwable and keeping it and its ClassLoader from being garbage-collected.\n\n2) The intended use of this code is for the WebappClassLoader to clean up Exceptions that are created and held by third-party libraries included in a webapp when the webapp is unloaded. \n\nThe 1.7 version is also intended to be usable from user code when the developer of the webapp is aware of one of their libraries having this issue. In this case the developer can use reflection to get the Exception object held by a library and call bootclassLoaderOnlyFill(Throwable) on it during initialization.", "id": 162474, "time": "2012-09-30T18:57:50Z", "creator": "timo.kinnunen@gmail.com", "creation_time": "2012-09-30T18:57:50Z", "attachment_id": null}, {"count": 4, "tags": [], "bug_id": 53936, "attachment_id": null, "is_private": false, "id": 162477, "time": "2012-09-30T23:37:18Z", "creator": "knst.kolinko@gmail.com", "creation_time": "2012-09-30T23:37:18Z", "text": "> MemoryLeakProtection in the Tomcat wiki says: \"Sun bug 6916498 - An\n> exception can keep a classloader in memory if the stack trace that was\n> recorded when it was created contains a reference to one of its classes.\"\n\n(In reply to comment #3)\n> The intended use of this code is for the WebappClassLoader to clean up\n> Exceptions that are created and held by third-party libraries included in a\n> webapp when the webapp is unloaded. \n> \n\nFor reference:\n\nhttp://wiki.apache.org/tomcat/MemoryLeakProtection\nhttps://issues.apache.org/bugzilla/show_bug.cgi?id=50460\n\n1. First, I think that there will not be a leak in your scenario.\n\nTomcat already has code to clear static fields in classes that belong to a web application.  Note though that it is possible only because those classes are loaded through Tomcat's own WebappClassLoader class. It holds references to all classes that it loaded.\n\n\nThe scenario where I observed this memory leak issue was different. See bug 50460 for details. The Exception instance was being hold by a shared library, not by webapp one:\n\n1) A webapp does its first call to a shared library or to Tomcat server code.\n2) A class from the shared library is loaded and creates an Exception instance.\n3) That exception holds reference to the calling webapp class.\n\n\n2. If a library caches an Exception instance and has such a leak, it is a bug in that library. It is up to the authors of that library to fix their bug, e.g. by implementing fillInStackTrace() as a NOOP, like we did in ImmutableNameNotFoundException.\n\n3. Each \"class scanning\" solution takes noticeable time, because usually there are a lot of classes. It is not worth here.\n\nIf there is no way to fix a library, one could implement a \"targeted\" solution: write a listener to perform cleanup in their specific case.\n\n4. If the leak occurs in a shared library, I see no sane way to enumerate loaded classes (and thus to apply your solution). A good news is that there is an alternative solution: you can preload those classes.\n\nA list of classes to preload is already configurable on JreMemoryLeakPreventionListener.\n\n\nThus I am closing this issue as WONTFIX."}, {"count": 5, "tags": [], "bug_id": 53936, "attachment_id": null, "id": 162481, "time": "2012-10-01T08:02:24Z", "creator": "markt@apache.org", "creation_time": "2012-10-01T08:02:24Z", "is_private": false, "text": "*** Bug 53935 has been marked as a duplicate of this bug. ***"}]