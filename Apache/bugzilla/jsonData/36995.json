[{"count": 0, "tags": [], "bug_id": 36995, "attachment_id": null, "is_private": false, "id": 80960, "time": "2005-10-10T18:15:38Z", "creator": "c.roslawski@mairdumont.com", "creation_time": "2005-10-10T18:15:38Z", "text": "Greetings,\n\nWe ran a simple load test against Tomcat 4.1.x after having some strange\nsession effects on our website, to see if the generated session ids are\nreally unique. The test made HTTP requests with wget, extracted the newly\ngenerated session ids and wrote them into a file. It turned up two pairs\nof duplicate session ids from active sessions.\n\nI read the source code to see how the session ids are generated, and found\nthis code in org.apache.catalina.session.ManagerBase#createSession() from\nTomcat 4.1.31, line 544 to 555:\n\n        synchronized (sessions) {\n            while (sessions.get(sessionId) != null){ // Guarantee uniqueness\n                sessionId = generateSessionId();\n                duplicates++;\n                // @todo Move appending of jvmRoute generateSessionId()???\n                if (jvmRoute != null) {\n                    sessionId += '.' + jvmRoute;\n                }\n            }\n        }\n\n        session.setId(sessionId);\n\nI came up with the following scenario, where duplicate session ids could\nbe generated:\n\nThread 1 runs into the method, generates a session id, checks if the session\nid is unique and leaves the synchronized block. There the thread 1 pauses and\nthread 2, a request from a different user, takes over.\n\nThread 2 runs into the method, generates the same session id by pure chance\nand checks if the session id is unique. Since thread 1 has not yet called\nsetId, the session id isn't stored in the HashMap, the session id is\nconsidered unique and the loop is left. The method setId() is called, which\nresults in a call to the method add() of the ManageBase class. There the new\nsession object is stored in the HashMap with the session id.\n\nThread 1 continues and calls setId() as well, overwriting the already present\nsession object in the HashMap with a new one.\n\nBoth threads continue and return a duplicate session id to different user.\nBoth users use the same session object for subsequent requests.\n\nI know the chances for this scenario are slim, as it must generate the same\nsession id and run into the race condition between the two syncronised blocks\nin createSession() and add(), but it appears to be happening.\n\nShouldn't the check for uniqueness and the adding of the newly generated\nsession id be in the same syncronized block of \"sessions\", to really\nensure uniqueness? Or did I get something wrong here?\n\nTomcat 5.0.28 and Tomcat 5.5.9 appears to have the same problem, btw.\n\nThanks,\n\nChristian"}, {"count": 1, "tags": [], "text": "I hava look inside also inside 5.5.x code (ManagerBase.generateSessionId()) and\nthink the duplication risk is there. But the risk is small, as random generator\nworks really good. I have test with Linux Suse 9.3 and have no chance to\nreproduce your test result. Can you please send your testscripts and os information?\n\nThanks\nPeter ", "attachment_id": null, "bug_id": 36995, "id": 80966, "time": "2005-10-10T19:58:08Z", "creator": "pr@objektpark.de", "creation_time": "2005-10-10T19:58:08Z", "is_private": false}, {"count": 2, "tags": [], "bug_id": 36995, "text": "(In reply to comment #1)\n> I hava look inside also inside 5.5.x code (ManagerBase.generateSessionId()) and\n> think the duplication risk is there. But the risk is small, as random generator\n> works really good. I have test with Linux Suse 9.3 and have no chance to\n> reproduce your test result. Can you please send your testscripts and os\ninformation?\n> \n\nThis does not make any sense. The risk does not exist, and the uniqueness check\nis just there to make insecure people more secure. I am actually tired of it,\nand would want it removed.", "id": 80979, "time": "2005-10-11T09:09:17Z", "creator": "remm@apache.org", "creation_time": "2005-10-11T09:09:17Z", "is_private": false, "attachment_id": null}, {"count": 3, "tags": [], "bug_id": 36995, "is_private": false, "text": "Created attachment 16657\nA simple test case to check for duplicate session ids.", "id": 80990, "time": "2005-10-11T14:01:58Z", "creator": "c.roslawski@mairdumont.com", "creation_time": "2005-10-11T14:01:58Z", "attachment_id": 16657}, {"count": 4, "text": "We have Suse 8.2 with kernel 2.4.20-64GB-SMP on our servers. Java version is\n1.4.2_03 and Tomcat 4.1.29.\n\nAs the chances for the described scenario are slim, I suggest to reduce the\nvalue of ManagerBase.SESSION_ID_BYTES from 16 to 2 or 3 for testing. This\nshould increase the chances of duplicates returned by\nManagerBase.generateSessionId() without affecting the behaviour of Tomcat.\n\nAdditionally, I put a Thread.yield() below the end of the sychronized block\nin ManagerBase.createSession(), to provoke the racing time condition, further\nincreasing the chances for the scenario.\n\nThen I started Tomcat with the JSP page \"session.jsp\":\n\n<%@ page language=\"java\" %><%= request.getSession().getId() %>\n\nThe test application performs repeated request from different threads,\nrecoding the returned session ids and checking for duplicates. Even with\nthe reduced random range it might take several runs to stumble into a\nduplicate. I'm sure there are better ways to test it, it is just a simple\ntest.\n\nI'm not saying this is an urgent problem, or that it happens all the time, I\nmerely think that it can happen, because random numbers, however large the\nrange might be, are not unique by themselves, are they? And if it can happen,\nit will happen, eventually. Or am I missing something here?\n", "bug_id": 36995, "attachment_id": null, "id": 80991, "time": "2005-10-11T14:02:45Z", "creator": "c.roslawski@mairdumont.com", "creation_time": "2005-10-11T14:02:45Z", "tags": [], "is_private": false}, {"count": 5, "tags": [], "bug_id": 36995, "attachment_id": null, "id": 81033, "time": "2005-10-12T14:09:21Z", "creator": "remm@apache.org", "creation_time": "2005-10-12T14:09:21Z", "is_private": false, "text": "(In reply to comment #4)\n> We have Suse 8.2 with kernel 2.4.20-64GB-SMP on our servers. Java version is\n> 1.4.2_03 and Tomcat 4.1.29.\n> \n> As the chances for the described scenario are slim, I suggest to reduce the\n> value of ManagerBase.SESSION_ID_BYTES from 16 to 2 or 3 for testing. This\n> should increase the chances of duplicates returned by\n> ManagerBase.generateSessionId() without affecting the behaviour of Tomcat.\n> \n> Additionally, I put a Thread.yield() below the end of the sychronized block\n> in ManagerBase.createSession(), to provoke the racing time condition, further\n> increasing the chances for the scenario.\n> \n> Then I started Tomcat with the JSP page \"session.jsp\":\n> \n> <%@ page language=\"java\" %><%= request.getSession().getId() %>\n> \n> The test application performs repeated request from different threads,\n> recoding the returned session ids and checking for duplicates. Even with\n> the reduced random range it might take several runs to stumble into a\n> duplicate. I'm sure there are better ways to test it, it is just a simple\n> test.\n> \n> I'm not saying this is an urgent problem, or that it happens all the time, I\n> merely think that it can happen, because random numbers, however large the\n> range might be, are not unique by themselves, are they? And if it can happen,\n> it will happen, eventually. Or am I missing something here?\n\nThe whole idea of even checking for duplicates is a nonsense (beyond giving\npeople some sense of safety). If the id generation has conflicts, then it means\nthe system is completely insecure, so fixing a bug which will never actually\noccur doesn't have any benefits.\n"}]