[{"count": 0, "tags": [], "bug_id": 33934, "attachment_id": null, "text": "<c:set ..> does not clear its target/value fields after usage, it keeps\nreferences to these objects when the application server places the tag instance\nback into a tag pool.\n\nExample: I have a session attribute named hugeBean and set a property of that\nbean with <c:set target=\"${hugeBean}\" ... />. In doStartTag() the EL ${hugeBean}\nis evaluated and the result is placed into the field \"target\" - see\norg.apache.taglibs.standard.tag.el.core.SetTag and\norg.apache.taglibs.standard.tag.common.core.SetSupport. In doEndTag() the\nproperty of hugeBean is changed, but the field \"target\" in SetSupport is not\ncleared afterwards. After calling doEndTag() the application server may (and\ntomcat does) put the tag into a tag pool for recycling - release() is not called\nbefore this (which is correct I think). Now the tag pool contains the SetTag\ninstance that still contains a reference to the hugeBean. If the application\nremoves hugeBean from the session, it can not be garbage collected because of\nthe reference from the tag pool.\n\nThe fix should be not too difficult, I think doEndTag() should clear all\nreferences to appliaction objects.", "id": 72060, "time": "2005-03-09T17:24:44Z", "creator": "av@tonbeller.com", "creation_time": "2005-03-09T17:24:44Z", "is_private": false}, {"count": 1, "attachment_id": null, "creator": "martinc@apache.org", "is_private": false, "id": 72107, "time": "2005-03-10T06:13:31Z", "bug_id": 33934, "creation_time": "2005-03-10T06:13:31Z", "tags": [], "text": "This isn't something that should be changed. To adhere to the JSP spec, a tag \ncannot clear out values that correspond to tag attributes. See the description \nof AttSets (attribute sets) in the spec.\n\n(I'm leaving it to one of the Standard folks to change the status of this bug.)"}, {"count": 2, "tags": [], "bug_id": 33934, "is_private": false, "text": "Quote from the spec:\n\nNote that since there are no guarantees on the state of the properties, a tag \nhandler that had some optional properties set can only be reused if those \nproperties are set to a new (known) value. This means that tag handlers can \nonly be reused within the same \"AttSet\" (set of attributes that have been set).\n\nI'd say, this means that there is no requirement for tag handlers \nto \"remember\" their state after doEndTag(). \n\nI understand this like this example: a tag has attributes a1, a2, a3, a4, a5. \nWhen its used the first time, e.g. the attributes a1, a2 and a4 are set. Then \nit can be reused only in situations where  a1, a2 and a4 are set again. It can \nnot be reused in a situation where only a1 and a2 are set again. Its not \nassumed that a4 will still contain the value from the previous call here. \n\nAlso it would not make much sense to remember the value I think, because it \nwould lead to some random behaviour. Another example:\n\n<c:out value=\"${bean.property}\" escapeXml=\"false\"/>\n<c:out value=\"${bean.property}\"/>\n\nIs escapeXml true or false in the second call? Of course it should be true, so \nthe container can not reuse the first instance whose escapeXml attribute does \nnot have the default value. If the container were allowed to reuse the tag \nhandler, the behaviour would be random (depending on tag handler caching). But \nthe container may reuse the c:out tag handler here:\n\n<c:out value=\"${bean.property}\" escapeXml=\"true\"/>\n\nbecause the same attributes are set again.\n\n\n", "id": 72110, "time": "2005-03-10T09:59:42Z", "creator": "av@tonbeller.com", "creation_time": "2005-03-10T09:59:42Z", "attachment_id": null}, {"count": 3, "tags": [], "creator": "martinc@apache.org", "attachment_id": null, "id": 72153, "time": "2005-03-10T21:03:57Z", "bug_id": 33934, "creation_time": "2005-03-10T21:03:57Z", "is_private": false, "text": "Your quote from the spec refers to the invocation of the release() method. \nHowever, the release() method is not required to be called between uses of the \ntag within the same page. If a tag is reused on a page with the same AttSet, \nthen the container is not required to invoke the setter for attributes that \nhave the same value. Therefore, the tag itself cannot clear out the values, \nbecause the container would then be assuming the old values, which would no \nlonger be there.\n\nYour example with the 'escapeXml' attribute is not valid, because the two tag \nusages do not have the same AttSet, and so the rule for reusing tag handlers \nwith the same AttSets does not apply."}, {"count": 4, "tags": [], "creator": "av@tonbeller.com", "attachment_id": null, "id": 72181, "time": "2005-03-11T09:26:39Z", "bug_id": 33934, "creation_time": "2005-03-11T09:26:39Z", "is_private": false, "text": "Oops - you are right, I missed the paragraph above where the spec says:\n\n... After the doEndTag invocation, the tag handler is available for further \ninvocations (and it is expected to have retained its properties.\n\nBut it still seems to me that the memory leak is not necessary for the EL \nversion of c:set. In SetTag.java, doStartTag() calls evaluateExpressions() \nwhich means that new values are assigned to the fields value, target and \nproperty. If these are assigned on every doStartTag() there is no need to \nretain their state after doEndTag(). \n\nThe question may be whether the string \"${bean.property}\" should be retained \nor the result of the evaluation of that string. c:set retains both but \ndiscards the result of evaluation on every doStartTag().\n\nSo I think its valid to clear value, target and property fields after doEndTag\n().\n"}, {"count": 5, "tags": [], "creator": "av@tonbeller.com", "attachment_id": null, "is_private": false, "id": 43188, "time": "2005-03-22T09:25:27Z", "bug_id": 33934, "creation_time": "2005-03-22T09:25:27Z", "text": "Let me summarize the bug once more:\n\nThe field \"target\" of the EL version of the c:set tag contains a reference to\nthe bean whose property shall be modified, lets call that e.g. \"hugeBean\". After\ndoEndTag() was called the application server puts the c:set tag instance into a\ntag pool for recycling. The field \"target\" still holds the reference to\n\"hugeBean\", so it can not be garbage collected. This is not necessary, because\n\"target\" is assigned a new value on every usage of the c:set tag instance in\ndoStartTag(). doStartTag() evaluates the EL string (e.g. \"${hugeBean}\") and\nassigns the result to the field \"target\".\n\nWhenever the c:set tag is used - for the first time or recycled from the pool -\nthe method doStartTag() is called. doStartTag() evaluates the EL expression and\nassigns the result to the field \"target\". So there is no need to retain the\nresult of that evaluation in the field \"target\" after doEndTag() was processed,\nbecause on the next usage it will overwritten anyway. Its sufficient to retain\nthe EL string \"${hugeBean}\" but retaining the result of its evaluation causes\nthe memory leak."}, {"count": 6, "tags": [], "bug_id": 33934, "attachment_id": null, "text": "NOTE:  I'm new to asf bugzilla, so please forgive any mis-use of this website and please let me know if \nthere is a better way for me to submit a request like this in the future!  :\\\n\n\nI am having the same problem (memory \"leak\") with this tag along with the c:forEach tag and I was \nwondering if there's any progress being made on this issue?  It appears from the last two comments \nand \nthis bug's state that this issue is still open.  I think Andreas' last post suggests a way to conform to the \nspec and still fix the memory leak.  From perusing the code for the forEach tag, I believe a similar \napproach can be used to solve the same problem.  The following \"rules\" (which are merely re-stating \nAndreas' last suggesting to something more general) could be applied to all tags in the jstl \nimplementation:\n\n1.  If a tag has a reference that is in the AttSet, only set it to null in the release() method.\n2.  Otherwise, set it to null at the end of doEndTag.\n\nThis would solve the memory leak that Andreas observed 2 years ago and it would solve the memroy \nleak I'm seeing in the forEach tag (there is a reference to \"item\" in the LoopTagSupport class that is not \nin the AttSet and keeping it around is causing my application some memory problems).\n", "id": 98010, "time": "2007-01-12T11:11:02Z", "creator": "tb-asfbugzilla@nixnerd.net", "creation_time": "2007-01-12T11:11:02Z", "is_private": false}, {"count": 7, "tags": [], "text": "Apologies for the delay in reply Tim.\n\nThis issue is one of the ones I've listed for trying to fix for a 1.1.3 release\n(slowly getting there). Patches are very welcomed - otherwise I'll slowly plod\nalong and hopefully get somewhere with it.\n\nThe specific one mentioned in Andreas' last comment sounds good to me, though\nI'm not planning to go through all of the tags. Currently I have:\n\nc:set - release 'target' in doEndTag\nc:forEach - release 'item' in doEndTag\n\n", "attachment_id": null, "bug_id": 33934, "id": 100995, "time": "2007-03-26T17:22:55Z", "creator": "bayard@apache.org", "creation_time": "2007-03-26T17:22:55Z", "is_private": false}, {"count": 8, "tags": [], "creator": "kschneider@gmail.com", "attachment_id": null, "is_private": false, "id": 100998, "time": "2007-03-26T19:53:45Z", "bug_id": 33934, "creation_time": "2007-03-26T19:53:45Z", "text": "(In reply to comment #7)\n> c:set - release 'target' in doEndTag\n> c:forEach - release 'item' in doEndTag\n\nBut you're not allowed to do that sort of thing in doEndTag, it's only valid for\nthe release method (which usually calls a private init method). However, even if\nthe properties are cleared by the release method, there's no guarantee as to\nwhen the container will call it, so it can still behave like a leak.\n\nI haven't looked at <c:forEach>, but the init method for <c:set> should at least\nset target and property to null (it already sets value to null).\n\nBeyond that, I can remember hacking something together that used reference\nobjects but also required implementing the TryCatchFinally interface. I'd have\nto double-check, but I think that would still maintain binary compatibility. The\nreal question is whether reference objects would violate the spec's definition\nof persistent:\n\nOnce properly set, all properties are expected to be persistent, so that if the\nJSP container ascertains that a property has already been set on a given tag\nhandler instance, it must not set it again.\n\nThe JSP container may reuse classic tag handler instances for multiple\noccurrences of the corresponding custom action, in the same page or in different\npages, but only if the same set of attributes are used for all occurrences. If a\ntag handler is used for more than one occurence, the container must reset all\nattributes where the values differ between the custom action occurrences.\nAttributes with the same value in all occurrences must not be reset. If an\nattribute value is set as a request-time attribute value (using a scripting or\nan EL expression), the container must reset the attribute between all reuses of\nthe tag handler instance."}, {"count": 9, "tags": [], "text": "The class org.apache.taglibs.standard.tag.el.core.SetTag (in 1.0.6) has two \nfields, \"_target\" and \"target\". The field \"_target\" is set by the setTarget \nmethod and contains the EL expression, e.g. \"${hugeBean}\". This field may not \nbe cleared between invocations because the container is allowed to cache tag \ninstances.\n\nThe other field \"target\" contains the result of the evaluation of the EL \nexpression of \"_target\" and is assigned a new value on each and every call to \ndoStartTag() which the container must call. So it makes no sense to keep the \nreference in \"target\".\n\nSame applies to the fields \"_value\" and \"value\".", "is_private": false, "id": 101013, "creation_time": "2007-03-27T00:39:22Z", "time": "2007-03-27T00:39:22Z", "creator": "av@tonbeller.com", "bug_id": 33934, "attachment_id": null}, {"count": 10, "tags": [], "text": "Tim's forEach problem would seem to be the one referred to in\nhttps://issues.apache.org/bugzilla/show_bug.cgi?id=25623.", "attachment_id": null, "id": 101060, "creation_time": "2007-03-27T12:03:24Z", "time": "2007-03-27T12:03:24Z", "creator": "bayard@apache.org", "bug_id": 33934, "is_private": false}, {"count": 11, "attachment_id": null, "creator": "bayard@apache.org", "is_private": false, "id": 101063, "time": "2007-03-27T12:15:30Z", "bug_id": 33934, "creation_time": "2007-03-27T12:15:30Z", "tags": [], "text": "My fix in https://issues.apache.org/bugzilla/show_bug.cgi?id=34896 should be\nlooked at too. Same concept of leakage, except in this case it was a connection\nnot closing."}, {"count": 12, "tags": [], "creator": "bayard@apache.org", "attachment_id": null, "is_private": false, "id": 107823, "time": "2007-09-07T07:44:02Z", "bug_id": 33934, "creation_time": "2007-09-07T07:44:02Z", "text": "\nLooking at SetSupport, its init() already sets target and property to null:\n\n    private void init() {\n        value = target = property = var = null;\n        scopeSpecified = valueSpecified = false;\n        scope = PageContext.PAGE_SCOPE;\n    }\n\nLooking at the JSTL LoopTagSupport, its init() sets item to null.\n\nSo the easy part of Kris' comment is already taken care of. \n\nAndreas points out that the attributes themselves are handled by target_,\nproperty_ etc in the EL SetTag and suggests the transient target, property etc\ncould be released. They're not in the RT SetTag though, so I presume we can't\nrelease them in the support class.\n\nie) Andreas' suggested change is the addition of a doEndTag method to EL SetTag\nand (presumably as it's simplest) a call to init() from it.\n\nLooking at the EL ForEachTag, the same could be done there.\n\nKris - is that still going to be against the spec?"}, {"count": 13, "tags": [], "bug_id": 33934, "attachment_id": null, "id": 107824, "time": "2007-09-07T08:42:44Z", "creator": "kschneider@gmail.com", "creation_time": "2007-09-07T08:42:44Z", "is_private": false, "text": "(In reply to comment #12)\n\nAre we thinking about making changes on the STANDARD_1_0_BRANCH branch (e.g. for\na 1.0.7 release)? That's the only place where changes to\norg.apache.taglibs.standard.tag.el.core.SetTag would make a difference. If we\nare, then I think we can safely reset value, target and property in doFinally -\nassuming that implementing TryCatchFinally maintains binary compatibility. This\n*only* applies to the EL version, not the RT version. Which means it *only*\napplies to Standard 1.0, not 1.1."}, {"count": 14, "tags": [], "creator": "bayard@apache.org", "attachment_id": null, "id": 107896, "time": "2007-09-09T00:54:34Z", "bug_id": 33934, "creation_time": "2007-09-09T00:54:34Z", "is_private": false, "text": "I hadn't realized that - so this is only a 1.0.x bug and not a 1.1.x bug?\n\nI don't think we've any intent to do a 1.0.7."}, {"count": 15, "tags": [], "text": "The bug that Andreas refers to in comment #5 and comment #9 is specific to 1.0.\n\nFor 1.1, the only thing I can see attempting is what I mentioned in comment #8:\n\nBeyond that, I can remember hacking something together that used reference\nobjects but also required implementing the TryCatchFinally interface.", "is_private": false, "id": 107975, "creation_time": "2007-09-10T10:20:00Z", "time": "2007-09-10T10:20:00Z", "creator": "kschneider@gmail.com", "bug_id": 33934, "attachment_id": null}, {"count": 16, "tags": [], "text": "It doesn't look to me like we'll be doing anything here for the 1.1.3 release.", "attachment_id": null, "bug_id": 33934, "id": 111534, "time": "2007-12-07T05:54:11Z", "creator": "bayard@apache.org", "creation_time": "2007-12-07T05:54:11Z", "is_private": false}, {"count": 17, "attachment_id": 26179, "creator": "jboynes@apache.org", "is_private": false, "id": 140776, "time": "2010-10-16T13:47:22Z", "bug_id": 33934, "creation_time": "2010-10-16T13:47:22Z", "tags": [], "text": "Created attachment 26179\nFix for memory leak in c:set\n\nThis would be a problem for all branches when a user still uses the old 1.0 tag libraries.\n\nPatch attached to refactor SetSupport to defer evaluation of the expressions until needed allowing only the attribute values to be retained (per the spec).\n\nPatch also switches to using the JSP container's EL evaluator and pre-parses the expressions (avoiding reparsing if the container is pooling tags)."}, {"count": 18, "tags": [], "creator": "jboynes@apache.org", "attachment_id": null, "id": 140956, "time": "2010-10-23T14:00:32Z", "bug_id": 33934, "creation_time": "2010-10-23T14:00:32Z", "is_private": false, "text": "Fix in 1.2 standard-jstlel"}]