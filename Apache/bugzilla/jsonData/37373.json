[{"count": 0, "attachment_id": null, "creator": "stoddard@apache.org", "is_private": false, "id": 82156, "time": "2005-11-06T14:57:10Z", "bug_id": 37373, "creation_time": "2005-11-06T14:57:10Z", "tags": [], "text": "This patch is a backport of persistent connection support for mod_proxy from\nv2.0.  The port was performed by Sean C Farley <sean-apache@farley.org> when he\nwas employed by IBM. The patch is against 1.3.27 (yes, this patch is old and dusty).\n\ndiff -ru apache_1.3.27/src/include/http_config.h mod/src/include/http_config.h\n--- apache_1.3.27/src/include/http_config.h\tWed Mar 13 15:05:29 2002\n+++ mod/src/include/http_config.h\tMon Mar  3 11:13:46 2003\n@@ -354,6 +354,7 @@\n API_EXPORT(void) ap_init_modules(pool *p, server_rec *s);\n API_EXPORT(void) ap_child_init_modules(pool *p, server_rec *s);\n API_EXPORT(void) ap_child_exit_modules(pool *p, server_rec *s);\n+CORE_EXPORT(void *) ap_create_conn_config(pool *p);\n API_EXPORT(void) ap_setup_prelinked_modules(void);\n API_EXPORT(void) ap_show_directives(void);\n API_EXPORT(void) ap_show_modules(void);\ndiff -ru apache_1.3.27/src/include/httpd.h mod/src/include/httpd.h\n--- apache_1.3.27/src/include/httpd.h\tMon Sep 30 11:35:21 2002\n+++ mod/src/include/httpd.h\tFri Apr  4 14:34:45 2003\n@@ -698,7 +698,7 @@\n \n     char *the_request;\t\t/* First line of request, so we can log it */\n     int assbackwards;\t\t/* HTTP/0.9, \"simple\" request */\n-    enum proxyreqtype proxyreq;/* A proxy request (calculated during\n+    enum proxyreqtype proxyreq;\t/* A proxy request (calculated during\n \t\t\t\t * post_read_request or translate_name) */\n     int header_only;\t\t/* HEAD request, as opposed to GET */\n     char *protocol;\t\t/* Protocol, as given to us, or HTTP/0.9 */\n@@ -894,6 +894,12 @@\n     char *local_host;\t\t/* used for ap_get_server_name when\n \t\t\t\t * UseCanonicalName is set to DNS\n \t\t\t\t * (ignores setting of HostnameLookups) */\n+\n+    void *conn_config;\t\t/* Notes on *this* connection */\n+    /* The 'notes' table is for notes from one module to another, with no\n+     * other set purpose in mind...\n+     */\n+    table *notes;\n };\n \n /* Per-vhost config... */\ndiff -ru apache_1.3.27/src/main/http_config.c mod/src/main/http_config.c\n--- apache_1.3.27/src/main/http_config.c\tMon Sep 30 06:17:40 2002\n+++ mod/src/main/http_config.c\tMon Mar  3 11:10:09 2003\n@@ -216,6 +216,11 @@\n     return create_empty_config(p);\n }\n \n+CORE_EXPORT(void *) ap_create_conn_config(pool *p)\n+{\n+    return create_empty_config(p);\n+}\n+\n CORE_EXPORT(void *) ap_create_per_dir_config(pool *p)\n {\n     return create_empty_config(p);\ndiff -ru apache_1.3.27/src/main/http_main.c mod/src/main/http_main.c\n--- apache_1.3.27/src/main/http_main.c\tFri Sep 27 12:40:24 2002\n+++ mod/src/main/http_main.c\tMon Mar  3 11:30:12 2003\n@@ -3562,6 +3562,8 @@\n     /* Got a connection structure, so initialize what fields we can\n      * (the rest are zeroed out by pcalloc).\n      */\n+    conn->conn_config = ap_create_conn_config(p);\n+    conn->notes = ap_make_table(p, 5);\n \n     conn->child_num = child_num;\n \ndiff -ru apache_1.3.27/src/modules/proxy/mod_proxy.h\nmod/src/modules/proxy/mod_proxy.h\n--- apache_1.3.27/src/modules/proxy/mod_proxy.h\tSun Apr 21 06:35:07 2002\n+++ mod/src/modules/proxy/mod_proxy.h\tFri Apr  4 17:16:35 2003\n@@ -205,6 +205,19 @@\n     char io_buffer_size_set;\n } proxy_server_conf;\n \n+typedef struct {\n+    conn_rec *connection;\n+    char *hostname;\n+    unsigned short port;\n+    BUFF *sock;\n+} proxy_conn_rec;\n+\n+typedef struct {\n+    const char     *name;\n+    unsigned short  port;\n+    int             close;              /* Close connection indicator */\n+} proxy_http_conn_t;\n+\n struct hdr_entry {\n     const char *field;\n     const char *value;\n@@ -282,6 +295,13 @@\n \n /* proxy_http.c */\n \n+int ap_proxy_http_create_connection(pool *p, request_rec *r,\n+                                    proxy_http_conn_t *p_conn, conn_rec *conn,\n+                                    proxy_conn_rec *backend,\n+                                    proxy_server_conf *conf,\n+                                    const char *proxyhost, BUFF **f,\n+                                    struct hostent *server_hp,\n+                                    struct sockaddr_in *server);\n int ap_proxy_http_canon(request_rec *r, char *url, const char *scheme,\n                      int def_port);\n int ap_proxy_http_handler(request_rec *r, cache_req *c, char *url,\ndiff -ru apache_1.3.27/src/modules/proxy/proxy_http.c\nmod/src/modules/proxy/proxy_http.c\n--- apache_1.3.27/src/modules/proxy/proxy_http.c\tTue Sep  3 02:12:46 2002\n+++ mod/src/modules/proxy/proxy_http.c\tThu Apr 10 16:58:12 2003\n@@ -64,6 +64,8 @@\n #include \"http_core.h\"\n #include \"util_date.h\"\n \n+module MODULE_VAR_EXPORT proxy_http_module;\n+\n /*\n  * Canonicalise http-like URLs.\n  *  scheme is the scheme for the URL\n@@ -114,6 +116,353 @@\n     return OK;\n }\n \n+int ap_proxy_http_create_connection(pool *p,\n+                                    request_rec *r,\n+                                    proxy_http_conn_t *p_conn,\n+                                    conn_rec *conn,\n+                                    proxy_conn_rec *backend,\n+                                    proxy_server_conf *conf,\n+                                    const char *proxyhost,\n+                                    BUFF **f,\n+                                    struct hostent *server_hp,\n+                                    struct sockaddr_in *server)\n+{\n+    int i, j, sock;\n+\n+    /* if a keepalive socket is already open, check whether it must stay\n+     * open, or whether it should be closed and a new socket created.\n+     */\n+    if (backend->connection)\n+    {\n+        *f = backend->sock;\n+        /*\n+         * Only GET/HEAD requests are re-used.  The reasoning behind this is\n+         * that the proxy does not save the data sent from the client within a\n+         * POST.  If an existing connection is closed by the backend while\n+         * POST'd data is being sent to the backend, the data is lost and canoot\n+         * be resent.  This would result in a 502 being sent back to the client.\n+         *\n+         * It is safer to just close the connection and create a new one to\n+         * avoid a timeout by the server.  This will prevent 502's being issued\n+         * because of connection timeouts.\n+         */\n+        if (r->method_number != M_GET)\n+        {\n+            ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO,\n+                         r->server,\n+                         \"proxy: non-GET/HEAD request.  Closing connection\");\n+            ap_bclose(*f);\n+            backend->connection = NULL;\n+        }\n+        else if ((backend->connection->child_num == conn->child_num) &&\n+                 (backend->port == p_conn->port) &&\n+                 (backend->hostname) &&\n+                 (!strcasecmp(backend->hostname, p_conn->name)))\n+        {\n+            fd_set fds;\n+            struct timeval tv;\n+\n+            ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server,\n+                         \"proxy: keepalive address match \"\n+                         \"(keep original socket)\");\n+            /*\n+             * Verify connection to backend is still alive.\n+             *\n+             * If the connection is readable, there is either leftover data on\n+             * the connection (should not be) or an EOF from the server.\n+             */\n+            do\n+            {\n+                FD_ZERO(&fds);\n+                FD_SET((*f)->fd_in, &fds);\n+                tv.tv_sec = 0;\n+                tv.tv_usec = 0;\n+                i = ap_select((*f)->fd_in + 1, &fds, NULL, NULL, &tv);\n+            } while (i < 0 && errno == EINTR && !((*f)->flags & B_EOUT));\n+            if (FD_ISSET((*f)->fd_in, &fds))\n+            {\n+                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO,\n+                             r->server,\n+                             \"proxy: previous connection is closed\");\n+                ap_bclose(*f);\n+                backend->connection = NULL;\n+            }\n+        }\n+        else\n+        {\n+            ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server,\n+                         \"proxy: keepalive address mismatch / connection has\"\n+                         \" changed (close old socket (%s/%s, %d/%d))\",\n+                         p_conn->name, backend->hostname, p_conn->port, \n+                         backend->port);\n+            ap_bclose(*f);\n+            backend->connection = NULL;\n+        }\n+    }\n+\n+    /* Make connection to backend. */\n+    if (!backend->connection)\n+    {\n+        /*\n+         * we have worked out who exactly we are going to connect to, now make\n+         * that connection...\n+         */\n+        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server,\n+                     \"proxy: creating connection to backend\");\n+        sock = ap_psocket(p, PF_INET, SOCK_STREAM, IPPROTO_TCP);\n+        if (sock == -1)\n+        {\n+            ap_log_rerror(APLOG_MARK, APLOG_ERR, r,\n+                          \"proxy: error creating socket\");\n+            return HTTP_INTERNAL_SERVER_ERROR;\n+        }\n+\n+#if !defined(TPF) && !defined(BEOS)\n+        if (conf->recv_buffer_size)\n+        {\n+            if (setsockopt(sock, SOL_SOCKET, SO_RCVBUF,\n+                           (const char *)&conf->recv_buffer_size, sizeof(int))\n+                == -1)\n+            {\n+                ap_log_rerror(APLOG_MARK, APLOG_ERR, r,\n+                              \"setsockopt(SO_RCVBUF): Failed to set\nProxyReceiveBufferSize, using default\");\n+            }\n+        }\n+#endif\n+\n+        /* Initialize.  Start out as an error. */\n+        i = -1;\n+\n+#ifdef SINIX_D_RESOLVER_BUG\n+        {\n+            struct in_addr *ip_addr = (struct in_addr *)*server_hp->h_addr_list;\n+\n+            for (; ip_addr->s_addr != 0; ++ip_addr)\n+            {\n+                memcpy(&server->sin_addr, ip_addr, sizeof(struct in_addr));\n+                i = ap_proxy_doconnect(sock, server, r);\n+                if (i == 0)\n+                    break;\n+            }\n+        }\n+#else\n+        j = 0;\n+        while (server_hp->h_addr_list[j] != NULL)\n+        {\n+            memcpy(&server->sin_addr, server_hp->h_addr_list[j],\n+                   sizeof(struct in_addr));\n+            i = ap_proxy_doconnect(sock, server, r);\n+            if (i == 0)\n+                break;\n+            j++;\n+        }\n+#endif\n+        if (i == -1)\n+        {\n+            if (proxyhost != NULL)\n+                return DECLINED;    /* try again another way */\n+            else\n+                return ap_proxyerror(r, HTTP_BAD_GATEWAY, ap_pstrcat(r->pool,\n+                                                                     \"Could not\nconnect to remote machine: \",\n+                                                                    \nstrerror(errno), NULL));\n+        }\n+\n+        /*\n+         * At this point, we start sending the HTTP/1.1 request to the remote\n+         * server (proxy or otherwise).\n+         */\n+        *f = ap_bcreate(p, B_RDWR | B_SOCKET);\n+        ap_bpushfd(*f, sock, sock);\n+\n+        backend->connection = conn;\n+        backend->hostname = ap_pstrdup(p, p_conn->name);\n+        backend->port = p_conn->port;\n+        backend->sock = *f;\n+    }\n+\n+    return OK;\n+}\n+\n+void ap_proxy_http_build_request(pool *p,\n+                                 request_rec *r,\n+                                 proxy_http_conn_t *p_conn,\n+                                 const char *url,\n+                                 const char *desthost,\n+                                 const char *destportstr,\n+                                 proxy_server_conf *conf,\n+                                 table **req_hdrs,\n+                                 char **requestLine)\n+{\n+    int i;\n+    char portstr[32];\n+\n+    /*\n+     * build upstream-request headers by stripping r->headers_in from\n+     * connection specific headers. We must not remove the Connection: header\n+     * from r->headers_in, we still have to react to Connection: close\n+     */\n+    *req_hdrs = ap_copy_table(r->pool, r->headers_in);\n+    ap_proxy_clear_connection(r->pool, *req_hdrs);\n+\n+    if (conf->viaopt == via_block) {\n+        /* Block all outgoing Via: headers */\n+        ap_table_unset(*req_hdrs, \"Via\");\n+    }\n+    else if (conf->viaopt != via_off) {\n+        /* Create a \"Via:\" request header entry and merge it */\n+        i = ap_get_server_port(r);\n+        if (ap_is_default_port(i, r)) {\n+            strcpy(portstr, \"\");\n+        }\n+        else {\n+            ap_snprintf(portstr, sizeof portstr, \":%d\", i);\n+        }\n+        /* Generate outgoing Via: header with/without server comment: */\n+        ap_table_mergen(*req_hdrs, \"Via\",\n+                        (conf->viaopt == via_full)\n+                        ? ap_psprintf(p, \"%d.%d %s%s (%s)\",\n+                                      HTTP_VERSION_MAJOR(r->proto_num),\n+                                      HTTP_VERSION_MINOR(r->proto_num),\n+                                      ap_get_server_name(r), portstr,\n+                                      SERVER_BASEVERSION)\n+                        : ap_psprintf(p, \"%d.%d %s%s\",\n+                                      HTTP_VERSION_MAJOR(r->proto_num),\n+                                      HTTP_VERSION_MINOR(r->proto_num),\n+                                      ap_get_server_name(r), portstr)\n+            );\n+    }\n+\n+    /* the X-* headers are only added if we are a reverse\n+     * proxy, otherwise we would be giving away private information.\n+     */\n+    if (r->proxyreq == PROXY_PASS) {\n+        const char *buf;\n+\n+        /*\n+         * Add X-Forwarded-For: so that the upstream has a chance to determine,\n+         * where the original request came from.\n+         */\n+        ap_table_mergen(*req_hdrs, \"X-Forwarded-For\", r->connection->remote_ip);\n+\n+        /* Add X-Forwarded-Host: so that upstream knows what the\n+         * original request hostname was.\n+         */\n+        if ((buf = ap_table_get(r->headers_in, \"Host\"))) {\n+            ap_table_mergen(*req_hdrs, \"X-Forwarded-Host\", buf);\n+        }\n+\n+        /* Add X-Forwarded-Server: so that upstream knows what the\n+         * name of this proxy server is (if there are more than one)\n+         * XXX: This duplicates Via: - do we strictly need it?\n+         */\n+        ap_table_mergen(*req_hdrs, \"X-Forwarded-Server\",\nr->server->server_hostname);\n+    } \n+\n+    /* sub-requests never use keepalives */\n+    if ((ap_proxy_liststr(ap_table_get(r->headers_in, \"Connection\"),\n+                          \"close\", NULL)) ||\n+        (r->main))\n+    {\n+        p_conn->close = 1;\n+        ap_table_set(*req_hdrs, \"Connection\", \"close\");\n+    }\n+\n+    if (destportstr)\n+    {\n+        *requestLine = ap_pstrcat(p, r->method, \" \", url, \" HTTP/1.1\", CRLF,\n+                                  \"Host: \", desthost, \":\", destportstr, CRLF,\n+                                  NULL);\n+    }\n+    else\n+    {\n+        *requestLine = ap_pstrcat(p, r->method, \" \", url, \" HTTP/1.1\", CRLF,\n+                                  \"Host: \", desthost, CRLF, NULL);\n+    }\n+\n+    return;\n+}\n+\n+void ap_proxy_http_send_request(BUFF *f,\n+                                request_rec *r,\n+                                table *req_hdrs,\n+                                const char *requestLine)\n+{\n+    int i;\n+    array_header *reqhdrs_arr = ap_table_elts(req_hdrs);\n+    table_entry *reqhdrs_elts = (table_entry *)reqhdrs_arr->elts;\n+\n+    ap_hard_timeout(\"proxy send\", r);\n+    ap_bvputs(f, requestLine, NULL);\n+    for (i = 0; i < reqhdrs_arr->nelts; i++) {\n+        if (reqhdrs_elts[i].key == NULL || reqhdrs_elts[i].val == NULL\n+\n+        /*\n+         * Clear out hop-by-hop request headers not to send: RFC2616 13.5.1\n+         * says we should strip these headers:\n+         */\n+            || !strcasecmp(reqhdrs_elts[i].key, \"Host\") /* Already sent */\n+            || !strcasecmp(reqhdrs_elts[i].key, \"Keep-Alive\")\n+            || !strcasecmp(reqhdrs_elts[i].key, \"TE\")\n+            || !strcasecmp(reqhdrs_elts[i].key, \"Trailer\")\n+            || !strcasecmp(reqhdrs_elts[i].key, \"Transfer-Encoding\")\n+            || !strcasecmp(reqhdrs_elts[i].key, \"Upgrade\")\n+        /*\n+         * XXX: @@@ FIXME: \"Proxy-Authorization\" should *only* be suppressed\n+         * if THIS server requested the authentication, not when a frontend\n+         * proxy requested it!\n+         * \n+         * The solution to this problem is probably to strip out the\n+         * Proxy-Authorisation header in the authorisation code itself, not\n+         * here. This saves us having to signal somehow whether this request\n+         * was authenticated or not.\n+         */\n+            || !strcasecmp(reqhdrs_elts[i].key, \"Proxy-Authorization\"))\n+            continue;\n+\n+        /* for sub-requests, ignore freshness/expiry headers */\n+        if (r->main) {\n+            if (reqhdrs_elts[i].key == NULL || reqhdrs_elts[i].val == NULL\n+                || !strcasecmp(reqhdrs_elts[i].key, \"If-Match\")\n+                || !strcasecmp(reqhdrs_elts[i].key, \"If-Modified-Since\")\n+                || !strcasecmp(reqhdrs_elts[i].key, \"If-Range\")\n+                || !strcasecmp(reqhdrs_elts[i].key, \"If-Unmodified-Since\")\n+                || !strcasecmp(reqhdrs_elts[i].key, \"If-None-Match\")) {\n+                continue;\n+            }\n+\n+            /* If you POST to a page that gets server-side parsed\n+             * by mod_include, and the parsing results in a reverse\n+             * proxy call, the proxied request will be a GET, but\n+             * its request_rec will have inherited the Content-Length\n+             * of the original request (the POST for the enclosing\n+             * page).  We can't send the original POST's request body\n+             * as part of the proxied subrequest, so we need to avoid\n+             * sending the corresponding content length.  Otherwise,\n+             * the server to which we're proxying will sit there\n+             * forever, waiting for a request body that will never\n+             * arrive.\n+             */\n+            if ((r->method_number == M_GET) && reqhdrs_elts[i].key &&\n+                !strcasecmp(reqhdrs_elts[i].key, \"Content-Length\")) {\n+                continue;\n+            }\n+        }\n+\n+        ap_bvputs(f, reqhdrs_elts[i].key, \": \", reqhdrs_elts[i].val, CRLF, NULL);\n+    }\n+\n+    /* the obligatory empty line to mark the end of the headers */\n+    ap_bputs(CRLF, f);\n+\n+    /* and flush the above away */\n+    ap_bflush(f);\n+\n+    /* and kill the send timeout */\n+    ap_kill_timeout(r);\n+\n+    return;\n+}\n+\n /* handle the conversion of URLs in the ProxyPassReverse function */\n static const char *proxy_location_reverse_map(request_rec *r, const char *url)\n {\n@@ -152,24 +501,28 @@\n     const char *strp;\n     char *strp2;\n     const char *err, *desthost;\n-    int i, j, sock,/* len,*/ backasswards;\n+    int i, /* len,*/ backasswards;\n     table *req_hdrs, *resp_hdrs;\n-    array_header *reqhdrs_arr;\n-    table_entry *reqhdrs_elts;\n     struct sockaddr_in server;\n     struct in_addr destaddr;\n     struct hostent server_hp;\n-    BUFF *f;\n+    BUFF *f = NULL;\n     char buffer[HUGE_STRING_LEN];\n     char portstr[32];\n-    pool *p = r->pool;\n+    conn_rec *conn = r->connection;\n+    pool *p = conn->pool;\n+    /* Previous connection information to downstream. */\n+    proxy_conn_rec *backend = NULL;\n     int destport = 0;\n     int chunked = 0;\n     char *destportstr = NULL;\n     const char *urlptr = NULL;\n+    char *requestLine;\n     const char *datestr, *urlstr;\n-    int result, major, minor;\n+    int result = 0;\n+    int major, minor;\n     const char *content_length;\n+    int connectAttempts;\n \n     void *sconf = r->server->module_config;\n     proxy_server_conf *conf =\n@@ -178,6 +531,29 @@\n     struct nocache_entry *ncent = (struct nocache_entry *) conf->nocaches->elts;\n     int nocache = 0;\n \n+    /* Current connection information to downstream. */\n+    proxy_http_conn_t *p_conn = ap_pcalloc(p, sizeof(*p_conn));\n+\n+    /* only use stored info for top-level pages. Sub requests don't share \n+     * in keepalives\n+     */\n+    if (!r->main) {\n+        backend = (proxy_conn_rec *) ap_get_module_config(conn->conn_config,\n+                                                          &proxy_http_module);\n+    }\n+\n+    /* create space for state information */\n+    if (!backend) {\n+        backend = ap_pcalloc(p, sizeof(*backend));\n+        backend->connection = NULL;\n+        backend->hostname = NULL;\n+        backend->port = 0;\n+        if (!r->main) {\n+            ap_set_module_config(conn->conn_config, &proxy_http_module,\n+                                 backend);\n+        }\n+    }\n+\n     if (conf->cache.root == NULL)\n         nocache = 1;\n \n@@ -224,195 +600,95 @@\n     }\n \n     if (proxyhost != NULL) {\n+        p_conn->port = proxyport;\n+        p_conn->name = proxyhost;\n         server.sin_port = htons((unsigned short)proxyport);\n         err = ap_proxy_host2addr(proxyhost, &server_hp);\n         if (err != NULL)\n             return DECLINED;    /* try another */\n     }\n     else {\n+        p_conn->port = destport;\n+        p_conn->name = desthost;\n         server.sin_port = htons((unsigned short)destport);\n         err = ap_proxy_host2addr(desthost, &server_hp);\n         if (err != NULL)\n             return ap_proxyerror(r, HTTP_INTERNAL_SERVER_ERROR, err);\n     }\n \n-\n-    /*\n-     * we have worked out who exactly we are going to connect to, now make\n-     * that connection...\n-     */\n-    sock = ap_psocket(p, PF_INET, SOCK_STREAM, IPPROTO_TCP);\n-    if (sock == -1) {\n-        ap_log_rerror(APLOG_MARK, APLOG_ERR, r,\n-                      \"proxy: error creating socket\");\n-        return HTTP_INTERNAL_SERVER_ERROR;\n-    }\n-\n-#if !defined(TPF) && !defined(BEOS)\n-    if (conf->recv_buffer_size) {\n-        if (setsockopt(sock, SOL_SOCKET, SO_RCVBUF,\n-                       (const char *)&conf->recv_buffer_size, sizeof(int))\n-            == -1) {\n-            ap_log_rerror(APLOG_MARK, APLOG_ERR, r,\n-                          \"setsockopt(SO_RCVBUF): Failed to set\nProxyReceiveBufferSize, using default\");\n-        }\n-    }\n-#endif\n-\n-#ifdef SINIX_D_RESOLVER_BUG\n-    {\n-        struct in_addr *ip_addr = (struct in_addr *)*server_hp.h_addr_list;\n-\n-        for (; ip_addr->s_addr != 0; ++ip_addr) {\n-            memcpy(&server.sin_addr, ip_addr, sizeof(struct in_addr));\n-            i = ap_proxy_doconnect(sock, &server, r);\n-            if (i == 0)\n-                break;\n-        }\n-    }\n-#else\n-    j = 0;\n-    while (server_hp.h_addr_list[j] != NULL) {\n-        memcpy(&server.sin_addr, server_hp.h_addr_list[j],\n-               sizeof(struct in_addr));\n-        i = ap_proxy_doconnect(sock, &server, r);\n-        if (i == 0)\n-            break;\n-        j++;\n-    }\n-#endif\n-    if (i == -1) {\n-        if (proxyhost != NULL)\n-            return DECLINED;    /* try again another way */\n-        else\n-            return ap_proxyerror(r, HTTP_BAD_GATEWAY, ap_pstrcat(r->pool,\n-                                    \"Could not connect to remote machine: \",\n-                                                    strerror(errno), NULL));\n-    }\n+    /* Build request. */\n+    ap_proxy_http_build_request(p, r, p_conn, proxyhost ? url : urlptr,\n+                                desthost, (destport != DEFAULT_HTTP_PORT ?\n+                                           destportstr : NULL), conf, &req_hdrs,\n+                                &requestLine);\n \n     /* record request_time for HTTP/1.1 age calculation */\n     c->req_time = time(NULL);\n \n     /*\n-     * build upstream-request headers by stripping r->headers_in from\n-     * connection specific headers. We must not remove the Connection: header\n-     * from r->headers_in, we still have to react to Connection: close\n-     */\n-    req_hdrs = ap_copy_table(r->pool, r->headers_in);\n-    ap_proxy_clear_connection(r->pool, req_hdrs);\n-\n-    /*\n-     * At this point, we start sending the HTTP/1.1 request to the remote\n-     * server (proxy or otherwise).\n+     * Make connection (hopefully verified) to backend.  Only GET's are actually\n+     * verified.\n      */\n-    f = ap_bcreate(p, B_RDWR | B_SOCKET);\n-    ap_bpushfd(f, sock, sock);\n-\n-    ap_hard_timeout(\"proxy send\", r);\n-    ap_bvputs(f, r->method, \" \", proxyhost ? url : urlptr, \" HTTP/1.1\" CRLF,\n-              NULL);\n-    /* Send Host: now, adding it to req_hdrs wouldn't be much better */\n-    if (destportstr != NULL && destport != DEFAULT_HTTP_PORT)\n-        ap_bvputs(f, \"Host: \", desthost, \":\", destportstr, CRLF, NULL);\n-    else\n-        ap_bvputs(f, \"Host: \", desthost, CRLF, NULL);\n-\n-    if (conf->viaopt == via_block) {\n-        /* Block all outgoing Via: headers */\n-        ap_table_unset(req_hdrs, \"Via\");\n+    if (r->method_number == M_GET)\n+    {\n+        connectAttempts = 2;\n     }\n-    else if (conf->viaopt != via_off) {\n-        /* Create a \"Via:\" request header entry and merge it */\n-        i = ap_get_server_port(r);\n-        if (ap_is_default_port(i, r)) {\n-            strcpy(portstr, \"\");\n-        }\n-        else {\n-            ap_snprintf(portstr, sizeof portstr, \":%d\", i);\n-        }\n-        /* Generate outgoing Via: header with/without server comment: */\n-        ap_table_mergen(req_hdrs, \"Via\",\n-                        (conf->viaopt == via_full)\n-                        ? ap_psprintf(p, \"%d.%d %s%s (%s)\",\n-                                      HTTP_VERSION_MAJOR(r->proto_num),\n-                                      HTTP_VERSION_MINOR(r->proto_num),\n-                                      ap_get_server_name(r), portstr,\n-                                      SERVER_BASEVERSION)\n-                        : ap_psprintf(p, \"%d.%d %s%s\",\n-                                      HTTP_VERSION_MAJOR(r->proto_num),\n-                                      HTTP_VERSION_MINOR(r->proto_num),\n-                                      ap_get_server_name(r), portstr)\n-            );\n+    else\n+    {\n+        connectAttempts = 0;\n     }\n+    do\n+    {\n+        /* Perform this test only one time. */\n+        connectAttempts--;\n \n-    /* the X-* headers are only added if we are a reverse\n-     * proxy, otherwise we would be giving away private information.\n-     */\n-    if (r->proxyreq == PROXY_PASS) {\n-        const char *buf;\n-\n-        /*\n-         * Add X-Forwarded-For: so that the upstream has a chance to determine,\n-         * where the original request came from.\n-         */\n-        ap_table_mergen(req_hdrs, \"X-Forwarded-For\", r->connection->remote_ip);\n-\n-        /* Add X-Forwarded-Host: so that upstream knows what the\n-         * original request hostname was.\n-         */\n-        if ((buf = ap_table_get(r->headers_in, \"Host\"))) {\n-            ap_table_mergen(req_hdrs, \"X-Forwarded-Host\", buf);\n+        /* Make connection to backend. */\n+        result = ap_proxy_http_create_connection(p, r, p_conn, conn, backend,\n+                                                 conf, proxyhost, &f,\n+                                                 &server_hp, &server);\n+        if (result != OK)\n+        {\n+            return result;\n         }\n \n-        /* Add X-Forwarded-Server: so that upstream knows what the\n-         * name of this proxy server is (if there are more than one)\n-         * XXX: This duplicates Via: - do we strictly need it?\n-         */\n-        ap_table_mergen(req_hdrs, \"X-Forwarded-Server\",\nr->server->server_hostname);\n-    } \n-\n-    /* we don't yet support keepalives - but we will soon, I promise! */\n-    ap_table_set(req_hdrs, \"Connection\", \"close\");\n-\n-    reqhdrs_arr = ap_table_elts(req_hdrs);\n-    reqhdrs_elts = (table_entry *)reqhdrs_arr->elts;\n-    for (i = 0; i < reqhdrs_arr->nelts; i++) {\n-        if (reqhdrs_elts[i].key == NULL || reqhdrs_elts[i].val == NULL\n+        /* Send request. */\n+        ap_proxy_http_send_request(f, r, req_hdrs, requestLine);\n \n         /*\n-         * Clear out hop-by-hop request headers not to send: RFC2616 13.5.1\n-         * says we should strip these headers:\n+         * Verify that server has not timed-out on us.  If it has, then try once\n+         * more with a new connection.  This only works on GET requests.\n          */\n-            || !strcasecmp(reqhdrs_elts[i].key, \"Host\") /* Already sent */\n-            || !strcasecmp(reqhdrs_elts[i].key, \"Keep-Alive\")\n-            || !strcasecmp(reqhdrs_elts[i].key, \"TE\")\n-            || !strcasecmp(reqhdrs_elts[i].key, \"Trailer\")\n-            || !strcasecmp(reqhdrs_elts[i].key, \"Transfer-Encoding\")\n-            || !strcasecmp(reqhdrs_elts[i].key, \"Upgrade\")\n-        /*\n-         * XXX: @@@ FIXME: \"Proxy-Authorization\" should *only* be suppressed\n-         * if THIS server requested the authentication, not when a frontend\n-         * proxy requested it!\n-         * \n-         * The solution to this problem is probably to strip out the\n-         * Proxy-Authorisation header in the authorisation code itself, not\n-         * here. This saves us having to signal somehow whether this request\n-         * was authenticated or not.\n-         */\n-            || !strcasecmp(reqhdrs_elts[i].key, \"Proxy-Authorization\"))\n-            continue;\n-        ap_bvputs(f, reqhdrs_elts[i].key, \": \", reqhdrs_elts[i].val, CRLF, NULL);\n-    }\n-\n-    /* the obligatory empty line to mark the end of the headers */\n-    ap_bputs(CRLF, f);\n+        if (r->method_number == M_GET)\n+        {\n+            /*\n+             * Grab the response line.  It doubles as a test of connectivity to\n+             * the server.\n+             */\n+            ap_hard_timeout(\"proxy receive response status line\", r);\n+            result = ap_proxy_read_response_line(f, r, buffer, sizeof(buffer),\n+                                                 &backasswards, &major, &minor);\n+            ap_kill_timeout(r);\n \n-    /* and flush the above away */\n-    ap_bflush(f);\n-\n-    /* and kill the send timeout */\n-    ap_kill_timeout(r);\n+            if (result != OK)\n+            {\n+                if (connectAttempts > 0)\n+                {\n+                    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO,\n+                                 r->server,\n+                                 \"proxy: previous connection is closed\");\n+                    ap_bclose(f);\n+                    backend->connection = NULL;\n+                }\n+                else\n+                {\n+                    ap_bclose(f);\n+                    backend->connection = NULL;\n \n+                    return (result);\n+                }\n+            }\n+        }\n+    } while (result != OK);\n \n     /* read the request data, and pass it to the backend.\n      * we might encounter a stray 100-continue reponse from a PUT or POST,\n@@ -420,46 +696,52 @@\n      * response again.\n      */\n     {\n-        /* send the request data, if any. */\n-        ap_hard_timeout(\"proxy receive request data\", r);\n-        if (ap_should_client_block(r)) {\n-            while ((i = ap_get_client_block(r, buffer, sizeof buffer)) > 0) {\n-                ap_reset_timeout(r);\n-                ap_bwrite(f, buffer, i);\n+        if (r->method_number != M_GET)\n+        {\n+            /* send the request data, if any. */\n+            ap_hard_timeout(\"proxy receive request data\", r);\n+            if (ap_should_client_block(r)) {\n+                while ((i = ap_get_client_block(r, buffer, sizeof buffer)) > 0)\n+                {\n+                    ap_reset_timeout(r);\n+                    ap_bwrite(f, buffer, i);\n+                }\n             }\n-        }\n-        ap_bflush(f);\n-        ap_kill_timeout(r);\n-\n+            ap_bflush(f);\n+            ap_kill_timeout(r);\n \n-        /* then, read a response line */\n-        ap_hard_timeout(\"proxy receive response status line\", r);\n-        result = ap_proxy_read_response_line(f, r, buffer, sizeof(buffer)-1,\n&backasswards, &major, &minor);\n-        ap_kill_timeout(r);\n+            /* then, read a response line */\n+            ap_hard_timeout(\"proxy receive response status line\", r);\n+            result = ap_proxy_read_response_line(f, r, buffer, sizeof(buffer),\n+                                                 &backasswards, &major, &minor);\n+            ap_kill_timeout(r);\n \n-        /* trap any errors */\n-        if (result != OK) {\n-            ap_bclose(f);\n-            return result;\n+            /* trap any errors */\n+            if (result != OK) {\n+                ap_bclose(f);\n+                backend->connection = NULL;\n+                return result;\n+            }\n         }\n \n         /* if this response was 100-continue, a stray response has been caught.\n          * read the line again for the real response\n          */\n-        if (r->status == 100) {\n+        if (r->status == HTTP_CONTINUE) {\n             ap_hard_timeout(\"proxy receive response status line\", r);\n-            result = ap_proxy_read_response_line(f, r, buffer,\nsizeof(buffer)-1, &backasswards, &major, &minor);\n+            result = ap_proxy_read_response_line(f, r, buffer, sizeof(buffer),\n+                                                 &backasswards, &major, &minor);\n             ap_kill_timeout(r);\n \n             /* trap any errors */\n             if (result != OK) {\n                 ap_bclose(f);\n+                backend->connection = NULL;\n                 return result;\n             }\n         }\n     }\n \n-\n     /*\n      * We have our response status line from the convoluted code above,\n      * now we read the headers to continue.\n@@ -512,6 +794,16 @@\n                                      ap_table_get(resp_hdrs, \"Transfer-Encoding\"),\n                                      \"chunked\");\n \n+        /* Will the backend close the connection on us? */\n+        if (ap_proxy_liststr(ap_table_get(resp_hdrs, \"Connection\"),\n+                             \"close\", NULL) ||\n+            ((major == 1) && (minor == 0) &&\n+             !ap_proxy_liststr(ap_table_get(resp_hdrs, \"Connection\"),\n+                               \"keep-alive\", NULL)))\n+        {\n+            p_conn->close = 1;\n+        }\n+\n         /* strip hop-by-hop headers defined by Connection and RFC2616 */\n         ap_proxy_clear_connection(p, resp_hdrs);\n \n@@ -526,6 +818,9 @@\n \n         /* no headers */\n         resp_hdrs = ap_make_table(p, 20);\n+\n+        /* Connection will close. */\n+        p_conn->close = 1;\n     }\n \n     ap_kill_timeout(r);\n@@ -573,6 +868,7 @@\n         i = ap_proxy_cache_update(c, resp_hdrs, !backasswards, nocache);\n         if (i != DECLINED) {\n             ap_bclose(f);\n+            backend->connection = NULL;\n             return i;\n         }\n \n@@ -630,7 +926,12 @@\n /* HTTP/1.0 tells us to read to EOF, rather than content-length bytes */\n /* XXX CHANGEME: We want to eventually support keepalives, which means\n  * we must read content-length bytes... */\n-    if (!r->header_only) {\n+    if ((!r->header_only) &&\n+        (r->status >= HTTP_OK) &&              /* not any 1xx response */\n+        (r->status != HTTP_NO_CONTENT) &&      /* not 204 */\n+        (r->status != HTTP_RESET_CONTENT) &&   /* not 205 */\n+        (r->status != HTTP_NOT_MODIFIED)) {    /* not 304 */\n+\n /* we need to set this for ap_proxy_send_fb()... */\n         c->cache_completion = conf->cache.cache_completion;\n \n@@ -641,10 +942,43 @@\n         ap_proxy_send_fb(f, r, c, c->len, 0, chunked, conf->io_buffer_size);\n     }\n \n-    /* ap_proxy_send_fb() closes the socket f for us */\n+    /* Update the backend if the connection is to be closed. */\n+    if (p_conn->close)\n+    {\n+        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server,\n+                     \"proxy: closing connection to backend\");\n+        ap_bclose(f);\n+        backend->connection = NULL;\n+    }\n \n     ap_proxy_cache_tidy(c);\n \n     ap_proxy_garbage_coll(r);\n     return OK;\n }\n+\n+/*\n+ * Used to hold back-end connection information.\n+ */\n+module MODULE_VAR_EXPORT proxy_http_module =\n+{\n+    STANDARD_MODULE_STUFF,\n+    NULL,                       /* initializer */\n+    NULL,                       /* create per-directory config structure */\n+    NULL,                       /* merge per-directory config structures */\n+    NULL,                       /* create per-server config structure */\n+    NULL,                       /* merge per-server config structures */\n+    NULL,                       /* command table */\n+    NULL,                       /* handlers */\n+    NULL,                       /* translate_handler */\n+    NULL,                       /* check_user_id */\n+    NULL,                       /* check auth */\n+    NULL,                       /* check access */\n+    NULL,                       /* type_checker */\n+    NULL,                       /* pre-run fixups */\n+    NULL,                       /* logger */\n+    NULL,                       /* header parser */\n+    NULL,                       /* child_init */\n+    NULL,                       /* child_exit */\n+    NULL                        /* post read-request */\n+};\ndiff -ru apache_1.3.27/src/modules/proxy/proxy_util.c\nmod/src/modules/proxy/proxy_util.c\n--- apache_1.3.27/src/modules/proxy/proxy_util.c\tMon Jul 22 11:26:03 2002\n+++ mod/src/modules/proxy/proxy_util.c\tThu Mar 27 10:08:06 2003\n@@ -616,17 +616,6 @@\n         total_bytes_rcvd += n;\n \n         /* if we've received everything... */\n-        /*\n-         * in the case of slow frontends and expensive backends, we want to\n-         * avoid leaving a backend connection hanging while the frontend\n-         * takes it's time to absorb the bytes. so: if we just read the last\n-         * block, we close the backend connection now instead of later - it's\n-         * no longer needed.\n-         */\n-        if (total_bytes_rcvd == len) {\n-            ap_bclose(f);\n-            f = NULL;\n-        }\n \n         /* Write to cache first. */\n         /*\n@@ -689,11 +678,6 @@\n \n     }                           /* loop and ap_bread while \"ok\" */\n \n-    /* if the backend connection is still open, close it */\n-    if (f) {\n-        ap_bclose(f);\n-    }\n-\n     if (!con->aborted) {\n         ap_bflush(con->client);\n     }\n@@ -1608,11 +1592,11 @@\n         *backasswards = 0;\n \n         /* there need not be a reason phrase in the response,\n-\t * and ap_getline() already deleted trailing whitespace.\n-\t * But RFC2616 requires a SP after the Status-Code. Add one:\n-\t */\n-\tif (strlen(buffer) < sizeof(\"HTTP/1.x 200 \")-1)\n-\t  buffer = ap_pstrcat(r->pool, buffer, \" \", NULL);\n+         * and ap_getline() already deleted trailing whitespace.\n+         * But RFC2616 requires a SP after the Status-Code. Add one:\n+         */\n+        if (strlen(buffer) < sizeof(\"HTTP/1.x 200 \")-1)\n+            buffer = ap_pstrcat(r->pool, buffer, \" \", NULL);\n         buffer[12] = '\\0';\n         r->status = atoi(&buffer[9]);\n         buffer[12] = ' ';\n@@ -1636,7 +1620,6 @@\n     }\n \n     return OK;\n-\n }\n \n \ndiff -ru apache_1.3.27/src/support/httpd.exp mod/src/support/httpd.exp\n--- apache_1.3.27/src/support/httpd.exp\tMon Jun 17 21:30:00 2002\n+++ mod/src/support/httpd.exp\tMon Mar  3 13:07:21 2003\n@@ -85,6 +85,7 @@\n ap_coredump_dir\n ap_count_dirs\n ap_cpystrn\n+ap_create_conn_config\n ap_create_environment\n ap_create_per_dir_config\n ap_create_request_config"}, {"count": 1, "tags": [], "text": "Created attachment 16886\nmod_proxy 1.3 patch to add persistent connection support", "attachment_id": 16886, "id": 82157, "creator": "stoddard@apache.org", "time": "2005-11-06T15:01:43Z", "bug_id": 37373, "creation_time": "2005-11-06T15:01:43Z", "is_private": false}, {"count": 2, "text": "all proxy efforts are in 2.2", "bug_id": 37373, "attachment_id": null, "id": 106204, "time": "2007-08-02T13:06:46Z", "creator": "jim@apache.org", "creation_time": "2007-08-02T13:06:46Z", "tags": [], "is_private": false}]