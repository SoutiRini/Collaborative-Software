[{"count": 0, "tags": [], "bug_id": 47693, "attachment_id": null, "id": 129679, "time": "2009-08-13T05:23:12Z", "creator": "alex@envivio.com", "creation_time": "2009-08-13T05:23:12Z", "is_private": false, "text": "When a GET request is received by Apache, it first opens the file to determine the length, then closes it, then reopens it to serve the file.\n\nAn interesting use case is to replace a file (using an atomic rename) and have Apache give consistent results: always return either the old file or the new file.\n\nHowever, the current implementation will give inconsistent results when the length of the file changes between the first and second time Apache opens the files.\n\nIf the new file is longer, Apache returns the content of the new file truncated to the length of the first file. If the new file is shorter, Apache returns an error response."}, {"attachment_id": null, "tags": [], "bug_id": 47693, "is_private": false, "count": 1, "id": 129687, "time": "2009-08-14T04:34:41Z", "creator": "poirier@pobox.com", "creation_time": "2009-08-14T04:34:41Z", "text": "That's all true, but are there are any feasible ways to fix the behavior?  For that matter, what is the right behavior if a file changes in the middle of a request?\n\nThe server could ensure consistency by making a complete copy of every file before beginning to serve it, but that's not reasonable for any significant load.  There might be some operating systems where the server could get an exclusive lock on the file before beginning to serve it, but not on most OSes.\n\nPractically speaking, the solution is not to change files under a running server.  Or serve the content from a database or other source with true atomic changes."}, {"count": 2, "tags": [], "bug_id": 47693, "attachment_id": null, "is_private": false, "id": 130737, "time": "2009-09-29T01:38:29Z", "creator": "alex@envivio.com", "creation_time": "2009-09-29T01:38:29Z", "text": "Perhaps it won't be feasible in terms of internal state management inside the server, but the solution would be to use the following sequence:\n\nopen the file, get it's length, read the file, close the file\n\ninstead of:\n\nopen the file, get it's length, close the file, open the file, read the file, close the file.\n\nNote that the interference with file that I'm talking about is not an arbitrary modification to the file, but only the case where the file is replaced by another file. This is a typical filesystem operation for doing a \"clean\" / \"atomic\" modification to a file: write a new copy of the file content to a temporary file, then replace the target file by the temporary file.\n\nReopening to get feedback on the feasibility of the proposed solution..."}]