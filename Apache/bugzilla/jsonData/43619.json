[{"count": 0, "tags": [], "creator": "lilianne_blaze@tlen.pl", "attachment_id": null, "id": 109329, "time": "2007-10-13T22:50:47Z", "bug_id": 43619, "creation_time": "2007-10-13T22:50:47Z", "is_private": false, "text": "I wrote a simple patch which makes property resolving pluggable. It can\nbe used, for example, to check JNDI env-entries in addition to system\nproperties, or to specify the priority in which they are resolved\n(allowing or disallowing sys props to override local props, etc). Could\nyou please review it? Could something like that be included in Log4j? If\nyes, what changes (the current version works, but is pretty rudimentary)\nare required?"}, {"attachment_id": 20974, "tags": [], "bug_id": 43619, "text": "Created attachment 20974\nProposed patch - 'skeletal' version", "count": 1, "id": 109330, "time": "2007-10-13T22:52:22Z", "creator": "lilianne_blaze@tlen.pl", "creation_time": "2007-10-13T22:52:22Z", "is_private": false}, {"count": 2, "tags": [], "bug_id": 43619, "attachment_id": null, "is_private": false, "id": 109670, "time": "2007-10-23T13:00:08Z", "creator": "carnold@apache.org", "creation_time": "2007-10-23T13:00:08Z", "text": "The attached file only adds the pluggable property resolver to the PropertyConfigurator.  It does not \nappear to affect the DOMConfigurator.  I'd be relunctant to add a new capability to PropertyConfigurator \nwithout a consistent equivalent for DOMConfigurator.\n\nYou may be able to address your use case with a couple of different approaches that would not require \nmodifications to log4j.  Since older log4j's are widely deployed and hard to displace, it would probably \nbe in your interest to use capabilities in those versions when at all possible.\n\nIf you would be willing to extend DOMConfigurator, you could override DOMConfigurator.subst(String) \nand accomplish the same type of goal by passing in a specialized implementation of Properties \ndownstream.\n\nYou could also extend PropertyConfigurator.configure(Properties, LoggerRepository) and wrap the \npassed Properties object with a specialized implementation of Properties that will also pull properties \nfrom JMX.  System properties would still be checked in preference to properties defined in the config \nfile or in JMX, but that might be sufficient for your needs."}, {"count": 3, "tags": [], "creator": "lilianne_blaze@tlen.pl", "text": "Are you 100% positive?\n\nI'm using the same patch right now with DOMConfigurator. In production\nenvironment, no less.\n\nThe idea was that DOMConfigurator.subst(String) calls\nDOMConfigurator.subst(String,Props), which calls\nOptionConverter.substVars(String,Props), which in turn calls my\nPropertyResolver.getInstance().resolveProperty(String,Props). As long as a\nspecific implementation of Configurator eventually calls\nOptionConverter.substsVars, my\nPropertyResolver.getInstance().resolveProperty(...) is called.\n\nYes, I know it can be accomplished easier by subclassing a XxxConfigurator, but\nthis way we can have any combination of XxxConfigurator and YyyPropertyResolver.", "id": 109671, "time": "2007-10-23T13:30:40Z", "bug_id": 43619, "creation_time": "2007-10-23T13:30:40Z", "is_private": false, "attachment_id": null}, {"count": 4, "tags": [], "bug_id": 43619, "attachment_id": null, "text": "Quite a bit less than 100%.  I did a quick read through the patch and apparently came to a faulty \nconclusion.\n\nThere is an arbitrariness of where you stop using System.getProperty().  If you rework \nOptionConverter.getSystemProperty() (instead of OptionConverter.substVars) to use a user-specified \nsource for properties, then you could have JMX specify the default configurator, etc.  The source for \n\"system properties\" would be the only property that would have to come from System.getProperty().\n\nI'd like to avoid adding a new interface, but overriding Map seems like an inordinate amount of effort \nand likely to be short-cut.  Plus it is hard to explain what the effective value of the current behavior is.  \nPerhaps a property (\"log4j.systemPropertyClass\" ?) could specify a class name whose getProperty(String) \nmethod would be used for system properties.  The effective default value would be \"java.lang.System\".\n", "id": 109753, "time": "2007-10-25T14:26:26Z", "creator": "carnold@apache.org", "creation_time": "2007-10-25T14:26:26Z", "is_private": false}, {"count": 5, "tags": [], "creator": "lilianne_blaze@tlen.pl", "attachment_id": null, "id": 109754, "time": "2007-10-25T14:45:01Z", "bug_id": 43619, "creation_time": "2007-10-25T14:45:01Z", "is_private": false, "text": "Wouldn't that be over-simplifing things?\nNote the key method has (String key, Properties localProps, String def)\narguments - it allows any strategy, for example to use System, local (defined in\nconfig file), JNDI props in any order. You can have System1stLocal2nd stratedy\nwhich would effectively override local properties with system properties, or\nLocal1stSystem2nd which would do the opposite. Not so with a simple\ngetProperty(String) replacement."}, {"count": 6, "tags": [], "text": "Basically what I mean is, it would be better to have pluggable 'strategies'\ninstead of 'sources'.\n\n\n> Plus it is hard to explain what the effective value of the current behavior is\n\nWhy \"hard\"?\nCurrent code:\n\t  // first try in System properties\n\t  String replacement = getSystemProperty(key, null);\n\t  // then try props parameter\n\t  if(replacement == null && props != null) {\n\t    replacement =  props.getProperty(key);\n\t  }\n\nTry system property first, then try local property. System overrides local. Simple.", "attachment_id": null, "id": 109766, "creation_time": "2007-10-25T21:30:32Z", "time": "2007-10-25T21:30:32Z", "creator": "lilianne_blaze@tlen.pl", "bug_id": 43619, "is_private": false}, {"count": 7, "tags": [], "creator": "carnold@apache.org", "attachment_id": null, "id": 109813, "time": "2007-10-26T10:46:34Z", "bug_id": 43619, "creation_time": "2007-10-26T10:46:34Z", "is_private": false, "text": "Redirecting the calls that currently go to java.lang.System.getProperty(String) to another arbitrary \nclass's static getProperty(String) method, should still allow you to use JNDI in preference to system \nproperties or vice-versa.\n\nWhat I meant as hard to explain is that in either case you can't say something like the default value of \nthis new property is some existing class that the user will be familiar.  \n\nIn redirecting the getSystemProperty() call, you can explain that you are redirecting the source of all \nsystem properties with the exception of \"log4j.systemPropertySource\" and the user has some familiarity \nwith System.getProperty(String).  \n\nIn redirecting OptionConverter.substVars(), you have to say that you are redirecting from some \ndescription of the current strategy or a some new class that encapsulate that strategy.\n\nOverriding OptionConverter.getSystemProperty() would allow you, for example, to set the location of \nthe configuration file as an environment variable (assuming a JNDI implementation of getProperty()) that \noverriding OptionConverter.substVars() wouldn't.  Like:\n\nexport log4j.configuration=~/mylogconfig.xml\n\n\n"}, {"count": 8, "tags": [], "creator": "lilianne_blaze@tlen.pl", "attachment_id": null, "id": 109816, "time": "2007-10-26T11:29:14Z", "bug_id": 43619, "creation_time": "2007-10-26T11:29:14Z", "is_private": false, "text": "I'm not sure I understand that completely.\n\n> What I meant as hard to explain is that in either case you can't say something\nlike the default value of \nthis new property is some existing class that the user will be familiar.\n\nIt's simply DefaultPropertyResolver.resolveProperty, which does exactly what\n404-409 lines in OptionConverter did.\n\nHowever, there's one major issue I see with your version - no access to 'local'\nproperties, and no ability to choose order. With setting a 'source', as opposed\nto 'strategy', you have to hardcode the overriding order, either the custom\nsource overrides local properties, or local properties override the custom\nsource. Also, your version depends on reflection, does it not? And that is\nhardly easier for Joe Newbie, no compile-time checks, etc.\n\nWith 'strategies' you can have things like system properties \"x\" and\n\"x.allowOverride=false\", and a strategy which disallows overriding by local\nproperties if a property with \".allowOverride\" suffix and \"false\" value exists.\n\nWell, why not have both? Have \"log4j.propertyResolver\" for 'strategies' and\n\"log4j.propertySource\" for 'sources', with the default being a\nuse-source-strategy with \"java.lang.System.getProperty(String)\"?"}]