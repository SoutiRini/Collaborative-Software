[{"count": 0, "tags": [], "bug_id": 50297, "attachment_id": null, "id": 141815, "creation_time": "2010-11-18T20:47:21Z", "time": "2010-11-18T20:47:21Z", "creator": "isaac@shabtay.com", "text": "Various resource collections (union, etc) are designed with particular iteration orders in mind. For example, a \"union\" stores items in a LinkedHashSet to preserve ordering.\n\nTurns out, though, that the Copy task doesn't respect the natural ordering of items.\n\nI am suspecting this is because \"fileCopyMap\" is a Hashtable; the \"doFileOperations()\" method goes over the elements in \"fileCopyMap\" to execute the copy instructions.\n\nI took a few minutes (OK, more than a few) to look at the code and it appears as if changing \"fileCopyMap\", \"dirCopyMap\" and perhaps \"completeDirMap\" to \"LinkedHashMap\" instances would resolve this problem.", "is_private": false}, {"attachment_id": null, "tags": [], "creator": "bodewig@apache.org", "is_private": false, "count": 1, "id": 141835, "time": "2010-11-19T10:52:59Z", "bug_id": 50297, "creation_time": "2010-11-19T10:52:59Z", "text": "While your proposed change would fix the ordering problem it would also\nbreak the publiches API of the copy task in a backwards incompatible\nway - so we can't do it that easily.\n\nUnder what circumstances is the order of file operations important to you?"}, {"attachment_id": null, "tags": [], "creator": "isaac@shabtay.com", "is_private": false, "count": 2, "id": 141862, "time": "2010-11-19T19:00:32Z", "bug_id": 50297, "creation_time": "2010-11-19T19:00:32Z", "text": "Well, both Hashtable and LinkedHashMap extend the Map interface so we could change the variables' declaration to \"Map\". But you're right... it would still break those who use these protected members within their code.\n\n(Even though I think that's the way things should really be)\n\nMy situation is a bit tricky. Before the \"copy\" operation, I prepare a union of resources to copy; the copy operation itself has a flattenmapper attached to it. It is definitely possible for my union to contain more than one entry with the same basename (different directories though).\n\nSo (for example):\n\n<union>\n   <file name=\"dir1/file.txt\"/>\n   <file name=\"dir2/file.txt\"/>\n</union>\n\nand my intention is that \"dir2/file.txt\" will end-up in the target directory. So I use a \"copy\" task with a flattenmapper...... therefore the order of iteration is *VERY* important."}, {"count": 3, "tags": [], "bug_id": 50297, "attachment_id": null, "text": "The Copy class predates Java2 and in particular the point in time when Ant\nstarted to require a JDK 1.2 to run, that's why it is using \"old\" collections.\n\nThe real BWC problem is that the fields are protected.\n\nEven though I think you are trying to solve the problem with the wrong\napproach I now understand your usecase.  I've been thinking about a different\nway to do what you want using built-in resource collections or selectors;\nmappedresources would work if your union was in reverse order (i.e. you'd\nonly kee the first file of multiple files that mapped to the same name).", "id": 141906, "time": "2010-11-22T05:35:46Z", "creator": "bodewig@apache.org", "creation_time": "2010-11-22T05:35:46Z", "is_private": false}, {"count": 4, "tags": [], "bug_id": 50297, "attachment_id": null, "is_private": false, "id": 141930, "time": "2010-11-22T11:41:28Z", "creator": "isaac@shabtay.com", "creation_time": "2010-11-22T11:41:28Z", "text": "Well I'm not sure why my approach is the wrong one; the only alternative I can see is issuing multiple \"copy\" tasks, but that seems wasteful.\n\nTo fix this with a \"Map\", without breaking the API, I can only think of the following:\n\n1) Define a class that extends Hashtable (call it HashtableEx or something, doesn't matter).\n\n2) Have its constructor receive a reference to a Map, which will basically be an \"observer\".\n\n3) Override the \"put\" and \"remove\" method so, in addition to putting /removing stuff to / from the Hashtable, also puts / removes stuff from / to the Map that was provided in construction time.\n\n4) Define an actual Map inside the Copy task - one for each Hashtable.\n\nFrom there on, any addition/removal will be \"posted\" to the map so the hashtable and the map are always in sync. Internally, the Copy task should use the Map rather than the hashtable; we can mark the hashtable instance as \"deprecated\" so it can be removed in future releases.\n\nOther than that, I can't really think of another way to resolve this issue."}, {"attachment_id": null, "tags": [], "creator": "mbenson@apache.org", "is_private": false, "count": 5, "id": 141931, "time": "2010-11-22T12:29:49Z", "bug_id": 50297, "creation_time": "2010-11-22T12:29:49Z", "text": "Much simpler would be to simply remove the unwanted resources from the source collection by narrowing, composing, etc., using the various selectors and collections available."}, {"count": 6, "tags": [], "bug_id": 50297, "attachment_id": null, "text": "I beg to differ on that. Code-wise, there would be much less code in the universe if the bug is fixed, than if I (or others who might encounter this behavior later) work around it.\n\nPlus, I don't see how I can work around this with the currently-available resource collections, filters and such. Writing custom Java code seems to be the only way to \"filter\" my list.", "id": 141940, "time": "2010-11-22T21:53:37Z", "creator": "isaac@shabtay.com", "creation_time": "2010-11-22T21:53:37Z", "is_private": false}, {"count": 7, "tags": [], "bug_id": 50297, "text": "After revisiting this I understood I was trong about mappedresources - it does everything you need for your case.\n\nWrap a mappedresources element http://ant.apache.org/manual/Types/resources.html#mappedresources around your union and move the mapper from the copy task to a nested element of the mappedresources element.\n\nShould work or am I missing anything?", "id": 142123, "time": "2010-11-29T10:20:26Z", "creator": "bodewig@apache.org", "creation_time": "2010-11-29T10:20:26Z", "is_private": false, "attachment_id": null}, {"count": 8, "text": "(In reply to comment #7)\n> After revisiting this I understood I was trong about mappedresources - it does\n> everything you need for your case.\n> \n\nThanks, I will try that, however I just realized something. This also happens when nested filesets exist for the \"copy\" task without any resource-collection container (such as union). I just had a \"copy\" ask with two nested fileset elements, and executing it I noticed that files are copied \"out of order\"; I would expect the first fileset to be copied first (in whatever order), and the second fileset to be copied afterwards.... But some files were copied from fileset #1, then some files from fileset #2, then again some other files from fileset #1....\n\nI really think we have a serious problem here.", "bug_id": 50297, "attachment_id": null, "id": 142142, "time": "2010-11-29T14:24:29Z", "creator": "isaac@shabtay.com", "creation_time": "2010-11-29T14:24:29Z", "tags": [], "is_private": false}, {"count": 9, "tags": [], "bug_id": 50297, "text": "Two possibilities I have thought of:\n\n1.  Extend Hashtable such that all its methods actually defer to a wrapped LinkedHashMap and use instances of that class in Copy's initializers.  This won't help the case where a subclass reassigns the references, however.\n\n2.  Rewrite copy/move and assign the task names to the new classes, which share the existing introspection/XML interface.  Users who extend the now deprecated Copy/Move classes are unaffected.\n\nThoughts?", "id": 142143, "time": "2010-11-29T14:39:33Z", "creator": "mbenson@apache.org", "creation_time": "2010-11-29T14:39:33Z", "is_private": false, "attachment_id": null}, {"count": 10, "tags": [], "bug_id": 50297, "attachment_id": null, "id": 142144, "time": "2010-11-29T14:45:20Z", "creator": "isaac@shabtay.com", "creation_time": "2010-11-29T14:45:20Z", "is_private": false, "text": "(In reply to comment #9)\n> Two possibilities I have thought of:\n> \n> 1.  Extend Hashtable such that all its methods actually defer to a wrapped\n> LinkedHashMap and use instances of that class in Copy's initializers.  This\n> won't help the case where a subclass reassigns the references, however.\n> \n> 2.  Rewrite copy/move and assign the task names to the new classes, which share\n> the existing introspection/XML interface.  Users who extend the now deprecated\n> Copy/Move classes are unaffected.\n> \n> Thoughts?\n\nI believe extending Hashtable will impact maintainability in the long term. If it was up to me I'd go for option (2)."}, {"count": 11, "tags": [], "bug_id": 50297, "attachment_id": null, "text": "First of all I'm sorry to suggest the mappedresources - this won't work since the Hashtable is still free to reorder things.\n\nMatt's option (1) is more or less the same we've done for VectorSet (which\nmight better wrap LinkedHashMap rather than use its current code).  Yes, it\nwouldn't help with subclasses but I'd live with that.", "id": 142170, "time": "2010-11-29T23:50:41Z", "creator": "bodewig@apache.org", "creation_time": "2010-11-29T23:50:41Z", "is_private": false}, {"count": 12, "tags": [], "bug_id": 50297, "text": "svn revision 1040627 contains LinkedHashtable but I'm running out of time and\ncan't test a modified Copy task using it right now - will do so tomorrow.\n\nBTW, VectorSet couldn't wrap LinkedHashSet because of the insertAt operations\n- and random access would be pretty slow as well.", "id": 142207, "time": "2010-11-30T11:42:47Z", "creator": "bodewig@apache.org", "creation_time": "2010-11-30T11:42:47Z", "is_private": false, "attachment_id": null}, {"count": 13, "tags": [], "bug_id": 50297, "attachment_id": null, "is_private": false, "id": 142233, "time": "2010-12-01T00:27:29Z", "creator": "bodewig@apache.org", "creation_time": "2010-12-01T00:27:29Z", "text": "implemented with svn revision 1040874"}, {"count": 14, "tags": [], "bug_id": 50297, "attachment_id": null, "text": "Fantastic! Thank you both.", "id": 142282, "time": "2010-12-01T21:46:39Z", "creator": "isaac@shabtay.com", "creation_time": "2010-12-01T21:46:39Z", "is_private": false}]