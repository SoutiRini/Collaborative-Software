[{"count": 0, "tags": [], "bug_id": 9289, "is_private": false, "text": "I think Apache should have a directive to block some banner words if apache is \nused as a pure proxy server. This directive is similar to the ProxyBlock \ndirective. This directive allows apache to grep an ad word in the URL and \nblock the connection if it matches the predefined word. it also doesn't do a \nhost lookup in the server start-up. Here is what I did to implement a \ndirective ProxyWordBlock :\n\n(1) add the following to the definition of \n\nstatic const command_rec proxy_cmds[]=\n{\n    ...\n    ...\n    {\"ProxyWordBlock\", set_proxy_word_exclude, NULL, RSRC_CONF, ITERATE,\n\t/* LINKBYTE */\n     \"A list of names, words, hosts or domains to which the proxy will not \nconnect\"},\n   {NULL}\n};\n\nwhere, funcion set_proxy_word_exclude is defined later.\n\n(2) add a new data member to the structure of proxy_server_conf in the \nmod_proxy.h file:\n\n    array_header *nowords;\n\n(3) insert the following line into the function of create_proxy_config:\n\n    ps->nowords = ap_make_array(p, 10, sizeof(struct noproxy_entry));   \n\n(4) insert the following line into the function of merge_proxy_config:\n\n    ps->nowords = ap_append_arrays(p, base->nowords, overrides->nowords);\n\n(5) create a new funciton in the mod_proxy.c file:\n\n/* Similar to set_proxy_exclude(), but not resolve the hostname and make\n * the case sensible\n */\nstatic const char *\n     set_proxy_word_exclude(cmd_parms *parms, void *dummy, char *arg)\n{\n    server_rec *s = parms->server;\n    proxy_server_conf *conf =\n    ap_get_module_config(s->module_config, &proxy_module);\n    struct noproxy_entry *new;\n    struct noproxy_entry *list = (struct noproxy_entry *) conf->nowords->elts;\n    int found = 0;\n    int i;\n\n    /* Don't duplicate entries */\n    for (i = 0; i < conf->nowords->nelts; i++) {\n        if (strcmp(arg, list[i].name) == 0)\n            found = 1;\n    }\n\n    if (!found) {\n        new = ap_push_array(conf->nowords);\n        new->name = arg;\n        new->addr.s_addr = 0;\n    }\n    return NULL;\n}\n\n(6)in the file of proxy_http.c, add the following line in the beginning of \nfunction ap_proxy_http_handler:\n\nstruct noproxy_entry *nwent = (struct noproxy_entry *) conf->nowords->elts;\n\n6)in the file of proxy_http.c, add the following line in the function \nap_proxy_http_handler after the similar proxyblock codes:\n\n/* check if ProxyWordBlock directive on this host */\n    for (i = 0; i < conf->nowords->nelts; i++) {\n        if (nwent[i].name && nwent[i].name[0] &&\n\t\t\tstrstr(url, nwent[i].name))\n            return ap_proxyerror(r, HTTP_FORBIDDEN,\n                                 \"Connect to remote machine blocked\");\n    }\n\n\n(7) we can do the similar thing for the proxy_ftp.c and proxy_connect.c, \nhowever, i choose to let it alone.", "id": 16484, "time": "2002-05-21T16:13:15Z", "creator": "fan_xia@hotmail.com", "creation_time": "2002-05-21T16:13:15Z", "attachment_id": null}, {"count": 1, "tags": [], "text": "Well, it is already possible to filter/block URLs by using mod_rewrite inside a\nproxy directive.\n\nIMHO such a ProxyWordBlock feature is only of interested to a limited number of\nusers. mod_rewrite is IMHO the most sophisticated way of doing filtering if a\nuser requires such a filtering feature when using the proxy.\n", "attachment_id": null, "bug_id": 9289, "id": 16743, "time": "2002-05-26T20:48:42Z", "creator": "lars@apache.org", "creation_time": "2002-05-26T20:48:42Z", "is_private": false}]