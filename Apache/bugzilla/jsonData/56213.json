[{"count": 0, "tags": [], "bug_id": 56213, "attachment_id": null, "id": 173609, "creation_time": "2014-03-03T22:48:06Z", "time": "2014-03-03T22:48:06Z", "creator": "jmiddav@gmail.com", "text": "This is a request to prop the following fix to Tomcat 7.\n\nhttp://svn.apache.org/viewvc?diff_format=h&view=revision&revision=1388890\n\nUsing the NIO connector with a WebSocket application many (millions of) KeyReference objects are  created under traffic.  While the objects are small, the sheer number of them seems to overwhelm the CMS collector.  Before the above fix with our application the CMS remark stop the world phase was taking up to 8.8 seconds.\n\n716.463: [GC[YG occupancy: 213377 K (392896 K)]716.463: [Rescan (parallel) , 5.7904380 secs]722.253: [weak refs processing, 2.3101000 secs] [1 CMS-remark: 1160677K(1703936K)] 1374054K(2096832K), 8.8005960 secs] [Times: user=107.17 sys=0.00, real=8.80 secs] \nTotal time for which application threads were stopped: 8.8020690 seconds\n\nAfter applying the fix under the same traffic the time drops to 110ms.\n\n1282.459: [GC[YG occupancy: 203760 K (392896 K)]1282.459: [Rescan (parallel) , 0.0594610 secs]1282.519: [weak refs processing, 0.0452530 secs] [1 CMS-remark: 1159948K(1703936K)] 1363708K(2096832K), 0.1084940 secs] [Times: user=1.12 sys=0.00, real=0.11 secs] \nTotal time for which application threads were stopped: 0.1100650 seconds\n\nFor a real time application the 9 second pause is a killer.\n\nThese tests were executed under:\nRHEL 6.4\njava version \"1.6.0_65\"\nJava(TM) SE Runtime Environment (build 1.6.0_65-b14-BR8013809)\nJava HotSpot(TM) 64-Bit Server VM (build 20.65-b04, mixed mode)\n\nWith the following JVM parms:\n -server\n -XX:NewSize=384m\n -XX:MaxNewSize=384m\n -XX:+UseParNewGC\n -XX:MaxTenuringThreshold=0\n -Xms2048m\n -Xmx2048m\n -XX:+UseConcMarkSweepGC\n -XX:CMSInitiatingOccupancyFraction=68\n -XX:+UseCMSInitiatingOccupancyOnly\n -XX:PermSize=96m\n -XX:MaxPermSize=96m\n -XX:+UseMembar\n -XX:+HeapDumpOnOutOfMemoryError\n -XX:+PrintClassHistogram", "is_private": false}, {"count": 1, "attachment_id": null, "bug_id": 56213, "is_private": false, "id": 173633, "time": "2014-03-05T13:42:20Z", "creator": "markt@apache.org", "creation_time": "2014-03-05T13:42:20Z", "tags": [], "text": "This has been fixed in 7.0.x and will be included in 7.0.53 onwards."}, {"count": 2, "tags": [], "bug_id": 56213, "text": "Regarding this change ( r1574484 ) I would like to hear, whether it really improves situation for you.\n\nKeyReference is just a reference object. Reusing and recycling it via a queue creates another reference object that holds it in the queue (ConcurrentLinkedQueue$Node, in queue.offer()). These Node objects are created on each offer and are not reused.\n\nSo, amount of garbage is exactly the same, but some processing cost is added.\n\nMy guess is that Node objects are more short-lived and thus are collected more easily. Also they do not have a finalize() method and can be disposed of in one step without going through a finalizer queue. So the only difference is in the kind of garbage.\n\nIs it worth it?", "id": 173710, "attachment_id": null, "creator": "knst.kolinko@gmail.com", "creation_time": "2014-03-08T18:44:41Z", "time": "2014-03-08T18:44:41Z", "is_private": false}, {"count": 3, "tags": [], "creator": "jmiddav@gmail.com", "text": "Thanks for the quick turnaround!\n\nI see what you are saying about the reference objects, but yes this change made a huge difference in gc times.   The times quoted in the description (100ms vs 8.8 secs) were with and without that patch.  Maybe it is the finalization method that is slowing things down.  Just did some quick reading and it appears to be executed during that phase.", "id": 173919, "time": "2014-03-18T23:16:03Z", "bug_id": 56213, "creation_time": "2014-03-18T23:16:03Z", "is_private": false, "attachment_id": null}]