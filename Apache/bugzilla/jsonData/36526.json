[{"count": 0, "tags": [], "bug_id": 36526, "text": "When signing or verifying a bigger (about 0.5 Gbyte) file got out of memory \nerror in org.apache.xml.security.signature.XMLSignatureInput, at line 1275:\nbytes=JavaUtils.getBytesFromStream(_inputOctetStreamProxy);", "id": 79466, "time": "2005-09-06T20:38:12Z", "creator": "polysys@axelero.hu", "creation_time": "2005-09-06T20:38:12Z", "is_private": false, "attachment_id": null}, {"count": 1, "tags": [], "bug_id": 36526, "text": "There is only one case where the library can avoid reading the whole reference\nfile in memory. And it is when the only transformation that is going to apply to\nthe transformation is B64 decoding/encoding.  And this optimiozation is already\nimplemented.\n\nWhat is your case?\n\nCan you post your signature, with the references and trasformation?\n\nThanks.\n\np.s- I understand that all issues are critical to the people suffering them. But\nthis one seems important to me but not critical. Mind this the next time you\nreport a bug to other projects.", "id": 79560, "time": "2005-09-07T17:46:03Z", "creator": "raul-info@r-bg.com", "creation_time": "2005-09-07T17:46:03Z", "is_private": false, "attachment_id": null}, {"count": 2, "tags": [], "creator": "polysys@axelero.hu", "attachment_id": 16366, "text": "Created attachment 16366\nModified CreateSignature.java for testing OutOfMemoryError\n\nnew lines at line 151:\n  \n  // add a bigger file (size: 45 635 523)\n  File bigfile = new File(\"jdk-1_5_0-doc.zip\");\n  sig.addDocument(bigfile.toURI().toString());", "id": 79783, "time": "2005-09-12T10:50:12Z", "bug_id": 36526, "creation_time": "2005-09-12T10:50:12Z", "is_private": false}, {"count": 3, "tags": [], "text": "If you don't put any transformation to a reference, the inclusive C14N is\nimplicit, so the file need to be readed in memory. \nThe only transformation that is not going to convert is base64 decoding.\nSo if you want to sign rawdata base64 encoding it before, and handle like this:\n\n{\n        //create the transforms object for the Document/Reference\n        Transforms transforms = new Transforms(doc);\n\n        transforms.addTransform(Transforms.TRANSFORM_BASE64_DECODE);\n        // add a bigger file (size: 62 163 072 > 45 635 523)\n        // comming from base64 /usr/portage/distfiles/xorg-x11-6.8.99.15.tar.bz2\n         File bigfile = new File(\"/tmp/tmp.b64\");\n         sig.addDocument(bigfile.toURI().toString(),transforms,\nConstants.ALGO_ID_DIGEST_SHA1);\n      }\n\nIn this way as the test pass without any out of memory error (I have test with\njust plain java).\n\nI will mark this bug as invalid.", "is_private": false, "id": 79841, "creation_time": "2005-09-13T00:35:34Z", "time": "2005-09-13T00:35:34Z", "creator": "raul-info@r-bg.com", "bug_id": 36526, "attachment_id": null}, {"count": 4, "tags": [], "creator": "polysys@axelero.hu", "attachment_id": null, "id": 79863, "time": "2005-09-13T14:21:33Z", "bug_id": 36526, "creation_time": "2005-09-13T14:21:33Z", "is_private": false, "text": "(In reply to comment #3)\n> If you don't put any transformation to a reference, the inclusive C14N is\n> implicit, so the file need to be readed in memory. \n> The only transformation that is not going to convert is base64 decoding.\n> So if you want to sign rawdata base64 encoding it before, and handle like \nthis:\n> {\n>         //create the transforms object for the Document/Reference\n>         Transforms transforms = new Transforms(doc);\n>         transforms.addTransform(Transforms.TRANSFORM_BASE64_DECODE);\n>         // add a bigger file (size: 62 163 072 > 45 635 523)\n>         // comming from base64 /usr/portage/distfiles/xorg-x11-\n6.8.99.15.tar.bz2\n>          File bigfile = new File(\"/tmp/tmp.b64\");\n>          sig.addDocument(bigfile.toURI().toString(),transforms,\n> Constants.ALGO_ID_DIGEST_SHA1);\n>       }\n> In this way as the test pass without any out of memory error (I have test \nwith\n> just plain java).\n> I will mark this bug as invalid.\n\nThank you for your answer. But base64 encoding is not solution for my case. We \nhave a Protection Profile and Security Target which dispose of \"What You See \nIs What You Sign\". We have to sign the original file selected and seen by the \nuser not the base64 encoding of the file. The developed application will be CC \nevaluated and certified so I must satisfy the WYSWYS security objective.\nI realized that here a resettable FileInputStream could be the solution. Could \nyou give me instruction how and where to put it ?\nThanks,\nAgnes"}, {"count": 5, "tags": [], "creator": "polysys@axelero.hu", "attachment_id": 16449, "id": 80124, "time": "2005-09-19T17:41:15Z", "bug_id": 36526, "creation_time": "2005-09-19T17:41:15Z", "is_private": false, "text": "Created attachment 16449\nSolution idea\n\nI have an idea to solve signing and verifying big files without Base64\ntransformation and without OutOfMemoryError.\n\n\n\n1) In XMLSignatureInput.java should be a new member:\n\n\tFile InputFile = null;\n\n2) In XMLSignatureInput.java should be a new constructor:\n\n\tpublic XMLSignatureInput(File inputfile)\n\t{\n\t\tInputFile = inputfile;\n\t}\n\n3) In XMLSignatureInput.java, updateOutputStream method should be modified:\n\n\t/**\n\t * @param diOs\n\t * @throws IOException\n\t * @throws CanonicalizationException\n\t */\n\tpublic void updateOutputStream(OutputStream diOs) throws\nCanonicalizationException, IOException {\t\n\tif (diOs==outputStream) {\n\t\treturn;\n\t}\n\tif (bytes!=null) {\n\t    diOs.write(bytes);\n\t    return;\t \n\t }else if (this.isElement()) {\t\t\t  \n\t     Canonicalizer20010315OmitComments c14nizer =\n\t\t    new Canonicalizer20010315OmitComments();\t   \n\t     c14nizer.setWriter(diOs);\n\t    c14nizer.engineCanonicalizeSubTree(this._subNode,this.excludeNode);\n\n\t    return;\n\t  } else if (this.isNodeSet()) {\t\n\t     /* If we have a node set but an octet stream is needed, we MUST\nc14nize\n\t      * without any comments.\n\t      *\n\t      * We don't use the factory because direct instantiation should be\na\n\t      * little bit faster...\n\t      */\n\t     Canonicalizer20010315OmitComments c14nizer =\n\t\tnew Canonicalizer20010315OmitComments();\t \n\t     c14nizer.setWriter(diOs);\n\t     if (this._inputNodeSet.size() == 0) {\n\t\t// empty nodeset\n\t\treturn;\n\t     }\t\t\t\t    \n\t     c14nizer.engineCanonicalizeXPathNodeSet(this._inputNodeSet);      \n\t \n\t     return;\t\t \n\t  } else {\n\n/* --> begin of new lines */\n\t    if ( InputFile != null )\n\t    {\n\t      byte[] buffer = new byte[32*1024];\n\t      BufferedInputStream bis = null;\n\t      try\n\t      {\n\t\tbis = new BufferedInputStream(new FileInputStream(InputFile));\n\t\tint bytesread = 0;\n\t\twhile ( (bytesread = bis.read(buffer)) != -1 )\n\t\t{\n\t\t  diOs.write(buffer,0,bytesread);\n\t\t}\n\t      }\n\t      finally\n\t      {\n\t\tif ( bis != null )\n\t\t{\n\t\t  bis.close();\n\t\t  bis = null;\n\t\t}\n\t      }\n\t      return;\n\t    }\n/* <-- end of new lines */\n\n\t    InputStream is = getResetableInputStream();\n\t    if (bytes!=null) {\n\t\t//already read write it, can be rea.\n\t\tdiOs.write(bytes,0,bytes.length);\n\t\treturn;\n\t    }\t\t \n\t    is.reset(); \t   \n\t    int num;\n\t    byte[] bytesT = new byte[1024];\n\t    while ((num=is.read(bytesT))>0) {\n\t\tdiOs.write(bytesT,0,num);\n\t    }\n\t\t\n\t  }\n\t\t\n\t}\n\n\n4) In ResolverLocalFileSystem.java, line 65 and 66 should be modified:\n\n/* original, line 65-66:\n\tFileInputStream inputStream = new FileInputStream(fileName);\n\tXMLSignatureInput result = new XMLSignatureInput(inputStream);\n*/\n/* new, line 65: */\n\tXMLSignatureInput result = new XMLSignatureInput(new File(fileName));\n\n\n\n\nIt is only an idea, not a real patch. I tried it with signing and verifying \ntwo big files (jdk-1_5_0-doc.zip, size=45635523 and lnx_920_disk2.cpio.gz,\nsize=588798999) and it works fine in this case:\n\n<ds:SignedInfo Id=\"BigFile_2_Signature-1__SignedInfo-1\">\n  <ds:CanonicalizationMethod\nAlgorithm=\"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\" /> \n  <ds:SignatureMethod Algorithm=\"http://www.w3.org/2000/09/xmldsig#rsa-sha1\" />\n\n  <ds:Reference Id=\"BigFile_2_Signature-1__Reference-1\"\nType=\"http://uri.etsi.org/01903/v1.2.2#SignedProperties\"\nURI=\"#BigFile_2_Signature-1__SignedProperties-1\">\n  <ds:DigestMethod Algorithm=\"http://www.w3.org/2000/09/xmldsig#sha1\" /> \n  <ds:DigestValue>NmZTo8j7D61PP1opL1HTs2YphN0=</ds:DigestValue> \n  </ds:Reference>\n  <ds:Reference Id=\"BigFile_2_Signature-1__Reference-2\"\nURI=\"file:jdk-1_5_0-doc.zip\">\n  <ds:DigestMethod Algorithm=\"http://www.w3.org/2000/09/xmldsig#sha1\" /> \n  <ds:DigestValue>HZqRglwK5G0XFQ36wdGzx00w+kQ=</ds:DigestValue> \n  </ds:Reference>\n  <ds:Reference Id=\"BigFile_2_Signature-1__Reference-3\"\nURI=\"file:lnx_920_disk2.cpio.gz\">\n  <ds:DigestMethod Algorithm=\"http://www.w3.org/2000/09/xmldsig#sha1\" /> \n  <ds:DigestValue>gaHz/04SteF1VCpuLY/+fkWksT8=</ds:DigestValue> \n  </ds:Reference>\n</ds:SignedInfo>\n\n\nMaybe something like this idea should be useful for other people or should be\napplied in a new version of the library."}, {"count": 6, "tags": [], "creator": "jdmarshall@gmail.com", "attachment_id": null, "id": 91222, "time": "2006-07-12T17:29:05Z", "bug_id": 36526, "creation_time": "2006-07-12T17:29:05Z", "is_private": false, "text": "I have the same problem as Agnes.  \n\nWe're using a Manifest in the signature to refer to very large external files. \nWe're expecting to encounter multi-gigabyte files in some situations., and we'd\nalso prefer to have them signed as-is, not as a B64 encoding of the original. \nUnless I'm misunderstanding the workaround, this suggestion does NOT constitute\na useful resolution to the problem.\n\nPlease provide a direct programatic mechanism to add References to binary files\nwithout reading them into memory in their entirety."}, {"count": 7, "tags": [], "bug_id": 36526, "attachment_id": null, "id": 91224, "time": "2006-07-12T17:44:47Z", "creator": "jdmarshall@gmail.com", "creation_time": "2006-07-12T17:44:47Z", "is_private": false, "text": "To be more precise, I am experiencing this error in a call to\nManifest.generateDigestValues(), not in Signature (Agnes appears not to have\nspecified how the error occured)"}, {"count": 8, "tags": [], "bug_id": 36526, "attachment_id": null, "id": 91227, "time": "2006-07-12T18:17:17Z", "creator": "raul-info@r-bg.com", "creation_time": "2006-07-12T18:17:17Z", "is_private": false, "text": "The idea of Agnes sounds good.\nBut please post a patch, If you want to discuss further. If not sadly it will be\nend in the TODO list. \n\nSorry"}, {"count": 9, "tags": [], "creator": "jdmarshall@gmail.com", "attachment_id": null, "text": "I did find myself a nice workaround for the problem.\n\nAt issue, as I currently understand the code, is that the code in\nXMLSignatureInput assumes that it is dealing with a relatively small piece of\ninput (true for internal references, not so for external), and further that the\ntransforms will/may scan the input several times (also true for internal\nreferences, probably not so for external).\n\nAs Agnes found, the crux of the problem starts with updateOutputStream, but\nextends into the retrieval of the resettable stream (which has far more side\neffects than I'm comfortable with).  \n\nFor my situation, I already had a custom resolver in place.  It was simple\nenough, once I had a better grasp on the problem, to create a custom\nXMLSignatureInput implementation that overrides updateOutputStream to open a\nFileInputStream, copy it to diOS, and close the input stream.  \n\nI suspect a better solution than either mine or Agnes' would present itself if I\ncould understand exactly what's going on with some of those member variables in\nXMLSignatureInput.  The code is just peculiar enough that I'm not confident that\nI understand everything it's trying to accomplish.\n\nI can observe however that XMLSignatureInput has changed somewhat since Agnes'\nproposal, so some rework would be necessary to apply it.", "id": 91278, "time": "2006-07-13T16:24:28Z", "bug_id": 36526, "creation_time": "2006-07-13T16:24:28Z", "is_private": false}, {"count": 10, "tags": [], "creator": "raul-info@r-bg.com", "text": "This bug is not critical. Change to enhancement.\nBut before we apply the patch, I think that we need to refactor\nXmlSignatureInput with the strategy pattern.", "id": 91930, "time": "2006-08-06T17:04:07Z", "bug_id": 36526, "creation_time": "2006-08-06T17:04:07Z", "is_private": false, "attachment_id": null}, {"count": 11, "tags": [], "creator": "sean.mullan@oracle.com", "text": "I took another look at this bug and was able to fix it. The fix I putback was very similar to Agnes' proposed patch, with a few small differences.\n\nThis should fix the OOM problems if you are simply trying to sign the bytes of a large file without any transformations that cause intermediate node-sets to be created. It doesn't address those use cases but it does address the use case of this bug and the one that I believe most users have complained about.", "id": 130657, "time": "2009-09-24T11:12:25Z", "bug_id": 36526, "creation_time": "2009-09-24T11:12:25Z", "is_private": false, "attachment_id": null}]