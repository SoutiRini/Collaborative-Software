[{"count": 0, "tags": [], "bug_id": 48286, "attachment_id": null, "id": 132334, "time": "2009-11-25T13:40:31Z", "creator": "vass.sanyi@freemail.hu", "creation_time": "2009-11-25T13:40:31Z", "is_private": false, "text": "When I'm using Constant Timer in my testplan it turned out that the timer's value (the speed of the stability test) could not be changed on the fly.\n\nI was wondering why it happened, so I simply recreated the ConstantTimerGui and ConstantTimer class itself (on a different name) and logged method calls on them.\n\ninteresting issue 1)\nIt turned out, that MyTimerGui was instantiated and init'ed at the startup time of JMeter (when there were no visible TimerGUI in JMeter at all).\n\nLater on, I created a simple test plan, with an empty java sampler and with my timer.\nA new MyTimerGui instance was created and init'ed. A Timer object is created here through the createTestElement() on the Gui.\ninteresting issue 2)\nSeveral methods on MyConstantTimerGui was called 5 times, just because it was created: modifyTestElment(), clearGui(), configure() and those methods, that were called by these (getDelay, setDelay, configureTestElement...\n\ninteresting issue 3)\nWhen I started my plan two brand new MyTimer instance were created. The first one was just left to the garbage collection, it is never referenced again, as far as I see. On the second one the iterationStart() and the delay() methods were called, on each round, which is OK, except I thought those methods should have been called on the firstly created Timer object (created by the Gui's createTestElement() method).\n\ninteresting issue 4) (sounds like a bug to me)\nwhen I change the delay of the timer, the Gui changes the delay's value on the first created Timer object, not on which the framework is continuosuly calling the delay() and the iterationStart() methods.\n\nSummarizing it seems at the first sight, that the problem is, that two extra Timers were created on starting a test instead of using the one, which was created by the Gui component itself.\nBut. The 3rd (used) Timer object is able to retrieve the delay's value set before starting the test, so my assumption would be that there is a problem with the property container inside the Timers... I don't know.\n\nDon't you think it would be very useful to be able to finetune a stability test during the test execution itself? For example to measure the maximum throughput of the system?\nCurrently there is only one way I can see as solution: during cloning the Timers, the property map should not be cloned but the map's reference should be copied. But it needs some hack, since the map is a private field of the AbstractTestElement...\n\nbr,\nSandor"}, {"count": 1, "tags": [], "bug_id": 48286, "attachment_id": null, "id": 132335, "time": "2009-11-25T13:52:45Z", "creator": "sebb@apache.org", "creation_time": "2009-11-25T13:52:45Z", "is_private": false, "text": "A work-round is to use the Constant Throughput timer instead.\nIMO this is more suited to the job anyway.\n\nSee for example:\n\nhttp://jakarta.apache.org/jmeter/usermanual/best-practices.html#beanshell_server\n\nIs that sufficient for you?"}, {"count": 2, "tags": [], "creator": "vass.sanyi@freemail.hu", "attachment_id": null, "id": 132336, "time": "2009-11-25T14:43:44Z", "bug_id": 48286, "creation_time": "2009-11-25T14:43:44Z", "is_private": false, "text": "Well, dereferencing the delay value with a variable is a good workaround for the case, although not an elegant solution of the problem, IMHO.\nI can't see the point why were the timers designed that way, that their delay values are not changeable directly on the gui, during a test on-the-fly. That's why I assumed it was a bug.\nThe three Timer instance generation and the unnecessary method calls are just an other issue. Currently they don't cause any problem, but I doubt they should be created and called 5 times.\n\nAnyway, regarding of the static delay value, the throughput timer behaves the same way as the normal constant timer, its delay value is not changeable from the GUI during a running test.\n\nOn the other hand you are right: in most cases the throughput timer is way much useful timer than the constant timer.\n\n\nAs far as I see, the solution would be only that the clone() method of the timer(s) does not clone the stored properties, but simply copies the reference of the properties' map. But I accept if this modification is not acceptable, since it might involve many other issues..."}, {"count": 3, "tags": [], "bug_id": 48286, "text": "I misunderstood your issue; I thought the timer was not picking up changes to its variable.\n\nWhen the test run starts, the underlying plan as displayed in the GUI has to be processed into samplers etc that are copied for each thread. This allows the threads to operate independently.\n\nIt's just not possible to reflect subsequent GUI changes in the running code.", "id": 132337, "time": "2009-11-25T15:21:51Z", "creator": "sebb@apache.org", "creation_time": "2009-11-25T15:21:51Z", "is_private": false, "attachment_id": null}, {"count": 4, "tags": [], "bug_id": 48286, "text": "I'm sorry to hear that... :)\n\n\nThank you for your time!", "id": 132346, "time": "2009-11-25T23:54:36Z", "creator": "vass.sanyi@freemail.hu", "creation_time": "2009-11-25T23:54:36Z", "is_private": false, "attachment_id": null}]