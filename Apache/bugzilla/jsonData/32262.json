[{"count": 0, "attachment_id": null, "bug_id": 32262, "is_private": false, "id": 66989, "time": "2004-11-16T10:33:38Z", "creator": "frederic.bages@123multimedia.com", "creation_time": "2004-11-16T10:33:38Z", "tags": [], "text": "Recently we got the following message \"SEVERE: Caught exception \n(java.lang.OutOfMemoryError: unable to create new native thread) executing \norg.apache.tomcat.util.net.TcpWorkerThread@7effa5, terminating thread\". Tomcat \nstopped responding to request but was still alive. This message comes from the \nThreadPool class \n(jakarta-tomcat-connectors/util/java/org/apache/tomcat/util/threads/ThreadPool.java) \nwhen an exception is received. This exception comes from the TcpWorkerThread \nand is an OutOfMemoryError. I don't know exactly where this exception is \nthrown but it could be from these lines : \n \n            // Accept a new connection \n            Socket s = null; \n            try { \n                s = endpoint.acceptSocket(); \n            } finally { \n                // Continue accepting on another thread... \n                if (endpoint.isRunning()) { \n                    endpoint.tp.runIt(this); \n                } \n            } \n \nThe lines int ThreadPool catching the exception are : \n \n                        /* Check if should execute a runnable.  */ \n                        try { \n                            if (noThData) { \n                                if (_toRun != null) { \n                                    Object thData[] = _toRun.getInitData(); \n                                    t.setThreadData(p, thData); \n                                    if (ThreadPool.log.isDebugEnabled()) \n                                        ThreadPool.log.debug( \n                                            \"Getting new thread data\"); \n                                } \n                                noThData = false; \n                            } \n \n                            if (_shouldRun) { \n                                if (_toRun != null) { \n                                    _toRun.runIt(t.getThreadData(p)); \n                                } else if (toRunRunnable != null) { \n                                    toRunRunnable.run(); \n                                } else { \n                                    if (ThreadPool.log.isDebugEnabled()) \n                                    ThreadPool.log.debug(\"No toRun ???\"); \n                                } \n                            } \n                        } catch (Throwable t) { \n                            ThreadPool.log.error(sm.getString \n                                (\"threadpool.thread_error\", t, \ntoRun.toString())); \n                            /* \n                             * The runnable throw an exception (can be even a \nThreadDeath), \n                             * signalling that the thread die. \n                             * \n                            * The meaning is that we should release the thread \nfrom \n                            * the pool. \n                            */ \n                            shouldTerminate = true; \n                            shouldRun = false; \n                            p.notifyThreadEnd(this); \n                        } finally { \n                            if (_shouldRun) { \n                                shouldRun = false; \n                                /* \n                                * Notify the pool that the thread is now idle. \n                                 */ \n                                p.returnController(this); \n                            } \n                        } \n \n \nand the ThreadPool runIt method is : \n \n        public synchronized void runIt(ThreadPoolRunnable toRun) { \n     this.toRun = toRun; \n     // Do not re-init, the whole idea is to run init only once per \n     // thread - the pool is supposed to run a single task, that is \n     // initialized once. \n            // noThData = true; \n            shouldRun = true; \n            this.notify(); \n        } \n \nAs i had problems seeing how all this was working together i made a simple \ntest to check if there could be a problem with this code when throwing an \nexception in place of acceptSocket(). Here is the test code : \n \n \npackage org.apache.tomcat.util.net; \n \nimport org.apache.tomcat.util.threads.ThreadPool; \nimport org.apache.tomcat.util.threads.ThreadPoolRunnable; \n \npublic class TcpPoolTest { \n \n static ThreadPool tp = null; \n \n  public static void main( String args[] ) { \n tp = new ThreadPool(); \n tp.setMaxThreads(200); \n tp.start(); \n tp.runIt( new Worker() ); \n while ( true ) { \n                try { \n                    Thread.sleep(1000); \n   System.out.println(\"Sleeping.\"); \n                } catch (InterruptedException e) { \n                    // Ignore \n                } \n } \n  } \n \n  static class Worker implements ThreadPoolRunnable { \n \n    public Object[] getInitData() { \n        return new Object[0]; \n    } \n \n public void runIt(Object perThrData[]) { \n  try { \n                 System.out.println(\"runIt\"); \n   throw new RuntimeException(); \n  } finally { \n     // Continue accepting on another thread... \n                    tp.runIt(this); \n                } \n        } \n  } \n} \n \nSave it in jakarta-tomcat-connectors/util/java/org/apache/tomcat/util/net/, \nrun ant from jakarta-tomcat-connectors (there are errors but what we need is \ncompiled), then run with java -cp \ndist/lib/tomcat-util.jar:PATH_TO_COMMONS_LOG/commons-logging.jar \norg.apache.tomcat.util.net.TcpPoolTest \n \nHere is the test trace : \n \nrunIt \nrunIt \nrunIt \nrunIt \nNov 16, 2004 10:25:03 AM \norg.apache.tomcat.util.threads.ThreadPool$ControlRunnable run \nSEVERE: Caught exception (java.lang.RuntimeException) executing \norg.apache.tomcat.util.net.TcpPoolTest$Worker@a981ca, terminating thread \nNov 16, 2004 10:25:03 AM \norg.apache.tomcat.util.threads.ThreadPool$ControlRunnable run \nSEVERE: Caught exception (java.lang.RuntimeException) executing \norg.apache.tomcat.util.net.TcpPoolTest$Worker@a981ca, terminating thread \nNov 16, 2004 10:25:03 AM \norg.apache.tomcat.util.threads.ThreadPool$ControlRunnable run \nSEVERE: Caught exception (java.lang.RuntimeException) executing \norg.apache.tomcat.util.net.TcpPoolTest$Worker@a981ca, terminating thread \nNov 16, 2004 10:25:03 AM \norg.apache.tomcat.util.threads.ThreadPool$ControlRunnable run \nSEVERE: Caught exception (java.lang.RuntimeException) executing \norg.apache.tomcat.util.net.TcpPoolTest$Worker@a981ca, terminating thread \nrunIt \nNov 16, 2004 10:25:03 AM \norg.apache.tomcat.util.threads.ThreadPool$ControlRunnable run \nSEVERE: Caught exception (java.lang.RuntimeException) executing \norg.apache.tomcat.util.net.TcpPoolTest$Worker@a981ca, terminating thread \nSleeping. \nSleeping. \nSleeping. \nSleeping. \nSleeping. \nSleeping. \nSleeping. \n \nI would have expected to see infinite \"runIt\" output or at least *max threads* \ntimes."}, {"count": 1, "tags": [], "text": "Which OS? If SUSE 8 32Bit: Their Thread Library reserves 2MB of stack space per\nThread which leads to only about 400 Threads possible per 32-Bit process.\n\nThe first thread created above that will cause an OutOfMemoryError exception and\nthen there will be no more accept, so Tomcat is no longer reachable.\n\nAjust your ThreadPool maximum to what your OS supports.\n\n*** This bug has been marked as a duplicate of 31426 ***", "attachment_id": null, "bug_id": 32262, "id": 66990, "time": "2004-11-16T10:43:03Z", "creator": "rainer.jung@kippdata.de", "creation_time": "2004-11-16T10:43:03Z", "is_private": false}]