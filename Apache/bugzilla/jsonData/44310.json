[{"count": 0, "attachment_id": null, "bug_id": 44310, "is_private": false, "id": 113189, "time": "2008-01-28T06:52:49Z", "creator": "cpierret@sparus-software.com", "creation_time": "2008-01-28T06:52:49Z", "tags": [], "text": "When using asynchronous sending (with async receive through Comet API), a\nservlet can try to use a recycled response and its output stream by error.\nIf it is the case, then some random client may get the data sent to another client.\nAn exception is thrown :\njava.lang.NullPointerException\n\tat\norg.apache.coyote.http11.InternalNioOutputBuffer.addToBB(InternalNioOutputBuffer.java:615)\n\tat\norg.apache.coyote.http11.InternalNioOutputBuffer.commit(InternalNioOutputBuffer.java:608)\n\tat org.apache.coyote.http11.Http11NioProcessor.action(Http11NioProcessor.java:1017)\n\tat org.apache.coyote.Response.action(Response.java:183)\n\tat org.apache.coyote.Response.sendHeaders(Response.java:379)\n\tat org.apache.catalina.connector.OutputBuffer.doFlush(OutputBuffer.java:305)\n\tat org.apache.catalina.connector.OutputBuffer.flush(OutputBuffer.java:288)\n\tat\norg.apache.catalina.connector.CoyoteOutputStream.flush(CoyoteOutputStream.java:98)\n\nBy activating\n-Dorg.apache.catalina.connector.RECYCLE_FACADES=true\non the command line, the problem of data corruption does not occur anymore\n(exception occurs in write and not flush).\n\nIt is a robustness issue for applications trying to use asynchronous IOs in tomcat."}, {"count": 1, "tags": [], "bug_id": 44310, "attachment_id": 21437, "is_private": false, "id": 113190, "time": "2008-01-28T06:57:16Z", "creator": "cpierret@sparus-software.com", "creation_time": "2008-01-28T06:57:16Z", "text": "Created attachment 21437\nFixing recycle code for Coyote Response\n\nA patch improving robustness of recycle code"}, {"count": 2, "tags": [], "creator": "cpierret@sparus-software.com", "text": "Thinking about it, it could be used to create a security exploit between webapps.\ne.g.: You could write a webapp that could send arbitrary data to clients of\nanother webapp ...\n", "id": 113192, "time": "2008-01-28T07:00:26Z", "bug_id": 44310, "creation_time": "2008-01-28T07:00:26Z", "is_private": false, "attachment_id": null}, {"count": 3, "tags": [], "bug_id": 44310, "text": "Could you be clearer how this happens please. It looks at the minute as if the\nroot cause of this is a coding error in the servlet.", "id": 113228, "time": "2008-01-28T12:30:27Z", "creator": "markt@apache.org", "creation_time": "2008-01-28T12:30:27Z", "is_private": false, "attachment_id": null}, {"count": 4, "tags": [], "bug_id": 44310, "text": "Short explanation: \nUsing this failure, a black hat could craft a malicious application in order to\nwrite arbitrary data to a random connection in any web app in the same tomcat\ninstance.\n\nLong explanation:\nWhen developing asynchronous IO on top of tomcat, one need some kind of thread\npool writing asynchronously on sockets (through response's outputStream) and use\nComet API for reading.\nWhen doing so, you need to track any error or exception that may occur and avoid\nany thread writing as soon as any such error or exception occurs while reading\n(say a mobile device disconnected due to bad cellular network condition).  It is\nclose to impossible to ensure such behavior (if you can prove me wrong,  you are\nhired and will get big bonuses from me :-).  While in the process of running\nstability and load testing on such an application, where we made a lot of effort\nto avoid such bad behavior, we encountered rare cases that produced such bad\ncondition (using the outputstream from a recycled response) thus resulting in\ndata corruption in random other client connection.  It took several weeks to\nfind out why it was occurring and the consequences of such error is extremely\nbad: \"data corruption!\". We still do not see how to avoid all cases that could\nlead it to occur.\n\nFurthermore, the patch is attached, simple (5 lines moved) and very unlikely to\nintroduce any regression.\n\nI have no requirement to include it in 6.0.16 since I have a workaround (disable\nrecycling facades), but I think that other developers may encounter this kind of\nissue and take a lot of time (one man month in our case) to find this same\nworkaround.", "id": 113229, "time": "2008-01-28T12:55:03Z", "creator": "cpierret@sparus-software.com", "creation_time": "2008-01-28T12:55:03Z", "is_private": false, "attachment_id": null}, {"count": 5, "tags": [], "creator": "markt@apache.org", "text": "My current thoughts are that the option should be documented as recommended\nconfiguration for comet on the appropriate page of the documentation.", "id": 113230, "time": "2008-01-28T13:21:36Z", "bug_id": 44310, "creation_time": "2008-01-28T13:21:36Z", "is_private": false, "attachment_id": null}, {"count": 6, "attachment_id": null, "bug_id": 44310, "is_private": false, "id": 113239, "time": "2008-01-28T15:36:09Z", "creator": "cpierret@sparus-software.com", "creation_time": "2008-01-28T15:36:09Z", "tags": [], "text": "This issue does not depend on the usage of the Comet API.\nIt is related to the usage of the Coyote Response object with sends occurring in\nseparate thread as read.\n\nIn Response.recycle(), the outputBuffer is always recycled and neither the\nResponse that references the outputStream that references the outputBuffer are.\n\nIt can lead to the outputStream referencing the outputBuffer reallocated to\nanother outputStream in another Response object, which can occur as soon as you\ntry to send data asynchronously in another thread (due to read errors not\ndepending on the usage of Comet). \n\nAt least the outputBuffer should not be recycled by default in this case for\nconsistency, since there are two public API objects referencing it without being\nrecycled.  IMHO, the behaviour of the Response.recyle can be viewed as\ninconsistent and can lead to inter web app side effects.\nThe attached patch fixes this issue with a regression risk that is extremely low .\n\n"}, {"count": 7, "attachment_id": null, "creator": "funkman@joedog.org", "is_private": false, "id": 113242, "time": "2008-01-28T16:57:17Z", "bug_id": 44310, "creation_time": "2008-01-28T16:57:17Z", "tags": [], "text": "If a security manager is enabled, the response is already discarded and not\nrecycled. This means in a shared/hosted (or any tin foil hat like) environment,\na black hat couldn't exploit this issue. \n\nThe spec is clear about servlets not reusing requests/responses outside of the\ncurrent request. \n\nFilip/Remy are much in tune with the comet api internals and can comment if the\nabove is incorrect.\n"}, {"count": 8, "tags": [], "bug_id": 44310, "text": "I agree the current servlet spec is quite clear about not reusing objects\noutside of the request/response scope.\nThe servlet spec does not offer any support for asynchronous I/Os, which is the\ncontext of the current request.\nIn order to improve overall robustness of tomcat in front of what can be\nconsidered bad programming in the context of the current servlet spec but is\nrequired to implement asynchronous SENDs (using an application-defined thread\nSEND pool that have no real way to sync with RECV errors without blocking), I\nsuggested that the lifecycle of public objects (Response, OutputStream)\nreferencing internal implementation details (OutputBuffer) be in sync.\nThe outputBuffer is recycled, but public objects that may have been stored for\napplication-defined purposes are still pointing to it, which is , in my opinion,\nnot the best design possible.\nI have a design pattern of trying to keep related API objects' lifecycles in\nsync to avoid the kind of issue I was experiencing before applying the patch.\nI will anyhow ship my product with this patch in my installer , which packages\ntomcat inside.\ne.g.: the application I am talking about is a commercial Mobile SSL VPN based on\ntomcat. It may be bold, but it works like a charm...", "id": 113262, "time": "2008-01-29T04:24:22Z", "creator": "cpierret@sparus-software.com", "creation_time": "2008-01-29T04:24:22Z", "is_private": false, "attachment_id": null}]