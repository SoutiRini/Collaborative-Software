[{"count": 0, "tags": [], "bug_id": 51234, "attachment_id": null, "id": 146473, "creation_time": "2011-05-20T09:37:47Z", "time": "2011-05-20T09:37:47Z", "creator": "a.kupcov@gmail.com", "text": "http://svn.apache.org/repos/asf/tomcat/taglibs/standard/trunk/impl/src/main/java/org/apache/taglibs/standard/tag/common/fmt/FormatNumberSupport.java\n\n==== Cut ====\n\n        if (input instanceof String) {\n            try {\n                if (((String) input).indexOf('.') != -1) {\n                    input = Double.valueOf((String) input);\n                } else {\n                    input = Long.valueOf((String) input);\n                }\n            } catch (NumberFormatException nfe) {\n                throw new JspException(\n                        Resources.getMessage(\"FORMAT_NUMBER_PARSE_ERROR\", input),\n                        nfe);\n            }\n        }\n\n==== End of cut ==========\n\nWhat about string value \"0e-8\"? It is a normal zero value but exception throws.", "is_private": false}, {"count": 1, "tags": [], "creator": "chris@christopherschultz.net", "attachment_id": null, "text": "I don't see any documentation that mandates what formats are acceptable to the \"value\" attribute of this tag.\n\nOne could argue that it doesn't accept European-style decimals numbers like \"1,05\" for 1 + point-oh-five, etc. (that's what <fmt:parseNumber> is for).\n\nBut it's true that \"0e-8\" is a valid String-value for a double, so the code could afford to be modified at least slightly.", "id": 146476, "time": "2011-05-20T15:24:57Z", "bug_id": 51234, "creation_time": "2011-05-20T15:24:57Z", "is_private": false}, {"count": 2, "tags": [], "creator": "a.kupcov@gmail.com", "attachment_id": null, "text": "I'm getting data from a database query. One of the values \u200b\u200b- 0 in the form of \"0E-8\" and this value can not be shown in the output JSP because an exception is thrown. I do not use European-style decimals numbers. I think one of the solutions - in this example, besides the point look for the presence of a character 'e' (and 'E').", "id": 146490, "time": "2011-05-20T19:45:51Z", "bug_id": 51234, "creation_time": "2011-05-20T19:45:51Z", "is_private": false}, {"count": 3, "tags": [], "bug_id": 51234, "attachment_id": null, "text": "From the JSTL 1.2 spec:\n\nIf the numeric value is given as a string literal, it is first parsed into a java.lang.Number. If the string does not contain any decimal point, it is parsed using java.lang.Long.valueOf(), or java.lang.Double.valueOf() otherwise.\n\nSo the code appears to at least match the spec, for what it's worth. As a workaround, perhaps you can make use of the pattern attribute...", "id": 146492, "time": "2011-05-20T20:09:41Z", "creator": "kschneider@gmail.com", "creation_time": "2011-05-20T20:09:41Z", "is_private": false}, {"count": 4, "tags": [], "creator": "a.kupcov@gmail.com", "attachment_id": null, "text": "Thanks for the link to the specification JSTL, but...\n\nFrom javadoc (\nhttp://download.oracle.com/javase/1.4.2/docs/api/java/lang/Double.html#valueOf%28java.lang.String%29) :\n============= cut =======\n    FloatValue:\n        Signopt NaN \n        Signopt Infinity \n        Signopt FloatingPointLiteral \n\nwhere Sign and FloatingPointLiteral are as defined in \u00a73.10.2 of the Java Language Specification.\n============= end of cut =======\n\nwell, look at the The Java Language Specification:\n\n============= cut =======\n3.10.2 Floating-Point Literals\nSee \u00a74.2.3 for a general discussion of the floating-point types and values.\n\nA floating-point literal has the following parts: a whole-number part, a decimal point (represented by an ASCII period character), a fractional part, an exponent, and a type suffix. The exponent, if present, is indicated by the ASCII letter e or E followed by an optionally signed integer.\n\nAt least one digit, in either the whole number or the fraction part, and either a decimal point, an exponent, or a float type suffix are required. All other parts are optional.\n\nA floating-point literal is of type float if it is suffixed with an ASCII letter F or f; otherwise its type is double and it can optionally be suffixed with an ASCII letter D or d.\n\nFloatingPointLiteral:\n\tDigits . Digitsopt ExponentPartopt FloatTypeSuffixopt\n\t. Digits ExponentPartopt FloatTypeSuffixopt\n\tDigits ExponentPart FloatTypeSuffixopt\n\tDigits ExponentPartopt FloatTypeSuffix\n\nExponentPart:\n\tExponentIndicator SignedInteger\n\nExponentIndicator: one of\n\te E\n\n============= end of cut =======\n\nI think that's enough. As a result, I think, JSTL ignores (or the developers have missed this point) ExponentIndicator in floating point numbers.\n\nWhat do you think maybe it's worth to fix a mistake?", "id": 146513, "time": "2011-05-21T09:50:32Z", "bug_id": 51234, "creation_time": "2011-05-21T09:50:32Z", "is_private": false}, {"count": 5, "tags": [], "creator": "jboynes@apache.org", "attachment_id": null, "text": "Resolving as WONTFIX as the spec defines what we must do here.", "id": 154149, "time": "2012-02-25T19:46:41Z", "bug_id": 51234, "creation_time": "2012-02-25T19:46:41Z", "is_private": false}]