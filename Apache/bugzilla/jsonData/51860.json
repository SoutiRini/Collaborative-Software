[{"count": 0, "tags": [], "bug_id": 51860, "attachment_id": null, "id": 149572, "time": "2011-09-21T10:03:38Z", "creator": "romanvt@inbox.ru", "creation_time": "2011-09-21T10:03:38Z", "is_private": false, "text": "Error reproduction conditions:\nTomcat 7.0.20 and 21.\nConnector=\"...Http11NioProtocol\"\nSSLEnabled=\"true\"\nsecure=\"true\"\nscheme=\"https\"\nclientAuth=true or false\nJDK 1.6.0_27 X64.\nAll operation systems.\n\nWhen user connects to https://, the SSL handshake fails with error:\njavax.net.ssl.SSLHandshakeException: no cipher suites in common\n\nIf we have same connector settings,  but if we change it to BIO: Connector=\"...Http11Protocol\", everything works fine.\n\nThe problem cause is a differences in SSL behavior between BIO and NIO handshake.\nI've found the workaround here:\nhttp://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6448723\n\n\nSee the org.apache.tomcat.util.net.jsse.JSSESocketFactory. JSSEKeyManager wraps the KeyManager.\nIn NIO mode, the KeyManager should have two extra methods:\n\n        public java.lang.String chooseEngineClientAlias(java.lang.String[] keyType, java.security.Principal[] issuers, javax.net.ssl.SSLEngine engine);\n\n        public java.lang.String chooseEngineServerAlias(java.lang.String keyType, java.security.Principal[] issuers, javax.net.ssl.SSLEngine engine);\n\nWe use a custom hand-made SSLInmplemention with extra features:\n* Keypair storage on hardware device or database\n* ExtendedKeyUsage verification in TrustManager\n* CRL validation on CRL distribution point online synchronization\n* ActiveDirectory account lookup by certificate\n\nThe complete source code of workaround:\npackage ru.yamoney.calypso.server.security.jsse;\n\nimport org.apache.tomcat.util.net.AbstractEndpoint;\nimport org.apache.tomcat.util.net.jsse.JSSESocketFactory;\nimport ru.yamoney.calypso.server.CommonKernel;\n\nimport javax.net.ssl.*;\nimport java.net.Socket;\nimport java.security.KeyStore;\nimport java.security.Principal;\nimport java.security.PrivateKey;\nimport java.security.cert.X509Certificate;\n\n/**\n * SSLImplementation for Tomcat-7-NIO\n *\n * @author Roman Tsirulnikov\n */\nfinal class CalypsoSSLSocketFactory\n        extends JSSESocketFactory {\n    private final CalypsoKeyManager keyManager;\n    private final X509TrustManager trustManager;\n\n    public CalypsoSSLSocketFactory(AbstractEndpoint endpoint) {\n        super(endpoint);\n        keyManager = CommonKernel.getInstance().getBean(\"server_calypsoKeyManager\");\n        trustManager = CommonKernel.getInstance().getBean(\"server_calypsoTrustManager\");\n    }\n\n    @Override\n    public KeyManager[] getKeyManagers() {\n        try {\n            KeyStore ks = keyManager.getKeyStore();\n            if (!ks.isKeyEntry(keyManager.getKeyAlias())) {\n                throw new IllegalArgumentException(\"Keystore entry is not a private keypair: \" + keyManager.getKeyAlias());\n            }\n\n            KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n            kmf.init(ks, keyManager.getKeystorePass().toCharArray());\n            KeyManager[] kms = kmf.getKeyManagers();\n            for (int i = 0; i < kms.length; i++) {\n                kms[i] = new NIOKeyManagerWrapper((X509KeyManager) kms[i], keyManager.getKeyAlias());\n            }\n\n            return kms;\n        } catch (Exception e) {\n            throw new IllegalArgumentException(\"SSLSocketFactory init: \" + e.getMessage(), e);\n        }\n    }\n\n    @Override\n    public TrustManager[] getTrustManagers() {\n        return new TrustManager[]{trustManager};\n    }\n\n    /**\n     * X509KeyManager wrapper\n     * Workaround for the SSL-NIO engine bug http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6448723\n     */\n    private final class NIOKeyManagerWrapper extends X509ExtendedKeyManager {\n        private X509KeyManager delegate;\n        private String serverKeyAlias;\n\n        /**\n         * Constructor.\n         *\n         * @param mgr            The X509KeyManager used as a delegate\n         * @param serverKeyAlias The alias name of the server's keypair and\n         *                       supporting certificate chain\n         */\n        NIOKeyManagerWrapper(X509KeyManager mgr, String serverKeyAlias) {\n            super();\n            this.delegate = mgr;\n            this.serverKeyAlias = serverKeyAlias;\n        }\n\n        /**\n         * Choose an alias to authenticate the client side of a secure socket,\n         * given the public key type and the list of certificate issuer authorities\n         * recognized by the peer (if any).\n         *\n         * @param keyType The key algorithm type name(s), ordered with the\n         *                most-preferred key type first\n         * @param issuers The list of acceptable CA issuer subject names, or null\n         *                if it does not matter which issuers are used\n         * @param socket  The socket to be used for this connection. This parameter\n         *                can be null, in which case this method will return the most generic\n         *                alias to use\n         * @return The alias name for the desired key, or null if there are no\n         *         matches\n         */\n        @Override\n        public String chooseClientAlias(String[] keyType, Principal[] issuers,\n                                        Socket socket) {\n            return delegate.chooseClientAlias(keyType, issuers, socket);\n        }\n\n        /**\n         * Returns this key manager's server key alias that was provided in the\n         * constructor.\n         *\n         * @param keyType The key algorithm type name (ignored)\n         * @param issuers The list of acceptable CA issuer subject names, or null\n         *                if it does not matter which issuers are used (ignored)\n         * @param socket  The socket to be used for this connection. This parameter\n         *                can be null, in which case this method will return the most generic\n         *                alias to use (ignored)\n         * @return Alias name for the desired key\n         */\n        @Override\n        public String chooseServerAlias(String keyType, Principal[] issuers,\n                                        Socket socket) {\n            return serverKeyAlias;\n        }\n\n        /**\n         * Returns the certificate chain associated with the given alias.\n         *\n         * @param alias The alias name\n         * @return Certificate chain (ordered with the user's certificate first\n         *         and the root certificate authority last), or null if the alias can't be\n         *         found\n         */\n        @Override\n        public X509Certificate[] getCertificateChain(String alias) {\n            return delegate.getCertificateChain(alias);\n        }\n\n        /**\n         * Get the matching aliases for authenticating the client side of a secure\n         * socket, given the public key type and the list of certificate issuer\n         * authorities recognized by the peer (if any).\n         *\n         * @param keyType The key algorithm type name\n         * @param issuers The list of acceptable CA issuer subject names, or null\n         *                if it does not matter which issuers are used\n         * @return Array of the matching alias names, or null if there were no\n         *         matches\n         */\n        @Override\n        public String[] getClientAliases(String keyType, Principal[] issuers) {\n            return delegate.getClientAliases(keyType, issuers);\n        }\n\n        /**\n         * Get the matching aliases for authenticating the server side of a secure\n         * socket, given the public key type and the list of certificate issuer\n         * authorities recognized by the peer (if any).\n         *\n         * @param keyType The key algorithm type name\n         * @param issuers The list of acceptable CA issuer subject names, or null\n         *                if it does not matter which issuers are used\n         * @return Array of the matching alias names, or null if there were no\n         *         matches\n         */\n        @Override\n        public String[] getServerAliases(String keyType, Principal[] issuers) {\n            return delegate.getServerAliases(keyType, issuers);\n        }\n\n        /**\n         * Returns the key associated with the given alias.\n         *\n         * @param alias The alias name\n         * @return The requested key, or null if the alias can't be found\n         */\n        @Override\n        public PrivateKey getPrivateKey(String alias) {\n            return delegate.getPrivateKey(alias);\n        }\n\n        public java.lang.String chooseEngineClientAlias(java.lang.String[] keyType, java.security.Principal[] issuers, javax.net.ssl.SSLEngine engine) {\n            return delegate.chooseClientAlias(keyType, issuers, null);\n        }\n\n        public java.lang.String chooseEngineServerAlias(java.lang.String keyType, java.security.Principal[] issuers, javax.net.ssl.SSLEngine engine) {\n            return serverKeyAlias;\n        }\n\n    }\n}"}, {"count": 1, "tags": [], "bug_id": 51860, "attachment_id": null, "is_private": false, "id": 149591, "time": "2011-09-21T14:17:13Z", "creator": "markt@apache.org", "creation_time": "2011-09-21T14:17:13Z", "text": "This appears to be related to the use of a custom SSLImplementation. No errors are observed with the default SSLImplmentation.\n\nThanks for the pointer to this issue. I have applied the fix to trunk and 7.0.x and it will be included in 7.0.22 onwards."}]