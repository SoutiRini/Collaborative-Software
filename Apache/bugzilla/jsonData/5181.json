[{"count": 0, "tags": [], "bug_id": 5181, "text": "Using Tomcat 4.0 and Catalina, after a short time, receive HttpConnector [8080] \nNo processor available, rejecting this connection error.  Changing \nconfiguration in server.xml does not resolve this.  This does not happen in the \nproduction 3.3 version", "id": 8422, "time": "2001-11-29T07:17:02Z", "creator": "chill10549@yahoo.com", "creation_time": "2001-11-29T07:17:02Z", "is_private": false, "attachment_id": null}, {"count": 1, "tags": [], "creator": "remm@apache.org", "text": "Could you:\n- Upgrade to 4.0.1\n- Give more details about your configuration and the web traffic, since this is \nthe first report about that we got\n\nYou can also try to raise the number of processors (using the 'maxProcessors' \nattribute of the Connector).", "id": 8424, "attachment_id": null, "bug_id": 5181, "creation_time": "2001-11-29T07:44:19Z", "time": "2001-11-29T07:44:19Z", "is_private": false}, {"count": 2, "tags": [], "bug_id": 5181, "text": "You can change the max and min processors till the cow come home it ignore \nthese.  Why don't you guys get a loadrunner and try it yourselves. You should \nsee the problem right aways", "id": 8470, "time": "2001-11-30T11:23:29Z", "creator": "chill10549@yahoo.com", "creation_time": "2001-11-30T11:23:29Z", "is_private": false, "attachment_id": null}, {"count": 3, "tags": [], "bug_id": 5181, "attachment_id": null, "id": 8472, "time": "2001-11-30T11:40:06Z", "creator": "chill10549@yahoo.com", "creation_time": "2001-11-30T11:40:06Z", "is_private": false, "text": "FYI this is on Linux Redhat 7.0"}, {"count": 4, "tags": [], "bug_id": 5181, "text": "Thanks for the details, it really helps a lot. AFAIK, it works very well for me;\nunless somebody can confirm the problem, I'll close it.", "id": 8483, "time": "2001-11-30T17:47:27Z", "creator": "remm@apache.org", "creation_time": "2001-11-30T17:47:27Z", "is_private": false, "attachment_id": null}, {"count": 5, "text": "I have tested this extensively using ab (which is the load testing tool from\nApache), without experiencing any problems. Since no further details were given,\nexcept than the bug was obvious (which clearly isn't the case for me), I'll\nclose the bug.", "bug_id": 5181, "attachment_id": null, "id": 8654, "time": "2001-12-05T16:32:46Z", "creator": "remm@apache.org", "creation_time": "2001-12-05T16:32:46Z", "tags": [], "is_private": false}, {"count": 6, "tags": [], "bug_id": 5181, "is_private": false, "id": 9723, "attachment_id": null, "creator": "dirk.herrmann@bb-data.de", "creation_time": "2002-01-17T22:18:04Z", "time": "2002-01-17T22:18:04Z", "text": "\nunder heavy load (more then 200 request at same time) this coud be help,\nchanges marked as !!! Changed !!!\n\n################################################################################\n\n/*\n * $Header:\n/home/a430499/PROJECTS/C-JAVIS/repository/de/bbdata/javis30/fix/HttpConnector.java,v\n1.1 2002/01/18 05:35:31 a430499 Exp $\n * $Revision: 1.1 $\n * $Date: 2002/01/18 05:35:31 $\n *\n * ====================================================================\n *\n * The Apache Software License, Version 1.1\n *\n * Copyright (c) 1999 The Apache Software Foundation.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * 3. The end-user documentation included with the redistribution, if\n *    any, must include the following acknowlegement:\n *       \"This product includes software developed by the\n *        Apache Software Foundation (http://www.apache.org/).\"\n *    Alternately, this acknowlegement may appear in the software itself,\n *    if and wherever such third-party acknowlegements normally appear.\n *\n * 4. The names \"The Jakarta Project\", \"Tomcat\", and \"Apache Software\n *    Foundation\" must not be used to endorse or promote products derived\n *    from this software without prior written permission. For written\n *    permission, please contact apache@apache.org.\n *\n * 5. Products derived from this software may not be called \"Apache\"\n *    nor may \"Apache\" appear in their names without prior written\n *    permission of the Apache Group.\n *\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n * ====================================================================\n *\n * This software consists of voluntary contributions made by many\n * individuals on behalf of the Apache Software Foundation.  For more\n * information on the Apache Software Foundation, please see\n * <http://www.apache.org/>.\n *\n * [Additional notices, if required by prior licensing conditions]\n *\n */\n\n\npackage org.apache.catalina.connector.http;\n\n\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.security.AccessControlException;\nimport java.util.Stack;\nimport java.util.Vector;\nimport java.util.Enumeration;\nimport org.apache.catalina.Connector;\nimport org.apache.catalina.Container;\nimport org.apache.catalina.HttpRequest;\nimport org.apache.catalina.HttpResponse;\nimport org.apache.catalina.Lifecycle;\nimport org.apache.catalina.LifecycleEvent;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.LifecycleListener;\nimport org.apache.catalina.Logger;\nimport org.apache.catalina.Request;\nimport org.apache.catalina.Response;\nimport org.apache.catalina.Service;\nimport org.apache.catalina.net.DefaultServerSocketFactory;\nimport org.apache.catalina.net.ServerSocketFactory;\nimport org.apache.catalina.util.LifecycleSupport;\nimport org.apache.catalina.util.StringManager;\n\n\n/**\n * Implementation of an HTTP/1.1 connector.\n *\n * @author Craig R. McClanahan\n * @author Remy Maucherat\n * @version $Revision: 1.1 $ $Date: 2002/01/18 05:35:31 $\n */\n\n\npublic final class HttpConnector\nimplements Connector, Lifecycle, Runnable {\n    \n    \n    // ----------------------------------------------------- Instance Variables\n    \n\n    // !!! START:Changes !!!\n    private int sleep = Constants.DEFAULT_CONNECTION_TIMEOUT;\n    private final short LOOPS = 128;\n    // !!! END:Changes !!!\n    \n\n    /**\n     * The <code>Service</code> we are associated with (if any).\n     */\n    private Service service = null;\n    \n    \n    /**\n     * The accept count for this Connector.\n     */\n    private int acceptCount = 10;\n    \n    \n    /**\n     * The IP address on which to bind, if any.  If <code>null</code>, all\n     * addresses on the server will be bound.\n     */\n    private String address = null;\n    \n    \n    /**\n     * The input buffer size we should create on input streams.\n     */\n    private int bufferSize = 2048;\n    \n    \n    /**\n     * The Container used for processing requests received by this Connector.\n     */\n    protected Container container = null;\n    \n    \n    /**\n     * The set of processors that have ever been created.\n     */\n    private Vector created = new Vector();\n    \n    \n    /**\n     * The current number of processors that have been created.\n     */\n    private int curProcessors = 0;\n    \n    \n    /**\n     * The debugging detail level for this component.\n     */\n    private int debug = 0;\n    \n    \n    /**\n     * The \"enable DNS lookups\" flag for this Connector.\n     */\n    private boolean enableLookups = false;\n    \n    \n    /**\n     * The server socket factory for this component.\n     */\n    private ServerSocketFactory factory = null;\n    \n    \n    /**\n     * Descriptive information about this Connector implementation.\n     */\n    private static final String info =\n    \"org.apache.catalina.connector.http.HttpConnector/1.0\";\n    \n    \n    /**\n     * The lifecycle event support for this component.\n     */\n    protected LifecycleSupport lifecycle = new LifecycleSupport(this);\n    \n    \n    /**\n     * The minimum number of processors to start at initialization time.\n     */\n    protected int minProcessors = 5;\n    \n    \n    /**\n     * The maximum number of processors allowed, or <0 for unlimited.\n     */\n    private int maxProcessors = 20;\n    \n    \n    /**\n     * Timeout value on the incoming connection.\n     * Note : a value of 0 means no timeout.\n     */\n    private int connectionTimeout = Constants.DEFAULT_CONNECTION_TIMEOUT;\n    \n    \n    /**\n     * The port number on which we listen for HTTP requests.\n     */\n    private int port = 8080;\n    \n    \n    /**\n     * The set of processors that have been created but are not currently\n     * being used to process a request.\n     */\n    private Stack processors = new Stack();\n    \n    \n    /**\n     * The server name to which we should pretend requests to this Connector\n     * were directed.  This is useful when operating Tomcat behind a proxy\n     * server, so that redirects get constructed accurately.  If not specified,\n     * the server name included in the <code>Host</code> header is used.\n     */\n    private String proxyName = null;\n    \n    \n    /**\n     * The server port to which we should pretent requests to this Connector\n     * were directed.  This is useful when operating Tomcat behind a proxy\n     * server, so that redirects get constructed accurately.  If not specified,\n     * the port number specified by the <code>port</code> property is used.\n     */\n    private int proxyPort = 0;\n    \n    \n    /**\n     * The redirect port for non-SSL to SSL redirects.\n     */\n    private int redirectPort = 443;\n    \n    \n    /**\n     * The request scheme that will be set on all requests received\n     * through this connector.\n     */\n    private String scheme = \"http\";\n    \n    \n    /**\n     * The secure connection flag that will be set on all requests received\n     * through this connector.\n     */\n    private boolean secure = false;\n    \n    \n    /**\n     * The server socket through which we listen for incoming TCP connections.\n     */\n    private ServerSocket serverSocket = null;\n    \n    \n    /**\n     * The string manager for this package.\n     */\n    private StringManager sm =\n    StringManager.getManager(Constants.Package);\n    \n    \n    /**\n     * Has this component been initialized yet?\n     */\n    private boolean initialized = false;\n    \n    \n    /**\n     * Has this component been started yet?\n     */\n    private boolean started = false;\n    \n    \n    /**\n     * The shutdown signal to our background thread\n     */\n    private boolean stopped = false;\n    \n    \n    /**\n     * The background thread.\n     */\n    private Thread thread = null;\n    \n    \n    /**\n     * The name to register for the background thread.\n     */\n    private String threadName = null;\n    \n    \n    /**\n     * The thread synchronization object.\n     */\n    private Object threadSync = new Object();\n    \n    \n    /**\n     * Is chunking allowed ?\n     */\n    private boolean allowChunking = true;\n    \n    \n    /**\n     * Use TCP no delay ?\n     */\n    private boolean tcpNoDelay = true;\n    \n    \n    // ------------------------------------------------------------- Properties\n    \n    \n    /**\n     * Return the <code>Service</code> with which we are associated (if any).\n     */\n    public Service getService() {\n        \n        return (this.service);\n        \n    }\n    \n    \n    /**\n     * Set the <code>Service</code> with which we are associated (if any).\n     *\n     * @param service The service that owns this Engine\n     */\n    public void setService(Service service) {\n        \n        this.service = service;\n        \n    }\n    \n    \n    /**\n     * Return the connection timeout for this Connector.\n     */\n    public int getConnectionTimeout() {\n        \n        return (connectionTimeout);\n        \n    }\n    \n    \n    /**\n     * Set the connection timeout for this Connector.\n     *\n     * @param count The new connection timeout\n     */\n    public void setConnectionTimeout(int connectionTimeout) {\n        \n        this.connectionTimeout = connectionTimeout;\n        \n    }\n    \n    \n    /**\n     * Return the accept count for this Connector.\n     */\n    public int getAcceptCount() {\n        \n        return (acceptCount);\n        \n    }\n    \n    \n    /**\n     * Set the accept count for this Connector.\n     *\n     * @param count The new accept count\n     */\n    public void setAcceptCount(int count) {\n        \n        this.acceptCount = count;\n        \n    }\n    \n    \n    /**\n     * Get the allow chunking flag.\n     */\n    public boolean isChunkingAllowed() {\n        \n        return (allowChunking);\n        \n    }\n    \n    \n    /**\n     * Set the allow chunking flag.\n     *\n     * @param allowChunking Allow chunking flag\n     */\n    public void setAllowChunking(boolean allowChunking) {\n        \n        this.allowChunking = allowChunking;\n        \n    }\n    \n    \n    /**\n     * Return the bind IP address for this Connector.\n     */\n    public String getAddress() {\n        \n        return (this.address);\n        \n    }\n    \n    \n    /**\n     * Set the bind IP address for this Connector.\n     *\n     * @param address The bind IP address\n     */\n    public void setAddress(String address) {\n        \n        this.address = address;\n        \n    }\n    \n    \n    /**\n     * Is this connector available for processing requests?\n     */\n    public boolean isAvailable() {\n        \n        return (started);\n        \n    }\n    \n    \n    /**\n     * Return the input buffer size for this Connector.\n     */\n    public int getBufferSize() {\n        \n        return (this.bufferSize);\n        \n    }\n    \n    \n    /**\n     * Set the input buffer size for this Connector.\n     *\n     * @param bufferSize The new input buffer size.\n     */\n    public void setBufferSize(int bufferSize) {\n        \n        this.bufferSize = bufferSize;\n        \n    }\n    \n    \n    /**\n     * Return the Container used for processing requests received by this\n     * Connector.\n     */\n    public Container getContainer() {\n        \n        return (container);\n        \n    }\n    \n    \n    /**\n     * Set the Container used for processing requests received by this\n     * Connector.\n     *\n     * @param container The new Container to use\n     */\n    public void setContainer(Container container) {\n        \n        this.container = container;\n        \n    }\n    \n    \n    /**\n     * Return the current number of processors that have been created.\n     */\n    public int getCurProcessors() {\n        \n        return (curProcessors);\n        \n    }\n    \n    \n    /**\n     * Return the debugging detail level for this component.\n     */\n    public int getDebug() {\n        \n        return (debug);\n        \n    }\n    \n    \n    /**\n     * Set the debugging detail level for this component.\n     *\n     * @param debug The new debugging detail level\n     */\n    public void setDebug(int debug) {\n        \n        this.debug = debug;\n        \n    }\n    \n    \n    /**\n     * Return the \"enable DNS lookups\" flag.\n     */\n    public boolean getEnableLookups() {\n        \n        return (this.enableLookups);\n        \n    }\n    \n    \n    /**\n     * Set the \"enable DNS lookups\" flag.\n     *\n     * @param enableLookups The new \"enable DNS lookups\" flag value\n     */\n    public void setEnableLookups(boolean enableLookups) {\n        \n        this.enableLookups = enableLookups;\n        \n    }\n    \n    \n    /**\n     * Return the server socket factory used by this Container.\n     */\n    public ServerSocketFactory getFactory() {\n        \n        if (this.factory == null) {\n            synchronized (this) {\n                this.factory = new DefaultServerSocketFactory();\n            }\n        }\n        \n        return (this.factory);\n        \n    }\n    \n    \n    /**\n     * Set the server socket factory used by this Container.\n     *\n     * @param factory The new server socket factory\n     */\n    public void setFactory(ServerSocketFactory factory) {\n        \n        this.factory = factory;\n        \n    }\n    \n    \n    /**\n     * Return descriptive information about this Connector implementation.\n     */\n    public String getInfo() {\n        \n        return (info);\n        \n    }\n    \n    \n    /**\n     * Return the minimum number of processors to start at initialization.\n     */\n    public int getMinProcessors() {\n        \n        return (minProcessors);\n        \n    }\n    \n    \n    /**\n     * Set the minimum number of processors to start at initialization.\n     *\n     * @param minProcessors The new minimum processors\n     */\n    public void setMinProcessors(int minProcessors) {\n        \n        this.minProcessors = minProcessors;\n        \n    }\n    \n    \n    /**\n     * Return the maximum number of processors allowed, or <0 for unlimited.\n     */\n    public int getMaxProcessors() {\n        \n        return (maxProcessors);\n        \n    }\n    \n    \n    /**\n     * Set the maximum number of processors allowed, or <0 for unlimited.\n     *\n     * @param maxProcessors The new maximum processors\n     */\n    public void setMaxProcessors(int maxProcessors) {\n        \n        this.maxProcessors = maxProcessors;\n        \n    }\n    \n    \n    /**\n     * Return the port number on which we listen for HTTP requests.\n     */\n    public int getPort() {\n        \n        return (this.port);\n        \n    }\n    \n    \n    /**\n     * Set the port number on which we listen for HTTP requests.\n     *\n     * @param port The new port number\n     */\n    public void setPort(int port) {\n        \n        this.port = port;\n        \n    }\n    \n    \n    /**\n     * Return the proxy server name for this Connector.\n     */\n    public String getProxyName() {\n        \n        return (this.proxyName);\n        \n    }\n    \n    \n    /**\n     * Set the proxy server name for this Connector.\n     *\n     * @param proxyName The new proxy server name\n     */\n    public void setProxyName(String proxyName) {\n        \n        this.proxyName = proxyName;\n        \n    }\n    \n    \n    /**\n     * Return the proxy server port for this Connector.\n     */\n    public int getProxyPort() {\n        \n        return (this.proxyPort);\n        \n    }\n    \n    \n    /**\n     * Set the proxy server port for this Connector.\n     *\n     * @param proxyPort The new proxy server port\n     */\n    public void setProxyPort(int proxyPort) {\n        \n        this.proxyPort = proxyPort;\n        \n    }\n    \n    \n    /**\n     * Return the port number to which a request should be redirected if\n     * it comes in on a non-SSL port and is subject to a security constraint\n     * with a transport guarantee that requires SSL.\n     */\n    public int getRedirectPort() {\n        \n        return (this.redirectPort);\n        \n    }\n    \n    \n    /**\n     * Set the redirect port number.\n     *\n     * @param redirectPort The redirect port number (non-SSL to SSL)\n     */\n    public void setRedirectPort(int redirectPort) {\n        \n        this.redirectPort = redirectPort;\n        \n    }\n    \n    \n    /**\n     * Return the scheme that will be assigned to requests received\n     * through this connector.  Default value is \"http\".\n     */\n    public String getScheme() {\n        \n        return (this.scheme);\n        \n    }\n    \n    \n    /**\n     * Set the scheme that will be assigned to requests received through\n     * this connector.\n     *\n     * @param scheme The new scheme\n     */\n    public void setScheme(String scheme) {\n        \n        this.scheme = scheme;\n        \n    }\n    \n    \n    /**\n     * Return the secure connection flag that will be assigned to requests\n     * received through this connector.  Default value is \"false\".\n     */\n    public boolean getSecure() {\n        \n        return (this.secure);\n        \n    }\n    \n    \n    /**\n     * Set the secure connection flag that will be assigned to requests\n     * received through this connector.\n     *\n     * @param secure The new secure connection flag\n     */\n    public void setSecure(boolean secure) {\n        \n        this.secure = secure;\n        \n    }\n    \n    \n    /**\n     * Return the TCP no delay flag value.\n     */\n    public boolean getTcpNoDelay() {\n        \n        return (this.tcpNoDelay);\n        \n    }\n    \n    \n    /**\n     * Set the TCP no delay flag which will be set on the socket after\n     * accepting a connection.\n     *\n     * @param tcpNoDelay The new TCP no delay flag\n     */\n    public void setTcpNoDelay(boolean tcpNoDelay) {\n        \n        this.tcpNoDelay = tcpNoDelay;\n        \n    }\n    \n    \n    // --------------------------------------------------------- Public Methods\n    \n    \n    /**\n     * Create (or allocate) and return a Request object suitable for\n     * specifying the contents of a Request to the responsible Container.\n     */\n    public Request createRequest() {\n        \n        //        if (debug >= 2)\n        //            log(\"createRequest: Creating new request\");\n        HttpRequestImpl request = new HttpRequestImpl();\n        request.setConnector(this);\n        return (request);\n        \n    }\n    \n    \n    /**\n     * Create (or allocate) and return a Response object suitable for\n     * receiving the contents of a Response from the responsible Container.\n     */\n    public Response createResponse() {\n        \n        //        if (debug >= 2)\n        //            log(\"createResponse: Creating new response\");\n        HttpResponseImpl response = new HttpResponseImpl();\n        response.setConnector(this);\n        return (response);\n        \n    }\n    \n    \n    // -------------------------------------------------------- Package Methods\n    \n    \n    /**\n     * Recycle the specified Processor so that it can be used again.\n     *\n     * @param processor The processor to be recycled\n     */\n    void recycle(HttpProcessor processor) {\n        \n        //        if (debug >= 2)\n        //            log(\"recycle: Recycling processor \" + processor);\n        processors.push(processor);\n        \n    }\n    \n    \n    // -------------------------------------------------------- Private Methods\n    \n    \n    /**\n     * Create (or allocate) and return an available processor for use in\n     * processing a specific HTTP request, if possible.  If the maximum\n     * allowed processors have already been created and are in use, return\n     * <code>null</code> instead.\n     */\n    private HttpProcessor createProcessor() {\n        \n        synchronized (processors) {\n            if (processors.size() > 0) {\n                // if (debug >= 2)\n                // log(\"createProcessor: Reusing existing processor\");\n                return ((HttpProcessor) processors.pop());\n            }\n            if ((maxProcessors > 0) && (curProcessors < maxProcessors)) {\n                // if (debug >= 2)\n                // log(\"createProcessor: Creating new processor\");\n                return (newProcessor());\n            } else {\n                if (maxProcessors < 0) {\n                    // if (debug >= 2)\n                    // log(\"createProcessor: Creating new processor\");\n                    return (newProcessor());\n                } else {\n                    // if (debug >= 2)\n                    // log(\"createProcessor: Cannot create new processor\");\n                    return (null);\n                }\n            }\n        }\n        \n    }\n    \n    \n    /**\n     * Log a message on the Logger associated with our Container (if any).\n     *\n     * @param message Message to be logged\n     */\n    private void log(String message) {\n        \n        Logger logger = container.getLogger();\n        String localName = threadName;\n        if (localName == null)\n            localName = \"HttpConnector\";\n        if (logger != null)\n            logger.log(localName + \" \" + message);\n        else\n            System.out.println(localName + \" \" + message);\n        \n    }\n    \n    \n    /**\n     * Log a message on the Logger associated with our Container (if any).\n     *\n     * @param message Message to be logged\n     * @param throwable Associated exception\n     */\n    private void log(String message, Throwable throwable) {\n        \n        Logger logger = container.getLogger();\n        String localName = threadName;\n        if (localName == null)\n            localName = \"HttpConnector\";\n        if (logger != null)\n            logger.log(localName + \" \" + message, throwable);\n        else {\n            System.out.println(localName + \" \" + message);\n            throwable.printStackTrace(System.out);\n        }\n        \n    }\n    \n    \n    /**\n     * Create and return a new processor suitable for processing HTTP\n     * requests and returning the corresponding responses.\n     */\n    private HttpProcessor newProcessor() {\n        \n        //        if (debug >= 2)\n        //            log(\"newProcessor: Creating new processor\");\n        HttpProcessor processor = new HttpProcessor(this, curProcessors++);\n        if (processor instanceof Lifecycle) {\n            try {\n                ((Lifecycle) processor).start();\n            } catch (LifecycleException e) {\n                log(\"newProcessor\", e);\n                return (null);\n            }\n        }\n        created.addElement(processor);\n        return (processor);\n        \n    }\n    \n    \n    /**\n     * Open and return the server socket for this Connector.  If an IP\n     * address has been specified, the socket will be opened only on that\n     * address; otherwise it will be opened on all addresses.\n     *\n     * @exception IOException if an input/output error occurs\n     */\n    private ServerSocket open() throws IOException {\n        \n        // Acquire the server socket factory for this Connector\n        ServerSocketFactory factory = getFactory();\n        \n        // If no address is specified, open a connection on all addresses\n        if (address == null) {\n            log(sm.getString(\"httpConnector.allAddresses\"));\n            return (factory.createSocket(port, acceptCount));\n        }\n        \n        // Open a server socket on the specified address\n        try {\n            InetAddress is = InetAddress.getByName(address);\n            log(sm.getString(\"httpConnector.anAddress\", address));\n            return (factory.createSocket(port, acceptCount, is));\n        } catch (Exception e) {\n            log(sm.getString(\"httpConnector.noAddress\", address));\n            return (factory.createSocket(port, acceptCount));\n        }\n        \n    }\n    \n    \n    // ---------------------------------------------- Background Thread Methods\n    \n    \n    /**\n     * The background thread that listens for incoming TCP/IP connections and\n     * hands them off to an appropriate processor.\n     */\n    public void run() {\n        if (connectionTimeout > 0) {\n            sleep = connectionTimeout / LOOPS;\n        }\n        \n        \n        // Loop until we receive a shutdown command\n        while (!stopped) {\n            \n            // Accept the next incoming connection from the server socket\n            Socket socket = null;\n            try {\n                //                if (debug >= 3)\n                //                    log(\"run: Waiting on serverSocket.accept()\");\n                socket = serverSocket.accept();\n                //                if (debug >= 3)\n                //                    log(\"run: Returned from\nserverSocket.accept()\");\n                if (connectionTimeout > 0)\n                    socket.setSoTimeout(connectionTimeout);\n                socket.setTcpNoDelay(tcpNoDelay);\n            } catch (AccessControlException ace) {\n                log(\"socket accept security exception\", ace);\n                continue;\n            } catch (IOException e) {\n                //                if (debug >= 3)\n                //                    log(\"run: Accept returned IOException\", e);\n                try {\n                    synchronized (threadSync) {\n                        if (started && !stopped)\n                            log(\"accept: \", e);\n                        if (!stopped) {\n                            //                    if (debug >= 3)\n                            //                        log(\"run: Closing server\nsocket\");\n                            serverSocket.close();\n                            //                        if (debug >= 3)\n                            //                            log(\"run: Reopening\nserver socket\");\n                            serverSocket = open();\n                        }\n                    }\n                    //                    if (debug >= 3)\n                    //                        log(\"run: IOException processing\ncompleted\");\n                } catch (IOException ex) {\n                    // If reopening fails, exit\n                    log(\"socket reopen: \", ex);\n                    break;\n                }\n                continue;\n            }\n            \n            \n            \n            // Hand this socket off to an appropriate processor\n            // !!! START:Changed !!! \n            HttpProcessor processor = null; short loops = LOOPS;\n            while (!stopped && (processor == null) && (--loops > 1)) {\n                processor = createProcessor();\n                if (processor == null) {\n                    try {\n                        Thread.currentThread().sleep(sleep);\n                    } catch (InterruptedException ignored) {}\n                }\n                else {\n                    //            if (debug >= 3)\n                    //                log(\"run: Assigning socket to processor \"\n+ processor);\n                    processor.assign(socket);\n                    //log(\"run:try \" + (LOOPS - loops) + \"/\" + sleep + \"ms for ip\n\" + socket.getInetAddress().getHostAddress());\n                    // The processor will recycle itself when it finishes\n                    break;\n                }\n            }\n            \n            if (processor == null) {\n                try {\n                    log(sm.getString(\"httpConnector.noProcessor\"));\n                    socket.close();\n                } catch (IOException e) {\n                    ;\n                }\n            }\n            // !!! END:Changed !!! \n\n        }\n        \n        // Notify the threadStop() method that we have shut ourselves down\n        //        if (debug >= 3)\n        //            log(\"run: Notifying threadStop() that we have shut down\");\n        synchronized (threadSync) {\n            threadSync.notifyAll();\n        }\n        \n    }\n    \n    \n    /**\n     * Start the background processing thread.\n     */\n    private void threadStart() {\n        \n        log(sm.getString(\"httpConnector.starting\"));\n        \n        thread = new Thread(this, threadName);\n        thread.setDaemon(true);\n        thread.start();\n        \n    }\n    \n    \n    /**\n     * Stop the background processing thread.\n     */\n    private void threadStop() {\n        \n        log(sm.getString(\"httpConnector.stopping\"));\n        \n        stopped = true;\n        try {\n            threadSync.wait(5000);\n        } catch (InterruptedException e) {\n            ;\n        }\n        thread = null;\n        \n    }\n    \n    \n    // ------------------------------------------------------ Lifecycle Methods\n    \n    \n    /**\n     * Add a lifecycle event listener to this component.\n     *\n     * @param listener The listener to add\n     */\n    public void addLifecycleListener(LifecycleListener listener) {\n        \n        lifecycle.addLifecycleListener(listener);\n        \n    }\n    \n    \n    /**\n     * Remove a lifecycle event listener from this component.\n     *\n     * @param listener The listener to add\n     */\n    public void removeLifecycleListener(LifecycleListener listener) {\n        \n        lifecycle.removeLifecycleListener(listener);\n        \n    }\n    \n    \n    /**\n     * Initialize this connector (create ServerSocket here!)\n     */\n    public void initialize()\n    throws LifecycleException {\n        if (initialized)\n            throw new LifecycleException(\n            sm.getString(\"httpConnector.alreadyInitialized\"));\n        this.initialized=true;\n        \n        // Establish a server socket on the specified port\n        try {\n            serverSocket = open();\n        } catch (IOException e) {\n            throw new LifecycleException(threadName + \".open\", e);\n        }\n        \n    }\n    \n    \n    /**\n     * Begin processing requests via this Connector.\n     *\n     * @exception LifecycleException if a fatal startup error occurs\n     */\n    public void start() throws LifecycleException {\n        \n        // Validate and update our current state\n        if (started)\n            throw new LifecycleException\n            (sm.getString(\"httpConnector.alreadyStarted\"));\n        threadName = \"HttpConnector[\" + port + \"]\";\n        lifecycle.fireLifecycleEvent(START_EVENT, null);\n        started = true;\n        \n        // Start our background thread\n        threadStart();\n        \n        // Create the specified minimum number of processors\n        while (curProcessors < minProcessors) {\n            if ((maxProcessors > 0) && (curProcessors >= maxProcessors))\n                break;\n            HttpProcessor processor = newProcessor();\n            recycle(processor);\n        }\n        \n    }\n    \n    \n    /**\n     * Terminate processing requests via this Connector.\n     *\n     * @exception LifecycleException if a fatal shutdown error occurs\n     */\n    public void stop() throws LifecycleException {\n        \n        // Validate and update our current state\n        if (!started)\n            throw new LifecycleException\n            (sm.getString(\"httpConnector.notStarted\"));\n        lifecycle.fireLifecycleEvent(STOP_EVENT, null);\n        started = false;\n        \n        // Gracefully shut down all processors we have created\n        for (int i = created.size() - 1; i >= 0; i--) {\n            HttpProcessor processor = (HttpProcessor) created.elementAt(i);\n            if (processor instanceof Lifecycle) {\n                try {\n                    ((Lifecycle) processor).stop();\n                } catch (LifecycleException e) {\n                    log(\"HttpConnector.stop\", e);\n                }\n            }\n        }\n        \n        synchronized (threadSync) {\n            // Close the server socket we were using\n            if (serverSocket != null) {\n                try {\n                    serverSocket.close();\n                } catch (IOException e) {\n                    ;\n                }\n            }\n            // Stop our background thread\n            threadStop();\n        }\n        serverSocket = null;\n        \n    }\n    \n    \n}\n"}, {"count": 7, "tags": [], "creator": "gvrossum@springsite.com", "is_private": false, "id": 11505, "attachment_id": null, "bug_id": 5181, "creation_time": "2002-03-06T13:39:13Z", "time": "2002-03-06T13:39:13Z", "text": "Urgent!:\n\nWe are experiencing the same error: \"HttpConnector [8080] No processor \navailable, rejecting this connection\".\nIt seems that this error occurs under heavy load, resulting in \"gaps\" in web \npages serverd by tomcat (missing images), \"server returned an unrecognized \nresponse\", blank pages, no repsonse at all. Very unpredictable behaviour!\nLog file shows up till 20 lines whith same error message.\n\nWhen the load decreases the error disappears.\n\nWe are running Apache Tomcat/4.0-b6-dev\non Win2000 Server / SDK 1.3.1\n\nPhenomena can be viewed at http://www.stemwijzer.nl (a dutch site, about \nelections). Try refreshing the page several times to show the problem.\n\nWe'll try the solution provided by Dirk Herrmann.\nPlease respond."}, {"count": 8, "tags": [], "bug_id": 5181, "attachment_id": null, "id": 11515, "time": "2002-03-06T17:29:11Z", "creator": "remm@apache.org", "creation_time": "2002-03-06T17:29:11Z", "is_private": false, "text": "First of all, you should upgrade, because 4.0b6 may be vulnerable to URL-based\nsecurity hacks. I understand it can be very hard to upgrade a production server,\nbut you should plan to do it here.\nI never experienced that particular problem, so I'm afraid I can't help much.\nThere are no known problems with the thread pooling code.\nI tried accessing your site, and didn't run into any problems."}, {"count": 9, "tags": [], "bug_id": 5181, "attachment_id": null, "id": 11853, "time": "2002-03-15T20:39:11Z", "creator": "remm@apache.org", "creation_time": "2002-03-15T20:39:11Z", "is_private": false, "text": "I still lack a test case, or some conclusive information on this bug. Also, I\ndon't think adding a retry mechanism is necessary."}, {"count": 10, "tags": [], "creator": "glenn@apache.org", "attachment_id": null, "is_private": false, "id": 12042, "time": "2002-03-20T03:26:01Z", "bug_id": 5181, "creation_time": "2002-03-20T03:26:01Z", "text": "I have not run into this problem using the Tomcat HTTP connector, but I have\nseen similar problems when using mod_jk to connect to Tomcat via AJP on a\nserver with heavy load.\n\nIn my case, after alot of detective work, I determined that Tomcat itself\nwas not the problem.\n\nThere are alot of things which can affect the ability of Tomcat to handle\na request regardless of whether they come from its own HTTP connector or\nfrom Apache via AJP.\n\nYou may have already looked at one or more of the following issues, I will\ninclude everything just for completeness.\n\nThe first thing I found is that JVM garbage collection can have a significant\nintermittent effect on Tomcat.  When GC occurs processing by Tomcat freezes,\nyet the OS will continue to accept requests on the port.  When GC has completed,\nTomcat will try to handle all pending requests.  If the GC took a significant\namount of time, this can cause a cascading affect where Tomcat runs out of\nprocessors to handle requests.  I made the mistake of setting the JVM -Xmx\ntoo large.  The JVM ended up using more memory than the OS would keep in\nphysical memory, when a Full GC occurred, performing GC on objects swapped\nout to disk caused GC to take a significant amount of time.  In my case,\n70 seconds.  Decreasing the -Xmx to make sure the JVM stack was always\nresident in physical memory fixed the problem.\n\nJVM Memory Usage and Garbage Collection\n---------------------------------------\n\nIt is very important to tune the JVM startup options for GC and JVM memory \nusage for a production server.\n\n1. Make sure you are running Tomcat with a JVM that supports Hotspot -server,\n   I use 1.3.1_02.\n\n2. Use incremental GC, the -xincgc java startup option.\n\n3. Try running Tomcat with the -verbose:gc java arg so you can collect\n   data on GC.\n\n4. Make sure the OS is keeping all JVM stack in physical memory and not\n   swapping it out to disk.  Reduce -Xmx if this is a problem.\n\n5. Try setting -Xms and -Xmx to the same size.\n\n6. Search the fine web for articles on JVM GC and JVM performance tuning.\n\nAfter researching and testing all of the above I significantly reduced the\nmaximum time for GC's.  99% of my GC's now run in < .05 sec, of the remaining,\nmost run at < 1 sec, no more than 5-10 times a day do I see a GC > 1 sec,\nand they never exceed 5 sec.\n\ndB access by applications\n-------------------------\n\nIf your applications uses a db, make sure you set it's connection timeout\nto a value > the max GC time you see.  Otherwise you will start seeing\ndb connection failures.  I set my db connection timeouts to 10 seconds.\n\nA problem with your database, or if you frequently reach the maxiumum\nconnections you allow in a db connection pool can cause the type of\nproblems you see.  If the db connections fail, or your connection pool\nis exhaused, each servlet which is waiting for a connection (remember\nI recommended 10 seconds) will eat up an HTTP or AJP processor for 10 seconds.\nThis can cause a cascading effect where you see alot of processors used\nby Tomcat.\n\nCheck your web applications for thread locking problems, or long delays.\n-----------------------------------------------------------------------\n\nTomcat can't do anything useful by itself, its the applications you\ninstall that provide the content.  There could very well be thread locking\nproblems or other bugs which cause delays in a servlet handling a request.\nThis can cause Tomcat to appear to fail due to runaway use of Processors.\n\nIncrease maxProcessors\n----------------------\n\nIncrease your maxProcessors to handle intermittent cascading of requests\ndue to GC, etc.  I set my maxProcessors to 2X max concurrent requests\nI see under heavy load.\n\nProposition for a change to Processors to help debug these problems\n--------------------------------------------------------------------\n\nAdding code to Processors so that they dump a stack trace for each\nexisting thread when the pool of processors is exhausted could provide\nvaluable information for tracking down the source of problems in\na web application or tomcat.  With a stack trace dump for each thread\nyou may be able to tell where the problem is.\n\nI will be committing some code for the mod_jk AJP processor which\ndoes this.\n\nAnd my comments here could be used as the start of a performance tuning\ndocument for Tomcat. AKA, Before you report a bug in Tomcat. :-)\n"}, {"count": 11, "tags": [], "creator": "gvrossum@springsite.com", "text": "Thanx for your 'article' on performance tuning, good information to have. We \nalready tuned our application as you described (not everything ofcourse).\n\nIn our case I found out that the we started having the HttpConnector problem \nafter some enthusiastic system administrator had turned off some default \nservices which run on Win2K Server. After he put everything back, the problem \nwas solved. Unfortunately, afterwards he could not tell me which services he \nhad stopped (what a system admin huh?).\nThe server load has increased up till 4 times (compared to the load when the \nproblem occurred) without having any problems (FYI we now reach over 120,000 \nhits per hour at peak values)\n\nSo I agree with you that Tomcat itself was not the problem. If I'll ever find\nout what services kept Tomcat from running at full speed, I'll let you know.", "id": 12056, "attachment_id": null, "bug_id": 5181, "creation_time": "2002-03-20T09:16:59Z", "time": "2002-03-20T09:16:59Z", "is_private": false}, {"count": 12, "text": "I can reproduce this bug every time with the following:\n\nTomcat 4.0.3\nJRE 1.4 (final release)\nTurbine TDK 2.1 - Sample App\nhttp://jakarta.apache.org/builds/jakarta-turbine/release/2.1/\n\nUsing IE 5.0 goto the URL:\nhttp://localhost:8080/newapp/servlet/newapp\nand hold down the F5 key for a bit.\n\nUsing JRE 1.3 it does not reproduce.\n\nAfter walking through the code, it appears (to someone not familiar with the\nsource) that this exception prevents the recycle of the HttpProcessor.  The net\neffect is that once maxProcessors is exceeded the server can never accept\nrequests again.\n\nStack Trace:\njava.lang.IllegalStateException: Current state = FLUSHED, new state = CODING_END\n\n        at java.nio.charset.CharsetEncoder.throwIllegalStateException(CharsetEnc\noder.java:933)\n        at java.nio.charset.CharsetEncoder.encode(CharsetEncoder.java:529)\n        at sun.nio.cs.StreamEncoder$CharsetSE.flushLeftoverChar(StreamEncoder.ja\nva:356)\n        at sun.nio.cs.StreamEncoder$CharsetSE.implClose(StreamEncoder.java:413)\n        at sun.nio.cs.StreamEncoder.close(StreamEncoder.java:158)\n        at java.io.OutputStreamWriter.close(OutputStreamWriter.java:222)\n        at java.io.PrintWriter.close(PrintWriter.java:137)\n        at org.apache.catalina.connector.ResponseBase.finishResponse(ResponseBas\ne.java:482)\n        at org.apache.catalina.connector.HttpResponseBase.finishResponse(HttpRes\nponseBase.java:236)\n        at org.apache.catalina.connector.http.HttpResponseImpl.finishResponse(Ht\ntpResponseImpl.java:288)\n        at org.apache.catalina.connector.http.HttpProcessor.process(HttpProcesso\nr.java:1039)\n        at org.apache.catalina.connector.http.HttpProcessor.run(HttpProcessor.ja\nva:1107)\n        at java.lang.Thread.run(Thread.java:536)", "bug_id": 5181, "attachment_id": null, "id": 12113, "time": "2002-03-21T08:23:11Z", "creator": "russelle@concur.com", "creation_time": "2002-03-21T08:23:11Z", "tags": [], "is_private": false}, {"count": 13, "tags": [], "bug_id": 5181, "is_private": false, "id": 12141, "attachment_id": null, "creator": "remm@apache.org", "creation_time": "2002-03-21T16:13:55Z", "time": "2002-03-21T16:13:55Z", "text": "This is a bug with JDK 1.4.\nThe processor not being recycled in that particular case has been fixed in \n4.0.4-b1."}, {"count": 14, "tags": [], "bug_id": 5181, "is_private": false, "id": 53884, "attachment_id": null, "creator": "dhay@lexmark.com", "creation_time": "2004-03-11T17:43:55Z", "time": "2004-03-11T17:43:55Z", "text": "I just ran into the same problem with Tomcat 4.1.12!  I'm running JMeter to \nstress an app, and after a couple of hours nothing else can connect and I get \nhundreds of lines of this error in the logs.  We are running 180 threads \nhitting tomcat, but with random delays on each thread of between 0 and 10 \nminutes, so I wouldn't call this a very heavy load.\n\nApparently this was fixed for 4.0.4-b1, according to Remy's comments below.\n\nAny ideas?\n\nMany thanks,\n\nDavid\n"}, {"text": "This connector is deprecated and no longer supported. Please use the Coyote \nHTTP connector instead.\n\nNo further work will take place against this bug.", "tags": [], "bug_id": 5181, "is_private": false, "count": 15, "id": 59492, "time": "2004-06-18T18:35:14Z", "creator": "markt@apache.org", "creation_time": "2004-06-18T18:35:14Z", "attachment_id": null}]