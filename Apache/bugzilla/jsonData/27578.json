[{"count": 0, "tags": [], "bug_id": 27578, "attachment_id": null, "id": 53833, "time": "2004-03-10T18:18:32Z", "creator": "ojd@aspectgroup.co.uk", "creation_time": "2004-03-10T18:18:32Z", "is_private": false, "text": "we have a load-balanced array of apache web servers and are trying to \nsyncronise content between them using webdav. to make the content optimally \ncacheable we have switched off using the inode number in the etag and have to \nhave the Last-Modified date the same across all the servers so the If-Modified-\nSince request header works as it hopes to.\n\nOli\n\n\ndiff -u repos.c.orig repos.c\n--- repos.c.orig        2004-03-10 17:32:57.000000000 +0000\n+++ repos.c     2004-03-10 12:35:14.000000000 +0000\n@@ -60,6 +60,7 @@\n #include \"apr_file_io.h\"\n #include \"apr_strings.h\"\n #include \"apr_buckets.h\"\n+#include \"apr_date.h\"\n \n #if APR_HAVE_STDIO_H\n #include <stdio.h>              /* for sprintf() */\n@@ -1940,10 +1959,32 @@\n         return 1;\n #endif\n \n+    if (propid == DAV_PROPID_getlastmodified )\n+        return 1;\n+\n     (void) dav_get_liveprop_info(propid, &dav_fs_liveprop_group, &info);\n     return info->is_writable;\n }\n \n+struct dav_fs_context\n+{\n+    int propid;\n+    union rollback\n+    {\n+        apr_time_t modtime;\n+        apr_fileperms_t perms;\n+    } oldvalue;\n+    union context\n+    {\n+        apr_time_t modtime;\n+        int perms;\n+    } value;\n+};\n+\n+apr_time_t xapr_date_parse_http(char*s)\n+{\n+return 12345000000000LL + (int)s;\n+}\n static dav_error *dav_fs_patch_validate(const dav_resource *resource,\n                                         const apr_xml_elem *elem,\n                                         int operation,\n@@ -1954,7 +1995,34 @@\n     const apr_text *f_cdata;\n     char value;\n     dav_elem_private *priv = elem->priv;\n+    struct dav_fs_context *fscontext;\n+\n+    fscontext = apr_pcalloc(resource->info->pool, sizeof(*fscontext) );\n+    fscontext->propid = priv->propid;\n+\n+    if ( priv->propid == DAV_PROPID_getlastmodified ) {\n+        if (operation == DAV_PROP_OP_DELETE)\n+            return dav_new_error(resource->info->pool, HTTP_CONFLICT, 0,\n+                             \"The 'lastmodified' property cannot be removed.\");\n+        if ( elem->first_cdata.first )\n+            cdata = elem->first_cdata.first;\n+        else if ( elem->first_child )\n+            cdata = elem->first_child->following_cdata.first;\n+        else\n+            cdata = NULL;\n \n+       if ( cdata == NULL )\n+            return dav_new_error(resource->info->pool, HTTP_CONFLICT, 0,\n+                             \"The 'lastmodified' property cannot be found.\");\n+        fscontext->value.modtime = apr_date_parse_http(cdata->text);\n+        short ttt = apr_date_parse_http(cdata->text);\n+        if ( fscontext->value.modtime == 0 ) {\n+            return dav_new_error(resource->info->pool, HTTP_CONFLICT, 0,\n+                             \"The 'lastmodified' property cannot be parsed.\");\n+        }\n+        *context = (void*)fscontext;\n+       return NULL;\n+    }\n     if (priv->propid != DAV_PROPID_FS_executable) {\n         *defer_to_dead = 1;\n         return NULL;\n@@ -1997,8 +2065,8 @@\n                              \"submitted is invalid.\");\n     }\n \n-    *context = (void *)(value == 'T');\n-\n+    fscontext->value.perms = (value == 'T');\n+    *context = (void*)fscontext;\n     return NULL;\n \n   too_long:\n@@ -2009,37 +2077,49 @@\n \n }\n \n+\n static dav_error *dav_fs_patch_exec(const dav_resource *resource,\n                                     const apr_xml_elem *elem,\n                                     int operation,\n                                     void *context,\n                                     dav_liveprop_rollback **rollback_ctx)\n {\n-    int value = context != NULL;\n-    apr_fileperms_t perms = resource->info->finfo.protection;\n-    int old_value = (perms & APR_UEXECUTE) != 0;\n-\n-    /* assert: prop == executable. operation == SET. */\n-\n-    /* don't do anything if there is no change. no rollback info either. */\n-    /* DBG2(\"new value=%d  (old=%d)\", value, old_value); */\n-    if (value == old_value)\n-        return NULL;\n-\n-    perms &= ~APR_UEXECUTE;\n-    if (value)\n-        perms |= APR_UEXECUTE;\n-\n-    if (apr_file_perms_set(resource->info->pathname, perms) != APR_SUCCESS) {\n-        return dav_new_error(resource->info->pool,\n+    struct dav_fs_context *fscontext;\n+    \n+    fscontext = (struct dav_fs_context*)context;\n+    if ( fscontext->propid == DAV_PROPID_getlastmodified ) {\n+        fscontext->oldvalue.modtime = resource->info->finfo.mtime;\n+        if ( apr_file_mtime_set(resource->info->pathname, fscontext-\n>value.modtime, resource->info->pool) != APR_SUCCESS )\n+            return dav_new_error(resource->info->pool,\n+                             HTTP_INTERNAL_SERVER_ERROR, 0,\n+                             \"Could not set the lastmodified date of the \"\n+                             \"target resource.\");\n+        resource->info->finfo.mtime = fscontext->value.modtime;\n+    } else if (fscontext->propid == DAV_PROPID_FS_executable ) {\n+        apr_fileperms_t perms = resource->info->finfo.protection;\n+        fscontext->oldvalue.perms = perms;\n+\n+        /* assert: prop == executable. operation == SET. */\n+\n+        /* don't do anything if there is no change. no rollback info either. */\n+        /* DBG2(\"new value=%d  (old=%d)\", value, old_value); */\n+\n+        perms &= ~APR_UEXECUTE;\n+        if (fscontext->value.perms != 0 )\n+            perms |= APR_UEXECUTE;\n+\n+        if ( perms != fscontext->oldvalue.perms )\n+            if (apr_file_perms_set(resource->info->pathname, perms) != \nAPR_SUCCESS) {\n+            return dav_new_error(resource->info->pool,\n                              HTTP_INTERNAL_SERVER_ERROR, 0,\n                              \"Could not set the executable flag of the \"\n                              \"target resource.\");\n-    }\n+            }\n \n-    /* update the resource and set up the rollback context */\n-    resource->info->finfo.protection = perms;\n-    *rollback_ctx = (dav_liveprop_rollback *)old_value;\n+        /* update the resource and set up the rollback context */\n+        resource->info->finfo.protection = perms;\n+    }\n+    *rollback_ctx = (dav_liveprop_rollback *)fscontext;\n \n     return NULL;\n }\n@@ -2057,8 +2137,17 @@\n                                         void *context,\n                                         dav_liveprop_rollback *rollback_ctx)\n {\n+    struct dav_fs_context *rollback = (struct dav_fs_context*)rollback_ctx;\n+    if ( rollback->propid == DAV_PROPID_getlastmodified ) {\n+        if ( apr_file_mtime_set(resource->info->pathname, rollback-\n>oldvalue.modtime, resource->info->pool) != APR_SUCCESS )\n+            return dav_new_error(resource->info->pool,\n+                             HTTP_INTERNAL_SERVER_ERROR, 0,\n+                             \"Could not set the lastmodified date of the \"\n+                             \"target resource.\");\n+        return NULL;\n+    }\n     apr_fileperms_t perms = resource->info->finfo.protection & ~APR_UEXECUTE;\n-    int value = rollback_ctx != NULL;\n+    int value = (rollback->oldvalue.perms & APR_UEXECUTE) != 0;\n \n     /* assert: prop == executable. operation == SET. */"}, {"count": 1, "tags": [], "bug_id": 27578, "attachment_id": null, "id": 166018, "time": "2013-03-19T22:11:05Z", "creator": "wiml@omnigroup.com", "creation_time": "2013-03-19T22:11:05Z", "is_private": false, "text": "++. I have also run into situation where I'd like to be able to set the last-modified-date via PROPPATCH."}, {"count": 2, "tags": [], "creator": "wiml@omnigroup.com", "attachment_id": 32560, "text": "Created attachment 32560\nUpdated patch against trunk\n\nI've attached an updated patch for this feature based on Oliver Dewdney's patch.\n\nThis patch applies to trunk or 2.4.x-dev, and also includes a configuration directive \"DAVAllowSetModTime\" which allows the feature to be enabled. By default it is disabled so that no one will be surprised by a change in behavior, but I think it might make sense to enable it in the 2.5.x versions.\n\nI also took the opportunity to clean up some code in _exec and _rollback. I think this fixes a bug where the executable flag of files could be spuriously cleared during rollback of a PROPPATCH that affects multiple files.", "id": 181692, "time": "2015-03-11T23:48:29Z", "bug_id": 27578, "creation_time": "2015-03-11T23:48:29Z", "is_private": false}]