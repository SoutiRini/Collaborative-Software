[{"count": 0, "tags": [], "bug_id": 8464, "attachment_id": null, "is_private": false, "id": 14623, "time": "2002-04-24T12:42:21Z", "creator": "JTait@wyrddreams.demon.co.uk", "creation_time": "2002-04-24T12:42:21Z", "text": "NOTE: This bug has been reproduced on Solaris 8 as well.\n\nI have the following working config for Apache 1.3.24:\n\nRewriteMap DAAC \"prg:/usr/j2se/bin/java -classpath\n/usr/apache/libexec/rewrite:/usr/apache/libexec/rewrite/jlog.jar DAAC 550\n/var/apache/logs/daac_log\"\nRewriteRule ^/Prot([^/]*)/(.+)     /${DAAC:Prot$1/$2|DENIED} [C]\nRewriteRule ^/DENIED$              - [F]\n\nThe config is simple enough, if the incoming request is for a file within a\ndirectory named, for example, /Protected, then the external rewrite engine gets\ncalled to perform authorisation (in reality there'd be an auth token or\nsomething in the URI).\n\nHowever, transferring this configuration to 2.0.35 does not have the desired\neffect -- in fact, the external rewrite engine is never exec'd.  This has been\ntested with the above command line, a very basic shell script, a Perl script and\na natively compiled binary -- none of them ever appear to get called (they\nshould all touch a file in the filesystem when they are run, and do so when run\nfrom the command line).\n\nThe C program I used is as follows:\n\n#include <stdio.h>\n#include <sys/time.h>\n\nint main(int argc, char *argv[]) {\n  char input[1024];\n  FILE *error_log;\n  struct timeval tv;\n  long delay;\n\n  if(argc < 2) {\n    printf(\"Usage: %s <millisecond delay>\\n\", argv[0]);\n    printf(\"Defaulting to 500ms\\n\");\n    delay = 500000;\n  } else {\n    delay = (atol(argv[1]) * 1000);\n  }\n  if (delay < 0) {\n    printf(\"Delay must be a positive integer\\n\");\n    return 1;\n  }\n\n  if((error_log = fopen(\"/tmp/DAAC.log\", \"a\")) == NULL) {\n    printf(\"Unable to open logfile\\n\");\n    return 2;\n  }\n\n  while (scanf(\"%1023s\", input)) {\n    tv.tv_sec = 0;\n    tv.tv_usec = delay;\n    fprintf(error_log, \"%s\\n\", input);\n    fflush(error_log);\n    select(0, NULL, NULL, NULL, &tv);\n    printf(\"%s\\n\", input);\n    fflush(stdout);\n  }\n  fclose(error_log);\n  return 0;\n}"}, {"count": 1, "tags": [], "bug_id": 8464, "attachment_id": 1814, "id": 15720, "time": "2002-05-08T16:21:09Z", "creator": "JTait@wyrddreams.demon.co.uk", "creation_time": "2002-05-08T16:21:09Z", "is_private": false, "text": "Created attachment 1814\nOutput of strace -f httpd -X"}, {"count": 2, "tags": [], "bug_id": 8464, "attachment_id": null, "is_private": false, "id": 16558, "time": "2002-05-22T16:50:26Z", "creator": "JTait@wyrddreams.demon.co.uk", "creation_time": "2002-05-22T16:50:26Z", "text": "I've looked into this a bit further with 2.0.36, and also compared to 1.3.24.\n\nIn 1.3.24, mod_rewrite execl's a shell process itself in the function\nrewritemap_program_child(), passing the user-supplied config line as an argument:\n\nexecl(SHELL_PATH, SHELL_PATH, \"-c\", (char *)cmd, NULL);\n\n\nThis works, even if you supply arguments to the program to be run.\n\nIn 2.0.36 it leaves the exec to APR:\n\n    if (((rc = apr_procattr_create(&procattr, p)) != APR_SUCCESS) ||\n        ((rc = apr_procattr_io_set(procattr, APR_FULL_BLOCK,\n                                  APR_FULL_NONBLOCK,\n                                  APR_FULL_NONBLOCK)) != APR_SUCCESS) ||\n        ((rc = apr_procattr_dir_set(procattr,\n                                   ap_make_dirstr_parent(p, progname)))\n         != APR_SUCCESS) ||\n        ((rc = apr_procattr_cmdtype_set(procattr, APR_PROGRAM)) != APR_SUCCESS)) {\n        /* Something bad happened, give up and go away. */\n    }\n    else {\n        procnew = apr_pcalloc(p, sizeof(*procnew));\n        rc = apr_proc_create(procnew, progname, NULL, NULL, procattr, p);\n\n\nThis works when the program doesn't have arguments to be passed, but fails if\nthere are arguments.  Looking at the apr_proc_create() function:\n\n        else if (attr->cmdtype == APR_PROGRAM) {\n            if (attr->detached) {\n                apr_proc_detach(APR_PROC_DETACH_DAEMONIZE);\n            }\n\n            execve(progname, (char * const *)args, (char * const *)env);\n        }\n\n\nNERK!  The whole user-supplied string is passed as progname, with args and env\nempty.\n\nI can get around this by running a shell script that runs my program with\narguments, but that's kinda messy.  I'd prefer to see mod_rewrite handle this\ncorrectly and pass in the args.\n\nIf I get time, I'll settle down and fix this.  If anyone wants to beat me to it...."}, {"count": 3, "tags": [], "bug_id": 8464, "attachment_id": null, "is_private": false, "id": 16848, "time": "2002-05-29T03:29:38Z", "creator": "jwoolley@apache.org", "creation_time": "2002-05-29T03:29:38Z", "text": "I committed the revised patch you posted to dev@httpd, with one change, which \nwas that I had to disable the stat of the program to avoid having to duplicate \nthe apr_tokenize_to_argv() call.  If the program doesn't exist, it will fail to \nstartup anyway, so this should still be fine.\n\nThanks!"}, {"count": 4, "tags": [], "text": "Okay, so the apr_stat() thing wasn't *quite* that easy... apr_proc_create()\ndoes not necessarily return an error if the program specified doesn't exist... \non Unix, it only returns an error if the fork() call itself failed.  Bah.  So I \nadded another apr_stat() call just after the apr_tokenize_to_argv() call has\nalready happened.\n\nAnyway, consider it fixed.  :)", "is_private": false, "id": 16849, "creator": "jwoolley@apache.org", "time": "2002-05-29T04:45:55Z", "bug_id": 8464, "creation_time": "2002-05-29T04:45:55Z", "attachment_id": null}]