[{"count": 0, "tags": [], "bug_id": 18456, "attachment_id": null, "id": 34029, "time": "2003-03-28T09:14:00Z", "creator": "tomasz@rtsoftware.com", "creation_time": "2003-03-28T09:14:00Z", "is_private": false, "text": "In a Tomcat 4.1.18 embedded within JBoss I have an application that uses \nFilters. At one point one of the filters decides if the current session should \nbe recreated (for example after having checked that the session is not valid) \nand does it so using request.getSession(true).\n\nThe problem is, that even then request.isRequestedSessionIdValid remains false. \nAs a result methods further on in the execution pipeline, that do not have the \nknowledge of the fact that the session has been recreated do have troubles with \nit. \n\nTo summarize:\nafter request.getSession(true);\n\nread the session with\nrequest.getSession(false);\n\nthen (session != null) since it is now new and valid\nbut request.isRequestedSessionIsValid() == false\n\nit's IMO not logical"}, {"count": 1, "tags": [], "bug_id": 18456, "attachment_id": null, "text": "If the session has been re-created, then request.isRequestedSessionIdValid() \nwill always return 'false'.  The test is \"is the Id sent by the browser the \nsame as the current sessionId\".", "id": 34030, "time": "2003-03-28T09:32:10Z", "creator": "william.barker@wilshire.com", "creation_time": "2003-03-28T09:32:10Z", "is_private": false}, {"count": 2, "attachment_id": null, "bug_id": 18456, "is_private": false, "id": 34042, "time": "2003-03-28T12:36:17Z", "creator": "tomasz@rtsoftware.com", "creation_time": "2003-03-28T12:36:17Z", "tags": [], "text": "I doesn't make much sense, does it? \n\nSession ID and its validity is of any use only if it applies to the current \nsession being in use.\n\nInformation that the client have sent an invalid Session ID as well as this \ninvalid Sesion ID itself is useless, if I already have a new session where I \ncan put data.\n\nNow look at the following HttpServletRequest API description:\n\npublic boolean isRequestedSessionIdValid()\n\nChecks whether the requested session ID is still valid. \nReturns: true if this request has an id for a valid session in the current \nsession context; false otherwise\n\nNow if I create a new session using HttpServletRequest method then this very \nHttpServletRequest does have a valid session.\n\npublic java.lang.String getRequestedSessionId()\n\nReturns the session ID specified by the client. This may not be the same as\nthe ID of the actual session in use. For example, if the request specified an \nold (expired) session ID and the server has started a new session, this method\ngets a new session with a new ID. If the request did not specify a session ID,\nthis method returns null.\nReturns: a String specifying the session ID, or null if the request did not\nspecify a session ID\n\nSo what you've stated is plainly wrong: if the server has started a new session \nthis HttpServletRequest's methods should apply to the new session. As stated \nabove the old invalid session ID is useless.\n"}, {"count": 3, "tags": [], "creator": "tomasz@rtsoftware.com", "text": "I don't want to shift the work on you, here are two proposed corrections:\n\nTomcat v4.1.18\n\nSolution 1:\n\norg.apache.catalina.connector.HttpRequestBase\n\npublic boolean isRequestedSessionIdValid() {\n\n    if (requestedSessionId == null)\n        return (false);\n    if (context == null)\n        return (false);\n\n    // Return the validitity of the current session if it exists and is valid\n    if ((session != null) && session.isValid())\n        return (true);\n\n    Manager manager = context.getManager();\n    if (manager == null)\n        return (false);\n    Session session = null;\n    try {\n        session = manager.findSession(requestedSessionId);\n    } catch (IOException e) {\n        session = null;\n    }\n    if ((session != null) && session.isValid())\n        return (true);\n    else\n        return (false);\n}\n\nif the request has a session that is valid return true, otherwise lookup \ncurrent session ID.\n\nSolution 2:\n\norg.apache.catalina.connector.HttpRequestBase\n\nprivate HttpSession doGetSession(boolean create) {\n    // There cannot be a session if no context has been assigned yet\n    if (context == null)\n        return (null);\n\n    // Return the current session if it exists and is valid\n    if ((session != null) && !session.isValid())\n        session = null;\n    if (session != null)\n        return (session.getSession());\n\n\n    // Return the requested session if it exists and is valid\n    Manager manager = null;\n    if (context != null)\n        manager = context.getManager();\n    if (manager == null)\n        return (null);      // Sessions are not supported\n    if (requestedSessionId != null) {\n        try {\n            session = manager.findSession(requestedSessionId);\n        } catch (IOException e) {\n            session = null;\n        }\n        if ((session != null) && !session.isValid())\n            session = null;\n        if (session != null) {\n            return (session.getSession());\n        }\n    }\n\n    // Create a new session if requested and the response is not committed\n    if (!create)\n        return (null);\n    if ((context != null) && (response != null) &&\n        context.getCookies() &&\n        response.getResponse().isCommitted()) {\n        throw new IllegalStateException\n          (sm.getString(\"httpRequestBase.createCommitted\"));\n    }\n\n    if (session != null) {\n        setRequestedSessionId(session.getId());\n        return (session.getSession());\n    } else\n        return (null);\n\n}\n\nAfter creating a new session put its ID as a new requestedSessionId.\n\n", "id": 34044, "time": "2003-03-28T12:42:54Z", "bug_id": 18456, "creation_time": "2003-03-28T12:42:54Z", "is_private": false, "attachment_id": null}, {"count": 4, "tags": [], "creator": "rm@moosauer.de", "text": "Hi Tomasz, \nIt seems that you simply haven't understood  \nthe text in the api docs. As Bill already tried to explain, with this function you can \nsee, if the session is _new_. \nThat means: The client has already accepted our cookie and sent it back with the current \nrequest. \nAnd you have to know: getSession(true or false) does _only_ return valid sessions. \nSo no further check is necessary! \n \nThis functionality have never changed since the creation of the spec. I think, you will not change \nit either, will you? \nIt's up to you to close this bug. \n \nkind regards, \n \nReinhard \n ", "id": 34056, "time": "2003-03-28T14:19:09Z", "bug_id": 18456, "creation_time": "2003-03-28T14:19:09Z", "is_private": false, "attachment_id": null}, {"count": 5, "tags": [], "bug_id": 18456, "attachment_id": null, "text": "As several people have pointed out, this is a misunderstanding of the spec.", "id": 50792, "time": "2004-01-19T23:43:57Z", "creator": "markt@apache.org", "creation_time": "2004-01-19T23:43:57Z", "is_private": false}]