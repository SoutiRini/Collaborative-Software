[{"count": 0, "tags": [], "text": "Using log4j 1.2.16 on Linux.\n\nWhen logging from 10 threads almost simultaneously, I'm seeing intermittent deadlocking. Doing a kill -3 on Linux shows the thread dump and shows java.lang.Thread.State: BLOCKED -  waiting to lock <0xd42e9a78> (a org.apache.log4j.spi.RootLogger)\n\nLooking at the Category code, I can see how threads could potentially deadlock:\n\nMethod: callAppenders(LoggingEvent event)\n...\n\n    for(Category c = this; c != null; c=c.parent) {\n      // Protected against simultaneous call to addAppender, removeAppender,...\n      synchronized(c) {\n\tif(c.aai != null) {\n\t  writes += c.aai.appendLoopOnAppenders(event);\n\t}\n\tif(!c.additive) {\n\t  break;\n\t}\n      }\n...\n\nHowever, before thinking too hard about exactly the scenario can occur I'd rather just remove the need to synchronize altogether when looping through the appenders attached to a Category.\n\nAppenders are themselves thread safe due to AppenderSkeleton's doAppend() method being synchronized. So, the only reason why Category synchronizes when iterating through appenders is, as the comments say, to:\n// Protected against simultaneous call to addAppender, removeAppender,...\n\nThis is only required because AppenderAttachableImpl aai is a mutable object which allows appenders to be added or removed at any time. By making it immutable (a copy-on-write list) we can avoid the synchronization at the most contentious point in log4j, the point at which the logging occurs. I'm sure we'll agree that adding and removing appenders is extremely rare compared to writing logs. So, if we can remove the synchronization at this point then we should see a significant benefit with very little performance hit for the copy-on-write of the AppenderAttachableImpl.\n\nI'll produce a patch for review.\n\n\nHere's an extract of the kill -3 dump:\n\n\"message.receiver-1\" prio=10 tid=0xcf2d4400 nid=0x6501 waiting for monitor entry [0xcc12e000]\n   java.lang.Thread.State: BLOCKED (on object monitor)\n        at org.apache.log4j.Category.callAppenders(Category.java:205)\n        - waiting to lock <0xd42e9a78> (a org.apache.log4j.spi.RootLogger)\n        at org.apache.log4j.Category.forcedLog(Category.java:391)\n        at org.apache.log4j.Category.info(Category.java:666)\n\n\n\"org.springframework.jms.listener.DefaultMessageListenerContainer#1-1\" prio=10 tid=0xcf0e6800 nid=0x6507 waiting for monitor entry [0xcabc6000]\n   java.lang.Thread.State: BLOCKED (on object monitor)\n        at org.apache.log4j.Category.callAppenders(Category.java:205)\n        - waiting to lock <0xd42e9a78> (a org.apache.log4j.spi.RootLogger)\n        at org.apache.log4j.Category.forcedLog(Category.java:391)\n        at org.apache.log4j.Category.log(Category.java:856)\n        at org.apache.commons.logging.impl.Log4JLogger.trace(Log4JLogger.java:146)\n\n\nLOTS MORE OF THESE...", "is_private": false, "bug_id": 50213, "id": 141401, "time": "2010-11-04T10:50:49Z", "creator": "dave@daveboden.com", "creation_time": "2010-11-04T10:50:49Z", "attachment_id": null}, {"count": 1, "tags": [], "text": "Created attachment 26254\nPatch to remove synchronization from Category but still keep thread safety", "attachment_id": 26254, "bug_id": 50213, "id": 141414, "time": "2010-11-04T13:04:42Z", "creator": "dave@daveboden.com", "creation_time": "2010-11-04T13:04:42Z", "is_private": false}, {"count": 2, "tags": [], "text": "The deadlock that you are experiencing isn't likely due to the lock on category.  There are likely two other locks in conflict that result in cascade of blocks.  Could you attach a full dump to see if we can pick out the blocks that start the problem.\n\nI am assuming that you've used you modified version of log4j and you saw an improved experience.  It might possibly isolate the threads where you might still have the initiating deadlock but it doesn't spread to any other thread that logs on the same logger which would be a very beneficial change.\n\nChanging the result type of Category.removeAppender(Appender) and removeAppender(String) breaks compatibility with any compiled app that calls either method as they will now could throw a NoSuchMethodException, see http://java.sun.com/docs/books/jls/second_edition/html/binaryComp.doc.html#45208.  Also, as you saw with NOPLogger, it requires any extended Logger (discouraged, but not prevented) to be modified.\n\nReplacing the lazy construction of AppenderAttachableImpl might have some, but likely small, performance impact.  It likely was a big deal in the JDK 1.1 days when object creation was substantially more expensive.  The member is package visible (no explicit public, private or protected) so the only way that it could become null again is if something in org.apache.log4j set it null and scanning the rest of the source shows no place that that could occur.\n\nTouching synchronization in Category is a minefield.  It could be safer to approach this by introducing a new class extended from Logger that is inherently thread-safe and then allowing the user to configure to use the corresponding logger factory when they want the new behavior.", "is_private": false, "bug_id": 50213, "id": 141513, "time": "2010-11-06T10:59:27Z", "creator": "carnold@apache.org", "creation_time": "2010-11-06T10:59:27Z", "attachment_id": null}, {"count": 3, "tags": [], "bug_id": 50213, "is_private": false, "id": 145039, "creation_time": "2011-03-16T22:40:41Z", "time": "2011-03-16T22:40:41Z", "creator": "dcherk@djinnsoft.com", "text": "Created attachment 26778\nMy thread dump with exact same problem, I think\n\nI seem to have the exact same deadlock.  Since comment 2 asked for a thread dump, I am attaching mine, perhaps it will help you.", "attachment_id": 26778}, {"count": 4, "tags": [], "bug_id": 50213, "attachment_id": null, "id": 145040, "time": "2011-03-16T22:45:38Z", "creator": "dcherk@djinnsoft.com", "creation_time": "2011-03-16T22:45:38Z", "is_private": false, "text": "(In reply to comment #3)\n> Created an attachment (id=26778) [details]\n> My thread dump with exact same problem, I think\n> \n> I seem to have the exact same deadlock.  Since comment 2 asked for a thread\n> dump, I am attaching mine, perhaps it will help you.\n\nBTW, I am using (from the MANIFEST file):\n\n---------------\nManifest-Version: 1.0\nArchiver-Version: Plexus Archiver\nCreated-By: Apache Maven\nBuilt-By: ubuntu\nBuild-Jdk: 1.6.0\n\nName: org.apache.log4j\nImplementation-Title: log4j\nImplementation-Vendor: \"Apache Software Foundation\"\nImplementation-Version: 1.2.15\n---------------"}, {"count": 5, "attachment_id": null, "bug_id": 50213, "is_private": false, "id": 145041, "time": "2011-03-17T00:11:04Z", "creator": "dcherk@djinnsoft.com", "creation_time": "2011-03-17T00:11:04Z", "tags": [], "text": "(In reply to comment #3)\n> Created an attachment (id=26778) [details]\n> My thread dump with exact same problem, I think\n> \n> I seem to have the exact same deadlock.  Since comment 2 asked for a thread\n> dump, I am attaching mine, perhaps it will help you.\n\nOk, we've analysed this and realized that the problem lies with the com.djinnsoft.jade.httputil.AuthorizedSMTPAppender class.  \n\nThis was a custom-built class that we created a while ago before log4j's SMTP appender supported authentication.  Our client misconfigured the log4j.properties file, and the AuthorizedSMTPAppender started blocking when it could not reach an email server.  Obviously, AuthorizedSMTPAppender is poorly written -- it was meant as a stop-gap.  Also, obviously, it shouldn't even be in use since the latest log4j version supports this functionality.\n\nSo, the obvious solution (for us) is to correct the log4j configuration.\n\n\nHaving said that, it might still be worth while for you guys to make the callAppenders() method more bullet-proof.  I guess it's up to you :)\n\n\nBest of luck,\n-- \nDave Cherkassky\n  VP of Software Development\n  DJiNN Software Inc.\n  416.504.1354"}, {"count": 6, "tags": [], "text": "Hi guys,\n\nWhen doing performance/load tests of my system, I've been observing plenty of threads waiting on this synchronization - on org.apache.log4j.Category.callAppenders(). For sure a deadlock is not possible and, what is more, this suboptimal synchronization mechanism cannot cause HUGE performance degradation if async appenders are used underneath. However, in a really multithreaded env it'll cause some delays.\n\nIt should not be hard to improve this synchronization mechanism without the need to change API. Introduce a read-write lock? \n\nLog4j 1.2.x is compliant with JDK 1.2, right? If so, using java.util.concurrent.locks classes is not an option. Maybe a simple custom impl of read-write lock would be enough?\n\nBest regards,\n  Bartek", "attachment_id": null, "id": 145534, "creator": "kowalewski.bartosz@gmail.com", "time": "2011-04-04T06:28:51Z", "bug_id": 50213, "creation_time": "2011-04-04T06:28:51Z", "is_private": false}, {"attachment_id": null, "tags": [], "bug_id": 50213, "is_private": false, "count": 7, "id": 145695, "time": "2011-04-11T05:52:25Z", "creator": "kowalewski.bartosz@gmail.com", "creation_time": "2011-04-11T05:52:25Z", "text": "I've just created https://issues.apache.org/bugzilla/attachment.cgi?bugid=51047 (Move org.apache.log4j.Category to reentrant read/write locks). This change should get rid of issues with synchronization and deadlocks."}]