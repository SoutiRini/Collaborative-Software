[{"count": 0, "tags": [], "creator": "knst.kolinko@gmail.com", "text": "I encountered this trying to run the current TC trunk with TC-Native 1.1.19 on Windows.\n\nThe root cause to this behavior occurred to be a wrong value configured by default as a timeout in AprEndpoint.Poller. (Also there might be further issue in how that timeout is applied / how the Poller works, but that is debatable).\n\nCurrent 6.0 and 5.5 (6.0.24, 5.5.28) are unaffected, because the defaults are different there. Though it looks like 6.0 can be configured to misbehave in the same way. More details below.\n\nI was accessing Tomcat by HTTP (using Http11AprProtocol), but I think that AJP (AjpAprProtocol) is affected as well.\n\nTomcat was build from trunk (aka future TC7), at revision 904960.\n\n\n~ Symptoms ~\n\nTo reproduce this issue:\n1. My environment:\n- Windows XP 32-bit\n- java version \"1.6.0_17\"\nJava(TM) SE Runtime Environment (build 1.6.0_17-b04)\nJava HotSpot(TM) Client VM (build 14.3-b01, mixed mode, sharing)\n- Tomcat trunk, built from revision 904960\n- Tomcat Native DLL 1.1.19\n\n2. Place tcnative-1.dll into %CATALINA_HOME%/bin and start Tomcat.\n\nI am using an HTTP client, so AJP connector configuration can be removed from server.xml.\n\nTomcat starts:\n\n31.01.2010 18:45:16 org.apache.catalina.core.AprLifecycleListener init\nINFO: Loaded APR based Apache Tomcat Native library 1.1.19.\n31.01.2010 18:45:16 org.apache.catalina.core.AprLifecycleListener init\nINFO: APR capabilities: IPv6 [true], sendfile [true], accept filters [false], random [true].\n\n3. Use a web browser (I was using Firefox 3.6) to access some simple JSP page\n\n4. Refresh the page in the browser. The problem is that sometimes the page does not load, (the browser shows a blank page and page info says that response length was 0 bytes) - connection was aborted.\n\nThe problem was more noticeable when I had a Firewall/Ad blocker running (because they incurred some delay while sending the request?). Turning it off made this error less frequent, but it was still there -- I was able to observe it running wget in a cycle requesting the page. 500 iterations were enough for this error to occur several times, with all firewalls turned off.\n\nHere is how this error was displayed by wget:\n\n\n--17:32:51--  http://localhost:8080/test/foo.jsp\nResolving localhost... 127.0.0.1\nConnecting to localhost|127.0.0.1|:8080... connected.\nHTTP request sent, awaiting response... Read error (Software caused connection abort) in headers.\nRetrying.\n\n--17:32:51--  (try: 2)  http://localhost:8080/test/foo.jsp\nConnecting to localhost|127.0.0.1|:8080... connected.\nHTTP request sent, awaiting response... No data received.\nRetrying.\n\n--17:32:51--  (try: 3)  http://localhost:8080/test/foo.jsp\nConnecting to localhost|127.0.0.1|:8080... connected.\nHTTP request sent, awaiting response... 200 OK\nLength: 130 [text/html]\nSaving to: `foo.jsp.98'\n\n     0K                                                       100% 3.52M=0s\n\n\n~ Investigation ~\n\n1. I enabled FINE, then FINEST logging for all Tomcat components in logging.properties (then selectively disabling those components that I was not interested in).\n\nThat was futile: the logs showed no trace of those ignored request.\n\n2. I enabled AccessLogValve.\n\nIt did not help either: The ignored requests were not listed in the access log.\n\n3. I launched jvisualvm tool from Java 6 JDK, connected to running Tomcat to investigate the threads and possible deadlocks there.\n\nThere was no deadlock, and all threads were running. But I noticed one more thing: on a freshly started Tomcat several first requests, even if those were ignored ones,  resulted in creation of a new thread in some thread pool.\n\nHere is one of those threads, from a thread dump:\n\n\"http-8080-exec-9\" daemon prio=6 tid=0x0afac800 nid=0xe10 waiting on condition [0x0cc5f000]\n   java.lang.Thread.State: WAITING (parking)\n\tat sun.misc.Unsafe.park(Native Method)\n\t- parking to wait for  <0x03258e80> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)\n\tat java.util.concurrent.locks.LockSupport.park(Unknown Source)\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(Unknown Source)\n\tat java.util.concurrent.LinkedBlockingQueue.take(Unknown Source)\n\tat java.util.concurrent.ThreadPoolExecutor.getTask(Unknown Source)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)\n\tat java.lang.Thread.run(Unknown Source)\n\n   Locked ownable synchronizers:\n\t- None\n\nThat was the clue: it means that the request has reached Tomcat.\n\n\nSearching by a substring of that thread name I found that getName() + \"-exec-\" is thread name prefix used by  AbstractEndpoint.createExecutor().\n\nThus I investigated behaviour of AprEndpoint, confirming it by adding with some ad-hoc logging statements. I will not commit them, because this issue is sensitive to timing, so some of them were affecting its reproducibility.\n\n\n~ Behaviour of AprEndpoint ~\n\nIn my configuration I was using Http11AprProtocol and it creates and uses AprEndpoint.\n\nIncoming request is processed by an Acceptor thread (AprEndpoint.Acceptor#run()) ->  Acceptor#processSocketWithOptions(long) will use getExecutor().execute(new SocketWithOptionsProcessor( )) to pass this newly opened socked further.  It is the thread created by this \"execute()\" call that I spotted in jvisualvm earlier.\n\nIn SocketWithOptionsProcessor#run() in my configuration deferAccept is false, so we are calling  getPoller().add(socket)  and pass the socket to a poller.\n\nIn the AprEndpoint.Poller#add( ) the socket is added to a queue to be processed.\nThe queue array size in my configuration occurred to be 1024, so queue overflow was not an issue.\n\nThen AprEndpoint.Poller#run() processes the queue, passes the new sockets from there to TC-Native  (Poll.add() call)  and then loops over and over polling their status  (Poll.poll() call).\n\nThe problem occurred to be caused by Poll.maintain( ) calls, that are executed every several iterations of the loop.\n\nIn my case:  the recently opened socket remained for several iterations of the Poller loop,  but when Poll.maintain() call occurred the socket was returned from the maintain() call as a one to be closed,  and was immediately closed, dropping the connection.\n\nThus,  Poll.maintain() was misbehaving, closing fresh sockets.\n\nImplementation of Poll.maintain() (in poll.c of TC-Native) showed that if (p->max_ttl == 0) there, the socket is to be closed immediately.\n\np->max_ttl value is set when configuring a pollset in Poll.create( ), and can be changed later for the pollset as a whole in Poll.setTtl( ) method.\n\nIn AprEndpoint.Poller the pollset is created in Poller.init().\n\nThere, the value for the timeout is determined as\n\n            int timeout = getKeepAliveTimeout();\n            if (timeout < 0) {\n                timeout = socketProperties.getSoTimeout();\n            }\n\nwhere\n    /**\n     * Keepalive timeout, if lesser or equal to 0 then soTimeout will be used.\n     */\n    private int keepAliveTimeout = 0;\n\nso, the timeout actually occurred to be configured as 0. Thus the observed buggy behaviour.\n\nIn TC 6.0.24  keepAliveTimeout = -1, thus soTimeout will be used.\n\n\n\nNotes:\n - The JavaDoc for keepAliveTimeout says that 0 means that soTimepout will be used,  but the actual implementation is different.\n\nChanging the above cited code to be\n            if (timeout <= 0) {\n                timeout = socketProperties.getSoTimeout();\n            }\nwould be the most obvious fix for this issue.\n\n\n - A delay longer than soTimeout (60 or 20 seconds? IIRC) will likewise result in closing the socket, with no details mentioned in the logs.\n\n\n - The keepAliveTimeout property name suggests that it is used for sockets where processing already occurred, and we are keeping them alive between requests. (Zero timeout would be okay there).\n\nWhy was it used for a freshly open sockets? (Zero timeout cannot be used for them)  Maybe it is a wrong name for this property?\n\n\n - Is it possible in the Poller to distinguish fresh sockets vs. those in keep-alive state,  and configure different timeouts for them?  It will require to keep several  pollset pools with different TTLs ?\n\n\n - AjpAprProtocol also uses this AjpEndpoint, so I expect it to be affected by this issue as well.\n\n\n - This chain of calls causing this issue occurs only if AprEndpoint.deferAccept field is false.  It is true by default but is set to false when the system does not support the requested feature.\n\nIn my case, in Windows XP SP3, that feature (Socket.APR_TCP_DEFER_ACCEPT) was not supported.  A comment in the code says that it is supported in Linux kernel 2.4 and later.\n\nThus, this issue is likely not affect Linux.", "id": 134089, "time": "2010-01-31T17:58:11Z", "bug_id": 48648, "creation_time": "2010-01-31T17:58:11Z", "is_private": false, "attachment_id": null}, {"count": 1, "tags": [], "creator": "markt@apache.org", "text": "I've fixed the immediate problem in AprEndpoint. I'm still reviewing the broader issues around timeouts", "id": 135878, "time": "2010-04-04T16:27:24Z", "bug_id": 48648, "creation_time": "2010-04-04T16:27:24Z", "is_private": false, "attachment_id": null}, {"count": 2, "tags": [], "bug_id": 48648, "text": "Some quick tests have confirmed that if a keepAliveTimeout is specified it is used for connectionTimeout as well. I haven't yet looked at how this might be fixed.", "id": 135986, "attachment_id": null, "creator": "markt@apache.org", "creation_time": "2010-04-09T12:03:09Z", "time": "2010-04-09T12:03:09Z", "is_private": false}, {"count": 3, "attachment_id": null, "bug_id": 48648, "is_private": false, "id": 138794, "time": "2010-08-01T15:41:38Z", "creator": "markt@apache.org", "creation_time": "2010-08-01T15:41:38Z", "tags": [], "text": "I have created a separate isse (bug 49683) to track the timeout issue"}]