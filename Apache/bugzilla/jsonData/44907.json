[{"count": 0, "tags": [], "creator": "christian.liesch@united-security-providers.ch", "is_private": false, "id": 116046, "attachment_id": null, "bug_id": 44907, "creation_time": "2008-04-30T01:32:36Z", "time": "2008-04-30T01:32:36Z", "text": "If I do send plain HTTP to an SSL enabled vhost the expected 400 Bad Request Answer do not have any HTTP headers nor a status line only the HTML is sent.\n\nRequest:\nGET /foobar HTTP/1.1 \nHost: localhost  \n\nResponse:\n<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\"\n<html><head\n<title>400 Bad Request</title\n</head><body\n<h1>Bad Request</h1\n<p>Your browser sent a request that this server could not understand.<br /\nReason: You're speaking plain HTTP to an SSL-enabled server port.<br /\nInstead use the HTTPS scheme to access this URL, please.<br /\n<blockquote>Hint: <a href=\"https://xxx:yyy/\"><b>https://xxx:yyy/</b></a></blockquote></p\n</body></html OK"}, {"count": 1, "tags": [], "creator": "christian.liesch@united-security-providers.ch", "attachment_id": null, "id": 116058, "time": "2008-04-30T05:14:10Z", "bug_id": 44907, "creation_time": "2008-04-30T05:14:10Z", "is_private": false, "text": "I think the problem is, that mod ssl does consume the bytes before it sees that this is not ssl. As soon as it detect something other than SSL it does a dummy bucket with \"GET /\" into the bucket brigade.\n\nThis \"GET /\" does lead to r->assbackward == 1 which means HTTP/0.9. In this case no headers at all is not a wrong behavour."}, {"count": 2, "tags": [], "creator": "jorton@redhat.com", "attachment_id": null, "id": 119506, "time": "2008-08-06T08:03:11Z", "bug_id": 44907, "creation_time": "2008-08-06T08:03:11Z", "is_private": false, "text": "Yeah.  It's an 80% solution; browsers will grok that response as HTML anyway, but if they don't, well, sending them an SSL alert would have confused them just as much."}]