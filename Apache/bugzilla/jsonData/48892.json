[{"count": 0, "tags": [], "creator": "ew@omikron.net", "text": "Here is a simple scenario. I have a HTML page served by tomcat with \"Content-Type: text/html;charset=utf-8\":\n\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n</head>\n<body>\n<form method=\"POST\" action=\"test.jsp\" accept-charset=\"utf-8\" method=\"post\" enctype=\"application/x-www-form-urlencoded\" >\n    <input type=\"text\" name=\"P\"/>\n    <input type=\"submit\" value=\"subMit\"/>\n</form>\n</body>\n</html>\n\nWhen this form is submitted the browser will encode the value of the input field using UTF-8. It will create a POST request header with a content type line like this:\nContent-Type: application/x-www-form-urlencoded\n\nI checked this behavior using FF3.6 and IE8. Both browsers will omit the charset param in the Content-Type header.\n\nWhen parsing this request Tomcat will try to get the encoding from the content type header line (org.apache.coyote.Request.getCharacterEncoding()). Since there is no charset param in the content type header, Tomcat will use the standard encoding ISO-8859-1 (org.apache.catalina.connector.Request.parseParameters()). Which is obviously wrong in this case.\n\nThere is no way to force the browser to put the charset in the content type header (http://stackoverflow.com/questions/2418944/how-to-force-browser-to-set-charset-in-content-type-http-header).\n\nA good solution for this problem would be to use the URIEncoding connector setting for application/x-www-form-urlencoded encoded post requests. After all the encoding names says \"URLencoded\".", "id": 135268, "time": "2010-03-11T12:10:09Z", "bug_id": 48892, "creation_time": "2010-03-11T12:10:09Z", "is_private": false, "attachment_id": null}, {"count": 1, "tags": [], "creator": "markt@apache.org", "text": "There are already a number of connector options that modify behaviour around character encoding. I'd rather not add to them unless there is a strong demand for this feature (which there hasn't been to date).\n\nThe standard approach for handling this situation has been to use a filter. This has the added advantage of being container neutral, so your application will work across multiple containers without modification rather than being tied to a Tomcat specific feature. See http://wiki.apache.org/tomcat/FAQ/CharacterEncoding#Q3 for more info.", "id": 135873, "time": "2010-04-04T10:18:48Z", "bug_id": 48892, "creation_time": "2010-04-04T10:18:48Z", "is_private": false, "attachment_id": null}, {"count": 2, "tags": [], "creator": "chris@christopherschultz.net", "attachment_id": null, "id": 142687, "time": "2010-12-14T14:30:22Z", "bug_id": 48892, "creation_time": "2010-12-14T14:30:22Z", "is_private": false, "text": "-1 for defaulting to use URIEncoding to decode the request body when no Content-Type encoding is specified, since that setting might violate the HTTP spec in it's default configuration.\n\nSee http://wiki.apache.org/tomcat/FAQ/CharacterEncoding#Q9, specifically \"Default encoding for POST\".\n\nThe de-facto standard for encoding-less Content-Type in POST bodies is ISO-8859-1."}, {"count": 3, "tags": [], "creator": "markt@apache.org", "attachment_id": null, "id": 152815, "time": "2012-01-15T21:59:32Z", "bug_id": 48892, "creation_time": "2012-01-15T21:59:32Z", "is_private": false, "text": "Resolving as WONTFIX. A filter is the best way to handle this until such time that browsers send the necessary encoding info."}]