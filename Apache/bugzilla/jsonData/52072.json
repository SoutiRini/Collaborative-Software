[{"count": 0, "attachment_id": null, "bug_id": 52072, "is_private": false, "id": 150834, "time": "2011-10-22T07:50:56Z", "creator": "alexchan@task.com.hk", "creation_time": "2011-10-22T07:50:56Z", "tags": [], "text": "LengthPrefixedBinaryTcpClientImpl may end a sample prematurely in a network environment with small MSS or client with shortage of TCP buffer.\n\nIn LengthPrefixedBinaryTcpClientImp.java, the sampler does a single read on the inputstream after the length of the message is determined:\n\n/**\n     * {@inheritDoc}\n     */\n    public String read(InputStream is) {\n        byte[] msg = new byte[0];\n        int msgLen = 0;\n        try {\n            byte[] lengthBuffer = new byte[lengthPrefixLen];\n            if (is.read(lengthBuffer, 0, lengthPrefixLen) == lengthPrefixLen) {\n                msgLen = byteArrayToInt(lengthBuffer);\n                msg = new byte[msgLen];\n                int bytes = is.read(msg);\n                if (bytes < msgLen){\n                    log.warn(\"Incomplete message read, expected: \"+msgLen+\" got: \"+bytes);\n                }\n            }\n        } catch (SocketTimeoutException e) {\n            // drop out to handle buffer\n        } catch (InterruptedIOException e) {\n            // drop out to handle buffer\n        } catch (IOException e) {\n            log.warn(\"Read error:\" + e);\n        }\n\n        String buffer = JOrphanUtils.baToHexString(msg);\n        log.debug(\"Read: \" + msgLen + \"\\n\" + buffer);\n        return buffer;\n    }\n\nIn a network with small MSS or a client with shortage of buffer (e.g. during a stress test), the response message may not be returned completely in just one call to is.read(msg). When this occurs, the sampler mistakenly assumes that the response is complete and leads to the following problems. Let's call the first sample S1, the next one S2 etc.\n\n1. It reports a wrong response time shorter than the actual one for S1\n\n2. In case \"Re-use connection\" is set to true, the remaining bytes of the response message of S1 in the TCP stream confuses the sampler in the next sample, S2. The sampler thinks that these bytes are the initial part of the response of S2 and therefore reports another wrong and unrealistically short response time for S2. Worse, it now sends yet another new sample S3 because it thinks that S2 has completed. This may cause problem to the server side if the server side assumes the stop-and-wait nature of the connection in order to function correctly. \n\nIn other words, this bug may render the stress test ineffective in these circumstances because of the wrong response times and problems triggered on the server side."}, {"count": 1, "tags": [], "bug_id": 52072, "attachment_id": null, "id": 150835, "time": "2011-10-22T08:06:36Z", "creator": "alexchan@task.com.hk", "creation_time": "2011-10-22T08:06:36Z", "is_private": false, "text": "I have created a temporary fix , at least it works for my case and let me pass my stress test :)\nCaveat: The actual timeout may be multiplied by the actual number of read required in the extreme case.\n\npublic String read(InputStream is) {\n        byte[] msg = new byte[0];\n        int msgLen = 0;\n        /* BEGFIX */\n        int nleft = 0;\n        int nread = 0;\n        int offset = 0;\n        /* ENDFIX */\n        try {\n            byte[] lengthBuffer = new byte[lengthPrefixLen];\n            if (is.read(lengthBuffer, 0, lengthPrefixLen) == lengthPrefixLen) {\n                msgLen = byteArrayToInt(lengthBuffer);\n                msg = new byte[msgLen];\n                /* BEGFIX\n                int bytes = is.read(msg);\n                if (bytes < msgLen){ \n                     log.warn(\"Incomplete message read, expected: \"+msgLen+\"\ngot: \"+bytes);\n                }\n                ENDFIX */\n                /* BEGFIX */\n                nleft = msgLen;\n                offset = 0;\n                while (nleft > 0) {\n                    nread = is.read(msg, offset, nleft);\n                    nleft = nleft - nread;\n                    offset = offset + nread;\n                }\n                /* ENDFIX */\n            }\n        } catch (SocketTimeoutException e) {\n            // drop out to handle buffer\n        } catch (InterruptedIOException e) {\n            // drop out to handle buffer\n        } catch (IOException e) {\n            log.warn(\"Read error:\" + e);\n        }\n\n        String buffer = JOrphanUtils.baToHexString(msg);\n        log.debug(\"Read: \" + msgLen + \"\\n\" + buffer);\n        return buffer;\n    }"}, {"count": 2, "tags": [], "text": "Good catch - there is clearly a bug here.\n\nIf \"re-use connection\" is selected, and the sample ends prematurely even after fixing this bug, seems to me this should be treated as an error, and the connection should be closed. Otherwise the error can propagate to the next sample.", "attachment_id": null, "bug_id": 52072, "id": 150836, "time": "2011-10-22T22:31:47Z", "creator": "sebb@apache.org", "creation_time": "2011-10-22T22:31:47Z", "is_private": false}, {"count": 3, "tags": [], "bug_id": 52072, "attachment_id": null, "text": "Fixed the incomplete read issue:\n\nURL: http://svn.apache.org/viewvc?rev=1188830&view=rev\nLog:\nBug 52072 - LengthPrefixedBinaryTcpClientImpl may end a sample prematurely\n\nModified:\n   jakarta/jmeter/trunk/src/jorphan/org/apache/jorphan/util/JOrphanUtils.java\n   jakarta/jmeter/trunk/src/protocol/tcp/org/apache/jmeter/protocol/tcp/sampler/LengthPrefixedBinaryTCPClientImpl.java\n   jakarta/jmeter/trunk/xdocs/changes.xml\n\nHowever, this still leaves the issue of how to handle re-use connection.\n\nAt present, this is quite tricky, as the API does not allow for returning a status to the controlling sampler.\n\nSee Bug 52087 which has been raised to cover this aspect.", "id": 150909, "time": "2011-10-25T18:28:47Z", "creator": "sebb@apache.org", "creation_time": "2011-10-25T18:28:47Z", "is_private": false}]