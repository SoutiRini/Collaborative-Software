[{"count": 0, "tags": [], "bug_id": 3784, "is_private": false, "id": 5943, "creation_time": "2001-09-23T18:55:06Z", "time": "2001-09-23T18:55:06Z", "creator": "ron@roncemer.com", "text": "I have discovered and fixed several bugs in jakarta-tomcat-3.2.3, all in the\nHttpRequestAdapter.java source file.\n\nThe bugs manifest themselves when the URI for the HTTP request (including the\nrequest parameter list) exceeds 2048 characters.  This prevents Tomcat from\nbeing useful for sites which have forms with lots of fields, for example, in\nwhich case the sumission of the form could cause a \"POST\" or \"GET\" request with\na lot of parameters tacked onto the URI.  This causes an\nArrayIndexOutOfBoundsException due to badly written code in the\nsrc/org/apache/tomcat/service/http/HttpRequestAdapter.java.  I have included my\ncorrected versions of the affected methods from this file, and have tested it\nwith URIs over 12,000 characters in length.  There are two methods affected:\nreadNextRequest() and readHeaders().\n\nPlease integrate these changes into the next release of jakarta-tomcat, so that\neveryone can benefit from them.\n\nThanks for the great software!!!\nRon Cemer \n\n    public void readNextRequest(Response response) throws IOException {\n\n\t// Odd, but works: we use the ServletInputStream, which uses doRead.\n\t// We do implement doRead in Http protocol to return from the input\n\t// stream - it works for the normal body but also for the HTTP\n\t// head. The limit is set after ( and if ) we have a content-length.\n\t\n/// Replaced this line with the code block below to support requests of\n/// arbitrary lengths.  - Ron Cemer\n///\ncount = in.readLine(buf, 0, buf.length);\n\tcount = 0;\n\twhile (true) {\n\t    int len = buf.length-count;\n\t    if (len > 0) {\n\t\tlen = in.readLine(buf, count, len);\n\t\tif ( (len == -1) && (count == 0) ) {\n\t\t    count = -1;\n\t\t    break;\n\t\t}\n\t\tcount += len;\n\t\tif (len == 0 || buf[count-1] == '\\n') {\n\t\t    break;\n\t\t}\n\t    }\n\t\t// overflowed buffer, so temporarily expand and continue\n\t    byte[] tmp = new byte[buf.length * 2];\n\t    System.arraycopy(buf, 0, tmp, 0, buf.length);\n\t    buf = tmp;\n\t}\n/// End of replacement code.\n\n\tif (count < 0 ) {\n\t    response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n\t    return;\n\t}\n\t\n\tprocessRequestLine(response  );\n\n\t// for 0.9, we don't have headers!\n\tif (protocol!=null) { // all HTTP versions with protocol also have headers ( 0.9\nhas no HTTP/0.9 !)\n\t    readHeaders( headers, in  );\n\t}\n\n\t// XXX\n\t// detect for real whether or not we have more requests\n\t// coming\n\tmoreRequests = false;\t\n    }\n\n\n    /**\n     * Reads header fields from the specified servlet input stream until\n     * a blank line is encountered.\n     * @param in the servlet input stream\n     * @exception IllegalArgumentException if the header format was invalid \n     * @exception IOException if an I/O error has occurred\n     */\n    public void readHeaders( MimeHeaders headers, ServletInputStream in ) \nthrows IOException {\n\t// use pre-allocated buffer if possible\n\toff = count; // where the request line ended\n\t\n\twhile (true) {\n\t    int start = off;\n\n\t    while (true) {\n\t\tint len = buf.length - off;\n\n\t\tif (len > 0) {\n\t\t    len = in.readLine(buf, off, len);\n\t\t    if (len == -1) {\n                        String msg =\n                            sm1.getString(\"mimeHeader.connection.ioe\");\n\n\t\t\tthrow new IOException (msg);\n\t\t    }\n///\n\t}\n\n/// This code should be WITHIN the second \"while (true)\".  - Ron Cemer\n\t\t    off += len;\n\n\t\t    if (len == 0 || buf[off-1] == '\\n') {\n\t\t\tbreak;\n\t\t    }\n///\n\t\t}\n\n\t\t// overflowed buffer, so temporarily expand and continue\n\n\t\t// XXX DOS - if the length is too big - stop and throw exception\n\t\tbyte[] tmp = new byte[buf.length * 2];\n\n\t\tSystem.arraycopy(buf, 0, tmp, 0, buf.length);\n\t\tbuf = tmp;\n\t    }\n\n\t    // strip off trailing \"\\r\\n\"\n///\n    if (--off > start && buf[off-1] == '\\r') {\n///\n\t--off;\n///\n    }\n/// This is a less error-prone way of accomplishing the task.  - Ron Cemer\n\t    if ( (off > start) && (buf[off-1] == '\\n') ) {\n\t\toff--;\n\t\tif ( (off > start) && (buf[off-1] == '\\r') )\n\t\t    off--;\n\t    }\n\n\t    if (off == start) {\n\t\tbreak;\n\t    }\n\t    \n\t    // XXX this does not currently handle headers which\n\t    // are folded to take more than one line.\n\t    MimeHeaderField mhf=headers.putHeader();\n\t    if( ! parseHeaderFiled(mhf, buf, start, off - start) ) {\n\t\t// error parsing header\n\t\treturn;\n\t    }\n\t}\n    }", "attachment_id": null}, {"count": 1, "attachment_id": null, "creator": "cmanolache@yahoo.com", "is_private": false, "id": 6026, "time": "2001-09-25T14:03:00Z", "bug_id": 3784, "creation_time": "2001-09-25T14:03:00Z", "tags": [], "text": "Resolved in 3.3, we do resize the buffer."}, {"count": 2, "tags": [], "creator": "william.barker@wilshire.com", "text": "*** Bug 5171 has been marked as a duplicate of this bug. ***", "id": 8410, "time": "2001-11-28T15:45:42Z", "bug_id": 3784, "creation_time": "2001-11-28T15:45:42Z", "is_private": false, "attachment_id": null}]