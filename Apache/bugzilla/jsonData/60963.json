[{"count": 0, "text": "Created attachment 34902\nProposed patch\n\nAttached patch improves the class loading time for unpackWARs=false especially when the war is build with only uncompressed entries.", "creator": "thomas@m3y3r.de", "is_private": false, "id": 198208, "time": "2017-04-07T15:58:50Z", "bug_id": 60963, "creation_time": "2017-04-07T15:58:50Z", "tags": [], "attachment_id": 34902}, {"count": 1, "tags": [], "bug_id": 60963, "text": "Depending on the deployed WAR files loading is up to 7 times faster.\nWould be nice if somebody from the tomcat developers could have a look at this.", "id": 198214, "time": "2017-04-08T12:43:45Z", "creator": "thomas@m3y3r.de", "creation_time": "2017-04-08T12:43:45Z", "is_private": false, "attachment_id": null}, {"attachment_id": null, "tags": [], "bug_id": 60963, "is_private": false, "count": 2, "id": 198215, "time": "2017-04-08T19:59:41Z", "creator": "thomas@m3y3r.de", "creation_time": "2017-04-08T19:59:41Z", "text": "I did als upload the patch here: http://static.217.14.99.88.clients.your-server.de/501"}, {"count": 3, "tags": [], "creator": "markt@apache.org", "text": "Looking at this is on my TODO list. The main question I have is does it still avoid file locking issues? These will be more obvious Windows (you won't be able to delete the WAR) but they affect all platforms.", "id": 198266, "attachment_id": null, "bug_id": 60963, "creation_time": "2017-04-12T14:30:58Z", "time": "2017-04-12T14:30:58Z", "is_private": false}, {"count": 4, "tags": [], "creator": "chris@christopherschultz.net", "text": "It looks like isInWAR in getJarInputStreamWrapper can be leaked.\n\nWill calling getWebResourceSet().closeJarFile undo this performance optimization?\n\nFor ZipInputStreamWithPosition constructor, should you do this instead:\n\n        super(new PushbackCountingInputStream(in, 512));\n\nThat seems a little cleaner.", "id": 198272, "attachment_id": null, "bug_id": 60963, "creation_time": "2017-04-12T21:22:37Z", "time": "2017-04-12T21:22:37Z", "is_private": false}, {"attachment_id": null, "tags": [], "bug_id": 60963, "is_private": false, "count": 5, "id": 198301, "time": "2017-04-14T21:49:09Z", "creator": "thomas@m3y3r.de", "creation_time": "2017-04-14T21:49:09Z", "text": "Regarding file locking issue: I didn't check this. I'll try to test this."}, {"count": 6, "tags": [], "creator": "thomas@m3y3r.de", "attachment_id": null, "is_private": false, "id": 198302, "time": "2017-04-14T21:57:05Z", "bug_id": 60963, "creation_time": "2017-04-14T21:57:05Z", "text": "Regarding ZipInputStreamWithPosition:\nI think you found the ugly part of this patch. I guess your suggestion wouldn't work, because ZipInputStream will construct itself with a new PushBackInputstream and the provided input stream as decorated object. Passing the input stream as you suggest would result in a PushBackInputStream with an PushBackInputStreamWithPosition as decorated object, which is wrong for our intention here.\nBy setting the decorated object after the super constructor has finished we replace the PushbsckInputStream with our implementation."}, {"count": 7, "tags": [], "bug_id": 60963, "text": "(In reply to Thomas Meyer from comment #6)\n> Regarding ZipInputStreamWithPosition:\n> I think you found the ugly part of this patch. I guess your suggestion\n> wouldn't work, because ZipInputStream will construct itself with a new\n> PushBackInputstream and the provided input stream as decorated object.\n> Passing the input stream as you suggest would result in a\n> PushBackInputStream with an PushBackInputStreamWithPosition as decorated\n> object, which is wrong for our intention here.\n> By setting the decorated object after the super constructor has finished we\n> replace the PushbsckInputStream with our implementation.\n\nI'm sorry, I don't follow. What's the problem with the superclass's constructor using the PushbackCountingInputStream instead of handing it an undecorated InputStream, and then replacing it after the constructor has completed?\n\nDoes the superclass constructor do something with the InputStream that we don't want to happen to the PushbackCountingInputStream?\n\nI would think that \"bytesread\" would be incorrect (initialized to zero) if the superclass constructor performs a read. Don't you want those reads to be counted?", "id": 198310, "time": "2017-04-16T21:00:35Z", "creator": "chris@christopherschultz.net", "creation_time": "2017-04-16T21:00:35Z", "is_private": false, "attachment_id": null}, {"count": 8, "tags": [], "creator": "thomas@m3y3r.de", "is_private": false, "id": 198339, "attachment_id": null, "bug_id": 60963, "creation_time": "2017-04-18T17:31:43Z", "time": "2017-04-18T17:31:43Z", "text": "(In reply to Christopher Schultz from comment #7)\n> (In reply to Thomas Meyer from comment #6)\n> > Regarding ZipInputStreamWithPosition:\n> > I think you found the ugly part of this patch. I guess your suggestion\n> > wouldn't work, because ZipInputStream will construct itself with a new\n> > PushBackInputstream and the provided input stream as decorated object.\n> > Passing the input stream as you suggest would result in a\n> > PushBackInputStream with an PushBackInputStreamWithPosition as decorated\n> > object, which is wrong for our intention here.\n> > By setting the decorated object after the super constructor has finished we\n> > replace the PushbsckInputStream with our implementation.\n> \n> I'm sorry, I don't follow. What's the problem with the superclass's\n> constructor using the PushbackCountingInputStream instead of handing it an\n> undecorated InputStream, and then replacing it after the constructor has\n> completed?\nYes, exactly this is what is happening:\n\"super(new PushbackInputStream(in, 512), new Inflater(true), 512);\"\nIn the super constructor.\n\n> Does the superclass constructor do something with the InputStream that we\n> don't want to happen to the PushbackCountingInputStream?\n\nYes, it decorates the passed InputStream with a PushBackInputStream.\n\n> \n> I would think that \"bytesread\" would be incorrect (initialized to zero) if\n> the superclass constructor performs a read. Don't you want those reads to be\n> counted?\n\nTheoretically we want those bytes to be counted, but the ZipInputStream doesn't read anything in it's construction phase, that's why the whole \"fast forward skipping works at all\".\nAnd yes this is a somewhat hackish solution but it works.\n\nI did also look at what commons-compress provides but their implementation also doesn't have a callback for the event \"new PK entry in the InputStream reached\""}, {"count": 9, "text": "I've spent a little time looking at this.\n\nI can confirm that I see similar performance improvements with local testing.\n\nI can also confirm I have not observed any file locking. I haven't looked for other leaks but if there are any, I expect them to be simple to fix.\n\nThe one thing that worries me about this patch is the degree to which it depends on the JVM internals. While this works with the current Oracle JVM, my concern is for JVMs from other vendors and future Oracle versions.\n\nI did take a quick look at the ZIP specification [1] and it appears it should be fairly simple to read the file names and data offsets from the local file headers. I wonder if writing a parser that extracts just the info we need and skips the rest might be a better option. \n\nFinally, there are a few changes in the patch that aren't strictly related to fixing the problem at hand. It is generally better to put that sort of clean-up in a separate patch (no need to re-submit this patch - the comment is more for future reference).\n\n[1] https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT", "creator": "markt@apache.org", "is_private": false, "id": 198348, "time": "2017-04-19T08:46:10Z", "bug_id": 60963, "creation_time": "2017-04-19T08:46:10Z", "tags": [], "attachment_id": null}, {"attachment_id": null, "tags": [], "bug_id": 60963, "text": "(In reply to Mark Thomas from comment #9)\n \n> The one thing that worries me about this patch is the degree to which it\n> depends on the JVM internals. While this works with the current Oracle JVM,\n> my concern is for JVMs from other vendors and future Oracle versions.\n\nI ha exactly the same concerns! But I was sure about how much change the upstream development would accept.\n\n> \n> I did take a quick look at the ZIP specification [1] and it appears it\n> should be fairly simple to read the file names and data offsets from the\n> local file headers. I wonder if writing a parser that extracts just the info\n> we need and skips the rest might be a better option.\n\nYes, I had the same idea while figuring how to abuse the ZipInputStream for above solution. How hard could it be to parse an header entry...\n\n> \n> Finally, there are a few changes in the patch that aren't strictly related\n> to fixing the problem at hand. It is generally better to put that sort of\n> clean-up in a separate patch (no need to re-submit this patch - the comment\n> is more for future reference).\n\nOkay, I always try to separate the relevant changes from unrelated stuff, but sometimes I miss something while preparing a patch.\n\n> \n> [1] https://pkware.cachefly.net/webdocs/casestudies/\n\nAnother remark from my side:\nThe JarInputStream is used to parse each i.e. Jar file once per Webapp class loader. I tried to understand the verifying of the manifest and possible signed entries, but I failed. Do you have a better understanding of this topic and can you say if something did break in this area? How to check?", "count": 10, "id": 198362, "time": "2017-04-19T13:06:10Z", "creator": "thomas@m3y3r.de", "creation_time": "2017-04-19T13:06:10Z", "is_private": false}, {"count": 11, "tags": [], "creator": "knst.kolinko@gmail.com", "text": "(In reply to Thomas Meyer from comment #8)\n> \n> Theoretically we want those bytes to be counted, but the ZipInputStream\n> doesn't read anything in it's construction phase, that's why the whole \"fast\n> forward skipping works at all\".\n> And yes this is a somewhat hackish solution but it works.\n> \n\n1. I do not know whether this is a concern (I have not looked at the patch), but note the behaviour that was recently reported as bug 60940:\n\nJarInputStream constructor does read MANIFEST.MF and META-INF/ directory entry that may precede it.\n\n2. Zip* and Jar* APIs differ in their handling of i18n filenames. JAR specification uses UTF-8 for file names, Zip uses platform encoding by default.", "id": 198368, "time": "2017-04-19T18:01:51Z", "bug_id": 60963, "creation_time": "2017-04-19T18:01:51Z", "is_private": false, "attachment_id": null}, {"attachment_id": null, "tags": [], "bug_id": 60963, "is_private": false, "count": 12, "id": 198377, "time": "2017-04-19T20:01:28Z", "creator": "thomas@m3y3r.de", "creation_time": "2017-04-19T20:01:28Z", "text": "(In reply to Konstantin Kolinko from comment #11)\n> (In reply to Thomas Meyer from comment #8)\n> > \n> > Theoretically we want those bytes to be counted, but the ZipInputStream\n> > doesn't read anything in it's construction phase, that's why the whole \"fast\n> > forward skipping works at all\".\n> > And yes this is a somewhat hackish solution but it works.\n> > \n> \n> 1. I do not know whether this is a concern (I have not looked at the patch),\n> but note the behaviour that was recently reported as bug 60940:\n> \n> JarInputStream constructor does read MANIFEST.MF and META-INF/ directory\n> entry that may precede it.\n\nYes, I saw this and it's still done after the patch.\n\nWhat I didn't finish to understand is the validation of the signed MANIFEST.MF entries. Is it really enough to just read through the whole JAR file with a JarInputStream with getNextJarEntry() and everything is automagically checked for correctness?\n\nDo we care that a WAR file contains only correct signed JAR files? I never really was involved in the topic signed war files and/or containing jar files inside a war file.\n\n> \n> 2. Zip* and Jar* APIs differ in their handling of i18n filenames. JAR\n> specification uses UTF-8 for file names, Zip uses platform encoding by\n> default.\n\nThat is an important hint, I think we should really go for an minimal functional ZIP \"PK entry\" parser to extract the offset of each \"PK entry start\", to fast forward in the jar file inside the war file."}, {"count": 13, "tags": [], "creator": "thomas@m3y3r.de", "text": "Hi,\n\nI implemented a basic ZIP file parser. An updated patch is here:\nhttp://static.217.14.99.88.clients.your-server.de/501", "id": 198470, "time": "2017-04-22T14:28:20Z", "bug_id": 60963, "creation_time": "2017-04-22T14:28:20Z", "is_private": false, "attachment_id": null}, {"count": 14, "tags": [], "text": "Hi,\n\nany news on this? Do you want me to attach the patch here? Anything else I can do?", "is_private": false, "bug_id": 60963, "id": 198582, "time": "2017-04-28T06:34:59Z", "creator": "thomas@m3y3r.de", "creation_time": "2017-04-28T06:34:59Z", "attachment_id": null}, {"attachment_id": 34980, "tags": [], "bug_id": 60963, "text": "Created attachment 34980\nupdated patch", "count": 15, "id": 198686, "time": "2017-05-05T07:57:01Z", "creator": "thomas@m3y3r.de", "creation_time": "2017-05-05T07:57:01Z", "is_private": false}, {"count": 16, "text": "Created attachment 34981\nupdated patch", "creator": "thomas@m3y3r.de", "is_private": false, "id": 198687, "time": "2017-05-05T07:58:23Z", "bug_id": 60963, "creation_time": "2017-05-05T07:58:23Z", "tags": [], "attachment_id": 34981}, {"attachment_id": null, "tags": [], "bug_id": 60963, "text": "The upcoming commons-compress 1.14 library will have support for fetching the offsets of the zip local headers - https://github.com/apache/commons-compress/pull/22\n\nshould we use that library in favour of my custom written zip parser?\n\nopinions?", "count": 17, "id": 198773, "time": "2017-05-13T05:57:24Z", "creator": "thomas@m3y3r.de", "creation_time": "2017-05-13T05:57:24Z", "is_private": false}, {"count": 18, "tags": [], "creator": "markt@apache.org", "text": "That is probably overkill in terms of size of the library compared to the current patch.", "id": 198777, "time": "2017-05-13T22:54:33Z", "bug_id": 60963, "creation_time": "2017-05-13T22:54:33Z", "is_private": false, "attachment_id": null}, {"count": 19, "tags": [], "bug_id": 60963, "text": "Just a quick note to say I haven't forgotten about this. It is still on my TODO list. I hope to get to it in the next week or so.", "id": 199305, "time": "2017-06-20T21:13:59Z", "creator": "markt@apache.org", "creation_time": "2017-06-20T21:13:59Z", "is_private": false, "attachment_id": null}, {"count": 20, "tags": [], "text": "Just kibitzing, and likely way off base, but:  I've been fairly impressed by the Spring Boot Loader code for handling JARs in (uncompressed) WARs, not sure whether it could make itself useful here.", "is_private": false, "bug_id": 60963, "id": 199343, "time": "2017-06-22T21:47:28Z", "creator": "thomas.mpp.maslen@gmail.com", "creation_time": "2017-06-22T21:47:28Z", "attachment_id": null}, {"count": 21, "tags": [], "bug_id": 60963, "text": "*** Bug 61212 has been marked as a duplicate of this bug. ***", "id": 199372, "time": "2017-06-23T18:59:16Z", "creator": "markt@apache.org", "creation_time": "2017-06-23T18:59:16Z", "is_private": false, "attachment_id": null}, {"count": 22, "text": "Unfortunately, Boot depends on the outer JAR/WAR being uncompressed. Tomcat does not have the option to require that.\n\nMy current test (a WAR that just contains all the JAR files from Jira 7.3.4) takes ~3s to start unpacked, ~110s to start packed and ~95s to start packed with the latest patch. There is clear improvement but it is still a long way off the unpacked start time.\n\nNearly all the additional time is spent in decompression.\n\nThe fundamental problem is that we have to decompress the input stream associated with the inner JAR file before we can read any resources from it. And we have to do this for every resource we read.\n\nThe obvious answer is to unpack the JAR files to the work directory. This is what Tomcat 7 does. Start-up time there is ~9s (including the time to unpack the JARs to work). However, one of the aims of the resources re-write in 8.0.x was to avoid the complexity of file locking protection that that entailed.\n\nWhich brings me back to an old question on this topic. What is it that prevents you from running with unpackWARs=\"true\"? It might turn out to be simpler to address whatever is preventing you from using that default config.\n\nStill mulling over how best to handle this...", "creator": "markt@apache.org", "is_private": false, "id": 199596, "time": "2017-07-05T21:21:37Z", "bug_id": 60963, "creation_time": "2017-07-05T21:21:37Z", "tags": [], "attachment_id": null}, {"count": 23, "tags": [], "creator": "thomas@m3y3r.de", "attachment_id": null, "is_private": false, "id": 199598, "time": "2017-07-05T21:50:34Z", "bug_id": 60963, "creation_time": "2017-07-05T21:50:34Z", "text": "I was told that all tomcats are run with unpackWARs=false for security reasons. I really tried to convince the ops from changing the parameter to true, but no chance. I think you can run Tomcat with ro filesystem with unpackWARs=false?!\n\nSo this is why I tried to optimise this case a bit."}, {"count": 24, "tags": [], "creator": "markt@apache.org", "text": "Any chance you could elaborate on \"security reasons\"?\n\nFor a read-only file system, you'd be much better off deploying am unpacked WAR. And the tricks earlier Tomcat versions used (like unpacking the JARs to the work directory) wouldn't work in that case anyway.\n\nThe proposed patch essentially trades memory for performance. I'm currently thinking about extending that idea and experimenting with caching different things with a view to providing a small number of options that gives enough flexibility to meet the needs of most use cases.", "id": 199870, "time": "2017-07-18T20:21:47Z", "bug_id": 60963, "creation_time": "2017-07-18T20:21:47Z", "is_private": false, "attachment_id": null}, {"count": 25, "tags": [], "bug_id": 60963, "text": "Having looked into this further, the only way I could see to improve things significantly was to pre-process the JAR files from a packed WAR and populate the cache with the contents of the JARs. This wasn't a great solution for several reasons:\n- It would have required a fair amount of new code and/or a lot of refactoring\n- The memory requirements for the cache would increase. For the solution to be useful, all the contents of all the JARs need to reside in the cache.\n\nIn the end, I opted to implement a new WebResourceRoot implementation, ExtractingRoot that returns to the 7.0.x idea of extracting the JAR files into the work directory. This will be included in 9.0.0.M25 onwards. Assuming no issues are identified, I'll back-port it to 8.5.x and 8.0.x. An open question is whether the overall refactoring of resource handling is sufficient to protect against the file locking issues.", "id": 199892, "time": "2017-07-20T14:20:31Z", "creator": "markt@apache.org", "creation_time": "2017-07-20T14:20:31Z", "is_private": false, "attachment_id": null}, {"count": 26, "tags": [], "creator": "markt@apache.org", "text": "ExtractingRoot has been back-ported to 8.5.x for 8.5.22 onwards and to 8.0.x for 8.0.47 onwards.", "id": 200866, "time": "2017-09-14T09:40:05Z", "bug_id": 60963, "creation_time": "2017-09-14T09:40:05Z", "is_private": false, "attachment_id": null}]