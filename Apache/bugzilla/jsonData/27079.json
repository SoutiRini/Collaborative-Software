[{"count": 0, "attachment_id": null, "bug_id": 27079, "text": "I am testing apache 2.048 for use in a business application and am trying to \nsee what happens when the client processs dies (simulating a program error by \nusing kill -5 PID) I can see that the process gets restarted by the parent but \nit will no longer accept requests.  I have reproduced this without my 3rd party \nmodule loaded by doing the following\n\nI am using SSL / although my non-ssl port also has the problem.\n\nEnable Mod Info\nStart Apache\ntry https://localhost/server-info (displayed OK)\nKill the non-root version of httpd. the process will get restarted.\ntry https://localhost/server-info (Hangs for me)\n\n\nThanks\n\nMick", "id": 52568, "time": "2004-02-19T14:47:31Z", "creator": "mick@mickandwendy.com", "creation_time": "2004-02-19T14:47:31Z", "tags": [], "is_private": false}, {"count": 1, "tags": [], "bug_id": 27079, "attachment_id": null, "text": "Are you using a non-default AcceptMutex mechanism, such as \"AcceptMutex pthread\"?\n\nDoes it matter whether or not mod_ssl is loaded?\n\nDoes it matter whether you use SIGSEGV vs. SIGTRAP (kill -5)?  Try kill -SEGV\nPID.  I've done this many times on AIX but with signals other than SIGTRAP and\nwithout mod_ssl loaded.\n\nI'm afraid that when this type of hang occurs (server won't respond after some\ncrash), it would be nice to see backtraces of all threads in all children to\nmake sure that there is no lost mutex.  Try this script:\nhttp://www.apache.org/~trawick/aixthrdbt.pl\n", "id": 52614, "time": "2004-02-19T21:15:53Z", "creator": "trawick@apache.org", "creation_time": "2004-02-19T21:15:53Z", "is_private": false}, {"count": 2, "tags": [], "bug_id": 27079, "text": "Jeff, Thanks for the comments, It doesn't seem to matter what signal I send it, \nI've tried 2 5 and 9!.  We are using AcceptMutex=pthread?, I'll get the back \ntraces tomorrow when I'm back in the office.\n\nMick", "id": 52617, "time": "2004-02-19T21:42:30Z", "creator": "mick@mickandwendy.com", "creation_time": "2004-02-19T21:42:30Z", "is_private": false, "attachment_id": null}, {"count": 3, "tags": [], "bug_id": 27079, "attachment_id": null, "id": 52618, "creation_time": "2004-02-19T21:52:36Z", "time": "2004-02-19T21:52:36Z", "creator": "trawick@apache.org", "text": "\"We are using AcceptMutex=pthread\"\n\nIf you're using AcceptMutex pthread, don't bother.  The tracebacks would\npresumably show the listener thread in each child waiting to obtain the accept\nmutex, and no listener thread holding the mutex.  That type of mutex cannot be\nrecovered after a holder of the mutex crashes.  You're better off leaving it at\nthe AIX default of sysvsem.\n", "is_private": false}, {"count": 4, "tags": [], "creator": "mick@mickandwendy.com", "attachment_id": null, "id": 52619, "time": "2004-02-19T21:56:54Z", "bug_id": 27079, "creation_time": "2004-02-19T21:56:54Z", "is_private": false, "text": "Thanks, I'll try that.  Would this still be true if we only have one client?.  \nWe are using the worker MPM and have it configured to allow only 1 client with \nmany threads (a limitation of the application i'm working with).\n\nMick"}, {"count": 5, "tags": [], "text": ">Would this still be true if we only have one client?.  \n>We are using the worker MPM and have it configured to allow only \n>1 client with many threads\n\nWe call that \"one child process\" instead of \"one client.\"\n\nYes, it is true with one many-threaded child process too.  In fact, with a\nsingle child process you guarantee that the child process being whacked is\nholding the accept mutex.  The parent sees that it needs to create a new child\nprocess, but the listener thread in the new child process blocks waiting to\nobtain the accept mutex that was held by the whacked child process.\n\n(This use of the accept mutex on modern AIX is only when there is more than one\nlistening socket.  But you have more than one listening socket.)\n", "attachment_id": null, "id": 52623, "creator": "trawick@apache.org", "time": "2004-02-20T00:50:51Z", "bug_id": 27079, "creation_time": "2004-02-20T00:50:51Z", "is_private": false}, {"count": 6, "attachment_id": null, "bug_id": 27079, "text": "Many thanks, problem solved.  Can't help thinking something should be done on \nthe pthread implementation so stop this.\n\nThanks again \n\nMick", "id": 52633, "time": "2004-02-20T09:21:47Z", "creator": "mick@mickandwendy.com", "creation_time": "2004-02-20T09:21:47Z", "tags": [], "is_private": false}, {"count": 7, "attachment_id": null, "bug_id": 27079, "text": "Unforunately all the mutex implementations have their own nuances.  This\nparticular nuance of pthread cross-process mutexes is why it is not the default\non AIX.\n\nFWIW, Solaris offers APIs for recovery of a cross-process pthread mutex after\nthe holder crashes and Apache 2 uses those APIs, but some Apache users and\ncustomers of Apache-based servers have unfortunately found out that the recovery\nafter the mutex holder crashes is not reliable.  The accept mutex has to be\nchanged in that situation to something besides pthread.\n\nWhat Apache MPMs could do is implement an exception hook and release the accept\nmutex in the exception hook if it was being held.  This wouldn't catch all\naccept mutex scenarios (e.g., some thread caused a crash right as the OS gave\nthe listener thread ownership of the mutex and the MPM didn't get a chance to\ntake note that it held it).  It wouldn't help for any mutexes used by modules\neither.\n\nAnd regardless of the mutex issues, the original cause of the crash still hs to\nbe fixed.\n\nI'm reopening the bug and will close it as WONTFIX, as there is work that could\npotentially be done to help this situation but at the present time we would not\nplan to do it ;)", "id": 52657, "time": "2004-02-20T12:48:37Z", "creator": "trawick@apache.org", "creation_time": "2004-02-20T12:48:37Z", "tags": [], "is_private": false}]