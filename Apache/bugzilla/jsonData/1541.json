[{"count": 0, "tags": [], "creator": "aroy@boostmyscore.com", "attachment_id": null, "id": 2120, "time": "2001-04-26T11:10:38Z", "bug_id": 1541, "creation_time": "2001-04-26T11:10:38Z", "is_private": false, "text": "Even in very small documents, a TreeWalkerImpl created to find nodes of a \nspecific name can take arbitrarily long amounts of time. Also, in larger \ndocuments, similar filters can cause StackOverflowError's.\n\nI have included source for a small test file below that can be used to \nreproduce the bug. In it, an xml document is created and passed to the \nTreeWalker. A filter is created that matches only nodes with a given name. \nTreeWalker.nextNode() begins to take arbitrarily long amounts of time for even \nsmall documents (~60 seconds for a 3/3/2 (~20) node document). This only occurs \nwhen there is a low number of nodes that match the filter.\n\nIn addition, a wider filter (for example two tags) can cause a \nStackOverflowError on large documents (e.g. 14/13/11 (2000+) nodes).\n\nRunning the following code will result in the output:\n>>\nrootheader\nnull\napproximately 68.098 seconds\n>>\nChanging the size of the document to 14/13/11, and setting the nodefilter to \nuse FILTER_TAGS_B will result in the following output:\n>>\nrootheader\njava.lang.StackOverflowError\n>>\n\nCode:\n>>>>>\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.traversal.TreeWalker;\nimport org.apache.xerces.dom.TreeWalkerImpl;\nimport org.w3c.dom.traversal.NodeFilter;\nimport org.apache.xerces.parsers.DOMParser;\nimport org.xml.sax.InputSource;\nimport java.io.StringReader;\n\npublic class TestWalker {\n\t// this many children of root node\n\tprivate static final int NUM_BRANCH = 3;\n\t// this many children of each branch node\n\tprivate static final int NUM_TWIG = 3;\n\t// this many children for each twig node\n\tprivate static final int NUM_LEAF = 2;\n\tprivate static final String[] FILTER_TAGS_A = {\"rootheader\"};\n\tprivate static final String[] FILTER_TAGS_B = {\"rootheader\",\n\t\t\t\t\t\t\t\t\t\t\n\t\t \"rootfooter\"};\n\n\tpublic TestWalker() {\n\t\ttry {\n\t\t\trunTest(parseXML(createXML()));\n\t\t} catch (StackOverflowError e) {\n\t\t\tSystem.out.println(e);\n\t\t}\n\t} // end constructor()\n\n\t// Creates a TreeWalker with a simple name filter and loops\n\t// through each node returned until the document is finished.\n\tprivate void runTest(Document doc) {\n\t\t// Create TreeWalker with inline filter.\n\t\t// The filter simply looks for a node matching the filter node.\n\t\tTreeWalker walker = new \n\t\t\tTreeWalkerImpl(doc, Node.ELEMENT_NODE,\n\t\t\t\t\t\t   new NodeFilter() {\n\t\t\t\t\t\t\t\t   protected \nString tag[] = FILTER_TAGS_A;\n\t\t\t\t\t\t\t\t   \n\t\t\t\t\t\t\t\t   public short \nacceptNode (Node n) {\n\t\t\t\t\t\t\t\t\t   \nString testName = n.getNodeName();\n\t\t\t\t\t\t\t\t\t   for \n(int i=0; i < tag.length; i++) {\n\t\t\t\t\t\t\t\t\t\n\t   if (testName.equals(tag[i]))\n\t\t\t\t\t\t\t\t\t\t\n\t   return FILTER_ACCEPT;\n\t\t\t\t\t\t\t\t\t   }\n\t\t\t\t\t\t\t\t\t   \nreturn FILTER_SKIP;\n\t\t\t\t\t\t\t\t   } // end \nacceptNode(Node)\n\t\t\t\t\t\t\t\t   \n\t\t\t\t\t\t\t   }, true);\n\t\t// Loop until done.\n\t\tlong startTime;\n\t\tlong endTime;\n\t\tstartTime = System.currentTimeMillis();\n\t\tNode node = walker.nextNode();\n\t\twhile (node != null) {\n\t\t\tSystem.out.println(node.getNodeName());\n\t\t\tnode = walker.nextNode();\n\t\t}\n\t\tendTime = System.currentTimeMillis();\n\t\tSystem.out.println(\"null\");\n\t\tdouble runTime = (double)(endTime - startTime);\n\t\tSystem.out.println(\"approximately \" + (runTime/1000.0) + \n\t\t\t\t\t\t   \" seconds\");\n\t} // end runTest()\n\n\t// Parses given String and returns a Document\n\tprivate Document parseXML(String xmlSrc) {\n\t\t// Double check accuracy of created xml:\n\t\t// System.out.println(\"Source:\\n\" + xmlSrc);\n\t\tDOMParser parser = new DOMParser();\n\t\tInputSource in = new InputSource(new StringReader(xmlSrc));\n\t\ttry { parser.parse(in);\n\t\t} catch (Exception e) {e.printStackTrace();System.exit(1);}\n\t\treturn parser.getDocument();\n\t} // end parseXML()\n\n\t// Creates a simple Document based on global parameters.\n\t// The root has NUM_BRANCH children, each has NUM_TWIG children,\n\t// and each of those has NUM_LEAF children.\n\tprivate String createXML() {\n\t\tStringBuffer xmlSrc = new StringBuffer();\n\t\txmlSrc.append(\"<?xml version=\\\"1.0\\\"?>\\n\");\n\t\txmlSrc.append(\"<root><rootheader>Root</rootheader>\\n\");\n\t\tfor (int x=0; x < NUM_BRANCH; x++) {\n\t\t\txmlSrc.append\n(\"\\t<branch><branchheader>Branch\"+x+\"</branchheader>\\n\");\n\t\t\txmlSrc.append\n(\"\\t\\t<resource>Resource\"+x+\"</resource>\\n\");\n\t\t\tfor (int y=0; y<NUM_TWIG; y++) {\n\t\t\t\txmlSrc.append\n(\"\\t\\t<twig><twigheader>Twig\"+x+\".\"+y+\n\t\t\t\t\t\t\t  \"</twigheader>\\n\");\n\t\t\t\tfor (int z=0; z<NUM_LEAF; z++)\n\t\t\t\t\txmlSrc.append\n(\"\\t\\t\\t<leaf>Leaf\"+x+\".\"+y+\".\"+z+\"</leaf>\\n\");\n\t\t\t\txmlSrc.append(\"\\t\\t</twig>\\n\");\n\t\t\t}\n\t\t\txmlSrc.append(\"\\t</branch>\\n\");\n\t\t}\n\t\txmlSrc.append(\"<rootfooter>The End</rootfooter>\\n\");\n\t\txmlSrc.append(\"</root>\");\n\t\treturn xmlSrc.toString();\n\t} // end createXML()\n\n\t// Usage: java TestWalker\n\tpublic static void main(String[] args) {\n\t\tTestWalker bob = new TestWalker();\n\t} // end main\n} // end class TestWalker\n\n>>>>>"}, {"count": 1, "tags": [], "bug_id": 1541, "attachment_id": null, "text": "Fixed in CVS today. Can you pick up latest Xerces and try it out?", "id": 3070, "time": "2001-06-19T09:55:10Z", "creator": "elena@apache.org", "creation_time": "2001-06-19T09:55:10Z", "is_private": false}, {"count": 2, "tags": [], "bug_id": 1541, "text": "Created attachment 250\nRevised test case showing new failure modes and unresolved failures", "id": 3204, "time": "2001-06-22T11:22:40Z", "creator": "dean@brettle.com", "creation_time": "2001-06-22T11:22:40Z", "is_private": false, "attachment_id": 250}, {"count": 3, "text": "Created attachment 251\nPatch to resolve problems illustrated by TestWalker.java", "creator": "dean@brettle.com", "attachment_id": 251, "id": 3205, "time": "2001-06-22T11:27:44Z", "bug_id": 1541, "creation_time": "2001-06-22T11:27:44Z", "tags": [], "is_private": false}, {"count": 4, "tags": [], "creator": "dean@brettle.com", "attachment_id": null, "id": 3208, "time": "2001-06-22T11:50:11Z", "bug_id": 1541, "creation_time": "2001-06-22T11:50:11Z", "is_private": false, "text": "Unfortunately, Elena's fix created a new problem.  Specifically,\nTreeWalker.firstChild() now returns the nextSibling() of the current node if the\ncurrent node is a leaf node.  I attached a test case (id=250) to illustrate.\n\nThe test case also takes forever when traversing backwards (eg via\npreviousNode()).\n\nThe cause of the original problem (and the remaining problem with\npreviousNode()) is that getNextSibling(Node) and getPreviousSibling(Node) can\ntraverse all the way up the tree, even when they are called from\ngetFirstChild(Node) and getLastChild(Node).  I've attached a patch (id=251)\nwhich solves the problem by allowing getFirstChild(Node) and getLastChild(Node)\nto specify the parent node above which getNextSibling(Node) and\ngetPreviousSibling(Node) should not traverse.\n\nEven with my patch, there is still a problem with running out of stack space\nwhen traversing very large documents.  I see this if I set NUM_BRANCH = 10000 in\nthe test case.  To solve this the class would need to be rewritten to not use\nrecursion.\n"}, {"count": 5, "tags": [], "creator": "elena@apache.org", "attachment_id": null, "id": 3209, "time": "2001-06-22T12:05:22Z", "bug_id": 1541, "creation_time": "2001-06-22T12:05:22Z", "is_private": false, "text": "Dean thank you for testing the code and submitting the patch: I did not realize \nthat getFirstChild() is also used in DOM firstChild() method.. I will take a \nlook at your patch."}, {"count": 6, "tags": [], "bug_id": 1541, "attachment_id": null, "text": "Applied the patch. Might need to revisit in the future.", "id": 3265, "time": "2001-06-26T07:18:20Z", "creator": "elena@apache.org", "creation_time": "2001-06-26T07:18:20Z", "is_private": false}]