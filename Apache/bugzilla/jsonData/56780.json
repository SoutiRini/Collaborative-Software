[{"count": 0, "tags": [], "creator": "rwatts@us.ibm.com", "attachment_id": null, "id": 176715, "time": "2014-07-28T17:38:05Z", "bug_id": 56780, "creation_time": "2014-07-28T17:38:05Z", "is_private": false, "text": "The problem is a change made in Tomcat 7.0.39. \n\nThe offending code is in org.apache.tomcat.util.net.jsse.JSSESocketFactory.{...}:\n\n        try {\n            context = SSLContext.getInstance(\"TLS\");\n            ...\n\n            SSLServerSocket socket = (SSLServerSocket) ssf.createServerSocket();\n           ...\n        } catch (NoSuchAlgorithmException e) {\n            // Assume no RFC 5746 support\n        } catch (KeyManagementException e) {\n            // Assume no RFC 5746 support\n        } catch (IOException e) {\n            // Unable to determine default ciphers/protocols so use none\n        }\n        \nWith the IBM JVM configured for strict SP800-131a mode, the ssf.createServerSocket() will throw an IllegalArgumentException, which is a very bad thing to have happen in a class initializer.\n\nIBM JRE: 6.0 (SR16) : Email me direct for the JRE if you want to test it."}, {"count": 1, "attachment_id": null, "bug_id": 56780, "text": "What value(s) will the IBM JRE accept there?\n\nAs an aside, if you can provide a IBM JRE for Windows to test with (preferably 64-bit) to markt@apache.org that would be great.", "id": 176731, "time": "2014-07-28T21:59:10Z", "creator": "markt@apache.org", "creation_time": "2014-07-28T21:59:10Z", "tags": [], "is_private": false}, {"count": 2, "tags": [], "creator": "karl.freburger@gmail.com", "attachment_id": null, "text": "If the IBM JVM is configured for strict SP800-131a mode, the only acceptable value (currently) for the protocol would be \"TLSv1.2\". If strict SP800-131a mode is NOT on, many other values are acceptable (\"TLS\", etc).\n\nNote that if there was ever a TLSv1.3, then that would also become an acceptable value for the protocol.\n\nIf I read the code correctly (that's a big IF), the appropriate action here is to catch IllegalArgumentException and treat it like IOException.", "id": 176753, "time": "2014-07-29T15:29:45Z", "bug_id": 56780, "creation_time": "2014-07-29T15:29:45Z", "is_private": false}, {"count": 3, "tags": [], "creator": "markt@apache.org", "text": "Handling it the same way as IOException should work, yes. That fix has been applied to 8.0.x for 8.0.11 onwards and to 7.0.x for 7.0.56 onwards.", "id": 176929, "time": "2014-08-05T15:51:09Z", "bug_id": 56780, "creation_time": "2014-08-05T15:51:09Z", "is_private": false, "attachment_id": null}, {"count": 4, "tags": [], "bug_id": 56780, "attachment_id": null, "text": "looking at 7.0.56... it does not look like this made it into that release. Can someone comment?", "id": 178622, "time": "2014-10-20T14:37:31Z", "creator": "rwatts@us.ibm.com", "creation_time": "2014-10-20T14:37:31Z", "is_private": false}, {"count": 5, "attachment_id": null, "bug_id": 56780, "text": "Unfortunately, the fix doesn't work...now we see this:\n\nThrowable occurred: org.apache.catalina.LifecycleException: Failed to initialize component [Connector[HTTP/1.1-9443]]\n        at org.apache.catalina.util.LifecycleBase.init(LifecycleBase.java:106)\n        at org.apache.catalina.core.StandardService.initInternal(StandardService.java:559)\n        at org.apache.catalina.util.LifecycleBase.init(LifecycleBase.java:102)\n        at org.apache.catalina.core.StandardServer.initInternal(StandardServer.java:821)\n        at org.apache.catalina.util.LifecycleBase.init(LifecycleBase.java:102)\n        at org.apache.catalina.startup.Catalina.load(Catalina.java:638)\n        at org.apache.catalina.startup.Catalina.load(Catalina.java:663)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:60)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:37)\n        at java.lang.reflect.Method.invoke(Method.java:611)\n        at org.apache.catalina.startup.Bootstrap.load(Bootstrap.java:280)\n        at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:454)\nCaused by: org.apache.catalina.LifecycleException: Protocol handler initialization failed\n        at org.apache.catalina.connector.Connector.initInternal(Connector.java:980)\n        at org.apache.catalina.util.LifecycleBase.init(LifecycleBase.java:102)\n        ... 12 more\nCaused by: java.io.IOException: Protocols may not be null\n        at org.apache.tomcat.util.net.jsse.JSSESocketFactory.init(JSSESocketFactory.java:465)\n        at org.apache.tomcat.util.net.jsse.JSSESocketFactory.createSocket(JSSESocketFactory.java:187)\n        at org.apache.tomcat.util.net.JIoEndpoint.bind(JIoEndpoint.java:398)\n        at org.apache.tomcat.util.net.AbstractEndpoint.init(AbstractEndpoint.java:646)\n        at org.apache.coyote.AbstractProtocol.init(AbstractProtocol.java:434)\n        at org.apache.coyote.http11.AbstractHttp11JsseProtocol.init(AbstractHttp11JsseProtocol.java:119)\n        at org.apache.catalina.connector.Connector.initInternal(Connector.java:978)\n        ... 13 more\nCaused by: java.lang.IllegalArgumentException: Protocols may not be null\n        at com.ibm.jsse2.zb.a(zb.java:86)\n        at com.ibm.jsse2.zb.<init>(zb.java:55)\n        at com.ibm.jsse2.cd.setEnabledProtocols(cd.java:8)\n        at org.apache.tomcat.util.net.jsse.JSSESocketFactory.initServerSocket(JSSESocketFactory.java:753)\n        at org.apache.tomcat.util.net.jsse.JSSESocketFactory.checkConfig(JSSESocketFactory.java:768)\n        at org.apache.tomcat.util.net.jsse.JSSESocketFactory.init(JSSESocketFactory.java:460)\n        ... 19 more\n\nIt's triggered by the same place in org.apache.tomcat.util.net.jsse.JSSESocketFactory.{...}:\n\n            context = SSLContext.getInstance(\"TLS\");\n\nNow DEFAULT_SERVER_PROTOCOLS is set to null because of the exception.\n\nIs there a way to get the sslProtocol attribute specified for the connector in the server.xml? That has the value that should be used to create the SSLContext.", "id": 178623, "time": "2014-10-20T14:53:40Z", "creator": "karl.freburger@gmail.com", "creation_time": "2014-10-20T14:53:40Z", "tags": [], "is_private": false}, {"count": 6, "tags": [], "bug_id": 56780, "attachment_id": null, "text": "@Mark Thomas: I am able to see the bug fix in 7.0.56.\n\n@Karl Freburger:  Can you mail a 64-bit IBM JRE for Windows to cloakcavalier@gmail.com?", "id": 178631, "time": "2014-10-21T08:13:29Z", "creator": "cloakcavalier@gmail.com", "creation_time": "2014-10-21T08:13:29Z", "is_private": false}, {"count": 7, "tags": [], "creator": "markt@apache.org", "attachment_id": null, "id": 178685, "time": "2014-10-22T20:59:47Z", "bug_id": 56780, "creation_time": "2014-10-22T20:59:47Z", "is_private": false, "text": "> Is there a way to get the sslProtocol attribute specified for the connector\n> in the server.xml? That has the value that should be used to create the\n> SSLContext.\n\nThat is what is used. If you set sslProtocol=\"TLSv1.2\" and sslEnabledProtocols=\"TLSv1.2\" you should get past the exception you are currently seeing.\n\nI now see a problem with cipher suites in my test environment. I'm still looking at whether this is a configuration problem or a Tomcat bug. The jury is out at this point so I am leaving this issue open."}, {"count": 8, "tags": [], "bug_id": 56780, "attachment_id": null, "is_private": false, "id": 178687, "time": "2014-10-22T21:37:03Z", "creator": "markt@apache.org", "creation_time": "2014-10-22T21:37:03Z", "text": "I have confirmed that this is a configuration issue.\n\nA side effect of configuring strict SP800-131a mode and how Tomcat determines the available ciphers is that the default set of configured ciphers ends up being null. The simplest workaround to get to a working system is to use ciphers=\"ALL\". In strict SP800-131a mode that should be a safe option. If you want to further restrict the ciphers list you can configure an explicit list of ciphetrs.\n\nI am restoring this issue to FIXED since the additional issues raised since the original bug was fixed in 7.0.56 are configuration issues not coding bugs."}, {"id": 178690, "tags": [], "creator": "knst.kolinko@gmail.com", "is_private": false, "count": 9, "text": "1. If IllegalArgumentException is thrown from static{} block of a class,  is it fatal for the class or not?\n\nIf it were fatal, the static{} block should have try/catch for IllegalArgumentException.\n\nOK - JSSESocketFactory in Tomcat 7 has such catch, but Tomcat 6 does not have it yet.\n\n2. This affects RFC_5746_SUPPORTED flag as well, as it will not be initialized and will remain in the state of \"false\".\n\n3. Is it possible to try several names in turn in \"SSLContext.getInstance(\"TLS\");\"\nsuch as \"TLS\", \"TLSv1.1\" and \"TLSv1.2\"?\n\n4. If this results in null value for DEFAULT_SERVER_PROTOCOLS then maybe\n\na) Report some error when DEFAULT_SERVER_PROTOCOLS is null?\n\nFrom comment 5 we are lucky that passing the null to JRE API call results in an IllegalArgumentException with some decent message. I feared that it would be a NullPointerException.\n\nb) Replace it with an empty String[] array. I think the message from JRE will be more near to the actual problem.", "time": "2014-10-22T22:44:28Z", "bug_id": 56780, "creation_time": "2014-10-22T22:44:28Z", "attachment_id": null}, {"count": 10, "attachment_id": null, "bug_id": 56780, "text": "> 3. Is it possible to try several names in turn in\n> \"SSLContext.getInstance(\"TLS\");\" such as \"TLS\", \"TLSv1.1\" and \"TLSv1.2\"?\n\nOther ideas:\nA) Use JSSESocketFactory.defaultProtocol field here and allow it to be configured via a system property.\n\nB) Defer evaluation of DEFAULT_SERVER_PROTOCOLS until there is a SSLContext instance that can be used to evaluate it, created from user-provided protocol name.\n\nSSLContext.getProtocol() returns the protocol name and that allows to create a different SSLContext instance to test its defaults.", "id": 178694, "time": "2014-10-23T08:27:59Z", "creator": "knst.kolinko@gmail.com", "creation_time": "2014-10-23T08:27:59Z", "tags": [], "is_private": false}, {"count": 11, "attachment_id": null, "bug_id": 56780, "is_private": false, "id": 178697, "time": "2014-10-23T09:24:06Z", "creator": "markt@apache.org", "creation_time": "2014-10-23T09:24:06Z", "tags": [], "text": "(In reply to Konstantin Kolinko from comment #10)\n> > 3. Is it possible to try several names in turn in\n> > \"SSLContext.getInstance(\"TLS\");\" such as \"TLS\", \"TLSv1.1\" and \"TLSv1.2\"?\n\nWorkable but ugly and not future proof for TLSv1.3 etc.\n\n> Other ideas:\n> A) Use JSSESocketFactory.defaultProtocol field here and allow it to be\n> configured via a system property.\n\nYuck. I'm not a fan of system properties.\n\n> B) Defer evaluation of DEFAULT_SERVER_PROTOCOLS until there is a SSLContext\n> instance that can be used to evaluate it, created from user-provided\n> protocol name.\n\nI think this is possible. It looks as simple as moving the code from the static initializer to the constructor and having default per instance rather than at the class level (which makes more sense for protocols and ciphers since they may vary with connector configuration).\n\nI'll take a look..."}, {"count": 12, "tags": [], "bug_id": 56780, "attachment_id": null, "text": "Improved init code applied to 8.0.x for 8.0.15 onwards and to 7.0.x for 7.0.57 onwards.\n\nThe original issue has not been addressed in 6.0.x so the improved init code hasn't been applied either. The refactoring between 6.0.x and 7.0.x makes it more complex to backport and without an explicit user request, I do not plan to do so.", "id": 178698, "time": "2014-10-23T10:21:26Z", "creator": "markt@apache.org", "creation_time": "2014-10-23T10:21:26Z", "is_private": false}, {"count": 13, "attachment_id": null, "bug_id": 56780, "text": "Fixed in Tomcat 6 by r1639415. The fix will be in 6.0.43 onwards.", "id": 179088, "time": "2014-11-13T17:41:18Z", "creator": "knst.kolinko@gmail.com", "creation_time": "2014-11-13T17:41:18Z", "tags": [], "is_private": false}]