[{"count": 0, "tags": [], "bug_id": 25704, "is_private": false, "id": 49550, "attachment_id": null, "creator": "chenyj@yahoo.com", "creation_time": "2003-12-22T17:38:50Z", "time": "2003-12-22T17:38:50Z", "text": "When file name is more than 100 characters, Sun splits the name and the path and\nstores the file name in the first 100 characters of the header block and the\ndirectory name of up to 155 characters at the end of the header block.\n\nI modified ANT 1.6.1 to support Sun Solaris' Tar format. Please incorporate the\nchanges to the future release of ANT. Let me know if you need further\ninformation at chenyj@yahoo.com.\n\n\n\nJack Chen\n\n/*\n * The Apache Software License, Version 1.1\n *\n * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * 3. The end-user documentation included with the redistribution, if\n *    any, must include the following acknowlegement:\n *       \"This product includes software developed by the\n *        Apache Software Foundation (http://www.apache.org/).\"\n *    Alternately, this acknowlegement may appear in the software itself,\n *    if and wherever such third-party acknowlegements normally appear.\n *\n * 4. The names \"Ant\" and \"Apache Software\n *    Foundation\" must not be used to endorse or promote products derived\n *    from this software without prior written permission. For written\n *    permission, please contact apache@apache.org.\n *\n * 5. Products derived from this software may not be called \"Apache\"\n *    nor may \"Apache\" appear in their names without prior written\n *    permission of the Apache Group.\n *\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n * ====================================================================\n *\n * This software consists of voluntary contributions made by many\n * individuals on behalf of the Apache Software Foundation.  For more\n * information on the Apache Software Foundation, please see\n * <http://www.apache.org/>.\n */\n\npackage org.apache.tools.ant.taskdefs;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.Enumeration;\nimport java.util.Vector;\nimport java.util.zip.GZIPOutputStream;\nimport org.apache.tools.ant.BuildException;\nimport org.apache.tools.ant.DirectoryScanner;\nimport org.apache.tools.ant.Project;\nimport org.apache.tools.ant.types.EnumeratedAttribute;\nimport org.apache.tools.ant.types.FileSet;\nimport org.apache.tools.ant.util.MergingMapper;\nimport org.apache.tools.ant.util.SourceFileScanner;\nimport org.apache.tools.bzip2.CBZip2OutputStream;\nimport org.apache.tools.tar.TarConstants;\nimport org.apache.tools.tar.TarEntry;\nimport org.apache.tools.tar.TarOutputStream;\nimport org.apache.tools.zip.UnixStat;\n\n/**\n * Creates a tar archive.\n *\n * @author Stefano Mazzocchi\n *         <a href=\"mailto:stefano@apache.org\">stefano@apache.org</a>\n * @author Stefan Bodewig\n * @author Magesh Umasankar\n *\n * @since Ant 1.1\n *\n * @ant.task category=\"packaging\"\n */\npublic class Tar extends MatchingTask {\n\n    /**\n     * @deprecated Tar.WARN is deprecated and is replaced with\n     *             Tar.TarLongFileMode.WARN\n     */\n    public static final String WARN = \"warn\";\n    /**\n     * @deprecated Tar.FAIL is deprecated and is replaced with\n     *             Tar.TarLongFileMode.FAIL\n     */\n    public static final String FAIL = \"fail\";\n    /**\n     * @deprecated Tar.TRUNCATE is deprecated and is replaced with\n     *             Tar.TarLongFileMode.TRUNCATE\n     */\n    public static final String TRUNCATE = \"truncate\";\n    /**\n     * @deprecated Tar.GNU is deprecated and is replaced with\n     *             Tar.TarLongFileMode.GNU\n     */\n    public static final String GNU = \"gnu\";\n    /**\n     * @deprecated Tar.OMIT is deprecated and is replaced with\n     *             Tar.TarLongFileMode.OMIT\n     */\n    public static final String OMIT = \"omit\";\n\n    /**\n     * @ Tar.SUN for Solaris Tar\n     * jyc\n     */\n    public static final String SUN = \"sun\";\n\tpublic static final int SUN_MAXLEN = 255;\n\n    File tarFile;\n    File baseDir;\n\n    private TarLongFileMode longFileMode = new TarLongFileMode();\n\n    Vector filesets = new Vector();\n    Vector fileSetFiles = new Vector();\n\n    /**\n     * Indicates whether the user has been warned about long files already.\n     */\n    private boolean longWarningGiven = false;\n\n    private TarCompressionMethod compression = new TarCompressionMethod();\n\n    /**\n     * Add a new fileset with the option to specify permissions\n     */\n    public TarFileSet createTarFileSet() {\n        TarFileSet fileset = new TarFileSet();\n        filesets.addElement(fileset);\n        return fileset;\n    }\n\n\n    /**\n     * Set is the name/location of where to create the tar file.\n     * @deprecated for consistency with other tasks, please use setDestFile()\n     */\n    public void setTarfile(File tarFile) {\n        this.tarFile = tarFile;\n    }\n\n    /**\n     * Set is the name/location of where to create the tar file.\n     * @since Ant 1.5\n     * @param destFile The output of the tar\n     */\n    public void setDestFile(File destFile) {\n        this.tarFile = destFile;\n    }\n\n    /**\n     * This is the base directory to look in for things to tar.\n     */\n    public void setBasedir(File baseDir) {\n        this.baseDir = baseDir;\n    }\n\n    /**\n     * Set how to handle long files, those with a path&gt;100 chars.\n     * Optional, default=warn.\n     * <p>\n     * Allowable values are\n     * <ul>\n     * <li>  truncate - paths are truncated to the maximum length\n     * <li>  fail - paths greater than the maximum cause a build exception\n     * <li>  warn - paths greater than the maximum cause a warning and GNU is used\n     * <li>  gnu - GNU extensions are used for any paths greater than the maximum.\n     * <li>  omit - paths greater than the maximum are omitted from the archive\n     * </ul>\n     * @deprecated setLongFile(String) is deprecated and is replaced with\n     *             setLongFile(Tar.TarLongFileMode) to make Ant's Introspection\n     *             mechanism do the work and also to encapsulate operations on\n     *             the mode in its own class.\n     */\n    public void setLongfile(String mode) {\n        log(\"DEPRECATED - The setLongfile(String) method has been deprecated.\"\n            + \" Use setLongfile(Tar.TarLongFileMode) instead.\");\n        this.longFileMode = new TarLongFileMode();\n        longFileMode.setValue(mode);\n    }\n\n    /**\n     * Set how to handle long files, those with a path&gt;100 chars.\n     * Optional, default=warn.\n     * <p>\n     * Allowable values are\n     * <ul>\n     * <li>  truncate - paths are truncated to the maximum length\n     * <li>  fail - paths greater than the maximum cause a build exception\n     * <li>  warn - paths greater than the maximum cause a warning and GNU is used\n     * <li>  gnu - GNU extensions are used for any paths greater than the maximum.\n     * <li>  omit - paths greater than the maximum are omitted from the archive\n     * </ul>\n     */\n    public void setLongfile(TarLongFileMode mode) {\n        this.longFileMode = mode;\n    }\n\n    /**\n     * Set compression method.\n     * Allowable values are\n     * <ul>\n     * <li>  none - no compression\n     * <li>  gzip - Gzip compression\n     * <li>  bzip2 - Bzip2 compression\n     * </ul>\n     */\n    public void setCompression(TarCompressionMethod mode) {\n        this.compression = mode;\n    }\n\n    /**\n     * do the business\n     */\n    public void execute() throws BuildException {\n        if (tarFile == null) {\n            throw new BuildException(\"tarfile attribute must be set!\",\n                                     getLocation());\n        }\n\n        if (tarFile.exists() && tarFile.isDirectory()) {\n            throw new BuildException(\"tarfile is a directory!\",\n                                     getLocation());\n        }\n\n        if (tarFile.exists() && !tarFile.canWrite()) {\n            throw new BuildException(\"Can not write to the specified tarfile!\",\n                                     getLocation());\n        }\n\n        Vector savedFileSets = (Vector) filesets.clone();\n        try {\n            if (baseDir != null) {\n                if (!baseDir.exists()) {\n                    throw new BuildException(\"basedir does not exist!\",\n                                             getLocation());\n                }\n\n                // add the main fileset to the list of filesets to process.\n                TarFileSet mainFileSet = new TarFileSet(fileset);\n                mainFileSet.setDir(baseDir);\n                filesets.addElement(mainFileSet);\n            }\n\n            if (filesets.size() == 0) {\n                throw new BuildException(\"You must supply either a basedir \"\n                                         + \"attribute or some nested filesets.\",\n                                         getLocation());\n            }\n\n            // check if tar is out of date with respect to each\n            // fileset\n            boolean upToDate = true;\n            for (Enumeration e = filesets.elements(); e.hasMoreElements();) {\n                TarFileSet fs = (TarFileSet) e.nextElement();\n                String[] files = fs.getFiles(getProject());\n\n                if (!archiveIsUpToDate(files, fs.getDir(getProject()))) {\n                    upToDate = false;\n                }\n\n                for (int i = 0; i < files.length; ++i) {\n                    if (tarFile.equals(new File(fs.getDir(getProject()),\n                                                files[i]))) {\n                        throw new BuildException(\"A tar file cannot include \"\n                                                 + \"itself\", getLocation());\n                    }\n                }\n            }\n\n            if (upToDate) {\n                log(\"Nothing to do: \" + tarFile.getAbsolutePath()\n                    + \" is up to date.\", Project.MSG_INFO);\n                return;\n            }\n\n            log(\"Building tar: \" + tarFile.getAbsolutePath(), Project.MSG_INFO);\n\n            TarOutputStream tOut = null;\n            try {\n                tOut = new TarOutputStream(\n                    compression.compress(\n                        new BufferedOutputStream(\n                            new FileOutputStream(tarFile))));\n                tOut.setDebug(true);\n                if (longFileMode.isTruncateMode()) {\n                    tOut.setLongFileMode(TarOutputStream.LONGFILE_TRUNCATE);\n                } else if (longFileMode.isFailMode()\n                            || longFileMode.isOmitMode()) {\n                    tOut.setLongFileMode(TarOutputStream.LONGFILE_ERROR);\n                } else {\n                    // warn or GNU\n                    tOut.setLongFileMode(TarOutputStream.LONGFILE_GNU);\n                }\n\n                longWarningGiven = false;\n                for (Enumeration e = filesets.elements();\n                     e.hasMoreElements();) {\n                    TarFileSet fs = (TarFileSet) e.nextElement();\n                    String[] files = fs.getFiles(getProject());\n                    if (files.length > 1 && fs.getFullpath().length() > 0) {\n                        throw new BuildException(\"fullpath attribute may only \"\n                                                 + \"be specified for \"\n                                                 + \"filesets that specify a \"\n                                                 + \"single file.\");\n                    }\n                    for (int i = 0; i < files.length; i++) {\n                        File f = new File(fs.getDir(getProject()), files[i]);\n                        String name = files[i].replace(File.separatorChar, '/');\n                        tarFile(f, tOut, name, fs);\n                    }\n                }\n            } catch (IOException ioe) {\n                String msg = \"Problem creating TAR: \" + ioe.getMessage();\n                throw new BuildException(msg, ioe, getLocation());\n            } finally {\n                if (tOut != null) {\n                    try {\n                        // close up\n                        tOut.close();\n                    } catch (IOException e) {\n                        // ignore\n                    }\n                }\n            }\n        } finally {\n            filesets = savedFileSets;\n        }\n    }\n\n    /**\n     * tar a file\n     */\n    protected void tarFile(File file, TarOutputStream tOut, String vPath,\n                           TarFileSet tarFileSet)\n        throws IOException {\n        FileInputStream fIn = null;\n\n        String fullpath = tarFileSet.getFullpath();\n        if (fullpath.length() > 0) {\n            vPath = fullpath;\n        } else {\n            // don't add \"\" to the archive\n            if (vPath.length() <= 0) {\n                return;\n            }\n\n            if (file.isDirectory() && !vPath.endsWith(\"/\")) {\n                vPath += \"/\";\n            }\n\n            String prefix = tarFileSet.getPrefix();\n            // '/' is appended for compatibility with the zip task.\n            if (prefix.length() > 0 && !prefix.endsWith(\"/\")) {\n                prefix = prefix + \"/\";\n            }\n            vPath = prefix + vPath;\n        }\n\n        if (vPath.startsWith(\"/\") && !tarFileSet.getPreserveLeadingSlashes()) {\n            int l = vPath.length();\n            if (l <= 1) {\n                // we would end up adding \"\" to the archive\n                return;\n            }\n            vPath = vPath.substring(1, l);\n        }\n\n        try {\n            if (vPath.length() >= TarConstants.NAMELEN) {\n            \tif (longFileMode.isSunMode() \n            \t     && getFileName(vPath).length() < TarConstants.NAMELEN\n            \t     && vPath.length() < SUN_MAXLEN) {\n                    log(\"Sun Solaris Taring: \" + vPath + \"  length=\" +\nvPath.length(), Project.MSG_INFO);\n            \t     \t\n            \t} else if (longFileMode.isOmitMode()) {\n                    log(\"Omitting: \" + vPath, Project.MSG_INFO);\n                    return;\n                } else if (longFileMode.isWarnMode()) {\n                    log(\"Entry: \" + vPath + \" longer than \"\n                        + TarConstants.NAMELEN + \" characters.\",\n                        Project.MSG_WARN);\n                    if (!longWarningGiven) {\n                        log(\"Resulting tar file can only be processed \"\n                            + \"successfully by GNU compatible tar commands\",\n                            Project.MSG_WARN);\n                        longWarningGiven = true;\n                    }\n                } else if (longFileMode.isFailMode()) {\n                    throw new BuildException(\"Entry: \" + vPath\n                        + \" longer than \" + TarConstants.NAMELEN\n                        + \"characters.\", getLocation());\n                }\n            }\n\n            TarEntry te = new TarEntry(vPath);\n            if (longFileMode.isSunMode() && vPath.length() >\nTarConstants.NAMELEN ) { //jyc\n            \tte.setName( getFileName(vPath) );\n            \tte.setPrefix( getDirectoryName(vPath) );\n            }\n            te.setModTime(file.lastModified());\n            if (!file.isDirectory()) {\n                te.setSize(file.length());\n                te.setMode(tarFileSet.getMode());\n            } else {\n                te.setMode(tarFileSet.getDirMode());\n            }\n            te.setUserName(tarFileSet.getUserName());\n            te.setGroupName(tarFileSet.getGroup());\n\n            tOut.putNextEntry(te);\n\n            if (!file.isDirectory()) {\n                fIn = new FileInputStream(file);\n\n                byte[] buffer = new byte[8 * 1024];\n                int count = 0;\n                do {\n                    tOut.write(buffer, 0, count);\n                    count = fIn.read(buffer, 0, buffer.length);\n                } while (count != -1);\n            }\n\n            tOut.closeEntry();\n        } finally {\n            if (fIn != null) {\n                fIn.close();\n            }\n        }\n    }\n\n    /**\n     * @deprecated use the two-arg version instead.\n     */\n    protected boolean archiveIsUpToDate(String[] files) {\n        return archiveIsUpToDate(files, baseDir);\n    }\n\n    /**\n     * @since Ant 1.5.2\n     */\n    protected boolean archiveIsUpToDate(String[] files, File dir) {\n        SourceFileScanner sfs = new SourceFileScanner(this);\n        MergingMapper mm = new MergingMapper();\n        mm.setTo(tarFile.getAbsolutePath());\n        return sfs.restrict(files, dir, null, mm).length == 0;\n    }\n\n    /**\n     * This is a FileSet with the option to specify permissions\n     */\n    public static class TarFileSet extends FileSet {\n        private String[] files = null;\n\n        private int fileMode = UnixStat.FILE_FLAG | UnixStat.DEFAULT_FILE_PERM;\n        private int dirMode = UnixStat.DIR_FLAG | UnixStat.DEFAULT_DIR_PERM;\n\n        private String userName = \"\";\n        private String groupName = \"\";\n        private String prefix = \"\";\n        private String fullpath = \"\";\n        private boolean preserveLeadingSlashes = false;\n\n        public TarFileSet(FileSet fileset) {\n            super(fileset);\n        }\n\n        public TarFileSet() {\n            super();\n        }\n\n        /**\n         *  Get a list of files and directories specified in the fileset.\n         *  @return a list of file and directory names, relative to\n         *    the baseDir for the project.\n         */\n        public String[] getFiles(Project p) {\n            if (files == null) {\n                DirectoryScanner ds = getDirectoryScanner(p);\n                String[] directories = ds.getIncludedDirectories();\n                String[] filesPerSe = ds.getIncludedFiles();\n                files = new String [directories.length + filesPerSe.length];\n                System.arraycopy(directories, 0, files, 0, directories.length);\n                System.arraycopy(filesPerSe, 0, files, directories.length,\n                        filesPerSe.length);\n            }\n\n            return files;\n        }\n\n        /**\n         * A 3 digit octal string, specify the user, group and\n         * other modes in the standard Unix fashion;\n         * optional, default=0644\n         */\n        public void setMode(String octalString) {\n            this.fileMode =\n                UnixStat.FILE_FLAG | Integer.parseInt(octalString, 8);\n        }\n\n        public int getMode() {\n            return fileMode;\n        }\n\n        /**\n         * A 3 digit octal string, specify the user, group and\n         * other modes in the standard Unix fashion;\n         * optional, default=0755\n         *\n         * @since Ant 1.6\n         */\n        public void setDirMode(String octalString) {\n            this.dirMode =\n                UnixStat.DIR_FLAG | Integer.parseInt(octalString, 8);\n        }\n\n        /**\n         * @since Ant 1.6\n         */\n        public int getDirMode() {\n            return dirMode;\n        }\n\n        /**\n         * The username for the tar entry\n         * This is not the same as the UID, which is\n         * not currently set by the task.\n         */\n        public void setUserName(String userName) {\n            this.userName = userName;\n        }\n\n        public String getUserName() {\n            return userName;\n        }\n\n        /**\n         * The groupname for the tar entry; optional, default=\"\"\n         * This is not the same as the GID, which is\n         * not currently set by the task.\n         */\n        public void setGroup(String groupName) {\n            this.groupName = groupName;\n        }\n\n        public String getGroup() {\n            return groupName;\n        }\n\n        /**\n         * If the prefix attribute is set, all files in the fileset\n         * are prefixed with that path in the archive.\n         * optional.\n         */\n        public void setPrefix(String prefix) {\n            this.prefix = prefix;\n        }\n\n        public String getPrefix() {\n            return prefix;\n        }\n\n        /**\n         * If the fullpath attribute is set, the file in the fileset\n         * is written with that path in the archive. The prefix attribute,\n         * if specified, is ignored. It is an error to have more than one file\nspecified in\n         * such a fileset.\n         */\n        public void setFullpath(String fullpath) {\n            this.fullpath = fullpath;\n        }\n\n        public String getFullpath() {\n            return fullpath;\n        }\n\n        /**\n         * Flag to indicates whether leading `/'s should\n         * be preserved in the file names.\n         * Optional, default is <code>false</code>.\n         */\n        public void setPreserveLeadingSlashes(boolean b) {\n            this.preserveLeadingSlashes = b;\n        }\n\n        public boolean getPreserveLeadingSlashes() {\n            return preserveLeadingSlashes;\n        }\n    }\n\n    /**\n     * Set of options for long file handling in the task.\n     *\n     * @author Magesh Umasankar\n     */\n    public static class TarLongFileMode extends EnumeratedAttribute {\n\n        // permissible values for longfile attribute\n        public static final String WARN = \"warn\";\n        public static final String FAIL = \"fail\";\n        public static final String TRUNCATE = \"truncate\";\n        public static final String GNU = \"gnu\";\n        public static final String OMIT = \"omit\";\n        public static final String SUN = \"sun\";\n\n        private final String[] validModes = {WARN, FAIL, TRUNCATE, GNU, OMIT, SUN};\n\n        public TarLongFileMode() {\n            super();\n            setValue(WARN);\n        }\n\n        public String[] getValues() {\n            return validModes;\n        }\n\n        public boolean isTruncateMode() {\n            return TRUNCATE.equalsIgnoreCase(getValue());\n        }\n\n        public boolean isWarnMode() {\n            return WARN.equalsIgnoreCase(getValue());\n        }\n\n        public boolean isGnuMode() {\n            return GNU.equalsIgnoreCase(getValue());\n        }\n\n        public boolean isFailMode() {\n            return FAIL.equalsIgnoreCase(getValue());\n        }\n\n        public boolean isOmitMode() {\n            return OMIT.equalsIgnoreCase(getValue());\n        }\n        public boolean isSunMode() {\n            return SUN.equalsIgnoreCase(getValue());\n        }\n    }\n\n    /**\n     * Valid Modes for Compression attribute to Tar Task\n     *\n     */\n    public static final class TarCompressionMethod extends EnumeratedAttribute {\n\n        // permissible values for compression attribute\n        /**\n         *    No compression\n         */\n        private static final String NONE = \"none\";\n        /**\n         *    GZIP compression\n         */\n        private static final String GZIP = \"gzip\";\n        /**\n         *    BZIP2 compression\n         */\n        private static final String BZIP2 = \"bzip2\";\n\n\n        /**\n         * Default constructor\n         */\n        public TarCompressionMethod() {\n            super();\n            setValue(NONE);\n        }\n\n        /**\n         *  Get valid enumeration values.\n         *  @return valid enumeration values\n         */\n        public String[] getValues() {\n            return new String[] {NONE, GZIP, BZIP2 };\n        }\n\n        /**\n         *  This method wraps the output stream with the\n         *     corresponding compression method\n         *\n         *  @param ostream output stream\n         *  @return output stream with on-the-fly compression\n         *  @exception IOException thrown if file is not writable\n         */\n        private OutputStream compress(final OutputStream ostream)\n            throws IOException {\n            final String value = getValue();\n            if (GZIP.equals(value)) {\n                return new GZIPOutputStream(ostream);\n            } else {\n                if (BZIP2.equals(value)) {\n                    ostream.write('B');\n                    ostream.write('Z');\n                    return new CBZip2OutputStream(ostream);\n                }\n            }\n            return ostream;\n        }\n    }\n    public String getFileName(String name) {\n    \tint start = name.lastIndexOf('/');\n    \treturn name.substring( start + 1);\n    }\n    \n    public String getDirectoryName(String name) {\n    \tint start = name.lastIndexOf('/');\n    \treturn name.substring( 0, start);\n    }\n}\n\n\n\n/*\n * The Apache Software License, Version 1.1\n *\n * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * 3. The end-user documentation included with the redistribution, if\n *    any, must include the following acknowlegement:\n *       \"This product includes software developed by the\n *        Apache Software Foundation (http://www.apache.org/).\"\n *    Alternately, this acknowlegement may appear in the software itself,\n *    if and wherever such third-party acknowlegements normally appear.\n *\n * 4. The names \"Ant\" and \"Apache Software\n *    Foundation\" must not be used to endorse or promote products derived\n *    from this software without prior written permission. For written\n *    permission, please contact apache@apache.org.\n *\n * 5. Products derived from this software may not be called \"Apache\"\n *    nor may \"Apache\" appear in their names without prior written\n *    permission of the Apache Group.\n *\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n * ====================================================================\n *\n * This software consists of voluntary contributions made by many\n * individuals on behalf of the Apache Software Foundation.  For more\n * information on the Apache Software Foundation, please see\n * <http://www.apache.org/>.\n */\n\n/*\n * This package is based on the work done by Timothy Gerard Endres\n * (time@ice.com) to whom the Ant project is very grateful for his great code.\n */\n\npackage org.apache.tools.tar;\n\nimport java.io.File;\nimport java.util.Date;\nimport java.util.Locale;\n\n/**\n * This class represents an entry in a Tar archive. It consists\n * of the entry's header, as well as the entry's File. Entries\n * can be instantiated in one of three ways, depending on how\n * they are to be used.\n * <p>\n * TarEntries that are created from the header bytes read from\n * an archive are instantiated with the TarEntry( byte[] )\n * constructor. These entries will be used when extracting from\n * or listing the contents of an archive. These entries have their\n * header filled in using the header bytes. They also set the File\n * to null, since they reference an archive entry not a file.\n * <p>\n * TarEntries that are created from Files that are to be written\n * into an archive are instantiated with the TarEntry( File )\n * constructor. These entries have their header filled in using\n * the File's information. They also keep a reference to the File\n * for convenience when writing entries.\n * <p>\n * Finally, TarEntries can be constructed from nothing but a name.\n * This allows the programmer to construct the entry by hand, for\n * instance when only an InputStream is available for writing to\n * the archive, and the header information is constructed from\n * other information. In this case the header fields are set to\n * defaults and the File is set to null.\n *\n * <p>\n * The C structure for a Tar Entry's header is:\n * <pre>\n * struct header {\n * char name[NAMSIZ];\n * char mode[8];\n * char uid[8];\n * char gid[8];\n * char size[12];\n * char mtime[12];\n * char chksum[8];\n * char linkflag;\n * char linkname[NAMSIZ];\n * char magic[8];\n * char uname[TUNMLEN];\n * char gname[TGNMLEN];\n * char devmajor[8];\n * char devminor[8];\n * } header;\n * </pre>\n *\n * @author Timothy Gerard Endres <a href=\"mailto:time@ice.com\">time@ice.com</a>\n * @author Stefano Mazzocchi <a\nhref=\"mailto:stefano@apache.org\">stefano@apache.org</a>\n */\n\npublic class TarEntry implements TarConstants {\n    /** The entry's name. */\n    private StringBuffer name;\n\n    /** The entry's permission mode. */\n    private int mode;\n\n    /** The entry's user id. */\n    private int userId;\n\n    /** The entry's group id. */\n    private int groupId;\n\n    /** The entry's size. */\n    private long size;\n\n    /** The entry's modification time. */\n    private long modTime;\n\n    /** The entry's checksum. */\n    private int checkSum;\n\n    /** The entry's link flag. */\n    private byte linkFlag;\n\n    /** The entry's link name. */\n    private StringBuffer linkName;\n\n    /** The entry's magic tag. */\n    private StringBuffer magic;\n\n    /** The entry's user name. */\n    private StringBuffer userName;\n\n    /** The entry's group name. */\n    private StringBuffer groupName;\n\n    /** The entry's major device number. */\n    private int devMajor;\n\n    /** The entry's minor device number. */\n    private int devMinor;\n\n    /** The entry's directory prefix. */\n    private StringBuffer prefix;\n\n    /** The entry's file reference */\n    private File file;\n\n    /** Maximum length of a user's name in the tar file */\n    public static final int MAX_NAMELEN = 31;\n\n    /** Default permissions bits for directories */\n    public static final int DEFAULT_DIR_MODE = 040755;\n\n    /** Default permissions bits for files */\n    public static final int DEFAULT_FILE_MODE = 0100644;\n\n    /** Convert millis to seconds */\n    public static final int MILLIS_PER_SECOND = 1000;\n\n    /** Sun Solaris Tar Max Full Path Length */\n    //public static final int SUN_MAXLEN = 255;\n\n    /**\n     * Construct an empty entry and prepares the header values.\n     */\n    private TarEntry () {\n        this.magic = new StringBuffer(TMAGIC);\n        this.name = new StringBuffer();\n        this.linkName = new StringBuffer();\n\n        String user = System.getProperty(\"user.name\", \"\");\n\n        if (user.length() > MAX_NAMELEN) {\n            user = user.substring(0, MAX_NAMELEN);\n        }\n\n        this.userId = 0;\n        this.groupId = 0;\n        this.userName = new StringBuffer(user);\n        this.groupName = new StringBuffer(\"\");\n        this.prefix = new StringBuffer(\"\");//jyc\n        this.file = null;\n    }\n\n    /**\n     * Construct an entry with only a name. This allows the programmer\n     * to construct the entry's header \"by hand\". File is set to null.\n     *\n     * @param name the entry name\n     */\n    public TarEntry(String name) {\n        this();\n\n        boolean isDir = name.endsWith(\"/\");\n\n        this.devMajor = 0;\n        this.devMinor = 0;\n        this.name = new StringBuffer(name);\n        this.mode = isDir ? DEFAULT_DIR_MODE : DEFAULT_FILE_MODE;\n        this.linkFlag = isDir ? LF_DIR : LF_NORMAL;\n        this.userId = 0;\n        this.groupId = 0;\n        this.size = 0;\n        this.checkSum = 0;\n        this.modTime = (new Date()).getTime() / MILLIS_PER_SECOND;\n        this.linkName = new StringBuffer(\"\");\n        this.userName = new StringBuffer(\"\");\n        this.groupName = new StringBuffer(\"\");\n        this.devMajor = 0;\n        this.devMinor = 0;\n        this.prefix = new StringBuffer(\"\");//jyc\n\n    }\n\n    /**\n     * Construct an entry with a name an a link flag.\n     *\n     * @param name the entry name\n     * @param linkFlag the entry link flag.\n     */\n    public TarEntry(String name, byte linkFlag) {\n        this(name);\n        this.linkFlag = linkFlag;\n    }\n\n    /**\n     * Construct an entry for a file. File is set to file, and the\n     * header is constructed from information from the file.\n     *\n     * @param file The file that the entry represents.\n     */\n    public TarEntry(File file) {\n        this();\n\n        this.file = file;\n\n        String name = file.getPath();\n        String osname = System.getProperty(\"os.name\").toLowerCase(Locale.US);\n\n        if (osname != null) {\n\n            // Strip off drive letters!\n            // REVIEW Would a better check be \"(File.separator == '\\')\"?\n\n            if (osname.startsWith(\"windows\")) {\n                if (name.length() > 2) {\n                    char ch1 = name.charAt(0);\n                    char ch2 = name.charAt(1);\n\n                    if (ch2 == ':'\n                            && ((ch1 >= 'a' && ch1 <= 'z')\n                                || (ch1 >= 'A' && ch1 <= 'Z'))) {\n                        name = name.substring(2);\n                    }\n                }\n            } else if (osname.indexOf(\"netware\") > -1) {\n                int colon = name.indexOf(':');\n                if (colon != -1) {\n                    name = name.substring(colon + 1);\n                }\n            }\n        }\n\n        name = name.replace(File.separatorChar, '/');\n\n        // No absolute pathnames\n        // Windows (and Posix?) paths can start with \"\\\\NetworkDrive\\\",\n        // so we loop on starting /'s.\n        while (name.startsWith(\"/\")) {\n            name = name.substring(1);\n        }\n\n        this.linkName = new StringBuffer(\"\");\n        this.name = new StringBuffer(name);\n\n        if (file.isDirectory()) {\n            this.mode = DEFAULT_DIR_MODE;\n            this.linkFlag = LF_DIR;\n\n            if (this.name.charAt(this.name.length() - 1) != '/') {\n                this.name.append(\"/\");\n            }\n        } else {\n            this.mode = DEFAULT_FILE_MODE;\n            this.linkFlag = LF_NORMAL;\n        }\n\n        this.size = file.length();\n        this.modTime = file.lastModified() / MILLIS_PER_SECOND;\n        this.checkSum = 0;\n        this.devMajor = 0;\n        this.devMinor = 0;\n    }\n\n    /**\n     * Construct an entry from an archive's header bytes. File is set\n     * to null.\n     *\n     * @param headerBuf The header bytes from a tar archive entry.\n     */\n    public TarEntry(byte[] headerBuf) {\n        this();\n        this.parseTarHeader(headerBuf);\n    }\n\n    /**\n     * Determine if the two entries are equal. Equality is determined\n     * by the header names being equal.\n     *\n     * @param it Entry to be checked for equality.\n     * @return True if the entries are equal.\n     */\n    public boolean equals(TarEntry it) {\n        return this.getName().equals(it.getName());\n    }\n\n    /**\n     * Determine if the two entries are equal. Equality is determined\n     * by the header names being equal.\n     *\n     * @param it Entry to be checked for equality.\n     * @return True if the entries are equal.\n     */\n    public boolean equals(Object it) {\n        if (it == null || getClass() != it.getClass()) {\n            return false;\n        }\n        return equals((TarEntry) it);\n    }\n\n    /**\n     * Hashcodes are based on entry names.\n     *\n     * @return the entry hashcode\n     */\n    public int hashCode() {\n        return getName().hashCode();\n    }\n\n    /**\n     * Determine if the given entry is a descendant of this entry.\n     * Descendancy is determined by the name of the descendant\n     * starting with this entry's name.\n     *\n     * @param desc Entry to be checked as a descendent of this.\n     * @return True if entry is a descendant of this.\n     */\n    public boolean isDescendent(TarEntry desc) {\n        return desc.getName().startsWith(this.getName());\n    }\n\n    /**\n     * Get this entry's prefix.\n     *\n     * @return This entry's prefix.\n     */\n    public String getPrefix() {\n        return this.prefix.toString();\n    }\n\n    /**\n     * Set this entry's prefix.\n     *\n     * @param name This entry's new prefix.\n     */\n    public void setPrefix(String prefix) {\n        this.prefix = new StringBuffer(prefix);\n    }\n\n    /**\n     * Get this entry's name.\n     *\n     * @return This entry's name.\n     */\n    public String getName() {\n        return this.name.toString();\n    }\n\n    /**\n     * Set this entry's name.\n     *\n     * @param name This entry's new name.\n     */\n    public void setName(String name) {\n        this.name = new StringBuffer(name);\n    }\n\n    /**\n     * Set the mode for this entry\n     *\n     * @param mode the mode for this entry\n     */\n    public void setMode(int mode) {\n        this.mode = mode;\n    }\n\n    /**\n     * Get this entry's link name.\n     *\n     * @return This entry's link name.\n     */\n    public String getLinkName() {\n        return this.linkName.toString();\n    }\n\n    /**\n     * Get this entry's user id.\n     *\n     * @return This entry's user id.\n     */\n    public int getUserId() {\n        return this.userId;\n    }\n\n    /**\n     * Set this entry's user id.\n     *\n     * @param userId This entry's new user id.\n     */\n    public void setUserId(int userId) {\n        this.userId = userId;\n    }\n\n    /**\n     * Get this entry's group id.\n     *\n     * @return This entry's group id.\n     */\n    public int getGroupId() {\n        return this.groupId;\n    }\n\n    /**\n     * Set this entry's group id.\n     *\n     * @param groupId This entry's new group id.\n     */\n    public void setGroupId(int groupId) {\n        this.groupId = groupId;\n    }\n\n    /**\n     * Get this entry's user name.\n     *\n     * @return This entry's user name.\n     */\n    public String getUserName() {\n        return this.userName.toString();\n    }\n\n    /**\n     * Set this entry's user name.\n     *\n     * @param userName This entry's new user name.\n     */\n    public void setUserName(String userName) {\n        this.userName = new StringBuffer(userName);\n    }\n\n    /**\n     * Get this entry's group name.\n     *\n     * @return This entry's group name.\n     */\n    public String getGroupName() {\n        return this.groupName.toString();\n    }\n\n    /**\n     * Set this entry's group name.\n     *\n     * @param groupName This entry's new group name.\n     */\n    public void setGroupName(String groupName) {\n        this.groupName = new StringBuffer(groupName);\n    }\n\n    /**\n     * Convenience method to set this entry's group and user ids.\n     *\n     * @param userId This entry's new user id.\n     * @param groupId This entry's new group id.\n     */\n    public void setIds(int userId, int groupId) {\n        this.setUserId(userId);\n        this.setGroupId(groupId);\n    }\n\n    /**\n     * Convenience method to set this entry's group and user names.\n     *\n     * @param userName This entry's new user name.\n     * @param groupName This entry's new group name.\n     */\n    public void setNames(String userName, String groupName) {\n        this.setUserName(userName);\n        this.setGroupName(groupName);\n    }\n\n    /**\n     * Set this entry's modification time. The parameter passed\n     * to this method is in \"Java time\".\n     *\n     * @param time This entry's new modification time.\n     */\n    public void setModTime(long time) {\n        this.modTime = time / MILLIS_PER_SECOND;\n    }\n\n    /**\n     * Set this entry's modification time.\n     *\n     * @param time This entry's new modification time.\n     */\n    public void setModTime(Date time) {\n        this.modTime = time.getTime() / MILLIS_PER_SECOND;\n    }\n\n    /**\n     * Set this entry's modification time.\n     *\n     * @return time This entry's new modification time.\n     */\n    public Date getModTime() {\n        return new Date(this.modTime * MILLIS_PER_SECOND);\n    }\n\n    /**\n     * Get this entry's file.\n     *\n     * @return This entry's file.\n     */\n    public File getFile() {\n        return this.file;\n    }\n\n    /**\n     * Get this entry's mode.\n     *\n     * @return This entry's mode.\n     */\n    public int getMode() {\n        return this.mode;\n    }\n\n    /**\n     * Get this entry's file size.\n     *\n     * @return This entry's file size.\n     */\n    public long getSize() {\n        return this.size;\n    }\n\n    /**\n     * Set this entry's file size.\n     *\n     * @param size This entry's new file size.\n     */\n    public void setSize(long size) {\n        this.size = size;\n    }\n\n\n    /**\n     * Indicate if this entry is a GNU long name block\n     *\n     * @return true if this is a long name extension provided by GNU tar\n     */\n    public boolean isGNULongNameEntry() {\n        return linkFlag == LF_GNUTYPE_LONGNAME\n                           && name.toString().equals(GNU_LONGLINK);\n    }\n\n    /**\n     * Return whether or not this entry represents a directory.\n     *\n     * @return True if this entry is a directory.\n     */\n    public boolean isDirectory() {\n        if (this.file != null) {\n            return this.file.isDirectory();\n        }\n\n        if (this.linkFlag == LF_DIR) {\n            return true;\n        }\n\n        if (this.getName().endsWith(\"/\")) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * If this entry represents a file, and the file is a directory, return\n     * an array of TarEntries for this entry's children.\n     *\n     * @return An array of TarEntry's for this entry's children.\n     */\n    public TarEntry[] getDirectoryEntries() {\n        if (this.file == null || !this.file.isDirectory()) {\n            return new TarEntry[0];\n        }\n\n        String[]   list = this.file.list();\n        TarEntry[] result = new TarEntry[list.length];\n\n        for (int i = 0; i < list.length; ++i) {\n            result[i] = new TarEntry(new File(this.file, list[i]));\n        }\n\n        return result;\n    }\n\n    /**\n     * Write an entry's header information to a header buffer.\n     *\n     * @param outbuf The tar entry header buffer to fill in.\n     */\n    public void writeEntryHeader(byte[] outbuf) {\n        int offset = 0;\n\n        offset = TarUtils.getNameBytes(this.name, outbuf, offset, NAMELEN);\n        offset = TarUtils.getOctalBytes(this.mode, outbuf, offset, MODELEN);\n        offset = TarUtils.getOctalBytes(this.userId, outbuf, offset, UIDLEN);\n        offset = TarUtils.getOctalBytes(this.groupId, outbuf, offset, GIDLEN);\n        offset = TarUtils.getLongOctalBytes(this.size, outbuf, offset, SIZELEN);\n        offset = TarUtils.getLongOctalBytes(this.modTime, outbuf, offset,\nMODTIMELEN);\n\n        int csOffset = offset;\n\n        for (int c = 0; c < CHKSUMLEN; ++c) {\n            outbuf[offset++] = (byte) ' ';\n        }\n\n        outbuf[offset++] = this.linkFlag;\n        offset = TarUtils.getNameBytes(this.linkName, outbuf, offset, NAMELEN);\n        offset = TarUtils.getNameBytes(this.magic, outbuf, offset, MAGICLEN);\n        offset = TarUtils.getNameBytes(this.userName, outbuf, offset, UNAMELEN);\n        offset = TarUtils.getNameBytes(this.groupName, outbuf, offset, GNAMELEN);\n        offset = TarUtils.getOctalBytes(this.devMajor, outbuf, offset, DEVLEN);\n        offset = TarUtils.getOctalBytes(this.devMinor, outbuf, offset, DEVLEN);\n        offset = TarUtils.getNameBytes(this.prefix, outbuf, offset,\noutbuf.length - offset);//jyc\n\n        while (offset < outbuf.length) {\n            outbuf[offset++] = 0;\n        }\n\n        long checkSum = TarUtils.computeCheckSum(outbuf);\n\n        TarUtils.getCheckSumOctalBytes(checkSum, outbuf, csOffset, CHKSUMLEN);\n    }\n\n    /**\n     * Parse an entry's header information from a header buffer.\n     *\n     * @param header The tar entry header buffer to get information from.\n     */\n    public void parseTarHeader(byte[] header) {\n        int offset = 0;\n\n        this.name = TarUtils.parseName(header, offset, NAMELEN);\n        offset += NAMELEN;\n        this.mode = (int) TarUtils.parseOctal(header, offset, MODELEN);\n        offset += MODELEN;\n        this.userId = (int) TarUtils.parseOctal(header, offset, UIDLEN);\n        offset += UIDLEN;\n        this.groupId = (int) TarUtils.parseOctal(header, offset, GIDLEN);\n        offset += GIDLEN;\n        this.size = TarUtils.parseOctal(header, offset, SIZELEN);\n        offset += SIZELEN;\n        this.modTime = TarUtils.parseOctal(header, offset, MODTIMELEN);\n        offset += MODTIMELEN;\n        this.checkSum = (int) TarUtils.parseOctal(header, offset, CHKSUMLEN);\n        offset += CHKSUMLEN;\n        this.linkFlag = header[offset++];\n        this.linkName = TarUtils.parseName(header, offset, NAMELEN);\n        offset += NAMELEN;\n        this.magic = TarUtils.parseName(header, offset, MAGICLEN);\n        offset += MAGICLEN;\n        this.userName = TarUtils.parseName(header, offset, UNAMELEN);\n        offset += UNAMELEN;\n        this.groupName = TarUtils.parseName(header, offset, GNAMELEN);\n        offset += GNAMELEN;\n        this.devMajor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n        offset += DEVLEN;\n        this.devMinor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n        offset += DEVLEN;\n        this.prefix = TarUtils.parseName(header, offset, header.length -\noffset);//jyc\n    }\n    \n}\n\n\n\n/*\n * The Apache Software License, Version 1.1\n *\n * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * 3. The end-user documentation included with the redistribution, if\n *    any, must include the following acknowlegement:\n *       \"This product includes software developed by the\n *        Apache Software Foundation (http://www.apache.org/).\"\n *    Alternately, this acknowlegement may appear in the software itself,\n *    if and wherever such third-party acknowlegements normally appear.\n *\n * 4. The names \"Ant\" and \"Apache Software\n *    Foundation\" must not be used to endorse or promote products derived\n *    from this software without prior written permission. For written\n *    permission, please contact apache@apache.org.\n *\n * 5. Products derived from this software may not be called \"Apache\"\n *    nor may \"Apache\" appear in their names without prior written\n *    permission of the Apache Group.\n *\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n * ====================================================================\n *\n * This software consists of voluntary contributions made by many\n * individuals on behalf of the Apache Software Foundation.  For more\n * information on the Apache Software Foundation, please see\n * <http://www.apache.org/>.\n */\n\n/*\n * This package is based on the work done by Timothy Gerard Endres\n * (time@ice.com) to whom the Ant project is very grateful for his great code.\n */\n\npackage org.apache.tools.tar;\n\nimport java.io.FilterOutputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\n\n/**\n * The TarOutputStream writes a UNIX tar archive as an OutputStream.\n * Methods are provided to put entries, and then write their contents\n * by writing to this stream using write().\n *\n * @author Timothy Gerard Endres <a href=\"mailto:time@ice.com\">time@ice.com</a>\n */\npublic class TarOutputStream extends FilterOutputStream {\n    /** Fail if a long file name is required in the archive. */\n    public static final int LONGFILE_ERROR = 0;\n\n    /** Long paths will be truncated in the archive. */\n    public static final int LONGFILE_TRUNCATE = 1;\n\n    /** GNU tar extensions are used to store long file names in the archive. */\n    public static final int LONGFILE_GNU = 2;\n\n    /** SUN tar extensions are used to store long file names in the archive. */\n    public static final int LONGFILE_SUN = 3;\n\n    protected boolean   debug;\n    protected int       currSize;\n    protected int       currBytes;\n    protected byte[]    oneBuf;\n    protected byte[]    recordBuf;\n    protected int       assemLen;\n    protected byte[]    assemBuf;\n    protected TarBuffer buffer;\n    protected int       longFileMode = LONGFILE_ERROR;\n\n    public TarOutputStream(OutputStream os) {\n        this(os, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n    }\n\n    public TarOutputStream(OutputStream os, int blockSize) {\n        this(os, blockSize, TarBuffer.DEFAULT_RCDSIZE);\n    }\n\n    public TarOutputStream(OutputStream os, int blockSize, int recordSize) {\n        super(os);\n\n        this.buffer = new TarBuffer(os, blockSize, recordSize);\n        this.debug = false;\n        this.assemLen = 0;\n        this.assemBuf = new byte[recordSize];\n        this.recordBuf = new byte[recordSize];\n        this.oneBuf = new byte[1];\n    }\n\n    public void setLongFileMode(int longFileMode) {\n        this.longFileMode = longFileMode;\n    }\n\n\n    /**\n     * Sets the debugging flag.\n     *\n     * @param debugF True to turn on debugging.\n     */\n    public void setDebug(boolean debugF) {\n        this.debug = debugF;\n    }\n\n    /**\n     * Sets the debugging flag in this stream's TarBuffer.\n     *\n     * @param debug True to turn on debugging.\n     */\n    public void setBufferDebug(boolean debug) {\n        this.buffer.setDebug(debug);\n    }\n\n    /**\n     * Ends the TAR archive without closing the underlying OutputStream.\n     * The result is that the EOF record of nulls is written.\n     */\n    public void finish() throws IOException {\n        this.writeEOFRecord();\n    }\n\n    /**\n     * Ends the TAR archive and closes the underlying OutputStream.\n     * This means that finish() is called followed by calling the\n     * TarBuffer's close().\n     */\n    public void close() throws IOException {\n        this.finish();\n        this.buffer.close();\n    }\n\n    /**\n     * Get the record size being used by this stream's TarBuffer.\n     *\n     * @return The TarBuffer record size.\n     */\n    public int getRecordSize() {\n        return this.buffer.getRecordSize();\n    }\n\n    /**\n     * Put an entry on the output stream. This writes the entry's\n     * header record and positions the output stream for writing\n     * the contents of the entry. Once this method is called, the\n     * stream is ready for calls to write() to write the entry's\n     * contents. Once the contents are written, closeEntry()\n     * <B>MUST</B> be called to ensure that all buffered data\n     * is completely written to the output stream.\n     *\n     * @param entry The TarEntry to be written to the archive.\n     */\n    public void putNextEntry(TarEntry entry) throws IOException {\n        if (entry.getName().length() >= TarConstants.NAMELEN) {\n\n\t\t\tif (longFileMode == LONGFILE_SUN) {\n\t\t\t\t//continue process  jyc\n\n            } else if (longFileMode == LONGFILE_GNU) {\n                // create a TarEntry for the LongLink, the contents\n                // of which are the entry's name\n                TarEntry longLinkEntry = new TarEntry(TarConstants.GNU_LONGLINK,\n                                                     \nTarConstants.LF_GNUTYPE_LONGNAME);\n\n                longLinkEntry.setSize(entry.getName().length() + 1);\n                putNextEntry(longLinkEntry);\n                write(entry.getName().getBytes());\n                write(0);\n                closeEntry();\n            } else if (longFileMode != LONGFILE_TRUNCATE) {\n                throw new RuntimeException(\"file name '\" + entry.getName()\n                                             + \"' is too long ( > \"\n                                             + TarConstants.NAMELEN + \" bytes)\");\n            }\n        }\n\n        entry.writeEntryHeader(this.recordBuf);\n        this.buffer.writeRecord(this.recordBuf);\n\n        this.currBytes = 0;\n\n        if (entry.isDirectory()) {\n            this.currSize = 0;\n        } else {\n            this.currSize = (int) entry.getSize();\n        }\n    }\n\n    /**\n     * Close an entry. This method MUST be called for all file\n     * entries that contain data. The reason is that we must\n     * buffer data written to the stream in order to satisfy\n     * the buffer's record based writes. Thus, there may be\n     * data fragments still being assembled that must be written\n     * to the output stream before this entry is closed and the\n     * next entry written.\n     */\n    public void closeEntry() throws IOException {\n        if (this.assemLen > 0) {\n            for (int i = this.assemLen; i < this.assemBuf.length; ++i) {\n                this.assemBuf[i] = 0;\n            }\n\n            this.buffer.writeRecord(this.assemBuf);\n\n            this.currBytes += this.assemLen;\n            this.assemLen = 0;\n        }\n\n        if (this.currBytes < this.currSize) {\n            throw new IOException(\"entry closed at '\" + this.currBytes\n                                  + \"' before the '\" + this.currSize\n                                  + \"' bytes specified in the header were written\");\n        }\n    }\n\n    /**\n     * Writes a byte to the current tar archive entry.\n     *\n     * This method simply calls read( byte[], int, int ).\n     *\n     * @param b The byte written.\n     */\n    public void write(int b) throws IOException {\n        this.oneBuf[0] = (byte) b;\n\n        this.write(this.oneBuf, 0, 1);\n    }\n\n    /**\n     * Writes bytes to the current tar archive entry.\n     *\n     * This method simply calls write( byte[], int, int ).\n     *\n     * @param wBuf The buffer to write to the archive.\n     */\n    public void write(byte[] wBuf) throws IOException {\n        this.write(wBuf, 0, wBuf.length);\n    }\n\n    /**\n     * Writes bytes to the current tar archive entry. This method\n     * is aware of the current entry and will throw an exception if\n     * you attempt to write bytes past the length specified for the\n     * current entry. The method is also (painfully) aware of the\n     * record buffering required by TarBuffer, and manages buffers\n     * that are not a multiple of recordsize in length, including\n     * assembling records from small buffers.\n     *\n     * @param wBuf The buffer to write to the archive.\n     * @param wOffset The offset in the buffer from which to get bytes.\n     * @param numToWrite The number of bytes to write.\n     */\n    public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n        if ((this.currBytes + numToWrite) > this.currSize) {\n            throw new IOException(\"request to write '\" + numToWrite\n                                  + \"' bytes exceeds size in header of '\"\n                                  + this.currSize + \"' bytes\");\n\n            //\n            // We have to deal with assembly!!!\n            // The programmer can be writing little 32 byte chunks for all\n            // we know, and we must assemble complete records for writing.\n            // REVIEW Maybe this should be in TarBuffer? Could that help to\n            // eliminate some of the buffer copying.\n            //\n        }\n\n        if (this.assemLen > 0) {\n            if ((this.assemLen + numToWrite) >= this.recordBuf.length) {\n                int aLen = this.recordBuf.length - this.assemLen;\n\n                System.arraycopy(this.assemBuf, 0, this.recordBuf, 0,\n                                 this.assemLen);\n                System.arraycopy(wBuf, wOffset, this.recordBuf,\n                                 this.assemLen, aLen);\n                this.buffer.writeRecord(this.recordBuf);\n\n                this.currBytes += this.recordBuf.length;\n                wOffset += aLen;\n                numToWrite -= aLen;\n                this.assemLen = 0;\n            } else {\n                System.arraycopy(wBuf, wOffset, this.assemBuf, this.assemLen,\n                                 numToWrite);\n\n                wOffset += numToWrite;\n                this.assemLen += numToWrite;\n                numToWrite -= numToWrite;\n            }\n        }\n\n        //\n        // When we get here we have EITHER:\n        // o An empty \"assemble\" buffer.\n        // o No bytes to write (numToWrite == 0)\n        //\n        while (numToWrite > 0) {\n            if (numToWrite < this.recordBuf.length) {\n                System.arraycopy(wBuf, wOffset, this.assemBuf, this.assemLen,\n                                 numToWrite);\n\n                this.assemLen += numToWrite;\n\n                break;\n            }\n\n            this.buffer.writeRecord(wBuf, wOffset);\n\n            int num = this.recordBuf.length;\n\n            this.currBytes += num;\n            numToWrite -= num;\n            wOffset += num;\n        }\n    }\n\n    /**\n     * Write an EOF (end of archive) record to the tar archive.\n     * An EOF record consists of a record of all zeros.\n     */\n    private void writeEOFRecord() throws IOException {\n        for (int i = 0; i < this.recordBuf.length; ++i) {\n            this.recordBuf[i] = 0;\n        }\n\n        this.buffer.writeRecord(this.recordBuf);\n    }\n}"}, {"count": 1, "tags": [], "bug_id": 25704, "text": "Could we get this contribution as a diff output against Anbt 1.6.0's code please?\n\nIt is very hard to spot the changes this way.", "id": 51482, "time": "2004-01-30T15:51:38Z", "creator": "bodewig@apache.org", "creation_time": "2004-01-30T15:51:38Z", "is_private": false, "attachment_id": null}, {"count": 2, "tags": [], "text": "Created attachment 18765\nSrc which been modified to fix tar task to surport Sun tar. Base on ant version 1.6.5.\n\ninclude java source file:\n\torg\\apache\\tools\\ant\\taskdefs\\Tar.java\n\torg\\apache\\tools\\tar\\TarConstants.java\n\torg\\apache\\tools\\tar\\TarEntry.java\n\torg\\apache\\tools\\tar\\TarOutputStream.java\n\torg\\apache\\tools\\tar\\TarUtils.java\n\n\nI test it on windows 2000 and sun solaris 9, java version is 1.4.2_08, it works\nwell.\nStill exist problem is:\nThis patch cannot surport multi-byte file names well.\nSuch as GB2312 code, it can not surport the file names's \"String\" length over\n50.", "is_private": false, "id": 92694, "creation_time": "2006-08-30T01:10:37Z", "time": "2006-08-30T01:10:37Z", "creator": "wang.liang4@zte.com.cn", "bug_id": 25704, "attachment_id": 18765}, {"count": 3, "tags": [], "bug_id": 25704, "is_private": false, "id": 92695, "attachment_id": 18766, "creator": "wang.liang4@zte.com.cn", "creation_time": "2006-08-30T01:12:02Z", "time": "2006-08-30T01:12:02Z", "text": "Created attachment 18766\nHere is the compare report, left side is the file which been modified.\n\nHere is the compare report, left side is the file which been modified."}, {"count": 4, "attachment_id": null, "creator": "bodewig@apache.org", "text": "An improved version of Ant's tar classes is part of Apache Commons Compress - I've opened a ticket there https://issues.apache.org/jira/browse/COMPRESS-121\n\nOnce implemented it will become available to Ant via the compress antlib.", "id": 141039, "time": "2010-10-26T06:08:21Z", "bug_id": 25704, "creation_time": "2010-10-26T06:08:21Z", "tags": [], "is_private": false}]