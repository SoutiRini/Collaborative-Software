[{"count": 0, "tags": [], "bug_id": 56984, "text": "After I moved from 2.2 to 2.4 start the headaches. The crashes are random and occur very frequently. No hardware problem related, same behavior on an Cloud server. Same behavior with PHP 5.4.32 and 5.6.0. The crash occurs in any PHP script, with no warning/error in the logs.\n\nOS: FreeBSD 10.0-RELEASE-p7 amd64\n\nerror_log:\n[Sun Sep 14 22:15:20.114756 2014] [core:notice] [pid 80717:tid 34410095616] AH00052: child pid 81760 exit signal Segmentation fault (11)\n[Sun Sep 14 22:15:22.180905 2014] [core:notice] [pid 80717:tid 34410095616] AH00052: child pid 81727 exit signal Segmentation fault (11)\n[Sun Sep 14 22:27:14.973207 2014] [core:notice] [pid 80717:tid 34410095616] AH00052: child pid 81807 exit signal Segmentation fault (11)\n\nApache 2.4.10 compile options:\n./configure --prefix=/usr/apache --exec-prefix=/usr --sysconfdir=/etc/apache --enable-modules=none --enable-mods-static=\"authn_core authn_file authz_host authz_groupfile authz_user authz_core auth_basic socache_shmcb so include filter mime log_config env expires headers setenvif version ssl unixd status autoindex suexec cgi negotiation dir actions userdir alias rewrite\"\n\nPHP 5.6.0 compile options:\n./configure --prefix=/usr/php5 --exec-prefix=/usr --with-apxs2=/usr/bin/apxs --with-config-file-path=/etc --with-openssl --with-zlib --with-bz2 --with-curl --enable-ftp --with-gd --with-jpeg-dir --with-png-dir --with-zlib-dir --enable-mbstring --with-mcrypt --with-mssql --with-mysql --with-mysql-sock=/tmp/mysql.sock --with-mysqli=/usr/local/bin/mysql_config --enable-sockets --enable-zip\n\nphp.ini custom configurations:\nexpose_php = Off\nerror_reporting = E_ALL & ~E_NOTICE\ndate.timezone = \"America/Sao_Paulo\"\ndefault_charset = \"\"\n\ngdb output:\nProgram received signal SIGSEGV, Segmentation fault.\n[Switching to Thread 807418000 (LWP 100188/httpd)]\n0x00000008038b6157 in zend_stack_push (stack=0x808a9e4e8, element=0x808a9e4c8, size=<value optimized out>) at zend_stack.c:42\n42              stack->elements[stack->top] = (void *) emalloc(size);\nCurrent language:  auto; currently minimal\n(gdb) bt\n#0  0x00000008038b6157 in zend_stack_push (stack=0x808a9e4e8, element=0x808a9e4c8, size=<value optimized out>) at zend_stack.c:42\n#1  0x000000080387ee63 in compile_file (file_handle=<value optimized out>, type=<value optimized out>, tsrm_ls=0x8089a4900) at zend_language_scanner.l:583\n#2  0x0000000803752abf in phar_compile_file (file_handle=0x7ffffdbed920, type=2, tsrm_ls=0x8089a4900) at phar.c:3411\n#3  0x00000008038b9735 in zend_execute_scripts (type=2, tsrm_ls=0x8089a4900, retval=0x0, file_count=1) at zend.c:1307\n#4  0x000000080394cb8a in php_handler (r=0x80ba1c0a0) at sapi_apache2.c:669\n#5  0x0000000000471fdb in ap_run_handler ()\n#6  0x00000000004728bd in ap_invoke_handler ()\n#7  0x00000000004b8489 in ap_process_async_request ()\n#8  0x00000000004b301e in ap_process_http_async_connection ()\n#9  0x00000000004b2d12 in ap_process_http_connection ()\n#10 0x000000000048326b in ap_run_process_connection ()\n#11 0x000000000053b2df in process_socket ()\n#12 0x0000000000537b29 in worker_thread ()\n#13 0x000000080208c4a4 in pthread_create () from /lib/libthr.so.3\n#14 0x0000000000000000 in ?? ()\n(gdb) bt full\n#0  0x00000008038b6157 in zend_stack_push (stack=0x808a9e4e8, element=0x808a9e4c8, size=<value optimized out>) at zend_stack.c:42\nNo locals.\n#1  0x000000080387ee63 in compile_file (file_handle=<value optimized out>, type=<value optimized out>, tsrm_ls=0x8089a4900) at zend_language_scanner.l:583\n        original_lex_state = {yy_leng = 0, yy_start = 0x0, yy_text = 0x0, yy_cursor = 0x0, yy_marker = 0x0, yy_limit = 0x0, yy_state = 0, state_stack = {top = 0, max = 0, elements = 0x0}, in = 0x0, lineno = 0, filename = 0x0,\n  script_org = 0x0, script_org_size = 0, script_filtered = 0x0, script_filtered_size = 0, input_filter = 0, output_filter = 0, script_encoding = 0x0}\n        retval_znode = {op_type = 1, u = {op = {constant = 1, var = 1, num = 1, hash = 1, opline_num = 1, jmp_addr = 0x1, zv = 0x1, literal = 0x1, ptr = 0x1}, constant = {value = {lval = 1, dval = 4.9406564584124654e-324, str = {\n          val = 0x1 <Error reading address 0x1: Bad address>, len = 22}, ht = 0x1, obj = {handle = 1, handlers = 0x16}}, refcount__gc = 1, type = 1 '\\001', is_ref__gc = 0 '\\0'}, op_array = 0x1}, EA = 51444928}\n        original_active_op_array = (zend_op_array *) 0x0\n        original_in_compilation = 0 '\\0'\n        compiler_result = <value optimized out>\n        retval = <value optimized out>\n#2  0x0000000803752abf in phar_compile_file (file_handle=0x7ffffdbed920, type=2, tsrm_ls=0x8089a4900) at phar.c:3411\n        __bailout = {{_sjb = {34417748607, 140737450531104, 140737450530424, 140737450530720, 140737450531232, 0, 0, 34504067328, 140737450476415, 34389426431, 1280, 34359738368}}}\n        __bailout = {{_sjb = {34417748607, 140737450531104, 140737450530424, 140737450530720, 140737450531232, 0, 0, 34504067328, 140737450476415, 34389426431, 1280, 34359738368}}}\n        __orig_bailout = (sigjmp_buf *) 0x7ffffdbed9a0\n        name = 0x0\n        phar = (phar_archive_data *) 0x50\n        name = 0x0\n        res = <value optimized out>\n        failed = Error accessing memory address 0x0: Bad address.", "id": 177884, "time": "2014-09-15T13:47:36Z", "creator": "victor_volpe@bol.com.br", "creation_time": "2014-09-15T13:47:36Z", "is_private": false, "attachment_id": null}, {"count": 1, "tags": [], "text": "Hello Victor,\n\nMy guess is that when you went from 2.2 to 2.4 you switched from MPM prefork to MPM worker.  This would happen by default.\nYou can verify this by running httpd -M.\nIf I remember correctly, PHP routines are known to not be thread-safe.\nYou can try switching back to MPM prefork and see if your problems go away.\n\nYou can do this by adding --with-mpm=prefork to your httpd configure.\n\nThanks,\n\nMike Rumph", "is_private": false, "id": 177896, "creator": "mike.rumph@oracle.com", "time": "2014-09-16T00:25:22Z", "bug_id": 56984, "creation_time": "2014-09-16T00:25:22Z", "attachment_id": null}, {"count": 2, "tags": [], "bug_id": 56984, "text": "(In reply to Mike Rumph from comment #1)\n> Hello Victor,\n> \n> My guess is that when you went from 2.2 to 2.4 you switched from MPM prefork\n> to MPM worker.  This would happen by default.\n> You can verify this by running httpd -M.\n> If I remember correctly, PHP routines are known to not be thread-safe.\n> You can try switching back to MPM prefork and see if your problems go away.\n> \n> You can do this by adding --with-mpm=prefork to your httpd configure.\n> \n> Thanks,\n> \n> Mike Rumph\n\nOMG! Now my Apache is working like a charm. Thank you very much pal.", "id": 177901, "time": "2014-09-16T03:11:35Z", "creator": "victor_volpe@bol.com.br", "creation_time": "2014-09-16T03:11:35Z", "is_private": false, "attachment_id": null}, {"count": 3, "tags": [], "text": "Even with prefork worker, the PHP5 module segfaults on pipelined client requests when the script is not cached by the PHP5 opcache.", "attachment_id": null, "id": 181706, "creator": "gmoniker@gmail.com", "time": "2015-03-12T17:41:18Z", "bug_id": 56984, "creation_time": "2015-03-12T17:41:18Z", "is_private": false}, {"count": 4, "tags": [], "bug_id": 56984, "attachment_id": null, "is_private": false, "id": 181707, "time": "2015-03-12T17:42:15Z", "creator": "gmoniker@gmail.com", "creation_time": "2015-03-12T17:42:15Z", "text": "The bug is instantly reproducible on a fresh Ubuntu 14.04.\n\nInstall server.\napt-get install apache2 php5 netcat\n\nSetup a small PHP script with output in /var/www/html/\nFor Example as test.php\n<?php\n echo date('U').PHP_EOL;\n?>\n\nshutdown Apache service:\napache2ctl stop\n\nDisable opcache with semicolon in front in /etc/php5/apache2/conf.d/05-opcache.ini\n\nStart Apache debug server in separate shell\napache2ctl -X\n\nExecute this script (thanks to biggi at stefna dot is):\necho -e \"GET /test.php HTTP/1.1\\nHost: localhost\\n\\nGET /test.php HTTP/1.1\\nHost: localhost\\n\\n\"|nc localhost 80\n\nResult: immediate segfault\n\nIf you do only one request per connection, no problem\nIf you activate opcache, you will only get one response, the second one appears on the stdout of the debug apache\nIf you fill the opcache it will segfault if it can't fit the script anymore\n\nI confirmed the same behaviour on Centos 7 with its default packaged Apache"}, {"count": 5, "tags": [], "bug_id": 56984, "text": "See also:\nhttps://bugs.php.net/bug.php?id=68486\nhttps://bugs.launchpad.net/ubuntu/+source/php5/+bug/1407990", "id": 181708, "time": "2015-03-12T17:45:21Z", "creator": "gmoniker@gmail.com", "creation_time": "2015-03-12T17:45:21Z", "is_private": false, "attachment_id": null}, {"count": 6, "tags": [], "bug_id": 56984, "text": "I think this is result of expected httpd-2.4.x behaviour change.\n\nIn httpd-2.2.x, after each request, httpd destroyed r->pool. Apparently, PHP used that to clear its internal data before handling next request.\n\nIn httpd-2.4.x, we are passing EOR bucket down the stream and once it's freed, r->pool is destroyed. Thanks to the scanning done in core_output_filter, the response with EOR bucket does not have to be sent right after the ap_pass_brigade call.\n\nSo the result is, that request is handled, EOR bucket is created, but it's not sent yet. r->pool is therefore not cleared, but new request handling is started. This leads to mod_php crash, because its internal data structures are not cleared in r->pool clean-up *before* the next request comes.\n\nIn 2.2.x, r->pool has been cleaned-up once its handling has been finished.\nIn 2.4.x, r->pool is cleaned-up once it is fully sent.\n\nI think PHP could should be fixed to not use r->pool to clean-up things before next request.", "id": 181906, "time": "2015-03-19T13:09:52Z", "creator": "jkaluza@redhat.com", "creation_time": "2015-03-19T13:09:52Z", "is_private": false, "attachment_id": null}, {"count": 7, "tags": [], "text": "> In 2.2.x, r->pool has been cleaned-up once its handling has been finished.\n> In 2.4.x, r->pool is cleaned-up once it is fully sent.\n\nThis should have been:\n\nIn 2.2.x, r->pool has been cleaned-up once the request handling has been finished.\nIn 2.4.x, r->pool is cleaned-up once the response is fully sent.", "attachment_id": null, "id": 181908, "creator": "jkaluza@redhat.com", "time": "2015-03-19T14:07:28Z", "bug_id": 56984, "creation_time": "2015-03-19T14:07:28Z", "is_private": false}, {"count": 8, "tags": [], "bug_id": 56984, "attachment_id": null, "id": 181910, "time": "2015-03-19T18:59:59Z", "creator": "gmoniker@gmail.com", "creation_time": "2015-03-19T18:59:59Z", "is_private": false, "text": "There is now activity going on in the php5 Apache2 handler to solve the segfaults with pipelined client requests by not relying anymore on the destruction of the request pool between two client requests on the same connection.\n\nHowever there is some confusion about when the pool destructions are eventually going to run. It seems that disconnection is the only signal for a prefork worker to process the EOR buckets. Responses are fully sent earlier but not the EOR bucket. What if the client indicated keep-alive? \n\nIn this situation, module programmers will have to think hard about what they are allocating in the pool. There will be lots of modules that rely on cleanup callbacks to run after each client request gets processed, and a module programmer cannot influence the amount of requests sent on one connection by the client or for how long it stays connected. It seems that doing your own memory management is the only option going forward for anything that exceeds a couple of kilobytes."}, {"count": 9, "tags": [], "bug_id": 56984, "attachment_id": null, "is_private": false, "id": 181994, "time": "2015-03-23T11:49:16Z", "creator": "gmoniker@gmail.com", "creation_time": "2015-03-23T11:49:16Z", "text": "The problem with Apache 2.4 hanging on to pool data in case of persistent client connection until sometime in follow-on requests is not quite as bad as I was afraid of. Some output exceeding the buffer space in a follow-on request will be enough to flush the EOR bucket and destroy the pool space.\n\nBut is there any reason not to flush the response data and log the transaction immediately after processing a client request? Instead of pool destroy, the worker could call a flush after processing one client request.\n\nEven if this is expected behaviour, and given that the PHP handler is doing it wrong by depending on the previous request cleanup having been completed when entering the processing of a new client request, it seems kind of strange that output, and memory of one script is held back and only flushed dependent on  circumstances that are completely extraneous to it.\n\nIf for example follow-on processing causes a segfault and no response was sent yet by the first script to the client, the client will believe that the script never finished. So this behaviour seems to run counter to the expectation of stateless requests. Given that the user of a browser does not usually have much control of whether his browser uses pipelined connections or not, he cannot be said to have made a conscious choice for stateful behaviour."}, {"count": 10, "tags": [], "bug_id": 56984, "attachment_id": null, "is_private": false, "id": 182005, "time": "2015-03-23T17:00:24Z", "creator": "ylavic.dev@gmail.com", "creation_time": "2015-03-23T17:00:24Z", "text": "(In reply to gmoniker from comment #9)\n> But is there any reason not to flush the response data and log the\n> transaction immediately after processing a client request? Instead of pool\n> destroy, the worker could call a flush after processing one client request.\n\nThat would, I think, defeat the main goal of pipelining which is: fill in the pipe.\n\n> \n> Even if this is expected behaviour, and given that the PHP handler is doing\n> it wrong by depending on the previous request cleanup having been completed\n> when entering the processing of a new client request, it seems kind of\n> strange that output, and memory of one script is held back and only flushed\n> dependent on  circumstances that are completely extraneous to it.\n\nThe circonstance is precisely that the next (pipelined) request is already here when the current request is done, otherwise the flush is done (see the test on !c->data_in_input_filters in ap_process_request(), or in MPM event the test on c->data_in_output_filters so that all data get written before entering keepalive state).\n\nIOW, the current implementation considers pipelined requests should be answered with pipelined responses, as much as possible.\n\n> \n> If for example follow-on processing causes a segfault and no response was\n> sent yet by the first script to the client, the client will believe that the\n> script never finished. So this behaviour seems to run counter to the\n> expectation of stateless requests. Given that the user of a browser does not\n> usually have much control of whether his browser uses pipelined connections\n> or not, he cannot be said to have made a conscious choice for stateful\n> behaviour.\n\nIf some process crashes, I'm not sure the client should rely on the number responses it actually received to deduce any state on the server side, it solely depends on whether the requests sent were idempotent or not (IMHO)."}, {"count": 11, "tags": [], "text": "Hello Yann,\n\nThanks for your clear story about the design principles. I can see that coalescing writes to the client means more performance. I was also missing the point about idempotent requests. The browser/client should not resend possible non-idempotent requests as soon as they have left the client even if it doesn't get a reply from the server.\n\nI still think though that there are some concerns about this when you have requests with a long runtime, high pool usage and very small ack-like response. It could take several requests before any output gets sent back and memory gets cleared.\n\nAlso apache modules that didn't get updated to take this into account can misbehave as is now painfully clear. Not only can they have issues with pool cleanups not having run, but also with reentry of handlers that are also registered for output filters and respond to an EOS bucket of a previous request while processing a follow-on request.\n\nMost of the time I am just the custodian of a webserver and am most concerned with it functioning reliable and not having the highest possible performance. So I guess what I should be asking is, can we make it a feature request to have the option of configging Apache 2.4 to do a flush after each client request?\n\nThanks.", "attachment_id": null, "id": 182032, "creator": "gmoniker@gmail.com", "time": "2015-03-24T00:04:21Z", "bug_id": 56984, "creation_time": "2015-03-24T00:04:21Z", "is_private": false}, {"count": 12, "tags": [], "bug_id": 56984, "attachment_id": null, "id": 182035, "time": "2015-03-24T08:19:00Z", "creator": "ylavic.dev@gmail.com", "creation_time": "2015-03-24T08:19:00Z", "is_private": false, "text": "(In reply to gmoniker from comment #11)\n> \n> I still think though that there are some concerns about this when you have\n> requests with a long runtime, high pool usage and very small ack-like\n> response. It could take several requests before any output gets sent back\n> and memory gets cleared.\n\nThe maximum number of pipelined responses is 5 (see ap_core_output_filter()'s MAX_REQUESTS_IN_PIPELINE), and when this limit is reached, all 5 requests are destroyed at once.\n\n> \n> Also apache modules that didn't get updated to take this into account can\n> misbehave as is now painfully clear. Not only can they have issues with pool\n> cleanups not having run, but also with reentry of handlers that are also\n> registered for output filters and respond to an EOS bucket of a previous\n> request while processing a follow-on request.\n\nModules switching from httpd < 2.4 to >= 2.4 should normally take the new features into account (eg. pipelining), otherwise no major advancement would be possible on the httpd side.\n\n> \n> Most of the time I am just the custodian of a webserver and am most\n> concerned with it functioning reliable and not having the highest possible\n> performance. So I guess what I should be asking is, can we make it a feature\n> request to have the option of configging Apache 2.4 to do a flush after each\n> client request?\n\nMaybe MAX_REQUESTS_IN_PIPELINE could be configurable, or/and proxy/cgi(/php?) modules improved to flush when further responses take time to come (mod_proxy_http does that already IIRC)...\n\nThat's another story though, and we should discuss this on user@ (or dev@) mailing list, or create another bugzilla ticket (enhancement) for this."}, {"count": 13, "tags": [], "bug_id": 56984, "attachment_id": null, "is_private": false, "id": 182576, "time": "2015-04-22T18:59:48Z", "creator": "ylavic.dev@gmail.com", "creation_time": "2015-04-22T18:59:48Z", "text": "*** Bug 57846 has been marked as a duplicate of this bug. ***"}]