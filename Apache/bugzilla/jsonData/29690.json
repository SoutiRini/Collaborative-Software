[{"count": 0, "tags": [], "bug_id": 29690, "attachment_id": null, "is_private": false, "id": 59607, "time": "2004-06-19T20:41:11Z", "creator": "cra@gedas.de", "creation_time": "2004-06-19T20:41:11Z", "text": "Remark: This *may* be a duplicate of various reported bugs having to do with \ncrashing worker processes under Win2K/XP with log entry \"Parent: child process \nexited with status 3221225477 -- Restarting.\"\n\nDescription: Sometimes the winnt/child.c worker thread/process crashes in \nmemory/unix/apr_pools.c, line 323 (next = node->next;) when accessing the \nserver via SSL using mod_ssl with OpenSSL 0.9.7d. The worker is then restarted \nby the main process (with the error log entry above).\n\nThe error location in detail (all infos obtained using MS VC++ 6.0 debugger):\n\nstatic APR_INLINE\nvoid allocator_free(apr_allocator_t *allocator, apr_memnode_t *node)\n{\n/* *** (code deleted) *** */\n    /* Walk the list of submitted nodes and free them one by one,\n     * shoving them in the right 'size' buckets as we go.\n     */\n    do {\n        next = node->next;     <<==== CRASHES *HERE*\n        index = node->index;\n\nThe crash happens because 'node' (the second parameter) equals NULL. \nallocator_free() is called by apr_pool_clear() (same file, line 713). \nObviously, the pool specified as the function parameter has \n   pool->active->next == NULL.\n\nThe complete stack trace is as follows:\n\nallocator_free(apr_allocator_t * 0x0087ff88, apr_memnode_t * 0x00000000) line \n323 + 3 bytes\napr_pool_clear(apr_pool_t * 0x00ce8b80) line 713 + 18 bytes\ncore_output_filter(ap_filter_t * 0x00cc0d28, apr_bucket_brigade * 0x00cbdc68) \nline 4166\nap_pass_brigade(ap_filter_t * 0x00cc0d28, apr_bucket_brigade * 0x00cbdc68) line \n511 + 16 bytes\nbio_filter_out_flush(bio_st * 0x00cbbbc0) line 155 + 25 bytes\nbio_filter_out_write(bio_st * 0x00cbbbc0, const char * 0x00cd1e30, int 23) line \n220 + 9 bytes\nBIO_write(bio_st * 0x00cbbbc0, const void * 0x00cd1e30, int 23) line 201 + 20 \nbytes\nssl3_write_pending(ssl_st * 0x00cbb6c8, int 21, const unsigned char * \n0x00cbb9c4, unsigned int 2) line 742 + 50 bytes\ndo_ssl3_write(ssl_st * 0x00cbb6c8, int 21, const unsigned char * 0x00cbb9c4, \nunsigned int 2, int 0) line 713 + 21 bytes\nssl3_dispatch_alert(ssl_st * 0x00cbb6c8) line 1282 + 27 bytes\nssl3_send_alert(ssl_st * 0x00cbb6c8, int 1, int 0) line 1271 + 9 bytes\nssl3_shutdown(ssl_st * 0x00cbb6c8) line 1650 + 13 bytes\nSSL_shutdown(ssl_st * 0x00cbb6c8) line 895 + 13 bytes\nSSL_smart_shutdown(ssl_st * 0x00cbb6c8) line 188 + 9 bytes\nssl_filter_io_shutdown(ssl_filter_ctx_t * 0x00caf8e8, conn_rec * 0x00caf568, \nint 0) line 955 + 9 bytes\nssl_io_filter_cleanup(void * 0x00caf8e8) line 996 + 15 bytes\nrun_cleanups(cleanup_t * * 0x00caf470) line 1951 + 13 bytes\napr_pool_clear(apr_pool_t * 0x00caf460) line 693 + 12 bytes\nmpm_recycle_completion_context(CompContext * 0x00ca70a8) line 81\nwinnt_get_connection(CompContext * 0x00ca70a8) line 637\nworker_main(long 499) line 692 + 9 bytes\n\nThis error happens from \"inside\" mod_ssl, which corresponds to the fact that it \ndoes *not* occur when accessing the server through normal HTTP.\n\nNow my question is: Is is possible or \"legal\" that pools exist whose \n'active->next' is set to NULL? If this is the case, the allocator_free() \nfunction would have to check for this. If simply tried the following: CHanged \nthe beginning of the loop in allocator_free() to:\n\n   /* Walk the list of submitted nodes and free them one by one,\n     * shoving them in the right 'size' buckets as we go.\n     */\n    do {\n        /* *** NEW *** */\n        if (node == NULL)\n            break;\n\n        next = node->next;\n        index = node->index;\n\nHowever, after this change, the server now crashes in apr_buckets_alloc.c, line \n91 because its 'list' parameter equals NULL. Here is the full stack trace:\n\napr_bucket_alloc(unsigned int 40, apr_bucket_alloc_t * 0x00000000) line 91 + 3 \nbytes\napr_bucket_flush_create(apr_bucket_alloc_t * 0x00000000) line 38 + 11 bytes\ncheck_pipeline_flush(request_rec * 0x00d32260) line 211 + 13 bytes\nap_process_request(request_rec * 0x00d32260) line 269 + 9 bytes\nap_process_http_connection(conn_rec * 0x00ceed20) line 250 + 9 bytes\nap_run_process_connection(conn_rec * 0x00ceed20) line 42 + 78 bytes\nap_process_connection(conn_rec * 0x00ceed20, void * 0x00ceec50) line 177\nworker_main(long 497) line 718\n\nApparently, I was wrong with my first assumption :-(\n\nHowever, I still believe that it must have something to do with how mod_ssl \nhandles memory. But I really don't understand why this kind of error is only \nobserved under Windows. Hmmm."}, {"count": 1, "tags": [], "bug_id": 29690, "attachment_id": null, "id": 59609, "time": "2004-06-19T21:20:03Z", "creator": "cra@gedas.de", "creation_time": "2004-06-19T21:20:03Z", "is_private": false, "text": "Just found out that active->next ist set to NULL in the line just before the \nallocator_free() call at the end of apr_pool_clear():\n\n----------------------------- snip -----------------------------\n    if (active->next == active)  /* apr_pools.c, line 709 */\n        return;\n\n    *active->ref = NULL;\n    allocator_free(pool->allocator, active->next);\n----------------------------- snip -----------------------------\n\nThe '*active->ref = NULL;' statement sets active->next to NULL. It was *NOT* \nNULL before that statement.\n\nObviously, 'active->ref' pointed to the *own* 'next' field.\n"}, {"count": 2, "tags": [], "bug_id": 29690, "attachment_id": null, "is_private": false, "id": 59610, "time": "2004-06-19T21:56:26Z", "creator": "cra@gedas.de", "creation_time": "2004-06-19T21:56:26Z", "text": "New Info: I am reproducing the error using MS IE 6.0 on a SSL page containing a \nnumber of images that are loaded via SSL, too. Nearly every time I refresh the \npage, the error occurs. However, when I remove the images from the page, so \nonly the main HTML is loaded and no second connection is used by IE, the error \ndoes *not* occur anymore.\n\nI first thought it has something to do with the multithreading, but how I think \nthat the whole thing is cause by IE aborting connections because I can \nreproduce the error even w/o images just by hitting ESC before the page loads - \nthe connection is aborted, mod_ssl is shutting down the socket (SSL_Shutdown, \nssl3_send_alert...) and this causes the error.\n\nP.S. I forgot: Previously, the page was generated by a Tomcat. However, the \nerror appears also when directly putting the page in Apache's htdocs, so it has \nnothing to do with Tomcat. However, the error appears less often, I have to hit \nF5 (reload) in IE several times before it appears."}, {"count": 3, "tags": [], "bug_id": 29690, "attachment_id": null, "id": 59611, "time": "2004-06-19T23:26:38Z", "creator": "cra@gedas.de", "creation_time": "2004-06-19T23:26:38Z", "is_private": false, "text": "Possible workaround found: Make SSL shutdown a quiet one. \nChanged ssl_util_ssl.c, added 'ssl->quiet_shutdown = 1;' before OpenSSL's \nSSL_shutdown() is called:\n\nint SSL_smart_shutdown(SSL *ssl)\n{\n    int i;\n    int rc;\n\n    /*\n     * Repeat the calls, because SSL_shutdown internally dispatches through a\n     * little state machine. Usually only one or two interation should be\n     * needed, so we restrict the total number of restrictions in order to\n     * avoid process hangs in case the client played bad with the socket\n     * connection and OpenSSL cannot recognize it.\n     */\n    rc = 0;\n    ssl->quiet_shutdown = 1;\n    for (i = 0; i < 4 /* max 2x pending + 2x data = 4 */; i++) {\n        if ((rc = SSL_shutdown(ssl)))\n            break;\n    }\n    return rc;\n}\n\nThis removes the error completely, however I am not 100% sure about security \nissues (when does the client not get an abort notification, and when is that \ndangerous?)"}, {"count": 4, "tags": [], "text": "I am sorry - it's me again ;-) But this problem doesn't want to let me go...\n\nIn apr_pool_clear(), the following is done:\n   1. Destroy the subpools - *first*\n   2. Run cleanups\n   3. Free subprocesses\n\nCould it be that the cleanups do something wrong when they allocate memory (and \nthe SSL shutdown *does*!!) and the subpools are already destroyed?\n\nWhen I change this to:\n   1. Run cleanups\n   2. Free subprocesses\n   3. Destroy the subpools - *last*\n\nEverything works fine (w/o my previous quiet_shutdown workaround!). \n\nQuestion: Is this ok, or does it maybe produce memory leaks? I admit that I \nstill don't fully understand the pool concept :-)\n\nBTW: The same questions apply to the apr_pool_destroy() function which does the \nsame three steps for the sub-pools.", "is_private": false, "bug_id": 29690, "id": 59612, "time": "2004-06-20T00:40:00Z", "creator": "cra@gedas.de", "creation_time": "2004-06-20T00:40:00Z", "attachment_id": null}, {"count": 5, "tags": [], "bug_id": 29690, "attachment_id": null, "is_private": false, "id": 59616, "time": "2004-06-20T08:08:41Z", "creator": "jorton@redhat.com", "creation_time": "2004-06-20T08:08:41Z", "text": "Good analysis :) The problem is a misuse of pool cleanups, see patch on the\nother bug.\n\n*** This bug has been marked as a duplicate of 27945 ***"}, {"count": 6, "tags": [], "creator": "cra@gedas.de", "attachment_id": null, "text": "Thank you!\nI will search the database more thoroughly @ the next bug ;-)\n", "id": 59624, "time": "2004-06-20T17:00:34Z", "bug_id": 29690, "creation_time": "2004-06-20T17:00:34Z", "is_private": false}]