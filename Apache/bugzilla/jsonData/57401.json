[{"count": 0, "attachment_id": 32333, "creator": "rksuthar19@gmail.com", "is_private": false, "id": 180046, "time": "2014-12-29T07:29:56Z", "bug_id": 57401, "creation_time": "2014-12-29T07:29:56Z", "tags": [], "text": "Created attachment 32333\nattachment contains additional class and enum with tweek in existing code and test cases , writing part of test case require less then -Xmx100M to write data\n\nProblem : SXSSFWorkbook defaults to using inline strings instead of a shared strings table.This is very efficient, since no document content needs to be kept in memory, but is also known to produce documents that are incompatible with some clients and work book size will be large.\n\nSXSSFWorkbook with shared strings enabled all unique strings in the document has to be kept in memory but it use a lot more resources than with shared strings disabled.\n\nSolution : To reduce memory footprint of POI\u2019s shared strings table implementation we implemented shared strings table usin MapDB.\n\nOverall, the MapDB solution is slower than pure POI, but takes much lesser amount of memory.\n\n\nAttached patch \nWe couldn't so far find a clean way to achieve this without patching POI code.\n\nTo achieve this we have added SharedStringsTable type (Default or MapDB) to use while constructing XSSFWorkbook through it's constructor which and overridden write(OutputStream stream) method from from POIXMLDocument(by removing final keyword from this method to override it).\n\nDBMappedSharedStringsTable class extends from SharedStringsTable which have logic to flows data to disk as per availability of memory.\nMirror of Apache POI"}, {"count": 1, "tags": [], "creator": "rksuthar19@gmail.com", "attachment_id": 32333, "text": "Comment on attachment 32333\nattachment contains additional class and enum with tweek in existing code and test cases , writing part of test case require less then -Xmx100M to write data\n\nIndex: src/ooxml/testcases/org/apache/poi/xssf/model/TestDBMappedSharedStringsTableOption.java\nIDEA additional info:\nSubsystem: com.intellij.openapi.diff.impl.patch.CharsetEP\n<+>UTF-8\n===================================================================\n--- src/ooxml/testcases/org/apache/poi/xssf/model/TestDBMappedSharedStringsTableOption.java\t(revision )\n+++ src/ooxml/testcases/org/apache/poi/xssf/model/TestDBMappedSharedStringsTableOption.java\t(revision )\n@@ -0,0 +1,206 @@\n+package org.apache.poi.xssf.model;\n+\n+import org.apache.poi.ss.usermodel.Cell;\n+import org.apache.poi.ss.usermodel.Row;\n+import org.apache.poi.ss.usermodel.Workbook;\n+import org.apache.poi.xssf.SXSSFITestDataProvider;\n+import org.apache.poi.xssf.streaming.SXSSFSheet;\n+import org.apache.poi.xssf.streaming.SXSSFWorkbook;\n+import org.apache.poi.xssf.usermodel.XSSFWorkbook;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.io.*;\n+import java.util.Random;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class TestDBMappedSharedStringsTableOption {\n+    //Streaming version of workbook\n+    private SXSSFWorkbook workbook;\n+\n+    private SXSSFSheet sheet;\n+\n+    private File outputFile;\n+    public static final String TEST_OUTPUT_DIR = \"poi.test.xssf.output.dir\";\n+\n+    @Before\n+    public void setUp() {\n+        outputFile = new File(System.getProperty(TEST_OUTPUT_DIR), \"output.xlsx\");\n+        setupWorkBook();\n+        setupBlankSheet();\n+    }\n+\n+    private void setupWorkBook() {\n+        XSSFWorkbook wb = new XSSFWorkbook(SharedStringsTableType.LOW_FOOTPRINT_MAP_DB_SST);\n+        workbook = new SXSSFWorkbook(wb, 2, false, true);\n+    }\n+\n+    private void setupBlankSheet() {\n+        sheet = (SXSSFSheet) workbook.createSheet(\"Employee Data\");\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        outputFile.delete();\n+    }\n+\n+    @Test\n+    public void testWrite100UniqueRecordsOf10Char() throws IOException {\n+        int recordCount = 100;\n+        addUniqueRecordsToSheet(0, 100, 10);\n+        writeAndAssertRecord(recordCount);\n+    }\n+\n+    @Test\n+    public void testWrite1MUniqueRecordsOf100Char() {\n+        int recordCount = 1000000;\n+        addUniqueRecordsToSheet(0, recordCount, 100);\n+        writeAndAssertRecord(recordCount);\n+    }\n+\n+    @Test\n+    public void testWriteFromTextFile() {\n+        int recordCount = 3;\n+        File textInputFile = new File(System.getProperty(TEST_OUTPUT_DIR), \"temp.txt\");\n+        try {\n+            FileWriter w = new FileWriter(textInputFile);\n+            for (int i = 1; i <= recordCount; i++) {\n+                w.write(\"Line\" + i + \",FirstColumn,SecondColumn,ThirdColumn\\r\\n\");\n+            }\n+            w.close();\n+        } catch (IOException e) {\n+        }\n+        addRecordsFromFile(\"temp.txt\");\n+        writeAndAssertRecord(recordCount);\n+        textInputFile.delete();\n+    }\n+\n+    @Test\n+    public void testWrite1MRandomRecordsOf10Char() {\n+        int recordCount = 100000;\n+        addRandomRecordsToSheet(0, recordCount, 200000, 10);\n+        writeAndAssertRecord(recordCount);\n+    }\n+\n+    @Test\n+    public void test1MRecordHavingRepetitiveRecordsOf10Char() {\n+        int recordCount = 1000000;\n+        addUniqueRecordsToSheet(0, 200000, 10);\n+        addUniqueRecordsToSheet(200000, 200000, 10);\n+        addUniqueRecordsToSheet(400000, 200000, 10);\n+        addUniqueRecordsToSheet(600000, 200000, 10);\n+        addUniqueRecordsToSheet(800000, 200000, 10);\n+        writeAndAssertRecord(recordCount);\n+    }\n+\n+    @Test\n+    public void testWriteAllDuplicateRecord() {\n+        int recordCount = 100000;\n+        addRepeatingRecordsToSheet(recordCount);\n+        writeAndAssertRecord(recordCount);\n+    }\n+\n+    private void writeAndAssertRecord(int recordCount) {\n+        System.out.print(\"Started writing.....\");\n+        //NOTE: all tests can be executed within -Xmx100M by commenting out out code below\n+        //----\n+        XSSFWorkbook wb = (XSSFWorkbook) SXSSFITestDataProvider.instance.writeOutAndReadBack(workbook);\n+        System.out.println(\"File creation done...Asserting\");\n+        assertRows(wb, recordCount);\n+        //----\n+    }\n+\n+    private void addUniqueRecordsToSheet(int fromRowNum, int numberOfRecords, int constantStringLength) {\n+        System.out.print(\"adding records to sheet.....\");\n+        int i = 0;\n+        String constantString = getStringOf(constantStringLength);\n+        while (i++ < numberOfRecords) {\n+            if (i % 10000 == 0) System.out.print(i + \",\");\n+            Row row = sheet.createRow(fromRowNum++);\n+            Object[] objArr = new Object[]{constantString + i};\n+            int cellNum = 0;\n+            for (Object obj : objArr) {\n+                Cell cell = row.createCell(cellNum++);\n+                if (obj instanceof String) {\n+                    cell.setCellValue((String) obj);\n+                } else if (obj instanceof Integer)\n+                    cell.setCellValue((Integer) obj);\n+            }\n+        }\n+    }\n+\n+    private String getStringOf(int length) {\n+        StringBuilder str = new StringBuilder();\n+        for (int j = 0; j < length; j++) {\n+            str.append(\"a\");\n+        }\n+        return str.toString();\n+    }\n+\n+    private void addRandomRecordsToSheet(int fromRowNum, int numberOfRecords, int recordLength, int constantStringLength) {\n+        int i = 0;\n+        String constantString = getStringOf(constantStringLength);\n+        while (i++ < numberOfRecords) {\n+            if (i % 1000 == 0) System.out.print(i + \",\");\n+            Row row = sheet.createRow(fromRowNum++);\n+            Object[] objArr = new Object[]{constantString + new Random().nextInt(recordLength)};\n+            int cellNum = 0;\n+            for (Object obj : objArr) {\n+                Cell cell = row.createCell(cellNum++);\n+                if (obj instanceof String)\n+                    cell.setCellValue((String) obj);\n+                else if (obj instanceof Integer)\n+                    cell.setCellValue((Integer) obj);\n+            }\n+        }\n+    }\n+\n+    private void addRecordsFromFile(String fileName) {\n+        System.out.print(\"adding records to sheet.....\");\n+        try {\n+            int fromRowNum = 0;\n+            BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(fileName)));\n+            String line = null;\n+            while ((line = br.readLine()) != null) {\n+                Row row = sheet.createRow(fromRowNum++);\n+                Object[] objArr = line.split(\",\");\n+                int cellNum = 0;\n+                for (Object obj : objArr) {\n+                    Cell cell = row.createCell(cellNum++);\n+                    if (obj instanceof String)\n+                        cell.setCellValue((String) obj);\n+                    else if (obj instanceof Integer)\n+                        cell.setCellValue((Integer) obj);\n+                }\n+            }\n+            br.close();\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    private void addRepeatingRecordsToSheet(int count) {\n+        int rownum = 0;\n+        int i = 0;\n+        String constantString = getStringOf(10);\n+        while (i++ < count) {\n+            Row row = sheet.createRow(rownum++);\n+            Object[] objArr = new Object[]{constantString};\n+            int cellnum = 0;\n+            for (Object obj : objArr) {\n+                Cell cell = row.createCell(cellnum++);\n+                if (obj instanceof String)\n+                    cell.setCellValue((String) obj);\n+                else if (obj instanceof Integer)\n+                    cell.setCellValue((Integer) obj);\n+            }\n+        }\n+    }\n+\n+    public void assertRows(Workbook wb, int expectedRecordCount) {\n+        assertEquals(expectedRecordCount, wb.getSheetAt(0).getLastRowNum() + 1);\n+    }\n+\n+}\nIndex: src/ooxml/java/org/apache/poi/xssf/model/SharedStringsTableType.java\nIDEA additional info:\nSubsystem: com.intellij.openapi.diff.impl.patch.CharsetEP\n<+>UTF-8\n===================================================================\n--- src/ooxml/java/org/apache/poi/xssf/model/SharedStringsTableType.java\t(revision )\n+++ src/ooxml/java/org/apache/poi/xssf/model/SharedStringsTableType.java\t(revision )\n@@ -0,0 +1,37 @@\n+/* ====================================================================\n+   Licensed to the Apache Software Foundation (ASF) under one or more\n+   contributor license agreements.  See the NOTICE file distributed with\n+   this work for additional information regarding copyright ownership.\n+   The ASF licenses this file to You under the Apache License, Version 2.0\n+   (the \"License\"); you may not use this file except in compliance with\n+   the License.  You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+==================================================================== */\n+package org.apache.poi.xssf.model;\n+\n+/**\n+ * enum to specify shared strings table to use\n+ */\n+public enum SharedStringsTableType {\n+    DEFAULT_SST(SharedStringsTable.class),//in memory shared strings string table\n+    LOW_FOOTPRINT_MAP_DB_SST(DBMappedSharedStringsTable.class); //streaming version low foot print shared strings table\n+    /**\n+     * Defines what object is used to construct instances of this relationship\n+     */\n+    private Class<? extends SharedStringsTable> instance;\n+\n+    private SharedStringsTableType(Class<? extends SharedStringsTable> sharedStringsTableInstance) {\n+        instance = sharedStringsTableInstance;\n+    }\n+\n+    public Class<? extends SharedStringsTable> getInstance() {\n+        return instance;\n+    }\n+}\nIndex: src/ooxml/java/org/apache/poi/POIXMLDocument.java\nIDEA additional info:\nSubsystem: com.intellij.openapi.diff.impl.patch.CharsetEP\n<+>UTF-8\n===================================================================\n--- src/ooxml/java/org/apache/poi/POIXMLDocument.java\t(revision 8bf3ebfcee2e2799486de4ed8a5e063616b4083a)\n+++ src/ooxml/java/org/apache/poi/POIXMLDocument.java\t(revision )\n@@ -189,7 +189,7 @@\n      *\n      * @exception IOException if anything can't be written.\n      */\n-    public final void write(OutputStream stream) throws IOException {\n+    public void write(OutputStream stream) throws IOException {\n         //force all children to commit their changes into the underlying OOXML Package\n         Set<PackagePart> context = new HashSet<PackagePart>();\n         onSave(context);\nIndex: src/ooxml/java/org/apache/poi/xssf/model/DBMappedSharedStringsTable.java\nIDEA additional info:\nSubsystem: com.intellij.openapi.diff.impl.patch.CharsetEP\n<+>UTF-8\n===================================================================\n--- src/ooxml/java/org/apache/poi/xssf/model/DBMappedSharedStringsTable.java\t(revision )\n+++ src/ooxml/java/org/apache/poi/xssf/model/DBMappedSharedStringsTable.java\t(revision )\n@@ -0,0 +1,311 @@\n+/* ====================================================================\n+   Licensed to the Apache Software Foundation (ASF) under one or more\n+   contributor license agreements.  See the NOTICE file distributed with\n+   this work for additional information regarding copyright ownership.\n+   The ASF licenses this file to You under the Apache License, Version 2.0\n+   (the \"License\"); you may not use this file except in compliance with\n+   the License.  You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+==================================================================== */\n+\n+package org.apache.poi.xssf.model;\n+\n+import org.apache.poi.openxml4j.opc.PackagePart;\n+import org.apache.poi.openxml4j.opc.PackageRelationship;\n+import org.apache.poi.util.TempFile;\n+import org.apache.xmlbeans.XmlException;\n+import org.apache.xmlbeans.XmlOptions;\n+import org.mapdb.DB;\n+import org.mapdb.DBMaker;\n+import org.mapdb.HTreeMap;\n+import org.openxmlformats.schemas.spreadsheetml.x2006.main.CTRst;\n+import org.openxmlformats.schemas.spreadsheetml.x2006.main.CTSst;\n+import org.openxmlformats.schemas.spreadsheetml.x2006.main.SstDocument;\n+\n+import javax.xml.stream.XMLStreamException;\n+import java.io.*;\n+import java.math.BigInteger;\n+import java.security.SecureRandom;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * SharedStringsTable With Map DB implementation\n+ * </p>\n+ *\n+ */\n+public class DBMappedSharedStringsTable extends SharedStringsTable implements AutoCloseable{\n+\n+    /**\n+     * Maps strings and their indexes in the <code>recordVsIndexBasedSTMap</code> map db\n+     */\n+    private DB recordVsIndexMapDB;\n+    private HTreeMap<String, Integer> recordVsIndexBasedSTMap; //string vs index map to lookup existing record in stTable\n+    /**\n+     * Maps strings and their indexes in the <code>recordVsIndexBasedSTMap</code> map db\n+     */\n+    private DB indexVsRecordMapDB;\n+    private HTreeMap<Integer, String> indexVsRecordBasedSTMap; //index vs string map to retrieve record with index\n+\n+    private final File temp_shared_string_file;\n+\n+    /**\n+     * An integer representing the total count of strings in the workbook. This count does not\n+     * include any numbers, it counts only the total of text strings in the workbook.\n+     */\n+    private int count;\n+\n+    /**\n+     * An integer representing the total count of unique strings in the Shared String Table.\n+     * A string is unique even if it is a copy of another string, but has different formatting applied\n+     * at the character level.\n+     */\n+    private int uniqueCount;\n+\n+    private SstDocument _sstDoc;\n+\n+    private final static XmlOptions options = new XmlOptions();\n+    private final static XmlOptions out_options = new XmlOptions();\n+\n+\n+    static {\n+        options.put(XmlOptions.SAVE_INNER);\n+        options.put(XmlOptions.SAVE_AGGRESSIVE_NAMESPACES);\n+        options.put(XmlOptions.SAVE_USE_DEFAULT_NAMESPACE);\n+        options.setSaveImplicitNamespaces(Collections.singletonMap(\"\", \"http://schemas.openxmlformats.org/spreadsheetml/2006/main\"));\n+\n+        out_options.setLoadSubstituteNamespaces(Collections.singletonMap(\"\", \"http://schemas.openxmlformats.org/spreadsheetml/2006/main\"));   //TODO add options if required\n+    }\n+\n+    public DBMappedSharedStringsTable() {\n+        super();\n+        temp_shared_string_file = createTempFile(\"poi-shared-string-table\", \".xml\");\n+        initMapDbBasedSharedStringTableMap();\n+    }\n+\n+    private File createTempFile(String prefix, String suffix) {\n+        try {\n+            return TempFile.createTempFile(prefix, suffix);\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Couldn't create required temp file\", e);\n+        }\n+    }\n+\n+    public DBMappedSharedStringsTable(PackagePart part, PackageRelationship rel) throws IOException {\n+        super(part, rel);//TODO needs to be commented out whiler reading\n+        temp_shared_string_file = createTempFile(\"poi-shared-string-table\", \".xml\");\n+        initMapDbBasedSharedStringTableMap();\n+        readFrom(part.getInputStream());\n+    }\n+\n+    public FileInputStream getSharedStringInputStream() throws IOException {\n+        return new FileInputStream(temp_shared_string_file);\n+    }\n+\n+    public FileOutputStream getSharedStringsTableOutputStream() throws IOException {\n+        return new FileOutputStream(temp_shared_string_file);\n+    }\n+\n+    public File getTemp_shared_string_file() {\n+        return temp_shared_string_file;\n+    }\n+\n+    private void initMapDbBasedSharedStringTableMap() {\n+        initRecordVsIndexBasedMapDB();\n+        initIndexVsRecordBasedMapDB();\n+    }\n+\n+    private void initRecordVsIndexBasedMapDB() {\n+        File mapDbFile = createTempFile(new BigInteger(130, new SecureRandom()).toString(32), \"\");//creating random name file to store map db\n+        recordVsIndexMapDB = DBMaker.newFileDB(mapDbFile)\n+                .transactionDisable()\n+                .cacheHardRefEnable()\n+                .cacheSize(65536)\n+                .deleteFilesAfterClose()\n+                .mmapFileEnablePartial()\n+                .closeOnJvmShutdown().make();\n+        recordVsIndexBasedSTMap = recordVsIndexMapDB.createHashMap(new BigInteger(130, new SecureRandom()).toString(32)).make();\n+    }\n+\n+    private void initIndexVsRecordBasedMapDB() {\n+        File mapDb2File = createTempFile(new BigInteger(130, new SecureRandom()).toString(32), \"\");//creating random name file to store map db\n+        indexVsRecordMapDB = DBMaker.newFileDB(mapDb2File)\n+                .transactionDisable()\n+                .cacheDisable() //caching not required indexVsRecordBasedSTMap will be used to write all existing values\n+                .deleteFilesAfterClose()\n+                .mmapFileEnablePartial()\n+                .closeOnJvmShutdown().make();\n+        indexVsRecordBasedSTMap = indexVsRecordMapDB.createHashMap(new BigInteger(130, new SecureRandom()).toString(32)).make();\n+    }\n+\n+    /**\n+     * Read this shared strings table from an XML file.\n+     *\n+     * @param is The input stream containing the XML document.\n+     * @throws java.io.IOException if an error occurs while reading.\n+     */\n+    @SuppressWarnings(\"deprecation\") //YK: getXYZArray() array accessors are deprecated in xmlbeans with JDK 1.5 support\n+    public void readFrom(InputStream is) throws IOException {\n+        try {\n+            int cnt = 0;\n+            _sstDoc = SstDocument.Factory.parse(is);\n+            CTSst sst = _sstDoc.getSst();\n+            count = (int) sst.getCount();\n+            uniqueCount = (int) sst.getUniqueCount();\n+            for (CTRst st : sst.getSiArray()) {\n+                String key = getKey(st);\n+                recordVsIndexBasedSTMap.put(key, cnt);\n+                indexVsRecordBasedSTMap.put(cnt, key);\n+                cnt++;\n+            }\n+        } catch (XmlException e) {\n+            throw new IOException(e.getLocalizedMessage());\n+        }\n+    }\n+\n+    private String getKey(CTRst st) {\n+        return st.xmlText(options);\n+    }\n+\n+    /**\n+     * Return a string item by index\n+     *\n+     * @param idx index of item to return.\n+     * @return the item at the specified position in this Shared String table.\n+     */\n+    public CTRst getEntryAt(int idx) {\n+        try {\n+            return CTRst.Factory.parse(indexVsRecordBasedSTMap.get(idx), out_options);\n+        } catch (XmlException e) {\n+            throw new RuntimeException(\"Error Parsing xmlText from SSTable\");\n+        }\n+    }\n+\n+    /**\n+     * Return an integer representing the total count of strings in the workbook. This count does not\n+     * include any numbers, it counts only the total of text strings in the workbook.\n+     *\n+     * @return the total count of strings in the workbook\n+     */\n+    public int getCount() {\n+        return count;\n+    }\n+\n+    /**\n+     * Returns an integer representing the total count of unique strings in the Shared String Table.\n+     * A string is unique even if it is a copy of another string, but has different formatting applied\n+     * at the character level.\n+     *\n+     * @return the total count of unique strings in the workbook\n+     */\n+    public int getUniqueCount() {\n+        return uniqueCount;\n+    }\n+\n+    /**\n+     * Add an entry to this Shared String table (a new value is appened to the end).\n+     * <p/>\n+     * <p>\n+     * If the Shared String table already contains this <code>CTRst</code> bean, its index is returned.\n+     * Otherwise a new entry is aded.\n+     * </p>\n+     *\n+     * @param st the entry to add\n+     * @return index the index of added entry\n+     */\n+    public int addEntry(CTRst st) {\n+        String s = getKey(st);\n+        count++;\n+        if (recordVsIndexBasedSTMap.containsKey(s)) {\n+            return recordVsIndexBasedSTMap.get(s);\n+        }\n+        //new unique record\n+        recordVsIndexBasedSTMap.put(s, uniqueCount);\n+        indexVsRecordBasedSTMap.put(uniqueCount, s);\n+        return uniqueCount++;\n+    }\n+    /**\n+     * Provide low-level access to the underlying array of CTRst beans\n+     *\n+     * @return array of CTRst beans\n+     */\n+    public List<CTRst> getItems() {\n+        List<CTRst> beans = new ArrayList<CTRst>();\n+        for (int i = 0; i < uniqueCount; i++) {\n+            beans.add(getEntryAt(i));\n+        }\n+        return beans;\n+    }\n+\n+    /**\n+     * Write this table out as XML.\n+     *\n+     * @param out The stream to write to.\n+     * @throws java.io.IOException if an error occurs while writing.\n+     */\n+    public void writeTo(OutputStream out) throws IOException {\n+        //re-create the sst table every time saving a workbook at the end after adding all record using map DB\n+        try {\n+            Writer writer = new BufferedWriter(new OutputStreamWriter(out, \"UTF-8\"));\n+            addDefaultXmlOptions(writer);\n+            if (uniqueCount != 0) {\n+                addStringItems(writer);\n+                addEndDocument(writer);\n+            }\n+            writer.flush();\n+        } catch (XMLStreamException e) {\n+            throw new RuntimeException(\"Couldn't write to SharedStringsTable\", e);\n+        }\n+    }\n+\n+    private void addDefaultXmlOptions(Writer writer) throws XMLStreamException, IOException {\n+        writer.write(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\r\\n\");\n+        String isNoSIElements = uniqueCount == 0 ? \"/\" : \"\";\n+        writer.write(\"<sst count=\\\"\" + count + \"\\\" uniqueCount=\\\"\" + uniqueCount + \"\\\" xmlns=\\\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\\\"\" + isNoSIElements + \">\");\n+    }\n+\n+    private void addStringItems(Writer writer) throws XMLStreamException, IOException {\n+        for (int i = 0; i < uniqueCount; i++) {\n+            String s = indexVsRecordBasedSTMap.get(i);\n+            writer.write(\"<si>\");\n+            writer.write(s);\n+            writer.write(\"</si>\");\n+        }\n+    }\n+\n+    private void addEndDocument(Writer writer) throws XMLStreamException, IOException {\n+        writer.write(\"</sst>\");\n+    }\n+\n+    @Override\n+    protected void commit() throws IOException {\n+       // createDefaultSSTTableXml();\n+        FileOutputStream sharedStringOutputStream = getSharedStringsTableOutputStream();\n+        writeTo(sharedStringOutputStream);\n+        sharedStringOutputStream.close();\n+    }\n+\n+    private void createDefaultSSTTableXml() throws IOException {         //Todo, check if needed to create default one\n+        _sstDoc = SstDocument.Factory.newInstance();\n+        PackagePart part = getPackagePart();\n+        OutputStream out = part.getOutputStream();\n+        _sstDoc.save(out, options);\n+        out.close();\n+    }\n+\n+    @Override\n+    public void close() throws Exception {\n+        recordVsIndexBasedSTMap.clear();\n+        indexVsRecordBasedSTMap.clear();\n+        recordVsIndexMapDB.close();\n+        indexVsRecordMapDB.close();\n+    }\n+}\nIndex: src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFWorkbook.java\nIDEA additional info:\nSubsystem: com.intellij.openapi.diff.impl.patch.CharsetEP\n<+>UTF-8\n===================================================================\n--- src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFWorkbook.java\t(revision 8bf3ebfcee2e2799486de4ed8a5e063616b4083a)\n+++ src/ooxml/java/org/apache/poi/xssf/usermodel/XSSFWorkbook.java\t(revision )\n@@ -20,27 +20,17 @@\n import static org.apache.poi.xssf.usermodel.helpers.XSSFPaswordHelper.setPassword;\n import static org.apache.poi.xssf.usermodel.helpers.XSSFPaswordHelper.validatePassword;\n \n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n+import java.io.*;\n+import java.lang.reflect.Constructor;\n+import java.util.*;\n import java.util.regex.Pattern;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n \n import javax.xml.namespace.QName;\n \n-import org.apache.poi.POIXMLDocument;\n-import org.apache.poi.POIXMLDocumentPart;\n-import org.apache.poi.POIXMLException;\n-import org.apache.poi.POIXMLProperties;\n+import org.apache.poi.*;\n import org.apache.poi.openxml4j.exceptions.InvalidFormatException;\n import org.apache.poi.openxml4j.exceptions.OpenXML4JException;\n import org.apache.poi.openxml4j.opc.OPCPackage;\n@@ -61,19 +51,9 @@\n import org.apache.poi.ss.util.CellRangeAddress;\n import org.apache.poi.ss.util.CellReference;\n import org.apache.poi.ss.util.WorkbookUtil;\n-import org.apache.poi.util.Beta;\n-import org.apache.poi.util.IOUtils;\n-import org.apache.poi.util.Internal;\n-import org.apache.poi.util.POILogFactory;\n-import org.apache.poi.util.POILogger;\n-import org.apache.poi.util.PackageHelper;\n+import org.apache.poi.util.*;\n import org.apache.poi.xssf.XLSBUnsupportedException;\n-import org.apache.poi.xssf.model.CalculationChain;\n-import org.apache.poi.xssf.model.ExternalLinksTable;\n-import org.apache.poi.xssf.model.MapInfo;\n-import org.apache.poi.xssf.model.SharedStringsTable;\n-import org.apache.poi.xssf.model.StylesTable;\n-import org.apache.poi.xssf.model.ThemesTable;\n+import org.apache.poi.xssf.model.*;\n import org.apache.poi.xssf.usermodel.helpers.XSSFFormulaUtils;\n import org.apache.xmlbeans.XmlException;\n import org.apache.xmlbeans.XmlObject;\n@@ -147,6 +127,11 @@\n     private SharedStringsTable sharedStringSource;\n \n     /**\n+     * shared strings table type- to specify use default or map db shared strings table source\n+     */\n+    private SharedStringsTableType sharedStringsTableType = SharedStringsTableType.DEFAULT_SST;\n+\n+    /**\n      * A collection of shared objects used for styling content,\n      * e.g. fonts, cell styles, colors, etc.\n      */\n@@ -218,12 +203,22 @@\n         onWorkbookCreate();\n     }\n \n+    public XSSFWorkbook(SharedStringsTableType sharedStringsTableType) {\n+        super(newPackage());\n+        this.sharedStringsTableType = sharedStringsTableType;\n+        onWorkbookCreate();\n+    }\n+\n+    public SharedStringsTableType getSharedStringsTableType() {\n+        return sharedStringsTableType;\n+    }\n+\n     /**\n      * Constructs a XSSFWorkbook object given a OpenXML4J <code>Package</code> object,\n      *  see <a href=\"http://poi.apache.org/oxml4j/\">http://poi.apache.org/oxml4j/</a>.\n      * \n      * <p>Once you have finished working with the Workbook, you should close the package\n-     * by calling either {@link #close()} or {@link OPCPackage#close()}, to avoid \n+     * by calling either {@link #close()} or {@link OPCPackage#close()}, to avoid\n      * leaving file handles open.\n      * \n      * <p>Creating a XSSFWorkbook from a file-backed OPC Package has a lower memory\n@@ -338,7 +333,7 @@\n \n             if (sharedStringSource == null) {\n                 // Create SST if it is missing\n-                sharedStringSource = (SharedStringsTable)createRelationship(XSSFRelation.SHARED_STRINGS, XSSFFactory.getInstance());\n+                sharedStringSource = createSSTSourceBasedOnSSTType();\n             }\n             \n             // Load individual sheets. The order of sheets is defined by the order\n@@ -376,6 +371,73 @@\n         }\n     }\n \n+    @Override\n+    public void write(OutputStream stream) throws IOException {\n+        if (getSharedStringsTableType() == SharedStringsTableType.DEFAULT_SST) {\n+            super.write(stream);\n+        } else {\n+            writeWithPatchingMDBSST(stream);\n+        }\n+    }\n+\n+    public void writeWithPatchingMDBSST(OutputStream stream) throws IOException {\n+        //Save the template\n+        File tmplFile = TempFile.createTempFile(\"poi-sxssf-template\", \".xlsx\");\n+        try {\n+            FileOutputStream os = new FileOutputStream(tmplFile);\n+            try {\n+                super.write(os);\n+            } finally {\n+                os.close();\n+            }\n+\n+            //Substitute the template shared string xml with the temporarily generated xml data file\n+            injectSharedStringTableXml(tmplFile, stream);\n+        } finally {\n+            if (!tmplFile.delete()) {\n+                throw new IOException(\"Could not delete temporary file after processing: \" + tmplFile);\n+            }\n+        }\n+    }\n+\n+    private void injectSharedStringTableXml(File zipfile, OutputStream out) throws IOException {\n+        ZipFile zip = new ZipFile(zipfile);\n+        DBMappedSharedStringsTable _sst = (DBMappedSharedStringsTable) sharedStringSource;\n+        try {\n+            ZipOutputStream zos = new ZipOutputStream(out);\n+            try {\n+                Enumeration<? extends ZipEntry> en = zip.entries();\n+                while (en.hasMoreElements()) {\n+                    ZipEntry ze = en.nextElement();\n+                    zos.putNextEntry(new ZipEntry(ze.getName()));\n+                    InputStream is;\n+                    if (ze.getName().equals(\"xl/sharedStrings.xml\")) {\n+                        is = _sst.getSharedStringInputStream(); //injecting shared string table in target output\n+                    } else {\n+                        is = zip.getInputStream(ze);\n+                    }\n+                    copyStream(is, zos);\n+                    is.close();\n+                }\n+            } finally {\n+                zos.close();\n+                if (!_sst.getTemp_shared_string_file().delete()) {\n+                    throw new RuntimeException(\"Couldn't delete temporary shared strings table file.\");\n+                }\n+            }\n+        } finally {\n+            zip.close();\n+        }\n+    }\n+\n+    private static void copyStream(InputStream in, OutputStream out) throws IOException {\n+        byte[] chunk = new byte[1024];\n+        int count;\n+        while ((count = in.read(chunk)) >= 0) {\n+            out.write(chunk, 0, count);\n+        }\n+    }\n+\n     /**\n      * Create a new CTWorkbook with all values set to default\n      */\n@@ -394,12 +456,38 @@\n         POIXMLProperties.ExtendedProperties expProps = getProperties().getExtendedProperties();\n         expProps.getUnderlyingProperties().setApplication(DOCUMENT_CREATOR);\n \n-        sharedStringSource = (SharedStringsTable)createRelationship(XSSFRelation.SHARED_STRINGS, XSSFFactory.getInstance());\n+        sharedStringSource = createSSTSourceBasedOnSSTType();\n-        stylesSource = (StylesTable)createRelationship(XSSFRelation.STYLES, XSSFFactory.getInstance());\n+        stylesSource = (StylesTable) createRelationship(XSSFRelation.STYLES, XSSFFactory.getInstance());\n \n         namedRanges = new ArrayList<XSSFName>();\n         sheets = new ArrayList<XSSFSheet>();\n         pivotTables = new ArrayList<XSSFPivotTable>();\n+    }\n+\n+    private SharedStringsTable createSSTSourceBasedOnSSTType() {\n+        return (SharedStringsTable) createRelationship(XSSFRelation.SHARED_STRINGS, new POIXMLFactory() {\n+            @Override\n+            public POIXMLDocumentPart createDocumentPart(POIXMLDocumentPart parent, PackageRelationship rel, PackagePart part) {\n+                try {\n+                    Class<? extends POIXMLDocumentPart> cls = sharedStringsTableType.getInstance();\n+                    Constructor<? extends POIXMLDocumentPart> constructor = cls.getDeclaredConstructor(PackagePart.class, PackageRelationship.class);\n+                    return constructor.newInstance(part, rel);\n+                } catch (Exception e) {\n+                    throw new POIXMLException(e);\n+                }\n+            }\n+\n+            @Override\n+            public POIXMLDocumentPart newDocumentPart(POIXMLRelation descriptor) {\n+                try {\n+                    Class<? extends POIXMLDocumentPart> cls = sharedStringsTableType.getInstance();\n+                    Constructor<? extends POIXMLDocumentPart> constructor = cls.getDeclaredConstructor();\n+                    return constructor.newInstance();\n+                } catch (Exception e) {\n+                    throw new POIXMLException(e);\n+                }\n+            }\n+        });\n     }\n \n     /**\nIndex: maven/poi-ooxml.pom\nIDEA additional info:\nSubsystem: com.intellij.openapi.diff.impl.patch.CharsetEP\n<+>UTF-8\n===================================================================\n--- maven/poi-ooxml.pom\t(revision 8bf3ebfcee2e2799486de4ed8a5e063616b4083a)\n+++ maven/poi-ooxml.pom\t(revision )\n@@ -69,5 +69,10 @@\n       <artifactId>poi-ooxml-schemas</artifactId>\n       <version>@VERSION@</version>\n     </dependency>\n+    <dependency>\n+      <groupId>org.mapdb</groupId>\n+      <artifactId>mapdb</artifactId>\n+      <version>1.0.6</version>\n+      </dependency>\n   </dependencies>\n </project>", "id": 180047, "time": "2014-12-29T08:29:28Z", "bug_id": 57401, "creation_time": "2014-12-29T08:29:28Z", "is_private": false}, {"count": 2, "tags": [], "bug_id": 57401, "text": "Created attachment 32334\npatch wiht minor changes", "id": 180048, "time": "2014-12-29T08:32:20Z", "creator": "rksuthar19@gmail.com", "creation_time": "2014-12-29T08:32:20Z", "is_private": false, "attachment_id": 32334}, {"count": 3, "tags": [], "bug_id": 57401, "text": "Created attachment 32335\n[patch-alternate way] attaching patch to Integrating DBMappedSharedStringsTable by using SharedStringsTableType in SXSSFWorkbook\n\nIn earlier submitted path using DBMappedSharedStringsTable option (which provide use flexibility to use DBMapped SharedStringsTable) was included in XSSSFWorkbook.\n\nI am attaching alternate solution to Integrate DBMappedSharedStringsTable option by using SharedStringsTableType enum in SXSSFWorkbook where user can specify whether to use default or custom SharedStringsTable soucre. \nThis seems more cleaner and appropriate way to integrate it.\n\nThanks,\nRakesh Kumar Suthar", "id": 180071, "time": "2014-12-30T09:06:23Z", "creator": "rksuthar19@gmail.com", "creation_time": "2014-12-30T09:06:23Z", "is_private": false, "attachment_id": 32335}, {"count": 4, "tags": [], "bug_id": 57401, "text": "Created attachment 32336\nheap usage comparison 1,00,000 unique record of 100 char between default SharedStringTable vs SharedStringsTable Using MapDB", "id": 180072, "time": "2014-12-30T09:52:20Z", "creator": "rksuthar19@gmail.com", "creation_time": "2014-12-30T09:52:20Z", "is_private": false, "attachment_id": 32336}, {"count": 5, "tags": [], "bug_id": 57401, "is_private": false, "id": 180073, "creation_time": "2014-12-30T09:54:05Z", "time": "2014-12-30T09:54:05Z", "creator": "rksuthar19@gmail.com", "text": "Created attachment 32337\nheap usage comparison 1,00,000 unique record of 1000 char between default SharedStringTable vs SharedStringsTable Using MapDB", "attachment_id": 32337}, {"count": 6, "tags": [], "bug_id": 57401, "is_private": false, "text": "Created attachment 32338\nheap usage comparison 10,00,000 unique record of 1000 char between default SharedStringTable vs SharedStringsTable Using MapDB", "id": 180074, "time": "2014-12-30T09:55:12Z", "creator": "rksuthar19@gmail.com", "creation_time": "2014-12-30T09:55:12Z", "attachment_id": 32338}, {"count": 7, "attachment_id": null, "creator": "onealj@apache.org", "text": "Sounds like a cool implementation, though it would add another dependency to the project. It could be bundled into the poi-ooxml jar or could be required as an external dependency.\n\nIt might be worth providing all 3 options to the user: internal shared strings table, inline, MappedDB, with inline being default for SXSSFWorkbooks.", "id": 186626, "time": "2015-11-28T20:13:55Z", "bug_id": 57401, "creation_time": "2015-11-28T20:13:55Z", "tags": [], "is_private": false}]