[{"attachment_id": null, "tags": [], "bug_id": 12632, "is_private": false, "count": 0, "id": 22849, "time": "2002-09-13T20:46:25Z", "creator": "ddevienne@lgc.com", "creation_time": "2002-09-13T20:46:25Z", "text": "Uses internally the <copy> task to perform all the copies, and then removes \nfrom the destination directory all the files (and optionally empty directories \nwhen includeEmptyDirs in not true) which have not been selected by the input \n<fileset>s (what I call dangling files).\n\nNote that not all attributes/sub-elements of <copy> are exposed in <lsync>, as \nfilter chains, mappers, and global filtering would interfere with the syncing. \nAlso not that is as the same limitations as <copy> (since using it), so an \nexisting destination file having the same date as its source while still being \ndifferent will not be copied... Also, since multiple filesets are allowed by \n<copy>, one could have several source files for a single destination file... \nBehavior is undetermined in this case!\n\nHope someone finds this useful. Thanks, --DD\n\nSample usage:\n  <target name=\"sources\"\n          depends=\"-buildmagic\"\n          description=\"Copies the sources from DS_HOME for this module\">\n    <mkdir dir=\"${src}\" />\n    <lsync todir=\"${src}\">\n      <fileset refid=\"sources\" />\n    </lsync>\n  </target>\n\nSample output:\nsources:\nRemoved 120 dangling files from P:\\com_lgc\\dsp\\dsp-core\\da\\src\nRemoved 40 empty directories from P:\\com_lgc\\dsp\\dsp-core\\da\\src\n\nWhen no files not present in the source input fileset exist, the output is the \nsame as <copy>. When such files exist, output is as above."}, {"count": 1, "tags": [], "bug_id": 12632, "text": "Created attachment 3059\nSingle Java source file for <lsync> task (LocalSynchronize.java)", "id": 22850, "time": "2002-09-13T20:47:23Z", "creator": "ddevienne@lgc.com", "creation_time": "2002-09-13T20:47:23Z", "is_private": false, "attachment_id": 3059}, {"count": 2, "tags": [], "bug_id": 12632, "text": "Do you really need to taskdef your own copy subclass?  If so, I think you are\nexposing (yet another) design flaw in Ant.\n\n", "id": 22916, "time": "2002-09-16T15:33:56Z", "creator": "bodewig@apache.org", "creation_time": "2002-09-16T15:33:56Z", "is_private": false, "attachment_id": null}, {"count": 3, "tags": [], "text": "Honestly, I don't Stefan...\n\nI know I need to use a sub-class of Copy/<copy>, since I want to intercept the \ncall to a protected method. And I need to internally create this custom MyCopy \ntask.\n\nThe way I have composed existing tasks in the recent past was to use \nProject#createTask, as this seems to have been the recommended way. I was not \nvery sure how to properly initialize the custom task, so I went the easy route \n(and safe route I felt as well) of taskdefing it using a unique name so that \nProject#createTask would work.\n\nSo I guess the answer is probably NO. I don't need it, I just did it that way \nbecause I didn't know the right way to do it otherwise (or even what was the \ncorrect way in this situation).\n\nI'll happily change that to whatever you tell me is the correct way of doing \nthis.\n\nThanks for your comments. --DD", "is_private": false, "id": 22917, "creation_time": "2002-09-16T15:49:54Z", "time": "2002-09-16T15:49:54Z", "creator": "ddevienne@lgc.com", "bug_id": 12632, "attachment_id": null}, {"count": 4, "tags": [], "bug_id": 12632, "text": "So you think it will bubble up my patch queue faster if you do as I say instead\nof convincing my that your way is correct? ;-)\n\nSeriously.  If I had written that task, I would have taken an entirely different\nroute (and ended up scanning each directory at least twice instead\nof once 8-), something that delegates to <copy> and <delete>, each using\n<present> selectors under the covers.  Your approach is superior to that.\n\nOK, instead of using Project#createTask (I see you've done what CallTarget\ndoes), I'd probably instantiate the subclass directly, call setProject on it\nand that's it.  I'd assume you don't need to set the owning target or the \ntask's name, but I may be wrong in the presence of BuildListeners.\n\nGive us a testcase, pretty please 8-)\n", "id": 22925, "time": "2002-09-16T16:31:40Z", "creator": "bodewig@apache.org", "creation_time": "2002-09-16T16:31:40Z", "is_private": false, "attachment_id": null}, {"count": 5, "tags": [], "bug_id": 12632, "text": "Created attachment 3857\nLatest version of <lsync> task implementing Stefan's suggestion", "id": 26382, "time": "2002-11-15T13:57:47Z", "creator": "ddevienne@lgc.com", "creation_time": "2002-11-15T13:57:47Z", "is_private": false, "attachment_id": 3857}, {"count": 6, "tags": [], "bug_id": 12632, "text": "I tried this out, and it worked nearly perfect for me.\n\nThe one thing that it doesn't do it remove orphaned directories.\n\nI changed the removeOrphanedFilesMethod to the following:\n\n\tprivate int removeOrphanFiles(Hashtable nonOrphans, File file) {\n\t\tint removedCount = 0;\n\t\tif (file.isDirectory()) {\n\t\t\tFile[] children = file.listFiles();\n\t\t\tfor (int i=0; i<children.length; ++i) {\n\t\t\t\tremovedCount += removeOrphanFiles(nonOrphans, children[i]);\n\t\t\t}\n\t\t\tif (nonOrphans.get(file) == null) {\n\t\t\t\tlog(\"Removing orphan directory: \"+file, Project.MSG_DEBUG);\n\t\t\t\tfile.delete();\n\t\t\t\t++removedCount;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (nonOrphans.get(file) == null) {\n\t\t\t\tlog(\"Removing orphan file: \"+file, Project.MSG_DEBUG);\n\t\t\t\tfile.delete();\n\t\t\t\t++removedCount;\n\t\t\t}\n\t\t}\n\t\treturn removedCount;\n\t}\n\nto cause it to remove orphaned directories.  This works perfectly (in function)\nhowever, the messages printed to the screen are now incorrect, as it counts the\nremoved directories as files.  I'm not very familiar with ant tasks, and the\nsyntax of writing the log output, and I'm not sure how the author would like to\nfix this.  Suggestions?\n", "id": 29571, "time": "2003-01-16T22:44:05Z", "creator": "daniel.armbrust@mayo.edu", "creation_time": "2003-01-16T22:44:05Z", "is_private": false, "attachment_id": null}, {"count": 7, "attachment_id": null, "creator": "daniel.armbrust@mayo.edu", "text": "Ok, I thought about it another minute, and fixed the logging issue.  However,\nits a hack [I changed the return type to an int[], and then used position 0 for\ndirectories, and position 1 for files] - If you want the hack I'll post it.  But\nI don't think it fits well with the rest of the well designed class.", "id": 29572, "time": "2003-01-16T23:00:48Z", "bug_id": 12632, "creation_time": "2003-01-16T23:00:48Z", "tags": [], "is_private": false}, {"count": 8, "tags": [], "creator": "ddevienne@lgc.com", "attachment_id": null, "is_private": false, "id": 29574, "time": "2003-01-16T23:03:47Z", "bug_id": 12632, "creation_time": "2003-01-16T23:03:47Z", "text": "From the code, it looks like it should correctly remove empty directories, but \nonly if the 'includeEmptyDirs' attribute of the <fileset> is not set to (true). \nOrphan files are deleted on PASS#2, and empty directories are deleted on PASS#3 \n(see below).\n\nCould it be the problem you are seeing? Thanks, --DD\n\n        // Get rid of empty directories on the destination side\n        if (!_copy.getIncludeEmptyDirs()) {\n            log(\"PASS#3: Removing empty directories from \"+toDir,\n                Project.MSG_DEBUG);\n            int removedDirCount = removeEmptyDirectories(toDir, false);\n            logRemovedCount(removedDirCount, \"empty director\", \"y\", \"ies\");\n        }\n\n"}, {"attachment_id": null, "tags": [], "bug_id": 12632, "is_private": false, "count": 9, "id": 29576, "time": "2003-01-16T23:18:15Z", "creator": "daniel.armbrust@mayo.edu", "creation_time": "2003-01-16T23:18:15Z", "text": "Pass3 was working correctly.  However, I DO want it to include empty\ndirectories., so pass 3 is not executed.  But I also want it to also remove\norphaned empty directories.  This is the case that I submitted code for, which\nwas a modified version of case 2."}, {"attachment_id": 4477, "tags": [], "bug_id": 12632, "is_private": false, "count": 10, "id": 29622, "time": "2003-01-17T17:48:02Z", "creator": "daniel.armbrust@mayo.edu", "creation_time": "2003-01-17T17:48:02Z", "text": "Created attachment 4477\nRevised to remove orphaned directories."}, {"attachment_id": null, "tags": [], "bug_id": 12632, "is_private": false, "count": 11, "id": 29623, "time": "2003-01-17T17:50:05Z", "creator": "daniel.armbrust@mayo.edu", "creation_time": "2003-01-17T17:50:05Z", "text": "I have finished my mucking to repair pass 2 (removing orphaned files - on second\nthought, its not really a repair, but an extension.  In my opinion, if you ask\nit to removed orphaned files, it should remove orphaned files and orphaned\ndirectories).\n\nI have attached the class in its entirity.\n\nHere are the changes in diff format:\n\n<         int removedFileCount = removeOrphanFiles(allFiles, toDir);\n<         logRemovedCount(removedFileCount, \"dangling file\", \"\", \"s\");\n---\n>               int[] removedFileCount = removeOrphanFiles(allFiles, toDir);\n>               logRemovedCount(removedFileCount[0], \"dangling director\", \"y\",\n\"ies\");\n>               logRemovedCount(removedFileCount[1], \"dangling file\", \"\", \"s\");\n110c111\n<      * Removes all files not found as keyes of a table (used as a set!).\n---\n>        * Removes all files and folders not found as keyes of a table (used as\na set!).\n114a116,117\n>        * If the directory is an orphan, it will also be removed.\n>        *\n117c120,123\n<      * @return the number of orphaned files actually removed.\n---\n>        * @return the number of orphaned files and directories actually removed.\n>        * Position 0 of the array is the number of orphaned directories.\n>        * Position 1 of the array is the number or orphaned files.\n>        * Position 2 is meaningless.\n119,120c125,126\n<     private int removeOrphanFiles(Hashtable nonOrphans, File file) {\n<         int removedCount = 0;\n---\n>       private int[] removeOrphanFiles(Hashtable nonOrphans, File file) {\n>               int[] removedCount = new int[]{0, 0, 0};\n124c130,154\n<                 removedCount += removeOrphanFiles(nonOrphans, children[i]);\n---\n>                               int[] temp = removeOrphanFiles(nonOrphans,\nchildren[i]);\n>                               removedCount[0] += temp[0];\n>                               removedCount[1] += temp[1];\n>                               removedCount[2] += temp[2];\n>                       }\n>                       if (nonOrphans.get(file) == null && removedCount[2] == 0) {\n>                               log(\"Removing orphan directory: \"+file,\nProject.MSG_DEBUG);\n>                               file.delete();\n>                               ++removedCount[0];\n>                       }\n>                       else {\n>                               /*\n>                               Contrary to what is said above, position 2 is\nnot meaningless inside the recursion.\n>                               Position 2 is used to carry information back up\nthe recursion about whether or not\n>                               a directory contains a directory or file at any\ndepth that is not an orphan\n>                               This has to be done, because if you have the\nfollowing directory structure:\n>                               c:\\src\\a\\file\n>                               and your mapper src files were constructed like so:\n>                               <include name=\"**\\a\\**\\*\"/>\n>                               The folder 'a' will not be in the hashtable of\nnonorphans.  So, before deleting it as\n>                               an orphan, we have to know whether or not any of\nits children at any level are orphans.\n>                               If no, then this folder is also an orphan, and\nmay be deleted.  I do this by changing\n>                               position 2 to a '1'.\n>                               */\n>                               removedCount[2] = 1;\n131c161,164\n<                 ++removedCount;\n---\n>                               ++removedCount[1];\n>                       }\n>                       else {\n>                               removedCount[2] = 1;\n\n\nThe way I implemented this felt like sort of a hack.  But I don't know a better\nway to do it.  It has tested correctly in all of my use cases, but I am not well\nversed in ANT, so there may be problems that I have introduced in other use cases.  \n\nFeedback welcome!  Especially if you can think of a better way to implement my\nchanges."}, {"count": 12, "tags": [], "bug_id": 12632, "is_private": false, "text": "Another issue that I ran into using the synchronize task is a problem with the\ncopy task when it interacts with a samba mounted file system from linux/unix\nmachine while the ant task is running on a windows machine.\n\nI had 3 different files that I created on the ntfs drive (all done from a W2K\nmachine).  I then copied the three files to the samba share mounted drive.\nHere are the last 5 digits of the time stamps that the java vm reports.  I don't\nunderstand its behavior... As some round down, and some up.  \n\n\t\t\tFile a\tFile b\tFile c\nLocal NTFS\t\t35062\t87359\t18093\nMounted via samba\t36000\t88000\t18000\n\nAs you can imagnine, this leads to a lot of unnecessary file copying by the\nsynchronize task, as file c would have been recopied, even though it doesn't\nneed to be.\n\nTo fix this, I added a dateSlop feature to the synchronize, copy, and\nsourceFileScanner tasks/routines, so that by passing in a true for dateSlop, it\nwould only copy files that are more than 1 second apart from each other in their\ntime stamps.  I dont expect that my way of fixing this would be allowed by the\nmaintainers of ant (its really a hack) but this bug also makes synchronize\nworthless between ntfs and samba shares unless it is fixed.  I dont know a\nbetter way to fix it.  Suggestions?  I hope that a fix of some sort for this bug\nis thought about and implemented at the same time that the synchronize task is\nadded.\n\nI'm going to file it as a bug on the copy task.\n", "id": 29725, "time": "2003-01-20T18:46:56Z", "creator": "daniel.armbrust@mayo.edu", "creation_time": "2003-01-20T18:46:56Z", "attachment_id": null}, {"count": 13, "tags": [], "text": "Given this here\n\n> Copyright (c) 2002, Landmark Graphics Corp\n\nwe'll probably need you to sign a software-grant form, Dominique.  I'll send it to\nyou.\n", "is_private": false, "id": 31999, "creator": "bodewig@apache.org", "time": "2003-02-26T13:43:51Z", "bug_id": 12632, "creation_time": "2003-02-26T13:43:51Z", "attachment_id": null}, {"count": 14, "tags": [], "bug_id": 12632, "text": "OK, I've added the task more or less as is (renamed the class, repackaged it and\nchanged the formatting a little), but that's it.  <sync> should be in nightly\nbuild 2003-03-26.\n\nThings that are missing:\n\n* documentation\n* tests\n\nThings I'd like to do before the 1.6 release:\n\n* revisit the need for MyCopy\n* maybe introduce some kind of plugin architecture that would allow using rsync\n  instead of the built-in synchronization mechanism\n", "id": 33736, "time": "2003-03-25T09:35:40Z", "creator": "bodewig@apache.org", "creation_time": "2003-03-25T09:35:40Z", "is_private": false, "attachment_id": null}, {"count": 15, "tags": [], "bug_id": 12632, "text": "Could this bug (16270) possibly be visited as well, before the 1.6 release?", "id": 34078, "time": "2003-03-28T18:05:30Z", "creator": "daniel.armbrust@mayo.edu", "creation_time": "2003-03-28T18:05:30Z", "is_private": false, "attachment_id": null}]