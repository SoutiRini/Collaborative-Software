[{"count": 0, "tags": [], "bug_id": 18500, "is_private": false, "text": "I would like hosts to match aliases by regular expression instead of exact \nmatch.  This can be done trivially with the following patch under 1.4 (or under \nprevious VMs by using Jakarta Regexp):\n\n--- StandardEngineMapper.java.bak       2003-03-19 10:18:38.000000000 -0500\n+++ StandardEngineMapper.java   2003-03-30 12:13:13.000000000 -0500\n@@ -205,7 +205,7 @@\n             for (int i = 0; i < children.length; i++) {\n                 String aliases[] = ((Host) children[i]).findAliases();\n                 for (int j = 0; j < aliases.length; j++) {\n-                    if (server.equals(aliases[j])) {\n+                    if (server.matches(aliases[j])) {\n                         host = (Host) children[i];\n                         break;\n                     }", "id": 34132, "time": "2003-03-30T17:20:09Z", "creator": "arh14@cornell.edu", "creation_time": "2003-03-30T17:20:09Z", "attachment_id": null}, {"count": 1, "tags": [], "bug_id": 18500, "is_private": false, "text": "*** Bug 7676 has been marked as a duplicate of this bug. ***", "id": 134240, "time": "2010-02-04T12:26:39Z", "creator": "markt@apache.org", "creation_time": "2010-02-04T12:26:39Z", "attachment_id": null}, {"count": 2, "tags": [], "creator": "markt@apache.org", "attachment_id": null, "is_private": false, "id": 144783, "time": "2011-03-06T17:35:47Z", "bug_id": 18500, "creation_time": "2011-03-06T17:35:47Z", "text": "Whilst this would have been trivial in 4.1.x, the Mapper was re-written and adding regular expression support for aliases is non-trivial in all supported Tomcat versions.\n\nIf this is implemented, it will be in 7.0.x or later so updating version."}, {"count": 3, "tags": [], "creator": "markt@apache.org", "attachment_id": null, "is_private": false, "id": 146657, "time": "2011-05-26T13:03:57Z", "bug_id": 18500, "creation_time": "2011-05-26T13:03:57Z", "text": "*** Bug 51269 has been marked as a duplicate of this bug. ***"}, {"count": 4, "tags": [], "bug_id": 18500, "attachment_id": null, "text": "With the re-factoring of the mapper since this was requested it is no longer trivial so edit the title", "id": 148530, "time": "2011-08-10T18:20:55Z", "creator": "markt@apache.org", "creation_time": "2011-08-10T18:20:55Z", "is_private": false}, {"count": 5, "tags": [], "bug_id": 18500, "is_private": false, "text": "Unfortunately for this enhancement, the Mapper is written to use a relatively high-performance binary search algorithm to find a matching <Host> given all the <Host> and <Alias> definitions (where <Alias>es are basically treated as if they were additional <Host> definitions with shared configuration information).\n\nSuch an algorithm can't work with regular expressions because they can't be sorted in any sane way. Thus, a linear search would have to be performed which will degrade performance (along with the execution of all those regular expression matches).\n\nIf we're going to do this, I would recommend that we add another layer of abstraction near the insertMap/find/findIgnoreCase mechanism. Something along these lines:\n\n1. The Mapper works exactly as it currently does under \"normal\" operations.\n2. When a Host (or Alias) is added with special markings (say, leading and trailing \"/\" marks which are easily recognizable and otherwise illegal in a hostname), we switch into \"regex mode\".\n3. Entering into regex mode creates another List/Map/whatever of metadata that will need to be maintained: existing <Hosts> are processed-into this data structure.\n4. Hosts (and Aliases) added after going into regex mode will of course have this metadata updated as appropriate\n5. In internalMap, modify the call to findIgnoreCase depending upon the current mode: if we're in \"normal\" mode, just call findIgnoreCase and move-on; if we're in \"regex\" mode, make a different call that uses the aforementioned metadata to find the proper index into the <Host> array\n\nThis could be done by re-factoring the Mapper to use a pair of new private inner classes: one that behaves like the current implementation, and one that works with regular expressions. Switching from one mode to the other could be done by replacing the currently-effective Mapper with one of the other type. You could even go back if you really wanted to.\n\nWe will need a policy of conflict resolution: more than one <Host> could match. We can't use a policy like \"longest match wins\" because it's tough to tell which regex is \"longer\" due to their complexities. I would favor a linear search where the first-defined <Host> wins. The Digester should give us all <Host> elements in XML-order, so the user can specify the order of preference just by ordering server.xml to their liking.\n\nThoughts?", "id": 149547, "time": "2011-09-20T21:33:24Z", "creator": "chris@christopherschultz.net", "creation_time": "2011-09-20T21:33:24Z", "attachment_id": null}, {"count": 6, "tags": [], "text": "Since last time when I participated in discussion of such a feature [1] my thought is\n\n- start processing in the Mapper with the currently implemented binary search\n- iff the binary search has not found a match, proceed with alternative match algorithms (regexps, wildcards, etc.)\n- fallback to using the default host\n\n[1] \"Several hosts within one tomcat / catch-all problem\"\nhttp://marc.info/?t=129018176200002&r=1&w=2\nhttp://markmail.org/thread/si3msz4fstgbfenq", "is_private": false, "bug_id": 18500, "id": 149557, "time": "2011-09-21T00:04:47Z", "creator": "knst.kolinko@gmail.com", "creation_time": "2011-09-21T00:04:47Z", "attachment_id": null}, {"count": 7, "tags": [], "text": "Konstantin, in that case we would just maintain a separate list of regex-based <Host> matchers and they would all be consulted if no exact match was found, right? Fall-back is the same.\n\nYour suggestion is certainly simpler than mine, and will perform better when there are mixed regex/non-regex <Host> declarations.", "attachment_id": null, "bug_id": 18500, "id": 149637, "time": "2011-09-22T16:01:00Z", "creator": "chris@christopherschultz.net", "creation_time": "2011-09-22T16:01:00Z", "is_private": false}, {"count": 8, "tags": [], "text": "(In reply to comment #7)\n> Konstantin, in that case we would just maintain a separate list of regex-based\n> <Host> matchers and they would all be consulted if no exact match was found,\n> right? Fall-back is the same.\n> \n> Your suggestion is certainly simpler than mine, and will perform better when\n> there are mixed regex/non-regex <Host> declarations.\n\nYes. That is the idea.\n\nThe thread I linked in comment 6 proposes yet another matching:\n*.domainname\n\nThat is suffix matching,  like the one you can use when configuring your DNS, or when purchasing an SSL certificate for your site.", "attachment_id": null, "bug_id": 18500, "id": 149723, "time": "2011-09-25T00:13:23Z", "creator": "knst.kolinko@gmail.com", "creation_time": "2011-09-25T00:13:23Z", "is_private": false}, {"count": 9, "tags": [], "text": "Suffix-matching would certainly be faster than regular expression matching, but it has the same problems the regex's have with not being sortable, etc.\n\nSuffix-matching seems (to me) to be much more practically useful than complete regular-expression support, but I always just use a single default host, so what do I know?\n\nI just wouldn't watch to mix-and-match too many name-matching styles or things are going to get seriously ridiculous (exact-match, then suffix-match, then regex-match, then what next?).\n\nI do agree that keeping the existing code in there is a good thing: most folks don't need regex-matching and so the binary search is a good implementation. The question is how many other strategies are worth implementing /after/ an exact-match is not found?", "is_private": false, "bug_id": 18500, "id": 149776, "time": "2011-09-26T19:10:58Z", "creator": "chris@christopherschultz.net", "creation_time": "2011-09-26T19:10:58Z", "attachment_id": null}, {"count": 10, "tags": [], "bug_id": 18500, "attachment_id": null, "id": 149789, "time": "2011-09-27T01:12:47Z", "creator": "knst.kolinko@gmail.com", "creation_time": "2011-09-27T01:12:47Z", "is_private": false, "text": "(In reply to comment #9)\n> I just wouldn't watch to mix-and-match too many name-matching styles or things\n> are going to get seriously ridiculous (exact-match, then suffix-match, then\n> regex-match, then what next?).\n> \n> The question is how many other strategies are worth implementing /after/ an\n> exact-match is not found?\n\nI think it is just a single strategy: iterate linearly over list, trying each candidate whether it matches or not.\n\nThe candidate implements its matching algorithm by itself. For <Alias> value written as *.foo it can be suffix matching, and for /foo/ it can be Regexp matching. Or implement separate <AliasRegexp> element.\n\nI do not see any alternative to linear search here.\n\nThe search order probably depends on the order in web.xml (and will change if some hosts are stopped and started again through JMX or host-manager)."}, {"count": 11, "tags": [], "creator": "chris@christopherschultz.net", "attachment_id": null, "is_private": false, "id": 149854, "time": "2011-09-27T18:06:26Z", "bug_id": 18500, "creation_time": "2011-09-27T18:06:26Z", "text": "(In reply to comment #10)\n> I think it is just a single strategy: iterate linearly over list, trying each\n> candidate whether it matches or not.\n\nOh, I meant \"do we support suffix matches only, or do we also support regular expression matches\", not \"how do you iterate over those items\"? :)\n\n> The search order probably depends on the order in web.xml (and will change if\n> some hosts are stopped and started again through JMX or host-manager).\n\nAgreed. I suppose if there's a base class or interface to represents a matchable item (and probably a factory that knows how to convert, say \"/host/\" or \"*.host\" into the appropriate subtype), then there's no limit to the complexity that can be introduced.\n\nI'll take a stab at this."}, {"count": 12, "tags": [], "bug_id": 18500, "is_private": false, "text": "This feature would be very, very appreciated since apache supports wildcard aliases and it is usually used as a frontend for tomcat.\n\nI think that suffix-match would be more than enough for a first implementation, since it has most real-world use-cases.", "id": 169320, "time": "2013-08-09T08:50:32Z", "creator": "alex@nibbles.it", "creation_time": "2013-08-09T08:50:32Z", "attachment_id": null}, {"count": 13, "tags": [], "bug_id": 18500, "attachment_id": null, "id": 169323, "time": "2013-08-09T13:41:16Z", "creator": "chris@christopherschultz.net", "creation_time": "2013-08-09T13:41:16Z", "is_private": false, "text": "My stab has obviously languished, here. I'll take another look at this because I do in fact think it's quite useful.\n\nAlessandro, I'm interested in what your use-case is where you have a fronting httpd but still need to multiplex between different <Hosts> in Tomcat. Do you have a complex configuration where different webapps are (exclusively) available to different hosts?"}, {"count": 14, "tags": [], "text": "Hello Christopher,\nI've some setups where multiple (and different) web apps use domains of the form locale.mydomain.com to automatically select the language of the site.\n\nOf course in the conffig I can list all the supported language but they may be many tens and a wildcard would be much simpler.\n\nOn another use case there are some webapps that uses subdomain like x.mydomain.com to generate some kind of (dynmical) custom blog or report, and in that situation the wildcard is essential because the name of the subdomain can't be known in advance.\n\nI usually use multiple tomcat instances, each with a default webapp for this situation.", "is_private": false, "bug_id": 18500, "id": 169324, "time": "2013-08-09T14:00:02Z", "creator": "alex@nibbles.it", "creation_time": "2013-08-09T14:00:02Z", "attachment_id": null}, {"count": 15, "tags": [], "bug_id": 18500, "attachment_id": null, "id": 169329, "time": "2013-08-09T15:42:27Z", "creator": "chris@christopherschultz.net", "creation_time": "2013-08-09T15:42:27Z", "is_private": false, "text": "Which of those cases can't be solved trivially with a catch-all default host? You are not required to explicitly specify every hostname that a client might use."}, {"count": 16, "tags": [], "text": "As I explained, I'm actually using a default host but if you have more that one host with wildcards you end up using multiple tomcat instances, and that's far from ideal.", "is_private": false, "bug_id": 18500, "id": 169331, "time": "2013-08-09T16:17:52Z", "creator": "alex@nibbles.it", "creation_time": "2013-08-09T16:17:52Z", "attachment_id": null}, {"count": 17, "tags": [], "bug_id": 18500, "is_private": false, "text": "The rewrite valve that is now in Tomcat 8 supports vhost rewriting.", "id": 169369, "time": "2013-08-12T15:03:10Z", "creator": "remm@apache.org", "creation_time": "2013-08-12T15:03:10Z", "attachment_id": null}, {"count": 18, "tags": [], "bug_id": 18500, "is_private": false, "text": "How the rewrite valve could solve this problem?", "id": 169370, "time": "2013-08-12T15:38:45Z", "creator": "alex@nibbles.it", "creation_time": "2013-08-12T15:38:45Z", "attachment_id": null}, {"count": 19, "tags": [], "creator": "markt@apache.org", "attachment_id": null, "is_private": false, "id": 192080, "time": "2016-07-03T20:26:11Z", "bug_id": 18500, "creation_time": "2016-07-03T20:26:11Z", "text": "I've added support for wildcard hosts in 9.0.x which will be in 9.0.0.M9. Providing feedback is positive, I'll back-port it to at least 8.5.x."}, {"count": 20, "tags": [], "bug_id": 18500, "is_private": false, "text": "It has been back-ported to 8.5.x for 8.5.5 onwards.\n\nI don't propose back-porting it further.", "id": 192767, "time": "2016-08-01T09:54:55Z", "creator": "markt@apache.org", "creation_time": "2016-08-01T09:54:55Z", "attachment_id": null}]