[{"count": 0, "tags": [], "creator": "norair@freenet.am", "text": "When running apache versions 2.0.52 2.0.53, 2.0.54 with following simple module\nmemory usage continuing its grow until all memory and swap is used, after which\nsystem killing processes to free resources. I've tried this module with worker\nand prefork mpm compiled httpd's on a 2.4 and 2.6 kernel running machines\n(debian and fedora core).\nPlease, try to establish 500 - 1000 connections to module below and see what\nhappens with memory usage. Apache just killing the system when occupy all\navailable memory and swap space. In case of low number of connections, memory\nusage still grow but not so fast, so will be noticed after certain time interval\n\nmodule text:\n--------------------------\n\n#include \"httpd.h\"\n#include \"http_config.h\"\n\n#include <time.h>\n#include <sys/time.h>\n#include <stdio_ext.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"inc/sp.h\"\n\n\n\n#define DEFAULT_ENCTYPE \"application/x-www-form-urlencoded\"\n\n\nint start_receive(request_rec *r)\n{\n\tint ret;\n\n        while(TRUE)\n\t{\n          ret = ap_rprintf (r, \"888839457349857394573495888888888888888\\r\\n\");\n\t  ret = ap_rflush(r);\n\t  sleep(1);  \n        }\n\t\n\treturn 0;\n}\n\n/*\n * This function is registered as a handler for HTTP methods and will\n * therefore be invoked for all GET requests (and others).  Regardless\n * of the request type, this function simply sends a message to\n * STDERR (which httpd redirects to logs/error_log).  A real module\n * would do *alot* more at this point.\n */\n\nstatic int receiver_method_handler (request_rec *r)\n{\n    char* req;\n    int\t ret;\n    apr_table_t*\ttable;  \n\n    req = r->the_request;\n    if (strstr(req, \"messages\") == NULL) {\n       return DECLINED;\n    }\n    \n    table = apr_table_make(r->pool, 8);\n   \n    ret = read_post(r, &table);\n    \n    start_receive(r);\n\n    return OK;\n}\n\n/*\n * This function is a callback and it declares what other functions\n * should be called for request processing and configuration requests.\n * This callback function declares the Handlers for other events.\n */\nstatic void register_hooks (apr_pool_t *p)\n{\n\t// I think this is the call to make to register a handler for method calls (GET\nPUT et. al.).\n\t// We will ask to be last so that the comment has a higher tendency to\n\t// go at the end.\n\tap_hook_handler(receiver_method_handler, NULL, NULL, APR_HOOK_LAST);\n}\n\n/*\n * Declare and populate the module's data structure.  The\n * name of this structure ('rec_mod') is important - it\n * must match the name of the module.  This structure is the\n * only \"glue\" between the httpd core and the module.\n */\nmodule AP_MODULE_DECLARE_DATA receiver_module =\n{\n\t// Only one callback function is provided.  Real\n\t// modules will need to declare callback functions for\n\t// server/directory configuration, configuration merging\n\t// and other tasks.\n\tSTANDARD20_MODULE_STUFF,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tregister_hooks,\t\t\t/* callback for registering hooks */\n};\n\n\nstatic int util_read(request_rec *r, const char **rbuf)\n{\n   int rc;\n   if ((rc = ap_setup_client_block(r, REQUEST_CHUNKED_ERROR)) != OK) {\n      return rc;\n   }\n   if (ap_should_client_block(r)) {\n     char argsbuffer[HUGE_STRING_LEN];\n     int rsize, len_read, rpos=0;\n     long length = r->remaining;\n     *rbuf = apr_pcalloc(r->pool, length + 1);\n//     ap_hard_timeout(\"util_read\", r);\n     while ((len_read = ap_get_client_block(r, argsbuffer, sizeof(argsbuffer)))\n> 0) {\n//       ap_reset_timeout(r);\n       if ((rpos + len_read) > length) {\n         rsize = length - rpos;\n       }\n       else {\n         rsize = len_read;\n       }\n       memcpy((char*)*rbuf + rpos, argsbuffer, rsize);\n       rpos += rsize;\n    }\n//    ap_kill_timeout(r);\n  }\n  return rc;\n}\n\n\nstatic int read_post(request_rec *r, apr_table_t **tab)\n{\n   const char *data;\n   const char *key, *val, *type;\n   int rc = OK;\n   if(r->method_number != M_POST) {\n     return rc;\n   }\n   type = apr_table_get(r->headers_in, \"Content-Type\");\n   if(strcasecmp(type, DEFAULT_ENCTYPE) != 0) {\n         return DECLINED;\n   }\n   if((rc = util_read(r, &data)) != OK) {\n     return rc;\n   }\n   if(*tab) {\n     apr_table_clear(*tab);\n   }\n   else {\n     *tab = apr_table_make(r->pool, 8);\n   }\n   while(*data && (val = ap_getword(r->pool, &data, '&'))) {       \n     key = ap_getword(r->pool, &val, '=');\n     ap_unescape_url((char*)key);\n     ap_unescape_url((char*)val);\n     apr_table_merge(*tab, key, val);\n   }\n   return OK;\n}\n\n----------------\n\nThank You very much!", "id": 74024, "time": "2005-04-23T09:12:05Z", "bug_id": 34589, "creation_time": "2005-04-23T09:12:05Z", "is_private": false, "attachment_id": null}, {"count": 1, "tags": [], "bug_id": 34589, "attachment_id": null, "text": "This is caused by ap_rflush, which calls apr_brigade_create() on every call. \nThis could be fixed by re-using a brigade inside ap_rflush.", "id": 74026, "time": "2005-04-23T09:48:53Z", "creator": "chip@force-elite.com", "creation_time": "2005-04-23T09:48:53Z", "is_private": false}, {"count": 2, "attachment_id": null, "bug_id": 34589, "is_private": false, "id": 74111, "time": "2005-04-26T09:43:46Z", "creator": "norair@freenet.am", "creation_time": "2005-04-26T09:43:46Z", "tags": [], "text": "(In reply to comment #1)\n> This is caused by ap_rflush, which calls apr_brigade_create() on every call. \n> This could be fixed by re-using a brigade inside ap_rflush.\n\nThanks... but it seems that your solution doesn't work...\nlook at this...\noriginal source is:\nAP_DECLARE(int) ap_rflush(request_rec *r)\n{\n    conn_rec *c = r->connection;\n    apr_bucket_brigade *bb;\n    apr_bucket *b;\n    bb = apr_brigade_create(r->pool, c->bucket_alloc);\n    b = apr_bucket_flush_create(c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bb, b);\n\n    if (ap_pass_brigade(r->output_filters, bb) != APR_SUCCESS)\n        return -1;\n\n    return 0;\n}\n\nwe added following lines in the protocol.c file:\n\nAP_DECLARE(int) ap_rflush2(request_rec *r, apr_bucket_brigade **bb)\n{\nconn_rec *c = r->connection;\napr_bucket *b;\nif(*bb==NULL){\n*bb = apr_brigade_create(r->pool, c->bucket_alloc);\n}\nb = apr_bucket_flush_create(c->bucket_alloc);\nAPR_BRIGADE_INSERT_TAIL(*bb, b);\n\nif (ap_pass_brigade(r->output_filters, *bb) != APR_SUCCESS)\nreturn -1;\n\nreturn 0;\n}\n\nand now we are using ap_rflush2 in our module source.\n\nbut it didn't help...\n\nmemory usage still growing...\n"}, {"count": 3, "tags": [], "bug_id": 34589, "attachment_id": null, "text": "It's more complicated than that because other filters higher up the chain will\nsplit and leak a brigade for each FLUSH bucket sent, per bug 23567.", "id": 74112, "time": "2005-04-26T09:52:54Z", "creator": "jorton@redhat.com", "creation_time": "2005-04-26T09:52:54Z", "is_private": false}, {"count": 4, "tags": [], "creator": "norair@freenet.am", "text": "(In reply to comment #3)\n> It's more complicated than that because other filters higher up the chain will\n> split and leak a brigade for each FLUSH bucket sent, per bug 23567.\n\nWe had done some other changes in the the code of module and httpd...\nBut it seems that we can't find out solution.\nCould You help us anyway, or could you find out and fix the bug yourself?", "id": 74267, "time": "2005-04-29T08:02:45Z", "bug_id": 34589, "creation_time": "2005-04-29T08:02:45Z", "is_private": false, "attachment_id": null}, {"count": 5, "tags": [], "creator": "norair@freenet.am", "text": "(In reply to comment #4)\n> (In reply to comment #3)\n> > It's more complicated than that because other filters higher up the chain will\n> > split and leak a brigade for each FLUSH bucket sent, per bug 23567.\n\n----------------quote from bug number 23567 thread------------------\n\nJust brain-dumping, the design issue here is, per Jeff's analysis and subsequent\ndiscussion:\n\n1. brigades are allocated out of pools\n2. every call to apr_brigade_split allocates a new brigade\n3. every time a FLUSH bucket it sent down the filter stack, it causes at least\none call to apr_brigade_split\n\nfixes for this could be either:\n\nfix (1), allocate brigades out of the bucket-allocator so that they can really\nbe free'd (very intrusive since many filters presume brigades are never really\ndestroyed)\n\nfix (3), adjust all filters to ensure that they don't allocate a number of\nbrigades per request (and hence, memory allocated) which is proportional to\nnumber of FLUSH buckets sent.\n----------------------------- end of quote--------------------\n\n\nLook...\n\nFirst change we had made is call apr_brigade_create from module code.\nAnd we had played with following functions:\n\n      apr_brigade_cleanup(bb);\n      APR_BRIGADE_EMPTY(bb);\n      apr_brigade_destroy(bb);\n\nAll attempts was unsuccessful...\n\n\nThen we had attempt to make our module look like this:\n\nint start_receive(request_rec *r, char* user_name, char* group_name)\n{\n        int ret;\n        apr_bucket_brigade *bb = NULL;\n\n        //added\n        bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);\n\n        ret = 1;\n        ap_rprintf (r, \"%s_%s:connected|%d\\r\\n\", user_name, group_name, ret);\n        ap_rflush2(r, bb);\n             ... ... ...\nand made some changes in server/protocol.c:\n\nAP_DECLARE(int) ap_rflush2(request_rec *r, apr_bucket_brigade *bb)\n{\nconn_rec *c = r->connection;\napr_bucket *b;\n\n//if(*bb==NULL){\n//*bb = apr_brigade_create(r->pool, c->bucket_alloc);\n//}\n\nb = apr_bucket_flush_create(c->bucket_alloc);\nAPR_BRIGADE_INSERT_TAIL(bb, b);\n\n//if (ap_pass_brigade(r->output_filters, bb) != APR_SUCCESS)\n//return -1;\n\nreturn 0;\n}\n\nSo, even when apr_brigade_create function called from module and filters are\ncommented memory usage still growing.\nI can mention, that when following lines\n//if (ap_pass_brigade(r->output_filters, bb) != APR_SUCCESS)\n//return -1;\nare commented then memory usage grow too fast and can hang machine after few\nseconds because of lack of resources.\n\nWe preferring to use Apache 2 instead of Apache 1.3 because of uncomparable\nspeed that is very important in our project : 'World Biggest Chat' by Lycos-Europe\n\n\n\n", "id": 74297, "time": "2005-04-30T12:25:50Z", "bug_id": 34589, "creation_time": "2005-04-30T12:25:50Z", "is_private": false, "attachment_id": null}, {"count": 6, "tags": [], "creator": "jorton@redhat.com", "text": "This issue is essentially no different from bug 23567, marking as duplicate.\n\n*** This bug has been marked as a duplicate of 23567 ***", "id": 79554, "time": "2005-09-07T17:31:44Z", "bug_id": 34589, "creation_time": "2005-09-07T17:31:44Z", "is_private": false, "attachment_id": null}]