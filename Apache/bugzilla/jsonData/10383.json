[{"count": 0, "tags": [], "bug_id": 10383, "attachment_id": null, "id": 18817, "time": "2002-07-01T20:03:37Z", "creator": "ruediger.pluem@vodafone.com", "creation_time": "2002-07-01T20:03:37Z", "is_private": false, "text": "Hi,\n\nwhen using Apache, mod_jk 1.2.0 (the one delivered with Tomcat 4.0.4) and the\nAJP13 Connector of Tomcat 4.0.4, I encounter the problem, that a specially\ncrafted GET request causes the answering httpd process and the answering AJP13\nprocessor to hang indefinitely.\n\nI. Details on my enviroment:\n\nOS: Linux\nWebserver: Apache\nmod_jk: 1.2.0 (The one delivered with Tomcat 4.0.4)\nTomcat: 4.0.4\nJDK: 1.4.0_01-b03\n\nRemark: This problem was also discovered with Tomcat 4.0.1 running on Solaris\nand JDK 1.3.1\n\nII. How to reproduce the problem:\n\n1. Setup a standard Apache, make mod_jk.so available to the modules directory\nof Apache (/usr/lib/apache in my case) and add the following configuration\nto your httpd.conf:\n\nLoadModule jk_module /usr/lib/apache/mod_jk.so\n\nAddModule mod_jk.c\n\n<IfModule mod_jk.c>\n\nNamevirtualhost 192.168.2.2:80\n\nJkWorkersFile /etc/httpd/workers.properties\nJkLogFile  /var/log/httpd/mod_jk.log\nJkLogLevel warn\n\n<VirtualHost 192.168.2.2:80>\n\nServerName jktest.com\nDocumentRoot /tmp\nTransferlog /var/log/httpd/test.log\n\nJkMount /* ajp13\n#JkMount /*.jsp ajp13\n#JkMount /servlet/* ajp13\n#JkMount /examples/* ajp13\n\n</VirtualHost>\n\n</IfModule>\n\n2. Use the following /etc/httpd/workers.properties:\n\nworker.list=ajp13\nworker.ajp13.port=8009\nworker.ajp13.host=localhost\nworker.ajp13.type=ajp13\nworker.ajp13.lbfactor=1\n\n3. Ensure that the AJP13 connector is configured the following way in\nserver.xml:\n\n    <Connector className=\"org.apache.ajp.tomcat4.Ajp13Connector\"\n               port=\"8009\" minProcessors=\"5\" maxProcessors=\"75\"\n               acceptCount=\"10\" debug=\"1\"/>\n\n4. Start Tomcat and Apache. \n5. Send the following request to the webserver (e.g. via telnet 192.168.2.2 80):\n\nGET / HTTP/1.0\nHost: jktest.com\nCookie: domain=blah\n\nIII. What can be observed:\n\n1. The telnet process does not return with any answer, but hangs indefinitely.\n2. The anserwering httpd process is still connected to the telnet process\nTaking a look to the Apache server-status page says that this process is\ncurrently writing the response.\n3. Doing a strace to the answering httpd process delivers the following:\n\nrecv(10,\n\n(where 10 is the filedescriptor for the AJP13 TCP/IP connection)\n\n4. The situation of the answering httpd process does not change, even when\ntelnet is killed. The Apache server-status still says that this process is\ncurrently writing the response.\n\n5. Tomcat throws the following exception to catalina_log.2002-07-01.txt:\n\n2002-07-01 20:36:10 Ajp13Connector[8009] accepted socket, assigning to processor.\n2002-07-01 20:36:10 Ajp13Connector[8009] about to create a processor,\navailable=5, created=5, maxProcessors=75\n2002-07-01 20:36:10 Ajp13Processor[8009][4]  An incoming request is being assigned\n2002-07-01 20:36:10 Ajp13Processor[8009][4]   The incoming request has been awaited\n2002-07-01 20:36:10 Ajp13Processor[8009][4] socket assigned.\n2002-07-01 20:36:10 Ajp13Connector[8009] accepting socket...\n2002-07-01 20:36:10 Ajp13Processor[8009][4] [Ajp13] setSocket()\n2002-07-01 20:36:10 Ajp13Processor[8009][4] waiting on next request...\n2002-07-01 20:36:10 Ajp13Processor[8009][4] [Ajp13] receiveNextRequest()\n2002-07-01 20:36:10 Ajp13Processor[8009][4] [Ajp13] receive()\n2002-07-01 20:36:10 Ajp13Processor[8009][4] [Ajp13] receive:  total read = 89\n2002-07-01 20:36:10 Ajp13Processor[8009][4] [Ajp13] Received 2\nJK_AJP13_FORWARD_REQUEST\n2002-07-01 20:36:10 Ajp13Processor[8009][4] [Ajp13] [RequestHandler] decodeRequest()\n2002-07-01 20:36:10 Ajp13Processor[8009][4] received next request, status=200\n2002-07-01 20:36:11 Ajp13Processor[8009][4] process: invoke\njava.lang.IllegalArgumentException: Cookie name domain is a reserved token\n        at javax.servlet.http.Cookie.<init>(Cookie.java:185)\n        at org.apache.ajp.tomcat4.Ajp13Request.addCookies(Ajp13Request.java:189)\n       at org.apache.ajp.tomcat4.Ajp13Request.setAjpRequest(Ajp13Request.java:148)\n        at org.apache.ajp.tomcat4.Ajp13Processor.process(Ajp13Processor.java:446)\n        at org.apache.ajp.tomcat4.Ajp13Processor.run(Ajp13Processor.java:551)\n        at java.lang.Thread.run(Thread.java:536)\n\n2002-07-01 20:36:11 Ajp13Processor[8009][4] recyling objects ...\n2002-07-01 20:36:11 Ajp13Processor[8009][4] [Ajp13] recycle()\n2002-07-01 20:36:11 Ajp13Processor[8009][4] waiting on next request...\n2002-07-01 20:36:11 Ajp13Processor[8009][4] [Ajp13] receiveNextRequest()\n2002-07-01 20:36:11 Ajp13Processor[8009][4] [Ajp13] receive()\n\nIV. Conclusion\n\nIf the request shown in II.5 is executed often enough all httpd processes will\nbe blocked. Furthermore if there are more possible httpd processes than Tomcat\nprocessors Tomcat (MaxClients > maxProcessors) will have no processors left to\nanswer requests. This can be used for a denial of service attack on\nApache/Tomcat connected via AJP13.\n\nV. Discussion of the problem\n\nFrom my point of view the main source of the problem can be found in\nAjp13Processor.java in lines 441 till 473:\n\n            try {\n                // set flag\n                handlingRequest.set(true);\n\n                // set up request\n                request.setAjpRequest(ajpRequest);\n                request.setResponse(response);\n                request.setStream(input);\n\n                // setup response\n                response.setRequest(request);\n                response.setStream(output);\n\n                if (debug > 0) {\n                    logger.log(\"invoking...\");\n                }\n\n                connector.getContainer().invoke(request, response);\n\n                if (debug > 0) {\n                    logger.log(\"done invoking, finishing request/response....\");\n               }\n\n                response.finishResponse();\n                request.finishRequest();\n\n                if (debug > 0) {\n                    logger.log(\"finished handling request.\");\n                }\n\n            } catch (Throwable e) {\n                logger.log(\"process: invoke\", e);\n            }\n\nAlthough every exeception produced during the processing of the request will be\ncaught, no care will be taken to ensure that there is a definitive response\nback to the waiting httpd process (it is waiting for an answer indefinitely\nas seen by staying in the recv syscall).\n\nFrom my point of view the catch clause should contain code that sends\na code 500 together with a stack trace back to Apache. If it is impossible to\ndo so (maybe because no response object could be setup correctly) at least the\nwhile loop should be left.\n\nFrom my point of view this blocking situation can be caused by many more \nexceptions that are caught by the catch clause in line 471, not only by the\nIllegalArgumentException caused by the wrong cookie in my request.\n\nRegards\n\nR\u00fcdiger Pl\u00fcm"}, {"count": 1, "tags": [], "bug_id": 10383, "attachment_id": null, "id": 28726, "time": "2002-12-29T22:18:12Z", "creator": "ruediger.pluem@vodafone.com", "creation_time": "2002-12-29T22:18:12Z", "is_private": false, "text": "Hi,\n\nmeanwhile I found time (OK, quite a long time has passed between now and my\noriginal Bug Report :-), but I hoped someone would find a better solution.) to\ncreate a\nworkaround patch that prevents a least the hanging of the answering httpd and the\nanswering AJP13 processor (see also attachment):\n\ndiff -Nru\njakarta-tomcat-connectors-4.0.4-src.orig/jk/java/org/apache/ajp/tomcat4/Ajp13Processor.java\njakarta-tomcat-connectors-4.0.4-src/jk/java/org/apache/ajp/tomcat4/Ajp13Processor.java\n---\njakarta-tomcat-connectors-4.0.4-src.orig/jk/java/org/apache/ajp/tomcat4/Ajp13Processor.java\n2002-06-11 08:48:08.000000000 +0200\n+++\njakarta-tomcat-connectors-4.0.4-src/jk/java/org/apache/ajp/tomcat4/Ajp13Processor.java\n2002-12-29 14:33:56.000000000 +0100\n@@ -468,7 +468,11 @@\n                     logger.log(\"finished handling request.\");\n                 }\n\n-            } catch (Throwable e) {\n+            } catch (IllegalArgumentException e) {\n+                logger.log(\"process: invoke: IllegalArgumentException: \" +\ne.getMessage() + \": closing socket\");\n+                break;\n+            }\n+              catch (Throwable e) {\n                 logger.log(\"process: invoke\", e);\n             }\n\nThe patch has been made against the tomcat connectors of 4.0.4 as in my original\nenvironment\nof the bug report, but I guess it fits also to the newer versions of 4.0.x or is\neasy to adjust\nto them.\n\nOk, what are the effects of this patch:\n\n1. The IllegalArgumentException caused by the wrong cookie will be caught, a short\n   message without the full stack trace will be logged and the while loop\nstarting in line 388\n   will be left in line 493.\n2. Leaving the while loop in line 493 will cause the ajp13 object and thus the\nconnection to\n   mod_jk to be closed by the answering AJP13 processor.\n3. mod_jk gets an error reading the reply from the AJP13 processor (see\nmod_jk.log excerpt below)\n   because the socket has been closed by the AJP13 processor. Thus it tries to\ncontact\n   (via new TCP/IP connections) Tomcat two more times via the same worker to\nsend the request.\n   In a load balanced environment all other workers of the load balanced worker\nwill be tried\n   afterwards for three times. After that mod_jk gives up and Apache sends a\n   code 500 (Internal server error) back to the client.\n\nExcerpt from mod_jk.log:\n\n[Sun Dec 29 17:17:07 2002]  [jk_ajp_common.c (652)]:\najp_connection_tcp_get_message: Error - jk_tcp_socket_recvfull failed\n[Sun Dec 29 17:17:07 2002]  [jk_ajp_common.c (1013)]: Error reading reply\n[Sun Dec 29 17:17:07 2002]  [jk_ajp_common.c (1150)]: In jk_endpoint_t::service,\najp_get_reply failed in send loop 0\n[Sun Dec 29 17:17:07 2002]  [jk_ajp_common.c (652)]:\najp_connection_tcp_get_message: Error - jk_tcp_socket_recvfull failed\n[Sun Dec 29 17:17:07 2002]  [jk_ajp_common.c (1013)]: Error reading reply\n[Sun Dec 29 17:17:07 2002]  [jk_ajp_common.c (1150)]: In jk_endpoint_t::service,\najp_get_reply failed in send loop 1\n[Sun Dec 29 17:17:07 2002]  [jk_ajp_common.c (652)]:\najp_connection_tcp_get_message: Error - jk_tcp_socket_recvfull failed\n[Sun Dec 29 17:17:07 2002]  [jk_ajp_common.c (1013)]: Error reading reply\n[Sun Dec 29 17:17:07 2002]  [jk_ajp_common.c (1150)]: In jk_endpoint_t::service,\najp_get_reply failed in send loop 2\n[Sun Dec 29 17:17:07 2002]  [jk_lb_worker.c (373)]: In jk_endpoint_t::service,\nNo more workers left, can not submit the request\n[Sun Dec 29 17:17:07 2002]  [jk_lb_worker.c (380)]: In jk_endpoint_t::service:\nNULL Parameters\n\nExcerpt from catalina_log:\n\n2002-12-29 17:17:07 Ajp13Processor[7006][4] process: invoke:\nIllegalArgumentException: Cookie name domain is a reserved token: closing socket\n2002-12-29 17:17:07 Ajp13Processor[7006][2] process: invoke:\nIllegalArgumentException: Cookie name domain is a reserved token: closing socket\n2002-12-29 17:17:07 Ajp13Processor[7006][2] process: invoke:\nIllegalArgumentException: Cookie name domain is a reserved token: closing socket\n\n\nI know that this patch is far from optimal (at least because of the senseless\nreconnection\ntries of mod_jk), but it prevents at least the indefinite blocking of resources\non Apache and\nTomcat side. Thus it helps to prevent a denial of service attack using this bug.\nAs the JK/AJP connector is deprecated and is not used any longer in the 4.1.x\nseries, I guess\nthis patch will not find its way in the CVS, but it may be helpful to people\nwith the same\nproblem who search for a quick and easy fix of this bug without upgrading.\n\nThe patch has been tested within the following environments:\n\nOS: Linux\nSDK: 1.4.0_02\n\nOS: Solaris 8\nSDK: 1.4.0_02\n\nRegards\n\nR\u00fcdiger Pl\u00fcm"}, {"count": 2, "tags": [], "bug_id": 10383, "text": "Created attachment 4284\nPatch to comments from 2002-12-29 22:18 as attachment", "id": 28727, "time": "2002-12-29T22:20:16Z", "creator": "ruediger.pluem@vodafone.com", "creation_time": "2002-12-29T22:20:16Z", "is_private": false, "attachment_id": 4284}, {"count": 3, "tags": [], "creator": "glenn@apache.org", "attachment_id": null, "id": 28750, "time": "2002-12-30T15:23:12Z", "bug_id": 10383, "creation_time": "2002-12-30T15:23:12Z", "is_private": false, "text": "Thanks for the excellent bug report and the patch.  \nI have verified that the bug exists.\nI am looking into the best way to handle exceptions when processing a request\nwith Ajp."}, {"count": 4, "tags": [], "bug_id": 10383, "text": "I have just committed a patch that will return an HTTP status code of\n400 - Bad Request when this happens.", "id": 28752, "time": "2002-12-30T16:02:54Z", "creator": "glenn@apache.org", "creation_time": "2002-12-30T16:02:54Z", "is_private": false, "attachment_id": null}, {"count": 5, "tags": [], "bug_id": 10383, "text": "Thank you very much for the patch. Especially the second version of the patch\nis exactly what I had in mind when I wrote this bug report.\n\nOne last general request that is not focused on you:\n\nWhen I encounter problems with apache.org software (not only\nTomcat) I use bugzilla very often and most of the time I find a hint\nthere that solves my problem. But very often it is hard work to find\nall the patched files and the revisions of the files containing the\npatch that resolved the bug in the CVS (partionally CVS is to blame on\nthis problem).\n\nAlthough I know that the CVS is very dynamic, I think it would help a lot\nif any person who commits a patch to the CVS in reaction to a bug report\nwrites a short note to the bug report which files have been changed\nby the patch and the revision numbers of these files.\nEven if these patches change later on, this information is a good base\nfor searching the actual version of the patch to a bug in the CVS.\n\nFor this bug the note is rather short:\nAffected files and revisions:\n\njakarta-tomcat-connectors/jk/java/org/apache/ajp/tomcat4/Ajp13Processor.java\nrevisions: 1.10, 1.11\n\nComplete patch:\nhttp://cvs.apache.org/viewcvs/jakarta-tomcat-connectors/jk/java/org/apache/ajp/tomcat4/Ajp13Processor.java.diff?r1=1.9&r2=1.11\n\nRemark: The complete patch line is something I would not see within the scope\nof this short note in general, but in this case this was so easy that I\nadded it for everyones convenience.\n\nAgain thanks for the help.", "id": 28880, "attachment_id": null, "creator": "ruediger.pluem@vodafone.com", "creation_time": "2003-01-04T22:28:57Z", "time": "2003-01-04T22:28:57Z", "is_private": false}, {"count": 6, "tags": [], "bug_id": 10383, "attachment_id": null, "id": 92010, "time": "2006-08-07T21:12:39Z", "creator": "dlr@apache.org", "creation_time": "2006-08-07T21:12:39Z", "is_private": false, "text": "I ran into this problem with an old version of Tomcat (4.1.18) my company still\nhas in production.  A co-worker (Tim Dionne) and I identified the problem and a\nfix, then noticed that a fix similar to mine exists in ASF Subversion as r298276\nand r298276.\n\nFor the record, I was seeing cookie parsing failures from misbehaving HTTP\nclients (e.g. GetRight) which were sending malformed \"Cookie\" headers which\ncontained elements which appeared to the Servlet API's Cookie.java as cookies\nnamed \"Path\".  These HTTP headers were rejected during cookie parsing,\ntriggering the same IllegalArgumentException seen by R\u00fcdiger.  Only the mod_jk\nworker appears to be blocking (on read), not the Ajp13Processor thread (I'm\ncorrecting the Summary accordingly).  After 2 or 3 minutes (usually 3), the\nmod_jk worker gives up, and a 500 ISE is sent back to the HTTP client currently\nbeing served."}, {"count": 7, "tags": [], "bug_id": 10383, "attachment_id": null, "text": "For posterity, the relevant Cookie RFCs are:\n\n* RFC 2965 <http://www.faqs.org/rfcs/rfc2965> (obseletes RFC 2109)\n* RFC 2109 <http://www.faqs.org/rfcs/rfc2109.html>", "id": 92011, "time": "2006-08-07T21:13:47Z", "creator": "dlr@apache.org", "creation_time": "2006-08-07T21:13:47Z", "is_private": false}]