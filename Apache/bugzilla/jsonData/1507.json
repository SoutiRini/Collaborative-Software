[{"count": 0, "tags": [], "bug_id": 1507, "text": "NOTE: I have been able to produce these errors on a dual-processor PII\n400Mhz machine running NT 4.0.  The errors however have to with Java\nsemantics, and should be producible on all environments.\n\nThe implementation of class AppenderAttachableImpl is left\nnon--thread-safe, that is, it does not make use of synchronized\nmethods or blocks.  The exepctation appears to be that the classes\nthat are declared to implement AppenderAttachable are responsible for\nusing synchronization to protect the AppenderAttachableImpl object\nthey delegate to.  The classes AsyncAppender and Category are the only\nclasses that implement this interface (that I was able to detect).\nThe following methods related to AppenderAttachable use\nsynchronization\n\n  AsyncAppender.addAppender()\n  AsyncAppender.removeAllAppenders()\n  AsyncAppender.removeAppender(Appender)\n  AsyncAppender.removeAppender(String)\n\n  Category.addAppender()\n  Category.removeAllAppenders()\n  Category.removeAppender(Appender)\n  Category.removeAppender(String)\n  Category's use of appendLoopOnAppenders() IS synchronized\n\nBasically, the following additional methods need to be declared to be\nsynchronized\n\n  AsyncAppender.getAllAppenders\n  AsyncAppender.getAppender\n  Category.getAllAppenders\n  Category.getAppender\n\nAnd the use of appendLoopOnAppenders in Dispatcher.run() (in\nAsyncAppender.java) needs to be from within a block synchronized on\nthe AysncAppender object that created the Dispatcher.\n\nThe following race conditions can occur because of failure to properly\nsynchronize the use of AsyncAppenderImpl objects (attached to this\nreport are Java programs that cause the errors to occur):\n\n\n* AppenderAttachableImpl.removeAllAppenders &\n  AppenderAttachableImpl.getAllAppenders\n\nPROBLEM: removeAllAppenders sets the appenderList to null, which can\ncause getAllAppenders to throw a NullPointerException.\n\nFIX: Declare AsyncAppender.getAllAppenders and\nCategory.getAllAppenders to be synchronized.\n\n\n* Category.removeAllAppenders & Category.getAllAppenders\n\nPROBLEM: removeAllAppenders sets the reference (field \"aai\") to the\nAppenderAttachableImpl delegate to null, which can cause a\nNullPointerException in getAllAppenders.\n\nFIX: Declare Category.getAllAppenders to be synchronized.\n\n\n* AppenderAttachableImpl.removeAllAppenders & \n  AppenderAttachableImpl.getAppender\n\nPROBLEM: removeAllAppenders first removes each appender from the\nVector, causing the size of the Vector to decrease, and then sets the\nreference to the Vector to null.  This can occur while getAppender is\ntraversing the Vector, leading to either a NullPointerException or an\nArrayIndexOutOfBoundsException.\n\nFIX: Declare Category.getAppender and AsyncAppender.getAppender to be\nsynchronized.\n\n\n* Category.removeAllAppenders & Category.getAppender\n\nPROBLEM: removeAllAppenders sets the field \"aai\" to null, which can\ncause getAPpender to throw a NullPointerException.\n\nFIX: Declare Category.getAppender to be synchronized\n\n\n* AppenderAttachableImpl.getAppender &\n  AppenderAttachableImpl.removeAppender (both versions)\n\nPROBLEM: removeAppender shrinks the size of the Vector, which can\ncause getAPpender to throw an ArrayIndexOutOfBoundsException.\n\nFIX: Declare Category.getAppender and AsyncAppender.getAppender to be\nsynchronized.\n\n\n* AppenderAttachableImpl.appendLoopOnAppenders &\n  AppenderAttachableImpl.removeAllAppenders\n\nPROBLEM: removeAllAppenders shrinks the size of the Vector, and also\nsets the reference to the Vector to null, which can cause an\nArrayIndexOutOfBOundsException and NullPointerException in\nappendLoopOnAppenders, respectively.\n\nA non-exceptional error can also occur.  If the loop over the Vector\nin appendLoopOnAppenders lags behind the loop over the Vector in\nremoveAllAppenders, then the doAppend method of an Appender will be\ncalled after that Appender has been closed.  The documentation of\nAppender cays that this is erroneous.\n\nFIX: Enclose the call to appendLoopOnAppenders within Dispatcher.run()\nwithin a block synchronized on the appropriate AsyncAppender instance.\nThis requires either passing the AsyncAppender instance to the\nconstructor of the Dispatcher object, or making thd Dispatcher class a\nnon-static inner class of AsyncAppender.\n\n(This is not a problem for Category because as mentioned above,\nCategory already invokes appenderLoopOnAppenders from within a\nsynchronized block that locks the Category object.)\n\n\n* AppenderAttachableImpl.appendLoopOnAppenders &\n  AppenderAttachableImpl.removeAppender (both versions)\n\nPROBLEM: removeAppender shrinks the size of the Vector, which can\ncause an ArrayIndexOutOfBOundsException in appendLoopOnAppenders.\n\nFIX: Enclose the call to appendLoopOnAppenders within Dispatcher.run()\nwithin a block synchronized on the appropriate AsyncAppender instance.\nThis requires either passing the AsyncAppender instance to the\nconstructor of the Dispatcher object, or making the Dispatcher class a\nnon-static inner class of AsyncAppender.\n\n(This is not a problem for Category because as mentioned above,\nCategory already invokes appenderLoopOnAppenders from within a\nsynchronized block that locks the Category object.)", "id": 2087, "time": "2001-04-25T10:36:54Z", "creator": "aarong@cs.cmu.edu", "creation_time": "2001-04-25T10:36:54Z", "is_private": false, "attachment_id": null}, {"count": 1, "tags": [], "bug_id": 1507, "attachment_id": 120, "id": 2088, "time": "2001-04-25T10:38:02Z", "creator": "aarong@cs.cmu.edu", "creation_time": "2001-04-25T10:38:02Z", "is_private": false, "text": "Created attachment 120\nProgram that creates a race condition between removeAppenders and the call to appendLoopOnAppenders in Dispacher."}, {"count": 2, "tags": [], "bug_id": 1507, "attachment_id": 121, "id": 2089, "time": "2001-04-25T10:39:21Z", "creator": "aarong@cs.cmu.edu", "creation_time": "2001-04-25T10:39:21Z", "is_private": false, "text": "Created attachment 121\nProgram that creates a race condition between getAllAppenders and removeAllAppenders"}, {"count": 3, "tags": [], "bug_id": 1507, "text": "Created attachment 122\nProgram that creates a race condition between getAppender and removeAppender(String)", "id": 2090, "time": "2001-04-25T10:40:30Z", "creator": "aarong@cs.cmu.edu", "creation_time": "2001-04-25T10:40:30Z", "is_private": false, "attachment_id": 122}, {"count": 4, "tags": [], "creator": "aarong@cs.cmu.edu", "attachment_id": 123, "id": 2091, "time": "2001-04-25T10:41:19Z", "bug_id": 1507, "creation_time": "2001-04-25T10:41:19Z", "is_private": false, "text": "Created attachment 123\nprogram that creates a race condition between getAppender and removeAllAppenders"}, {"count": 5, "tags": [], "bug_id": 1507, "attachment_id": 124, "id": 2092, "time": "2001-04-25T10:42:33Z", "creator": "aarong@cs.cmu.edu", "creation_time": "2001-04-25T10:42:33Z", "is_private": false, "text": "Created attachment 124\nProgram that creates a race condition between getAppender and removeAppender(Appender)"}, {"count": 6, "tags": [], "bug_id": 1507, "text": "Created attachment 125\nProgram that creates a race condition between removeAppender(STring) and the call to appendLoopOnAppenders in Dispatcher.run()", "id": 2093, "time": "2001-04-25T10:43:28Z", "creator": "aarong@cs.cmu.edu", "creation_time": "2001-04-25T10:43:28Z", "is_private": false, "attachment_id": 125}, {"text": "Created attachment 126\nProgram that creates a race condition between removeAllAppenders and the call to appendLoopOnAppenders in Dispatcher.run()  (First file is mislabled, should be removeAppender(Appender))", "tags": [], "creator": "aarong@cs.cmu.edu", "attachment_id": 126, "count": 7, "id": 2094, "time": "2001-04-25T10:44:51Z", "bug_id": 1507, "creation_time": "2001-04-25T10:44:51Z", "is_private": false}, {"text": "\nThis is the most detailed bug report I have ever seen. I very much appreciate \nthe time you have spent on it. Thank you. Ceki", "tags": [], "creator": "bugzilla@apache.org", "attachment_id": null, "count": 8, "id": 2108, "time": "2001-04-26T00:49:11Z", "bug_id": 1507, "creation_time": "2001-04-26T00:49:11Z", "is_private": false}, {"count": 9, "text": "I should mention that these bugs were discovered as part of a study of\nhow multi-threading and thread-safety issues are managed in actual code.\n", "bug_id": 1507, "is_private": false, "id": 2121, "time": "2001-04-26T12:48:03Z", "creator": "aarong@cs.cmu.edu", "creation_time": "2001-04-26T12:48:03Z", "tags": [], "attachment_id": null}]