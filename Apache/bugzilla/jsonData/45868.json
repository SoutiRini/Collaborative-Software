[{"count": 0, "tags": [], "bug_id": 45868, "attachment_id": null, "id": 120898, "time": "2008-09-23T16:46:32Z", "creator": "blucia@gmail.com", "creation_time": "2008-09-23T16:46:32Z", "is_private": false, "text": "I am using mod_mem_cache with the worker MPM.  Using a profiling tool for detecting certain interleavings between the code of concurrently executing threads, I have discovered that headers which actually end up being cached may have originated partially from 1 thread, and partially from another.  Specifically, look at the following code:\n\n   mobj->req_hdrs = deep_table_copy(mobj->pool, r->headers_in);\n   /* Precompute how much storage we need to hold the headers */\n   headers_out = ap_cache_cacheable_hdrs_out(r->pool, r->headers_out,\n                                             r->server);\n   /* If not set in headers_out, set Content-Type */\n   if (!apr_table_get(headers_out, \"Content-Type\")\n       && r->content_type) {\n       apr_table_setn(headers_out, \"Content-Type\",\n                      ap_make_content_type(r, r->content_type)); \n   }\n   headers_out = apr_table_overlay(r->pool, headers_out, r->err_headers_out);\n   mobj->header_out = deep_table_copy(mobj->pool, headers_out);\n\n\nHere, the mobj->req_hdrs are assigned to the deep_table_copy result, which is based on r->headers_in.  After a short while, mobj->header_out is assigned to the deep_table_copy of the headers_out object (which is computed from r->headers_out).  Under heavy load (~100 concurrent requests), while this is happening in one thread (T1, say), it can be (and likely is) happening concurrently in another (T2, say).  So:  between when T1 writes mobj->req_hdrs, and when T1 writes mobj->header_out, T2 is able to preempt T1, and write mobj->req_hdrs and mobj->header_out.  The sequence of events is as follows:\n\nT1: Write mobj->req_hdrs\nT2: Write mobj->req_hdrs\nT2: Write mobj->header_out\nT1: Write mobj->header_out\n\nThis results in mobj->req_hdrs being the version written by the request being processed in T1, and mobj->header_out being the version written by the request being processed in T2.  Depending on the nature of the requests being issued, this could result in an inconsistent pair of headers being stored in the cached object."}]