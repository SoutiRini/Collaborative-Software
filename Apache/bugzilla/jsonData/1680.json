[{"count": 0, "tags": [], "text": "I am using Tomcat 3.2.1 as a stand-alone servlet container and I am also \nusing the standard directory layout for my files. The servlet uses a mySQL \ndatabase and the driver file (mysql.jar) is correctly copied during the servlet \nbuild process to the corresponding application  WEB-INF/lib directory. When \nstarting TOMCAT and then running a client programme to query the database I get \n\"SQLException: No suitable driver\".\nAlthough this is easily corrected by adding   WEB-INF/lib/mysql.jar to the \nCLASSPATH before starting TOMCAT it should not be necessary according to the \ndocumentation in $TOMCAT_HOME/doc/appdev/index.html.  This states that \"when \nyou install an application into tomcat ... all classes in JAR files found  in \nWEB-INF/lib/ directory are added to the classpath for your particular web \napplication ... no adjustment to the system class path will be necessary\".\nAdditional note: This problem where classes in JAR files in WEB-INF/lib are not \nadded to the CLASSPATH also occurs in version 3.2.2b4.", "is_private": false, "id": 2354, "creator": "a.djaoui@rl.ac.uk", "time": "2001-05-09T09:25:33Z", "bug_id": 1680, "creation_time": "2001-05-09T09:25:33Z", "attachment_id": null}, {"count": 1, "tags": [], "text": "I am also having a problem regarding jar files.  I have modified the tomcat.sh \nfile to add the files found in TOMCAT_HOME/lib/patch to the first part of the \nclasspath.  myapp.jar resides in the WEB-INF/lib directory.  With Tomcat 3.1, I \ncould build a file named myapp_patch.jar and place it in the \nTOMCAT_HOME/lib/patch directory.  Upon restarting Tomcat, classes would first \nbe pulled from the patch.  This approached has served me well.  I could apply a \npatch to the application easily, and I could also remove it quickly if \nnecessary.  Anyway, this doesn't work with Tomcat 3.2.1.  With the patch in \nplace, the application fails to start with a ClassNotFound exception, naming a \nclass that is unrelated to the patch.", "is_private": false, "id": 2641, "creator": "johnm@eepulse.com", "time": "2001-05-24T08:49:34Z", "bug_id": 1680, "creation_time": "2001-05-24T08:49:34Z", "attachment_id": null}, {"count": 2, "attachment_id": null, "bug_id": 1680, "is_private": false, "id": 3111, "time": "2001-06-19T23:12:07Z", "creator": "cmanolache@yahoo.com", "creation_time": "2001-06-19T23:12:07Z", "tags": [], "text": "Nothing we can do about this in general, in some cases it helps to add the \nJdk12Interceptor. The problem is the API is loaded from the parent loader, \nand it has no way to find the child loader ( unless the API uses context class loader and jdk12interceptor is added ). Same thing happens with JNDI, JAXP, etc."}]