[{"count": 0, "tags": [], "creator": "cwicke@ics.uci.edu", "attachment_id": null, "id": 29024, "time": "2003-01-08T17:03:15Z", "bug_id": 15894, "creation_time": "2003-01-08T17:03:15Z", "is_private": false, "text": "Hello \n \nit is possible to access a session of somebody else through calling \nsession.invalidate. Here is an example JSP: \n \n<% \n  HttpSession s = request.getSession(true); \n  String name = request.getParameter(\"name\"); \n  s.setAttribute(\"name\", name); \n  Thread.sleep(5000); \n  s.invalidate(); \n  Thread.sleep(5000); \n  s = request.getSession(true); \n  String nameFromSession = (String) s.getAttribute(\"name\"); %> \n<html> \n<head><title>Test Invalidate</title></head> \n<body bgcolor=\"white\"> \n<font size=4> \n \n<% if (nameFromSession == null) { %> \n  second session was clean. \n<% } else { %> \n \n  Session not Empty after invalidate!!!<p> \n \n  I got the session from <%=nameFromSession%> \n<% } %> \n \n</font> \n</body> \n</html> \n \nLogin on one browser with \nhttp://localhost:8080/examples/testInvalidate.jsp?name=Martin \nand then after 8 seconds on another browser (if cookies are disabled you can \nuse two windows of the same browser) with \nhttp://localhost:8080/examples/testInvalidate.jsp?name=Waldemar \nYou'll get the session of Martin. \n \nThe problem is that SimpleSessionStore recycles the sessions right away. I \nattached a path to delay the recycling. \nThe patch also touches three files to reduce racing problems. To fix the \nproblem only SimpleSessionStore needs to be updated. \n \nChristian Wicke \n \nHere is my patch: \n \ndiff -Naur ./facade22/org/apache/tomcat/facade/HttpSessionFacade.java \n../../../jakarta-tomcat-3.3.1-src/src/facade22/org/apache/tomcat/facade/HttpSessionFacade.java \n--- ./facade22/org/apache/tomcat/facade/HttpSessionFacade.java\tWed Jan  8 \n15:17:18 2003 \n+++ \n../../../jakarta-tomcat-3.3.1-src/src/facade22/org/apache/tomcat/facade/HttpSessionFacade.java\t\nTue Mar 26 16:36:48 2002 \n@@ -148,8 +148,7 @@ \n      * @exception IllegalStateException if this method is called on \n      *  an invalidated session \n      */ \n-    // avoid parallel call to invalidate through synchronized \n-    public synchronized void invalidate() { \n+    public void invalidate() { \n \tcheckValid(); \n  \trealSession.getTimeStamp().setValid( false ); \n \t// remove all attributes \ndiff -Naur ./share/org/apache/tomcat/modules/session/SessionExpirer.java \n../../../jakarta-tomcat-3.3.1-src/src/share/org/apache/tomcat/modules/session/SessionExpirer.java \n--- ./share/org/apache/tomcat/modules/session/SessionExpirer.java\tWed \nJan  8 13:32:21 2003 \n+++ \n../../../jakarta-tomcat-3.3.1-src/src/share/org/apache/tomcat/modules/session/SessionExpirer.java\t\nTue Mar 26 16:36:49 2002 \n@@ -159,14 +159,7 @@ \n \t} \n \n \tpublic void expired(TimeStamp o ) { \n-\t  ServerSession sses=(ServerSession)o.getParent(); \n-        // double check if this session is not touched in \n-        // meantime by SessionId.processSession \n-       synchronized (sses) { \n-          if (System.currentTimeMillis() - o.getLastAccessedTime() < \no.getMaxInactiveInterval()) \n-            // session touched in meantime, don't expire \n-            return; \n- \n+\t    ServerSession sses=(ServerSession)o.getParent(); \n \t    if( debug > 0  ) { \n \t\tse.log( \"Session expired \" + sses); \n \t    } \n@@ -174,7 +167,6 @@ \n \t    // After expiring it, we clean up. \n \t    if( debug > 0 ) se.log( \"Recycling \" + sses); \n \t    sses.recycle(); \n-        } \n \t} \n     } \n } \ndiff -Naur ./share/org/apache/tomcat/modules/session/SessionId.java \n../../../jakarta-tomcat-3.3.1-src/src/share/org/apache/tomcat/modules/session/SessionId.java \n--- ./share/org/apache/tomcat/modules/session/SessionId.java\tWed Jan  8 \n15:13:14 2003 \n+++ \n../../../jakarta-tomcat-3.3.1-src/src/share/org/apache/tomcat/modules/session/SessionId.java\t\nTue Mar 26 16:37:15 2002 \n@@ -239,13 +239,6 @@ \n \t\t\t\t      sessionId,  false ); \n \t    if( sess!=null ) break; \n \t} \n-      if (sess == null) \n-        return null; \n-     // avoid parallel expiration of the SessionExpirer \n-     synchronized (sess) { \n-       //double check whether the session has been expired meantime \n-       if (sess.getState() == ServerSession.STATE_EXPIRED) \n-         return null; \n \n         /* The following block of code verifies if Tomcat session matches \n            SSL session (if one was ever passed to Tomcat). Just in case \n@@ -253,7 +246,7 @@ \n            We can't verify that if SSL is not used. */ \n \n         // Do this only if request is over SSL \n-        if(checkSSLSessionId && request.isSecure() ){ \n+        if(checkSSLSessionId && sess != null && request.isSecure() ){ \n           // SSL session ID from session and request - they have to be equal! \n           String \nids=(String)sess.getAttribute(\"javax.servlet.session.ssl_session\"), \n                  \nidr=(String)request.getAttribute(\"javax.servlet.request.ssl_session\"); \n@@ -283,7 +276,7 @@ \n \t    // it and adjust the session \n \t    request.setSession( sess ); \n \t    request.setSessionId( sessionId ); \n- \n+ \n \t    sess.touch( System.currentTimeMillis() ); \n \n \t    // if the session was NEW ( never accessed - change it's state ) \n@@ -291,10 +284,9 @@ \n \t\tsess.setState( ServerSession.STATE_ACCESSED, request); \n \t    } \n \t} \n-     } \n \treturn sess; \n     } \n- \n+ \n //     /** Fix the session id. If the session is not valid return null. \n //      *  It will also clean up the session from load-balancing strings. \n //      * @return sessionId, or null if not valid \ndiff -Naur ./share/org/apache/tomcat/modules/session/SimpleSessionStore.java \n../../../jakarta-tomcat-3.3.1-src/src/share/org/apache/tomcat/modules/session/SimpleSessionStore.java \n--- ./share/org/apache/tomcat/modules/session/SimpleSessionStore.java\tTue \nJan  7 14:21:48 2003 \n+++ \n../../../jakarta-tomcat-3.3.1-src/src/share/org/apache/tomcat/modules/session/SimpleSessionStore.java\t\nWed Jan  8 16:15:19 2003 \n@@ -207,7 +207,9 @@ \n \tSimpleSessionManager sm= getManager( ctx ); \n \n \tif( sm == null ) { \n-\t    sm=new SimpleSessionManager(); \n+          SessionRecycler r = new SessionRecycler(); \n+          r.startRecycler() \n+\t    sm=new SimpleSessionManager(r); \n \t    sm.setDebug( debug ); \n \t    sm.setModule( this ); \n \t    ctx.getContainer().setNote( manager_note, sm ); \n@@ -236,16 +238,16 @@ \n \t    session.setState( ServerSession.STATE_SUSPEND ); \n \t    session.setState( ServerSession.STATE_EXPIRED ); \n \t} \n+      sm.getSessionRecycler.stopRecycler(); \n     } \n \n     public int sessionState( Request req, ServerSession session, int state ) \n{ \n \tTimeStamp ts=session.getTimeStamp(); \n \n \tif( state==ServerSession.STATE_EXPIRED ) { \n-\t    // session moved to expire state - remove all attributes from \n-\t    // storage \n-\t    SimpleSessionManager \nssm=(SimpleSessionManager)session.getManager(); \n-\t    ssm.removeSession( session ); \n+\t    // session moved to expire state - register to be recycled \n+\t    ((SimpleSessionManager)session.getManager()).getSessionRecycler() \n+             .registerToRecycle(session); \n \t} \n \treturn state; \n     } \n@@ -288,8 +290,9 @@ \n      * The actual \"simple\" manager \n      * \n      */ \n-    public static class SimpleSessionManager \n+    public static class SimpleSessionManager \n     { \n+      private SessionRecycler sessionRecycler; \n \tprivate int debug=0; \n \tprivate BaseInterceptor mod; \n \t/** The set of previously recycled Sessions for this Manager. \n@@ -302,8 +305,13 @@ \n \t */ \n \tprotected Hashtable sessions = new Hashtable(); \n \n-\tpublic SimpleSessionManager() { \n+\tpublic SimpleSessionManager(SessionRecycler r) { \n+        sessionRecycler = r \n \t} \n+ \n+      public SessionRecycler getSessionRecycler() { \n+        return sessionRecycler; \n+      } \n \n \tpublic void setDebug( int l ) { \n \t    debug=l; \n@@ -385,4 +393,62 @@ \n \t} \n \n     } \n+/** \n+ * Recycles Sessions after waiting for some time. \n+ * Fast Recycling is dangerous this it allows Threads to \n+ * access sessions after it's been recycled \n+ * \n+ * @author Christian Wicke cwicke@ics.uci.edu \n+ */ \n+ // Some of the code was borrowed from Expirer.java and Reaper.java \n+public final class SessionRecycler extends Thread { \n+    private long interval = 1000 * 60; //ms \n+    private Stack toBeRecycledNow; \n+    private Stack toBeRecycledLater; \n+    private boolean running; \n+ \n+    private SessionRecycler() { \n+      toBeRecycledNow = new Stack(); \n+      toBeRecycledLater = new Stack(); \n+    } \n+ \n+    public synchronized void startRecycler() { \n+      this.running = true; \n+      this.start(); \n+    } \n+ \n+    public synchronized void stopRecycler() { \n+      this.running = false; \n+      System.out.println(\"Stop recycler\"); \n+      this.interrupt(); \n+    } \n+ \n+    public synchronized void registerToRecycle(ServerSession s) { \n+      toBeRecycledLater.push(s); \n+    } \n+ \n+    public void run() { \n+ \twhile (running) { \n+\t    if( !running) break; \n+\t    try { \n+\t\tthis.sleep(interval); \n+\t    } catch (InterruptedException ie) { \n+\t\t// wake up when stopRecycler has been called \n+\t    } \n+ \n+\t    if( !running) break; \n+          while (!toBeRecycledNow.empty()) { \n+            ServerSession s = (ServerSession) toBeRecycledNow.pop(); \n+            SimpleSessionManager ssm=(SimpleSessionManager)s.getManager(); \n+            ssm.removeSession( s ); \n+          } \n+          synchronized (this) { \n+            Stack temp = toBeRecycledNow; \n+            toBeRecycledNow = toBeRecycledLater; \n+            toBeRecycledLater = temp; \n+          } \n+\t} \n+    } \n+} \n+ \n }"}, {"count": 1, "attachment_id": null, "bug_id": 15894, "is_private": false, "id": 29105, "time": "2003-01-10T05:43:07Z", "creator": "william.barker@wilshire.com", "creation_time": "2003-01-10T05:43:07Z", "tags": [], "text": "Fixed now in the CVS, and will appear in the next nightly."}, {"count": 2, "tags": [], "creator": "christian.wicke@rwg.de", "attachment_id": null, "is_private": false, "id": 29359, "time": "2003-01-14T17:22:05Z", "bug_id": 15894, "creation_time": "2003-01-14T17:22:05Z", "text": "Hello William,\n\nThanks for your fast reaction to my error report. I especially like that you \nuse two states now for EXPIRED and INVALID.\nYou fixed my problem by checking in request.getSession whether the session has \nstill the same sessionId. This works if the servlet/JSP uses request.getSession \nbefore it uses the session.\nHowever, if you remove the line with\n  s = request.getSession(true); \n(the one after sleep(5000);\nof my the example JSP you still get the same mistake. That why reopened the bug \nagain.\nThis problem is not just theoretical. The problem occurs when the client klicks \nmany times without waiting for the server to deliver the page. If a normal \nrequest and a log-off request is processed simultaneous, the normal request \nwill always read and write into the session of somebody else who logged in \nmeantime.\nI see four solutions to this problem:\n1. we delay the state change from EXPIRED to INVALID. With delay I mean to wait \ncouple (e.g. 60) seconds. The state change from EXPIRED to INVALID could be \neither done by the Expirer or elsewhere.\n2. we check on every access from HttpSessionFacade to ServerSession that we \nstill have the right session as you did in request.getSession. We could do it \nin HttpSessionFacade.checkValid() for those methods who call it.\n3. we register the HttpSessionFacade as listener for state change of the \nsession. When the session gets expired we delete the reference session.\nWe would have to check on session != null every time we use it.\n4. We set session to null in HttpSessionFacade.invalidate. The rest is like (3).\nThe problem here is that it only works if the session is invalidated through \nHttpSessionFacade.invalidate, but this should be ok.\nIf you need my help for any solution, please let me know.\n\nDo you know by chance, how soon tomcat 3.3.2 will be released?\nThanks a lot,\nChristian"}, {"count": 3, "tags": [], "bug_id": 15894, "attachment_id": null, "text": "Fixed now in the CVS.\n\nI went for a hybrid of your 2 and 3.\n\nThe answer for when 3.3.2 is going to be released is: Hopefully soon.  ", "id": 29388, "time": "2003-01-15T06:21:17Z", "creator": "william.barker@wilshire.com", "creation_time": "2003-01-15T06:21:17Z", "is_private": false}, {"count": 4, "tags": [], "creator": "william.barker@wilshire.com", "attachment_id": null, "id": 31327, "time": "2003-02-15T03:48:35Z", "bug_id": 15894, "creation_time": "2003-02-15T03:48:35Z", "is_private": false, "text": "*** Bug 17094 has been marked as a duplicate of this bug. ***"}, {"count": 5, "tags": [], "creator": "william.barker@wilshire.com", "attachment_id": null, "is_private": false, "id": 33272, "time": "2003-03-16T20:58:06Z", "bug_id": 15894, "creation_time": "2003-03-16T20:58:06Z", "text": "*** Bug 18044 has been marked as a duplicate of this bug. ***"}, {"count": 6, "tags": [], "creator": "william.barker@wilshire.com", "attachment_id": null, "id": 33274, "time": "2003-03-16T22:07:35Z", "bug_id": 15894, "creation_time": "2003-03-16T22:07:35Z", "is_private": false, "text": "*** Bug 12759 has been marked as a duplicate of this bug. ***"}, {"count": 7, "tags": [], "text": "*** Bug 18540 has been marked as a duplicate of this bug. ***", "is_private": false, "bug_id": 15894, "id": 45447, "time": "2003-10-12T20:30:30Z", "creator": "william.barker@wilshire.com", "creation_time": "2003-10-12T20:30:30Z", "attachment_id": null}, {"text": "*** Bug 24998 has been marked as a duplicate of this bug. ***", "tags": [], "bug_id": 15894, "is_private": false, "count": 8, "id": 48650, "time": "2003-12-07T23:06:13Z", "creator": "william.barker@wilshire.com", "creation_time": "2003-12-07T23:06:13Z", "attachment_id": null}]