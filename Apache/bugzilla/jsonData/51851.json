[{"count": 0, "tags": [], "bug_id": 51851, "attachment_id": null, "id": 149529, "time": "2011-09-20T18:23:09Z", "creator": "mattiase@acm.org", "creation_time": "2011-09-20T18:23:09Z", "is_private": false, "text": "The version of apr_atomic_xchgptr() in atomic/unix/ia32.c is completely broken:\n\nAPR_DECLARE(void*) apr_atomic_xchgptr(volatile void **mem, void *with)\n{\n    void *prev;\n#if APR_SIZEOF_VOIDP == 4\n    asm volatile (\"xchgl %2, %1\"\n                  : \"=a\" (prev), \"+m\" (*mem)\n                  : \"0\" (with));\n#elif APR_SIZEOF_VOIDP == 8\n    asm volatile (\"xchgq %q2, %1\"\n                  : \"=a\" (prev), \"+m\" (*mem)\n                  : \"r\" ((unsigned long)with));\n#else\n#error APR_SIZEOF_VOIDP value not supported\n#endif\n    return prev;\n}\n\nFor x86-64, the generated asm will be something like\n\n  a0:   48 87 37                xchg   %rsi,(%rdi)\n  a3:   c3                      retq   \n\nwhich is clearly wrong; the return value (%rax) isn't set, so the function returns garbage. This makes svn crash on startup when this code is used.\nSuggested patch:\n\n--- atomic/unix/ia32.c  (revision 1173061)\n+++ atomic/unix/ia32.c  (arbetskopia)\n@@ -117,7 +117,7 @@\n #elif APR_SIZEOF_VOIDP == 8\n     asm volatile (\"xchgq %q2, %1\"\n                   : \"=a\" (prev), \"+m\" (*mem)\n-                  : \"r\" ((unsigned long)with));\n+                  : \"0\" ((unsigned long)with));\n #else\n #error APR_SIZEOF_VOIDP value not supported\n #endif\n\nThe cast to unsigned long should really go away as well; it just breaks the code on IL32P64 platforms for no good reason.\n\nBy the way, the same function in atomic/unix/builtins.c is correct, but it adds an mfence instruction. I'm not sure that is needed - the XCHG instruction has an implicit memory fence."}, {"count": 1, "tags": [], "bug_id": 51851, "attachment_id": null, "id": 149530, "time": "2011-09-20T18:27:39Z", "creator": "mattiase@acm.org", "creation_time": "2011-09-20T18:27:39Z", "is_private": false, "text": "Related bugs: bug 50731 (wrong volatile qualifier in signature) and bug 42806 (origin of the code)."}, {"count": 2, "tags": [], "bug_id": 51851, "text": "This bug is not necessarily caught by the regression test (testatomic.c), because of a poor choice of test pointer value (NULL). The following patch makes the test stronger, and actually catches the bug:\n\n--- test/testatomic.c\t(revision 1174015)\n+++ test/testatomic.c\t(arbetskopia)\n@@ -84,11 +84,12 @@\n static void test_xchgptr(abts_case *tc, void *data)\n {\n     int a;\n-    volatile void *target_ptr = NULL;\n+    void *ref = \"little piggy\";\n+    volatile void *target_ptr = ref;\n     void *old_ptr;\n \n     old_ptr = apr_atomic_xchgptr(&target_ptr, &a);\n-    ABTS_PTR_EQUAL(tc, NULL, old_ptr);\n+    ABTS_PTR_EQUAL(tc, ref, old_ptr);\n     ABTS_PTR_EQUAL(tc, &a, (void *) target_ptr);\n }\n \nAlso note that for the bug to show up, the bad code in atomic/unix/ia32.c must be used, which is only the case when a gcc without builtin sync primitives was used for the configuration script - that is, gcc 4.0.x or older.", "id": 149614, "time": "2011-09-22T09:58:27Z", "creator": "mattiase@acm.org", "creation_time": "2011-09-22T09:58:27Z", "is_private": false, "attachment_id": null}, {"count": 3, "tags": [], "bug_id": 51851, "attachment_id": null, "id": 166747, "time": "2013-04-21T21:32:05Z", "creator": "sf@sfritsch.de", "creation_time": "2013-04-21T21:32:05Z", "is_private": false, "text": "Thanks for the analysis and test case.\n\ntrunk commit: r1470348\n1.5: r1470349\n1.4: r1470350"}, {"count": 4, "tags": [], "creator": "trawick@apache.org", "attachment_id": null, "id": 172591, "time": "2014-01-21T12:56:27Z", "bug_id": 51851, "creation_time": "2014-01-21T12:56:27Z", "is_private": false, "text": "Fixed in apr 1.4.7 and later releases."}]