[{"count": 0, "tags": [], "bug_id": 49754, "attachment_id": 25892, "text": "Created attachment 25892\npatch\n\nThis patch tries to fix the problems with the clone method as reported by findbugs.\n\nThe fix is not straightforward. The current design deviates from the design advocated by findbugs and the documentation of Object.clone(). It is sometimes hard to guess the author's intention with the original clone method. Often the clone is not completely deep; was this intentional or not? This patch makes almost always deep copies, esp. in the subclasses of AreaTreeObject. This patch passes all existing junit tests. Since findbugs requires more memory than my machine has, I could not check if this patch removes all findbugs warnings for clone.\n\nHow does clone differ from a copy constructor? Is it a bad situation to have both a clone method and a copy constructor? Is it advisable to delete one of them?\n\nBecause it is not straightforward, I submit this as a patch, instead of committing it right away.", "id": 139105, "time": "2010-08-16T09:19:35Z", "creator": "spepping@apache.org", "creation_time": "2010-08-16T09:19:35Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 49754, "attachment_id": null, "is_private": false, "id": 143220, "time": "2011-01-09T17:34:33Z", "creator": "adelmelle@apache.org", "creation_time": "2011-01-09T17:34:33Z", "text": "(In reply to comment #0)\n> \n> How does clone differ from a copy constructor? \n\nMainly in the returned type. The result of a call to a copy constructor will always be statically typed as the class where the constructor is defined. This can lead to undesired results if the parameter is an instance of a subclass, unless either:\na) the copy constructor is overridden in the subclass, which makes it awkward to use vs. a single clone() method, or\nb) the superclass' copy constructor contains some convoluted reflection logic to test the parameter for its runtime type (but that would not take into account possible subclasses out of your control)\n\nclone(), on the other hand, is guaranteed to always return an instance of Object, whose actual runtime type is (recommended to be) identical to that of the instance for which it is called. In practice, Object.clone() respect this, so having the Cloneable interface is enough for basic shallow cloning to be enabled. The key advantage being that in your code it takes only a single statement to invoke. The Java runtime will sort out which implementation to use.\n\n> Is it a bad situation to have both a clone method and a copy constructor?\n> Is it advisable to delete one of them?\n\nBoth have their merits. From the point of view of an internal API, if the class itself is final or you know in advance precisely which type(s) you need, a set of copy constructors will generally be more appropriate. From the point of view of an external API, where you need to accommodate potential subclasses, clone() would be the way to go.\nLooking closer at the code, especially for the AreaTreeObject subclasses, clone() is only used by the Java2DRenderer, and even then, it is only called externally on PageViewport. All the other calls to clone() happen internally in the area package. There seems to be no hard requirement at all to have a public API to create clones/copies of all the other object classes, so there I would be more inclined to opt for protected copy constructors, or an optimized set of static factory-like methods, maybe...?"}, {"count": 2, "tags": [], "creator": "gadams@apache.org", "attachment_id": null, "id": 157492, "time": "2012-04-07T01:43:51Z", "bug_id": 49754, "creation_time": "2012-04-07T01:43:51Z", "is_private": false, "text": "resetting P2 open bugs to P3 pending further review"}, {"count": 3, "tags": [], "text": "lower priority to P5, since this patch would not have an impact on features or performance", "is_private": false, "bug_id": 49754, "id": 157679, "time": "2012-04-08T09:05:54Z", "creator": "gadams@apache.org", "creation_time": "2012-04-08T09:05:54Z", "attachment_id": null}, {"count": 4, "tags": [], "creator": "gadams@apache.org", "text": "increase priority due to presence of a patch", "id": 157695, "time": "2012-04-08T09:11:11Z", "bug_id": 49754, "creation_time": "2012-04-08T09:11:11Z", "is_private": false, "attachment_id": null}, {"count": 5, "tags": [], "creator": "gadams@apache.org", "text": "patch landed at http://svn.apache.org/viewvc?view=revision&revision=1311120 with a few minor changes; N.B. IFGraphicContext.clone was unable to employ super.clone() at this time, so this remains a findbugs exclusion for now;\n\nthanks simon!", "id": 157718, "time": "2012-04-08T23:53:33Z", "bug_id": 49754, "creation_time": "2012-04-08T23:53:33Z", "is_private": false, "attachment_id": null}, {"count": 6, "tags": [], "creator": "lmpmbernardo@gmail.com", "text": "this patch introduced bug 53942 for which there already a patch (attachment 29465) that fixes it. looking at it the question I have is whether MainReference should also implement its own clone() method which then would be called by the BodyRegion.clone().", "id": 162998, "time": "2012-10-27T20:07:13Z", "bug_id": 49754, "creation_time": "2012-10-27T20:07:13Z", "is_private": false, "attachment_id": null}]