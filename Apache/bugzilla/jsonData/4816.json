[{"attachment_id": null, "tags": [], "creator": "Ryan.Lubke@Sun.COM", "is_private": false, "count": 0, "id": 7789, "time": "2001-11-12T10:57:04Z", "bug_id": 4816, "creation_time": "2001-11-12T10:57:04Z", "text": "If using a multi-threaded client, where each thread issues multiple requests,\nthe servlet below, which implements the SingleThreadedModel interface, will fail\nto prevent multiple threads running the service() method.\n\nI can reproduce easily using 5 threads with 3 requests per thread.\n\nUsing the same servlet and client code against the resin container, I can\neasily increase to 100 client threads without failure.\n\n*******************************************************************************\npackage single;\n\nimport javax.servlet.*;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\npublic class SingleModelTestServlet extends GenericServlet implements\nSingleThreadModel {\n\n  private int threadCount = 0;\n  private StringBuffer sb = null;\n\n  public void service ( ServletRequest request, ServletResponse response\n)         throws ServletException, IOException {\n \n        /*\n         * The threadCount variable should be at 0 each time service() is\ninvoked\n         * by the container.  If a request enters, and it's not zero, fail\n         * the test by throwing a ServletException\n         */\n        try {\n            assertThreadCount( 0 );\n            threadCount++;\n        } catch ( MultipleThreadException mte ) {\n            sb = new StringBuffer( 100 );\n            sb.append( \"Thread counter was not 0 upon entering the service()\nmethod\\n\" );\n            sb.append( \"The value found was: \" );\n            sb.append( threadCount );\n            throw new ServletException( sb.toString() );\n        } finally {\n            sb = null;\n        }\n \n        /*\n         * threadCount has now been incremented, loop\n         * for a period of time and assert that threadCount\n         * never changes. After the loop completes, decrement\n         * threadCount and return.\n         */\n        try {\n            for ( int i = 0; i < 200000; i++ ) {\n                assertThreadCount( 1 );\n            }\n        } catch ( MultipleThreadException mte ) {\n            sb = new StringBuffer( 75 );\n            sb.append( \"Thread count changed during processing!\\n\" );\n            sb.append( \"Expected a value of 1, but found: \" );\n            sb.append( threadCount );\n            throw new ServletException( sb.toString() );\n        } finally {\n            sb = null;\n            threadCount--;\n        }\n    }\n\n    private void assertThreadCount( int val ) throws MultipleThreadException {\n        if ( threadCount != val ) {\n            throw new MultipleThreadException();\n        }\n    }\n\n    private class MultipleThreadException extends java.lang.Exception {\n\n        /*\n         * Creates a new <code>MultipleThreadException</code> instance.\n         *\n         */\n        public MultipleThreadException() {\n            super();\n        }\n    }\n}\n\n******************************************************************************"}, {"count": 1, "tags": [], "creator": "Ryan.Lubke@Sun.COM", "attachment_id": null, "id": 8425, "time": "2001-11-29T08:06:59Z", "bug_id": 4816, "creation_time": "2001-11-29T08:06:59Z", "is_private": false, "text": "Issue is only apparent when running the J2EE RI."}, {"count": 2, "text": "Guess I requested this to be closed too soon.\nI'm able to get the failure to appear with TC 4.01 with 20 client threads.\n\nI'm adding the client code to make this issue easily reproduced.\n\nTo run the client issue:  java Client <hostname> <port> <number_of_threads>\n<request path>\n\nWhen a failure occurs, the client will report an Exception that the server\nreturned a 500.\n\nCheck the TC log and the following message, or one similar depending on where\nthe failure occurred in the Servlet:\njavax.servlet.ServletException: Thread counter was not 0 upon entering the\nservice() method\nThe value found was: 1\n\n\n*******************************************************************************\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class Client {\n\n    private static final int SLEEPTIME      = 5000;\n    private static final int NUM_REQUESTS   = 3;\n\n    // For Thread Synchronization\n    private static int threadCount          = 0;\n    private static int threadsDone          = 0;\n    private static int errors               = 0;\n    private static int port                 = 0;\n    private static Object lock              = new Object();\n    private static Object startLock         = new Object();\n    private static Object workLock          = new Object();\n    private static String hostname          = null;\n    private static String requestPath       = null;\n\n    public Client( String hostname, int port, int threadCount, String\nrequestPath ) {\n        this.hostname    = hostname;\n        this.port        = port;\n        this.threadCount = threadCount;\n        this.requestPath  = requestPath;\n    }\n\n    public void runTest() {\n\n        try {\n            Thread[] testThread = new Thread[ threadCount ];\n\n            for ( int i = 0; i < threadCount; i++ ) {\n                testThread[ i ] = new Thread( new TestThread( i ), \"TestThread-\"\n+ i );\n                testThread[ i ].setPriority( Thread.MAX_PRIORITY );\n                testThread[ i ].start();\n            }\n\n            synchronized( lock ) {\n                while ( threadsDone < testThread.length ) {\n                    lock.wait();\n                }\n\n                try {\n                    Thread.sleep( SLEEPTIME );\n                } catch ( Exception e ) {\n                    ;\n                }\n            }\n\n            //notify all to start\n            synchronized( startLock ) {\n                threadsDone = 0;\n                startLock.notifyAll();\n            }\n            //wait for completion\n            synchronized( lock ) {\n                while ( threadsDone < testThread.length ) {\n                    lock.wait();\n                }\n            }\n\n            if ( errors > 0 ) {\n                System.err.println( \"Number of Errors: \" + errors );\n                System.err.println( \"Test FAILED\" );\n            } else {\n                System.out.println( \"No Errors.  Test PASSED\" );\n            }\n        } catch ( Exception e ) {\n            System.err.println( \"Unexpected Exception in runTest()!\" );\n            System.err.println( \"Exception: \" + e.toString() );\n            System.err.println( \"Message: \" + e.getMessage() );\n            e.printStackTrace();\n            System.exit( 1 );\n        }\n    }\n\n    public static void main( String[] args ) {\n        Client client = new Client( args[ 0 ], new Integer( args[ 1 ] ).intValue(),\n                        new Integer( args[ 2 ] ).intValue(), args[ 3 ] );\n        client.runTest();\n        System.exit( 0 );\n    }\n\n    class TestThread implements Runnable {\n\n        // Instance variables\n        private int threadNum       = 0;\n        private boolean synchronize = true;\n\n        public TestThread( int threadNum ) {\n            this.threadNum = threadNum;\n        }\n\n        public void run() {\n\n            synchronized( lock ) {\n                ++threadsDone;\n                lock.notifyAll();\n            }\n\n            synchronized( startLock ) {\n                try {\n                    startLock.wait();\n                } catch ( InterruptedException ie ) {\n                    ;\n                }\n            }\n            this.runSingleThreadModelTest();\n\n            synchronized( lock ) {\n                ++threadsDone;\n                lock.notifyAll();\n            }\n        }\n\n        public void runSingleThreadModelTest() {\n\n            for ( int i = 0; i < 3; i++ ) {\n                try {\n                    URL url = new URL( \"http://\" + hostname + \":\" + port +\nrequestPath );\n                    HttpURLConnection conn = (HttpURLConnection)\nurl.openConnection();\n                    conn.setRequestMethod( \"GET\" );\n                    conn.connect();\n                    int code = conn.getResponseCode();\n                    if ( code != HttpURLConnection.HTTP_OK ) {\n                        synchronized( lock ) {\n                            ++errors;\n                        }\n                    }\n                } catch ( Exception e ) {\n                    System.err.println( \"Unexpected Exception in\nrunSingleThreadModelTest()!\" );\n                    System.err.println( \"Exception: \" + e.toString() );\n                    System.err.println( \"Message: \" + e.getMessage() );\n                    e.printStackTrace();\n                    System.exit( 1 );\n               }\n           }\n\n        }\n\n    }\n}\n\n************************************************", "bug_id": 4816, "attachment_id": null, "id": 8430, "time": "2001-11-29T10:19:26Z", "creator": "Ryan.Lubke@Sun.COM", "creation_time": "2001-11-29T10:19:26Z", "tags": [], "is_private": false}, {"count": 3, "text": "Fixed in 12/05 nightly.", "bug_id": 4816, "is_private": false, "id": 8587, "time": "2001-12-04T19:35:59Z", "creator": "remm@apache.org", "creation_time": "2001-12-04T19:35:59Z", "tags": [], "attachment_id": null}]