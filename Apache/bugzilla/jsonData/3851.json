[{"count": 0, "tags": [], "text": "I have found out that a class of type SingleThreadModel will not be\nsynchronized, which gives serious problem with thread security. This works in\nthe 3.1 release so it must have been removed in either the 3.2.2 rewrite or in\nthe 3.2 release.", "is_private": false, "bug_id": 3851, "id": 6087, "time": "2001-09-27T02:19:24Z", "creator": "lars-arne.mattsson@iconmedialab.se", "creation_time": "2001-09-27T02:19:24Z", "attachment_id": null}, {"count": 1, "attachment_id": null, "creator": "cmanolache@yahoo.com", "is_private": false, "id": 6126, "time": "2001-09-27T12:41:50Z", "bug_id": 3851, "creation_time": "2001-09-27T12:41:50Z", "tags": [], "text": "There are some known problems with SingleThread, it's better to not rely on it. Fixing for 3.2.x is unlikely, same for 3.3. You can do your own syncronization. "}, {"count": 2, "attachment_id": null, "creator": "mats.lofkvist@polopoly.com", "is_private": false, "id": 6154, "time": "2001-09-28T01:48:29Z", "bug_id": 3851, "creation_time": "2001-09-28T01:48:29Z", "tags": [], "text": "Using a single instance and synchronizing the requests is just\nnot acceptable since it results in horrible performance when\nmultiple users are requesting the same object.\n\nSo neither 'doing or own synchronization' or the Tomcat 4 hack\nwith a single instance is a working solution to this problem.\n\nOf course, SingleThreadModel wouldn't be in the standard at all\nif synchronizing was an acceptale solutions (since just adding\n'synchronzied' to the service() method would achieve the same effect)."}, {"count": 3, "attachment_id": null, "creator": "bojan@binarix.com", "is_private": false, "id": 6156, "time": "2001-09-28T04:11:50Z", "bug_id": 3851, "creation_time": "2001-09-28T04:11:50Z", "tags": [], "text": "This is a very interesting report. Here is what the API documentation says about\nSingleThreadModel interface:\n\n-------------------------------\nIf a servlet implements this interface, you are guaranteed that no two threads\nwill execute concurrently in the servlet's service method. The servlet container\ncan make this guarantee by synchronizing access to a single instance of the\nservlet, or by maintaining a pool of servlet instances and dispatching each new\nrequest to a free servlet. \n-------------------------------\n\nI think Tomcat is using the pool approach here, which means that the whole thing\nis not always synchronised, since it doesn't have to be. All that needs to\nhappen is that no two threads are executing the same service method\nconcurrently.\n\nWhat am I missing here?"}, {"count": 4, "tags": [], "creator": "mats.lofkvist@polopoly.com", "text": "Bojan, the behaviour you describe is correct (and what we want).\nThe problem is that no version of Tomcat (at least not 3.1, 3.2\nor 4.0) implements the pooling, resulting in bad performance.\n\nAnd to make things worse, 3.2.3 completely ignores SingleThreadModel\n(and the 'isThreadSafe=\"false\"' declaration) for JSPs, resulting\nin broken pages.\n\nI have attached 3 test cases. The first ('STMServlet.java')\nis a plain servlet implementing SingleThreadModel. This case works\nin Tomcat 3.1.1, 3.2.3 and 4.0, but with very bad perfomance since\nall requests are synchronized on a single instance.\n\nThe second test case ('isThreadSafe.jsp') is a plain JSP using\nthe 'isThreadSafe=\"false\"' declaration. This one works (but with\nthe performance problem) with 3.1.1 and 4.0, but NOT with 3.2.3.\nThe latter allows multiple requests to enter the (single) JSP\ninstance simultaneously.\n\nThe third test case ('STMBase.java' and 'STMBase.jsp') consists of\na base class implementing SingleThreadModel extended by the JSP.\nThis test behaves the same as the second one above, i.e. 'works'\nwith 3.1.1 and 4.0 but not with 3.2.3.", "id": 6194, "time": "2001-09-29T04:22:42Z", "bug_id": 3851, "creation_time": "2001-09-29T04:22:42Z", "is_private": false, "attachment_id": null}, {"count": 5, "attachment_id": 614, "creator": "mats.lofkvist@polopoly.com", "text": "Created attachment 614\nSTMBase.java, SingleThreadModel JSP base class.", "id": 6195, "time": "2001-09-29T04:24:23Z", "bug_id": 3851, "creation_time": "2001-09-29T04:24:23Z", "tags": [], "is_private": false}, {"count": 6, "tags": [], "creator": "mats.lofkvist@polopoly.com", "attachment_id": 615, "id": 6196, "time": "2001-09-29T04:25:05Z", "bug_id": 3851, "creation_time": "2001-09-29T04:25:05Z", "is_private": false, "text": "Created attachment 615\nSTMBase.jsp, JSP extending STMBase.java"}, {"count": 7, "tags": [], "creator": "mats.lofkvist@polopoly.com", "text": "Created attachment 616\nSTMServlet.java, SingleThreadModel servlet", "id": 6197, "time": "2001-09-29T04:26:40Z", "bug_id": 3851, "creation_time": "2001-09-29T04:26:40Z", "is_private": false, "attachment_id": 616}, {"count": 8, "tags": [], "bug_id": 3851, "is_private": false, "text": "Created attachment 617\nisThreadSafe.jsp, JSP declaring isThreadSafe=\"false\"", "id": 6198, "time": "2001-09-29T04:27:17Z", "creator": "mats.lofkvist@polopoly.com", "creation_time": "2001-09-29T04:27:17Z", "attachment_id": 617}, {"count": 9, "tags": [], "text": "I don't think we'll fix this for 3.3. I'll mark it as LATER, maybe someone commits a patch and we can add this in 3.3.x.\n\n\nI didn't meant you should synchronize 'service', but make it thread-safe and \nkeep the code that needs synchronization in classes where you do the synchronization ( or use a pool of objects, etc). \n\nIf you use a variable in your servlet, and SingleThreadModel, there's absolutely no guarantee the access will be safe - even worse, a counter will work completely different from what you would exepect ( since if a pool is used, each pool servlet will have it's own count) - unless a container is using synchronization, then you'll have a single counter.\n\n\n", "attachment_id": null, "bug_id": 3851, "id": 6201, "time": "2001-09-29T07:20:43Z", "creator": "cmanolache@yahoo.com", "creation_time": "2001-09-29T07:20:43Z", "is_private": false}, {"count": 10, "tags": [], "bug_id": 3851, "attachment_id": null, "text": "We are using base classes for JSP's (as with STMBase.java and STMBase.jsp)\nto provide the JSP with request-specific members. What we need is exactly\nwhat SingleThreadModel specified to do: making sure that a specific instance\nof a servlet is only used for a single request at a time.\n\nWith Tomcat 3.2.3 we end up with different requests accessing each others\nrequest specific data instead of their own under high load, braking pages in\nvarious mysterious ways.\n\n(Rewriting the code to work around the bug would change the API our customers\nare using, so we just tell them not to use Tomcat for now.)\n\n\n\n\n", "id": 6207, "time": "2001-09-29T09:35:05Z", "creator": "mats.lofkvist@polopoly.com", "creation_time": "2001-09-29T09:35:05Z", "is_private": false}, {"count": 11, "tags": [], "creator": "bojan@binarix.com", "attachment_id": null, "id": 6217, "time": "2001-09-30T17:37:25Z", "bug_id": 3851, "creation_time": "2001-09-30T17:37:25Z", "is_private": false, "text": "After reading the source for TC 3.3, I can now see I was totally wrong about the\npool approach. There are comments about it in the code, but it doesn't seem to\nbe implemented. JServ used to use the pool approach (as in: good old JServ!), so\nI thought this must be the case in TC as well. I missed one minor detail here:\nJServ and Tomcat have nothing to do with one another...\n\nI have found this code snippet in ServletHandler.java of TC 3.3:\n\n--------------------------------------------------------\n if (servlet instanceof SingleThreadModel) {\n   synchronized(servlet) {\n     servlet.service(reqF, resF);\n   }\n } else {\n   servlet.service(reqF, resF);\n }\n--------------------------------------------------------\n\nwhich suggest that during the execution of service(), servlet is synchronised\nfor SingleThreadModel. This is a piece of code from JspServlet.java:\n\n--------------------------------------------------------\n if (servlet instanceof SingleThreadModel) {\n   // sync on the wrapper so that the freshness\n   // of the page is determined right before servicing\n   synchronized (this) {\n     servlet.service(request, response);\n   }\n } else {\n   servlet.service(request, response);\n }\n-------------------------------------------------------\n\nwhich also suggests syncronisation for SingleThreadModel.\n\nCan someone that understands this whole thing a bit better comment. I think we\nshould be very clear in release notes of TC 3.3 if it doesn't comply with parts\nof the spec.\n\nFrom the code, it seems to be compliant..."}, {"count": 12, "attachment_id": null, "bug_id": 3851, "is_private": false, "id": 6222, "time": "2001-10-01T02:43:53Z", "creator": "mats.lofkvist@polopoly.com", "creation_time": "2001-10-01T02:43:53Z", "tags": [], "text": "If that is the code I'm running, it implies that more than one\n'wrapper' is created for the same servlet when the servlet is\na JSP.\n\nI guess changing 'synchronized(this)' to 'synchronized(servlet)'\nin JspServlet.java would fix the bug.\n\n(Note that this is what the code in ServletHandler.java already \ndoes which is consistent with the fact that we see the bug with\nJSPs but not with plain servlets.)\n\n\n"}, {"count": 13, "tags": [], "creator": "mats.lofkvist@polopoly.com", "attachment_id": null, "is_private": false, "id": 6227, "time": "2001-10-01T07:26:17Z", "bug_id": 3851, "creation_time": "2001-10-01T07:26:17Z", "text": "We have found the bug. JspServlet is using an internal wrapper\nclass JspCountedServlet that do not check for SingleThreadModel.\n\n\n(Note the diff is backwards, i.e. 'diff new old')\n***\njakarta-tomcat-3.2.3-src/src/share/org/apache/jasper/servlet/JspServlet.java       \nMon\nOct  1 15:54:53 2001 \n--- tmp/jakarta-tomcat-3.2.3/src/org/apache/jasper/servlet/JspServlet.java     \nTue Jul 17\n18:57:50 2001 \n*************** \n*** 127,141 **** \n          { \n              try{ \n                  incrementCount(); \n! \n!                 if(servlet instanceof SingleThreadModel) { \n!                     synchronized (servlet) { \n!                       servlet.service(req, res); \n!                     } \n!                 } else { \n!                   servlet.service(req, res); \n!                 } \n! \n              }catch(NullPointerException e){ \n                  throw new JasperException(e); \n              }finally{ \n--- 127,133 ---- \n          { \n              try{ \n                  incrementCount(); \n!                 servlet.service(req, res); \n              }catch(NullPointerException e){ \n                  throw new JasperException(e); \n              }finally{ \n"}, {"text": "Tomcat 3.3 does not use JspServlet by default - this a legacy behaviour. It is\ncontrolled by:\n\nuseJspServlet=\"(true|false)\"\n\nof the JspInterceptor. Default is false which causes JspServlet code not to be\nused at all, but rather straight servlet code.\n\nAnyway, your patch has been committed in case someone out there (including you)\nmight want to use JspServlet with TC 3.3.\n\nI think after Craigs comments in bug 3884\n<http://nagoya.apache.org/bugzilla/show_bug.cgi?id=3884>, less people will be\ninclined to use SingleThreadModel.\n\nPS. Thanks Costin ;-)", "tags": [], "bug_id": 3851, "attachment_id": null, "count": 14, "id": 6290, "time": "2001-10-02T15:07:43Z", "creator": "bojan@binarix.com", "creation_time": "2001-10-02T15:07:43Z", "is_private": false}, {"count": 15, "attachment_id": null, "bug_id": 3851, "is_private": false, "id": 6350, "time": "2001-10-04T01:31:27Z", "creator": "mats.lofkvist@polopoly.com", "creation_time": "2001-10-04T01:31:27Z", "tags": [], "text": "From the early comments we draw the conclusion that this bug was\nknown to exist and would not be fixed in the 3.3 branch.\n\nActually, a check with 3.3rc1 shows that the bug does not show\nup in 3.3rc1 with our code.\n\n(It obviosly would show up if useJspServlet was set to true,\nbut I see no reason we would want to do that. And even that\ncase should be fixed now.)\n\n"}]