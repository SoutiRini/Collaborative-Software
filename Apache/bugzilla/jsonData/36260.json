[{"count": 0, "tags": [], "bug_id": 36260, "attachment_id": null, "text": "I  have attached updated XSLTProcess.java (xslt task) to support failonerror \nproperty. Otherwise when using xslt to generate report (from xmt to html), and \nxml is not valid (generated from jmeter in my case), the task and the whole \nbuild fails.\n\n\nXSLTProcess.java:\n\n/*\n * Copyright  2000-2005 The Apache Software Foundation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n */\n\npackage org.apache.tools.ant.taskdefs;\n\nimport java.io.File;\nimport java.util.Enumeration;\nimport java.util.Vector;\nimport org.apache.tools.ant.AntClassLoader;\nimport org.apache.tools.ant.BuildException;\nimport org.apache.tools.ant.DirectoryScanner;\nimport org.apache.tools.ant.DynamicConfigurator;\nimport org.apache.tools.ant.Project;\nimport org.apache.tools.ant.types.Mapper;\nimport org.apache.tools.ant.types.Path;\nimport org.apache.tools.ant.types.Reference;\nimport org.apache.tools.ant.types.XMLCatalog;\nimport org.apache.tools.ant.util.FileNameMapper;\nimport org.apache.tools.ant.util.FileUtils;\n\n/**\n * Processes a set of XML documents via XSLT. This is\n * useful for building views of XML based documentation.\n *\n *\n * @since Ant 1.1\n *\n * @ant.task name=\"xslt\" category=\"xml\"\n */\n\npublic class XSLTProcess extends MatchingTask implements XSLTLogger {\n    /** destination directory */\n    private File destDir = null;\n\n    /** where to find the source XML file, default is the project's basedir */\n    private File baseDir = null;\n\n    /** XSL stylesheet */\n    private String xslFile = null;\n\n    /** extension of the files produced by XSL processing */\n    private String targetExtension = \".html\";\n\n    /** additional parameters to be passed to the stylesheets */\n    private Vector params = new Vector();\n\n    /** Input XML document to be used */\n    private File inFile = null;\n\n    /** Output file */\n    private File outFile = null;\n\n    /** The name of the XSL processor to use */\n    private String processor;\n\n    /** Classpath to use when trying to load the XSL processor */\n    private Path classpath = null;\n\n    /** The Liason implementation to use to communicate with the XSL\n     *  processor */\n    private XSLTLiaison liaison;\n\n    /** Flag which indicates if the stylesheet has been loaded into\n     *  the processor */\n    private boolean stylesheetLoaded = false;\n\n    /** force output of target files even if they already exist */\n    private boolean force = false;\n\n    protected boolean failOnError = true;\n    \n    /** Utilities used for file operations */\n    private FileUtils fileUtils;\n\n    /** XSL output properties to be used */\n    private Vector outputProperties = new Vector();\n\n    /** for resolving entities such as dtds */\n    private XMLCatalog xmlCatalog = new XMLCatalog();\n\n    /** Name of the TRAX Liaison class */\n    private static final String TRAX_LIAISON_CLASS =\n                        \"org.apache.tools.ant.taskdefs.optional.TraXLiaison\";\n\n    /** Name of the now-deprecated XSLP Liaison class */\n    private static final String XSLP_LIAISON_CLASS =\n                        \"org.apache.tools.ant.taskdefs.optional.XslpLiaison\";\n\n    /** Name of the now-deprecated Xalan liaison class */\n    private static final String XALAN_LIAISON_CLASS =\n                        \"org.apache.tools.ant.taskdefs.optional.XalanLiaison\";\n\n    /**\n     * Whether to style all files in the included directories as well.\n     *\n     * @since Ant 1.5\n     */\n    private boolean performDirectoryScan = true;\n\n    /**\n     * factory element for TraX processors only\n     * @since Ant 1.6\n     */\n    private Factory factory = null;\n\n    /**\n     * whether to reuse Transformer if transforming multiple files.\n     * @since 1.5.2\n     */\n    private boolean reuseLoadedStylesheet = true;\n\n    /**\n     * AntClassLoader for the nested &lt;classpath&gt; - if set.\n     *\n     * <p>We keep this here in order to reset the context classloader\n     * in execute.  We can't use liaison.getClass().getClassLoader()\n     * since the actual liaison class may have been loaded by a loader\n     * higher up (system classloader, for example).</p>\n     *\n     * @since Ant 1.6.2\n     */\n    private AntClassLoader loader = null;\n\n    /**\n     * Mapper to use when a set of files gets processed.\n     *\n     * @since Ant 1.6.2\n     */\n    private Mapper mapperElement = null;\n\n    /**\n     * Creates a new XSLTProcess Task.\n     */\n    public XSLTProcess() {\n        fileUtils = FileUtils.newFileUtils();\n    } //-- XSLTProcess\n\n    /**\n     * Specify how errors are to be handled.\n     * Optional, default is <code>true</code>.\n     * <p>\n     * If set to <code>true</code> (default), throw a buildException if the\n     * parser yields an error.\n     * @param fail if set to <code>false</code> do not fail on error\n     */\n    public void setFailOnError(boolean fail) {\n        this.failOnError = fail;\n    }\n\n    /**\n     * Whether to style all files in the included directories as well;\n     * optional, default is true.\n     *\n     * @param b true if files in included directories are processed.\n     * @since Ant 1.5\n     */\n    public void setScanIncludedDirectories(boolean b) {\n        performDirectoryScan = b;\n    }\n\n    /**\n     * Controls whether the stylesheet is reloaded for every transform.\n     *\n     * <p>Setting this to true may get around a bug in certain\n     * Xalan-J versions, default is false.</p>\n     *\n     * @since Ant 1.5.2\n     */\n    public void setReloadStylesheet(boolean b) {\n        reuseLoadedStylesheet = !b;\n    }\n\n    /**\n     * Defines the mapper to map source to destination files.\n     * @exception BuildException if more than one mapper is defined\n     * @since Ant 1.6.2\n     */\n    public void addMapper(Mapper mapper) {\n        if (mapperElement != null) {\n            if (this.failOnError)\n                throw new BuildException(\"Cannot define more than one mapper\",\n                                         getLocation());\n            else\n                log(\"Cannot define more than one mapper in \" + getLocation());\n        }\n        mapperElement = mapper;\n    }\n\n    /**\n     * Executes the task.\n     *\n     * @exception BuildException if there is an execution problem.\n     * @todo validate that if either in or our is defined, then both are\n     */\n    public void execute() throws BuildException {\n        File savedBaseDir = baseDir;\n\n        DirectoryScanner scanner;\n        String[]         list;\n        String[]         dirs;\n\n        if (xslFile == null) {\n            if (this.failOnError)\n                throw new BuildException(\"no stylesheet specified\", getLocation\n());\n            else {\n                log(\"no stylesheet specified in \" + getLocation());\n                return;\n            }\n        }\n\n        if (inFile != null && !inFile.exists()) {\n            if (this.failOnError)\n                throw new BuildException(\"input file \" + inFile.toString() +\n                        \" does not exist\", getLocation());\n            else {\n                log(\"input file \" + inFile.toString() + \" does not exist in \" \n+ getLocation());\n                return;\n            }\n        }\n\n        try {\n            if (baseDir == null) {\n                baseDir = getProject().resolveFile(\".\");\n            }\n\n            liaison = getLiaison();\n\n            // check if liaison wants to log errors using us as logger\n            if (liaison instanceof XSLTLoggerAware) {\n                ((XSLTLoggerAware) liaison).setLogger(this);\n            }\n\n            log(\"Using \" + liaison.getClass().toString(), Project.MSG_VERBOSE);\n\n            File stylesheet = getProject().resolveFile(xslFile);\n            if (!stylesheet.exists()) {\n                stylesheet = fileUtils.resolveFile(baseDir, xslFile);\n                /*\n                 * shouldn't throw out deprecation warnings before we know,\n                 * the wrong version has been used.\n                 */\n                if (stylesheet.exists()) {\n                    log(\"DEPRECATED - the style attribute should be relative \"\n                        + \"to the project\\'s\");\n                    log(\"             basedir, not the tasks\\'s basedir.\");\n                }\n            }\n\n            // if we have an in file and out then process them\n            if (inFile != null && outFile != null) {\n                process(inFile, outFile, stylesheet);\n                return;\n            }\n\n            /*\n             * if we get here, in and out have not been specified, we are\n             * in batch processing mode.\n             */\n\n            //-- make sure Source directory exists...\n            if (destDir == null) {\n                String msg = \"destdir attributes must be set!\";\n                if (this.failOnError)\n                    throw new BuildException(msg);\n                else {\n                    log(msg);\n                    return;\n                }\n            }\n            scanner = getDirectoryScanner(baseDir);\n            log(\"Transforming into \" + destDir, Project.MSG_INFO);\n\n            // Process all the files marked for styling\n            list = scanner.getIncludedFiles();\n            for (int i = 0; i < list.length; ++i) {\n                process(baseDir, list[i], destDir, stylesheet);\n            }\n            if (performDirectoryScan) {\n                // Process all the directories marked for styling\n                dirs = scanner.getIncludedDirectories();\n                for (int j = 0; j < dirs.length; ++j) {\n                    list = new File(baseDir, dirs[j]).list();\n                    for (int i = 0; i < list.length; ++i) {\n                        process(baseDir, dirs[j] + File.separator + list[i],\n                                destDir, stylesheet);\n                    }\n                }\n            }\n        } finally {\n            if (loader != null) {\n                loader.resetThreadContextLoader();\n                loader = null;\n            }\n            liaison = null;\n            stylesheetLoaded = false;\n            baseDir = savedBaseDir;\n        }\n    }\n\n    /**\n     * Set whether to check dependencies, or always generate;\n     * optional, default is false.\n     *\n     * @param force true if always generate.\n     */\n    public void setForce(boolean force) {\n        this.force = force;\n    }\n\n    /**\n     * Set the base directory;\n     * optional, default is the project's basedir.\n     *\n     * @param dir the base directory\n     **/\n    public void setBasedir(File dir) {\n        baseDir = dir;\n    }\n\n    /**\n     * Set the destination directory into which the XSL result\n     * files should be copied to;\n     * required, unless <tt>in</tt> and <tt>out</tt> are\n     * specified.\n     * @param dir the name of the destination directory\n     **/\n    public void setDestdir(File dir) {\n        destDir = dir;\n    }\n\n    /**\n     * Set the desired file extension to be used for the target;\n     * optional, default is html.\n     * @param name the extension to use\n     **/\n    public void setExtension(String name) {\n        targetExtension = name;\n    }\n\n    /**\n     * Name of the stylesheet to use - given either relative\n     * to the project's basedir or as an absolute path; required.\n     *\n     * @param xslFile the stylesheet to use\n     */\n    public void setStyle(String xslFile) {\n        this.xslFile = xslFile;\n    }\n\n    /**\n     * Set the optional classpath to the XSL processor\n     *\n     * @param classpath the classpath to use when loading the XSL processor\n     */\n    public void setClasspath(Path classpath) {\n        createClasspath().append(classpath);\n    }\n\n    /**\n     * Set the optional classpath to the XSL processor\n     *\n     * @return a path instance to be configured by the Ant core.\n     */\n    public Path createClasspath() {\n        if (classpath == null) {\n            classpath = new Path(getProject());\n        }\n        return classpath.createPath();\n    }\n\n    /**\n     * Set the reference to an optional classpath to the XSL processor\n     *\n     * @param r the id of the Ant path instance to act as the classpath\n     *          for loading the XSL processor\n     */\n    public void setClasspathRef(Reference r) {\n        createClasspath().setRefid(r);\n    }\n\n    /**\n     * Set the name of the XSL processor to use; optional, default trax.\n     * Other values are \"xalan\" for Xalan1 and \"xslp\" for XSL:P, though the\n     * later is strongly deprecated.\n     *\n     * @param processor the name of the XSL processor\n     */\n    public void setProcessor(String processor) {\n        this.processor = processor;\n    }\n\n    /**\n     * Add the catalog to our internal catalog\n     *\n     * @param xmlCatalog the XMLCatalog instance to use to look up DTDs\n     */\n    public void addConfiguredXMLCatalog(XMLCatalog xmlCatalog) {\n        this.xmlCatalog.addConfiguredXMLCatalog(xmlCatalog);\n    }\n\n    /**\n     * Load processor here instead of in setProcessor - this will be\n     * called from within execute, so we have access to the latest\n     * classpath.\n     *\n     * @param proc the name of the processor to load.\n     * @exception Exception if the processor cannot be loaded.\n     */\n    private void resolveProcessor(String proc) throws Exception {\n        if (proc.equals(\"trax\")) {\n            final Class clazz = loadClass(TRAX_LIAISON_CLASS);\n            liaison = (XSLTLiaison) clazz.newInstance();\n        } else if (proc.equals(\"xslp\")) {\n            log(\"DEPRECATED - xslp processor is deprecated. Use trax \"\n                + \"instead.\");\n            final Class clazz = loadClass(XSLP_LIAISON_CLASS);\n            liaison = (XSLTLiaison) clazz.newInstance();\n        } else if (proc.equals(\"xalan\")) {\n            log(\"DEPRECATED - xalan processor is deprecated. Use trax \"\n                + \"instead.\");\n            final Class clazz = loadClass(XALAN_LIAISON_CLASS);\n            liaison = (XSLTLiaison) clazz.newInstance();\n        } else {\n            liaison = (XSLTLiaison) loadClass(proc).newInstance();\n        }\n    }\n\n    /**\n     * Load named class either via the system classloader or a given\n     * custom classloader.\n     *\n     * @param classname the name of the class to load.\n     * @return the requested class.\n     * @exception Exception if the class could not be loaded.\n     */\n    private Class loadClass(String classname) throws Exception {\n        if (classpath == null) {\n            return Class.forName(classname);\n        } else {\n            loader = getProject().createClassLoader(classpath);\n            loader.setThreadContextLoader();\n            Class c = Class.forName(classname, true, loader);\n            return c;\n        }\n    }\n\n    /**\n     * Specifies the output name for the styled result from the\n     * <tt>in</tt> attribute; required if <tt>in</tt> is set\n     *\n     * @param outFile the output File instance.\n     */\n    public void setOut(File outFile) {\n        this.outFile = outFile;\n    }\n\n    /**\n     * specifies a single XML document to be styled. Should be used\n     * with the <tt>out</tt> attribute; ; required if <tt>out</tt> is set\n     *\n     * @param inFile the input file\n     */\n    public void setIn(File inFile) {\n        this.inFile = inFile;\n    }\n\n    /**\n     * Processes the given input XML file and stores the result\n     * in the given resultFile.\n     *\n     * @param baseDir the base directory for resolving files.\n     * @param xmlFile the input file\n     * @param destDir the destination directory\n     * @param stylesheet the stylesheet to use.\n     * @exception BuildException if the processing fails.\n     */\n    private void process(File baseDir, String xmlFile, File destDir,\n                         File stylesheet)\n        throws BuildException {\n\n        File   outFile = null;\n        File   inFile = null;\n\n        try {\n            long styleSheetLastModified = stylesheet.lastModified();\n            inFile = new File(baseDir, xmlFile);\n\n            if (inFile.isDirectory()) {\n                log(\"Skipping \" + inFile + \" it is a directory.\",\n                    Project.MSG_VERBOSE);\n                return;\n            }\n\n            FileNameMapper mapper = null;\n            if (mapperElement != null) {\n                mapper = mapperElement.getImplementation();\n            } else {\n                mapper = new StyleMapper();\n            }\n\n            String[] outFileName = mapper.mapFileName(xmlFile);\n            if (outFileName == null || outFileName.length == 0) {\n                log(\"Skipping \" + inFile + \" it cannot get mapped to output.\",\n                    Project.MSG_VERBOSE);\n                return;\n            } else if (outFileName == null || outFileName.length > 1) {\n                log(\"Skipping \" + inFile + \" its mapping is ambiguos.\",\n                    Project.MSG_VERBOSE);\n                return;\n            }\n\n            outFile = new File(destDir, outFileName[0]);\n\n            if (force\n                || inFile.lastModified() > outFile.lastModified()\n                || styleSheetLastModified > outFile.lastModified()) {\n                ensureDirectoryFor(outFile);\n                log(\"Processing \" + inFile + \" to \" + outFile);\n\n                configureLiaison(stylesheet);\n                liaison.transform(inFile, outFile);\n            }\n        } catch (Exception ex) {\n            // If failed to process document, must delete target document,\n            // or it will not attempt to process it the second time\n            log(\"Failed to process \" + inFile, Project.MSG_INFO);\n            if (outFile != null) {\n                outFile.delete();\n            }\n\n            if (this.failOnError) throw new BuildException(ex);\n        }\n\n    } //-- processXML\n\n    /**\n     * Process the input file to the output file with the given stylesheet.\n     *\n     * @param inFile the input file to process.\n     * @param outFile the destination file.\n     * @param stylesheet the stylesheet to use.\n     * @exception BuildException if the processing fails.\n     */\n    private void process(File inFile, File outFile, File stylesheet)\n         throws BuildException {\n        try {\n            long styleSheetLastModified = stylesheet.lastModified();\n            log(\"In file \" + inFile + \" time: \" + inFile.lastModified(),\n                Project.MSG_DEBUG);\n            log(\"Out file \" + outFile + \" time: \" + outFile.lastModified(),\n                Project.MSG_DEBUG);\n            log(\"Style file \" + xslFile + \" time: \" + styleSheetLastModified,\n                Project.MSG_DEBUG);\n            if (force || inFile.lastModified() >= outFile.lastModified()\n                || styleSheetLastModified >= outFile.lastModified()) {\n                ensureDirectoryFor(outFile);\n                log(\"Processing \" + inFile + \" to \" + outFile,\n                    Project.MSG_INFO);\n                configureLiaison(stylesheet);\n                liaison.transform(inFile, outFile);\n            } else {\n                log(\"Skipping input file \" + inFile\n                    + \" because it is older than output file \" + outFile\n                    + \" and so is the stylesheet \" + stylesheet, \nProject.MSG_DEBUG);\n            }\n        } catch (Exception ex) {\n            log(\"Failed to process \" + inFile, Project.MSG_INFO);\n            if (outFile != null) {\n                outFile.delete();\n            }\n            if (this.failOnError) throw new BuildException(ex);\n        }\n    }\n\n    /**\n     * Ensure the directory exists for a given file\n     *\n     * @param targetFile the file for which the directories are required.\n     * @exception BuildException if the directories cannot be created.\n     */\n    private void ensureDirectoryFor(File targetFile)\n         throws BuildException {\n        File directory = fileUtils.getParentFile(targetFile);\n        if (!directory.exists()) {\n            if (!directory.mkdirs()) {\n                if (this.failOnError)\n                    throw new BuildException(\"Unable to create directory: \"\n                                             + directory.getAbsolutePath());\n                else\n                    log(\"Unable to create directory: \" + \ndirectory.getAbsolutePath());\n            }\n        }\n    }\n\n    /**\n     * Get the factory instance configured for this processor\n     *\n     * @return the factory instance in use\n     */\n    public Factory getFactory() {\n        return factory;\n    }\n\n    /**\n     * Get the XML catalog containing entity definitions\n     *\n     * @return the XML catalog for the task.\n     */\n    public XMLCatalog getXMLCatalog() {\n        return xmlCatalog;\n    }\n\n    public Enumeration getOutputProperties() {\n        return outputProperties.elements();\n    }\n\n\n    /**\n     * Get the Liason implementation to use in processing.\n     *\n     * @return an instance of the XSLTLiason interface.\n     */\n    protected XSLTLiaison getLiaison() {\n        // if processor wasn't specified, see if TraX is available.  If not,\n        // default it to xslp or xalan, depending on which is in the classpath\n        if (liaison == null) {\n            if (processor != null) {\n                try {\n                    resolveProcessor(processor);\n                } catch (Exception e) {\n                    if (this.failOnError)\n                        throw new BuildException(e);\n                    else {\n                        log(e.getMessage());\n                        return null;\n                    }\n                }\n            } else {\n                try {\n                    resolveProcessor(\"trax\");\n                } catch (Throwable e1) {\n                    try {\n                        resolveProcessor(\"xalan\");\n                    } catch (Throwable e2) {\n                        try {\n                            resolveProcessor(\"xslp\");\n                        } catch (Throwable e3) {\n                            e3.printStackTrace();\n                            e2.printStackTrace();\n                            if (this.failOnError) throw new BuildException(e1);\n                            return null;\n                        }\n                    }\n                }\n            }\n        }\n        return liaison;\n    }\n\n    /**\n     * Create an instance of an XSL parameter for configuration by Ant.\n     *\n     * @return an instance of the Param class to be configured.\n     */\n    public Param createParam() {\n        Param p = new Param();\n        params.addElement(p);\n        return p;\n    }\n\n    /**\n     * The Param inner class used to store XSL parameters\n     */\n    public static class Param {\n        /** The parameter name */\n        private String name = null;\n\n        /** The parameter's value */\n        private String expression = null;\n\n        private String ifProperty;\n        private String unlessProperty;\n        private Project project;\n\n        /**\n         * Set the current project\n         *\n         * @param project the current project\n         */\n        public void setProject(Project project) {\n            this.project = project;\n        }\n\n        /**\n         * Set the parameter name.\n         *\n         * @param name the name of the parameter.\n         */\n        public void setName(String name) {\n            this.name = name;\n        }\n\n        /**\n         * The parameter value\n         * NOTE : was intended to be an XSL expression.\n         * @param expression the parameter's value.\n         */\n        public void setExpression(String expression) {\n            this.expression = expression;\n        }\n\n        /**\n         * Get the parameter name\n         *\n         * @return the parameter name\n         * @exception BuildException if the name is not set.\n         */\n        public String getName() throws BuildException {\n            if (name == null) {\n                throw new BuildException(\"Name attribute is missing.\");\n            }\n            return name;\n        }\n\n        /**\n         * Get the parameter's value\n         *\n         * @return the parameter value\n         * @exception BuildException if the value is not set.\n         */\n        public String getExpression() throws BuildException {\n            if (expression == null) {\n                throw new BuildException(\"Expression attribute is missing.\");\n            }\n            return expression;\n        }\n\n        /**\n         * Set whether this param should be used.  It will be\n         * used if the property has been set, otherwise it won't.\n         * @param ifProperty name of property\n         */\n        public void setIf(String ifProperty) {\n            this.ifProperty = ifProperty;\n        }\n\n        /**\n         * Set whether this param should NOT be used. It\n         * will not be used if the property has been set, otherwise it\n         * will be used.\n         * @param unlessProperty name of property\n         */\n        public void setUnless(String unlessProperty) {\n            this.unlessProperty = unlessProperty;\n        }\n        /**\n         * Ensures that the param passes the conditions placed\n         * on it with <code>if</code> and <code>unless</code> properties.\n         */\n        public boolean shouldUse() {\n            if (ifProperty != null && project.getProperty(ifProperty) == null) \n{\n                return false;\n            } else if (unlessProperty != null\n                    && project.getProperty(unlessProperty) != null) {\n                return false;\n            }\n\n            return true;\n        }\n    } // Param\n\n\n    /**\n     * Create an instance of an output property to be configured.\n     * @return the newly created output property.\n     * @since Ant 1.5\n     */\n    public OutputProperty createOutputProperty() {\n        OutputProperty p = new OutputProperty();\n        outputProperties.addElement(p);\n        return p;\n    }\n\n\n    /**\n     * Specify how the result tree should be output as specified\n     * in the <a href=\"http://www.w3.org/TR/xslt#output\">\n     * specification</a>.\n     * @since Ant 1.5\n     */\n    public static class OutputProperty {\n        /** output property name */\n        private String name;\n\n        /** output property value */\n        private String value;\n\n        /**\n         * @return the output property name.\n         */\n        public String getName() {\n            return name;\n        }\n\n        /**\n         * set the name for this property\n         * @param name A non-null String that specifies an\n         * output property name, which may be namespace qualified.\n         */\n        public void setName(String name) {\n            this.name = name;\n        }\n\n        /**\n         * @return the output property value.\n         */\n        public String getValue() {\n            return value;\n        }\n\n        /**\n         * set the value for this property\n         * @param value The non-null string value of the output property.\n         */\n        public void setValue(String value) {\n            this.value = value;\n        }\n    }\n\n    /**\n     * Initialize internal instance of XMLCatalog\n     */\n    public void init() throws BuildException {\n        super.init();\n        xmlCatalog.setProject(getProject());\n    }\n\n    /**\n     * Loads the stylesheet and set xsl:param parameters.\n     *\n     * @param stylesheet the file form which to load the stylesheet.\n     * @exception BuildException if the stylesheet cannot be loaded.\n     */\n    protected void configureLiaison(File stylesheet) throws BuildException {\n        if (stylesheetLoaded && reuseLoadedStylesheet) {\n            return;\n        }\n        stylesheetLoaded = true;\n\n        try {\n            log(\"Loading stylesheet \" + stylesheet, Project.MSG_INFO);\n            liaison.setStylesheet(stylesheet);\n            for (Enumeration e = params.elements(); e.hasMoreElements();) {\n                Param p = (Param) e.nextElement();\n                if (p.shouldUse()) {\n                    liaison.addParam(p.getName(), p.getExpression());\n                }\n            }\n            if (liaison instanceof XSLTLiaison2) {\n                ((XSLTLiaison2) liaison).configure(this);\n            }\n        } catch (Exception ex) {\n            log(\"Failed to transform using stylesheet \" + stylesheet,\n                 Project.MSG_INFO);\n            throw new BuildException(ex);\n        }\n    }\n\n    /**\n     * Create the factory element to configure a trax liaison.\n     * @return the newly created factory element.\n     * @throws BuildException if the element is created more than one time.\n     */\n    public Factory createFactory() throws BuildException {\n        if (factory != null) {\n            throw new BuildException(\"'factory' element must be unique\");\n        }\n        factory = new Factory();\n        return factory;\n    }\n\n    /**\n     * The factory element to configure a transformer factory\n     * @since Ant 1.6\n     */\n    public static class Factory {\n\n        /** the factory class name to use for TraXLiaison */\n        private String name;\n\n        /**\n         * the list of factory attributes to use for TraXLiaison\n         */\n        private Vector attributes = new Vector();\n\n        /**\n         * @return the name of the factory.\n         */\n        public String getName() {\n            return name;\n        }\n\n        /**\n         * Set the name of the factory\n         * @param name the name of the factory.\n         */\n        public void setName(String name) {\n            this.name = name;\n        }\n\n        /**\n         * Create an instance of a factory attribute.\n         * the newly created factory attribute\n         */\n        public void addAttribute(Attribute attr) {\n            attributes.addElement(attr);\n        }\n\n        /**\n         * return the attribute elements.\n         * @return the enumeration of attributes\n         */\n        public Enumeration getAttributes() {\n            return attributes.elements();\n        }\n\n        /**\n         * A JAXP factory attribute. This is mostly processor specific, for\n         * example for Xalan 2.3+, the following attributes could be set:\n         * <ul>\n         *  <li>http://xml.apache.org/xalan/features/optimize (true|false) \n</li>\n         *  <li>http://xml.apache.org/xalan/features/incremental (true|false) \n</li>\n         * </ul>\n         */\n        public static class Attribute implements DynamicConfigurator {\n\n            /** attribute name, mostly processor specific */\n            private String name;\n\n            /** attribute value, often a boolean string */\n            private Object value;\n\n            /**\n             * @return the attribute name.\n             */\n            public String getName() {\n                return name;\n            }\n\n            /**\n             * @return the output property value.\n             */\n            public Object getValue() {\n                return value;\n            }\n\n            public Object createDynamicElement(String name) throws \nBuildException {\n                return null;\n            }\n\n            public void setDynamicAttribute(String name, String value)\n                    throws BuildException {\n                // only 'name' and 'value' exist.\n                if (\"name\".equalsIgnoreCase(name)) {\n                    this.name = value;\n                } else if (\"value\".equalsIgnoreCase(name)) {\n                    // a value must be of a given type\n                    // say boolean|integer|string that are mostly used.\n                    if (\"true\".equalsIgnoreCase(value)\n                            || \"false\".equalsIgnoreCase(value)) {\n                        this.value = new Boolean(value);\n                    } else {\n                        try {\n                            this.value = new Integer(value);\n                        } catch (NumberFormatException e) {\n                            this.value = value;\n                        }\n                    }\n                } else {\n                    throw new BuildException(\"Unsupported attribute: \" + name);\n                }\n            }\n        } // -- class Attribute\n\n    } // -- class Factory\n\n    /**\n     * Mapper implementation of the \"traditional\" way &lt;xslt&gt;\n     * mapped filenames.\n     *\n     * <p>If the file has an extension, chop it off.  Append whatever\n     * the user has specified as extension or \".html\".</p>\n     *\n     * @since Ant 1.6.2\n     */\n    private class StyleMapper implements FileNameMapper {\n        public void setFrom(String from) {}\n        public void setTo(String to) {}\n        public String[] mapFileName(String xmlFile) {\n            int dotPos = xmlFile.lastIndexOf('.');\n            if (dotPos > 0) {\n                xmlFile = xmlFile.substring(0, dotPos);\n            }\n            return new String[] {xmlFile + targetExtension};\n        }\n    }\n\n}", "id": 78665, "time": "2005-08-18T21:57:25Z", "creator": "pochmans@gmail.com", "creation_time": "2005-08-18T21:57:25Z", "is_private": false}, {"count": 1, "tags": [], "text": "svn revision 720858 introduces two new attributes failOnError and the probably more common failOnTransformationError.", "is_private": false, "id": 122866, "creation_time": "2008-11-26T06:08:57Z", "time": "2008-11-26T06:08:57Z", "creator": "bodewig@apache.org", "bug_id": 36260, "attachment_id": null}]