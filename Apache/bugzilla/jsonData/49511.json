[{"count": 0, "tags": [], "creator": "kiralyattila.hu@gmail.com", "attachment_id": null, "text": "One of our customer is using IIS 7.5 (on top of Windows 2k8 r2 64 bit) with isapi_redirect 1.2.30. It seems IIS logging is messed up by the redirector: all requests on the same connection (keep-alive enabled) are logged with the same (probably the first) request uri (and query string). So if a jsp is requested, the images used on the jsp are logged with the jsp uri.\n\nMicrosoft said the following about the problem:\nIn native/iis/jk_isapi_plugin.c\n\n-------%<-------%<-------%<-------%<-------\n\nDWORD WINAPI HttpFilterProc(PHTTP_FILTER_CONTEXT pfc,\n\n                            DWORD dwNotificationType, LPVOID pvNotification)\n\n{\n\n\u2026\n\n    <rewrite original URI if needed>\n\n                \u2026\n\n     if (!pfc->pFilterContext) {                                                                                    <- save the rewritten URI/ Query String for logging purpose\n\n                    isapi_log_data_t *ld = (isapi_log_data_t *)pfc->AllocMem(pfc, sizeof(isapi_log_data_t), 0);\n\n                    memset(ld, 0, sizeof(isapi_log_data_t));\n\n                    StringCbCopy(ld->uri, INTERNET_MAX_URL_LENGTH, forwardURI);\n\n                    StringCbCopy(ld->query, INTERNET_MAX_URL_LENGTH, squery);\n\n                    pfc->pFilterContext = ld;\n\n                } else {                                                                                               <- update the rewritten URI / QS if context already exists\n\n                    isapi_log_data_t *ld = (isapi_log_data_t *)pfc->pFilterContext;\n\n                    memset(ld, 0, sizeof(isapi_log_data_t));\n\n                    StringCbCopy(ld->uri, INTERNET_MAX_URL_LENGTH, forwardURI);\n\n                    StringCbCopy(ld->query, INTERNET_MAX_URL_LENGTH, squery);\n\n        \u2026\n\n    else if (dwNotificationType == SF_NOTIFY_LOG) { <- when SF_NOTIFY_LOG  occurs, use URI/QS previously saved in pFilterContext to update URI/QS logged\n\n        if (pfc->pFilterContext) {\n\n            isapi_log_data_t *ld = (isapi_log_data_t *)pfc->pFilterContext;\n\n            HTTP_FILTER_LOG  *pl = (HTTP_FILTER_LOG *)pvNotification;\n\n            pl->pszTarget = ld->uri;\n\n            pl->pszParameters = ld->query;\n\n        }\n\n    }\n\n    return SF_STATUS_REQ_NEXT_NOTIFICATION;\n\n}\n\n \n\nSo, when ISAPI_REDIRECT redirects a URI, it saves/updates the target location (and query string) in a struct pointed by pFilterContext. This pointer is then subsequently used when the SF_NOTIFY_LOG  notification fires to write the redirected URL in the IIS log (instead of the original URL).\n\n \n\nNow, what happened with pFilterContext  when the next request comes in on the same connection ? It is re-initialized (set to NULL) by the caller (\u201cIIS\u201d) ? Well, unfortunately, the pFilterContext \u201cscope\u201d is the HTTP connection and not the HTTP request. This is more or less documented here :\n\n \n\n-          from http://blogs.msdn.com/b/david.wang/archive/2006/03/11/why-some-isapi-filter-events-trigger-multiple-times-per-request.aspx\n\n\u201cyou need to be aware that pfc->pFilterContext is PER-CONNECTION and NOT PER-REQUEST, which has special implications when servicing keep-alive or pipelined requests\u201d)\n\n \n\n-          MSDN doc http://msdn.microsoft.com/en-us/library/ms524517(v=VS.90).aspx\n\n \n\npFilterContext\n\n \n\nPoints to any context information that the filter wants to associate with this request.\n\nAny memory associated with this request can be safely freed during the SF_NOTIFY_END_OF_NET_SESSION\n\nnotification.\n\n \n\nSF_NOTIFY_END_OF_NET_SESSION (http://msdn.microsoft.com/en-us/library/ms524855(VS.90).aspx)\n\n \n\n When the connection between the client and the server is closed, the SF_NOTIFY_END_OF_NET_SESSION\n\nnotification occurs. If a Keep-Alive connection has been negotiated, it is possible for many HTTP\n\nrequests to occur before this notification.\n\n \n\nYou can now easily understand that the pFilterContext previously used keeps his value until the HTTP connection terminates. This is what is causing the \u201cwrong logging\u201d problem\n\nFortunately, this also helps to provide a workaround or a fix :\n\n \n\n1)      Workaround : disable HTTP Keep Alive (INETMGR -> HTTP Response Header icon in Feature View -> click on Set Common Headers at the Action task pane -> uncheck Keep Alive setting)\n\nThis allows to get pFilterContext cleared upon every request but, of course, this has performance implications\n\n \n\n2)      Fix : set pFilterContext  to NULL once we don\u2019t need it like this :\n\n \n\n   else if (dwNotificationType == SF_NOTIFY_LOG) {\n\n        if (pfc->pFilterContext) {\n\n            isapi_log_data_t *ld = (isapi_log_data_t *)pfc->pFilterContext;\n\n            HTTP_FILTER_LOG  *pl = (HTTP_FILTER_LOG *)pvNotification;\n\n            pl->pszTarget = ld->uri;\n\n            pl->pszParameters = ld->query;\n\n                // fix : make sure context is set to null once we don\u2019t need it :\n\n                pfc->pFilterContext = NULL;\n\n-------%<-------%<-------%<-------%<-------\n\nSome additional info:\nThis is the only place where AllocMem is used to memory allocation in isapi_redirect. According to the doc http://msdn.microsoft.com/en-us/library/ms525115%28v=VS.90%29.aspx \"You can call AllocMem as many times as your code requires, but you cannot flush the AllocMem buffers. IIS maintains a list of allocated memory blocks created in the filter context and frees them after a SF_NOTIFY_END_OF_NET_SESSION notification. This means that the lifespan of AllocMem memory blocks is associated with the connection to the client, not with a particular request. If you are allocating a lot of memory with a Keep-Alive connection, then none of those blocks will be freed until the client is no longer connected.\n\nAs an alternative, if blocks of memory are only needed \"per request\", then you can use whatever memory allocation function that you like and clean up after the SF_NOTIFY_END_OF_REQUEST notification. However, it is easy to lose track of memory blocks that you have allocated if you don't fully understand when notifications fire.\"\n\nSo maybe the memory should be allocated with malloc at the start of the request and freed with free at the end of the request instead of MS mentioned fix.", "id": 137947, "time": "2010-06-28T10:15:13Z", "bug_id": 49511, "creation_time": "2010-06-28T10:15:13Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 49511, "text": "The problem could be reproduced with IIS 6.0 too (32 bit).\n\nThe workaround, disabling keep-alive, solves the logging problem on both versions.", "id": 138029, "time": "2010-06-30T05:51:56Z", "creator": "kiralyattila.hu@gmail.com", "creation_time": "2010-06-30T05:51:56Z", "is_private": false, "attachment_id": null}, {"count": 2, "attachment_id": null, "creator": "timw@apache.org", "is_private": false, "id": 139843, "time": "2010-09-12T19:24:44Z", "bug_id": 49511, "creation_time": "2010-09-12T19:24:44Z", "tags": [], "text": "What is happening here is:\n - pFilterContext is allocated per connection/session\n - the uri and query are being correctly set on each request (even if pFilterContext has been allocated)\n - the uri and query are being set correctly in the HTTP_FILTER_LOG structure\n - the uri and query are not overwritten until the next request has started\n\nThe documentation of HTTP FILTER_LOG (http://msdn.microsoft.com/en-us/library/ms525464%28v=VS.90%29.aspx) states that the memory used for the uri and query variables \"must remain valid until the next filter notification\", implying that logging occurs before the next HttpFilterProc notification.\n\nhttps://forums.iis.net/p/1156804/1900220.aspx and other forum questions with response from Microsoft reps seems to support this theory.\n\nIt's implicit (and occasionally explicit) in all the ISAPI code and advice that I've seen (even by Microsoft ISAPI reps) that IIS serialises requests through the ISAPI filter (even for Keep-Alive and pipelined requests).\ni.e. you can expect a sequence of ISAPI event notifications through HttpFilterProc to conclude before a new sequence starts.\nI can find no structure, documentation, or advice on how to implement per-request data structures (aside from implementing something custom under pFilterContext), which lends weight to this theory.\n\nHowever if all this were true, then there would be no issue with the logging in the redirector now - the memory in pFilterContext is allocated once per connection, and is consistent from the SF_NOTIFY_LOG event until the subsequent request is started.\n\nThe only explanation I can see for this kind of behaviour then is that the actual log writing is being done outside the ISAPI event sequence and after the next request has entered HttpFilterProc and changed the uri and query values.\ni.e. we get a something like\n - SF_NOTIFY_PREPROC_HEADERS request 1\n - <normal request processing> request 1\n - SF_NOTIFY_LOG request 1\n - SF_NOTIFY_PREPROC_HEADERS request 2\n - <request 1 logged by IIS>\n\nIf this is the case, then setting pfc->pFilterContext to NULL in the SF_NOTIFY_LOG seems to be the only fix.\n\nThis will introduce a per-request memory growth of sizeof(isapi_log_data_t) (~ 4k) that will only be freed on termination of the connection though, which may be unacceptable. (We could implement a freeing of the previous log data in SF_NOTIFY_LOG, but we're still not sure that the actual logging would take place before that event. We could also trim the actual memory usage by using AllocMem individually on the uri and query parts, rather than allocating a struct with pre-allocated buffers.)\n\nPosts like this one from David Wang (Microsoft) indicate that this is standard practice however (I've seen numerous examples and mentions of this technique from MS reps). The code explicitly NULLs pFilterContext on request start, without checking whether it was allocated previously for that session.\nhttp://groups.google.ie/group/microsoft.public.platformsdk.internet.server.isapi-dev/msg/8d3a72b740735860\n\n\nWhat also doesn't make sense is the assertion in the original report that:\n\n\"all requests on the same connection (keep-alive enabled) are logged with the same (probably the first) request uri (and query string)\"\n\nWhat I would expect to see instead is that some (or in the extreme case) all of the requests on the same connection are logged with the request uri of a subsequent request (i.e. not the first, but perhaps the last)."}, {"attachment_id": null, "tags": [], "bug_id": 49511, "is_private": false, "count": 3, "id": 139845, "time": "2010-09-13T02:17:40Z", "creator": "kiralyattila.hu@gmail.com", "creation_time": "2010-09-13T02:17:40Z", "text": "I can add the following:\nto fix the logging problem I recompiled the isapi redirector with the MS mentioned code modification (adding pfc->pFilterContext = NULL;). The modified dll is used in production for 2 months now. The logging problem is gone and the system is stable. So the fix is good in practice.\n\n\n\"What I would expect to see instead is that some (or in the extreme case) all of\nthe requests on the same connection are logged with the request uri of a\nsubsequent request (i.e. not the first, but perhaps the last).\"\nI see the logic behind this but what we experienced was the opposit of this. Even when we made only a single request to a jsp that contained a js file and the js pulled down a gif (so 3 requests overall) we saw 3 jsp entries in the log. That was the problem because the log is analyzed and the gif plays a special role in it. However the gif was never found. I think the reason for this is that the redirect filter was only set to serve the jsp files (dynamic content) but the js and gif (the static content) were served by the IIS itself. So the filter did not update the uri and query info when the js and gif requests were processed."}, {"count": 4, "tags": [], "bug_id": 49511, "is_private": false, "text": "> I think the reason for\nthis is that the redirect filter was only set to serve the jsp files (dynamic\ncontent) but the js and gif (the static content) were served by the IIS itself.\n> So the filter did not update the uri and query info when the js and gif\nrequests were processed.\n\nThis might actually explain what you're seeing - since the pFilterContext is allocated per session/connection we store the uri/query on the .jsp request, and if the subsequent requests for the .js and .gif are served by IIS, we won't overwrite that data.\n\nIn the SF_NOTIFY_LOG notification, we just check whether pFilterContext is allocated (which only means that any previous request on that connection was mapped) and blindly overwrite the log information even if we didn't map the current request.\n\nI'll commit a fix to guard against this behaviour - if you could test it that'd be appreciated.", "id": 140006, "time": "2010-09-21T06:37:04Z", "creator": "timw@apache.org", "creation_time": "2010-09-21T06:37:04Z", "attachment_id": null}, {"count": 5, "attachment_id": null, "creator": "timw@apache.org", "text": "I've committed a fix to prevent logging unless we actually mapped the current request into the ISAPI Redirector into trunk.\n\nCan you please build and test this version (or alternatively apply the patch I've attached) and see if this resolves the issue.", "id": 140009, "time": "2010-09-21T07:08:25Z", "bug_id": 49511, "creation_time": "2010-09-21T07:08:25Z", "tags": [], "is_private": false}, {"count": 6, "tags": [], "bug_id": 49511, "text": "Created attachment 26060\nPatch to prevent override of logging for unmapped requests", "id": 140010, "time": "2010-09-21T07:09:19Z", "creator": "timw@apache.org", "creation_time": "2010-09-21T07:09:19Z", "is_private": false, "attachment_id": 26060}, {"count": 7, "tags": [], "bug_id": 49511, "attachment_id": null, "text": "This was fixed in 1.2.31", "id": 142140, "time": "2010-11-29T13:46:59Z", "creator": "timw@apache.org", "creation_time": "2010-11-29T13:46:59Z", "is_private": false}]