[{"attachment_id": null, "tags": [], "bug_id": 38365, "is_private": false, "count": 0, "id": 84937, "time": "2006-01-24T09:53:16Z", "creator": "milan@setcce.org", "creation_time": "2006-01-24T09:53:16Z", "text": "I have found very interesting bug inside WinCAPICryptoSymmetricKey::encrypt().\nI've been encrypting an XML file and used encrypt content (not whole element)\noption ( cipher->encryptElementContent() func ). The bug occurs whenever there\nare less then 12 (in my case only 4) characters inside XML element to encrypt.\nIn the case of 4 characters, values are:\n\n//unsigned int rounding = (m_bytesInLastBlock + inLength) % m_blockSize;\nunsigned int rounding = (0 + 4) % 8; // rounding == 8 now\n\n//rounding += m_blockSize;\nrounding += 8; // rounding == 12 now\n\n//memcpy(m_lastBlock, &inBuf[inLength - rounding], rounding);\nmemcpy(m_lastBlock, &inBuf[4 - 12], 12); // 4 - 12 ??? buffer \"underflow\"\n\n//memcpy(bufPtr, inBuf, inLength - rounding);\nmemcpy(bufPtr, inBuf, 4 - 12); // again 4 - 12 :(\n\nProbably, the same bug is inside NSS and OpenSSL providers."}, {"count": 1, "tags": [], "bug_id": 38365, "is_private": false, "text": "Turns out this only applied to the Windows code.  Both the NSS and OpenSSL code\nlet the underlying library handle this edge case naturally.  I have added some\ncode to see if the input is to small, and if so, store it in the buffer that is\nused for tail of input.", "id": 88130, "time": "2006-04-15T22:42:18Z", "creator": "blautenb@apache.org", "creation_time": "2006-04-15T22:42:18Z", "attachment_id": null}]