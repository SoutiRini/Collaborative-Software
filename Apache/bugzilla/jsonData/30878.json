[{"count": 0, "tags": [], "bug_id": 30878, "text": "Patch that fixes various issues with xupdate commands. \n\nHas a temp hack to get rid of \"temporaryXUpdateTree\" nodes. Going to look into a\nbetter solution. \n\nFixed xupdate commands being ran more then once on a document when a set of\ncommands was applied on a collection. \nPatch below....  Side note willing to write up some test cases to prove this\nworks and to supply xindice with some basic xupdate testing..\n\n--- xml-xindice/java/src/org/apache/xindice/core/xupdate/XUpdateImpl.java\n2004-02-07 19:50:54.000000000 -0700\n+++\n/home/byrne/jbproject/xindice-cvs-src/xml-xindice/java/src/org/apache/xindice/core/xupdate/XUpdateImpl.java\n2004-08-26 13:50:53.000000000 -0600\n@@ -27,6 +27,7 @@\n \n import org.w3c.dom.Document;\n import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n import org.xml.sax.SAXException;\n import org.xmldb.xupdate.lexus.XUpdateQueryImpl;\n import org.xmldb.xupdate.lexus.commands.CommandConstants;\n@@ -35,6 +36,7 @@\n \n import java.util.Enumeration;\n import java.util.Hashtable;\n+import org.apache.xindice.core.data.Key;\n \n /**\n  * Provides Collection and document based XUpdate capabilities.\n@@ -44,148 +46,194 @@\n  *\n  * @version CVS $Revision: 1.12 $, $Date: 2004/02/08 02:50:54 $\n  */\n-public class XUpdateImpl extends XUpdateQueryImpl {\n+public class XUpdateImpl\n+    extends XUpdateQueryImpl {\n \n-    protected int nodesModified = 0;\n-    protected NamespaceMap nsMap;\n+  protected int nodesModified = 0;\n+  protected NamespaceMap nsMap;\n \n-    /**\n-     * If set to true, then namespaces set explicitly via an API call will take\nprecendence.\n-     * If set to false, then namespaces set implicitly within query string will\ntake precedence.\n-     */\n-    private static final boolean API_NS_PRECEDENCE = true;\n-\n-    /**\n-     * Set the namespace map to be used when resolving queries\n-     */\n-    public void setNamespaceMap(NamespaceMap nsMap) {\n-        if (nsMap == null) {\n-            return;\n-        }\n-\n-        if (this.nsMap == null) {\n-            this.nsMap = nsMap;\n-        } else {\n-            this.nsMap.includeNamespaces(nsMap, API_NS_PRECEDENCE);\n-        }\n+  /**\n+   * If set to true, then namespaces set explicitly via an API call will take\nprecendence.\n+   * If set to false, then namespaces set implicitly within query string will\ntake precedence.\n+   */\n+  private static final boolean API_NS_PRECEDENCE = true;\n+\n+  /**\n+   * Set the namespace map to be used when resolving queries\n+   */\n+  public void setNamespaceMap(NamespaceMap nsMap) {\n+    if (nsMap == null) {\n+      return;\n     }\n \n-\n-    /**\n-     * Sets the query string to be used when executing update\n-     */\n-    public void setQString(String query) throws SAXException {\n-        super.setQString(query);\n-        if (nsMap == null) {\n-            nsMap = new NamespaceMap();\n-        }\n-        nsMap.includeNamespaces(super.namespaces, !API_NS_PRECEDENCE);\n+    if (this.nsMap == null) {\n+      this.nsMap = nsMap;\n     }\n+    else {\n+      this.nsMap.includeNamespaces(nsMap, API_NS_PRECEDENCE);\n+    }\n+  }\n \n+  /**\n+   * Sets the query string to be used when executing update\n+   */\n+  public void setQString(String query) throws SAXException {\n+    super.setQString(query);\n+    if (nsMap == null) {\n+      nsMap = new NamespaceMap();\n+    }\n+    nsMap.includeNamespaces(super.namespaces, !API_NS_PRECEDENCE);\n+  }\n \n-    /**\n-     * Execute the XUpdate commands against a document.\n-     */\n-    public void execute(Node contextNode) throws Exception {\n-        CommandObject currentCommand = new DefaultCommand(contextNode);\n-        Enumeration commands = super.query[0].elements();\n-        Enumeration attributes = super.query[1].elements();\n-        Enumeration characters = super.query[2].elements();\n-        Node origNode = contextNode;\n-        CommandObject.getXPath().setNamespace(nsMap.getContextNode());\n-\n-        while (commands.hasMoreElements()) {\n-            int id = ((Integer) commands.nextElement()).intValue();\n-\n-            if (id == CommandConstants.ATTRIBUTES) {\n-                currentCommand.submitAttributes((Hashtable)\nattributes.nextElement());\n-            } else if (id == CommandConstants.CHARACTERS) {\n-                currentCommand.submitCharacters((String) characters.nextElement());\n-            } else if (id > 0) {\n-                if (!currentCommand.submitInstruction(id)) {\n-                    super.commandConstants.setContextNode(contextNode);\n-                    currentCommand = super.commandConstants.commandForID(id);\n-                    if (currentCommand == null) {\n-                        throw new Exception(\"Operation can not have any\nXUpdate-instruction!\");\n-                    }\n-                    currentCommand.reset();\n-                }\n-            } else {\n-                if (!currentCommand.executeInstruction()) {\n-                    try {\n-                        contextNode = currentCommand.execute();\n-                    } catch (Exception e) {\n-                        // While not ideal, CommandObject.execute throws\n-                        // Exception(\"no nodes selected !\") if nothing is\n-                        // selected for modification we trap that case\n-                        // and ignore allowing continued processing\n-                        // of remaining xupdate instructions that may be present\n-                        if (!\"no nodes selected !\".equals(e.getMessage())) {\n-                            throw e;\n-                        }\n-                    }\n-                    // Default do-nothing command will soak up anything\n-                    // (characters, attributes, etc.) encountered until we\n-                    // come across the next xupdate instruction\n-                    // (e.g. remove, append, insert, etc.)\n-                    currentCommand = new DefaultCommand(contextNode);\n-                }\n+  /**\n+   * Execute the XUpdate commands against a document.\n+   */\n+  public void execute(Node contextNode) throws Exception {\n+    CommandObject currentCommand = new DefaultCommand(contextNode);\n+    Enumeration commands = super.query[0].elements();\n+    Enumeration attributes = super.query[1].elements();\n+    Enumeration characters = super.query[2].elements();\n+    Node origNode = contextNode;\n+    CommandObject.getXPath().setNamespace(nsMap.getContextNode());\n+    boolean contextNodeNeedsCleaning = false;\n+\n+    while (commands.hasMoreElements()) {\n+      int id = ( (Integer) commands.nextElement()).intValue();\n+\n+      if (id == CommandConstants.ATTRIBUTES) {\n+        currentCommand.submitAttributes( (Hashtable) attributes.nextElement());\n+      }\n+      else if (id == CommandConstants.CHARACTERS) {\n+        currentCommand.submitCharacters( (String) characters.nextElement());\n+      }\n+      else if (id > 0) {\n+        if (!currentCommand.submitInstruction(id)) {\n+          super.commandConstants.setContextNode(contextNode);\n+          currentCommand = super.commandConstants.commandForID(id);\n+          if (currentCommand == null) {\n+            throw new Exception(\n+                \"Operation can not have any XUpdate-instruction!\");\n+          }\n+          currentCommand.reset();\n+        }\n+      }\n+      else {\n+        if (!currentCommand.executeInstruction()) {\n+          try {\n+            contextNode = currentCommand.execute();\n+          }\n+          catch (Exception e) {\n+            // While not ideal, CommandObject.execute throws\n+            // Exception(\"no nodes selected !\") if nothing is\n+            // selected for modification we trap that case\n+            // and ignore allowing continued processing\n+            // of remaining xupdate instructions that may be present\n+            if (!\"no nodes selected !\".equals(e.getMessage())) {\n+              throw e;\n             }\n-        }\n-\n-        if (origNode instanceof CompressedNode) {\n-            CompressedNode cn = (CompressedNode) origNode;\n-            if (cn.isDirty()) {\n-                nodesModified++;\n+            // from my tests I figure out it adds one temporary node per\n+            // command, but when the exception gets thrown it never cleans it\nself up\n+            // this one node is always at the end\n+            String lastNodeName = origNode.getLastChild().getNodeName();\n+            if (lastNodeName.equals(\"temporaryXUpdateTree\")) {\n+              // assuming that one command one temporary node.\n+              origNode.removeChild(origNode.getLastChild());\n+            }\n+            else { // search for it?\n+              contextNodeNeedsCleaning = true;\n             }\n+          }\n+          // Default do-nothing command will soak up anything\n+          // (characters, attributes, etc.) encountered until we\n+          // come across the next xupdate instruction\n+          // (e.g. remove, append, insert, etc.)\n+          currentCommand = new DefaultCommand(contextNode);\n         }\n+      }\n     }\n+    if (contextNodeNeedsCleaning) {\n+      // search entire tree and to verify no extra nodes where left around.\n+      cleanUpNode(origNode);\n+    }\n+    if (origNode instanceof CompressedNode) {\n+      CompressedNode cn = (CompressedNode) origNode;\n+      if (cn.isDirty()) {\n+        nodesModified++;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Execute the set of XUpdate commands against a collection.\n+   *\n+   * @param col The collection against which the command will be executed\n+   * @exception Exception Description of Exception\n+   */\n+  public void execute(Collection col) throws Exception {\n+\n+    int attribIndex = 0;\n+    int temp = 0;\n+    Hashtable docsUpdated = new Hashtable();\n+\n+    for (int i = 0; i < super.query[0].size(); i++) {\n+      int cmdID = ( (Integer)super.query[0].elementAt(i)).intValue();\n+\n+      if (cmdID == CommandConstants.ATTRIBUTES) {\n+        Hashtable attribs = (Hashtable)super.query[1].elementAt(attribIndex);\n+        attribIndex++;\n+        String selector = (String) attribs.get(\"select\");\n+\n+        // If we found an XPath selector we need to execute the commands.\n+        // save to skip variable because at this point we have already run the\ncommands on the\n+        // files.\n+        if (selector != null && !selector.startsWith(\"$\")) {\n+          NodeSet ns = col.queryCollection(\"XPath\", selector, nsMap);\n+\n+          while (ns != null && ns.hasMoreNodes()) {\n+            DBNode node = (DBNode) ns.getNextNode();\n+            Document doc = node.getOwnerDocument();\n+            NodeSource source = node.getSource();\n+            Node contextNode = doc.getDocumentElement();\n \n-    /**\n-     * Execute the set of XUpdate commands against a collection.\n-     *\n-     * @param col The collection against which the command will be executed\n-     * @exception Exception Description of Exception\n-     */\n-    public void execute(Collection col) throws Exception {\n-\n-        int attribIndex = 0;\n-        for (int i = 0; i < super.query[0].size(); i++) {\n-            int cmdID = ((Integer) super.query[0].elementAt(i)).intValue();\n-\n-            if (cmdID == CommandConstants.ATTRIBUTES) {\n-                Hashtable attribs = (Hashtable)\nsuper.query[1].elementAt(attribIndex);\n-                attribIndex++;\n-                String selector = (String) attribs.get(\"select\");\n-\n-                // If we found an XPath selector we need to execute the commands.\n-                if (selector != null) {\n-                    NodeSet ns = col.queryCollection(\"XPath\", selector, nsMap);\n-                    Document lastDoc = null;\n-                    while (ns != null && ns.hasMoreNodes()) {\n-                        DBNode node = (DBNode) ns.getNextNode();\n-                        Document doc = node.getOwnerDocument();\n-\n-                        if (doc == lastDoc) {\n-                            continue; // We only have to process it once\n-                        } else {\n-                            lastDoc = doc;\n-                        }\n-\n-                        NodeSource source = node.getSource();\n-\n-                        Node contextNode = doc.getDocumentElement();\n-                        execute(contextNode);\n-\n-                        col.setDocument(source.getKey(), doc);\n-                    }\n-                }\n+            if (docsUpdated.containsKey(source.getKey())) {\n+              continue; // We only have to process it once\n             }\n+            else {\n+              docsUpdated.put(source.getKey(), doc);\n+            }\n+            execute(contextNode);\n+          }\n         }\n+      }\n+    }\n+    Enumeration keys = docsUpdated.keys();\n+    while (keys.hasMoreElements()) {\n+      Key docID = (Key) keys.nextElement();\n+      col.setDocument(docID, (Document) docsUpdated.get(docID));\n     }\n+  }\n+\n+  public int getModifiedCount() {\n+    return nodesModified;\n+  }\n+/**\n+ * Search the document tree for nodes left around from the xupdate commands.\n+ *\n+ */\n \n-    public int getModifiedCount() {\n-        return nodesModified;\n+  private void cleanUpNode(Node n) {\n+    NodeList list = n.getChildNodes();\n+    int listLength = list.getLength();\n+\n+    for (int i = listLength - 1; i >= 0; i--) {\n+      Node currentNode = list.item(i);\n+      if (currentNode.getNodeName().equals(\"temporaryXUpdateTree\")) {\n+        n.removeChild(currentNode);\n+      }\n+      else {\n+        cleanUpNode(currentNode);\n+      }\n     }\n-}\n \n+  }\n+}\n\\ No newline at end of file", "id": 62558, "attachment_id": null, "creator": "byrne@cns.montana.edu", "creation_time": "2004-08-26T22:20:29Z", "time": "2004-08-26T22:20:29Z", "is_private": false}, {"count": 1, "attachment_id": 12540, "bug_id": 30878, "text": "Created attachment 12540\nPossible patch", "id": 62559, "time": "2004-08-26T22:22:04Z", "creator": "byrne@cns.montana.edu", "creation_time": "2004-08-26T22:22:04Z", "tags": [], "is_private": false}, {"count": 2, "tags": [], "text": "Todd,\n\nI'm having hard time to understand what you patch here. Please keep original\nformatting of the file when submitting patches.\n\nHaving said that, I see that you try to clean up something when xupdate fails.\nWhy don't fix it in xupdate implementation instead?\n\nVadim\n", "is_private": false, "id": 62660, "creator": "vgritsenko@apache.org", "time": "2004-08-29T00:50:36Z", "bug_id": 30878, "creation_time": "2004-08-29T00:50:36Z", "attachment_id": null}, {"count": 3, "tags": [], "text": "Created attachment 12568\nNew cleaned up patch.", "is_private": false, "id": 62785, "creator": "byrne@cns.montana.edu", "time": "2004-08-30T16:25:33Z", "bug_id": 30878, "creation_time": "2004-08-30T16:25:33Z", "attachment_id": 12568}, {"count": 4, "tags": [], "bug_id": 30878, "attachment_id": null, "is_private": false, "id": 62786, "time": "2004-08-30T16:31:01Z", "creator": "byrne@cns.montana.edu", "creation_time": "2004-08-30T16:31:01Z", "text": "My new patch removes the document tree clean up as I have found the problem to\nlie  in the XUpdate code. I will work on trying to get the xupdate guys to fix\nor accept some patchs to fix the problem. \n\nThe orginal idea of the execute(Collection col) code was to do a pre xpath query\nto prune down the possible documents to run the update commands. The problem\noccurs when their is more then one update command. This causes the xupdate\ncommands to be run multiple times on the same file. The solution to this problem\nit to check to see what documents we have run the commands on and only run the\nxupdate commands once per document. \n\n"}, {"count": 5, "tags": [], "bug_id": 30878, "text": "Created attachment 12569\nContains to xml data files and a xupdate file", "id": 62788, "attachment_id": 12569, "creator": "byrne@cns.montana.edu", "creation_time": "2004-08-30T16:41:17Z", "time": "2004-08-30T16:41:17Z", "is_private": false}, {"count": 6, "attachment_id": null, "bug_id": 30878, "is_private": false, "id": 62789, "time": "2004-08-30T16:46:15Z", "creator": "byrne@cns.montana.edu", "creation_time": "2004-08-30T16:46:15Z", "tags": [], "text": "Unpack bugfiles.tgz in a dir then run the following commands:\n\n $XINDICE_HOME/bin/xindice dc  -c xmldb:xindice://localhost:8080/db/ -n test\n $XINDICE_HOME/bin/xindice ac  -c xmldb:xindice://localhost:8080/db/ -n test\n $XINDICE_HOME/bin/xindice ad  -c xmldb:xindice://localhost:8080/db/test -n\ndoc1.xml -f doc1.xml\n $XINDICE_HOME/bin/xindice ad  -c xmldb:xindice://localhost:8080/db/test -n\ndoc2.xml -f doc2.xml\n $XINDICE_HOME/bin/xindice xupdate  -c xmldb:xindice://localhost:8080/db/test -f\nupdate.xml\n\n\nFirst thing that pops up is the 3 documents updated.\n\nThen if you take a look at doc2.xml you see:\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ROOT>\n  <HEAD>\n    <test2/>\n    <test2/>\n  </HEAD>\n  <HEAD1>\n    <test1/>\n    <test1/>\n  </HEAD1>\n</ROOT>\n\nWhere both append commands got run twice."}, {"count": 7, "tags": [], "creator": "vgritsenko@apache.org", "is_private": false, "text": "applied patch:\nhttp://marc.theaimsgroup.com/?l=xindice-dev&m=111695214418879", "id": 75399, "time": "2005-05-26T03:18:23Z", "bug_id": 30878, "creation_time": "2005-05-26T03:18:23Z", "attachment_id": null}]