[{"count": 0, "tags": [], "bug_id": 56645, "attachment_id": null, "is_private": false, "id": 175894, "time": "2014-06-19T10:44:27Z", "creator": "takashi.asfbugzilla@tks.st", "creation_time": "2014-06-19T10:44:27Z", "text": "Even after fix bug 56642, mod_proxy_wstunnel with ProxyWebsocketAsync On and ProxyWebsocketIdleTimeout doesn't work well.\n\nI sent and receive small data many times, and sometimes went infinite loop.\n\nI got core and backtrace, and I saw one loop was inside of apr_skiplist_insert (event.c line 1464), and another is on while loop (event.c line 1767).\n\nI looked at event.c and found all timer_skiplist seemed to be well protected with g_timer_skiplist_mtx, so I don't have any idea why the infinity loop occurs."}, {"count": 1, "tags": [], "text": "I notice there is no checking of the return code for lock/unlock of those mutexes. They could be failing", "attachment_id": null, "id": 175897, "creator": "covener@gmail.com", "time": "2014-06-19T11:15:40Z", "bug_id": 56645, "creation_time": "2014-06-19T11:15:40Z", "is_private": false}, {"count": 2, "tags": [], "bug_id": 56645, "attachment_id": null, "is_private": false, "id": 175898, "time": "2014-06-19T11:20:20Z", "creator": "takashi.asfbugzilla@tks.st", "creation_time": "2014-06-19T11:20:20Z", "text": "(In reply to Eric Covener from comment #1)\n> I notice there is no checking of the return code for lock/unlock of those\n> mutexes. They could be failing\n\nOK, I try to put trace logs to log whether lock/unlock success or not."}, {"count": 3, "tags": [], "text": "Maybe the following path can help?\n\nIndex: server/mpm/event/event.c\n===================================================================\n--- server/mpm/event/event.c\t(revision 1603193)\n+++ server/mpm/event/event.c\t(working copy)\n@@ -1975,7 +1975,9 @@ static void * APR_THREAD_FUNC listener_thread(apr_\n                 int i = 0;\n                 socket_callback_baton_t *baton = (socket_callback_baton_t *) pt->baton;\n                 if (baton->cancel_event) {\n+                    apr_thread_mutex_lock(g_timer_skiplist_mtx);\n                     baton->cancel_event->canceled = 1;\n+                    apr_thread_mutex_unlock(g_timer_skiplist_mtx);\n                 }\n \n                 /* We only signal once per N sockets with this baton */\n--\n\nThere seem to be a race between the cancellation check and set.", "attachment_id": null, "bug_id": 56645, "id": 175900, "time": "2014-06-19T12:17:12Z", "creator": "ylavic.dev@gmail.com", "creation_time": "2014-06-19T12:17:12Z", "is_private": false}, {"count": 4, "tags": [], "bug_id": 56645, "attachment_id": null, "id": 175901, "time": "2014-06-19T12:20:39Z", "creator": "ylavic.dev@gmail.com", "creation_time": "2014-06-19T12:20:39Z", "is_private": false, "text": "(In reply to Yann Ylavic from comment #3)\n> There seem to be a race between the cancellation check and set.\n\nHmm, these are in the same thread, sorry for the noise."}, {"count": 5, "tags": [], "bug_id": 56645, "is_private": false, "text": "(In reply to Takashi Sato from comment #2)\n> (In reply to Eric Covener from comment #1)\n> > I notice there is no checking of the return code for lock/unlock of those\n> > mutexes. They could be failing\n> \n> OK, I try to put trace logs to log whether lock/unlock success or not.\n\nI tried. lock/unlock succeed...\n\nThen, I tried to migrate apr_skiplist to apr_array, then works fine (of cource performance is bad and may have memory leaks)!\nIt seems apr_skiplist has some bug.", "id": 175904, "time": "2014-06-19T12:51:10Z", "creator": "takashi.asfbugzilla@tks.st", "creation_time": "2014-06-19T12:51:10Z", "attachment_id": null}, {"attachment_id": null, "tags": [], "bug_id": 56645, "is_private": false, "count": 6, "id": 175905, "time": "2014-06-19T12:53:44Z", "creator": "covener@gmail.com", "creation_time": "2014-06-19T12:53:44Z", "text": "(In reply to Takashi Sato from comment #5)\n> (In reply to Takashi Sato from comment #2)\n> > (In reply to Eric Covener from comment #1)\n> > > I notice there is no checking of the return code for lock/unlock of those\n> > > mutexes. They could be failing\n> > \n> > OK, I try to put trace logs to log whether lock/unlock success or not.\n> \n> I tried. lock/unlock succeed...\n> \n> Then, I tried to migrate apr_skiplist to apr_array, then works fine (of\n> cource performance is bad and may have memory leaks)!\n> It seems apr_skiplist has some bug.\n\nYou might try Yanns patch. I don't know anything about the skiplist impl, but I don't know what might get moved while other threads add/remove unrelated entries.  In that case, his lock would unfortunately be required."}, {"count": 7, "tags": [], "bug_id": 56645, "attachment_id": 31733, "is_private": false, "id": 175906, "time": "2014-06-19T12:54:12Z", "creator": "takashi.asfbugzilla@tks.st", "creation_time": "2014-06-19T12:54:12Z", "text": "Created attachment 31733\npatch for debug (event MPM using apr_array for timer list)"}, {"count": 8, "tags": [], "bug_id": 56645, "attachment_id": null, "id": 175952, "time": "2014-06-21T06:51:47Z", "creator": "takashi.asfbugzilla@tks.st", "creation_time": "2014-06-21T06:51:47Z", "is_private": false, "text": "I observed apr_skiplist corruption, so I have annalyzed apr_skiplist, and found the bug 56654.\nWith 56654 fixed APR, I don't see any infinite loop.\n\nI don't think Yann's patch.\nbaton->cancel_event->canceled does not affect any for timer_skiplist."}]