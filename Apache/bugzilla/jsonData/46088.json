[{"count": 0, "tags": [], "text": "Path in ant are efficient only for very small/short paths. When working with large paths and their aggregation, path manipulation, including list() method can take by far the most (>80% in my case) of the *entire* build time (by creating my own 'fastpath' type that extends path I was able to reduce the build time from over 50 minutes to less than 10)! \n\nThe culprit: even though paths are specified immutable once created, they are not treated that way. Every time list() and related methods are invoked, the entire hierarchy of paths is walked through as if it never has been before. It explicitly prevents any form of caching, as far as I can see.\n\nOne of the problems is that the path \"materialization\" (e.g. for list() method) is deferred, and it can contain mutable pieces in it, such as the filesets (e.g. new files may appear after declaration and before materialization and also between two materializations). However, if one is willing to sacrifice that ability (not a problem in many cases) and accept that the first materialization freezes the state, then a lot of build time can be saved. Otherwise, a smarter caching and notification/update mechanism may need to be used.\n\nGranted, this issue is more pronounced with larger projects (tens of thousands of classes in my case), but solving it would not hurt anyone else.", "is_private": false, "id": 121872, "creator": "asusnjar@hotmail.com", "time": "2008-10-25T07:22:19Z", "bug_id": 46088, "creation_time": "2008-10-25T07:22:19Z", "attachment_id": null}, {"count": 1, "tags": [], "text": "Some of the resource collections do have a 'cache' attribute.  Further, most places that accept paths should accept other resource collections, so a simple workaround for you would be to wrap your path in a union resource collection (cache defaults to true).  Contrary to your assertion that paths, filesets, etc. are considered to be immutable, pre-Resource Collection versions of Ant worked by re-scanning for files (e.g. when getting the members of a fileset, of which it was and is possible to compose paths).  When path was retrofitted as a resource collection it actually did originally cache results, leading to bug 41151 (a regression).  As an additional measure we could propagate the 'cache' attribute directly to path to be passed to its underlying union (the original cut of path as a resource collection extended union and thus did support this attribute, but this was never released).", "attachment_id": null, "id": 121908, "creator": "mbenson@apache.org", "time": "2008-10-27T07:53:57Z", "bug_id": 46088, "creation_time": "2008-10-27T07:53:57Z", "is_private": false}, {"count": 2, "tags": [], "bug_id": 46088, "attachment_id": null, "id": 121915, "time": "2008-10-27T09:55:36Z", "creator": "asusnjar@hotmail.com", "creation_time": "2008-10-27T09:55:36Z", "is_private": false, "text": "I *did* mention the problems you re-state (\"... it can contain mutable pieces...\"). And paths are presented as immutable themselves as there is no way to affect them from the script once they are created. \n\nI resolved my own problem by creating my own subclass which caches its own results but also pre-wraps its component resource collection for added iterator performance. I could share this source code, but this *would* cause problems if someone expects file system changes to be reflected after caching (I don't have such a problem).\n\nI like the idea of adding \"cache\" attribute to Path (and other resource collections).\n\n\n\n"}, {"count": 3, "attachment_id": null, "bug_id": 46088, "text": "r808421", "id": 134025, "time": "2010-01-29T07:51:25Z", "creator": "mbenson@apache.org", "creation_time": "2010-01-29T07:51:25Z", "tags": [], "is_private": false}]