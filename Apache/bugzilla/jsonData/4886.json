[{"count": 0, "tags": [], "bug_id": 4886, "is_private": false, "text": "I like to keep my build files as generic as possible, avoiding special cases for\nsingles files where possible. This works well for all tasks I use, except for\nJUnit tasks, where you have to explicitly define which files (or classes) that\nimplement test cases.\n\nThis has been solved in some cases by separating the \"test\" source tree from the\n\"real\" source tree and forcing test classes to certain name standards.\n\nThe problem with this is that there is a possibility for name clashes between\nthe trees, and that it is a bit cumbersome to find test classes for the working\nclasses. In fact - there is no way to see if a class or package has a test case\nexcept for documentation.\n\nProvided is a patch that implements a connection between source files and\npackage documentation files and their respective test classes. The patch uses a\njavadoc tag (defaults to @testclass) that specifies which class that implements\na test case for the class or package that the javadoc describes.\n\nExample:\n\n/**\n * This is a nice class.\n * @author Erik Agsjo\n * @testclass com.noptec.some.Test\n */\n\nPatches:\n\nIndex: src/main/org/apache/tools/ant/taskdefs/optional/junit/BatchTest.java\n===================================================================\nRCS file:\n/home/cvspublic/jakarta-ant/src/main/org/apache/tools/ant/taskdefs/optional/junit/BatchTest.java,v\nretrieving revision 1.8\ndiff -u -r1.8 BatchTest.java\n--- src/main/org/apache/tools/ant/taskdefs/optional/junit/BatchTest.java\t2001/10/28 21:30:22\t1.8\n+++ src/main/org/apache/tools/ant/taskdefs/optional/junit/BatchTest.java\t2001/11/15 12:42:23\n@@ -63,12 +63,17 @@\n import java.util.Enumeration;\n import java.util.Vector;\n import java.io.File;\n+import java.io.FileReader;\n+import java.io.BufferedReader;\n \n /**\n- * <p> Create then run <code>JUnitTest</code>'s based on the list of files\ngiven by the fileset attribute.\n+ * <p> Create then run <code>JUnitTest</code>s based on the list of files given\nby the fileset attribute.\n  *\n  * <p> Every <code>.java</code> or <code>.class</code> file in the fileset is \n- * assumed to be a testcase. \n+ * assumed to be a testcase unless the <code>usetag</code> attribute is specified.\n+ * In that case, every <code>.java</code> or <code>.html</code> file in the fileset\n+ * is parsed for a javadoc tag that specifies which testcase to run.\n+ *\n  * A <code>JUnitTest</code> is created for each of these named classes with\nbasic setup\n  * inherited from the parent <code>BatchTest</code>.\n  *\n@@ -80,6 +85,15 @@\n  */\n public final class BatchTest extends BaseTest {\n \n+    /** are we scanning JavaDoc tags for test classes ? */\n+    private boolean useTag = false;\n+\n+    /** standard JavaDoc tag that defines test classes */\n+    static String DOCTAG_TEST = \"testclass\";\n+\n+    /** current JavaDoc tag that defines test classes */\n+    private String tagName = DOCTAG_TEST;\n+\n     /** the reference to the project */\n     private Project project;\n \n@@ -95,6 +109,21 @@\n     }\n \n     /**\n+     * enable / disable JavaDoc tag scanning\n+     */\n+    public void setUsetag(boolean status){\n+\nthis.useTag = status;\n+    }\n+\n+    /**\n+     * set JavaDoc tag name to look for if \"usetag\" is enabled\n+     * @param tagName the JavaDoc tag used to define test classes\n+     */\n+    public void setTagname(String tagName){\n+\nthis.tagName = tagName;\n+    }\n+\n+    /**\n      * Add a new fileset instance to this batchtest. Whatever the fileset is,\n      * only filename that are <tt>.java</tt> or <tt>.class</tt> will be\n      * considered as 'candidates'.\n@@ -130,16 +159,18 @@\n \n     /**\n      * Create all <tt>JUnitTest</tt>s based on the filesets. Each instance\n-     * is configured to match this instance properties.\n+     * is configured to match this instances properties.\n      * @return the array of all <tt>JUnitTest</tt>s that belongs to this batch.\n      */\n     private JUnitTest[] createAllJUnitTest(){\n         String[] filenames = getFilenames();\n-        JUnitTest[] tests = new JUnitTest[filenames.length];\n-        for (int i = 0; i < tests.length; i++) {\n+\n// hash set for eliminating duplicate test classes\n+\nHashSet uniqueTests = new HashSet();\n+        for (int i = 0; i < filenames.length; i++) {\n             String classname = javaToClass(filenames[i]);\n-            tests[i] = createJUnitTest(classname);\n+\n    uniqueTests.add(createJUnitTest(classname));\n         }\n+\nJUnitTest[] tests = (JUnitTest[]) uniqueTests.toArray(new JUnitTest[]{});\n         return tests;\n     }\n \n@@ -164,10 +195,26 @@\n             for (int k = 0; k < f.length; k++) {\n                 String pathname = f[k];\n                 if (pathname.endsWith(\".java\")) {\n-                    v.addElement(pathname.substring(0,\npathname.length()-\".java\".length()));\n+\n\t    if (useTag){\n+\n\t\t// parse javadoc tag from java source file\n+\n\t\tString className = parseTestTag(tagName,\n+\n\t\t\t\t\t\tds.getBasedir() + File.separator + pathname,\n+\n\t\t\t\t\t\ttrue);\n+\n\t\tif(className != null){\n+\n\t\t    v.addElement(className);\n+\n\t\t}\n+\n\t    }else{\n+\n\t\tv.addElement(pathname.substring(0, pathname.length()-\".java\".length()));\n+\n\t    }\n                 } else if (pathname.endsWith(\".class\")) {\n                     v.addElement(pathname.substring(0,\npathname.length()-\".class\".length()));\n-                }\n+                } else if (useTag && pathname.endsWith(\".html\")) {\n+\n\t    // parse javadoc tag from package doc file\n+\n\t    String className = parseTestTag(tagName, pathname, false);\n+\n\t    if(className != null){\n+\n\t\tv.addElement(className);\n+\n\t    }\n+\n\t}\n             }\n         }\n \n@@ -185,6 +232,57 @@\n      */\n     public static final String javaToClass(String filename){\n         return filename.replace(File.separatorChar, '.');\n+    }\n+\n+    /**\n+     * Simple, stupid, JavaDoc tag parser.\n+     *\n+     * @return the first word after the first matching tag in the file,\n+     *         or null if no tag is found, or any other error occurs\n+     * @param tagName the name of the tag to parse, with or without the\n<code>@</code>-character\n+     * @param fileName the full path to the file to parse\n+     * @param prependPackage if set, the package of a parsed .java file will be\nprepended to\n+     *        the parsed tag value, if the tag does not look like a fully\nspecified class name\n+     */\n+    public static String parseTestTag(String tagName, String fileName, boolean\nprependPackage){\n+\nString packageName = null;\n+\n+\nif(!tagName.startsWith(\"@\")){\n+\n    tagName = \"@\" + tagName;\n+\n}\n+\n\n+\ntry{\n+\n    BufferedReader reader = new BufferedReader(new FileReader(fileName));\n+\n    String line = null;\n+\n    while((line = reader.readLine()) != null){\n+\n\tif(prependPackage && packageName == null && fileName.endsWith(\".java\")){\n+\n\t    if(line.trim().startsWith(\"package\")){\n+\n\t\tpackageName = line.substring(\"package\".length()).trim();\n+\n\t\tif(packageName.endsWith(\";\")) {\n+\n\t\t    packageName = packageName.substring(0, packageName.length() - 1).trim();\n+\n\t\t}\n+\n\t    }\n+\n\t}\n+\n\tint tagIndex = line.indexOf(tagName);\n+\n\tif(tagIndex != -1){\n+\n\t    StringTokenizer strtok = new StringTokenizer(line.substring(tagIndex +\ntagName.length()));\n+\n\t    String className = null;\n+\n\t    try{\n+\n\t\tclassName = strtok.nextToken();\n+\n\t    }catch(NoSuchElementException ex){\n+\n\t\tcontinue;\n+\n\t    }\n+\n\t    return (prependPackage && className.indexOf(\".\") < 0 ?\n+\n\t\t    packageName + \".\" + className : className);\n+\n\t}\n+\n\t\n+\n    }\n+\n}catch(java.io.FileNotFoundException fnf){\n+\n    // not gonna happen :)\n+\n}catch(java.io.IOException iox){\n+\n    // not gonna happen :)\n+\n}\n+\nreturn null;\n     }\n \n     /**\n\n\n-----\n\n\nIndex: src/main/org/apache/tools/ant/taskdefs/optional/junit/JUnitTest.java\n===================================================================\nRCS file:\n/home/cvspublic/jakarta-ant/src/main/org/apache/tools/ant/taskdefs/optional/junit/JUnitTest.java,v\nretrieving revision 1.8\ndiff -u -r1.8 JUnitTest.java\n--- src/main/org/apache/tools/ant/taskdefs/optional/junit/JUnitTest.java\t2001/10/28 21:30:22\t1.8\n+++ src/main/org/apache/tools/ant/taskdefs/optional/junit/JUnitTest.java\t2001/11/15 12:42:34\n@@ -186,4 +186,29 @@\n             v.addElement( formatters.elementAt(i) );\n         }\n     }\n+\n+    /**\n+     * Test class name based hash code implementation\n+     */\n+    public int hashCode(){\n+\nString name = getName();\n+\nif(name == null){\n+\n    return 0;\n+\n}else{\n+\n    return name.hashCode();\n+\n}\n+    }\n+\n+    /**\n+     * Two JUnitTest descendants of the same class with the same \n+     * containing test class are considered equal.\n+     */\n+    public boolean equals(Object other){\n+\nif(other != null && other.getClass().equals(getClass())){\n+\n    JUnitTest otherTest = (JUnitTest) other;\n+\n    return getName().equals(otherTest.getName());\n+\n}else{\n+\n    return false;\n+\n}\n+    }\n }", "id": 7939, "time": "2001-11-15T04:59:32Z", "creator": "erik.agsjo@noptec.com", "creation_time": "2001-11-15T04:59:32Z", "attachment_id": null}, {"count": 1, "tags": [], "bug_id": 4886, "text": "This is an interesting idea; using javadoc attributes to bind to test cases. \nBy doing so you actually add a piece of information which doctools can use, as \nwell as ant. \n\nI''ll leave it to others to decide whether this patch should be committed, but \nI would like to recommend that a structured tag in ant namespace gets used \n(e.h. @ant:junittest), or maybe a junit one. That way an xdoclet for the \nnamespace can handle those tags too, and other doclets wont.\n\nIncidentally, what is wrong with having the unit tests in a separate package :-\n\n<include name=\"com/iseran/nordwand/model/unittests/*Test.java\"/>\n\nIs is because you need access to package level methods?\n", "id": 7949, "time": "2001-11-15T11:14:00Z", "creator": "steve_l@iseran.com", "creation_time": "2001-11-15T11:14:00Z", "is_private": false, "attachment_id": null}, {"count": 2, "tags": [], "bug_id": 4886, "text": "I'm sorry if my initial description of the problem wasn't too clear, I was in a\nhurry when I wrote it.\n\nI don't think that keeping tests in a separate package is wrong, especially when\nthis package is a subpackage to the package being tested as in your example. But\nin some cases, test cases that need access to package methods might be needed.\n\nI have even used test cases implemented in static inner classes to test really\ninternal mechanisms of some classes.\n\nThe main issue of my enhancement request is a way to define the connection\nbetween classes or packages and their test cases that works in any of the\nsituations above.\nKeeping the javadoc tag in an ant or junit namespace sounds like a good idea.", "id": 7964, "time": "2001-11-15T14:30:56Z", "creator": "erik.agsjo@noptec.com", "creation_time": "2001-11-15T14:30:56Z", "is_private": false, "attachment_id": null}, {"count": 3, "tags": [], "bug_id": 4886, "attachment_id": null, "is_private": false, "id": 7968, "time": "2001-11-15T15:07:24Z", "creator": "sbailliez@apache.org", "creation_time": "2001-11-15T15:07:24Z", "text": "I'm puzzled by your proposal.\n\nThis problem is easily solved by adopting naming guidelines for testcases.\nIn my company all JUnit testcases are prefixed by TestCase, in Ant all JUnit \ntestcases are postfixed by Test.\nThe classic trick is also to use a different directory for TestCase that match \nexactly the structure of the source code, this way you don't have to import the \nclasses you test, and you have package access.\n\nThis kind of guidelines makes it easy to set a consistent filter on sources and \nhas the benefit as well to distinguish easily testcases in an IDE source \nbrowser.\n\nIf such thing has to be done it would probably be easier and more reliable to \nuse the bytecode information than a tag in the source code. If it extends \nTestCase and is not abstract obviouslly it's a candidate. :)"}, {"count": 4, "tags": [], "text": "Stephane,\n\nas I wrote in my previous comment, my main concern is not how to organize source\ntrees, packages or class naming conventions. Clearly there are several methods\nof doing this that fit different development situations.\n\nWhat I would like is some way of seeing, for each class (and maybe each\npackage), what testcase that is responsible for verifying the functionality. If\nwe decide to use a javadoc tag for this purpose, then this could also be used to\nby ant to find out what testcases to run.\n\nI find it more intuitive to write rules that say \"run tests on these classes\"\nrather than \"run these testcases that test something\".\n\nIf a javadoc tag is used, the \"main class\" <-> \"test case\" relationship could be\nextracted by a doclet and included in the documentation. We could also specify a\ntestcase for a whole package by setting javadoc tags in the package\ndocumentation file.", "is_private": false, "id": 7979, "creator": "erik.agsjo@noptec.com", "time": "2001-11-16T02:16:07Z", "bug_id": 4886, "creation_time": "2001-11-16T02:16:07Z", "attachment_id": null}, {"count": 5, "tags": [], "bug_id": 4886, "is_private": false, "text": "After rereading it sounds like a good idea and I think our doclet master \n(Erik ? you there ?) could add his thoughts as well.", "id": 11905, "time": "2002-03-17T23:23:52Z", "creator": "sbailliez@apache.org", "creation_time": "2002-03-17T23:23:52Z", "attachment_id": null}, {"count": 6, "tags": [], "bug_id": 4886, "is_private": false, "id": 11928, "attachment_id": null, "creator": "jakarta@ehatchersolutions.com", "creation_time": "2002-03-18T11:52:24Z", "time": "2002-03-18T11:52:24Z", "text": "I thinking having Ant scan for @tags is not the right solution. But certainly \nXDoclet could pre-process source code to somehow filter test cases."}, {"count": 7, "tags": [], "creator": "erik.agsjo@noptec.com", "text": "Since I initially submitted the request, I have solved the situation by creating\na custom task for extracting the javadoc tags to a temporary file, and then\nusing this file in a fileset-includesfile tag for the junit task.\n\nThe only problem I had with this is that I have to run a \"replace\" on the\ntemporary file to expand '$' inner class name separators to '$$' to avoid ant\nparameter substitution.\n\nIf the doc parsing could be done by another, more generic task, that would be a\nmuch nicer solution.", "id": 11938, "time": "2002-03-18T15:02:26Z", "bug_id": 4886, "creation_time": "2002-03-18T15:02:26Z", "is_private": false, "attachment_id": null}, {"count": 8, "text": "XDoclet is what you're after.  With a custom template in the format of an \nincludesfile format it would be pretty easy to accomplish, I believe.  I'll \nmark this as WONTFIX since you've found a workaround that works for you.", "bug_id": 4886, "is_private": false, "id": 11944, "time": "2002-03-18T16:25:01Z", "creator": "jakarta@ehatchersolutions.com", "creation_time": "2002-03-18T16:25:01Z", "tags": [], "attachment_id": null}]