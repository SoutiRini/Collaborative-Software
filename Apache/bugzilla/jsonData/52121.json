[{"count": 0, "tags": [], "bug_id": 52121, "is_private": false, "id": 151126, "creation_time": "2011-11-01T22:15:16Z", "time": "2011-11-01T22:15:16Z", "creator": "dmarcks@amazon.com", "text": "Created attachment 27886\nGzip Corruption Repro WAR\n\nThis appears to be same issue as posted by Christopher Taylor\nJun 30, 2011 at 8:05 am to Tomcat Users. The subject line has been preserved above.\n\nAs mentioned in the post, this seems to have arisen with this issue:\nhttps://issues.apache.org/bugzilla/show_bug.cgi?id=48738\n\nThe change introduced this class: FlushableGZIPOutputStream. When we started using this, we noticed that certain string flush sequences would result in corrupt gzip output. \n\nThe attached WAR provides a repro. The sequence of writes to the output stream that would\u2019ve been done by our server is mimicked in this case using a file system. There are 40 files each representing a flush. URL:\n\n\"http://localhost:8080/TomcatBugReportWAR\"\n\nI\u2019ve allowed the \u2018start\u2019 and \u2018end\u2019 request parameters to control to the starting and ending points. I\u2019ve also allowed an \u2018append\u2019 request parameter dump anything to the outputstream.\n\nThe defaults are 0, 40, and \u201c\u201d for start end and append respectively.\n\nThe following query string appears particularly interesting as it seems to be the smallest sequence that causes the corruption and the subsequent string that is appended after the output is the only thing that appears corrupted:\n\n\"http://localhost:8080/TomcatBugReportWAR?start=19&end=30&append=something\u201d\n\nIt\u2019s also possible to reproduce this using only the FlushableGZIPOutputStream without using Tomcat at all. See attached JAR.", "attachment_id": 27886}, {"count": 1, "tags": [], "creator": "dmarcks@amazon.com", "attachment_id": 27887, "text": "Created attachment 27887\nIsolated Reproduction without using Tomcat", "id": 151127, "time": "2011-11-01T22:18:25Z", "bug_id": 52121, "creation_time": "2011-11-01T22:18:25Z", "is_private": false}, {"count": 2, "attachment_id": null, "bug_id": 52121, "is_private": false, "id": 151170, "time": "2011-11-03T23:14:00Z", "creator": "markt@apache.org", "creation_time": "2011-11-03T23:14:00Z", "tags": [], "text": "Many thanks for the excellent test case. It looks like it was very difficult to track down. We really do appreciate your efforts on this.\n\nI have converted the stand-alone reproduction JAR to a Tomcat test case. It isn't yet in the standard test suite as it currently always fails.\n\nI noticed that the following is sufficient to reproduce the issue:\n- send parts 19 to 28, flush, 29, flush, close\n\nI have therefore merged parts 19 to 28 for the test case.\n\nThe failure is a CRC error.\n\nAt this point this looks like a JVM bug.\n\nWe don't normally address JVM bugs in the Tomcat codebase but if we can figure out exactly what causes this bug (it seems to be related to a very precise state) then we might be able to detect the state and prevent the flush that triggers the bug. Failing that, it should be possible to make use of the flushable GZIP filter configurable.\n\nAs a workaround, you may be able to add an explicit flush() to the page(s) where this occurs."}, {"count": 3, "tags": [], "bug_id": 52121, "attachment_id": null, "text": "Note that you can run the test by adding the following line to the build.properties file:\ntest.entry=org.apache.coyote.http11.filters.TesterFlushableGZIPOutputStream\n\nJust for reference:\nIf I run the test through Ant it fails in an odd way:\n\n[[[\nTestsuite: org.apache.coyote.http11.filters.TesterFlushableGZIPOutputStream\nTests run: 1, Failures: 0, Errors: 1, Time elapsed: 0,031 sec\n\nTestcase: testBug52121 took 0,016 sec\n\tCaused an ERROR\nnull\njava.lang.NullPointerException\n\tat org.apache.catalina.util.IOTools.flow(IOTools.java:74)\n\tat org.apache.catalina.util.IOTools.flow(IOTools.java:85)\n\tat org.apache.coyote.http11.filters.TesterFlushableGZIPOutputStream.testBug52121(TesterFlushableGZIPOutputStream.java:47)\n]]]\n\nI cannot explain this NPE.\n\nIf I run it as JUnit test from with Eclipse IDE I get the IO error:\n\n[[[\njava.io.IOException: Corrupt GZIP trailer\n\tat java.util.zip.GZIPInputStream.readTrailer(GZIPInputStream.java:203)\n\tat java.util.zip.GZIPInputStream.read(GZIPInputStream.java:94)\n\tat java.io.FilterInputStream.read(FilterInputStream.java:90)\n\tat org.apache.catalina.util.IOTools.flow(IOTools.java:74)\n\tat org.apache.catalina.util.IOTools.flow(IOTools.java:85)\n\tat org.apache.coyote.http11.filters.TesterFlushableGZIPOutputStream.testBug52121(TesterFlushableGZIPOutputStream.java:63)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:597)\n\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)\n\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)\n\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)\n\tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runNotIgnored(BlockJUnit4ClassRunner.java:79)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:71)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:49)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:193)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:42)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:236)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)\n]]]\n\nThe sources are trunk@1197344, both were run with jdk 6u29 (build 1.6.0_29-b11) on Windows XP 32-bit.", "id": 151172, "time": "2011-11-03T23:53:23Z", "creator": "knst.kolinko@gmail.com", "creation_time": "2011-11-03T23:53:23Z", "is_private": false}, {"count": 4, "attachment_id": null, "bug_id": 52121, "is_private": false, "id": 151174, "time": "2011-11-04T01:35:22Z", "creator": "knst.kolinko@gmail.com", "creation_time": "2011-11-04T01:35:22Z", "tags": [], "text": "I think I fixed it with r1197382.\n\n\nRegarding the NPE when testing with Ant: it is a fault in the test case.\nThe resources are not copied when compiling the test classes. Thus classloader.getResourceAsStream() does not find the resource and returns null."}, {"count": 5, "tags": [], "creator": "markt@apache.org", "text": "Unfortunately, that hasn't fixed it. It just avoids the call that triggers the problem. I've added an additional write to expose the issue again. I also found a way to crash the JVM. This makes me more convinced this is as JVM bug.", "id": 151177, "time": "2011-11-04T10:13:57Z", "bug_id": 52121, "creation_time": "2011-11-04T10:13:57Z", "is_private": false, "attachment_id": null}, {"count": 6, "attachment_id": null, "bug_id": 52121, "text": "Several additional notes\n\nA link to the thread by Christopher Taylor mentioned by OP:\nhttp://tomcat.markmail.org/thread/v56xpi5uz4end7cd\n\nNote, that the Christopher Taylor's thread contains an attachment but only containing the corrupted gzip stream.\n\n1. I can observe the CRC error with 3-rd party tool, 7-zip.\n\nIt cannot decompress the file in Christopher Taylor's message, nether it can the one produced by the test case for this issue before I committed my changes. It reports CRC error.\n\nChristopher Taylor's file was produced by Tomcat 7.0.14.\n\nThus not only Java report that the stream is broken.\n\n2. According to the sources of deflate.c of zlib library that can be found in many placed, changing compression level which is performed by \"deflateParams\" call indeed causes deflate(strm, Z_PARTIAL_FLUSH) flushing the buffer.\n\nThat is in some old version of the code. In more recent ones it is just a deflate(strm, Z_BLOCK).\n\n\n3. Looking at the content of the streams produced by compression. Both the stream in Christopher Taylor's message and the one produced by the JUnit test case for this bug have uncompressed data near the end of the stream.\n\nThat is \"</id><version>\"... or \"<div \"... respectively - about 200 bytes of plain text.\n\nIt just means that the flush in deflateParams() call failed to flush the whole stream.\n\nThat happens when the output buffer used by deflate.c (that is configured by 'size' parameter in GZIPOutputStream constructor) is too small. There is a loop that deals with this in DeflaterOutputStream.deflate(). Because the effective compression level at that time is Deflater.NO_COMPRESSION the data is flushed uncompressed.\n\nThe following follows:\n1) If I increase size of the buffer by the following change in FlushableGZIPOutputStream constructor, the problem reported here disappears:\n\n-        super(os);\n+        super(os, 64*1024);\n\n\n4. The Java bugs 4255743 and 4813885 that are mentioned in the Javadoc for the FlushableGZIPOutputStream class are both fixed in Java 7.\n\nThere is an additional boolean argument to GZIPOutputStream and DeflaterOutputStream constructors in Java 7, \"syncFlush\". If it is set to true, then calling mere flush() results in flushing the compressor.\n\n5. Some documentation mentions that there is a trick in gzip when partial flush is performed. It sends either one block or two blocks.\n\nhttp://www.bolet.org/~pornin/deflate-flush.html", "id": 151184, "time": "2011-11-04T12:08:34Z", "creator": "knst.kolinko@gmail.com", "creation_time": "2011-11-04T12:08:34Z", "tags": [], "is_private": false}, {"count": 7, "tags": [], "bug_id": 52121, "attachment_id": null, "text": "Further fixed in r1197578\n\nI removed the trick with empty byte array and direct call to def.setInput(). Calling setInput() with empty data never happens in the standard write() method.", "id": 151189, "time": "2011-11-04T14:14:25Z", "creator": "knst.kolinko@gmail.com", "creation_time": "2011-11-04T14:14:25Z", "is_private": false}, {"count": 8, "attachment_id": null, "bug_id": 52121, "is_private": false, "id": 151206, "time": "2011-11-04T19:57:40Z", "creator": "markt@apache.org", "creation_time": "2011-11-04T19:57:40Z", "tags": [], "text": "The latest fix looks good to me. I have applied it to 7.0.x and it will be included in 7.0.23 onwards.\n\nMoving this issue to 6.0.x as it also needs to be fixed there."}, {"count": 9, "tags": [], "creator": "knst.kolinko@gmail.com", "text": "Created attachment 27905\n2011-11-07_tc6_FlushableGZIPOutputStream.patch\n\nPatch for Tomcat 6.0", "id": 151250, "time": "2011-11-07T02:45:47Z", "bug_id": 52121, "creation_time": "2011-11-07T02:45:47Z", "is_private": false, "attachment_id": 27905}, {"count": 10, "tags": [], "bug_id": 52121, "attachment_id": null, "text": "Applied to 6.0 with r1200603 and will be in 6.0.34.", "id": 151383, "time": "2011-11-10T22:36:52Z", "creator": "knst.kolinko@gmail.com", "creation_time": "2011-11-10T22:36:52Z", "is_private": false}, {"count": 11, "tags": [], "creator": "knst.kolinko@gmail.com", "text": "Reverted in 6.0 in r1200620. It is broken.\nBrowsers display empty page with compression=\"on\".\nWget says \"No data received\".\nAs if connection has been closed.\n\n\nDebugging with trunk, there is problem in OutputBuffer.close().\nIt does:\n        doFlush(false);\n        closed = true;\n\nIt closes underlying stream without closing FlushableGZIPOutputStream first.\nConsequently the attempt to write out the last byte at FlushableGZIPOutputStream#close() fails with an IOException.", "id": 151384, "time": "2011-11-11T00:11:03Z", "bug_id": 52121, "creation_time": "2011-11-11T00:11:03Z", "is_private": false, "attachment_id": null}, {"count": 12, "tags": [], "creator": "knst.kolinko@gmail.com", "attachment_id": null, "id": 151385, "creation_time": "2011-11-11T02:28:26Z", "time": "2011-11-11T02:28:26Z", "bug_id": 52121, "text": "The issue in comment 11 fixed in trunk and 7.0 with r1200696 and r1200698 respectively, will be in 7.0.23.", "is_private": false}, {"count": 13, "attachment_id": 27924, "bug_id": 52121, "is_private": false, "id": 151386, "time": "2011-11-11T02:38:54Z", "creator": "knst.kolinko@gmail.com", "creation_time": "2011-11-11T02:38:54Z", "tags": [], "text": "Created attachment 27924\n2011-11-11_tc6_FlushableGZIPOutputStream-v2.patch\n\nUpdated patch for 6.0.x."}, {"attachment_id": null, "tags": [], "bug_id": 52121, "text": "(In reply to comment #11)\n>> Debugging with trunk, there is problem in OutputBuffer.close().\n>> It does:\n>>         doFlush(false);\n>>         closed = true;\n>> \n>> It closes underlying stream without closing FlushableGZIPOutputStream first.\n>> Consequently the attempt to write out the last byte at\n>> FlushableGZIPOutputStream#close() fails with an IOException.\n\nJust to clear misinformation: the statements quoted above are wrong.\n\nIt behaved as if the stream were closed, but the real cause was finished Deflater. It has nothing to do with the underlying buffer and the code fragment above. See r1200696", "count": 14, "id": 151387, "time": "2011-11-11T04:34:39Z", "creator": "knst.kolinko@gmail.com", "creation_time": "2011-11-11T04:34:39Z", "is_private": false}, {"count": 15, "tags": [], "bug_id": 52121, "is_private": false, "text": "Fixed in 6.0 with r1201193 and will be in 6.0.34.", "id": 151426, "time": "2011-11-12T05:31:34Z", "creator": "knst.kolinko@gmail.com", "creation_time": "2011-11-12T05:31:34Z", "attachment_id": null}]