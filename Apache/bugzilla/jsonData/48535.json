[{"count": 0, "tags": [], "bug_id": 48535, "attachment_id": null, "is_private": false, "id": 133573, "time": "2010-01-13T04:36:12Z", "creator": "bart.vanassche@gmail.com", "creation_time": "2010-01-13T04:36:12Z", "text": "When analyzing a multithreaded program that calls both allocator_alloc() and allocator_free() with a data race detection tool, these tools report a potential data race on the accesses of allocator->index at the start of allocator_alloc(). While these conflicting accesses seem harmless to me because allocator->index is reread after having locked the allocator mutex, this is annoying.\n\nA straightforward workaround is to move the allocator->mutex locking / unlocking statements from inside the if-statement to outside the if-statement. But I'm afraid that doing this would decrease performance.\n\nThis issue has been reported previously on the apr-dev mailing list -- see also http://mail-archives.apache.org/mod_mbox/apr-dev/200908.mbox/%3C4A81D0F4.90406@ruppert-it.de%3E"}, {"count": 1, "tags": [], "bug_id": 48535, "text": "Isn't this an intentional race condition, following the usual pattern\n\nmake a very cheap but imperfect state check\nif it looks good so far:\n  get mutex\n  check state carefully this time, handle appropriately\n  release mutex", "id": 134015, "time": "2010-01-29T04:00:32Z", "creator": "trawick@apache.org", "creation_time": "2010-01-29T04:00:32Z", "is_private": false, "attachment_id": null}, {"count": 2, "tags": [], "creator": "bart.vanassche@gmail.com", "text": "(In reply to comment #1)\n> Isn't this an intentional race condition, following the usual pattern\n> \n> make a very cheap but imperfect state check\n> if it looks good so far:\n>   get mutex\n>   check state carefully this time, handle appropriately\n>   release mutex\n\nI agree with the above. The reason that I filed this report is not because I suspect a bug in APR but because the thread checker reports are annoying. Thread checking tools (Intel Parallel Studio, Intel Thread Checker, DRD, Helgrind, ...) complain about this construct during every run of every application that uses the APR.", "id": 134016, "time": "2010-01-29T04:06:11Z", "bug_id": 48535, "creation_time": "2010-01-29T04:06:11Z", "is_private": false, "attachment_id": null}, {"count": 3, "tags": [], "bug_id": 48535, "attachment_id": null, "text": "Is there a -DPURIFY-like constant that is in standard use, which could be used to ifdef-munge the code, to avoid the lazy check?  Given that the code is valid it would be better to fix the analysis tools to be smarter than to make the code dumber.", "id": 134070, "time": "2010-01-31T06:05:44Z", "creator": "jorton@redhat.com", "creation_time": "2010-01-31T06:05:44Z", "is_private": false}, {"count": 4, "tags": [], "bug_id": 48535, "attachment_id": null, "is_private": false, "id": 134075, "time": "2010-01-31T09:38:46Z", "creator": "bart.vanassche@gmail.com", "creation_time": "2010-01-31T09:38:46Z", "text": "(In reply to comment #3)\n> Is there a -DPURIFY-like constant that is in standard use, which could be used\n> to ifdef-munge the code, to avoid the lazy check?  Given that the code is valid\n> it would be better to fix the analysis tools to be smarter than to make the\n> code dumber.\n\nRecent DRD and Helgrind versions support annotations like ANNOTATE_IGNORE_READS_BEGIN() / ANNOTATE_IGNORE_READS_END(). Unfortunately these annotations are not supported by thread checking tools on Windows.\n\nAn approach that might work with all four mentioned data race detectors is to replace the read of allocator->index outside the critical section by an atomic read. Doing so would suppress race reports."}, {"attachment_id": null, "tags": [], "creator": "sr@myarm.com", "is_private": false, "count": 5, "id": 139698, "time": "2010-09-04T14:17:44Z", "bug_id": 48535, "creation_time": "2010-09-04T14:17:44Z", "text": "(In reply to comment #1)\n> Isn't this an intentional race condition, following the usual pattern\n> \n> make a very cheap but imperfect state check\n> if it looks good so far:\n>   get mutex\n>   check state carefully this time, handle appropriately\n>   release mutex\n\nThats true, but the current code does not do this (check again carefully). Currently it does the following:\n\nif index <= allocator->max_index\n   get mutex\n   do something1\n   release mutex\nelse\n   do something2\n\nBut it does not check the state carefully again... So I think it should do this:\n\nif index <= allocator->max_index\n   get mutex\n   // max_index could be changed in the mean while\n   if index <= allocator->max_index\n      do something1\n      release mutex\n   else\n      release mutex\n      do something2\nelse\n   do something2\n\nHowever, I do not know the allocator code at all. But without the second if it is possible to execute do something1 even if index is greater than max_index!\n\nRegards,\nStefan (reporter of the issue on the mailing list ;-)"}]