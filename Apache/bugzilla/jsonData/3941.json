[{"count": 0, "attachment_id": null, "creator": "a.djaoui@rl.ac.uk", "text": "Flushing of buffered output from a servlet to a client does not work as shown in  \nthe following Servlet code and Clinet code. This problem only occured in Tomcat \n4 where the output only occures after closing the PrintWriter. The flushing \nworks fine with Tomcat 3.2.3 for both the Prinwriter and the \nHttpServletResponse.\n\nHERE IS THE SERVLET TEST CODE:\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Enumeration;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic final class Server extends HttpServlet {\n    \n    /**\n     * Respond to a GET request for the content produced by\n     * this servlet.\n     *\n     * @param request The servlet request we are processing\n     * @param response The servlet response we are producing\n     *\n     * @exception IOException if an input/output error occurs\n     * @exception ServletException if a servlet error occurs\n     */\n    public void doGet(HttpServletRequest request,\n                      HttpServletResponse response)\n\tthrows IOException, ServletException {\n\t\n\tresponse.setContentType(\"text/xml\");\n\tPrintWriter writer = response.getWriter();\n\twriter.println(\"buffersize:\" + response.getBufferSize());\n\t\n\t\n\twriter.println(\"\\nTest:\");\n\twriter.println(\"initial isCommited:\" + response.isCommitted());\n\t\n\twriter.println(\"\\nresponse\");\n\twriter.flush();\n\twriter.println(\"after writer.flush() isCommited:\" +         \nresponse.isCommitted());\n\t\n\twriter.println(\"\\nParameters\");\t\n\tresponse.flushBuffer();\n\twriter.println(\"after response.flushBuffer() isCommited:\" +         \nresponse.isCommitted());\n\t\n\tEnumeration names = request.getParameterNames();\n\twhile (names.hasMoreElements()) {\n\t    String name = (String) names.nextElement();\n\t    writer.println(name + \": \" + request.getParameter(name));\n\t    writer.println(\"Waiting 2secs\\n\");\n//THESE ARE THE 2 PROBLEMATIC LINES -NONE OF THEM WORKS WITH TOMCAT 4\n\t    writer.flush();\n\t    response.flushBuffer();\n\t    \n\t    try {\n\t\tThread.sleep(2000);\n\t    }\n\t    catch (InterruptedException e){\n\t    }\n\t}\n    }\n    \n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n\tthrows IOException, ServletException {\n\tdoGet(request, response);\n    }\n}\n\nAND HERE IS THE CLIENT CODE:\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.net.URL;\nimport java.net.URLDecoder;\nimport java.net.URLEncoder;\nimport java.net.URLConnection;\n\npublic class Client {\n    \n    public static void main(String[] args) {\n\tString query = \n\"http://localhost:8080/Server1/Server1?banana=yellow&snow=white&sea=blue\";\n\n\ttry {\n\t    URL url = new URL(query);\n\t    BufferedReader in = new BufferedReader(new \nInputStreamReader(url.openStream()));\n\t    String line;\n\t    while ((line = in.readLine()) != null)\n\t\tSystem.out.println(line);\n\t    \n\t} catch(IOException e) {\n\t    System.out.println(\"Error \" + e);\n\t}\n    }\n}", "id": 6315, "time": "2001-10-03T08:19:49Z", "bug_id": 3941, "creation_time": "2001-10-03T08:19:49Z", "tags": [], "is_private": false}, {"count": 1, "tags": [], "creator": "remm@apache.org", "attachment_id": null, "id": 6321, "time": "2001-10-03T10:56:53Z", "bug_id": 3941, "creation_time": "2001-10-03T10:56:53Z", "is_private": false, "text": "This works for me (HEAD branch + hacked HelloWorld servlet + IE).\nBoth writer.flush() and response.flushBuffer() work properly."}, {"count": 2, "attachment_id": null, "creator": "craig.mcclanahan@sun.com", "text": "Works for me as well.  I would also add that your testing methodology is\nsuspect, because the *client* is buffering things (inside the buffered reader)\nas well.\n\nTo accurately test this servlet, you should connect with a browser (but change\nthe content type to \"text/plain\" so the browser does not buffer things), or\nconnect directly to Tomcat with a Telnet connection.\n", "id": 6322, "time": "2001-10-03T11:03:52Z", "bug_id": 3941, "creation_time": "2001-10-03T11:03:52Z", "tags": [], "is_private": false}, {"count": 3, "tags": [], "text": "I should clarify that I am implementing a SERVLET-TO-SERVLET streaming \ncommunication and although the flushing works with a browser it doesn't in\na situation such as shown in my simple example. It could be that the problem\nis not with PrinWriter.flush() or HttpServletResponse.flushBuffer(), but with \nanother component of Tomcat 4 which is doing some additional buffering behind \nthe scenes and thus preventing the output from being sent straight away to the \nclient side.\nBufferedReader on the client side did not cause any problems on Tomcat 3.\nWhen I run my test example under Tomcat 3.2.3 it outputs banana: yellow, waits \nfor 2 seconds then outputs sea: blue, waits for 2 seconds and then outputs \nsnow: white before exiting (AS IT SHOULD).\nWith Tomcat 4 I get all 3 parameters at once and ONLY when the program exits, \nwithout \nthe 2 second wait time between the 3 parameters, showing that flushing the \nwriter and the response is not enough to send the output to the client. only \nwhen the program exits that the output appears. ", "is_private": false, "bug_id": 3941, "id": 6353, "time": "2001-10-04T03:59:43Z", "creator": "a.djaoui@rl.ac.uk", "creation_time": "2001-10-04T03:59:43Z", "attachment_id": null}, {"count": 4, "attachment_id": null, "creator": "remm@apache.org", "text": "If a browser works correctly, but your client fails, then it's a client problem \n(if the flush didn't work correctly on the server side, there would be no way \nfor the browser to display the data either).\n\nIn your particlar case, Catalina will return chunked output, which may cause \nthe problem when using HttpURLConnection to read the data (probably the \nbuffering you're talking about happens here).\n\nYou can disable chunking on the server side (at least with the current version \nof the connector) by using the allowChunking attribute (set its value to false).", "id": 6371, "time": "2001-10-04T09:21:51Z", "bug_id": 3941, "creation_time": "2001-10-04T09:21:51Z", "tags": [], "is_private": false}]