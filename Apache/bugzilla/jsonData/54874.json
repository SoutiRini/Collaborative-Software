[{"count": 0, "tags": [], "bug_id": 54874, "attachment_id": 30219, "text": "Created attachment 30219\nPatch to fix HTTPSampler and accept also a device in the 'Source IP address' box\n\nOverview: \nCurrently HTTPSampler supports only source IP addresses in the 'Source IP address' box, to allow testing from various different IP addresses on the same machine. It doesn't support however entering a device, for instance eth0, eth1, tun0 etc\n\nSteps to Reproduce: \n1. Enter a device in the 'Source IP address' box instead of an IP address\n\nActual Results:\nThe main IP address of the machine is being used\n\nExpected Results:\nThe device address should be used.\n\nAdditional Information:\nThe following patch fixed the behaviour and allows entering a device and not only an IP address.", "id": 166749, "time": "2013-04-22T02:22:38Z", "creator": "malkodan@gmail.com", "creation_time": "2013-04-22T02:22:38Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 54874, "attachment_id": null, "text": "Sounds weird to use same field for ip and device.\nGui is already overwhelmed so not sure we should add this one.", "id": 169058, "time": "2013-08-02T21:58:51Z", "creator": "p.mouawad@ubik-ingenierie.com", "creation_time": "2013-08-02T21:58:51Z", "is_private": false}, {"count": 2, "tags": [], "text": "What advantage does using the device name give?\nDoes it do anything other than choose the IP address for that device?", "is_private": false, "id": 169059, "creator": "sebb@apache.org", "time": "2013-08-02T22:05:09Z", "bug_id": 54874, "creation_time": "2013-08-02T22:05:09Z", "attachment_id": null}, {"count": 3, "tags": [], "text": "(In reply to Sebb from comment #2)\n> What advantage does using the device name give?\n> Does it do anything other than choose the IP address for that device?\n\nThe scenario I solved at the time - when submitting this patch was trying to create HTTP load via VPN devices with dynamically assigned addresses. While possible to regenerate the scenario every time VPN devices change addresses, I've found it cleaner to be able to assign devices in the scenario rather than addresses. The script that fired up the VPN devices knew what devices are going to come up, but the addresses would be assigned dynamically every time. The current behaviour of having a source IP address is still preserved after applying this patch.", "is_private": false, "bug_id": 54874, "id": 169065, "time": "2013-08-03T12:27:13Z", "creator": "malkodan@gmail.com", "creation_time": "2013-08-03T12:27:13Z", "attachment_id": null}, {"count": 4, "tags": [], "bug_id": 54874, "attachment_id": null, "is_private": false, "id": 169066, "time": "2013-08-03T12:28:16Z", "creator": "malkodan@gmail.com", "creation_time": "2013-08-03T12:28:16Z", "text": "(In reply to Philippe Mouawad from comment #1)\n> Sounds weird to use same field for ip and device.\n> Gui is already overwhelmed so not sure we should add this one.\n\nI agree the GUI is already overwhelmed, however the previous behaviour remains with the additional option of specifying a device instead of only a source address."}, {"count": 5, "tags": [], "bug_id": 54874, "attachment_id": null, "id": 169071, "time": "2013-08-03T13:36:00Z", "creator": "sebb@apache.org", "creation_time": "2013-08-03T13:36:00Z", "is_private": false, "text": "(In reply to Dan Fruehauf from comment #3)\n> (In reply to Sebb from comment #2)\n> > What advantage does using the device name give?\n> > Does it do anything other than choose the IP address for that device?\n> \n> The scenario I solved at the time - when submitting this patch was trying to\n> create HTTP load via VPN devices with dynamically assigned addresses. While\n> possible to regenerate the scenario every time VPN devices change addresses,\n> I've found it cleaner to be able to assign devices in the scenario rather\n> than addresses. The script that fired up the VPN devices knew what devices\n> are going to come up, but the addresses would be assigned dynamically every\n> time. The current behaviour of having a source IP address is still preserved\n> after applying this patch.\n\nAs a work-round, maybe you could use a property for the IP address and define the property on the command-line.\n\nBut provided that the change does not affect any existing tests, I don't see why the field should not allow device names as well as host names.\n\nHowever, the current implementation always searches the device names first; I think that is wrong. This is because it takes time to search the interfaces and the device name will override a hostname.\n\nPerhaps just process the hostnames first - would that work?\n\nOr maybe insist that device names always have the ipv[46]: prefix, or insist that they have a suffix that is not valid for a hostname - e.g. \"eth0:\""}, {"count": 6, "tags": [], "bug_id": 54874, "attachment_id": null, "id": 169072, "time": "2013-08-03T14:00:11Z", "creator": "malkodan@gmail.com", "creation_time": "2013-08-03T14:00:11Z", "is_private": false, "text": "(In reply to Sebb from comment #5)\n> (In reply to Dan Fruehauf from comment #3)\n> > (In reply to Sebb from comment #2)\n> > > What advantage does using the device name give?\n> > > Does it do anything other than choose the IP address for that device?\n> > \n> > The scenario I solved at the time - when submitting this patch was trying to\n> > create HTTP load via VPN devices with dynamically assigned addresses. While\n> > possible to regenerate the scenario every time VPN devices change addresses,\n> > I've found it cleaner to be able to assign devices in the scenario rather\n> > than addresses. The script that fired up the VPN devices knew what devices\n> > are going to come up, but the addresses would be assigned dynamically every\n> > time. The current behaviour of having a source IP address is still preserved\n> > after applying this patch.\n> \n> As a work-round, maybe you could use a property for the IP address and\n> define the property on the command-line.\nI could, but define 100 properties? The test case made use of many VPN devices at the same time, not just one.\n> \n> But provided that the change does not affect any existing tests, I don't see\n> why the field should not allow device names as well as host names.\n> \n> However, the current implementation always searches the device names first;\n> I think that is wrong. This is because it takes time to search the\n> interfaces and the device name will override a hostname.\nBy all means, behaviour may change if one has a hostname named as a device name (tun0, tap250, eth11 etc.). This is a rather awkward situation when you think about it. I do not know of a single person who names hostnames as devices. But then still if he has a hostname (not interface) which resolves for instance 'eth0' -> '192.168.0.1' and a device which is 'eth0' -> '192.168.0.1', JMeter behaviour will not change if he entered 'eth0' in the 'Source IP' field. Before the patch it would resolve to '192.168.0.1' by using the hostname, while after it'll resolve as well to '192.168.0.1' using the device name.\n\nIf he has though a device 'eth0' -> '192.168.0.1' and hostname 'eth0' -> '192.168.0.2', then yes, behaviour will change. Then we should ask ourselves if we want to cater also for these stupid situations? I tend to say no.\n\n> \n> Perhaps just process the hostnames first - would that work?\nProvided I do that, how do I know if something is a hostname or a device? It means that I'll have to use regular expressions to actually parse any device type that's available on any unix system. So for instance if you put 'pony0' as hostname and pony0 is a device of type pony in operating system ZooOS (which is supported by JMeter), how do I decide if pony0 is a hostname or a device?\n\n> \n> Or maybe insist that device names always have the ipv[46]: prefix, or insist\n> that they have a suffix that is not valid for a hostname - e.g. \"eth0:\"\nThat could work, but could also confuse users and significantly reduce the usability of that feature IMO. The average user will just use \"tun10\". After not understanding why things work he'll either give up (most likely) or search the documentation just to find out he needs the 'ipv4:' prefix."}, {"count": 7, "tags": [], "bug_id": 54874, "attachment_id": null, "is_private": false, "id": 169142, "time": "2013-08-05T17:45:17Z", "creator": "sebb@apache.org", "creation_time": "2013-08-05T17:45:17Z", "text": "(In reply to Dan Fruehauf from comment #6)\n> (In reply to Sebb from comment #5)\n> > (In reply to Dan Fruehauf from comment #3)\n> > > (In reply to Sebb from comment #2)\n> > > > What advantage does using the device name give?\n> > > > Does it do anything other than choose the IP address for that device?\n> > > \n> > > The scenario I solved at the time - when submitting this patch was trying to\n> > > create HTTP load via VPN devices with dynamically assigned addresses. While\n> > > possible to regenerate the scenario every time VPN devices change addresses,\n> > > I've found it cleaner to be able to assign devices in the scenario rather\n> > > than addresses. The script that fired up the VPN devices knew what devices\n> > > are going to come up, but the addresses would be assigned dynamically every\n> > > time. The current behaviour of having a source IP address is still preserved\n> > > after applying this patch.\n> > \n> > As a work-round, maybe you could use a property for the IP address and\n> > define the property on the command-line.\n> I could, but define 100 properties? The test case made use of many VPN\n> devices at the same time, not just one.\n\nIt's still a possible work-round.\n\n> > \n> > But provided that the change does not affect any existing tests, I don't see\n> > why the field should not allow device names as well as host names.\n> > \n> > However, the current implementation always searches the device names first;\n> > I think that is wrong. This is because it takes time to search the\n> > interfaces and the device name will override a hostname.\n> By all means, behaviour may change if one has a hostname named as a device\n> name (tun0, tap250, eth11 etc.). This is a rather awkward situation when you\n> think about it. I do not know of a single person who names hostnames as\n> devices. But then still if he has a hostname (not interface) which resolves\n> for instance 'eth0' -> '192.168.0.1' and a device which is 'eth0' ->\n> '192.168.0.1', JMeter behaviour will not change if he entered 'eth0' in the\n> 'Source IP' field. Before the patch it would resolve to '192.168.0.1' by\n> using the hostname, while after it'll resolve as well to '192.168.0.1' using\n> the device name.\n> \n> If he has though a device 'eth0' -> '192.168.0.1' and hostname 'eth0' ->\n> '192.168.0.2', then yes, behaviour will change. Then we should ask ourselves\n> if we want to cater also for these stupid situations? I tend to say no.\n\nSorry, but for backwards compatibility, host names must take precedence over device names.\n\n> > \n> > Perhaps just process the hostnames first - would that work?\n> Provided I do that, how do I know if something is a hostname or a device? \n\nIf the name does not resolve as a host name, then assume it may be a device.\n\n> It\n> means that I'll have to use regular expressions to actually parse any device\n> type that's available on any unix system. So for instance if you put 'pony0'\n> as hostname and pony0 is a device of type pony in operating system ZooOS\n> (which is supported by JMeter), how do I decide if pony0 is a hostname or a\n> device?\n\nSee above.\n \n> > \n> > Or maybe insist that device names always have the ipv[46]: prefix, or insist\n> > that they have a suffix that is not valid for a hostname - e.g. \"eth0:\"\n> That could work, but could also confuse users \n\nWhy would it confuse users?\nSo long as the documentation is clear, it would be less confusing than suddenly having a host name stop working because it happens to be the same as the name of an interface.\n\n> and significantly reduce the\n> usability of that feature IMO. The average user will just use \"tun10\". \n\nThe average user won't even know that devices are supported unless they read the documentation.\n\nSurely the Unix device is actually something like /dev/tun10, not just \"tun10\" anyway?\n\n> After\n> not understanding why things work he'll either give up (most likely) or\n> search the documentation just to find out he needs the 'ipv4:' prefix.\n\nIf the user fails to read the documentation, then they are likely to encounter all sorts of problems."}, {"count": 8, "tags": [], "creator": "malkodan@gmail.com", "attachment_id": null, "text": "(In reply to Sebb from comment #7)\n> (In reply to Dan Fruehauf from comment #6)\n> > (In reply to Sebb from comment #5)\n> > > (In reply to Dan Fruehauf from comment #3)\n> > > > (In reply to Sebb from comment #2)\n> > > > > What advantage does using the device name give?\n> > > > > Does it do anything other than choose the IP address for that device?\n> > > > \n> > > > The scenario I solved at the time - when submitting this patch was trying to\n> > > > create HTTP load via VPN devices with dynamically assigned addresses. While\n> > > > possible to regenerate the scenario every time VPN devices change addresses,\n> > > > I've found it cleaner to be able to assign devices in the scenario rather\n> > > > than addresses. The script that fired up the VPN devices knew what devices\n> > > > are going to come up, but the addresses would be assigned dynamically every\n> > > > time. The current behaviour of having a source IP address is still preserved\n> > > > after applying this patch.\n> > > \n> > > As a work-round, maybe you could use a property for the IP address and\n> > > define the property on the command-line.\n> > I could, but define 100 properties? The test case made use of many VPN\n> > devices at the same time, not just one.\n> \n> It's still a possible work-round.\n> \n> > > \n> > > But provided that the change does not affect any existing tests, I don't see\n> > > why the field should not allow device names as well as host names.\n> > > \n> > > However, the current implementation always searches the device names first;\n> > > I think that is wrong. This is because it takes time to search the\n> > > interfaces and the device name will override a hostname.\n> > By all means, behaviour may change if one has a hostname named as a device\n> > name (tun0, tap250, eth11 etc.). This is a rather awkward situation when you\n> > think about it. I do not know of a single person who names hostnames as\n> > devices. But then still if he has a hostname (not interface) which resolves\n> > for instance 'eth0' -> '192.168.0.1' and a device which is 'eth0' ->\n> > '192.168.0.1', JMeter behaviour will not change if he entered 'eth0' in the\n> > 'Source IP' field. Before the patch it would resolve to '192.168.0.1' by\n> > using the hostname, while after it'll resolve as well to '192.168.0.1' using\n> > the device name.\n> > \n> > If he has though a device 'eth0' -> '192.168.0.1' and hostname 'eth0' ->\n> > '192.168.0.2', then yes, behaviour will change. Then we should ask ourselves\n> > if we want to cater also for these stupid situations? I tend to say no.\n> \n> Sorry, but for backwards compatibility, host names must take precedence over\n> device names.\n\nI understand the backward compatibility argument, however you are catering here for the an extremely unlikely use case, which probably doesn't exist and will happen if and only if both conditions are met:\n * The user has a hostname named as a device - UNLIKELY\n * That hostname resolves to an IP address which is not of the mentioned device - VERY VERY UNLIKELY\n\n> \n> > > \n> > > Perhaps just process the hostnames first - would that work?\n> > Provided I do that, how do I know if something is a hostname or a device? \n> \n> If the name does not resolve as a host name, then assume it may be a device.\n\nYou are adding significantly extra complexity here for a situation that probably doesn't happen. Over engineering backward compatibility.\n\n> \n> > It\n> > means that I'll have to use regular expressions to actually parse any device\n> > type that's available on any unix system. So for instance if you put 'pony0'\n> > as hostname and pony0 is a device of type pony in operating system ZooOS\n> > (which is supported by JMeter), how do I decide if pony0 is a hostname or a\n> > device?\n> \n> See above.\n>  \n> > > \n> > > Or maybe insist that device names always have the ipv[46]: prefix, or insist\n> > > that they have a suffix that is not valid for a hostname - e.g. \"eth0:\"\n> > That could work, but could also confuse users \n> \n> Why would it confuse users?\n> So long as the documentation is clear, it would be less confusing than\n> suddenly having a host name stop working because it happens to be the same\n> as the name of an interface.\n> \n> > and significantly reduce the\n> > usability of that feature IMO. The average user will just use \"tun10\". \n> \n> The average user won't even know that devices are supported unless they read\n> the documentation.\n> \n> Surely the Unix device is actually something like /dev/tun10, not just\n> \"tun10\" anyway?\nNo, it's just tun10.\n> \n> > After\n> > not understanding why things work he'll either give up (most likely) or\n> > search the documentation just to find out he needs the 'ipv4:' prefix.\n> \n> If the user fails to read the documentation, then they are likely to\n> encounter all sorts of problems.\n\nOn the other hand you are trying to address in this argument a use case likely to happen if the user's intelligence level is too low to even learn how to read.\n\nI'm unconvinced that any of the hypothetical scenarios we mentioned here actually happen in real life. Even with pretty bad engineering paradigms.", "id": 169158, "time": "2013-08-06T02:15:55Z", "bug_id": 54874, "creation_time": "2013-08-06T02:15:55Z", "is_private": false}, {"count": 9, "tags": [], "text": "(In reply to Dan Fruehauf from comment #8)\n> I understand the backward compatibility argument, however you are catering\n> here for the an extremely unlikely use case, which probably doesn't exist\n> and will happen if and only if both conditions are met:\n>  * The user has a hostname named as a device - UNLIKELY\n>  * That hostname resolves to an IP address which is not of the mentioned\n> device - VERY VERY UNLIKELY\n\nBut not impossible.\n\n> > \n> > > > \n> > > > Perhaps just process the hostnames first - would that work?\n> > > Provided I do that, how do I know if something is a hostname or a device? \n> > \n> > If the name does not resolve as a host name, then assume it may be a device.\n> \n> You are adding significantly extra complexity here for a situation that\n> probably doesn't happen. Over engineering backward compatibility.\n\nI disagree that any of the fixes I proposed would significantly increase the complexity.\n\n> > Surely the Unix device is actually something like /dev/tun10, not just\n> > \"tun10\" anyway?\n> No, it's just tun10.\n\nSo it does not exist under /dev?\n\n> I'm unconvinced that any of the hypothetical scenarios we mentioned here\n> actually happen in real life. Even with pretty bad engineering paradigms.\n\nWe disagree.\n\nThe patch will not be accepted without changes to ensure:\n- host names take precedence over device names\n- the network devices are not searched unnecessarily", "is_private": false, "bug_id": 54874, "id": 169161, "time": "2013-08-06T03:16:03Z", "creator": "sebb@apache.org", "creation_time": "2013-08-06T03:16:03Z", "attachment_id": null}, {"count": 10, "tags": [], "bug_id": 54874, "attachment_id": null, "text": "(In reply to Sebb from comment #9)\n> (In reply to Dan Fruehauf from comment #8)\n> > I understand the backward compatibility argument, however you are catering\n> > here for the an extremely unlikely use case, which probably doesn't exist\n> > and will happen if and only if both conditions are met:\n> >  * The user has a hostname named as a device - UNLIKELY\n> >  * That hostname resolves to an IP address which is not of the mentioned\n> > device - VERY VERY UNLIKELY\n> \n> But not impossible.\nProve me wrong.\n> \n> > > \n> > > > > \n> > > > > Perhaps just process the hostnames first - would that work?\n> > > > Provided I do that, how do I know if something is a hostname or a device? \n> > > \n> > > If the name does not resolve as a host name, then assume it may be a device.\n> > \n> > You are adding significantly extra complexity here for a situation that\n> > probably doesn't happen. Over engineering backward compatibility.\n> \n> I disagree that any of the fixes I proposed would significantly increase the\n> complexity.\n> \n> > > Surely the Unix device is actually something like /dev/tun10, not just\n> > > \"tun10\" anyway?\n> > No, it's just tun10.\n> \n> So it does not exist under /dev?\n> \n> > I'm unconvinced that any of the hypothetical scenarios we mentioned here\n> > actually happen in real life. Even with pretty bad engineering paradigms.\n> \n> We disagree.\nProve me wrong then.\n> \n> The patch will not be accepted without changes to ensure:\n> - host names take precedence over device names\n> - the network devices are not searched unnecessarily\n\nIf the JMeter team prefers backward compatibility for hypothetical, unlikely, probably non-existent scenarios over innovation (which solves real world scenarios) then I think my work here is done.\n\nFeel free to close that bug.", "id": 169162, "time": "2013-08-06T03:37:28Z", "creator": "malkodan@gmail.com", "creation_time": "2013-08-06T03:37:28Z", "is_private": false}, {"count": 11, "tags": [], "bug_id": 54874, "attachment_id": null, "is_private": false, "id": 169168, "time": "2013-08-06T07:11:37Z", "creator": "p.mouawad@ubik-ingenierie.com", "creation_time": "2013-08-06T07:11:37Z", "text": "Backward compatibility is important, performance and reliability are also concerned here.\nThe initial patch introduces performance issue anyway so it cannot be integrated as is.\nAlso resolving host before device does not seems the best option to me.\n\nIn my opinion it should be a choice of user either with checkbox or with a jmeter property, introduce a Resolver interface and use could choose:\n- hostresolver\n- deviceresolver\n- ...\n\nAnyway it is not very kind to say we prefer backward compatibility to innovation, but I will remain silent and let new features talk."}, {"count": 12, "tags": [], "text": "URL: http://svn.apache.org/r1511542\nLog:\nSupport device in addition to source IP address\nBugzilla Id: 54874\n\nModified:\n    jmeter/trunk/src/protocol/http/org/apache/jmeter/protocol/http/sampler/HTTPAbstractImpl.java\n    jmeter/trunk/xdocs/changes.xml\n    jmeter/trunk/xdocs/usermanual/component_reference.xml", "is_private": false, "bug_id": 54874, "id": 169288, "time": "2013-08-07T23:56:52Z", "creator": "sebb@apache.org", "creation_time": "2013-08-07T23:56:52Z", "attachment_id": null}, {"count": 13, "tags": [], "bug_id": 54874, "attachment_id": null, "is_private": false, "id": 169303, "time": "2013-08-08T10:45:55Z", "creator": "sebb@apache.org", "creation_time": "2013-08-08T10:45:55Z", "text": "URL: http://svn.apache.org/r1511681\nLog:\nSupport device in addition to source IP address\nSupport choice of IPv4 or IPv6; report error if selected interface is not found\nBugzilla Id: 54874\n\nModified:\n    jmeter/trunk/src/protocol/http/org/apache/jmeter/protocol/http/sampler/HTTPAbstractImpl.java\n    jmeter/trunk/xdocs/usermanual/component_reference.xml"}, {"count": 14, "tags": [], "bug_id": 54874, "attachment_id": null, "text": "URL: http://svn.apache.org/r1513685\nLog:\nRe-organizes the Source Address options.\nChange the organization for \"Optional tasks\" in the HTTP Request (separating into 3 sub-blocks : Embedded resources, Source Address, Optional tasks)\nBugzilla Id: 54874\n\nModified:\n    jmeter/trunk/src/core/org/apache/jmeter/resources/messages.properties\n    jmeter/trunk/src/core/org/apache/jmeter/resources/messages_es.properties\n    jmeter/trunk/src/core/org/apache/jmeter/resources/messages_fr.properties\n    jmeter/trunk/src/protocol/http/org/apache/jmeter/protocol/http/control/gui/HttpTestSampleGui.java\n    jmeter/trunk/src/protocol/http/org/apache/jmeter/protocol/http/sampler/HTTPAbstractImpl.java\n    jmeter/trunk/src/protocol/http/org/apache/jmeter/protocol/http/sampler/HTTPSamplerBase.java\n    jmeter/trunk/xdocs/usermanual/component_reference.xml\n\n\nURL: http://svn.apache.org/r1513743\nLog:\nFix an issue with localization in Source Address Type list\nBugzilla Id: 54874\n\nModified:\n    jmeter/trunk/src/protocol/http/org/apache/jmeter/protocol/http/sampler/HTTPSamplerBase.java", "id": 169425, "time": "2013-08-14T07:07:53Z", "creator": "milamber@apache.org", "creation_time": "2013-08-14T07:07:53Z", "is_private": false}, {"count": 15, "tags": [], "bug_id": 54874, "attachment_id": null, "id": 169436, "time": "2013-08-14T13:20:39Z", "creator": "sebb@apache.org", "creation_time": "2013-08-14T13:20:39Z", "is_private": false, "text": "URL: http://svn.apache.org/r1513863\nLog:\nSupport device in addition to source IP address\nUse enum for source types; don't convert between index and name unnecessarily.\nBugzilla Id: 54874\n\nModified:\n    jmeter/trunk/src/protocol/http/org/apache/jmeter/protocol/http/control/gui/HttpTestSampleGui.java\n    jmeter/trunk/src/protocol/http/org/apache/jmeter/protocol/http/sampler/HTTPAbstractImpl.java\n    jmeter/trunk/src/protocol/http/org/apache/jmeter/protocol/http/sampler/HTTPSamplerBase.java"}]