[{"count": 0, "tags": [], "creator": "fslzdd@gmail.com", "text": "In class org.apache.tomcat.util.collections.SimplePool, current is a mutable field. In method put/get, current field is updated with a lock held. But in method getCount(), the access to current field is not protected by a lock. \n\nIn current Java memory model, the up-to-date current field value is not guaranteed to be seen in the absence of synchronization. So getCount() method can return a stale or inconsistent value, which results in undesired behavior.\n\nProposed solution:\n\npublic int getCount() {\n  int ret = 0;\n  synchronized (lock) {\n\tret = current+1;\n  }\n  return ret;\n}", "id": 139232, "time": "2010-08-19T04:59:42Z", "bug_id": 49778, "creation_time": "2010-08-19T04:59:42Z", "is_private": false, "attachment_id": null}, {"count": 1, "tags": [], "bug_id": 49778, "text": "(In reply to comment #0)\n> Proposed solution:\n> \n> public int getCount() {\n>   int ret = 0;\n>   synchronized (lock) {\n>     ret = current+1;\n>   }\n>   return ret;\n> }\n\nSuch a change is utterly useless.  Since the lock is dropped immediately after retrieving the value, the value may change well before any decisions can be made based on the value.  This is completely independent of the JVM memory model.\n\nIf you want to insure that getCount always retrieves the current value, the field must be flagged as volatile - but that does nothing to prevent it changing the moment after it has been referenced.\n\n - Chuck", "id": 139244, "time": "2010-08-19T08:54:53Z", "creator": "chuck.caldarale@unisys.com", "creation_time": "2010-08-19T08:54:53Z", "is_private": false, "attachment_id": null}, {"count": 2, "tags": [], "bug_id": 49778, "is_private": false, "text": "(In reply to comment #1)\n> Such a change is utterly useless.  \n\nNot true. \n\nThe synchronisation block ensures that the value read by the thread is the current value.\n\n> Since the lock is dropped immediately after\n> retrieving the value, the value may change well before any decisions can be\n> made based on the value.  This is completely independent of the JVM memory\n> model.\n\nTrue, but irrelevant here.\n \n> If you want to insure that getCount always retrieves the current value, the\n> field must be flagged as volatile \n\nNot strictly true.\n\nVolatile is _one_ way to ensure safe publication, but it is not the _only_ solution.\n\nSince the other accesses need to use synchronisation, it makes sense to use synchronisation here too.\n\n> - but that does nothing to prevent it\n> changing the moment after it has been referenced.\n\nAgain true, but irrelevant.", "id": 139265, "time": "2010-08-19T19:02:10Z", "creator": "sebb@apache.org", "creation_time": "2010-08-19T19:02:10Z", "attachment_id": null}, {"count": 3, "attachment_id": null, "bug_id": 49778, "is_private": false, "id": 139266, "time": "2010-08-19T19:11:53Z", "creator": "chuck.caldarale@unisys.com", "creation_time": "2010-08-19T19:11:53Z", "tags": [], "text": "(In reply to comment #2)\n>\n> > Since the lock is dropped immediately after retrieving \n> > the value, the value may change well before any decisions\n> > can be made based on the value.  This is completely \n> > independent of the JVM memory model.\n> \n> True, but irrelevant here.\n\nNo, it's pretty much the only relevant part.  If the value can change after retrieval but before usage, you still don't have the current value.  If decisions are to be made based on the value, the lock must be maintained across the retrieval and the decision.  If no decisions are to be made on the value, then it doesn't matter if it's current, since it could change at any time.\n\n> > If you want to insure that getCount always retrieves the \n> > current value, the field must be flagged as volatile \n> \n> Not strictly true.\n\nAgreed; \"must\" was too strong.  Flagging it as volatile is the least expensive way of insuring that the various compilers involved don't over-optimize the reference.  Using a synchronization block is more expensive (although much cheaper in current JVMs than it used to be).\n\n> Since the other accesses need to use synchronisation, it\n> makes sense to use synchronisation here too.\n\nNo, the other accesses are mutators; the reader of a simple value such as an int needs no synchronization - unless it's going to base some action on the value.\n\n> > - but that does nothing to prevent it\n> > changing the moment after it has been referenced.\n> \n> Again true, but irrelevant.\n\nNot at all irrelevant; the value retrieved is no longer current, which was your stated concern."}, {"count": 4, "tags": [], "bug_id": 49778, "text": "(In reply to comment #3)\n> (In reply to comment #2)\n> >\n> > > Since the lock is dropped immediately after retrieving \n> > > the value, the value may change well before any decisions\n> > > can be made based on the value.  This is completely \n> > > independent of the JVM memory model.\n> > \n> > True, but irrelevant here.\n> \n> No, it's pretty much the only relevant part.  If the value can change after\n> retrieval but before usage, you still don't have the current value.  If\n> decisions are to be made based on the value, the lock must be maintained across\n> the retrieval and the decision.  If no decisions are to be made on the value,\n> then it doesn't matter if it's current, since it could change at any time.\n\nWhat I meant was that it was irrelevant to the original bug report, which only pointed out that the value might be arbitrarily stale.\n\n> > > If you want to insure that getCount always retrieves the \n> > > current value, the field must be flagged as volatile \n> > \n> > Not strictly true.\n> \n> Agreed; \"must\" was too strong.  Flagging it as volatile is the least expensive\n> way of insuring that the various compilers involved don't over-optimize the\n> reference.  Using a synchronization block is more expensive (although much\n> cheaper in current JVMs than it used to be).\n\nNot necessarily the least expensive here. Adding volatile to the field affects all accesses, including the ones currently protected by synch. blocks.\n\n> > Since the other accesses need to use synchronisation, it\n> > makes sense to use synchronisation here too.\n> \n> No, the other accesses are mutators; the reader of a simple value such as an\n> int needs no synchronization - unless it's going to base some action on the\n> value.\n\nIf it is not going to use the value, why read it in the first place?\n\n> > > - but that does nothing to prevent it\n> > > changing the moment after it has been referenced.\n> > \n> > Again true, but irrelevant.\n> \n> Not at all irrelevant; the value retrieved is no longer current, which was your\n> stated concern.\n\nIt was not my bug report...\nAIUI the original author was only concerned that the value might be stale.\n\nFor example, if the count is to be displayed, it might not matter if the value is not 100% current, but it would matter if the value is arbitrarily stale.\n\nIf the current exact value is needed, then of course the code needs to be part of the synch. block unless it is somehow known that the value cannot be changed by other threads at that point.", "id": 139268, "time": "2010-08-19T19:39:28Z", "creator": "sebb@apache.org", "creation_time": "2010-08-19T19:39:28Z", "is_private": false, "attachment_id": null}, {"count": 5, "tags": [], "bug_id": 49778, "is_private": false, "text": "(In reply to comment #4)\n> (In reply to comment #3)\n> > (In reply to comment #2)\n> > >\n> > > > Since the lock is dropped immediately after retrieving \n> > > > the value, the value may change well before any decisions\n> > > > can be made based on the value.  This is completely \n> > > > independent of the JVM memory model.\n> > > \n> > > True, but irrelevant here.\n> > \n> > No, it's pretty much the only relevant part.  If the value can change after\n> > retrieval but before usage, you still don't have the current value.  If\n> > decisions are to be made based on the value, the lock must be maintained across\n> > the retrieval and the decision.  If no decisions are to be made on the value,\n> > then it doesn't matter if it's current, since it could change at any time.\n> \n> What I meant was that it was irrelevant to the original bug report, which only\n> pointed out that the value might be arbitrarily stale.\n> \n> > > > If you want to insure that getCount always retrieves the \n> > > > current value, the field must be flagged as volatile \n> > > \n> > > Not strictly true.\n> > \n> > Agreed; \"must\" was too strong.  Flagging it as volatile is the least expensive\n> > way of insuring that the various compilers involved don't over-optimize the\n> > reference.  Using a synchronization block is more expensive (although much\n> > cheaper in current JVMs than it used to be).\n> \n> Not necessarily the least expensive here. Adding volatile to the field affects\n> all accesses, including the ones currently protected by synch. blocks.\n> \n> > > Since the other accesses need to use synchronisation, it\n> > > makes sense to use synchronisation here too.\n> > \n> > No, the other accesses are mutators; the reader of a simple value such as an\n> > int needs no synchronization - unless it's going to base some action on the\n> > value.\n> \n> If it is not going to use the value, why read it in the first place?\n> \n> > > > - but that does nothing to prevent it\n> > > > changing the moment after it has been referenced.\n> > > \n> > > Again true, but irrelevant.\n> > \n> > Not at all irrelevant; the value retrieved is no longer current, which was your\n> > stated concern.\n> \n> It was not my bug report...\n> AIUI the original author was only concerned that the value might be stale.\n> \n> For example, if the count is to be displayed, it might not matter if the value\n> is not 100% current, but it would matter if the value is arbitrarily stale.\n> \n> If the current exact value is needed, then of course the code needs to be part\n> of the synch. block unless it is somehow known that the value cannot be changed\n> by other threads at that point.\n\nSebb totally understands my willing. This bug report is only about reading current field without holding a lock can return a stale or inconsistent value, even for integer. Whether the future usage after retrieval can see the update-to-date value is not my concern of this bug report.", "id": 139280, "time": "2010-08-20T08:05:04Z", "creator": "fslzdd@gmail.com", "creation_time": "2010-08-20T08:05:04Z", "attachment_id": null}, {"attachment_id": null, "tags": [], "bug_id": 49778, "text": "The class is deprecated an is not used anywhere.\n\nNote: It has been removed in Tomcat 7", "count": 6, "id": 139427, "time": "2010-08-24T17:47:52Z", "creator": "markt@apache.org", "creation_time": "2010-08-24T17:47:52Z", "is_private": false}]