[{"count": 0, "tags": [], "text": "This is regarding jdbc connection and tyrex transaction manager. \nWhen I start the transaction and whenever i get a connection from the \ndatasource in the same thread from the same method, data source gives me new \nconnection always. If I start a transaction and calls get connection from the \nsame datasource with in the same thread, it should not give the new connection. \nFor example, if I get a connection and after I am done with it, I call close \nconnection. In the next method call(transaction is not over yet), If I call the \nget connection then also it should give me the same physical connection as the \nprevious one(sothat I can do the dirty read).", "is_private": false, "bug_id": 7640, "id": 12566, "time": "2002-03-31T07:44:41Z", "creator": "nmurthy@etouch.net", "creation_time": "2002-03-31T07:44:41Z", "attachment_id": null}, {"count": 1, "tags": [], "bug_id": 7640, "attachment_id": null, "text": "I don't agree with your suggested behavior.  IMHO, closing the allocated\nconnection (which really just returns it to the pool) should roll back any\ncurrent transaction that is in progress.  If you want to maintain the\ntransaction, you should hold on to the connection it was started with and\ncontinue to use it.\n", "id": 14153, "time": "2002-04-21T02:23:38Z", "creator": "craig.mcclanahan@sun.com", "creation_time": "2002-04-21T02:23:38Z", "is_private": false}, {"count": 2, "tags": [], "text": "I don't agree with your comments. In distributed environment, this is not the \ncase. If you take transaction manager of any application server like websphere, \nweblogic etc.. they behave the following way. \n1-start the transaction, getconnection from datasource1 in object1. object1 \nwrote some data to the datasource1. \n2-getconnection from the same datasource1 in object2(physically object2 can be \nrunning in another machine, so it is not feasible to pass the same connection \nobject) returns another connection, but internal connection object that is \ndatabase specific jdbc connection object will be same. \n3-now object2 can read the data written by object1(this ditry read is only \npossible if the internal database connection object is same). \n3. object2 closes the logical connection. object2 returns\n4. object1 closes the logical connection \n5. object1 commits the transaction. \n\nThis behaviour works in the above said transaction managers/app servers. \nIt works even if we close the object1 connection in the step 1 it self(instead \nof step 4). \n\nBut it doesn't work in tyrex/tomcat. \n\nthank you", "is_private": false, "bug_id": 7640, "id": 14186, "time": "2002-04-21T17:38:20Z", "creator": "nmurthy@etouch.net", "creation_time": "2002-04-21T17:38:20Z", "attachment_id": null}, {"count": 3, "tags": [], "text": "This is a Tyrex problem, not a Tomcat problem, so it won't be fixed (at least \nnot by Tomcat).", "is_private": false, "bug_id": 7640, "id": 14316, "time": "2002-04-22T13:46:27Z", "creator": "remm@apache.org", "creation_time": "2002-04-22T13:46:27Z", "attachment_id": null}]