[{"attachment_id": null, "tags": [], "bug_id": 55985, "text": "Since we want to use different \"postrotate\" scripts for different CustomLogs, we configure lgrotate with 3 different sections, one for each \"type\" of log file. Since none of the sections is guaranteed to run every time, each has its own call to apachectl graceful. Sometimes, this causes multiple calls to apachectl graceful within the same second, which in turn sometimes results in httpd not reopening the access logs. This is usually fixed by manually performing an apachectl graceful at a later time, but httpd may just as well continue to write to the same (deleted) access_log.1 for multiple days. This results in log data that never gets analyzed or can result in the /var partition filling up.\n\nI was able to reproduce this behaviour by running ab, a loop that just does graceful restarts every 5 seconds, and a second loop that uses lsof to find deleted files opened by httpd processes and forces logrotate to run for the single configured transfer log. I only have a single virtualhost configured, and ab is requesting a small static file.\n\nbin/ab -n 999999 -c 4 -t 10000 http://testserver:10106/favicon.ico\n\nfor i in {1..1000}; do \n   echo $i; \n   lsof |grep httpd |grep deleted | egrep -v 'ssl_mutex'; \n   echo; \n   logrotate  -f logrotate.conf ; \n   j=0; \n   while lsof |grep httpd |grep deleted | egrep -v 'ssl_mutex'; do \n      echo ====== $j ======; sleep 1; j=$[ $j + 1 ]; \n   done; \ndone\n\nwhile true; do apachectl graceful; sleep 5; done\n\nI've tried httpd 2.2.22, 2.2.24 and 2.2.26 on debian Wheezy (i686), RHEL 6.5 x86_64 and SLES 11 SP2 x86_64, all of which show the described behavior. The deleted access_log.1 is used even by children forked after the previous ones have exceeded their MaxRequestsPerChild.\n \nhttpd  -t -D DUMP_MODULES\nLoaded Modules:\n core_module (static)\n authn_file_module (static)\n authn_default_module (static)\n authz_host_module (static)\n authz_groupfile_module (static)\n authz_user_module (static)\n authz_default_module (static)\n auth_basic_module (static)\n cache_module (static)\n disk_cache_module (static)\n mem_cache_module (static)\n include_module (static)\n filter_module (static)\n deflate_module (static)\n log_config_module (static)\n log_forensic_module (static)\n logio_module (static)\n env_module (static)\n expires_module (static)\n headers_module (static)\n unique_id_module (static)\n setenvif_module (static)\n version_module (static)\n proxy_module (static)\n proxy_connect_module (static)\n proxy_ftp_module (static)\n proxy_http_module (static)\n proxy_scgi_module (static)\n proxy_ajp_module (static)\n proxy_balancer_module (static)\n ssl_module (static)\n mpm_prefork_module (static)\n http_module (static)\n mime_module (static)\n dav_module (static)\n status_module (static)\n autoindex_module (static)\n asis_module (static)\n cgi_module (static)\n dav_fs_module (static)\n dav_lock_module (static)\n vhost_alias_module (static)\n negotiation_module (static)\n dir_module (static)\n actions_module (static)\n userdir_module (static)\n alias_module (static)\n rewrite_module (static)\n so_module (static)\nSyntax OK\n\nthe logrotate.conf used:\n\nlogs/access_log {\n        su rainer rainer\n\tcompress\n\tnodelaycompress\n\tcompresscmd /bin/bzip2\n\tcompressext .bz2\n\tcreate 644 rainer rainer\n\tsharedscripts\n\tpostrotate\n\t\tbin/apachectl graceful\n\tendscript\n}", "count": 0, "id": 172270, "time": "2014-01-10T15:39:03Z", "creator": "rainer-apache@7val.com", "creation_time": "2014-01-10T15:39:03Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 55985, "attachment_id": null, "is_private": false, "id": 172272, "time": "2014-01-10T16:01:39Z", "creator": "covener@gmail.com", "creation_time": "2014-01-10T16:01:39Z", "text": "> I've tried httpd 2.2.22, 2.2.24 and 2.2.26 on debian Wheezy (i686), RHEL 6.5\n> x86_64 and SLES 11 SP2 x86_64, all of which show the described behavior. The\n> deleted access_log.1 is used even by children forked after the previous ones\n> have exceeded their MaxRequestsPerChild.\n\nLogs are opened in the parent, not in the children.  New children cannot be expected to reopen logs that have been deleted out from under them, this requires at least a graceful restart.\n\nBased on these comments, tt sounds like in some way you may know that a graceful does not always follow your unlink, so I am marking as invalid."}, {"attachment_id": null, "tags": [], "bug_id": 55985, "text": "Can you explain why the loop \n\nwhile true; do apachectl graceful; sleep 5; done\n\nis required to trigger this behaviour if there's only one apachectl graceful in the logrotate config, or, alternatively the logrotate must have multiple sections with one apachectl graceful in each section to causes the described behaviour?", "count": 2, "id": 172273, "time": "2014-01-10T16:58:20Z", "creator": "rainer-apache@7val.com", "creation_time": "2014-01-10T16:58:20Z", "is_private": false}, {"count": 3, "tags": [], "creator": "covener@gmail.com", "text": "> Can you explain why the loop \n> \n> while true; do apachectl graceful; sleep 5; done\n> \n> is required to trigger this behaviour if there's only one apachectl graceful\n> in the logrotate config, or, alternatively the logrotate must have multiple\n> sections with one apachectl graceful in each section to causes the described\n> behaviour?\n\nI assume there are windows where nearly simulataneous gracefuls happen don't \"stack\", and that somehow leads to you unlinking without a graceful being processed after. But i don't think there is a remedy in httpd.", "id": 172274, "time": "2014-01-10T17:29:47Z", "bug_id": 55985, "creation_time": "2014-01-10T17:29:47Z", "is_private": false, "attachment_id": null}, {"attachment_id": null, "tags": [], "bug_id": 55985, "is_private": false, "count": 4, "id": 172275, "time": "2014-01-10T17:46:09Z", "creator": "rainer-apache@7val.com", "creation_time": "2014-01-10T17:46:09Z", "text": "I think the fact that just running logrotate -f with a single section over and over again does not cause the problem to happen, as opposed to doing the same and running a separate loop with just apachectl graceful and sleep, is a clear indicator that logrotate is not at fault."}]