[{"count": 0, "tags": [], "bug_id": 10418, "attachment_id": null, "text": "[ This applies to current 4.1 CVS as well ] \nThe logic to determine whether a URL needs to be encoded in  \nHttpServletResponse.encodeURL() is broken. In  \nHttpServletResponseBase.isEncodeable(String location), it  \ndecides, that the URL needn't be encoded in the URL, if the  \ncurrent ID comes from the cookie; see code-snippet from  \nHttpServletResponseBase:  \n-------  \n    if (hreq.isRequestedSessionIdFromCookie()) {  \n        return (false);  \n    }  \n------  \n  \nHowever, this does not take into account, that the session ID we got  \nmight have been from some previous session that already is invalidated,  \ni.e. is not valid. In this case isRequestedSessionIdFromCookie() will  \nreturn true, but this does not say anything if future (valid) sessions  \nwill come through the cookie.  \n  \nThe fix is easy: So the only way to check this correctly is:  \n---------  \n   if (hreq.isRequestedSessionIdFromCookie()  \n       && hreq.isRequestedSessionIdValid()) {  \n     return (false);  \n   }  \n---------", "id": 18860, "time": "2002-07-02T17:03:01Z", "creator": "H.Zeller@acm.org", "creation_time": "2002-07-02T17:03:01Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 10418, "text": "I do not agree with this. If the client continues to submit the session id, then\nthat means he's still using the same user-agent. So unless we're in the unlikely\nevent that he disables cookies in the middle without ending his user agent\nsession, nothing bad should happen.\n\nI'm -1 for this patch anyway, as hreq.isRequestedSessionIdValid() is an\nexpensive methos call.", "id": 18919, "time": "2002-07-03T07:55:00Z", "creator": "remm@apache.org", "creation_time": "2002-07-03T07:55:00Z", "is_private": false, "attachment_id": null}, {"count": 2, "attachment_id": null, "bug_id": 10418, "text": "First of all: The paramount should be _not_ to loose a session in any case. \nSecond: It doesn't help, that the client sends _some_ session id; we only can  \n   decide that the current session id does not need to be encoded, if it sends \n  _our_ session id. So, you the call isRequestedSessionIdValid() can be \n  replaced by a simple string comparison  \n  session.getId().equals(hreq.getRequestedSessionId()). Thats cheap and still \n  the correct behaviour. \nThird: Anyway, I'd suggest to cache the result of isEncodable() anyway so \n       that we don't have to go through the relative expensive chain of \n       conditions anytime we call encodeURL() -- there can be many of them \n       in applications. \n \nBottomline: fixing this problem is a cheap operation (String.equals()). And \n            caching can enhance this even further. \n   ", "id": 18928, "time": "2002-07-03T08:50:59Z", "creator": "H.Zeller@acm.org", "creation_time": "2002-07-03T08:50:59Z", "tags": [], "is_private": false}, {"count": 3, "tags": [], "bug_id": 10418, "text": "Having reviewed this bug report, I am setting it back to WONTFIX. This report \nraises a number of issues and these are summarised below along with an \nexplanation as to why it is WONTFIX.\n\nThe report raises a number issues.\n1. hreq.isRequestedSessionIdFromCookie() is an insufficient test.\nSee Remy's comment - 2002-07-03 07:55.\n\n2. Client sends some other session ID rather than our session ID.\nThis requires the client to deliberately modify the session ID. In this case \nthe session is lost anyway.\n\n3. Caching the result of isEncodable().\nThis is only useful if the same url needs to be encoded multiple times within \nthe same response. I am not yet convinced that enhancing the existing \nfunctionality with a cache is worth the effort.\n\nI am prepared to be convinced that 3 is worth doing. In this case, feel free \nto reopen the report as an enhancement request including the justification.", "id": 49994, "attachment_id": null, "creator": "medthomas@ntlworld.com", "creation_time": "2004-01-03T18:40:19Z", "time": "2004-01-03T18:40:19Z", "is_private": false}, {"count": 4, "tags": [], "bug_id": 10418, "attachment_id": null, "text": "Since the original SessionBugDemonstration hasn't been reachable, I've moved \nit to \n   http://vicdor.org/~hzeller/SessionBugDemonstration.java \n \nPlease note, that this Bug is also related to #10419; problems with faulty \nclients like IE that may as well send invalid session IDs in cookies (see \ncomments there) could be effectively thwarted if tomcat would choose to encode \nURLs in that case. \n \nI still think that the behaviour is faulty and it is still not fixed. The \n_requested_ session ID is an ID that comes from the client and might not \nnecessarily be a valid ID (the browser continues to send cookies as long as it \nis not shutdown). So consider a web application that has a cookie that timed \nout. \nLater the user chooses to not accept any new cookies and enters the web \napplication again. \n \nSo this is not 'in the middle' of something that cookies are disabled (as Remy \nMaucherat states in comment at 2002-07-03 07:55) but between two usages of the \nsame application. \n \nThe web application creates a new session but gets a 'requested' session ID \nfrom the old cookie still lying around .. and chooses not to encode URLs based \non that fact -- even though the session-ID it got has nothing to do with the \nsession ID newly created. However, since the URLs are not encoded and the \nbrowser does not accept the new cookie, the application will simply not work \nbecause it will never see its newly creates session id again. \n \nAs long as the application has not received the _first valid_ cookie from the \nbrowser it must encode its URLs. Every application should (conservativly) \nstart encoding its URLs until it knows that it gets the session ID from the \ncookie; ITS session id, not SOME. \n \nRight now, tomcat optimistically assumes that if there is _some_ \nJSESSIONID-cookie then everything will go fine.. \n \nI had to do several workarounds in different applications already because of \nthis \n(like \nhttp://cvs.sourceforge.net/viewcvs.py/j-wings/wings/src/org/wings/session/SessionServlet.java?annotate=1.25#385 \n) \nAs application developer you often stumble over this bug when you actually \ntest your application if it works with cookies enabled and disabled -- you've \nto restart your browser everytime you invalidate a session ... \nOr if you don't restart your browser that often but use it for weeks (ok, this \nis probably unlikely on windows but on Un*x I do this all the time :-) \n \nSince there is no comment that explains that this is _not_ a bug and since \nthis bug actually requires to do workarounds at the application level (see \nabove), I'll reopen it again. \nIf you think, the solution I provided is to expensive I'll dig through the \nsources again and find another one. ", "id": 51895, "time": "2004-02-07T21:27:14Z", "creator": "H.Zeller@acm.org", "creation_time": "2004-02-07T21:27:14Z", "is_private": false}, {"count": 5, "tags": [], "bug_id": 10418, "text": "I don't agree with this: if the client submits a cookie, then Tomcat will send\nback a cookie. Please do not reopen this.", "id": 51901, "attachment_id": null, "creator": "remm@apache.org", "creation_time": "2004-02-08T10:39:20Z", "time": "2004-02-08T10:39:20Z", "is_private": false}]