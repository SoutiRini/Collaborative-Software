[{"count": 0, "text": "Created attachment 22298\nA suggested fix and a test to verify\n\nTake a look at the following lines from the apr_thread_rwlock_unlock() (trunk/locks/win32/thread_rwlock.c):\n \n...\n146 :\t \t\t/* Nope, we must have a read lock */ \t\n147 :\t  \t  \t if (rwlock->readers && \t\n148 :\t  \t  \t \t! InterlockedDecrement(&rwlock->readers) && \t\n149 :\t  \t  \t \t! SetEvent(rwlock->read_event)) { \t\n....\n \nNotice that no mutex is taken during apr_thread_rwlock_unlock().\n \nNow, consider a single reader is performing an unlock, called InterlockedDecrement() on line 148, received 0 as a result of InterlockedDecrement, and a context switch now happens right before the call to SetEvent() in line 149.\n \nNow, let's say that right after the context switch another thread tries to take the read-lock. Here's the implementation of apr_thread_rwlock_rdlock_core():\n\n... \n65 :\t \t\tDWORD code = WaitForSingleObject(rwlock->write_mutex, milliseconds); \t\n66 :\t  \t  \t \t\n67 :\t  \t  \t if (code == WAIT_FAILED || code == WAIT_TIMEOUT) \t\n68 :\t  \t  \t return APR_FROM_OS_ERROR(code); \t\n69 :\t  \t  \t \t\n70 :\t  \t  \t /* We've successfully acquired the writer mutex, we can't be locked \t\n71 :\t  \t  \t * for write, so it's OK to add the reader lock. The writer mutex \t\n72 :\t  \t  \t * doubles as race condition protection for the readers counter. \t\n73 :\t  \t  \t */ \t\n74 :\t  \t  \t InterlockedIncrement(&rwlock->readers); \t\n75 :\t  \t  \t \t\n76 :\t  \t  \t if (! ResetEvent(rwlock->read_event)) \t\n77 :\t \t\t\treturn apr_get_os_error(); \t\n78 :\n79 :\t  \t  \t if (! ReleaseMutex(rwlock->write_mutex)) \t\n80 :\t \t \t\treturn apr_get_os_error(); \t\n81 :\n82 :\t \t \treturn APR_SUCCESS; \t\n ...\n\nAfter this thread is done taking the lock, the readers counter is equal to 1, and the read_event is RESET.\nNow, the system might context-switch back to the original thread doing an unlock operation (at line 149) which will, unfortunately, SET the event.\n \nIf you've followed me so far, we've reached a situation where one thread has the read-lock, the readers count is equal to 1 but the read_event is SET.\n \nNow, if any thread will try to acquire a writer's lock, it will SUCCEED, and not wait for the reader thread to release its reader-lock.\n \nAs you can see - this is a race between two readers, which allows a writer to take the lock while a reader has it.\nThe comment in lines 71-72 is mesleading and isn't true.\n \nAs far as I can see, this issue was introduced 5 years ago, seen on revision 64541, and is part of all APR versions since 0.9.4.\nAttached is my suggestion for a fix for this issue, as well as an addition to the rwlock test which should cause the issue (if you're [un]lucky enough).", "creator": "rbarkan@websense.com", "attachment_id": 22298, "id": 118901, "time": "2008-07-22T03:37:37Z", "bug_id": 45455, "creation_time": "2008-07-22T03:37:37Z", "tags": [], "is_private": false}]