[{"count": 0, "tags": [], "creator": "scutvick@hotmail.com", "attachment_id": null, "text": "<?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?>\n<document>\n<properties>\n<title>Workers HowTo</title>\n<author email=\"hgomez@apache.org\">Henri Gomez</author>\n<author email=\"shachor@il.ibm.com\">Gal Shachor</author>\n<date>$Date$</date>\n</properties>\n\n<section name=\"Introduction\">\n<p>\nA Tomcat worker is a Tomcat instance that is waiting to execute servlets on \nbehalf of some web server. \nFor example, we can have a web server such as Apache forwarding servlet \nrequests to a \nTomcat process (the worker) running behind it.\n</p>\n<p>\nThe scenario described above is a very simple one; \nin fact one can configure multiple Tomcat workers to serve servlets on \nbehalf of a certain web server. \nThe reasons for such configuration can be:\n</p>\n<ul>\n<li>\nWe want different contexts to be served by different Tomcat workers to provide \na \ndevelopment environment where all the developers share the same web server but \nown a Tomcat worker of their own.\n</li>\n<li>\nWe want different virtual hosts served by different Tomcat processes to provide \na \nclear separation between sites belonging to different companies.\n</li>\n<li>\nWe want to provide load balancing, meaning run multiple Tomcat workers each on \na \nmachine of its own and distribute the requests between them.\n</li>\n</ul>\n\n<p>\nThere are probably more reasons for having multiple workers but I guess that \nthis list is enough...\nTomcat workers are defined in a properties file dubbed workers.properties and \nthis tutorial \nexplains how to work with it.\n</p>\n\n<p>\nThis document was originally part of <b>Tomcat: A Minimalistic User's Guide</b> \nwritten by Gal Shachor, \nbut has been split off for organizational reasons. \n</p>\n</section>\n\n<section name=\"Defining Workers\">\n<p>\nDefining workers for the Tomcat web server plugin can be done using a \nproperties file \n(a sample file named workers.properties is available in the conf/ directory).\n</p>\n\n<p>\nThe file contains entries of the following form:\n</p>\n\n<p>\n<b>worker.list</b>=&lt;a comma separated list of worker names&gt;\n</p>\n\n<screen>\n<note>the list of workers</note>\n<read>worker.list= worker1, worker2</read>\n</screen>\n\n<p>\nWhen starting up, the web server plugin will instantiate the workers whose \nnames appear in the \n<b>worker.list</b> property, these are the workers to which you can map \nrequests.\n</p>\n\n<subsection name=\"Workers Type\">\n<p>\nEach named worker should also have a few entries to provide additional \ninformation on its behalf.\nThis information includes the worker's type and other related worker \ninformation. \nCurrently the following worker types exist (JK 1.2.1):\n</p>\n\n<table>\n  <tr><th>Type</th><th>Description</th></tr>\n  <tr><td>ajp12</td><td>This worker knows how to forward requests to out-of-\nprocess Tomcat workers using the ajpv12 protocol.</td></tr>\n  <tr><td>ajp13</td><td>This worker knows how to forward requests to out-of-\nprocess Tomcat workers using the ajpv13 protocol.</td></tr>\n  <tr><td>jni</td><td>This worker knows how to forward requests to in-process \nTomcat workers using JNI.</td></tr>\n  <tr><td>lb</td><td>This is a load-balancing worker; it knows how to provide \nround-robin based sticky load balancing with a certain level of fault-\ntolerance.</td></tr>\n</table>\n\n<p>\nDefining workers of a certain type should be done with the following property \nformat:\n</p>\n\n<p>\n<b>worker</b>. <b>worker name</b>.<b>type</b>=&lt;worker type&gt;\nWhere worker name is the name assigned to the worker and the worker type is one \nof the four types defined \nin the table below (a worker name may not contain spaces, a good naming \nconvention to follow \nwould be the Java variable naming rules).\n</p>\n\n<screen>\n<note>Defines a worker named \"local\" that uses the ajpv12 protocol to forward \nrequests to a Tomcat process.</note>\n<read>worker.local.type=ajp12</read>\n<note>Defines a worker named \"remote\" that uses the ajpv13 protocol to forward \nrequests to a Tomcat process.</note>\n<read>worker.remote.type=ajp13</read>\n<note>Defines a worker named \"fast\" that uses JNI to forward requests to a \nTomcat process.</note>\n<read>worker.fast.type=jni</read>\n<note>Defines a worker named \"loadbalancer\" that loadbalances several Tomcat \nprocesses transparently.</note>\n<read>worker.loadbalancer.type=lb</read>\n</screen>\n\n</subsection>\n\n</section>\n\n<section name=\"Setting Worker Properties\">\n<p>\nAfter defining the workers you can also specify properties for them. \nProperties can be specified in the following manner:\n</p>\n\n<p>\nworker.&lt;worker name&gt;.&lt;property&gt;=&lt;property value&gt;\n</p>\n\nEach worker has a set of properties that you can set as specified in the \nfollowing subsections:\n\n<subsection name=\"ajp12 Worker properties\">\n<p>\nThe ajp12 workers forward requests to out-of-process Tomcat workers \nusing the ajpv12 protocol over TCP/IP sockets.\n</p>\n\n<p>\nthe ajp12 worker properties are :\n</p>\n\n<p>\n<b>host</b> Sets the host where the Tomcat worker is listening for ajp12 \nrequests.\n</p>\n\n<p>\n<b>port</b> Sets the port where the Tomcat worker is listening for ajp12 \nrequests.\n</p>\n\n<p>\n<b>lbfactor</b> Used when working with a load balancer worker, this is the load-\nbalancing factor for the worker.\nWe'll see more on this in the lb worker section.\n</p>\n\n<screen>\n<note>worker \"worker1\" will talk to Tomcat listening on machine www.x.com at \nport 8007 using 2.5 lb factor</note>\n<read>worker.worker1.host=www.x.com</read>\n<read>worker.worker1.port=8007</read>\n<read>worker.worker1.lbfactor=2.5</read>\n</screen>\n\n<p>\nNotes: In the ajpv12 protocol, connections are created, used and then closed \nfor each request.\nThe default port for ajp12 is 8007.\n</p>\n\n</subsection>\n\n<subsection name=\"ajp13 Worker properties\">\n<p>\nThe ajp13 typed workers forward requests to out-of-process Tomcat workers using \nthe ajpv13 protocol over TCP/IP sockets.\nThe main differences between ajpv12 and ajpv13 are:\n<ul>\n<li>\najpv13 is a more binary protocol and it tries to compress some of the request \ndata by coding \nfrequently used strings as small integers.\n</li>\n<li>\najpv13 reuses open sockets and leaves them open for future requests (remember \nwhen you've got a Firewall between your \nweb server and Tomcat).\n</li>\n<li>\najpv13 has special treatment for SSL information so that the container can \nimplement \nSSL related methods such as isSecure().\n</li>\n</ul>\n\n</p>\n\n<p>\nYou should note that Ajp13 is now the only out-process protocol supported by \nTomcat 4.0.x, 4.1.x and 5.\n</p>\n\n<p>\nThe following table specifies properties that the ajp13 worker can accept:\n</p>\n\n\n<p>\n<b>host</b> Sets the host where the Tomcat worker is listening for ajp13 \nrequests.\n</p>\n\n<p>\n<b>port</b> Sets the port where the Tomcat worker is listening for ajp13 \nrequests.\n</p>\n\n<p>\n<b>lbfactor</b> Used when working with a load balancer worker, this is the load-\nbalancing factor for the worker.\nWe'll see more on this in the lb worker section.\n</p>\n\n<p>\n<b>cachesize</b> property is useful when you're using JK in multithreaded \nweb servers such as Apache 2.0, IIS and Netscape. They will benefit the most by \nsetting this value to a higher level (such as the estimated average number of \nconcurrent users for Tomcat).\n</p>\n\n<p>\n<b>cache_timeout</b> Should be used with <b>cachesize</b> to specify how long \nJK should keep\nan open socket in cache before closing it. This property should be used to \nreduce the number of threads \non the Tomcat web server.\n</p>\n\n<p>\nYou should note that under heavy load some web servers, for example Apache, \ncreate many children/threads\nto handle the load and they destroy the children/threads only when the load \ndecreases.\n</p>\n\n<p> \nEach child could open an ajp13 connection if it has to forward a request to \nTomcat, creating\na new ajp13 thread on Tomcat side.\n</p>\n\n<p>\nThe problem is that after an ajp13 connection is created, the child won't drop \nit\nuntil killed. And since the web server will keep its children/threads running\nto handle high load, even if the children/threads handle only static contents, \nyou could\nend up having many unused ajp13 threads on the Tomcat side.\n</p>\n\n<p>\n<b>socket_keepalive</b> Should be used when you have a firewall between your \nweb server\nand the Tomcat engine which tends to drop inactive connections. This flag will \ntell the operating system\nto send <code>KEEP_ALIVE</code> messages on inactive connections (the interval \ndepends on global OS settings,\ngenerally 120 minutes), and thus prevent the firewall from cutting the \nconnection.\n</p>\n\n<p>\nThe problem with a firewall cutting inactive connections is that sometimes, \nneither webserver or tomcat\nhave know about the cut and can't handle it.\n</p>\n\n<p>\n<b>socket_timeout</b> Tells the web server to cut an ajp13 connection after \nsome time of \ninactivity. Open sockets will be closed if not used within the configured time.\nIt's a good way to ensure that there won't be too many old threads living on \nTomcat side, \nwith the extra cost that you must reopen the socket the next time a request is \nforwarded.\nThis property is very similar to <b>cache_timeout</b> but also works in non-\ncache mode.\n</p>\n\n<screen>\n<note>worker \"worker2\" will talk to Tomcat listening on machine www2.x.com at \nport 8009 using 3.5 lb factor</note>\n<read>worker.worker2.host=www2.x.com</read>\n<read>worker.worker2.port=8009</read>\n<read>worker.worker2.lbfactor=3.5</read>\n<note>worker \"worker2\" will use up to 10 sockets, which will stay no more than \n10 minutes in the cache</note>\n<read>worker.worker2.cachesize=10</read>\n<read>worker.worker2.cache_timeout=600</read>\n<note>worker \"worker2\" asks the operating system to send KEEP-ALIVE signals on \nthe connection</note>\n<read>worker.worker2.socket_keepalive=1</read>\n<note>worker \"worker2\" wants ajp13 connections to be dropped after 5 minutes \n(timeout)</note>\n<read>worker.worker2.socket_timeout=300</read>\n</screen>\n\n<p>\nNotes: In the ajpv13 protocol, the default port is 8009.\n</p>\n\n</subsection>\n\n<subsection name=\"lb Worker properties\">\n<p>\nThe load-balancing worker does not really communicate with Tomcat workers.\nInstead it is responsible for the management of several \"real\" workers. \nThis management includes:\n</p>\n\n<ul>\n<li>\nInstantiating the workers in the web server.\n</li>\n<li>\nUsing the worker's load-balancing factor, perform weighted-round-robin load \nbalancing where \nhigh lbfactor indicates a faster machine (that is going to handle more requests)\n</li>\n<li>\nKeeping requests belonging to the same session executing on the same Tomcat \nworker.\n</li>\n<li>\nIdentifying failed Tomcat workers, suspending requests to them and instead \nfalling back on \nother workers managed by the lb worker.\n</li>\n</ul>\n\n<p>\nThe overall result is that workers managed by the same lb worker are load-\nbalanced (based on their lbfactor and current user session) and also fault \ntolerant so a single Tomcat process death will not \"kill\" the entire site.\nThe following table specifies properties that the lb worker can accept:\n<ul>\n<li><b>balanced_workers</b> is a comma separated list of workers that the load \nbalancer needs to manage. \nThese workers should not appear in the worker.list property.</li>\n<li><b>sticky_session</b> specifies whether requests with SESSION ID's should \nbe routed back to the same\nTomcat worker. If sticky_session is an int and is not 0 it is set to JK_TRUE \nand sessions are sticky, otherwise\nsticky_session is set to false. Set sticky_session to JK_FALSE when Tomcat is \nusing a Session Manager which\ncan persist session data across multiple instances of Tomcat. By default \nsticky_session is set to JK_TRUE.</li>\n</ul>\n</p>\n\n<screen>\n<note> The worker balance1 will use \"real\" workers worker1 and worker2</note>\n<read>worker.balance1.balanced_workers=worker1, worker2</read>\n</screen>\n\n</subsection>\n\n<subsection name=\"Advanced lb Worker properties\">\n<p>\nWith JK 1.2.x, new load-balancing and fault tolerant support has been added via\n2 new properties, <b>local_worker_only</b> and <b>local_worker</b>.\n</p>\n\n<p>\nLet's take an example environment:\n</p>\n\n<p>\nA cluster with two nodes (worker1+worker2), running a webserver + tomcat tandem \non each node and \na loadbalancer in front of the nodes.\n</p>\n\n<screen>\n<note>The advanced router LB worker</note>\n<read>worker.list=router</read>\n<note># Define a 'local_worker' worker using ajp13</note>\n<read>worker.worker1.port=8009</read>\n<read>worker.worker1.host=node1.domain.org</read>\n<read>worker.worker1.type=ajp13</read>\n<read>worker.worker1.lbfactor=1</read>\n<read>worker.worker1.local_worker=1</read>\n<note># Define another 'local_worker' worker using ajp13</note>\n<read>worker.worker2.port=8009</read>\n<read>worker.worker2.host=node2.domain.org</read>\n<read>worker.worker2.type=ajp13</read>\n<read>worker.worker2.lbfactor=1</read>\n<read>worker.worker2.local_worker=0</read>\n<note># Define the LB worker</note>\n<read>worker.router.type=lb</read>\n<read>worker.router.balanced_workers=worker1,worker2</read>\n<read>worker.router.local_worker_only=1</read>\n</screen>\n\n<p>\nThe <b>local_worker</b> flag on worker1 and worker2 tells the <b>lb_worker</b> \nwhich connections are going \nto the local worker. \n</p>\n\n<p>\nIf local_worker is an int and is not 0 it is set to JK_TRUE and marked as local \nworker, JK_FALSE otherwise. \nIf at least one worker is marked as local worker, lb_worker is in local worker \nmode. \nAll local workers are moved to the beginning of the internal worker list in \nlb_worker during validation.\n</p>\n\n<p>\nThis means that if a request with a session id comes in it would be routed to \nthe appropriate worker. \nIf this worker is down it will be sent to the first local worker which is not \nin an error state.\n</p>\n\n<p>\nIf a request without a session comes in, it would be routed to the first local \nworker. \nIf all local workers are in an error state, then the 'local_worker_only' flag \nis important. \nIf it is set to an int which is not 0, it is set to JK_TRUE, JK_FALSE \notherwise. When set to JK_TRUE, this request gets an error response. If set to \nJK_FALSE lb_worker tries to route the request to another load balanced worker.\n</p>\n\n<p>\nIf one of the worker was in an error state and has recovered, nothing changes. \nThe local worker will be checked for requests without a session id (and with a \nsession on himself) and \nthe other worker will only be checked if a request with a session id of this \nworker comes in.\n</p>\n\n<p>\nWhy do we need such complex behavior?\n</p>\n\n<p>\nWe need a graceful shut down of a node for maintenance. The balancer in front \npolls a special port on each \nnode periodically. If we want to remove a node from the cluster, we switch off \nthis port. \nThe loadbalancer can't connect to it and marks the node as down. \nBut we don't move the sessions to another node. In this environment it is an \nerror if the balancer sends a request without a session to an \napache+mod_jk+tomcat whose port is switched off. And if the load balancer \ndetermines that a node is down, no other node is allowed to send a request \nwithout a session to it. Only requests with old sessions on the switched off \nnode would be routed to this node. If after some time nobody uses the old \nsessions, they will time out. Then nobody can use this node because all its \nsessions are gone and the node is unreachable without a session-id in the \nrequest. If someone uses a session which is timed out, our servlet system sends \na redirect response without a session id to the browser. This is necessary \nbecause on a switched-off node apache and tomcat can still be up and running, \nbut they are in an old state and should only be asked for valid old sessions. \nAfter the last session times out, I could update the node, etc., without \nkilling sessions or moving them to another node. Sometimes we have a lot of big \nobjects in our sessions, so it would be really time consuming to move them.\n</p>\n\n<p>\nThe defaults are still local_worker: 0 and local_worker_only:0\n</p>\n\n</subsection>\n\n<subsection name=\"jni Worker properties\">\n<p>\nThe jni worker opens a JVM inside the web server process and executes Tomcat \nwithin it (that is, in-process). \nFollowing that, messages to and from the JVM are passed using JNI method calls, \nthis makes the jni worker faster \nthan the out-of-process workers, which must communicate with the Tomcat workers \nby writing AJP messages over \nTCP/IP sockets.\n</p>\n\n<p>\nNote: Since the JVM is multithreaded, the jni worker should be used only within \nmultithreaded servers \nsuch as AOLServer, IIS, Netscape and Apache 2.0.<br/> \nYou should also make sure that the threading scheme used by the web servers \nmatches the one \nused to build the JK web server plugin.\n</p>\n\n<p>\nSince the jni worker opens a JVM, it can accept many properties which it \nforwards to the JVM, such as \nthe classpath, etc., as we can see in the following table.\n</p>\n\n<p>\n<b>class_path</b> is the classpath as used by the in-process JVM. This should \npoint to all Tomcats' \njar/file files as well as any class or other jar file that you want to add to \nthe JVM.\n</p>\n\n<p>\nTo have JSP compile support, you should remember to also add Javac to the \nclasspath. \nThis can be done in Java2 by adding tools.jar to the classpath. \nIn JDK1.xx you should just add classes.zip.\n</p>\n\n<p>\nThe <b>class_path</b> property can be given in multiple lines. \nIn this case the JK environment will concatenate all the classpath entries \ntogether \nby putting path delimiters (\":\"/\";\") between the entries.\n</p>\n\n<screen>\n<note>Set the classpath for worker \"wrkjni\"</note>\n<read>worker.wrkjni.class_path=/var/tomcat3/lib/tomcat.jar</read>\n<note>We don't forget to add JAVAC (tools.jar)</note>\n<read>worker.wrkjni.class_path=/opt/IBMJava2-131/lib/tools.jar</read>\n</screen>\n\n<p>\n<b>bridge</b> Indicates the kind of Tomcat you'll use via JNI.\n</p>\n\n<p>\nThe bridge property could be for now <b>tomcat32</b> or <b>tomcat33</b>.\nTomcat 3.2.x is deprecated but still present on some distributions like \niSeries. \nBy default the bridge type is set to tomcat33.\n</p>\n\n<screen>\n<note>Set the bridge type for \"wrkjni\", we'll use tomcat 3.3</note>\n<read>worker.wrkjni.bridge=tomcat33</read>\n</screen>\n\n<p>\n<b>cmd_line</b> The command line that is handed over to Tomcat's startup code.\n</p>\n\n<p>\nThe cmd_line property can be given in multiple lines. \nIn this case the JK environment will concatenate all the cmd_line entries \ntogether by putting spaces \nbetween the entries.\n</p>\n\n<screen>\n<note>Set command line for \"wrkjni\"</note>\n<read>worker.wrkjni.cmd_line=-config</read>\n<note>Next arg</note>\n<read>worker.wrkjni.cmd_line=/etc/tomcat3/conf/alt-server.xml</read>\n<note>Very important tomcat.home</note>\n<read>worker.wrkjni.cmd_line=-home</read>\n<note>Location of tomcat.home</note>\n<read>worker.wrkjni.cmd_line=/var/tomcat3</read>\n</screen>\n\n<p>\n<b>jvm_lib</b> The full path to the JVM implementation library. \nThe jni worker will use this path to load the JVM dynamically.\n</p>\n\n<screen>\n<note>Set the full path for the JVM shared lib (IBM SDK on Linux)</note>\n<read>worker.wrkjni.jvm_lib=/opt/IBMJava2-131/jre/bin/classic/libjvm.so</read>\n<note>Set the full path for the JVM shared lib (Sun SDK on Windows)</note>\n<read>worker.wrkjni.jvm_lib=c:\\JDK\\1.3.1\\jre\\bin\\classic</read>\n</screen>\n\n<p>\n<b>stdout</b> The full path to where the JVM writes its System.out\n</p>\n\n<screen>\n<note>Put logs in /var/log/http/jk-jvm-out.log</note>\n<read>worker.wrkjni.stdout=/var/log/http/jk-jvm-out.log</read>\n</screen>\n\n<p>\n<b>stderr</b> The full path to where the JVM writes its System.err\n</p>\n\n<screen>\n<note>Put logs in /var/log/http/jk-jvm-err.log</note>\n<read>worker.wrkjni.stderr=/var/log/http/jk-jvm-err.log</read>\n</screen>\n\n<p>\n<b>ms</b> Set the initial HEAP size for the JVM\n</p>\n\n<screen>\n<note>Tell the JVM to use 64MB of initial heap </note>\n<read>worker.wrkjni.ms=64</read>\n</screen>\n\n<p>\n<b>mx</b> Set maximum HEAP size for the JVM\n</p>\n\n<screen>\n<note>Tell the JVM to not use more than 128MB for the heap</note>\n<read>worker.wrkjni.mx=128</read>\n</screen>\n\n<p>\n<b>sysprops</b> Set the system properties for the JVM\n</p>\n\n<screen>\n<note>Tell the JVM to use the French language</note>\n<read>worker.wrkjni.sysprops=-Duser.region=FR</read>\n</screen>\n\n<p>\n<b>ld_path</b> Set the additional dynamic libraries path (similar in nature to \nLD_LIBRARY_PATH)\n</p>\n\n<screen>\n<note>Tell system which library paths to be added to access Java Env</note>\n<read>worker.wrkjni.ld_path=/opt/IBMJava2-131/jre/bin/</read>\n<read>worker.wrkjni.ld_path=/opt/IBMJava2-131/jre/bin/classic</read>\n</screen>\n\n<p>\nNotes: Under Linux it seems that processes can't update their own \nLD_LIBRARY_PATH,\nso you'll have to update it BEFORE launching the web server...\n</p>\n\n</subsection>\n\n<subsection name=\"Property file macros\">\n<p>\nYou can define \"macros\" in the property files. \nThese macros let you define properties and later on use them while \nconstructing other properties and it's very useful when you want to\nchange your Java Home, Tomcat Home or OS path separator.\n</p>\n\n<screen>\n<note>property example, don't hardcode path separator</note>\nps=\\\n<read>workers.tomcat_home=d:\\tomcat</read>\n<read>workers.java_home=d:\\sdk\\jdk1.2.2</read>\n<note>Using macros we'll have : \nworker.inprocess.class_path=d:\\tomcat\\classes</note>\n<read>worker.inprocess.class_path=$(workers.tomcat_home)$(ps)classes</read>\n<note>Using macros we'll have : worker.inprocess.class_path=d:\\sdk\\jdk1.2.2\n\\lib\\tools.jar</note>\n<read>worker.inprocess.class_path=$(workers.java_home)$(ps)lib$(ps)\ntools.jar</read>\n</screen>\n\n</subsection>\n\n</section>\n\n<section name=\"A sample worker.properties\">\n<p>\nSince coping with worker.properties on your own is not an easy thing to do, \na sample worker.properties file is bundled with JK. \n</p>\n\n<p>\nIn addition, here is a sample workers.properties defining:\n</p>\n\n<ul>\n<li>\nAn ajp12 worker that uses the host localhost and the port 8007\n</li>\n<li>\nAn ajp13 worker that uses the host localhost and the port 8008\n</li>\n<li>\nA jni worker\n</li>\n<li>\nA lb worker that load balances the ajp12 and ajp13 workers\n</li>\n</ul>\n\n<screen>\n<note># Define some properties</note>\n<read>workers.apache_log=/var/log/httpd/</read>\n<read>workers.tomcat_home=/var/tomcat3</read>\n<read>workers.java_home=/opt/IBMJava2-131/</read>\n<read>ps=/</read>\n<note># Define 4 workers, 3 real workers using ajp12, ajp13, jni, the last one \nbeing a loadbalancing worker</note> \n<read>worker.list=worker1, worker2, worker3, worker4</read>\n<note># Set properties for worker1 (ajp12)</note>\n<read>worker.worker1.type=ajp12</read>\n<read>worker.worker1.host=locahost</read>\n<read>worker.worker1.port=8007</read>\n<read>worker.worker1.lbfactor=5</read>\n<note># Set properties for worker2 (ajp13)</note>\n<read>worker.worker2.type=ajp13</read>\n<read>worker.worker2.host=locahost</read>\n<read>worker.worker2.port=8009</read>\n<read>worker.worker2.lbfactor=50</read>\n<read>worker.worker2.cachesize=10</read>\n<read>worker.worker2.cache_timeout=600</read>\n<read>worker.worker2.socket_keepalive=1</read>\n<read>worker.worker2.socket_timeout=300</read>\n<note># Set properties for worker3 (jni)</note>\n<read>worker.worker3.type=jni</read>\n<note># Set worker3 bridge type, here Tomcat 3.3</note>\n<read>worker.worker3.bridge=tomcat33</read>\n<note># Set worker3 classpath</note>\n<read>worker.worker3.class_path=$(workers.tomcat_home)$(ps)classes</read>\n<read>worker.worker3.class_path=$(workers.tomcat_home)$(ps)lib$(ps)\ntomcat.jar</read>\n<note># Set worker3 tomcat command line</note>\n<read>worker.worker3.cmd_line=-home</read>\n<read>worker.worker3.cmd_line=$(workers.tomcat_home)</read>\n<note># Set worker3 Tomcat/JVM settings</note>\n<read>worker.worker3.jvm_lib=$(workers.java_home)$(ps)jre$(ps)bin$(ps)\nclassic$(ps)libjvm.so</read>\n<read>worker.worker3.stdout=$(workers.apache_log)$(ps)inprocess.stdout</read>\n<read>worker.worker3.stderr=$(workers.apache_log)$(ps)inprocess.stderr</read>\n<read>worker.worker3.sysprops=tomcat.home=$(workers.tomcat_home)</read>\n<note># Set properties for worker4 (lb) which uses worker1 and worker2</note>\n<read>worker.worker4.balanced_workers=worker1,worker2</read>\n</screen>\n\n</section>\n\n</document>", "id": 34947, "time": "2003-04-11T09:47:52Z", "bug_id": 18943, "creation_time": "2003-04-11T09:47:52Z", "is_private": false}]