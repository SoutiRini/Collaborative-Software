[{"count": 0, "tags": [], "creator": "loren.anderson@mscibarra.com", "text": "As part of our software security remediations, we upgraded our site to use apache 2.2.13 from 2.2.2.\n\nWe found a critical issue with Apache 2.2.13 (and reproduced on 2.2.15). This issue does not exist in apache 2.2.2.\n\nThe basics of this problem are that when you use mod_proxy to connect to a backend tomcat server and apache is configured to timeout before tomcat, a connection to the backend tomcat server is placed back into the pool of existing connections with what ever data that was destined to the original caller waiting to be retrieved by the next caller to take this connection from the pool. In our application which is statefull, this lead to customer's sessions crossing and customer A saw customer B's data.\n\nSetting DisableReuse=true or changing the timeout of apache to be larger that the tomcat server avoids this issue.\n\nI was able to recreate the issue with a simple TOMCAT echo servlet that takes an incoming URL which contains a random number and returning that value in the body of an HTML response. The apache and tomcat servers run on a single Windows 7 box (I have also tried this on Windows Server 2003) configured to connect via localhost.\n\nThe client driver needs to have KEEPALIVE on (since the front end connection and back end connections seem to be linked from a life-span perspective). My sample client driver was written in ruby. It generates a random number and then checks that the response it gets is what it send. \n\nApache is configured to have 5 pooled connections (max=5, min=5) and set to timeout in 10 seconds. TOMCAT is configured to timeout in 5 minutes. \n\nThe client ruby code sleeps a random amount of time between 1 and 15 seconds. This leads to about 1/3 of the clients timeing out. I run 20 clients. Within a few seconds, the problem is reproduced (client does not see the number it send it).\n\nHere is my apache configuration:\n\n=== BEGIN httpd.conf ===\nPidFile httpd.pid\n\nTimeout 600\nKeepAlive On\nMaxKeepAliveRequests 0\nKeepAliveTimeout 300\nServerTokens ProductOnly\n\nFileETag -INode MTime Size\n\nServerSignature Off\n\nThreadsPerChild 1000\nMaxRequestsPerChild  0\n\nListen 81\n\nLoadModule authz_host_module    \"modules/mod_authz_host.so\"\nLoadModule proxy_module         \"modules/mod_proxy.so\"\nLoadModule proxy_http_module    \"modules/mod_proxy_http.so\"\nLoadModule dir_module           \"modules/mod_dir.so\"\nLoadModule log_config_module    \"modules/mod_log_config.so\"\nLoadModule mime_module          \"modules/mod_mime.so\"\nLoadModule rewrite_module       \"modules/mod_rewrite.so\"\nLoadModule headers_module       \"modules/mod_headers.so\"\n\nRewriteEngine on\nRewriteCond %{REQUEST_METHOD} ^(TRACE|TRACK)\nRewriteRule .* - [F]\n\nTypesConfig \"conf/mime.types\"\n\nAddDefaultCharset   ISO-8859-1\nMaxMemFree 1000000\n\nErrorLog \"apache-error.log\"\nLogLevel info\nLogFormat \"%h %l %u %t \\\"%r\\\" %>s %b \\\"%{Referer}i\\\" \\\"%{User-Agent}i\\\"\" combined\nLogFormat \"%h %A %l %u %t \\\"%r\\\" %>s %b\" common\nLogFormat \"%{Referer}i -> %U\" referer\nLogFormat \"%{User-agent}i\" agent\nCustomLog \"apache-access-BK-PEWEB01-B1_APACHE.log\" common\nDocumentRoot \"root\"\n\n<Directory \"root\">\n    Options FollowSymLinks Includes\n    AllowOverride None\n    Order allow,deny\n    Allow from all\n    DirectoryIndex index.html\n</Directory>\n\n<Proxy *>\n     AddDefaultCharset Off\n     Order deny,allow\n     Allow from all\n</Proxy>\n\nProxyPass /test http://localhost:9090/test min=5 max=5 timeout=10\nProxyPassReverse /test http://localhost:9090/test\n=== END httpd.conf ===\n\nHere is the TOMCAT configuration:\n\n=== BEGIN server.xml ===\n<Server\n  port=\"8005\"\n  shutdown=\"SHUTDOWN\"\n  debug=\"0\"\n>\n    <Service name=\"Tomcat\">\n        <Connector\n            port=\"9090\"\n            maxThreads=\"1000\"\n            minSpareThreads=\"25\"\n            maxSpareThreads=\"75\"\n            enableLookups=\"false\"\n            redirectPort=\"8443\"\n            acceptCount=\"100\"\n            debug=\"0\"\n            connectionTimeout=\"300000\"\n            disableUploadTimeout=\"true\"\n            server=\"THX1138\"\n            proxyName=\"pe1.barra.com\"\n            proxyPort=\"443\"\n        />\n        <Engine\n          name=\"Standalone\"\n          defaultHost=\"localhost\"\n          debug=\"0\"\n        >\n            <Host\n              name=\"localhost\"\n              debug=\"0\"\n              appBase=\"webapps\"\n              unpackWARs=\"true\"\n            >\n                <Context\n                  useHttpOnly=\"true\"\n                  reloadable=\"false\"\n                  path=\"/test\"\n                  docBase=\"c:/workspace/webapps/test\"\n                  debug=\"0\"\n                  privileged=\"true\"\n                />\n            </Host>\n        </Engine>\n    </Service>\n</Server>\n=== END server.xml ===\n\nHere is my simple eacho servlet:\n\n=== BEGIN EchoServlet.java ===\nimport com.sun.mail.util.UUEncoderStream;\nimport org.apache.derby.iapi.util.StringUtil;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Random;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class EchoServlet extends javax.servlet.http.HttpServlet implements javax.servlet.Servlet {\n    private static Random rand = new Random(System.nanoTime());\n    public EchoServlet() {\n        super();\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html\");\n\n        String uri = request.getRequestURI();\n\n        if(uri.startsWith(\"/test/\")) {\n            String num = uri.replace(\"/test/\", \"\");\n            long rid = Long.parseLong(num);\n            PrintWriter writer = response.getWriter();\n            try {\n                Thread.sleep(1000 * rand.nextInt(17));\n            } catch(InterruptedException e) {}\n            writer.print(\"<html>\");\n            writer.print(\"<body>\");\n            writer.print(rid);\n            writer.print(\"</body>\");\n            writer.print(\"</html>\");\n            writer.close();\n        }\n    }\n}\n=== END EchoServlet.java ===\n\nHere is my client ruby driver:\n\n=== BEGIN echoclient.rb ===\nrequire \"socket\"\nrequire \"cgi\"\n\n$printHeader = false\nclass Response\n  attr_reader :socket, :header, :content\n\n  def initialize socket\n    @socket = socket\n    @header = @content = \"\"\n    contentlength = 0\n\n    while (line = @socket.gets) != nil\n      break if line == \"\\r\\n\"\n      puts line if $printHeader\n      @header << line\n      case line\n      when /^content-length: (\\d+)/i\n        contentlength = $1.to_i\n      end\n    end\n    if contentlength != 0\n      @content = @socket.read contentlength\n    end\n  end\nend\n\nsocket = nil\nconnected = false\n\nwhile true\n    if socket == nil || socket.closed?\n      connected = false\n      socket = nil\n      print '='\n      $stdout.flush\n    end\n    while !connected\n       begin\n            socket = TCPSocket.new('localhost', 81)\n            connected = true\n        rescue\n            puts \"Got error, sleeping\"\n            sleep 5\n            next\n        end\n    end\n    num = rand(2000000000)\n    #puts \"Input: #{num}\"\n    req = \"GET /test/#{num} HTTP/1.1\\r\\nConnection: Keep-Alive\\r\\nHost: 127.0.0.1\\r\\n\\r\\n\"\n    socket.write req\n    socket.flush\n\n    resp_num = 0\n    response = Response.new socket\n    if response.content.length == 0\n      print '&'\n      $stdout.flush\n    end\n    if response.content =~ /<HTML><BODY>([0-9]+)<\\/BODY><\\/HTML>/io\n            resp_num = $1.to_i\n    end\n    if resp_num == 0\n      $printHeader = true\n      print '0'\n    elsif num != resp_num\n      $printHeader = false\n      puts num\n      puts resp_num\n      print '-'\n    else\n      $printHeader = false\n      print '*'\n    end\n    $stdout.flush\nend\n=== END echoclient.rb ===", "id": 137502, "time": "2010-06-09T11:26:10Z", "bug_id": 49417, "creation_time": "2010-06-09T11:26:10Z", "is_private": false, "attachment_id": null}, {"count": 1, "tags": [], "bug_id": 49417, "attachment_id": null, "id": 137503, "creation_time": "2010-06-09T11:49:06Z", "time": "2010-06-09T11:49:06Z", "creator": "rpluem@apache.org", "text": "Can you please provide the error log file that is created during your tests?", "is_private": false}, {"count": 2, "tags": [], "bug_id": 49417, "attachment_id": null, "text": "Ah forgot. Please set the loglevel to debug before.", "id": 137504, "time": "2010-06-09T11:50:03Z", "creator": "rpluem@apache.org", "creation_time": "2010-06-09T11:50:03Z", "is_private": false}, {"attachment_id": null, "tags": [], "bug_id": 49417, "text": "... and finally: if the problem really is triggered by Apache having a shorter timeout than Tomcat, I would expect it to be much more likely that the source of the problem would be a resued buffer in Tomcat.\n\nSo could you please also provide your Tomcat version and whether you are using tcnative (also known as Tomcat Native Connector or APR connector).", "count": 3, "id": 137505, "time": "2010-06-09T12:13:11Z", "creator": "rainer.jung@kippdata.de", "creation_time": "2010-06-09T12:13:11Z", "is_private": false}, {"count": 4, "tags": [], "creator": "loren.anderson@mscibarra.com", "attachment_id": null, "id": 137506, "time": "2010-06-09T12:29:08Z", "bug_id": 49417, "creation_time": "2010-06-09T12:29:08Z", "is_private": false, "text": "The problem is that TOMCAT does not know that apache has placed this connection back in the pool. There is nothing done to the connection to inform TOMCAT that the connection is going to be reused by another client request. The TOMCAT version is 2.2.27. The provided tomat server.xml shows which connector we are using (coyote)."}, {"count": 5, "tags": [], "creator": "rainer.jung@kippdata.de", "text": "(In reply to comment #4)\n> The problem is that TOMCAT does not know that apache has placed this connection\n> back in the pool. There is nothing done to the connection to inform TOMCAT that\n> the connection is going to be reused by another client request. The TOMCAT\n> version is 2.2.27. The provided tomat server.xml shows which connector we are\n> using (coyote).\n\nYou mean Tomcat version 5.5.27? There is no version 2.2.x for Tomcat.\n\nConcerning the connector: the configuration doesn't tell us which implementation it is. If Tomcat finds the tcnative DLL during startup it will automatically launch the APR connector instead of the Java Blocking IO connector.\n\nSo please double check:\n\nAPR during startup:\n\n10.06.2010 11:10:38 org.apache.coyote.http11.Http11AprProtocol init\nINFO: Initializing Coyote HTTP/1.1 on http-8080\n\nBocking IO:\n\n10.06.2010 11:13:43 org.apache.coyote.http11.Http11BaseProtocol init\nINFO: Initializing Coyote HTTP/1.1 on http-8080\n\nNote: \"Http11AprProtocol\" vs. \"Http11BaseProtocol\".\n\nPlease do also respond to R\u00fcdiger's questions.\n\nThanks.", "id": 137523, "time": "2010-06-10T05:15:50Z", "bug_id": 49417, "creation_time": "2010-06-10T05:15:50Z", "is_private": false, "attachment_id": null}, {"count": 6, "tags": [], "bug_id": 49417, "attachment_id": null, "id": 137586, "time": "2010-06-11T16:58:47Z", "creator": "wrowe@apache.org", "creation_time": "2010-06-11T16:58:47Z", "is_private": false, "text": "This is resolved in svn for 2.2.16 and 2.3.6-alpha releases.  Thank you for\nthe thorough details and research that went into your report!\n\nNote this affected also Netware and OS2 ports, but not *nix'es.\n\nThe simplest workaround is to globally configure;\n\nSetEnv proxy-nokeepalive 1"}]