[{"count": 0, "tags": [], "creator": "pverheyden@broadleafcommerce.com", "attachment_id": null, "is_private": false, "id": 179328, "time": "2014-11-27T13:28:14Z", "bug_id": 57274, "creation_time": "2014-11-27T13:28:14Z", "text": "Full context, I am using Spring 4.1.2.RELEASE in my application with Spring Instrument hooked up as a -javaagent (-javaagent:/path/to/spring-instrument-4.1.2.RELEASE). We are relying on class transformation to transform some of our JPA classes and add new methods/fields on startup. However, I observed that for some classes, class transformation is completely skipped.\n\nAfter some debugging, I have narrowed this down to the getResourceInternal method of WebappClassLoaderBase. Specifically, this is giving me grief:\n\n    protected ResourceEntry findResourceInternal(final String name, final String path) {\n\n        if (!state.isAvailable()) {\n            log.info(sm.getString(\"webappClassLoader.stopped\", name));\n            return null;\n        }\n\n        if (name == null || path == null) {\n            return null;\n        }\n        // This is returning a non-null entry. On every other class that I observed, this returns null and it continues on to the class transformers\n        ResourceEntry entry = resourceEntries.get(path);\n        if (entry != null) {\n            return entry;\n        }\n    ...\n    ...\n    // Remaining implementation excluded, but below here is where it loops through the configured `ClassFileTransformer`s\n\nWhen my JPA persistent unit is loaded, about 98% of the classes return null for resourceEntries.get(path). Some classes return a non-null entry, and so they are immediately returned thus skipping the class transformation below.\n\nWith more debugging, I came across the code on startup that scans every class in every jar in the web application on startup to look for SCIs (ContextConfig.webConfig()). For almost every class that it looks for, it grabs an input stream based for the class file based on the FileInputStream and then puts it in a cache.\n\nHowever, this process also looks for super classes (from ContextConfig):\n\n    private void populateJavaClassCache(String className, JavaClass javaClass) {\n        if (javaClassCache.containsKey(className)) {\n            return;\n        }\n\n        // Add this class to the cache\n        javaClassCache.put(className, new JavaClassCacheEntry(javaClass));\n\n        populateJavaClassCache(javaClass.getSuperclassName());\n\n        for (String iterface : javaClass.getInterfaceNames()) {\n            populateJavaClassCache(iterface);\n        }\n    }\n\nwhere populateJavaClassCache:\n\n    private void populateJavaClassCache(String className) {\n        if (!javaClassCache.containsKey(className)) {\n            String name = className.replace('.', '/') + \".class\";\n            try (InputStream is = context.getLoader().getClassLoader().getResourceAsStream(name)) {\n                if (is == null) {\n                    return;\n                }\n                ClassParser parser = new ClassParser(is);\n                JavaClass clazz = parser.parse();\n                populateJavaClassCache(clazz.getClassName(), clazz);\n            } catch (ClassFormatException e) {\n                log.debug(sm.getString(\"contextConfig.invalidSciHandlesTypes\",\n                        className), e);\n            } catch (IOException e) {\n                log.debug(sm.getString(\"contextConfig.invalidSciHandlesTypes\",\n                        className), e);\n            }\n        }\n    }\n\nUsing context.getLoader().getClassLoader().getResourceAsStream() causes the WebappClassLoader to load the class and store it in the resourceEntries map. However at this point, the WebappClassLoader does not have any ClassTransformers registered with it yet, and thus no class transformation happens.\n\nSo, if you have any JPA entity that is a superclass of something else, class transformation would be skipped.\n\nI am not sure exactly what the right fix is here but I feel like it should be something that skips using the WebappClassLoader to load the class? That could be very expensive though as we would need to scan through all of the jars in the classpath again to find the superclass definition (which would make this O(n2).\n\nI have some additional information at https://github.com/BroadleafCommerce/BroadleafCommerce/issues/1171 but I put in just the Tomcat-relevant info here."}, {"attachment_id": null, "tags": [], "creator": "pverheyden@broadleafcommerce.com", "is_private": false, "count": 1, "id": 179366, "time": "2014-11-29T16:47:39Z", "bug_id": 57274, "creation_time": "2014-11-29T16:47:39Z", "text": "I think that this issue can be closed. The problems that I highlighted below are a necessary outcome of Tomcat needing to scan for ServletContainerInitializers in the web application. It does this by looping through all of the classes in all of the jars loaded by the application and reading them in with a FileInputStream. I would imagine that it is a performance improvement to, after loading a class via FileInputStream, to go ahead and load the superclass and interfaces into the cache as well. However, the superclass has to be loaded through the WebappClassLoader which is what causes a problem in my case.\n\nAfter doing some additional digging (specifically at http://java.net/jira/browse/SERVLET_SPEC-36), I found that I can disable the jar scanning completely by adding an empty <absolute-ordering /> in my web.xml. After testing this everything in my application works as I would expect.\n\nSorry for the false positive here but hopefully someone else will come across this research and will save them some debugging time.\n\nAlso, I would also like to take this opportunity to say thanks for all the contributors to Tomcat! We love the simplicity and performance, and we consistently recommend Tomcat as our #1 servlet container for those that use Broadleaf. Thanks again!"}, {"count": 2, "tags": [], "bug_id": 57274, "attachment_id": null, "id": 179397, "time": "2014-12-01T10:55:33Z", "creator": "markt@apache.org", "creation_time": "2014-12-01T10:55:33Z", "is_private": false, "text": "Happy to leave this closed but I wanted to add the following comments:\n\n1. If the transformation attempts to make a change that would trigger something in the annotation scanning then that change is going to be ignored. I think I am OK with that. There are better ways to achieve the desired result.\n\n2. One way of fixing this would be to delay the transformation until the the class is declared."}, {"count": 3, "attachment_id": null, "bug_id": 57274, "is_private": false, "id": 179456, "time": "2014-12-02T21:53:18Z", "creator": "nicholas@nicholaswilliams.net", "creation_time": "2014-12-02T21:53:18Z", "tags": [], "text": "I will think about this some. Off the top of my head, I don't know what the answer is, but it sure would be nice if there were a solution."}, {"count": 4, "tags": [], "bug_id": 57274, "text": "The solution that I had was to completely disable the scanning by adding an empty <absolute-ordering /> tag into my web.xml. This obviously means that there is no way to have both my Spring/persistent unit class transformation along with the ServletContainerInitializers (not an issue in my case).\n\nI believe that one possible solution here would be to disable what I believe to be a performance improvement of loading the classes by the class loader. If the classes were not loaded by the classloader at all and instead every single class was loaded by the FileInputStream, then this would not be a problem at all. Perhaps there could be some sort of startup flag that controls whether or not to use the class loader to look for ServletContainerInitializers or to skip it and load all of them by FileInputStreams?\n\nMark, what do you mean by \"delay the transformation until the the class is declared\"? Does this mean moving the transformation code from WebAppClassLoader to after it has retrieved the cache from resourceEntries, but prior to actually loading the class itself (like via a Class.forName())? This seems like a better solution to me. It seems there is a slight deviation by looking up a class by name with a getResourceAsStream() and referencing it by doing a Class.forName().", "id": 179457, "time": "2014-12-02T22:02:34Z", "creator": "pverheyden@broadleafcommerce.com", "creation_time": "2014-12-02T22:02:34Z", "is_private": false, "attachment_id": null}, {"count": 5, "tags": [], "text": "(In reply to Phillip from comment #4)\n\n> Mark, what do you mean by \"delay the transformation until the the class is\n> declared\"? Does this mean moving the transformation code from\n> WebAppClassLoader to after it has retrieved the cache from resourceEntries,\n> but prior to actually loading the class itself (like via a Class.forName())?\n\nYes. Basically delay the transformation until just before we call defineClass().", "attachment_id": null, "bug_id": 57274, "id": 179458, "time": "2014-12-02T22:10:06Z", "creator": "markt@apache.org", "creation_time": "2014-12-02T22:10:06Z", "is_private": false}]