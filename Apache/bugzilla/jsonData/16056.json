[{"count": 0, "tags": [], "text": "While attempting to port mod_watch to Apache 2.0, which uses both anonymous\nshared memory and mutexes, I found that I kept getting EACCESS every time I\ntried to lock the mutex. Now comparing my shared memory and mutex code used in\n1.3 vs. that in the APR, the only difference I could find was that the APR code\nfails to assign the uid/gid ownership of the mutex to that of the \"prefork\"\nchild processes (User/Group directives). Now the APR has no appropriate API for\nchanging the ownership of shared memory or a mutex.  \n\nI tested my theory by adding the following code to my module, which proceeded to\nfunction afterwards:\n\n#if defined(APR_USE_SHMEM_SHMGET) || defined(APR_USE_SHMEM_SHMGET_ANON)\n#include \"arch/unix/shm.h\"\n#include \"unixd.h\"\n#endif\n\n#if defined(APR_HAS_SYSVSEM_SERIALIZE)\n#include \"arch/unix/global_mutex.h\"\n#include \"unixd.h\"\n#endif\n\n...\n\n  rc = apr_shm_create((apr_shm_t **) &tp->shared, bytes, (const char *) 0, p);\n  if (rc != APR_SUCCESS)\n\tgoto error0;\n\n#if defined(APR_USE_SHMEM_SHMGET) || defined(APR_USE_SHMEM_SHMGET_ANON)\n/* Setup the access permissions for the shared memory so that child processes\n * that change their user/group can still access the shared memory after. This\n * should have been done in the APR library or (due to lack of clear\n * documentation) I'm misundestanding how anonymous mutexes and shared\n * memory work.\n */\n{\n\tstruct shmid_ds shmbuf;\n        apr_shm_t *theMem = tp->shared;\n\n        if (shmctl(theMem->shmid, IPC_STAT, &shmbuf) != 0)\n                goto error1;\n        shmbuf.shm_perm.uid = unixd_config.user_id;;\n        shmbuf.shm_perm.gid = unixd_config.group_id;\n        shmbuf.shm_perm.mode = 0600;\n        if (shmctl(theMem->shmid, IPC_SET, &shmbuf) != 0)\n                goto error1;\n}\n#endif\n\n...\n\n\trc = apr_global_mutex_create(\n\t\t(apr_global_mutex_t **) &tp->mutex,\n\t\ttp->lockfile, APR_LOCK_DEFAULT, p\n\t);\n\tif (rc != APR_SUCCESS)\n\t\tgoto error1;\n\n#if defined(APR_HAS_SYSVSEM_SERIALIZE)\n/* || defined(APR_HAS_FCNTL_SERIALIZE) || defined(APR_HAS_FLOCK_SERIALIZE) */\n/* Setup the access permissions for the mutex so that child processes\n * that change their user/group can still access the mutex after. This\n * should have been done in the APR library or (due to lack of clear\n * documentation) I'm misundestanding how anonymous mutexes and shared\n * memory work.\n */\n{\n        union semun ick;\n        struct semid_ds sembuf;\n        apr_global_mutex_t *theMutex = tp->mutex;\n\n        ick.buf = &sembuf;\n        if (semctl(theMutex->proc_mutex->interproc->filedes, 0, IPC_STAT, ick) != 0)\n                goto error3;\n        sembuf.sem_perm.uid = unixd_config.user_id;\n        sembuf.sem_perm.gid = unixd_config.group_id;\n        sembuf.sem_perm.mode = 0600;\n        if (semctl(theMutex->proc_mutex->interproc->filedes, 0, IPC_SET, ick) != 0)\n                goto error3;\n}\n#endif", "is_private": false, "id": 29340, "creator": "achowe@snert.com", "time": "2003-01-14T08:16:18Z", "bug_id": 16056, "creation_time": "2003-01-14T08:16:18Z", "attachment_id": null}, {"count": 1, "tags": [], "text": "OK. After some further puttering about with mod_watch development, I stumbled\nacross the following API in <unixd.h> (damn I wish there was better\ndocumentation for developers):\n\n   unixd_set_proc_mutex_perms();\n   unixd_set_gobal_mutex_perms();\n\nHowever, I can't find the equivalent for the shared memory case.", "attachment_id": null, "id": 29677, "creator": "achowe@snert.com", "time": "2003-01-19T13:19:33Z", "bug_id": 16056, "creation_time": "2003-01-19T13:19:33Z", "is_private": false}, {"count": 2, "tags": [], "bug_id": 16056, "text": "Created attachment 4740\nProposed solution.", "id": 30735, "time": "2003-02-05T12:32:34Z", "creator": "achowe@snert.com", "creation_time": "2003-02-05T12:32:34Z", "is_private": false, "attachment_id": 4740}, {"count": 3, "tags": [], "creator": "wrowe@apache.org", "is_private": false, "text": "The feature you request is not inherently provided by APR; but I'm noting\nyour request as an enhancement; I concur that httpd providing all the workarounds\nhere in their unix.c sources really is lame.\n\nYour concern expressed in the patch is a no-go for the proposed solution, opening\nup the permissions for the mutex is definately a nonstarter for the very reasons\nyou mentioned in the comments.", "id": 85569, "time": "2006-02-07T22:51:06Z", "bug_id": 16056, "creation_time": "2006-02-07T22:51:06Z", "attachment_id": null}, {"count": 4, "tags": [], "bug_id": 16056, "attachment_id": null, "id": 93841, "time": "2006-09-19T19:54:39Z", "creator": "wrowe@apache.org", "creation_time": "2006-09-19T19:54:39Z", "is_private": false, "text": "Mass reassign the 44 open apr-bugs to apr bug list"}, {"count": 5, "attachment_id": 20532, "bug_id": 16056, "is_private": false, "id": 105818, "time": "2007-07-21T15:12:55Z", "creator": "davi@apache.org", "creation_time": "2007-07-21T15:12:55Z", "tags": [], "text": "Created attachment 20532\nextend apr_shm_create\n\nIt seems like for now we could extend apr_shm_create() to accept access\npermissions. How about the attached patch?"}]