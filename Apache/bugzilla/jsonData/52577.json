[{"count": 0, "attachment_id": null, "creator": "dmitry.neverov@gmail.com", "is_private": false, "id": 153354, "time": "2012-02-02T07:45:44Z", "bug_id": 52577, "creation_time": "2012-02-02T07:45:44Z", "tags": [], "text": "Due to changes 1229726, 1229727 and 1229728 output written to response in the filter can be truncated up to 8192 bytes. Consider the following scenario:\n\n- you have a filter that invoke getWriter() before chain.doFilter(request, responseWrapper)\n\n\n- responseWrapper overrides getWriter() method and returns some\n  buffered writer, not the real one\n\n\n- during execution of chain.doFilter there is a forward\n\n\nBefore the forward ApplicationDispather calls resetBuffer on response, which in turn calls reset() on OutputBuffer, which sets gotEnc field to false. This field is initialized in the setConverter() method which is called from response.getWriter(), but since our wrapperResponse overrides getWriter(), OutputBuffer.setConverter() never called and OutputBuffer still has gotEnc = false.\n\n\nResponse's close() and flushBuffer() methods call OutputBuffer's flush(), but since gotEnc == false, conv.flushBuffer() is not called:\n\n\nif (gotEnc && conv != null) {\n    conv.flushBuffer();\n}\n\n\nA workaround for us is to implement getWriter() method in responseWrapper like this:\n\n\npublic Writer getWriter() {\n  Writer originalWriter = originalResponse.getWriter();//save for future processing\n  return ourWriter;\n}\n\n\nMaybe you should change flushing to something like that:\n\n\nif (conv != null) {\n    conv.flushBuffer();\n}\n\n\nbecause you invoke conv.convert() without any checks in the write*() methods and it seems like conv is never null."}, {"count": 1, "tags": [], "bug_id": 52577, "is_private": false, "id": 153476, "attachment_id": null, "creator": "markt@apache.org", "creation_time": "2012-02-05T21:17:58Z", "time": "2012-02-05T21:17:58Z", "text": "Thanks for the report. The issue may be triggered simply by calling reset() on the response. No need for the filter or the wrapper.\n\nThis has been fixed in trunk and 7.0.x and will be included in 7.0.26 onwards."}]