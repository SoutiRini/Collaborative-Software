[{"count": 0, "tags": [], "text": "SsiServlet does not seem to close some of the streams it uses. The symptoms this\ncauses are that the whole server starts to suffer from 'Too many open files'\nerrors like this:\n\n2001-10-23 12:00:16 ApplicationDispatcher[/archive] Servlet.service() for\nservlet default threw exception\njava.io.FileNotFoundException: /home/ibs/archive/tk/tyyli_yleinen_ibs.ssi (Too\nmany open files)\n\tat java.io.FileInputStream.open(Native Method)\n\tat java.io.FileInputStream.<init>(FileInputStream.java:64)\n\tat java.io.FileInputStream.<init>(FileInputStream.java:95)\n\tat\norg.apache.naming.resources.FileDirContext$FileResource.streamContent(FileDirContext.java)\n\tat\norg.apache.catalina.servlets.DefaultServlet$ResourceInfo.getStream(DefaultServlet.java)\n\tat org.apache.catalina.servlets.DefaultServlet.copy(DefaultServlet.java)\n\tat\norg.apache.catalina.servlets.DefaultServlet.serveResource(DefaultServlet.java)\n\tat org.apache.catalina.servlets.DefaultServlet.doGet(DefaultServlet.java)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java)\n\tat\norg.apache.catalina.core.ApplicationDispatcher.invoke(ApplicationDispatcher.java)\n\tat\norg.apache.catalina.core.ApplicationDispatcher.doInclude(ApplicationDispatcher.java)\n\tat\norg.apache.catalina.core.ApplicationDispatcher.include(ApplicationDispatcher.java)\n\tat org.apache.catalina.util.ssi.SsiInclude.getStream(Unknown Source)\n\tat org.apache.catalina.servlets.SsiInvokerServlet.requestHandler(Unknown\nSource)\n\tat org.apache.catalina.servlets.SsiInvokerServlet.doGet(Unknown Source)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java)\n\tat\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java)\n\tat\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java)\n\tat\norg.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java)\n\tat org.apache.catalina.core.StandardPipeline.invokeNext(StandardPipeline.java)\n\tat org.apache.catalina.core.StandardPipeline.invoke(StandardPipeline.java)\n\tat org.apache.catalina.core.ContainerBase.invoke(ContainerBase.java)\n\tat\norg.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java)\n\tat org.apache.catalina.core.StandardPipeline.invokeNext(StandardPipeline.java)\n\tat org.apache.catalina.valves.CertificatesValve.invoke(CertificatesValve.java)\n\tat org.apache.catalina.core.StandardPipeline.invokeNext(StandardPipeline.java)\n\tat org.apache.catalina.core.StandardPipeline.invoke(StandardPipeline.java)\n\tat org.apache.catalina.core.ContainerBase.invoke(ContainerBase.java)\n\tat org.apache.catalina.core.StandardContext.invoke(StandardContext.java)\n\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java)\n\tat org.apache.catalina.core.StandardPipeline.invokeNext(StandardPipeline.java)\n\tat org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java)\n\tat org.apache.catalina.core.StandardPipeline.invokeNext(StandardPipeline.java)\n\tat org.apache.catalina.core.StandardPipeline.invoke(StandardPipeline.java)\n\tat org.apache.catalina.core.ContainerBase.invoke(ContainerBase.java)\n\tat\norg.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java)\n\tat org.apache.catalina.core.StandardPipeline.invokeNext(StandardPipeline.java)\n\tat org.apache.catalina.core.StandardPipeline.invoke(StandardPipeline.java)\n\tat org.apache.catalina.core.ContainerBase.invoke(ContainerBase.java)\n\tat org.apache.catalina.connector.http.HttpProcessor.process(HttpProcessor.java)\n\tat org.apache.catalina.connector.http.HttpProcessor.run(HttpProcessor.java)\n\tat java.lang.Thread.run(Thread.java:484)\n\nAlthough this error message alone does not prove that SSI is the guilty party,\nthe errors started to appear immediately after SSI servlet was taken into use.\nIn particular, I tested the system with a lengthly data import operation that\naccesses thousands of HTML documents, and it works fine when SSI is disabled,\nbut corrupts the server with the \"Too many open files\" problems when SSI is\nenabled.\n\nSSI implementation seems therefore to have at least some role in causing this\ntrouble.", "is_private": false, "bug_id": 4361, "id": 7036, "time": "2001-10-23T02:14:32Z", "creator": "rami.hanninen@davisor.com", "creation_time": "2001-10-23T02:14:32Z", "attachment_id": null}, {"count": 1, "tags": [], "creator": "bip@apache.org", "attachment_id": null, "is_private": false, "id": 7056, "time": "2001-10-23T09:57:37Z", "bug_id": 4361, "creation_time": "2001-10-23T09:57:37Z", "text": "Hmm, the SsiPackage doesn't open any FileStreams explicity, only indirect\nthrough RequestDispatcher.include(). Could it be that your \"lengthly data \nimport operation that accesses thousands of HTML documents\" exceeds the number \nof open files currently allowed on your system?\n\nYou could try to raise proc/sys/kernel/file-max AND /proc/sys/kernel/inode-max\nand see if things work better, you could also look at how many files currently\nopen with 'lsof'.\n\nCould you try that out and report back if it works or not.\n\n       Bip Thelin"}, {"count": 2, "tags": [], "text": "I can't recreate the error here but I did happen to notice something as I was \nbrowsing through the code.  Each SsiInvokerServlet request causes it to open the \nrequested file as a Resource.  The InputStream that is obtained from this \nResource is never closed.  I tried to poke around in the Resource classes to see \nif some magic was closing the stream but couldn't find anything.\n\nI can attach a patch if needed, but the change is pretty simple.  Just a \ntry/finally with a close().\n\n", "attachment_id": null, "bug_id": 4361, "id": 7066, "time": "2001-10-23T12:39:57Z", "creator": "pspeed@progeeks.com", "creation_time": "2001-10-23T12:39:57Z", "is_private": false}, {"count": 3, "tags": [], "bug_id": 4361, "attachment_id": null, "id": 7071, "time": "2001-10-23T13:17:30Z", "creator": "rami.hanninen@davisor.com", "creation_time": "2001-10-23T13:17:30Z", "is_private": false, "text": "Well, my \"lengthy\" operation succeeds if SSI operations have been disabled, and\nfails if SSI is enabled. The problem may of course be in my own application too,\nbut between the successfull and failed tests cases, the only thing that is\ndifferent is that wether SSI has been enabled or not. The same application has\nalso proven to work in other production environments, so I have some confidence\non it. On the other hand, Tomcat4 is a new and different runtime environment, so\nit may be that some old problem is just now manifesting itself in my\napplication.\n\nAnyway, the SSI servlet must surely open a stream to the material it is about to\ninclude into a master document, so the big question is, does the servlet ever\nclose that stream explicitly? And does it do it right, like this:\n\nInputStream in = someOpenOperation();\n\ntry\n{\n  :\n}\nfinally // Close the stream even if something goes wrong\n{\n  in.close();\n}\n\nAnyway, to make sure, I also run some 'lsof' tests. Without SSI servlets, my\nJava application kept about 4.000 open files at any given time. However, with\nSSI servlets enabled, the number started to grow. Although the garbage collertor\n(or something) seemed to periodically close files, the average number of open\nfiles soon exceeded 10.000, and the peak values grew near 80.000. And after some\ntime, the peak value hit 100.000, halting effectively all server services. After\nthe test, the number remained high until Tomcat was restarted, and all was well\nagain.\n\nHere is a sample of the number of open files data, taken at 2 second intervals,\nand at the moment the \"Too many files\" errors started to appeared. As you see,\nthere is some cyclic behaviour, but the average increased all the time.\n\n  36351\n  43159\n  49996\n  57696\n  62826\n  67088\n  77168\n  88502\n  96290\n 110256\n 100572\n  44237\n  48503\n  56869\n  63395\n  71967\n  80834\n  87933\n 100460\n 115717\n 118438\n 118438\n 118424\n 118438\n 118429\n 118438\n\nAs a final minor detail, I should propably mention that I'm mapping the SSI\nservlet to *.html file name pattern. This is propably not significant, but you\nnever know ...\n"}, {"count": 4, "tags": [], "creator": "bip@apache.org", "attachment_id": null, "is_private": false, "id": 7080, "time": "2001-10-23T17:18:50Z", "bug_id": 4361, "creation_time": "2001-10-23T17:18:50Z", "text": "I just commited some code that could very well fix the problem your having. You\nwere right about not closing some of the streams. Even though the \ngarbagcollector\nshould it takes a while for it to do it and is generally ugly to keep unused \nopen\nstreams.\n\nPlease try the upcoming nightly build and let me know if the problem persists.\nAnd about mapping SSI to *.html, that's not an optional solution since it adds \noverhead to each request.(It needs to scan every HTML file served)."}, {"count": 5, "text": "The file leaking problem appears to have been solved in the latest\nservlets-ssi.jar :-)\n\nThis was the last SSI related bug I have to report for now. Thank you Bip for\nyour time and contributions.\n", "bug_id": 4361, "attachment_id": null, "id": 7100, "time": "2001-10-24T07:47:45Z", "creator": "rami.hanninen@davisor.com", "creation_time": "2001-10-24T07:47:45Z", "tags": [], "is_private": false}]