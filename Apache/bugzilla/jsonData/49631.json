[{"count": 0, "tags": [], "bug_id": 49631, "is_private": false, "text": "I've written a custom extension to the DatabaseResourceProvider that allows our application to store some subset of files in the database.  In order to get a db connection I'm trying to lookup a datasource via JNDI:\n\n\tprivate Connection getConnection() throws SQLException, NamingException {\t\t\n\t\tContext initContext = new InitialContext();\n\t\tSystem.out.println(\"here\");\n\t\tDataSource ds = (DataSource)initContext.lookup(\"java:/comp/env/\"+JDBC_SYSTEM_JNDI);\n\t\treturn ds.getConnection();\n\t}\n\nI've found that in some cases it does get the datasource and in others it throws a namingexception that the resource was not found.  I debugged it out and found that in certain cases it works if the resources is being requested through a servlet or JSP call but when its a direct request for a static file such as an image or CSS file it fails.  In those failing cases I've found that its getting the server naming context and not the web app context.  \n\nMore digging into the tomcat naming stuff showed that the way it determines the naming context to use is derived by the current threads class loader.  Looks like the class loader is not getting replaced with the web apps class loader in the case of static resource serving. \n\nCould something be added to make sure the class loader for the thread is always updated to the current web app class loader before calling into the DirContext classes?", "id": 138612, "time": "2010-07-21T15:02:06Z", "creator": "matt.helgren@gmail.com", "creation_time": "2010-07-21T15:02:06Z", "attachment_id": null}, {"attachment_id": 25793, "tags": [], "bug_id": 49631, "text": "Created attachment 25793\nstack trace\n\nThis is a stack trace for the request that fails to find the jndi context entry.", "count": 1, "id": 138621, "time": "2010-07-21T17:58:25Z", "creator": "matt.helgren@gmail.com", "creation_time": "2010-07-21T17:58:25Z", "is_private": false}, {"count": 2, "tags": [], "bug_id": 49631, "is_private": false, "text": "Looking into this a bit more I noticed that when the JNDI lookup fails, its calling my FileDirContext without having gone through the default servlet (see attached stack trace).   Looks like CoyoteAdapter.postParseRequest ends up probing for the file.  I also noticed that since the file is not found it causes the ProxyDirContext to cache that the file does not exist for a period of time which might be causing the CoyoteAdpater to then not find the file subsequently through the default servlet.", "id": 138622, "time": "2010-07-21T18:01:15Z", "creator": "matt.helgren@gmail.com", "creation_time": "2010-07-21T18:01:15Z", "attachment_id": null}, {"count": 3, "attachment_id": null, "creator": "markt@apache.org", "is_private": false, "id": 140264, "time": "2010-09-28T08:21:05Z", "bug_id": 49631, "creation_time": "2010-09-28T08:21:05Z", "tags": [], "text": "The probing for the file is the result of the code that handles welcome files.\n\nI am reluctant to switch the TCCL in this code due to the potential performance impact.\n\nWhat should work is obtaining the DataSource once when the custom FileDirContext starts and then caching that reference. It should also make your FileDirContext a little faster. If you need further help with your custom FileDirContext then the users list is the best place to ask."}]