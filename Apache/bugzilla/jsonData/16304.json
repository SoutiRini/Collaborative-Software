[{"count": 0, "tags": [], "bug_id": 16304, "is_private": false, "id": 29806, "attachment_id": null, "creator": "chrispesarchick@westfieldgrp.com", "creation_time": "2003-01-21T19:13:14Z", "time": "2003-01-21T19:13:14Z", "text": "The problem seems to be the HashTree which is a HashMap.  This is a major\nproblem when there are multiple threads and the script is large.  If a thread\nshould get this error then the thread is done.  Then the test will not be\ncorrect.  I tried a few things.   I tried synchronizing on the HashTree in\nTestCompiler, but that didn't work. I then went to 'public void\ntraverse(HashTreeTraverser visitor)' in HashTree. I tried synchronizing on\nlist() and visitor that didn't work.  Then I created a static object and\nsynchronized the object and that has been working.  This slows down the\nperformance of setting up the test before it executes the test script.  Since I\ndon't have a full understanding of the program, my guess there is a better\nplace.  If anybody has another suggestion, let me know and I will give it a try.\n\nThis happens on NT and Linux.\n\njava.util.ConcurrentModificationException\n     at java.util.HashMap$HashIterator.nextEntry(HashMap.java:750)\n     at java.util.HashMap$KeyIterator.next(HashMap.java:786)\n     at\n\norg.apache.jmeter.threads.TestCompiler.hasFunctions(TestCompiler.java:498)\n     at\n\norg.apache.jmeter.threads.TestCompiler.saveSamplerConfigs(TestCompiler.java:\n\n 196)\n     at\n\norg.apache.jmeter.threads.TestCompiler.subtractNode(TestCompiler.java:158)\n     at\n org.apache.jorphan.collections.HashTree.traverseInto(HashTree.java:908)\n     at\n org.apache.jorphan.collections.HashTree.traverseInto(HashTree.java:902)\n     at\n org.apache.jorphan.collections.HashTree.traverseInto(HashTree.java:902)\n     at\n org.apache.jorphan.collections.HashTree.traverseInto(HashTree.java:902)\n     at\norg.apache.jorphan.collections.HashTree.traverse(HashTree.java:886)\n     at org.apache.jmeter.threads.JMeterThread.run(JMeterThread.java:125)\n     at java.lang.Thread.run(Thread.java:536)"}, {"count": 1, "text": "I just committed a change to org.apache.jmeter.testelement.AbstractTestElement\nthat changed the new HashMap() to Collections.synchronizedMap(new HashMap()).  I\nthink this should help fix this problem, and not slow things down overly much.\n\nIt's still not perfect, since to do a synchronized map correctly, you're\nsupposed to manually synchronize iteration code, but since the Map is a private\nvariable of AbstractTestElement, this is currently possible in other classes. \nOne way to fix this would be to add a method to the TestElement interface, such as:\n\ngetSyncObject()\n\nwhich would return the synchronized Map, so developers could write code such as:\n\nIterater iter = testElement.getPropertyNames().iterator();\nsynchronized(testElement.getSyncObject())\n{\n   while(iter.hasNext())\n   {\n      Object item = iter.next();\n      //do stuff safely\n   }\n}\n\nIt seems inelegant to me, but I'm not sure what a good alternative is.  Using\nHashtable is not viable, since Map's can hold null values, and Hashtables can't,\nand JMeter saves null values.", "bug_id": 16304, "attachment_id": null, "id": 29819, "time": "2003-01-21T22:20:00Z", "creator": "mstover1@apache.org", "creation_time": "2003-01-21T22:20:00Z", "tags": [], "is_private": false}, {"count": 2, "tags": [], "bug_id": 16304, "attachment_id": null, "id": 31877, "time": "2003-02-24T20:43:19Z", "creator": "chrispesarchick@westfieldgrp.com", "creation_time": "2003-02-24T20:43:19Z", "is_private": false, "text": "I retried this with 1.8.1 and the problem is still there."}]