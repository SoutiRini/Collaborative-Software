[{"count": 0, "tags": [], "bug_id": 8092, "is_private": false, "text": "The Bug\n=======\n\nTo reproduce the bug, deploy the attached war file and \nrequest \"/jsp/including.jsp\". What you get is the JSP source code of the \nfile \"test.jsp\". This behaviour is due to problems with chained includes and \nforwards (detailed explanation below).\n\n\nThe Analysis\n============\n\nI'll first explain the problem with a more simple test case than that described \nabove (I'll come back to the other one later): A servlet (\"BugtestServlet\") \nincludes another servlet (\"IncludedServlet\") using \nServletContext.getRequestDispatcher. Now IncludedServlet forwards \nto \"/jsp/forwarded.jsp\". So in summary we have:\n\n\"/BugtestServlet\" --- includes ---> \"/IncludedServlet\" --- forwards to --->\n\"/jsp/forwarded.jsp\"\n\nNow if you request \"/BugtestServlet\", Tomcat returns an exception message\nsaying the file \"/IncludedServlet\" cannot be found. Note that this problem\ndoes not occur when using Orion or Resin servlet engines.\n\nThe problem originates from chapter 8 of the Servlet 2.3 spec. In short, it \nsays that\n\n- in case of a forward, the resource that is forwarded to sees the servlet path \n(via getServletPath) used in the request dispatcher\n- in case of an include, the included resource sees the original servlet path \n(e.g. \"/BugtestServlet\") and can retrieve the path used in the request \ndispatcher (e.g. \"/IncludedServlet\") via special request attributes\n\nThe problem starts when Jasper's JspServlet tries to determine which page to \ndeliver. It cannot simply use getServletPath() since this will return the \noriginal path when doing an include. Thus, it checks \nif \"javax.servlet.include.servlet_path\" is present as a request attribute. If \nit is, JspServlet uses it instead of getServletPath(). This works in simple \ncases (e.g. a Servlet including a JSP), but fails for the bugtest webapp. \nExplanation:\n\n- in IncludedServlet, getServletPath() returns \"/BugtestServlet\" and \nthe \"javax.servlet.include.servlet_path\" attribute is \"/IncludedServlet\"\n- in JspServlet (indirectly invoked by forwarding to \"/jsp/forwarded.jsp\"), \ngetServletPath() returns \"/jsp/forwarded.jsp\" and \nthe \"javax.servlet.include.servlet_path\" attribute is \"/IncludedServlet\"\n- since the additional request attribute is present, JspServlet thinks it has \nto use it instead of getServletPath()\n- processing \"/IncludedServlet\" as a JSP fails with a FileNotFoundException\n\nThis is only the harmless case. If you replace the servlets with JSPs, you can \neasily produce endless forwarding loops or make Tomcat serve JSP source code \n(see test case mentioned at the beginning). The latter occurs if you forward to \nan HTML page (or another resource of type text/*) because the default servlet \nis invoked (since we have a static resource) but the file send to the client is \nthe JSP from which the forward originates.\n\n\nProposed Solution\n=================\n\nI would suggest to add a request \nattribute \"org.apache.catalina.actual_servlet_path\" that _always_ contains the \npath used when retrieving a request dispatcher. This way, the correct path \ncould be determined no matter whether include or forward is used:\n\n- check if \"org.apache.catalina.actual_servlet_path\" is present; if so, use it \nas the path for accessing resources etc.\n- if the attribute is not present, fall back to the standard behaviour (i.e. \ncheck for \"javax.servlet.include.servlet_path\" and use getServletPath if this \nis not present)\n\nI've already tested this with JspServlet, and it works fine. However, to be \nconsistent, several source files would have to be changed, for example:\n\n- DefaultServlet.java (necessary to solve the \"forward to html\" problem \ndescribed above)\n- HttpRequestBase.java since it uses \"javax.servlet.include.servlet_path\" to \nconvert a request-relative path to a context-relative one (currently, this \nprobably failes within include/forward chains)\n- a bunch of other files (basically all that deal with the case of an include \nspecifically)\n\nAlso, the problem is not limited to \"javax.servlet.include.servlet_path\" but \napplies to all request attributes set in an include. For all of these, \ncounterparts that reflect the correct path should be introduced. The best \nsolution would be if the spec mandated such attributes, \ne.g. \"javax.servlet.actual_path.servlet_path\" etc. Should I write to servletapi-\nfeedback@eng.sun.com about it or is there a better place? Or maybe I'm missing \nsomething and the issue can be solved more elegantly?\n\n\nFinal remarks\n=============\n\nIf I receive positive feedback on this, I'll happily send a comprehensive \npatch. Until now, I've only added an attribute for the servlet path (and not \npath info etc.) and a check for it in JspServlet.\n\n\nThanks for your time\n\nPS Maybe this bug is also present in Tomcat 3.3 (haven't tested that).", "id": 13594, "time": "2002-04-15T08:18:25Z", "creator": "Andreas.Junghans@fh-karlsruhe.de", "creation_time": "2002-04-15T08:18:25Z", "attachment_id": null}, {"count": 1, "attachment_id": 1575, "bug_id": 8092, "is_private": false, "id": 13596, "time": "2002-04-15T08:19:54Z", "creator": "Andreas.Junghans@fh-karlsruhe.de", "creation_time": "2002-04-15T08:19:54Z", "tags": [], "text": "Created attachment 1575\nTest case"}, {"count": 2, "tags": [], "bug_id": 8092, "is_private": false, "id": 13599, "creation_time": "2002-04-15T08:53:58Z", "time": "2002-04-15T08:53:58Z", "creator": "remm@apache.org", "text": "This is not a security issue (please don't file it with a title sounding like a \nsecurity issue). Dynamically included content will never be interpreted as JSP \nsource, so what you see there is normal.\nI'd like the opinion of the spec gurus on the rest of this issue.", "attachment_id": null}, {"count": 3, "tags": [], "creator": "Andreas.Junghans@fh-karlsruhe.de", "attachment_id": null, "text": "Sorry, I don't agree. This _is_ a security issue.\n\n> Dynamically included content will never be interpreted as JSP \n> source\n\nI don't understand what you mean here. Let's examine a simple example:\n\n\"x.jsp\" --- includes ---> \"y.jsp\" --- includes ---> \"z.html\"\n\nWith a chain like this, Tomcat behaves correctly. Now consider the following:\n\n\"x.jsp\" --- includes ---> \"y.jsp\" --- forwards to ---> \"z.html\"\n\nThe result is that the client browser receives the _unprocessed contents_ \n(including all Java scriptlets) of \"y.jsp\" (sorry, I think the term \"source \ncode\" I used before was a bit misleading). I think it is perfectly legal to \nchain include and forward calls in this way, and it comes as a nasty surprise \nwhen you suddenly see an unprocessed JSP (which may contain sensitve \ninformation!) in the browser. We had this in our application: A part that \nworked fine before suddendly didn't work anymore when it was included via \nRequestDispatcher.\n\nAs stated before, both Orion and Resin (and I'm pretty sure most other servlet \nengines as well) don't show this issue.", "id": 13601, "time": "2002-04-15T09:13:03Z", "bug_id": 8092, "creation_time": "2002-04-15T09:13:03Z", "is_private": false}, {"count": 4, "attachment_id": null, "creator": "remm@apache.org", "text": "Thanks to Bill's help, it has been fixed in the HEAD branch.\nApparently, he understood the issue better than I did :)\nAn attempt will be made to port this to the 4.0.x branch.", "id": 13874, "time": "2002-04-17T16:58:10Z", "bug_id": 8092, "creation_time": "2002-04-17T16:58:10Z", "tags": [], "is_private": false}]