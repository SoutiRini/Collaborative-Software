[{"count": 0, "tags": [], "bug_id": 53785, "text": "Password-based authentication for the built-in realms can currently use three digestion algorithms from the java.security.MessageDigest class (SHA, MD2, or MD5).  All of these are out of date*, and each Realm implementation does its own comparison of the password to the saved digest.\n\n[*It's not clear whether Java's SHA is SHA-1 or one of the SHA-2 algorithms.  SHA-1 is obsolete;  SHA-2, potentially less so.]\n\nI recently created my own custom Realm in order to support bcrypt.  While I do not claim that bcrypt is the right algorithm for everyone, it is a much better default than the current built-in options-- so Tomcat should offer it.\n\nHowever, rather than being a general purpose hash function, bcrypt a one-way hash designed for passwords.  The salt is built into the hash in such a way that it can't be extracted.  That is to say, you can't say:\n\n    if ( bcrypt.hash(password1) == bcrypt.hash(password2) )\n        log(\"Passwords match\");\n\nbecause every time you hash a password, you get a different result.  This is a security feature, since novices won't mismanage the salt.  Instead, you call:\n\n    String hash = BCrypt.hashpw(\"hello\"); // To hash, not to check\n\n    if (BCrypt.checkpw(passwordFromLoginForm, savedPasswordHash))\n        log(\"Passwords match\");\n\nThis example uses the JBCrypt implementation at http://www.mindrot.org/projects/jBCrypt/\n\nLike I said, I don't think BCrypt is the right solution for every user. See http://www.unlimitednovelty.com/2012/03/dont-use-bcrypt.html and http://security.stackexchange.com/questions/4781/do-any-security-experts-recommend-bcrypt-for-password-storage\n\nAlso note that NIST will recommend a new secure hashing algorithm soon ( http://csrc.nist.gov/groups/ST/hash/timeline.html ) although that will be a general purpose cryptographic hash function, not an out-of-the-box password hash format like bcrypt.\n\n\nInstead, I propose that we make three (or four) changes:\n\n1. Update all applicable subclasses of RealmBase to call a new method, RealmBase.checkDigest(String credentials, String savedHash), instead of each implementation doing a string comparison against the realms.\n\n2. Implement RealmBase.checkDigest with the following rules:\n   a.  If digest == null, implement the current string comparison.\n   b.  If digest is \"SHA\", \"MD2\", or \"MD5\", compare with the current algorithm.\n   c.  If digest is the name of a Java class, try calling checkPassword(credentials, savedHash) on the class, both as a static method and on an instance created with no constructor arguments.\n \n3. (Depending on legal issues) Bundle Tomcat with JBCrypt, thus providing a secure hash out of the box.\n\n4. Write unit tests and documentation and update Tomcat 7+ with the new code.  Of course, we could jump ahead and implement this in Tomcat 8, since this is a public API change.\n\nI will check with my boss to see if I can take the time to implement this.  Of course, I'd prefer to get feedback before I go ahead with it.", "id": 161755, "time": "2012-08-27T22:20:40Z", "creator": "david@leppik.net", "creation_time": "2012-08-27T22:20:40Z", "is_private": false, "attachment_id": null}, {"count": 1, "tags": [], "bug_id": 53785, "attachment_id": null, "id": 161756, "time": "2012-08-27T22:22:30Z", "creator": "david@leppik.net", "creation_time": "2012-08-27T22:22:30Z", "is_private": false, "text": "Should have said under step 3:  \"Bundle BCrypt with Tomcat\" rather than the other way around."}, {"count": 2, "tags": [], "bug_id": 53785, "attachment_id": null, "text": "Tomcat supports the use of any MessageDigest provided by the JRE. Additional algorithms may be supported by adding 3rd party security providers to the JRE.\n\nFYI:\n- as far as the Sun JRE is concerned, SHA is an alias for SHA-1.\n- the MessageDigests supported by the latest Sun JDKs for Java 5 to Java 7 are:\nMD2, MD5, SHA-1, SHA-256, SHA-384, SHA-512\n\nOne open source provider is BouncyCastle. It certainly provides additional digests although I haven't investigated how secure they are.\n\nI do not see the point in adding bloat to Tomcat to provide a feature that the JRE already provides.", "id": 161757, "time": "2012-08-27T22:42:00Z", "creator": "markt@apache.org", "creation_time": "2012-08-27T22:42:00Z", "is_private": false}, {"count": 3, "tags": [], "bug_id": 53785, "text": "I think you miss one important point, namely that Tomcat only supports bidirectional hashes, whereas modern password hash functions are one-way.\n\nOne workaround is for the user to provide salt (which currently isn't possible--see Bug 51966), but that is more error prone and arguably less secure than having the salt baked into the password algorithm.\n\nUsing a different MessageDigest does not fix this.\n\n\nBut as a bare minimum, could we at least change the documentation to direct novice users toward SHA-256 or better, since it currently implies that SHA, MD2, and MD5 are the only options?", "id": 161775, "time": "2012-08-28T14:45:33Z", "creator": "david@leppik.net", "creation_time": "2012-08-28T14:45:33Z", "is_private": false, "attachment_id": null}, {"count": 4, "tags": [], "bug_id": 53785, "text": "> Tomcat only supports bidirectional hashes\n\nI am sure that you are wrong in the above statement. If I missed something, please define what you mean by \"bidirectional\".\n\nAll cryptographic hash functions supported by Tomcat are one-way (as a hash function should be).", "id": 161780, "time": "2012-08-28T18:04:52Z", "creator": "knst.kolinko@gmail.com", "creation_time": "2012-08-28T18:04:52Z", "is_private": false, "attachment_id": null}, {"count": 5, "tags": [], "bug_id": 53785, "text": "Ignoring several of David's foolish statements (one-way hashing versus bi-directional, bcrypt using non-retrievable salts, etc.), I do think this enhancement request has merit.\n\nDavid is right that merely using a \"better\" hash algorithm (i.e. SHA-65536) isn't the same as using a so-called \"password-hashing algorithm\" like bcrypt, scrypt, etc.: those algorithms use built-in random salts and iterations of the base algorithm (which is something like SHA-256) and do require more than just \"hashing\" the incoming password and comparing it to the stored hash.\n\nOne could also argue that this kind of thing can be implemented outside of Tomcat by merely writing a custom Realm, which is certainly true, but the existing API doesn't lend itself to extensibility (other than to the realms currently built-into Tomcat). I think there are some changes we could make to the code to allow a bcrypt-based implementation to bemuch easier to built.\n\nFor instance: instead of a method that hashes the attempted-password, retrieves the known-hashed-password and comparing the two, perhaps we could have a method that retrieves the known-hashed-password and then calls a method to \"hashAndCompare\" or something similar. This would allow a bcrypt-based implementation to merely override this method and use the bcrypt tools to compare (for some definition of \"compare\") an attempted-password directly to the known-hashed-password while the \"standard\" implementation could perform the existing MessageDigest-based hashing and String-comparison.\n\nThis then brings up the fact that RealmBase seems like the most reasonable place to do all of this, except that nobody really wants to extend RealmBase because the real action is in the realm implementations (DataSourceRealm, JNDIRealm, etc.). If the \"hashing stuff\" could be isolated from RealmBase, then we could make it pluggable such that users could use a DataSourceRealm or JNDIRealm but also plug-in a bcrypt implementation for the password-hashing work.\n\nI'd like to reopen this unless there are any strong objections.", "id": 161785, "attachment_id": null, "creator": "chris@christopherschultz.net", "creation_time": "2012-08-28T20:27:51Z", "time": "2012-08-28T20:27:51Z", "is_private": false}, {"count": 6, "tags": [], "creator": "david@leppik.net", "attachment_id": null, "text": "> > Tomcat only supports bidirectional hashes\n>\n> I am sure that you are wrong in the above statement. If I missed something, \n> please define what you mean by \"bidirectional\".\n>\n> All cryptographic hash functions supported by Tomcat are one-way (as a hash \n> function should be).\n\nBidirectional in the sense that the same function is used for password checking and password hashing.\n\nI am making a distinction between the underlying general-purpose hash algorithm and the password hashing algorithm.  Although password hashing algorithms are built on top of general-purpose hash algorithms, they may include additional steps, such as salting.\n\nA password API which includes salt is unidirectional in the sense that the same function is not used both for encryption and decryption.  Thus it is not possible to do a string comparison between two hashes in order to validate a password, as is done by Tomcat.\n\nSince Tomcat does password checking like this:\n\n  validated = (digest(credentials).equals(dbCredentials));\n\nyou cannot use a system such as bcrypt (or any API with built-in salt) which has a separate function for validation.\n\nMind you, bcrypt is built on top of Blowfish, but from a user's perspective it is more than just a front end to Blowfish.  A bcrypt hash includes the Blowfish hash, the salt, and the cost (log of number of iterations)-- all of which are required for validation.\n\nThe cost is a core feature of bcrypt:  the user can specify how expensive password checking is, and therefore how long brute force password guessing will take.\n\nThere is another password hashing algorithm, scrypt, which defines cost in terms of time and memory.  You'll also hear about PBKDF2 as well, although it is not so much an API as recommended procedures for password encryption (described in RFC 2898).\n\n\nThe point is that to do proper password checking you can't just do this (in JDBCRealm):\n\n  validated = (digest(credentials).equals(dbCredentials));\n\nas it doesn't work with salt;  nor can you do this:\n\n  validated = (digest(credentials, salt).equals(digest(dbCredentials, salt)));\n\nas it doesn't work with a cost function; and while you could do this:\n\n  validated = (digest(credentials, salt, cost).equals(digest(dbCredentials, salt, cost)));\n\nthat's just getting silly-- and it won't work anyway since PBKDF2 requires that you specify an additional algorithm.  It's a lot more general and future-proof to just do this instead:\n\n  validated = validate(credentials, dbCredentials);", "id": 161786, "time": "2012-08-28T20:31:56Z", "bug_id": 53785, "creation_time": "2012-08-28T20:31:56Z", "is_private": false}, {"count": 7, "tags": [], "bug_id": 53785, "text": "(In reply to comment #5)\n> This then brings up the fact that RealmBase seems like the most reasonable\n> place to do all of this, except that nobody really wants to extend RealmBase\n> because the real action is in the realm implementations (DataSourceRealm,\n> JNDIRealm, etc.). If the \"hashing stuff\" could be isolated from RealmBase,\n> then we could make it pluggable such that users could use a DataSourceRealm\n> or JNDIRealm but also plug-in a bcrypt implementation for the\n> password-hashing work.\n> \n> I'd like to reopen this unless there are any strong objections.\n\nI have no issue with refactoring to make Realms easier to extend (for better digests or for any other reason) subject to the usual issues regarding backwards compatibility.\n\nI not so keen on including jBCrypt (or any other library) without a much stronger demand for it.", "id": 161787, "time": "2012-08-28T20:45:58Z", "creator": "markt@apache.org", "creation_time": "2012-08-28T20:45:58Z", "is_private": false, "attachment_id": null}]