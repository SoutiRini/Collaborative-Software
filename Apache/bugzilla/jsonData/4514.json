[{"attachment_id": null, "tags": [], "bug_id": 4514, "text": "I returned a big string value by SOAP. The client side takes 4 minutes with \n100% CPU until returning from getNodeValueString method.\nThe problem is that the code is using StringBuffer.insert for each chunk (line \n1007). This is very unefficient because StringBuffer.insert cause shifting and \nrecopy of the buffer for each chunk. When the value is big (I had 70,000 \nchunks) - the function don't return immediatly (this takes me 4 minutes with \n100% CPU on Pentium III 500).\nI fixed it by using a vector to save each chunk, then iterate the vector \nbackward and use StringBuffer.append. The function return immediatly!\nHere is the fixed method: (I ADD \"//////////////////\" before and after each \nchange).\n\t\t/**\n\t\t * Returns the value of the given node.\n\t\t * @param free True to free the string index.\n\t\t */\n\t\tpublic String getNodeValueString(int nodeIndex, boolean free) {\n\n\t\t\t\tif (nodeIndex == -1) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tint chunk = nodeIndex >> CHUNK_SHIFT;\n\t\t\t\tint index = nodeIndex & CHUNK_MASK;\n\t\t\t\tint valueIndex = free\n\t\t\t\t\t\t\t\t\t\t\n\t ? clearChunkIndex(fNodeValue, chunk, index)\n\t\t\t\t\t\t\t\t\t\t\n\t : getChunkIndex(fNodeValue, chunk, index);\n\t\t\t\tif (valueIndex == -1) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tint type  = getChunkIndex(fNodeType, chunk, \nindex);\n\t\t\t\tif (type == Node.TEXT_NODE) {\n\t\t\t\t\t\tint prevSib = getRealPrevSibling\n(nodeIndex);\n\t\t\t\t\t\tif (prevSib != -1 && getNodeType\n(prevSib, false) == Node.TEXT_NODE) {\n\t\t\t\t\t\t\t\tStringBuffer \nstr = new StringBuffer();\n\t\t\t\t\t\t\t\n\t////////////////////////////////\n\t\t\t\t\t\t\t\t// The previous \nimplementation was using str.insert\n\t\t\t\t\t\t\t\t// It was very \nnot efficient\n\t\t\t\t\t\t\t\t// I save each \nchunk string in a vector then use str.append\n\t\t\t\t\t\t\t\tVector \nchunkStrings = new Vector();\n\t\t\t\t\t\t\t\tchunkStrings.add\n(fStringPool.toString(valueIndex));\n\t\t\t\t\t\t\t\n\t////////////////////////////////\n\t\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\t\t\n\tchunk = prevSib >> CHUNK_SHIFT;\n\t\t\t\t\t\t\t\t\t\n\tindex = prevSib & CHUNK_MASK;\n\t\t\t\t\t\t\t\t\t\n\tvalueIndex = getChunkIndex(fNodeValue, chunk, index);\n\t\t\t\t\t\t\t\t\t\n\t// NOTE: This has to be done backwards because the\n\t\t\t\t\t\t\t\t\t\n\t//       children are placed backwards.\n\n\t\t\t\t\t\t\t\t\t\n\t////////////////////////////////\n\t\t\t\t\t\t\t\t\t\n\t//str.insert(0, fStringPool.toString(valueIndex));\n\t\t\t\t\t\t\t\t\t\n\tchunkStrings.add(fStringPool.toString(valueIndex));\n\t\t\t\t\t\t\t\t\t\n\t////////////////////////////////\n\t\t\t\t\t\t\t\t\t\n\tprevSib = getChunkIndex(fNodePrevSib, chunk, index);\n\t\t\t\t\t\t\t\t\t\n\tif (prevSib == -1) {\n\t\t\t\t\t\t\t\t\t\t\n\t\tbreak;\n\t\t\t\t\t\t\t\t\t\n\t}\n\t\t\t\t\t\t\t\t} while \n(getNodeType(prevSib, false) == Node.TEXT_NODE);\n\t\t\t\t\t\t\t\n\t////////////////////////////////\n\t\t\t\t\t\t\t\t// backwards \niteration and append each string to stringBuffer\n\t\t\t\t\t\t\t\tfor (int \ni=chunkStrings.size()-1; i>=0; i--) {\n\t\t\t\t\t\t\t\t\n\tstr.append((String)chunkStrings.elementAt(i));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\tchunkStrings.clear();\n\t\t\t\t\t\t\t\n\t////////////////////////////////\n\t\t\t\t\t\t\t\treturn \nstr.toString();\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn fStringPool.toString(valueIndex);\n\n\t\t} // getNodeValueString(int,boolean):String\n\nRegards,\n    Stephane Dahan", "count": 0, "id": 7303, "time": "2001-10-30T03:46:50Z", "creator": "stephane@quiver.com", "creation_time": "2001-10-30T03:46:50Z", "is_private": false}, {"count": 1, "tags": [], "text": "Thanks a lot for providing the fix! \nI've applied it with minor modifications. Please, pick up the latest vs from CVS \nand verify the fix.\n\n", "attachment_id": null, "id": 7651, "creator": "elena@apache.org", "time": "2001-11-07T10:16:58Z", "bug_id": 4514, "creation_time": "2001-11-07T10:16:58Z", "is_private": false}, {"count": 2, "tags": [], "text": "*** Bug 4432 has been marked as a duplicate of this bug. ***", "is_private": false, "id": 8217, "creator": "lehors@apache.org", "time": "2001-11-23T09:28:08Z", "bug_id": 4514, "creation_time": "2001-11-23T09:28:08Z", "attachment_id": null}]