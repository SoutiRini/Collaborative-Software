[{"count": 0, "tags": [], "bug_id": 42987, "attachment_id": null, "is_private": false, "id": 105994, "time": "2007-07-27T05:23:42Z", "creator": "werner.baumann@onlinehome.de", "creation_time": "2007-07-27T05:23:42Z", "text": "When Apache cannot create an etag reliably, due to insufficient time resolution,\nit returns a weak etag. When a client uses this weak etag in a conditional\nrequest, it will *never* match. (see test cases)\n\nAccording to RFC 2616, 13.3.3, a weak etag should match, even if the resource\nhas changed, as long as the changes are semantically insignificant.\nContrary to this, apache-style weak etags have the meaning \"never match\". This\nweak etags are completely useless in any cache validation. No etag would be just\nas good, except for the missing confusion.\n\nFor standard HTTP: Apache should send *no* etag or a valid one.\n\nFor mod_dav: Strong etags are essential for any caching client. As long as the\nserver does not edit the content of resources, it should always send a valid\nstrong etag, even if this affects performance. It should also return a strong\netag in a response to PUT."}, {"count": 1, "tags": [], "bug_id": 42987, "attachment_id": 20556, "is_private": false, "id": 105995, "time": "2007-07-27T05:26:36Z", "creator": "werner.baumann@onlinehome.de", "creation_time": "2007-07-27T05:26:36Z", "text": "Created attachment 20556\nconditional GET with apache-style weak etag\n\nThese test cases show that a apache-style weak etag in a conditional GET will\nnever match. An unconditional GET without etag would do the same."}, {"count": 2, "tags": [], "creator": "werner.baumann@onlinehome.de", "attachment_id": null, "id": 112241, "time": "2007-12-27T12:51:36Z", "bug_id": 42987, "creation_time": "2007-12-27T12:51:36Z", "is_private": false, "text": "I am referring to\nhttp://mail-archives.apache.org/mod_mbox/httpd-dev/200710.mbox/%3c470E9A9F.8020202@pearsoncmg.com%3e\nand would like to propose this solution.\n\nPrecondition: Getting a strong Etag immediately (withing 1 second) after\nchanging a resource is not important for many applications of HTTP, but is very\nimportant for WebDAV. For this reason the bug must be fixed differently in\nap_make_etag() and in mod_dav/mod_dav_fs.\n\nApache core, ap_make_etag()\n---------------------------\nIf the file mtime is within the same second as the request time:\n- do not create and not send an etag\n- send header Cache-Control: no-cache (to prevent a fallback to using\n  Last-Modified for cache validation)\n\nNote: There are no backward compatibility issues with dropping the weak etag.\nThe meaning of Apache-style weak etags is \"never-matching-etag\". It's single\neffect is, that a cache might store the entity, only to drop it on the next request.\n\nBut this misuse of weak etags has the effect to encourage/force clients to\nimplement handling of weak etags in a way that violates the RFC and might cause\nproblems whenever someone uses weak etags in an RFC-compliant way.\n\nWebDAV (mod_dav_fs)\n-------------------\nWebDAV-clients need a strong etag immediately after a PUT to avoid a lot of\ntraffic. To avoid race conditions, this strong etag must be returned in the\nresponse to the PUT-request.\nBecause of the limited time resolution of many file systems this can not be\ncreated with information from the stored file alone. Using some kind of hash\nfunction would consume to much CPU-power and does not guarantee really strong\netags. So I vote for storing the strong etag as a WebDAV-property.\n\nThis solution imposes a restriction on the administrator of the server:\n- resources must only be changed via WebDAV (to not bypass the etag\n  maintainance of mod_dav_fs)\n- if the administrator feels the need to change the repository via the local\n  file system, serving PUT-requests must be stopped one second before, and\n  only be restarted one second after the changes are made.\n\nThis restrictions may not be acceptable in some cases, so a configuration option\nis needed, to turn this off and fall back to ap_make_etag().\n\nTo be reliable and to catch most of the errors of lazy administrators, I propose\nthis logic:\n\n1. The etag is stored as a WebDAV-property. It consists of two parts.\n   Part 1 is the same as created by ap_make_etag().\n   Part 2 is a simple counter. It is set to 0, when the mtime changes. If\n   the file is changed without change in mtime, it is incremented.\n\n2. on PUT-requests (and other requests that change the file)\n   - get the old etag property\n   - change the file\n   - create Part 1 of the new etag\n   - compare the new and the old Part 1:\n     if they are equal: increment Part 2\n     otherwise take the new Part1 and append Part 2 with value 0\n\n3. on GET, HEAD, PROPFIND and other requests that don't change the file\n   (this also applies when checking If-Match and If-None_match headers)\n   - get the stored etag property\n   - create Part 1 from the file\n   - compare Parts 1; if they are different replace the etag property by the\n     new Part 1 with Part 2 = 0\n   This will catch most of the cases, where resources have been changed via\n   the local file system.\n\nThere is a small chance to get a wrong etag, if\n- a file has been changed via WebDAV\n- after this, but within the same second, the file is changed via the local\n  file system (neglecting the good advise given in that fine manual)\n\nAdditionally:\nWhen strong etags are enabled this way for mod_dav_fs, responses to PUT requests\nshould always include Etag and Last_modified headers.\n\nTo make clear, why this is important for WebDAV:\nAt the moment, a WebDAV-Client, that wants to save a file and have the file\navailable after that, has to\n- send a LOCK-request\n- do a HEAD-request to check for changes or existence\n- send the file via PUT\n- retrieve the file via GET (unconditional)\n- UNLOCK\nThat's five requests, and there is still a potential danger, as locks are\nnot guaranteed to work; so the file might be changed between HEAD and PUT.\n\nHaving proper etags and working If-Match and If-None-Match, this transaction\nwould be atomic: just one PUT with If-Match or If-None-Match header, and the\nclient would have a valid strong etag for use in the next request.\n\nI am not able, to prepare a patch. It would take me at least 3 month to learn\nenough about apche and another three month to understand and change mod_dav_fs.\n\nWerner\n"}, {"count": 3, "tags": [], "text": "It's not true that the meaning of a weak etag sent by Apache is useless and the\nobject will be dropped on the next request. Only on the next cache validation\nafter the object has expired.\n\nFor as long as the object has not expired the weak etag is sufficient for\nclient<->cache validations.\n\nThere is no real problem in that Apache never matches these weak etags in\nIf-None-Match.\n\nYes, it's true that to comply with the RFC the ETag should guarantee within\nreasonable doubt that the representations is equal (semantically in case of a\nweak etag, octet equal in case of a strong). The only way of guaranteeing this\nis by knowing why the object gets updatated and how. This can not be guaranteed\nwhile using a fs backend as direct filesystem access may modify the object and\nobject timestamps in any manner it likes.\n\nBut direct filesystem modifications not modifying mtime, or significant\nmodifications within the same second where results matter within that same\nsecond is both relatively unlikely to be seen in real life.\n\nBut you should probably modify the weak ETag a little more than only making it\nweak. In the RFC a strong and weak ETag with the same value compares true for\nIf-None-Match.", "is_private": false, "bug_id": 42987, "id": 112296, "time": "2007-12-29T21:42:24Z", "creator": "hno@squid-cache.org", "creation_time": "2007-12-29T21:42:24Z", "attachment_id": null}, {"count": 4, "tags": [], "text": "Henrik Nordstrom wrote:\n> There is no real problem in that Apache never matches these weak etags in\n> If-None-Match.\n\nOn\nhttp://mail-archives.apache.org/mod_mbox/httpd-dev/200712.mbox/%3c7002DFA0-43B9-464A-9843-B566D44980AF@gbiv.com%3e\nRoy T. Fielding wrote:\n> If the weak etags are not being matched to the string etags on\n> GET, then that is another bug that must be fixed.  It is not an\n> excuse to ignore the HTTP design.\n\nSeems to be time that Apache developers make up their mind on what they want to\nachieve, so it could make sense discussing how to do it in an efficient and\ncomlying way.\nI was mislead by the asumption, that what Apache does is what it is intended to do.\n\nWerner\n", "is_private": false, "bug_id": 42987, "id": 112297, "time": "2007-12-30T04:26:32Z", "creator": "werner.baumann@onlinehome.de", "creation_time": "2007-12-30T04:26:32Z", "attachment_id": null}]