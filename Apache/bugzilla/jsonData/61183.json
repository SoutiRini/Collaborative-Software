[{"count": 0, "tags": [], "bug_id": 61183, "is_private": false, "text": "Hi,\nWe have recently ran into a deadlock situation in a customer site while using websockets.\nOne of the locks is in our code while the other is the Tomcat \"stateLock\" defined in \"class WsSession\".\n\nI have marked this issue as a regression because one of the 2 locations that Tomcat takes the stateLock in 8.0.33 did not exist in 8.0.29. Here's a quick look at the differences before examining the deadlocked call stacks:\n\nIn 8.0.33 there's an expansion of the stateLock usage:\n    protected void registerFuture(FutureToSendHandler f2sh) {\n        boolean fail = false;\n        synchronized (stateLock) {\n\t\t\t// leaving out the details...\n\t\t}\n\t}\n\t\t\nWhile in 8.0.29 the entire method looks like:\n    protected void registerFuture(FutureToSendHandler f2sh) {\n        futures.put(f2sh, f2sh);\n    }\n\nI can understand why the stateLock usage has been expanded. But I think there is a problem with this. Previously we'd only enter stateLock in Tomcat -> Application calls. Now with the new registerFuture we also can enter stateLock in Application -> Tomcat calls.\nSo a recent change seems to have introduced a key ingredient for deadlocks. If my application has its own lock there is the potential for 2 locks to be acquired in reverse order by 2 simultaneous threads. \n\nWe have experienced a real-world example of this:\n\nIn the 1st thread Tomcat is closing the session after an abrupt disconnect from the client. The close action bubbles up to the Application onClose handler:\n\n\"http-nio-8445-exec-76\" daemon prio=5 tid=249 BLOCKED\n                at com.myc.common.domain.websocketutil.WsOutbound.setSocketStatus(WsOutbound.java:152) --> Waits on the Application local lock\n                   Local Variable: com.myc.common.domain.websocketutil.WsOutbound$SocketStatus#2\n                at com.myc.customer.web.socket.WebSocketEndpoint.onClose(WebSocketEndpoint.java:224)  --> Application onClose handler called which has to do some tidy up\n                   Local Variable: javax.websocket.CloseReason#2\n                   Local Variable: com.myc.customer.web.socket.WebSocketEndpoint#4\n                   Local Variable: java.lang.Object#9184\n                at sun.reflect.GeneratedMethodAccessor250.invoke(<unknown string>)\n                at sun.reflect.DelegatingMethodAccessorImpl.invoke(<unknown string>)\n                at java.lang.reflect.Method.invoke(<unknown string>)\n                at org.apache.tomcat.websocket.pojo.PojoEndpointBase.onClose(PojoEndpointBase.java:107)\n                   Local Variable: org.apache.tomcat.websocket.pojo.PojoEndpointServer#6\n                at org.apache.tomcat.websocket.WsSession.fireEndpointOnClose(WsSession.java:541)\n                   Local Variable: org.apache.catalina.loader.WebappClassLoader#2\n                   Local Variable: org.apache.catalina.core.DefaultInstanceManager#3\n                at org.apache.tomcat.websocket.WsSession.doClose(WsSession.java:490)        \t\t--> Acquires a \u201cstate lock\u201d on Tomcats call to close the session\n                at org.apache.tomcat.websocket.server.WsHttpUpgradeHandler.onError(WsHttpUpgradeHandler.java:150)\n                   Local Variable: org.apache.tomcat.websocket.server.WsHttpUpgradeHandler#6\n                at org.apache.tomcat.websocket.server.WsHttpUpgradeHandler.access$300(WsHttpUpgradeHandler.java:48)\n\n\t\t\t\t\nIn the 2nd thread the Application is simply sending a normal message to Tomcat (unaware the session is closing simultaneously):\n\n\"defaultEventExecutorGroup-3-1\" prio=5 tid=94 BLOCKED\n                at org.apache.tomcat.websocket.WsSession.registerFuture(WsSession.java:650)           --> Waits on the Tomcat \u201cstateLock\u201d\n                   Local Variable: org.apache.tomcat.websocket.WsSession#6\n                at org.apache.tomcat.websocket.FutureToSendHandler.get(FutureToSendHandler.java:104)\n                   Local Variable: org.apache.tomcat.websocket.FutureToSendHandler#247\n                   Local Variable: java.util.concurrent.TimeUnit$4#1\n                at org.apache.tomcat.websocket.FutureToSendHandler.get(FutureToSendHandler.java:31)\n                at com.myc.common.domain.websocketutil.WsOutbound.await(WsOutbound.java:255)\n                at com.myc.common.domain.websocketutil.WsOutbound.sendObj(WsOutbound.java:234)\n                at com.myc.common.domain.websocketutil.WsOutbound.send(WsOutbound.java:215)         --> Acquires the Application local lock while sending (to guarantee message order when sending multiple messages)\n                   Local Variable: com.myc.customer.model.json.notification.NewMessageNotification#3\n\nOur interface to Tomcat (wsOutbound.java) takes the Application lock using class \"synchronized\" as follows:\n\n    public synchronized void setSocketStatus(SocketStatus status) {\n\t\t// Does some state change stuff. Can be invoked from onClose()\n\t}\n\t\n\tpublic synchronized boolean send(Object obj) {\n\t\t// Sends one or more messages to Tomcat\n\t}\n\t\nSo we had a simple locking strategy. Now I have to come up with a message queuing strategy so that I can send multiple messages, in order, without holding an Application lock.\n\nTo my mind the root problem is in the existing Tomcat code for doClose(). In other deadlock situations I've been involved with the onus has been on the thread that invokes a callback/listener to exit any locks it holds first:\n\n    private void doClose(CloseReason closeReasonMessage,\n            CloseReason closeReasonLocal) {\n        // Double-checked locking. OK because state is volatile\n        if (state != State.OPEN) {\n            return;\n        }\n\n        synchronized (stateLock) {\n            if (state != State.OPEN) {\n                return;\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(sm.getString(\"wsSession.doClose\", id));\n            }\n            try {\n                wsRemoteEndpoint.setBatchingAllowed(false);\n            } catch (IOException e) {\n                log.warn(sm.getString(\"wsSession.flushFailOnClose\"), e);\n\t\t\t\t\t\t\t\t\t\t\t<-- Exit stateLock first?\n                fireEndpointOnError(e);\n            }\n\n            state = State.CLOSING;\n\n            sendCloseMessage(closeReasonMessage);\n\t\t\t\t\t\t\t\t\t\t\t<-- Exit stateLock first?\n            fireEndpointOnClose(closeReasonLocal);\n\t\t\t\t\t\t\t\t\t\t\t<-- Reenter stateLock?\n            state = State.CLOSED;\n        }\n\t\t\nI took a quick look at the latest 8.0.x (8.0.44) code and it appears the same issue can happen.\nI'd appreciate any comment on my analysis or improvements in coding our application.", "id": 199181, "time": "2017-06-13T16:25:12Z", "creator": "lorcan2@live.com", "creation_time": "2017-06-13T16:25:12Z", "attachment_id": null}, {"attachment_id": 35050, "tags": [], "bug_id": 61183, "is_private": false, "count": 1, "id": 199182, "time": "2017-06-13T16:33:50Z", "creator": "lorcan2@live.com", "creation_time": "2017-06-13T16:33:50Z", "text": "Created attachment 35050\nDescription in txt\n\nCall stacks and comments might be easier to read with .txt"}, {"count": 2, "tags": [], "bug_id": 61183, "attachment_id": null, "text": "The analysis looks to be spot on. The tricky part is likely to be fixing this without re-introducing the bugs those locks were put in place to fix.", "id": 199266, "time": "2017-06-18T20:24:37Z", "creator": "markt@apache.org", "creation_time": "2017-06-18T20:24:37Z", "is_private": false}, {"count": 3, "attachment_id": null, "creator": "markt@apache.org", "text": "I spent a lot of time trying to avoid calling the callbacks with the lock held. In the end, I opted to refactor registerFuture().\n\nFixed in:\n- trunk for 9.0.0.M22 onwards\n- 8.5.x for 8.5.16 onwards\n- 8.0.x for 8.0.45 onwards\n- 7.0.x for 7.0.79 onwards", "id": 199276, "time": "2017-06-19T12:34:27Z", "bug_id": 61183, "creation_time": "2017-06-19T12:34:27Z", "tags": [], "is_private": false}, {"count": 4, "tags": [], "bug_id": 61183, "is_private": false, "id": 199310, "creation_time": "2017-06-21T09:32:22Z", "time": "2017-06-21T09:32:22Z", "creator": "lorcan2@live.com", "text": "Thanks Mark,\nI assume the refactoring of registerFuture involved avoiding stateLock. I would imagine this problem should be reproducible with the right test harness. \n\nHave you any view to when these patches will be made available?\nregards,\nLorcan", "attachment_id": null}, {"count": 5, "tags": [], "bug_id": 61183, "is_private": false, "id": 199311, "creation_time": "2017-06-21T09:46:45Z", "time": "2017-06-21T09:46:45Z", "creator": "markt@apache.org", "text": "I'm building the 9.0.0.M22 release now. 8.5.x will follow shortly. Releases take 4-5 days, mainly because of the minimum 72 hour voting period and allowing 24 hours for the mirrors to sync.", "attachment_id": null}]