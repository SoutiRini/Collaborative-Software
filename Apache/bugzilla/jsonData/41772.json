[{"count": 0, "tags": [], "bug_id": 41772, "is_private": false, "text": "I'm running on Suse 9.3 (I think) with tomcat 5.0.30 running under Java\n1.5.0_07-b03.  I'm front-ending with Apache 2.2.0 using mod_jk set up to hit an\nAJP 1.3 connector.  As far as I can tell, everything is configured correctly.\n\nAbout 20% of the time, when I hit my application without handing in a session\nID, I get an \"IllegalStateException: Cannot create a session after the response\nhas been committed\".  The problem is at its worst when I hit my application\nusing a client OTHER than a web browser.  I have tried putting a ServletFilter\nin front of my application to verify that 1) the session truly cannot be\ncreated, and 2) that the response is actually committed before my code touches\nit.  It appears my application is being handed an already commited\nHttpServletResponse.\n\nI have 3 separate applications running in the same tomcat instance.\n\n1) a webservice powered first by Axis, and now by XFire.  This bug showed up\nusing both of these libraries.\n2) a straight up servlet / JSP webapp powered by struts.\n3) a struts-powered app used exclusively for dynamic image generation.\n\nIn the case of app 1, I ended up hacking XFire to not call\nresponse.setBufferSize(), which kept it from triggering an\n\"IllegalStateException: response has already been committed.\"  I don't have any\nremaining stack traces, as I did this fix several months ago and dumped them,\nthinking this was the end of the issue.\n\nIn app #2 everything seems to work fine except occasionally on my login page,\nwhere I get this problem occasionally when I hand in no SESSIONID or an expired\none.  A page refresh usually takes care of it.\n\nIn app #3, I'm generating images to be included in a dynamically generated PDF.\n I make a bunch of calls to this app in rapid succession (12-15 images per PDF)\nand invariably, anywhere between 1 and 5 of them returns a content length of 0.\n I checked the logs and found this stack trace:\n\n(NOTE: that stray line in my SessionFilter class is:\n((HttpServletRequest)request).getSession(true);  If you need the whole content\nof that filter, I can send it to you, but that's all it does at the moment.)\n\njava.lang.IllegalStateException: Cannot create a session after the response has\nbeen committed\n        at\norg.apache.coyote.tomcat5.CoyoteRequest.doGetSession(CoyoteRequest.java:2270)\n        at\norg.apache.coyote.tomcat5.CoyoteRequest.getSession(CoyoteRequest.java:2116)\n        at\norg.apache.coyote.tomcat5.CoyoteRequestFacade.getSession(CoyoteRequestFacade.java:528)\n        at com.mycompany.util.SessionFilter.doFilter(SessionFilter.java:37)\n        at\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:202)\n        at\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:173)\n        at\norg.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:214)\n        at\norg.apache.catalina.core.StandardValveContext.invokeNext(StandardValveContext.java:104)\n        at\norg.apache.catalina.core.StandardPipeline.invoke(StandardPipeline.java:520)\n        at\norg.apache.catalina.core.StandardContextValve.invokeInternal(StandardContextValve.java:198)\n        at\norg.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:152)\n        at\norg.apache.catalina.core.StandardValveContext.invokeNext(StandardValveContext.java:104)\n        at\norg.apache.catalina.core.StandardPipeline.invoke(StandardPipeline.java:520)\n        at\norg.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:137)\n        at\norg.apache.catalina.core.StandardValveContext.invokeNext(StandardValveContext.java:104)\n        at\norg.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:118)\n        at\norg.apache.catalina.core.StandardValveContext.invokeNext(StandardValveContext.java:102)\n        at\norg.apache.catalina.core.StandardPipeline.invoke(StandardPipeline.java:520)\n        at\norg.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:109)\n        at\norg.apache.catalina.core.StandardValveContext.invokeNext(StandardValveContext.java:104)\n        at\norg.apache.catalina.core.StandardPipeline.invoke(StandardPipeline.java:520)\n        at org.apache.catalina.core.ContainerBase.invoke(ContainerBase.java:929)\n        at org.apache.coyote.tomcat5.CoyoteAdapter.service(CoyoteAdapter.java:160)\n        at org.apache.jk.server.JkCoyoteHandler.invoke(JkCoyoteHandler.java:300)\n        at org.apache.jk.common.HandlerRequest.invoke(HandlerRequest.java:374)\n        at org.apache.jk.common.ChannelSocket.invoke(ChannelSocket.java:743)\n        at\norg.apache.jk.common.ChannelSocket.processConnection(ChannelSocket.java:675)\n        at org.apache.jk.common.SocketConnection.runIt(ChannelSocket.java:866)\n        at\norg.apache.tomcat.util.threads.ThreadPool$ControlRunnable.run(ThreadPool.java:684)\n        at java.lang.Thread.run(Thread.java:595)\n\nI would shrug it off as my own bad code, except this occurs before ANY of my\ncode executes, other than the one line in the ServletFilter.\n\nI set up an automated test, just to demonstrate the differences in the two\nrequests.  It hits the app 50 times in a row (one request at a time) and between\n8 and 15 of the requests fail, every time I run it.  Here are the headers\nreturned by both a successful and unsuccessful request.\n\nHeaders for Request 0 (unsuccessful)\n\tDate - Tue, 06 Mar 2007 09:38:26 GMT\n\tServer - Apache/2.2.0 (Linux/SUSE)\n\tContent-Length - 0\n\tContent-Type - image/png\n\tContent Length - 0\n\nHeaders for Request 3 (successful)\n\tDate - Tue, 06 Mar 2007 09:38:30 GMT\n\tServer - Apache/2.2.0 (Linux/SUSE)\n\tSet-Cookie - JSESSIONID=E4F3D53DD87F132B1668E04A14C2BDC4; Path=/myapp\n\tContent-Length - 330\n\tContent-Type - image/png\n\tContent Length - 330\n\nI can provide more info if needed.", "id": 100093, "time": "2007-03-06T09:27:59Z", "creator": "nathan.nelson@digitalbarista.com", "creation_time": "2007-03-06T09:27:59Z", "attachment_id": null}, {"count": 1, "attachment_id": 19672, "creator": "nathan.nelson@digitalbarista.com", "is_private": false, "id": 100094, "time": "2007-03-06T09:32:21Z", "bug_id": 41772, "creation_time": "2007-03-06T09:32:21Z", "tags": [], "text": "Created attachment 19672\nMy test case - used to reproduce my problem.\n\nI've attached the test case I used to reproduce my bug.  I have changed the URL\nto edit out the host, application, and struts action mapping.  However, all\nother parts of the file are as-is."}, {"count": 2, "attachment_id": null, "creator": "nathan.nelson@digitalbarista.com", "is_private": false, "id": 100099, "time": "2007-03-06T12:43:30Z", "bug_id": 41772, "creation_time": "2007-03-06T12:43:30Z", "tags": [], "text": "So, sheepishly I admit that this is an application error, but I believe there's\nstill a weakness to be patched up.  \n\nIt relates back to the Java2D stuff I'm using.  After the following two lines:\n\nImageOutputStream out=ImageIO.createImageOutputStream(response.getOutputStream());\nImageIO.write(image,\"png\",out);\nresponse.getOutputStream().flush();\n\nI never closed ImageOutputStream.  Obviously an application error.  However, in\nthe catalina logs, I found this stack trace:\n\n2007-03-05 07:00:01,167 [Finalizer] ERROR org.apache.jk.server.JkCoyoteHandler -\nError in action code\njava.net.SocketException: Socket closed\n        at java.net.SocketOutputStream.socketWrite(SocketOutputStream.java:99)\n        at java.net.SocketOutputStream.write(SocketOutputStream.java:136)\n        at org.apache.jk.common.ChannelSocket.send(ChannelSocket.java:506)\n        at org.apache.jk.server.JkCoyoteHandler.appendHead(JkCoyoteHandler.java:401)\n        at org.apache.jk.server.JkCoyoteHandler.action(JkCoyoteHandler.java:416)\n        at org.apache.coyote.Response.action(Response.java:182)\n        at org.apache.coyote.Response.sendHeaders(Response.java:374)\n        at org.apache.coyote.tomcat5.OutputBuffer.doFlush(OutputBuffer.java:322)\n        at org.apache.coyote.tomcat5.OutputBuffer.flush(OutputBuffer.java:298)\n        at\norg.apache.coyote.tomcat5.CoyoteOutputStream.flush(CoyoteOutputStream.java:85)\n        at\njavax.imageio.stream.FileCacheImageOutputStream.close(FileCacheImageOutputStream.java:194)\n        at\njavax.imageio.stream.ImageInputStreamImpl.finalize(ImageInputStreamImpl.java:850)\n        at java.lang.ref.Finalizer.invokeFinalizeMethod(Native Method)\n        at java.lang.ref.Finalizer.runFinalizer(Finalizer.java:83)\n        at java.lang.ref.Finalizer.access$100(Finalizer.java:14)\n        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:160)\n\n\nDuring GC, that ImageOutputStream is trying to flush the response output stream.\n It seems like Tomcat recycles HttpServletResponse objects.  If this finalizer\nis executed AFTER the Response object it references is recycled, the resulting\n'flush()' would cause that Response object to become committed.  When a new\nrequest then comes in to be handled by a thread with a now broken Response\nobject . . . well, there's where my error comes from.\n\nI also believe this bug report relates directly to bug #37516.  Note that in the\nexample code provided in that bug, he ALSO does not close his image output\nstream.  My apologies for duplicating a previous bug.\n\nWhile I understand this is my application's bug, it seems that recycling\nResponse objects should be a bit more safe than it currently is."}, {"count": 3, "tags": [], "bug_id": 41772, "attachment_id": null, "is_private": false, "id": 100105, "time": "2007-03-06T13:51:45Z", "creator": "remm@apache.org", "creation_time": "2007-03-06T13:51:45Z", "text": "This has been reported many times, and will not be patched, since enabling the\nsecurity manager fixes it."}]