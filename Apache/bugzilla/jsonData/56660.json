[{"count": 0, "tags": [], "creator": "alex-pub.apache-ant@reflexion.net", "text": "tomcat-jdbc version: 7.0.54\n\nIn this code fragment from FairBlockingQueue::poll method\n\n                Line 144\n                //the queue is empty we will wait for an object\n                ExchangeCountDownLatch<E> c = new ExchangeCountDownLatch<E>(1);\n                //add to the bottom of the wait list\n                waiters.addLast(c);\n                //unlock the global lock\n                lock.unlock();\n                //wait for the specified timeout\n                if (!c.await(timeout, unit)) {\n                    //if we timed out, remove ourselves from the waitlist\n                    lock.lock();\n                    waiters.remove(c);\n                    lock.unlock();\n                }\n                //return the item we received, can be null if we timed out\n                result = c.getItem();\n\nWhen the 'c.await' is interrupted, the Latch is not removed from 'waiters'.\nAs I understand, it can hold on to the connection object.\n\nThus the pool is leaking connections, and at some time, all new requests just hang on the c.await indefinitely.\n\nThe fix is pretty simple. Catch InterruptedException (and any other non-checked exception) and do a cleanup there.\n\n    boolean needsWaitersCleanup = false;\n    \n    try\n    {\n        if (!c.await(timeout, unit)) {\n            needsWaitersCleanup = true;\n        }\n    }\n    catch ( InterruptedException | RuntimeException | Error e )\n    {\n        needsWaitersCleanup = true;\n    \n        throw e;\n    }\n    finally\n    {\n        if ( needsWaitersCleanup )\n        {\n            //if we timed out, remove ourselves from the waitlist\n            lock.lock();\n            try\n            {\n                waiters.remove(c);\n            }\n            finally\n            {\n                lock.unlock();\n            }\n        }\n    }", "id": 175995, "time": "2014-06-23T22:05:40Z", "bug_id": 56660, "creation_time": "2014-06-23T22:05:40Z", "is_private": false, "attachment_id": null}, {"count": 1, "tags": [], "creator": "alex-pub.apache-ant@reflexion.net", "text": "I've encountered this bug in production, under a heavy load.  The problem here is that it's manifestation is pretty random.\n\nOne workaround, until this bug is fixed, is to turn off 'fairQueue' property of PoolProperties.\n\nWhen 'fairQueue' is off, current implementation falls back to 'java.util.concurrent.ArrayBlockingQueue', which does not have this issue.", "id": 175996, "time": "2014-06-23T22:09:17Z", "bug_id": 56660, "creation_time": "2014-06-23T22:09:17Z", "is_private": false, "attachment_id": null}, {"count": 2, "tags": [], "creator": "fhanik@apache.org", "text": "https://issues.apache.org/bugzilla/show_bug.cgi?id=53367\n\n*** This bug has been marked as a duplicate of bug 53367 ***", "id": 183329, "time": "2015-06-04T17:12:21Z", "bug_id": 56660, "creation_time": "2015-06-04T17:12:21Z", "is_private": false, "attachment_id": null}]