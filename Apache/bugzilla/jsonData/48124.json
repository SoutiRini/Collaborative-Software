[{"count": 0, "tags": [], "bug_id": 48124, "attachment_id": null, "text": "hi\n  I am so sorry ,my english is not very well.But i have some trouble in using POI to parse excel,the precision is lossed.\n  For exampe,the right amount is:1860.68,but the result is 1860.6800000000001 when i using poi in Linux 64-bit and the poi version is poi-3.5-FINAL.\n  If I run the project in Linux 32-bit,the result is right.But I can't change the os because it's a production.\n  Pls give me some suggestions and i must solve it quickly because many users can't use  our product.\n\n  This is the testing code in Linux RatHat5.0 64-bit :\n\n   /**\n    *This function return 1860.6800000000001 which i see in the log,but the \n    * amount is 1860.68 in the excel\n    **/\n   public double getNumericCellValue(HSSFSheet hssfsheet, int i, int j)\n   {\n       HSSFCell hssfcell = getCell(hssfsheet, i , j );\n       double value=hssfcell.getNumericCellValue();\n       return vaule;\n\n   }", "id": 131679, "time": "2009-11-04T02:43:22Z", "creator": "xunwei@csii.com.cn", "creation_time": "2009-11-04T02:43:22Z", "is_private": false}, {"count": 1, "tags": [], "text": "I am going to answer you in two parts.\n\n(1) How floating point numbers work.\n\nThis is not a POI issue. It is how doubles work. Double precision numbers are atored in a certain binary format and on 64 bit architectures you get more bits in your mantissa. This is the mathematics of numbers represented by the form of mantissa ** exponential, like for instance 1 / 3 = 0.3333333333333333. 64 bits gives you more. Some hardware even uses extra bits beyond the 64.\n\nI suggest that you try these google searches and learn about how floating point works.\n\n(a) 32 bit jvm on 64 bit linux\n\n(b) ieee-754\n\n(c) java double precision\n\nIf you want further explanation then you will need to tell us about your hardware and jvm versions, and we might have an insight.\n\nYou might be better off on a linux or redhat list for this issue.\n\n(2) A question.\n\nIn your program how are you using the result of getNumericCellValue? How are you writing the value to your log?\n\nRegards,\nDave", "is_private": false, "id": 131695, "creator": "dfisher@jmlafferty.com", "time": "2009-11-04T10:26:39Z", "bug_id": 48124, "creation_time": "2009-11-04T10:26:39Z", "attachment_id": null}, {"count": 2, "tags": [], "bug_id": 48124, "text": "*** Bug 48081 has been marked as a duplicate of this bug. ***", "id": 131715, "attachment_id": null, "creator": "josh@apache.org", "creation_time": "2009-11-04T17:57:36Z", "time": "2009-11-04T17:57:36Z", "is_private": false}, {"count": 3, "tags": [], "creator": "josh@apache.org", "text": "This problem is almost certainly independent of POI.  The underlying floating point values are being stored/retrieved properly and any numerical calculations you perform on those will be fine (within normal IEEE double constraints).  Your problem seems to be related to text conversion, in particular the method \"public static String toString(double d)\" on class java.lang.Double in your JRE.\n\nIf you are concerned about the apparent error in the converted text value, you can attempt to get around these problems by using the POI class NumberToTextConverter (which uses Excel rules instead of JRE rules for text conversion).  Alternatively, if you have specified an number format in Excel (e.g. \"2 decimal places\") you can try HSSFDataFormatter.convertCellValue(Cell) to reproduce the same formatting.\n\n--  --  --  --\nBelow I have added some details to help explain the source of your error.\n\nYour value \"1860.68\" is represented by the double with raw bit value 0x409D12B851EB851FL. \n\nThe following code shows this double value and its two neighbours:\n\nSystem.out.println(Double.longBitsToDouble(0x409D12B851EB851EL));\nSystem.out.println(Double.longBitsToDouble(0x409D12B851EB851FL));\nSystem.out.println(Double.longBitsToDouble(0x409D12B851EB8520L));\n\nOn my JREs (Sun 1.5/WinXP and Sun 1.6/Ubuntu) I get this:\n1860.6799999999998\n1860.68\n1860.6800000000003\n\nI suspect you'll get 1860.6800000000001 for the second line\n\nHopefully it's clear that POI *is* reading the correct double value from your Excel file (since 1860.68+1e-13 is still closer to 1860.68 than 1860.68+3e-13).\n\n\nTo dig a little deeper, you can see the exact (over precise) decimal representation of these same three IEEE double values with the following code:\n\nBigDecimal x = new BigDecimal(new BigInteger(\"2\").pow(42));\nSystem.out.println(new BigDecimal(Long.toString(0x1D12B851EB851EL)).divide(x));\nSystem.out.println(new BigDecimal(Long.toString(0x1D12B851EB851FL)).divide(x));\nSystem.out.println(new BigDecimal(Long.toString(0x1D12B851EB8520L)).divide(x));\n\nWhich gives:\n1860.67999999999983629095368087291717529296875\n1860.680000000000063664629124104976654052734375\n1860.6800000000002910383045673370361328125\n\nNow from this you might conclude that your JRE is actually doing the correct thing, since the true value (~1860.68+6.366e-14) is closer to 1860.68+1e-13 than 1860.68.  However, if you read the javadoc of Double.toString(double), you will see the following:\n\n\"How many digits must be printed for the fractional part of m or a? There must be at least one digit to represent the fractional part, and beyond that as many, but only as many, more digits as are needed to uniquely distinguish the argument value from adjacent values of type double\"\nhttp://java.sun.com/j2se/1.5.0/docs/api/java/lang/Double.html#toString(double)\n\nSo, since \"1860.68\" still uniquely identifies double value 0x409D12B851EB851FL (i.e. there is no other double value closer to 1860.68), only 2 decimal places are required.  Perhaps you should log a bug with your JRE provider.\n\n\nBTW if you look for 0x409D12B851EB851FL in the hex dump of your XLS file you won't find it.  This is because 1860.68 has been encoded as an RKNum with value 1090959009 (A1 B6 06 41) which Excel/POI automatically translate into a double with value 0x409D12B851EB851FL.", "id": 131717, "time": "2009-11-04T18:08:41Z", "bug_id": 48124, "creation_time": "2009-11-04T18:08:41Z", "is_private": false, "attachment_id": null}]