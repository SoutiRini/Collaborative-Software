[{"count": 0, "tags": [], "bug_id": 54842, "attachment_id": null, "is_private": false, "id": 166588, "time": "2013-04-13T22:22:40Z", "creator": "matteosistisette@gmail.com", "creation_time": "2013-04-13T22:22:40Z", "text": "https://bugs.php.net/bug.php?id=64644&thanks=3\n\nAt PHP they say they can't fix it because Apache doesn't provide any way to detect client disconnection except when php tries to send output. If that's true there's a huge design flaw in the way Apache interfaces with PHP (this may concern other modules too, I have no idea).\n\nIt's definitely something php MUST be able to detect, regardless of whether it's trying to send output or not."}, {"count": 1, "tags": [], "bug_id": 54842, "attachment_id": null, "id": 166589, "time": "2013-04-13T22:42:55Z", "creator": "covener@gmail.com", "creation_time": "2013-04-13T22:42:55Z", "is_private": false, "text": "The best way to detect if a write will fail is to write. If a module wants to poke around guess, it can get the native socket and do whatever it wants.    Apache won't asynchronously do anything with the client socket while a module is generating a response."}, {"count": 2, "tags": [], "bug_id": 54842, "is_private": false, "text": "It's not just a matter of detecting or \"guessing\" whether a write will fail!! It's about knowing whether or not the connection is still up, in order to know whether or not it makes sense to keep generating the response, even if it will only be flushed after it is completely generated. One shouldn't be obliged to renounce to do output buffering just in order to know that.\n\nHowever the \"get the native socket and do whatever it wants\" may be the solution? Then they're lying at PHP when they say there's nothing php can do to figure out if the connection is closed without attempting to write?\n\n(but even so, I wouldn't understand why you don't \"want to\" do \"anything asynchronously\". You do get notified when the client disconnects, don't you? then why not just let the module know?)", "id": 166591, "time": "2013-04-13T23:48:41Z", "creator": "matteosistisette@gmail.com", "creation_time": "2013-04-13T23:48:41Z", "attachment_id": null}, {"count": 3, "tags": [], "bug_id": 54842, "attachment_id": null, "is_private": false, "id": 166592, "time": "2013-04-14T01:19:24Z", "creator": "matteosistisette@gmail.com", "creation_time": "2013-04-14T01:19:24Z", "text": "You may want to have a look at https://bugs.php.net/bug.php?id=64644#1365900153\n\n\nBtw there is one thing that does _not_ make any sense: even requests that have been QUEUED (i.e. above MaxClients), are processed (i.e. passed to PHP) even if the client has already disconnected after they were queued and BEFORE they start being processed (i.e. before one spare child becomes available with prefork)!!\nBut maybe that should be reported as a separate issue."}]