[{"count": 0, "tags": [], "bug_id": 17883, "attachment_id": null, "id": 32968, "creation_time": "2003-03-11T16:27:40Z", "time": "2003-03-11T16:27:40Z", "creator": "dlwhiteman@us.ibm.com", "text": "I have a subclass of Task that implements TaskContainer.  When I iterate over \nthe child tasks, the property values that are set don't seem to maintain their \nstate for the next child task.\n\nThis is how my Ant task executes the subtasks:\n\n\tfor (int i=0; i<fTasks.size(); i++) {\n\t\tTask task = (Task) fTasks.elementAt(i);\n\t\ttask.perform();\n\t}\n\nThis is my small testcase:\n\n<target name=\"testProps\">\n\t<property name=\"joe\" value=\"bob\"/>\n\t<myTaskContainer>\n\t\t<echo message=\"${joe}\"/>\n\t\t<property name=\"test\" value=\"foo\"/>\n\t\t<echo message=\"${test}\"/>\n\t</myTaskContainer>\n</target>\n\nWhen I run this under Ant 1.4, the output is:\n\nbob\nfoo\n\nWhen I run this under Ant 1.5.2, the output is:\n\nbob\n${test}\n\nThis is a critical bug for us, since we rely on being able to set properties in \ncontainer tasks.", "is_private": false}, {"text": "Take a look at how <sequential> solves that.  The key is overriding maybeConfigure.\n\nI completely agree that this needs to be documented.", "tags": [], "creator": "bodewig@apache.org", "attachment_id": null, "count": 1, "id": 33012, "time": "2003-03-12T09:50:19Z", "bug_id": 17883, "creation_time": "2003-03-12T09:50:19Z", "is_private": false}, {"text": "So this was an intentional change in how things worked in TaskContainers \nbetween 1.4.1 and 1.5.2?  I didn't think you would want to break existing \nscripts.  I would think the default for custom tasks that implement \nTaskContainer would be that all subtasks are executed sequentially.  Note that \nmy custom task isn't just a plain vanilla container; it does some other things -\n I just reduced it down to the simplest form to illustrate the problem", "tags": [], "bug_id": 17883, "attachment_id": null, "count": 2, "id": 33036, "time": "2003-03-12T14:58:17Z", "creator": "dlwhiteman@us.ibm.com", "creation_time": "2003-03-12T14:58:17Z", "is_private": false}, {"count": 3, "tags": [], "bug_id": 17883, "attachment_id": null, "id": 33044, "creation_time": "2003-03-12T15:52:18Z", "time": "2003-03-12T15:52:18Z", "creator": "bodewig@apache.org", "text": "Some internal APIs changed to adapt for a bug that couldn't get fixed otherwise\nIIRC.\n\nWe try to keep a reasonable level of backwards compatibility, but from time to\ntime we are forced to changed APIs if it was impossible or unreasonably\ncumbersome to fix problems otherwise.\n\nThe changes in question are\n<http://cvs.apache.org/viewcvs/ant/src/main/org/apache/tools/ant/taskdefs/Sequential.java.diff?r1=1.7&r2=1.7.2.1>\nin response to bug 9259 which in turn became necessary because of some other\nchanges - I think because of\n<http://cvs.apache.org/viewcvs/ant/src/main/org/apache/tools/ant/RuntimeConfigurable.java.diff?r1=1.10&r2=1.11>\nwhich was necessary to allow users to define tasks that have the same name as\nbuilt-in tasks.\n", "is_private": false}, {"count": 4, "tags": [], "creator": "dlwhiteman@us.ibm.com", "text": "Ok, I was able to work around the problem through the use of heavy reflection, \nfollowing the pattern of the Sequential task.  Now my custom task works in both \nAnt 1.4.1 and Ant 1.5.2.", "id": 33054, "time": "2003-03-12T16:28:47Z", "bug_id": 17883, "creation_time": "2003-03-12T16:28:47Z", "is_private": false, "attachment_id": null}, {"count": 5, "tags": [], "creator": "bodewig@apache.org", "text": "I wouldn't call the report invalid 8-)\n\nDo you want to (canb your) share the heavy reflection part so that other task\nwriters in a similar situation could benefit from it?\n", "id": 33057, "time": "2003-03-12T16:34:58Z", "bug_id": 17883, "creation_time": "2003-03-12T16:34:58Z", "is_private": false, "attachment_id": null}, {"count": 6, "tags": [], "creator": "bodewig@apache.org", "text": "s/canb your/can you/ - sorry.  Do you know the feeling when you detect a really\nugly typo right at the moment after pressing the submit button?\n", "id": 33058, "time": "2003-03-12T16:36:20Z", "bug_id": 17883, "creation_time": "2003-03-12T16:36:20Z", "is_private": false, "attachment_id": null}, {"count": 7, "tags": [], "creator": "Patrick_Mueller@us.ibm.com", "is_private": false, "text": "It seems to be like TaskContainer should have some overridable setting to make\nthis behaviour work.  You don't really want some bag of code that everyone has\nto add to their own tasks to make it work the way you would expect to.\n\nOr a new subclass of TaskContainer (not sure if this is feasible; been a while\nsince I looked at this), that does the property thing right ...", "id": 33063, "time": "2003-03-12T16:52:01Z", "bug_id": 17883, "creation_time": "2003-03-12T16:52:01Z", "attachment_id": null}, {"text": "I agree with Pat... a new subclass to handle this for users would be nice.\n\nHere's my contribution to how I worked around the problem.  I think you could \ncreate a subclass of TaskContainer to hold this stuff that Sequential could \noverride.\n\nBTW... I wonder why Bugzilla hasn't yet made it possible to edit existing \ncomments - would allow folks to clean up typos or sensitive information that \nshould never have been posted.\n\n--- code below ---\n\n//--------------------------------------------------------------------\n/**\n * Use reflection to find any public or protected method in\n * the hierarchy of <CODE>starterClass</CODE>.\n */\npublic static Method findMethod(Class starterClass, String methodName, Class[] \ndefinedArgTypes) {\n\tClass currentClass = starterClass;\n\twhile ((currentClass != null)) {\n\t\ttry {\n\t\t\treturn currentClass.getDeclaredMethod(methodName, \ndefinedArgTypes);\n\t\t} catch (NoSuchMethodException e) {\n\t\t\tcurrentClass = currentClass.getSuperclass();\n\t\t}\n\t}\n\treturn null;\n}\n\n//--------------------------------------------------------------------\n/**\n * Convenience method for the other findMethod() so that callers don't need\n * to send getClass().\n */\npublic static Method findMethod(Object receiver, String methodName, Class[] \ndefinedArgTypes) {\n\treturn findMethod(receiver.getClass(), methodName, definedArgTypes);\n}\n\n//--------------------------------------------------------------------\n/**\n * Workaround for design change in Ant 1.5.2 with preserving property state\n * between contained tasks.  In Ant 1.4.1, it won't find the isInvalid()\n * method, and will end up just calling the parent class maybeConfigure(),\n * so this approach is backward compatible.\n */\npublic void maybeConfigure() throws BuildException {\n\tMethod isInvalidMethod = findMethod(this, \"isInvalid\", null);\n\tif (isInvalidMethod == null) {\n\t\tsuper.maybeConfigure();\n\t\treturn;\n\t}\n\tObject isInvalidResult = null;\n\ttry {\n\t\tisInvalidResult = isInvalidMethod.invoke(this, new Object[] {});\n\t} catch (IllegalAccessException e) {\n\t} catch (InvocationTargetException e) {\n\t}\n    if (((Boolean) isInvalidResult).booleanValue()) {\n        super.maybeConfigure();\n    } else {\n    \tMethod maybeConfigureTwoArgMethod = null;\n\t\tmaybeConfigureTwoArgMethod =\n\t\t\tfindMethod(getRuntimeConfigurableWrapper(),\n\t\t\t\t\"maybeConfigure\",\n\t\t\t\tnew Class[] { Project.class, boolean.class });\n\t\tif (maybeConfigureTwoArgMethod == null) {\n\t\t\t// should not occur, since we already found isInvalid(),\n\t\t\t// which was made available in the same Ant version as\n\t\t\t// the 2-arg maybeConfigure()\n\t\t\tSystem.out.println(\"couldn't find method \nmaybeConfigure\");\n\t\t\treturn;\n\t\t}\n    \ttry {\n\t\t\tmaybeConfigureTwoArgMethod.invoke\n(getRuntimeConfigurableWrapper(), new Object[] {getProject(), Boolean.FALSE});\n\t\t} catch (IllegalAccessException e) {\n\t\t} catch (InvocationTargetException e) {\n\t\t}\n    }\n}\n", "tags": [], "creator": "dlwhiteman@us.ibm.com", "attachment_id": null, "count": 8, "id": 33064, "time": "2003-03-12T16:58:46Z", "bug_id": 17883, "creation_time": "2003-03-12T16:58:46Z", "is_private": false}, {"count": 9, "tags": [], "creator": "Patrick_Mueller@us.ibm.com", "attachment_id": null, "text": "Um ... icky?\n\nIs reflection the only answer here?  It seems like it would be safer, if\npossible, to check some kind of Ant version constant, and call stuff differently\nbased on it.  This would only work, of course, if the 'newer' Ant didn't\nactually remove any methods from the 'older' Ant.  Which from code, I'm guessing\nit didn't (the newer Ant has some kind of new isInvalid() method on something,\nand also has a two-arg maybeConfigure(), but the old Ant and new Ant both have\nno-arg maybeConfigure().  Making the code more like:\n\npublic void maybeConfigure() throws BuildException {\n\tif (Ant.Version < 1.5) {\n\t\tsuper.maybeConfigure()\n\t}\n\telse {\n\t\tsuper.maybeConfigure(getProject().false);\n\t}\n}\n\nA little shorter.  And clearer. <g/>\n\nAssumption is you can compile this against Ant 1.5, but it will actually run\nfine on Ant 1.4, since it never tries to execute the 2-arg maybeConfigure() call.\n\nNot being able to edit existing comments is 100% pure goodness.  You revisionist!", "id": 33071, "time": "2003-03-12T18:15:19Z", "bug_id": 17883, "creation_time": "2003-03-12T18:15:19Z", "is_private": false}]