[{"count": 0, "tags": [], "bug_id": 57324, "attachment_id": null, "text": "1) In the version of Tomcat 7.0.50, the behavior of Coyote handler is modified to handle \"Expect: 100-continue\" clients. To be specific look at this change in the following line, http://grepcode.com/file/repo1.maven.org/maven2/org.apache.tomcat/tomcat-coyote/7.0.50/org/apache/coyote/http11/AbstractHttp11Processor.java#1088\n\n2) In the above change, the fix was done to handle cases against misbehaving client while POST requests are submitted to Tomcat.\n\n3) While it is done with a \"security\" intent, the fix only takes into account status codes ranging in 2xx series. It breaks some legitimate cases where other status codes are returned for legitimate usecases. An example is given below.\n\nExample:\n\n   * It is quite normal to have a keepalive connections with different resources having different authorization controls\n   * HTTP 401 is typical of webservers to inform clients of unauthorized access to resources and triggering client to resubmit the request. Please refer http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html for 401 behavior.\n   * The change done in Tomcat breaks this legitimate case.\n\nSteps to reproduce:\n1) Install a version of Tomcat 7.0.50 or above\n2) Write a client that uses Expect100Continue behavior along with KeepAlive\n3) Make atleast two requests with the first request succeeding and second request simulating a HTTP 401 scenario. \n4) Notice that the server closes the connection after the second response\n5) This will break clients which are in the process of responding to the second request with valid credentials\n\nWhy blocker:\n\n1) .NET defaults to Expect 100 behaviour\n2) .NET clients optimize the keepalive connections and do not send credentials with every request going out on keepalive connections\n3) This induces 401 situation more often in communications between Tomcat and .NET clients\n4) Closing of server connections is causing existing connections to break and our customers are complaining this started happening after upgrading Tomcat (7.0.50)\n5) Hence, this needs attention.", "id": 179606, "time": "2014-12-08T05:58:16Z", "creator": "vkrishna@novell.com", "creation_time": "2014-12-08T05:58:16Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 57324, "attachment_id": null, "text": "Reverting this feature won't help you, as .NET clients misbehave either way.\n\n\nSee recent thread \"Receiving HTTP 505 on Expect: 100-continue\" on users mailing http://marc.info/?t=141768539900004&r=1&w=2", "id": 179607, "time": "2014-12-08T06:45:34Z", "creator": "knst.kolinko@gmail.com", "creation_time": "2014-12-08T06:45:34Z", "is_private": false}, {"count": 2, "tags": [], "bug_id": 57324, "attachment_id": null, "text": "I suggest to consider giving an option in Tomcat to configure the behavior. Having such a popular Application Server behave only one configured is breaking lot of existing software.\n\nI think we should have a conversation on what is the \"right\" fix that can satisfy both needs.", "id": 179609, "time": "2014-12-08T07:37:07Z", "creator": "vkrishna@novell.com", "creation_time": "2014-12-08T07:37:07Z", "is_private": false}, {"count": 3, "tags": [], "creator": "vkrishna@novell.com", "text": "I am attaching traces from my wireshark analysis. It captures 3 request response cycles. Please proceed to my notes at the end after the trace.\n\n**************************************************\n1) POST /someresource/ HTTP/1.1\nUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; MS Web Services Client Protocol 4.0.30319.18444)\nContent-Type: text/xml; charset=utf-8\nAuthorization: Basic VALIDCREDENTIALS=\nHost: serveraddress\nContent-Length: 327\nExpect: 100-continue\n\nHTTP/1.1 100 Continue\n\n<request body sent>\n\nHTTP/1.1 200 OK\nServer: Apache-Coyote/1.1\nContent-Type: text/xml;charset=utf-8\nContent-Length: 424\nDate: Mon, 08 Dec 2014 08:47:08 GMT\n\n<first response successful>\n\n\n2) POST /someotherresource/ HTTP/1.1\nUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; MS Web Services Client Protocol 4.0.30319.18444)\nContent-Type: text/xml; charset=utf-8\nHost: serveraddress\nContent-Length: 331\nExpect: 100-continue\n\nHTTP/1.1 100 Continue\n\n<request body sent>\n\nHTTP/1.1 401 Unauthorized\nServer: Apache-Coyote/1.1\nWWW-Authenticate: Basic realm=\"blah\"\nWWW-Authenticate: blah realm=\"blah\"\nContent-Type: text/html;charset=utf-8\nContent-Language: en\nContent-Length: 951\nDate: Mon, 08 Dec 2014 08:47:09 GMT\n\n<response with possible error message>\n\n3) POST /someotherresource/ HTTP/1.1\nUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; MS Web Services Client Protocol 4.0.30319.18444)\nContent-Type: text/xml; charset=utf-8\nAuthorization: Basic VALIDCREDENTIALS=\nHost: 10.71.65.156\nContent-Length: 331\nExpect: 100-continue\n\n\n***************************************************\n\n* In the above trace, my client made two webservice calls in a total of 3 reply-request cycles. The first request marked with 1) was straight forward and completed successfully with Expect100continue behavior.\n\n* The second webservice call was split into two cycles by .NET and its unnecessary optimization. Without the Application Developers clear intent to do so, .NET sent the second request without any credentials triggering a 401 response from server. However, according to RFC http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.2 \n\n\"401\" response does give a chance for client to resubmit its request with proper credentials.\n\n* The third request number 3) in the trace is .NET trial at doing the same i.e resubmitting the second request with credentials.\n\nBecause of the change done by Tomcat, the client does not get a chance and the socket is closed by Tomcat. \n\nThe problem is severe because , in all of this, Application Developer does not get any control from .NET and Client code simply breaks with an exception because .NET did not check the health of socket before making request 3) in the above trace.\n\nAgreed there is a lot of problem here in .NET and we can reach out to Microsoft, but going and patching each and every client out there is going to be really costly. Also, it can be argued that with this new change, Tomcat is not giving opportunity to client to resubmit the 401 challenged response, so it may be a violation of RFC. \n\nAlso, my traces are not consistent with the original issue reported so I need someone to investigate further. The original issue may be something happening only when there is an intermediate node involved. \n\nI may not be an expert in all of this, but feel there is something Tomcat can do about all of this. I have also reopened the bug only to demonstrate my point, but not to violate the process in the forum. If it is still not convincing, please go ahead and close the case.", "id": 179612, "time": "2014-12-08T09:12:00Z", "bug_id": 57324, "creation_time": "2014-12-08T09:12:00Z", "is_private": false, "attachment_id": null}, {"count": 4, "tags": [], "bug_id": 57324, "attachment_id": null, "id": 179668, "time": "2014-12-09T21:05:43Z", "creator": "markt@apache.org", "creation_time": "2014-12-09T21:05:43Z", "is_private": false, "text": "Upgrade to the latest 7.0.x release. A 401 should not trigger a connection drop in that case."}, {"count": 5, "tags": [], "bug_id": 57324, "attachment_id": 32279, "text": "Created attachment 32279\nIssue seen with Tomcat 7.0.57\n\nWireshark trace with Tomcat 7.0.57 using my test code.", "id": 179682, "time": "2014-12-10T04:55:36Z", "creator": "vkrishna@novell.com", "creation_time": "2014-12-10T04:55:36Z", "is_private": false}, {"text": "Mark,\n\nI have upgraded to Tomcat 7.0.57 and the problem is still reproducible. I have attached the screenshot of my wireshark trace which clearly demonstrates a connection closure after a 401 response from Tomcat. Note that Tomcat 7.0.39 does not have this behavior. \n\nIn the trace, you will find the packets highlighted in red that demonstrates the connection closure from Tomcat.\n\nI have also checked the code and in AbstractHttp11Processor from Tomcat 7.0.57, I do not see any different handling for 401 \n\n**************************Snippet *****************************\n\n if (!isAsync() && !comet) {\n                if (getErrorState().isError()) {\n                    // If we know we are closing the connection, don't drain\n                    // input. This way uploading a 100GB file doesn't tie up the\n                    // thread if the servlet has rejected it.\n                    getInputBuffer().setSwallowInput(false);\n                } else if (expectation &&\n                        (response.getStatus() < 200 || response.getStatus() > 299)) {\n                    // Client sent Expect: 100-continue but received a\n                    // non-2xx final response. Disable keep-alive (if enabled)\n                    // to ensure that the connection is closed. Some clients may\n                    // still send the body, some may send the next request.\n                    // No way to differentiate, so close the connection to\n                    // force the client to send the next request.\n                    getInputBuffer().setSwallowInput(false);\n                    keepAlive = false;\n                }\n                endRequest();\n            }\n\n****************************End of Snippet **************************\n\nLet me know what is missing link here ?\n\nThanks for your time.", "tags": [], "bug_id": 57324, "attachment_id": null, "count": 6, "id": 179683, "time": "2014-12-10T05:00:49Z", "creator": "vkrishna@novell.com", "creation_time": "2014-12-10T05:00:49Z", "is_private": false}, {"count": 7, "tags": [], "bug_id": 57324, "attachment_id": null, "id": 179691, "time": "2014-12-10T12:35:08Z", "creator": "1983-01-06@gmx.net", "creation_time": "2014-12-10T12:35:08Z", "is_private": false, "text": "As far as I can see, this behavior is fully RFC-compliant:\n\nA server that responds with a final status code before reading the\nentire message body SHOULD indicate in that response whether it\nintends to close the connection or continue reading and discarding\nthe request message (see Section 6.6 of [RFC7230]).\n\nhttp://tools.ietf.org/html/rfc7231#section-5.1.1\n\nThis is what Tomcat does, closing the connection."}, {"text": "Ah yes. I confused two different error condition handling mechanisms.\n\nUltimately Tomcat has to deal with the problem that after a non 2xx response, Tomcat can't tell if the next bytes received are the request body from the previous request or a brand new request. While this problematic for directly connected clients, it is a security risk when behind a proxy.\n\nTomcat should send the connection close header to signal that the connection is being closed. If there are cases where it isn't there that is something we could look at.", "tags": [], "bug_id": 57324, "attachment_id": null, "count": 8, "id": 179694, "time": "2014-12-10T14:38:39Z", "creator": "markt@apache.org", "creation_time": "2014-12-10T14:38:39Z", "is_private": false}, {"count": 9, "tags": [], "bug_id": 57324, "attachment_id": 32280, "id": 179695, "time": "2014-12-10T15:05:37Z", "creator": "vkrishna@novell.com", "creation_time": "2014-12-10T15:05:37Z", "is_private": false, "text": "Created attachment 32280\nTomcat HTTP traffic"}, {"text": "Yes, Tomcat is not sending \"Connection: close\" after response to 401.\n\nMy traces where the client is connected directly demonstrate that 401 is responded by Tomcat only after consuming the previous request body completely.Please refer Tomcat HTTP traffic attachment. I do not see your security point here in my trace. Is the security issue only when a \"Proxy\" is involved. \n\nAccording to RFC, if a server responds with 401 and if client has not sent \"credentials\" atleast once , then the client MAY request again with credentials. By closing the connection, you have really denied that right of the client. Having said that, the client can always resubmit using a fresh connection, but this adds the overhead of SSL handshake for those repeated calls. In a \"Keepalive\" scenario this does impact performance.\n\nSo, may I request and if you do not mind, can you cross reference the wireshark trace when the original problem is raised with a Proxy in middle so that people referencing this bug in future has the full context.\n\nAt the very least, by making sure Tomcat sends a \"Connection: close\" directive is acceptable, but I do want you to consider the performance aspect and see if something better can be done. I am trying to get to speed on Tomcat code to see if I can suggest a patch, but given my familiarity it may take time. So, it will help if you solve both problems.", "tags": [], "bug_id": 57324, "attachment_id": null, "count": 10, "id": 179697, "time": "2014-12-10T15:15:36Z", "creator": "vkrishna@novell.com", "creation_time": "2014-12-10T15:15:36Z", "is_private": false}, {"count": 11, "tags": [], "bug_id": 57324, "attachment_id": null, "id": 179765, "time": "2014-12-15T12:01:25Z", "creator": "markt@apache.org", "creation_time": "2014-12-15T12:01:25Z", "is_private": false, "text": "I've added code to set the \"Connection: close\" header if it is known at the time that the response is committed that the connection is going to be closed. This change has been made to trunk, 8.0.x (for 8.0.16 onwards) and 7.0.x (for 7.0.58 onwards)."}, {"count": 12, "tags": [], "bug_id": 57324, "attachment_id": null, "text": "Can we have this complete handling fixed in Tomcat 6 too?\nThis patch and the previous one by Konstantin.", "id": 179766, "time": "2014-12-15T13:29:39Z", "creator": "1983-01-06@gmx.net", "creation_time": "2014-12-15T13:29:39Z", "is_private": false}, {"count": 13, "tags": [], "bug_id": 57324, "text": "Any ambitions to port this back to 6.0.x?", "id": 186757, "attachment_id": null, "creator": "1983-01-06@gmx.net", "creation_time": "2015-12-03T09:57:32Z", "time": "2015-12-03T09:57:32Z", "is_private": false}, {"count": 14, "tags": [], "bug_id": 57324, "attachment_id": null, "text": "I don't intend for this to sound confrontational, but would you care to submit a patch?\n\nTomcat 7 and higher differ substantially from Tomcat 6 and so a back-port might not be trivial. If you are motivated to get this back-ported to Tomcat 6, you could try your hand at preparing a patch and help both yourself and The Community at large at the same time (not to mention the various committers who would otherwise have to prepare the patch themselves).", "id": 186767, "time": "2015-12-03T15:56:53Z", "creator": "chris@christopherschultz.net", "creation_time": "2015-12-03T15:56:53Z", "is_private": false}, {"count": 15, "tags": [], "bug_id": 57324, "attachment_id": null, "text": "(In reply to Christopher Schultz from comment #14)\n> I don't intend for this to sound confrontational, but would you care to\n> submit a patch?\n>\n> Tomcat 7 and higher differ substantially from Tomcat 6 and so a back-port\n> might not be trivial. If you are motivated to get this back-ported to Tomcat\n> 6, you could try your hand at preparing a patch and help both yourself and\n> The Community at large at the same time (not to mention the various\n> committers who would otherwise have to prepare the patch themselves).\n\nHopefully, because I am a long year ASF committer and don't need a lecture on that. I don't mind to provide patches at all.\n\nI can try to backport that but I cannot compile Tomcat. The custom Ant build won't download the dependencies at work. It has either to be Maven or at least Aether Ant Tasks. Nothing else will work. All calls must be routed through Nexus.", "id": 186776, "time": "2015-12-03T19:48:15Z", "creator": "1983-01-06@gmx.net", "creation_time": "2015-12-03T19:48:15Z", "is_private": false}]