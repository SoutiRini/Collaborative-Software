[{"count": 0, "tags": [], "text": "McastServiceImpl.java re-uses the same DatagramPacket.  The byte buffer for this\npacket gets set to the size of the first packet received and then not reset.\n\nI have two machines in a cluster.  One with IP Address 192.168.1.5, the other\nwith 192.168.1.27.  The DatagramPacket for one machine is size 49, the other 50\nbecause of the one character difference in the name length in the packet.\n\nThe problem is that when the 2nd packet is received, the DatagramPacket still\nhas size 49.  The following exception gets thrown each time a packet from that\nmachine is received:\n\njava.lang.ArrayIndexOutOfBoundsException\n        at\njava.lang.System.arraycopy(Ljava.lang.Object;ILjava.lang.Object;II)V(Unknown Source)\n        at\norg.apache.catalina.cluster.mcast.McastMember.getMember(McastMember.java:180)\n        at\norg.apache.catalina.cluster.mcast.McastServiceImpl.receive(McastServiceImpl.java:209)\n        at\norg.apache.catalina.cluster.mcast.McastServiceImpl$ReceiverThread.run(McastServiceImpl.java:253)\n\nThe byte buffer for the DatagramPacket needs to check the length and possibly\nresize if needed.\n\nThis probably doesn't affect many people.", "attachment_id": null, "bug_id": 35920, "id": 77782, "time": "2005-07-28T18:47:24Z", "creator": "devel@muhlesteins.com", "creation_time": "2005-07-28T18:47:24Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 35920, "attachment_id": null, "is_private": false, "id": 77803, "time": "2005-07-28T22:12:04Z", "creator": "rainer.jung@kippdata.de", "creation_time": "2005-07-28T22:12:04Z", "text": "It looks like the Datagram always has buffer for 1000 Bytes.\nThe IP itself has constant length (4 Bytes), the name (containing the IP as a\nstring) has variable length, but the length is passed as part of the datagram.\nSo no bug to be seen here.\n\nI tried with two different length IPs - no problem.\n\nIf the third line of this:\n       int dlen = XByteBuffer.toInt(dlend, 0);\n       byte[] domaind = new byte[dlen];\n       System.arraycopy(data, nlen + 24, domaind, 0, domaind.length);\nis where it happens, can you debug by a print statement giving:\n\ndata.getLength()\nXByteBuffer.toLong(alived, 0))\nXByteBuffer.toInt(portd, 0),\naddressToString(addr),\nnlen,\nnew String(named),\ndlen,\n\nand for i=0...dlen-1\ndata[nlen + 24 + i]\n\nThat way you can see, if you received the data which is expected, or where there\nmight be something wrong.\n"}, {"count": 2, "tags": [], "bug_id": 35920, "is_private": false, "text": "Well, I forgot to mention something important.  I'm using the BEA JRockit jvm\nand I'm betting they've done some kind of internal optimization at the java.net\nclass level.  I'll try again with the sun jvm and see if that solves the issue.\n\nI had done some print statements to see what the byte[] contained.  It always\nsaid it was 49 bytes long but there were 50 bytes worth of data sent (and received).", "id": 77804, "time": "2005-07-28T22:21:24Z", "creator": "devel@muhlesteins.com", "creation_time": "2005-07-28T22:21:24Z", "attachment_id": null}, {"count": 3, "tags": [], "text": "This problem does not exhibit itself with Sun-jdk-1.5.0.04.\nIt's more likely a bug in the JRockit jvm.", "is_private": false, "id": 77834, "creator": "devel@muhlesteins.com", "time": "2005-07-29T19:09:12Z", "bug_id": 35920, "creation_time": "2005-07-29T19:09:12Z", "attachment_id": null}, {"count": 4, "tags": [], "bug_id": 35920, "attachment_id": null, "is_private": false, "id": 81229, "time": "2005-10-17T06:05:11Z", "creator": "yoavs@computer.org", "creation_time": "2005-10-17T06:05:11Z", "text": "Thank you for following up."}]