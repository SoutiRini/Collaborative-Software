[{"count": 0, "tags": [], "creator": "sean.mullan@oracle.com", "is_private": false, "id": 93592, "attachment_id": null, "bug_id": 40512, "creation_time": "2006-09-14T14:43:54Z", "time": "2006-09-14T14:43:54Z", "text": "In 1.4, a new abstract protected\nenginePerformTransform(XMLSignatureInput, Transform) method was added to the\nTransformSpi class and the existing enginePerformTransform(XMLSignatureInput)\nmethod was\nremoved. The new method was designed to replace the old method and was\ndone to improve performance, which is all very good.\n\nUnfortunately, it means that existing TransformSpi implementations when\ncompiled against 1.4 will not compile until the new method is\nimplemented. This is not a problem for the built-in implementations with\nXMLSec (since they have been adjusted) but it is a problem for any\nTransformSpi implementations developed by users out there. In any case,\nthis particular compilation failure is not such a big deal since you\nwill want to implement the better method anyway.\n\nThe more serious problem (IMO) is that you will get a runtime error\n(NoSuchMethodError) if the current TransformSpi implementations are run\nwith 1.4 without updating and recompiling to support the new method\n(because the new methods don't exist). So this means you cannot\nseamlessly upgrade existing TransformSpi implementations to 1.4 without\nreimplementing the new methods. \n\nSuggested fix (for TransformSpi):\n\n1. Restore old method\n2. Change new method to be non-abstract and throw UnsupportedOperationExc \nby default\n3. Change Transform code to fallback to old method if it gets UnsuppOpExc, ex:\n\ntry {\n  result = transformSpi.enginePerformTransform(input,this);\n} catch (UnsupportedOperationException ex) {\n  result = transformSpi.enginePerformTransform(input);\n\n4. Document in release notes that developers should override new method"}, {"count": 1, "tags": [], "creator": "raul-info@r-bg.com", "attachment_id": null, "text": "Sorry for the delay too much daily work.\nFor me the better is the 4. Document it and let the people work.\n\nThe point 3 can be done but the solution is slightly different and can be slow.\nThe change comes because of the thread issues and the \"slowness\" of\nnewInstance() method. Before the change we create a transform object for every\nsignature to process. After the change we create only a stateless object and\nreuse in all transformations. \n\nYour solution can change slightly with(I have no compiler here so take it with a\ngrain of salt).\n\ntry {\n  result = transformSpi.enginePerformTransform(input,this);\n} catch (UnsupportedOperationException ex) {\n  TransformSpi newTransformSpi=transformSpi.class.newInstance();\n  newTransformSpi.setTransfor(this);\n  result = newTransformSpi.enginePerformTransform(input);\n}\n\nWhat do you think?\n\nThe only main problem with your solution is that when someone want to create a\nTransform the compiler will not force to implement any method.\n\nIf there is enough push for the 3. I will implement this. But I still think it\nshould be better to document the change.\n\nRegards,\nRaul", "id": 93594, "time": "2006-09-14T15:22:39Z", "bug_id": 40512, "creation_time": "2006-09-14T15:22:39Z", "is_private": false}, {"count": 2, "tags": [], "creator": "sean.mullan@oracle.com", "text": "> What do you think?\n\nI think your reasons for the new method are good! But I still think we need to\npreserve compatibility (esp. binary).\n\nThis change breaks binary compat in a service provider API that has been in  \nXMLSec since the first release. Users should be able to depend on that\nAPI (especially since it was designed for them to plug in their own Transform\nimplementations) being stable over the long run. Compatibility is really\nimportant IMHO across all APIs. We have too many users now, they need to\nbe able to trust us that this software will continue to work and they \ndon't have to keep modifying their code to keep up with the latest revisions.\n\nAnd maybe we should start thinking about starting an XMLSec 2 that \ncleans up some of these issues and ties better with JSR 105 and streaming\nimplementations :)\n\n> The only main problem with your solution is that when someone want to create a\n> Transform the compiler will not force to implement any method.\n\nTrue. We could log a warning though if it throws an UnsupportedExc.\n \n> If there is enough push for the 3. I will implement this. But I still think it\n> should be better to document the change.\n> \n> Regards,\n> Raul", "id": 93595, "time": "2006-09-14T17:06:01Z", "bug_id": 40512, "creation_time": "2006-09-14T17:06:01Z", "is_private": false, "attachment_id": null}, {"count": 3, "tags": [], "bug_id": 40512, "text": "My feeling is that if this is going to be left with version 4, then we need to\nbump the version number from 1.4 to 2.0 - the general convention is that small\nversion changes should not break compatibility at an API level.", "id": 93678, "time": "2006-09-17T08:57:10Z", "creator": "blautenb@apache.org", "creation_time": "2006-09-17T08:57:10Z", "is_private": false, "attachment_id": null}, {"count": 4, "tags": [], "creator": "raul-info@r-bg.com", "text": "I will add again the old methods with an empty implementation, and I will make\nthe new methods throw NotImplementedException and I will check this exception\nand revert to the old slow method when doing the transformation.\nSo we have backward compatibility and the speed of the new methods. As Sean\nproposed(Thanks Sean it is a good idea).\nI will do the change also in KeyResolver.\n\nThe timeframe is this week. Sorry I cannot be more precise.\n\nThanks again for the discussion. Very enlighten\n", "id": 93729, "attachment_id": null, "bug_id": 40512, "creation_time": "2006-09-18T10:29:47Z", "time": "2006-09-18T10:29:47Z", "is_private": false}, {"count": 5, "tags": [], "bug_id": 40512, "attachment_id": null, "is_private": false, "id": 94048, "time": "2006-09-24T17:46:25Z", "creator": "raul-info@r-bg.com", "creation_time": "2006-09-24T17:46:25Z", "text": "I have just made TransformSPI backward compatible. Now it is possible to use old\nimplementations made for the >1.3 versions paying the performance hit of the old\nway.\nI have adapt a little the ideas above. Instead of doing the try..catch in the\ntransform object I change the new method to have the implementation that call\nthe old api method. And have the old method throw the NotImplemented exception.\nI have done a small test case that seems to pass but I have not test with a real\nimplementation. So I wait for your feedback before closing the bug.\n\nThe problem in keyresolver still lings on. It is a little diferent than this one.\nIn KeyresolverSPI & other resolvers there were two methods boolean\nengineCanResolveX and engineResolveX. And they were called with a code like that:\nX x=null;\nwhile(x!=null && hasMoreResolvers) {\n  if (engineCanResolveX(...)) {\n     x=engineResolveX(...);\n  }\n}\n\nThe new code is simple and works like this:\nX x=null;\nwhile(x!=null && hasMoreResolvers) {\n     x=engineResolveX(...);\n}\n\nIt doesn't call engineCanResolve but it goes straight forward to the\nengineResolveX if it is null it keeps trying with other resolver.\nThis change can impact resolvers that expect engineCanResolve be called before\nengineResolve(there is one in the old code) that now will be called always\nwithout engineCanResolve(indeed the engineCanResolve is no more a method of the\nresolver).\n\nSO it is a change in the contract in the api. Well, we neve document very well\nthe API and this was not written but I think it follows the semantic of the\nnames of the methods.\n\nWe have two options.\n  1. Document the current behavior and wait and see if there are any out of the\ntree resolver that expect this behavior.\n 2. Change the name of the new method engineLookAndResolve() and let this call\nthe old methods like we do in the TransformSpi.\n\nWhat do you think?\n\n\n"}, {"count": 6, "tags": [], "creator": "sean.mullan@oracle.com", "attachment_id": null, "text": "(In reply to comment #5)\n> I have just made TransformSPI backward compatible. Now it is possible to use old\n> implementations made for the >1.3 versions paying the performance hit of the old\n> way.\n> I have adapt a little the ideas above. Instead of doing the try..catch in the\n> transform object I change the new method to have the implementation that call\n> the old api method. And have the old method throw the NotImplemented exception.\n> I have done a small test case that seems to pass but I have not test with a real\n> implementation. So I wait for your feedback before closing the bug.\n\nIt looks fine and have tested with an implementation.\n \n> The problem in keyresolver still lings on. It is a little diferent than this one.\n> In KeyresolverSPI & other resolvers there were two methods boolean\n> engineCanResolveX and engineResolveX. And they were called with a code like that:\n> X x=null;\n> while(x!=null && hasMoreResolvers) {\n>   if (engineCanResolveX(...)) {\n>      x=engineResolveX(...);\n>   }\n> }\n> \n> The new code is simple and works like this:\n> X x=null;\n> while(x!=null && hasMoreResolvers) {\n>      x=engineResolveX(...);\n> }\n> \n> It doesn't call engineCanResolve but it goes straight forward to the\n> engineResolveX if it is null it keeps trying with other resolver.\n> This change can impact resolvers that expect engineCanResolve be called before\n> engineResolve(there is one in the old code) that now will be called always\n> without engineCanResolve(indeed the engineCanResolve is no more a method of the\n> resolver).\n> \n> SO it is a change in the contract in the api. Well, we neve document very well\n> the API and this was not written but I think it follows the semantic of the\n> names of the methods.\n> \n> We have two options.\n>   1. Document the current behavior and wait and see if there are any out of the\n> tree resolver that expect this behavior.\n>  2. Change the name of the new method engineLookAndResolve() and let this call\n> the old methods like we do in the TransformSpi.\n\nI prefer to be on the safe side and preserve compatibility so I vote  2.\n\nHowever, if the consensus is to break compatibility (1) then all of \nthe engineResolve methods need to changed to clearly specify that null should \nbe returned if the key material cannot be resolved. They do not document \nthat behavior right now.\n\n", "id": 94093, "time": "2006-09-25T21:10:17Z", "bug_id": 40512, "creation_time": "2006-09-25T21:10:17Z", "is_private": false}, {"count": 7, "attachment_id": null, "creator": "sean.mullan@oracle.com", "is_private": false, "id": 108395, "time": "2007-09-19T12:17:17Z", "bug_id": 40512, "creation_time": "2007-09-19T12:17:17Z", "tags": [], "text": "Closing old bugs. Fixed in 1.4.1"}]