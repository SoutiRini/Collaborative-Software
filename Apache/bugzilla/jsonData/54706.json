[{"count": 0, "tags": [], "bug_id": 54706, "attachment_id": null, "text": "The mod_cache module handles the Cache-Control directive \"no-cache\" the same way whether it specifies a field-name (response header) or not, and \"private\" with a field-name is also handled the same way, that is: treat as stale causing revalidation (ie. send a conditional request to the origin).\n\nAccording to the RFC2616 14.9.1 :\n   no-cache\n       If the no-cache directive does not specify a field-name, then a\n      cache MUST NOT use the response to satisfy a subsequent request\n      without successful revalidation with the origin server. This\n      allows an origin server to prevent caching even by caches that\n      have been configured to return stale responses to client requests.\n\n      If the no-cache directive does specify one or more field-names,\n      then a cache MAY use the response to satisfy a subsequent request,\n      subject to any other restrictions on caching. However, the\n      specified field-name(s) MUST NOT be sent in the response to a\n      subsequent request without successful revalidation with the origin\n      server. This allows an origin server to prevent the re-use of\n      certain header fields in a response, while still allowing caching\n      of the rest of the response.\n\nMy understanding is that no-cache with a field-name does concern that field-name, not the whole response, hence mod_cache is allowed to serve the cached response if the specified header is not there (with regard to the other restrictions).\n\nWhen the specified header is cached, a revalidation is required, and now the problem is when the \"revalidated\" response is a 304 (Not Modified), but that 304 does not \"overwrite\" the headers specified in the no-cache or private directives. Should mod_cache serve its cached headers or not ?\n\nThe RFC does not say anything about the private directive with a field-name, can one consider it is the same as no-cache, or is it the same difference than without a field-name (no-cache = revalidation, private = no store, hence mod_cache would serve the cached headers with no-cache,but not with private...) ?\n\nIMHO, either private or no-cache,mod_proxy should never store (or at least serve) the headers specified with these directives.\n\nThe only applications I've seen so far implementing that feature use :\n Cache-Control: no-cache=\"Set-Cookie\",\nnone uses private, or anything else than Set-Cookie,and of course these apps don't overwrite the Set-Cookie on 304, how could they ?\n\nNow consider the following scenario :\n\nclientA => mod_cache:\nGET /foo HTTP/1.1\n\nmod_cache => origin:\nGET /foo HTTP/1.1\n\norigin => mod_cache:\nHTTP/1.1 200\nETag: \"etag\"\nDate: \"date\"\nExpires: \"expiry\"\nCache-Control: private=\"Set-Cookie\"\nSet-Cookie: data=A\n\nmod_cache => client:\nHTTP/1.1 200\nETag: \"etag\"\nDate: \"date\"\nExpires: \"expiry\"\nCache-Control: private=\"Set-Cookie\", max-age=3600\nSet-Cookie: data=A\n\nLater on :\n\nclientB => mod_cache:\nGET /foo HTTP/1.1\nCookie: data=B\n\nmod_cache => origin:\nGET /foo HTTP/1.1\nCookie: data=B\nIf-None-Match: \"etag\"\nIf-Modified-Since: \"date\"\n\norigin => mod_cache (no Set-Cookie here, the origin wants to continue with data=B) :\nHTTP/1.1 304\nETag: \"etag\"\n\nmod_cache => clientB:\nHTTP/1.1 200 OK\nETag: \"etag\"\nDate: \"date\"\nExpires: \"expiry\"\nCache-Control: private=\"Set-Cookie\", max-age=3600\nSet-Cookie: data=A\n\nThat's actually how mod_cache is handling the scenario (with private or no-cache), and clientB becomes clientA!\n\nBoth versions trunk, 2.4 and 2.2 handle no-cache with or without a header as stale response as a whole.\nBoth trunk and 2.4 handle private with a header as stale response (as a whole).\nOnly 2.2 handles private with or without a header as no store (as a whole).\n\nI have got different patches (for all the versions) to strip these headers, should this bug be valid, but I need to know if they better not be stored or stripped from the cache (private vs no-cache?).", "id": 165866, "time": "2013-03-15T17:31:38Z", "creator": "ylavic.dev@gmail.com", "creation_time": "2013-03-15T17:31:38Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 54706, "attachment_id": 30107, "is_private": false, "id": 166183, "time": "2013-03-27T18:18:01Z", "creator": "ylavic.dev@gmail.com", "creation_time": "2013-03-27T18:18:01Z", "text": "Created attachment 30107\nPatch against trunk and 2.4\n\nThis patch will not store the headers specified by Cache-Control private= or no-cache= and allow mod_cache to cache (and serve) the rest of the response (with regard to other restrictions)."}, {"count": 2, "tags": [], "text": "Fix applied to trunk in r1478382, and proposed for backport to v2.4.\n\nThe fix applied supports the option that multiple Cache-Control headers may be present at once.\n\nWould it be possible to verify that this fixes it for you?", "is_private": false, "id": 166998, "creator": "minfrin@sharp.fm", "time": "2013-05-02T14:33:28Z", "bug_id": 54706, "creation_time": "2013-05-02T14:33:28Z", "attachment_id": null}, {"count": 3, "tags": [], "text": "Sorry for my late answer.\n\nThe patch works well exept in one case: mod_proxy has a stale entry which is not \"fresh\" (according to. cache_check_freshness), and the origin responds to the validation request with a 304.\n\nIn that case (that is whenever \"r->headers_out = ap_cache_cacheable_headers_out(r)\" is executed in cache_save_filter), the original response headers concerned by \"no-cache=\" and/or \"private=\" won't be stored in the cache (legitimately), but they won't be forwarded to the client either.\n\nThe same arise for the headers specified with the CacheIgnoreHeaders directive, but that was already the case before your patch(es).\n\nFinally, the macro CACHE_SEPARATOR is defined as \",   \" (with 3 spaces), I guess some tab might have been expanded in there...", "is_private": false, "id": 167060, "creator": "ylavic.dev@gmail.com", "time": "2013-05-06T15:20:02Z", "bug_id": 54706, "creation_time": "2013-05-06T15:20:02Z", "attachment_id": null}, {"count": 4, "tags": [], "creator": "ylavic.dev@gmail.com", "text": "What about maintaining the r->headers_out and the h->resp_hdrs separately, once (currently ap_cache_cacheable_headers_out can be called multiple times), and with no API change by setting the current cache_handle_t in the r->request_config of cache_module (which does not seem to be used) ?\n\nThereby, by defining a new function cache_parse_out(h, r) like :\n{\n    if (!h->cache_obj->info.control.parsed) {\n         /* once, parse the Cache-Control header,\n            put the right things in r->headers_out,\n            when applyable, stuff from cache_accept_headers(),\n            together with the right things in h->resp_hdrs */\n    }\n}\n\nand modifying ap_cache_cacheable_headers_out(r) like :\n{\n    cache_handle_t *h = (cache_handle_t *)\n         ap_get_module_config(r->request_config, &cache_module);\n    cache_parse_out(h, r);\n    return h->resp_hdrs;\n}\n\nand then using ap_set_module_config at the right place(s)...", "id": 167064, "time": "2013-05-06T17:10:08Z", "bug_id": 54706, "creation_time": "2013-05-06T17:10:08Z", "is_private": false, "attachment_id": null}, {"count": 5, "tags": [], "bug_id": 54706, "attachment_id": 30258, "is_private": false, "id": 167073, "time": "2013-05-07T11:26:24Z", "creator": "ylavic.dev@gmail.com", "creation_time": "2013-05-07T11:26:24Z", "text": "Created attachment 30258\nCompute cached headers once and keep request headers untouched\n\nThis patch fixes the forwarding of the original headers (304) with stale entry and computes/parses the cached headers once."}, {"count": 6, "tags": [], "bug_id": 54706, "attachment_id": 30259, "text": "Created attachment 30259\nThis patch fixes the forwarding of the original headers (304) with stale entry and computes/parses the cached headers once (no tabs)\n\nSorry, the previous patch introduced some tabulations.", "id": 167074, "time": "2013-05-07T11:37:34Z", "creator": "ylavic.dev@gmail.com", "creation_time": "2013-05-07T11:37:34Z", "is_private": false}, {"count": 7, "tags": [], "text": "Created attachment 30260\nCompute cached headers once and merge them to the request headers when needed\n\nFinally the previous patch is no good either.\n\nThe cached headers (out) have to be merged to the response headers on 304 for ap_meet_conditions to take the good decision, hence this new patch.\n\nAlso, since the cached headers contain entity-headers, these have to be (re)unset from the response when ap_meet_conditions returns 304.", "is_private": false, "id": 167080, "creator": "ylavic.dev@gmail.com", "time": "2013-05-07T17:21:16Z", "bug_id": 54706, "creation_time": "2013-05-07T17:21:16Z", "attachment_id": 30260}, {"count": 8, "tags": [], "creator": "ylavic.dev@gmail.com", "text": "I missed to change the status back.", "id": 167132, "time": "2013-05-10T09:07:16Z", "bug_id": 54706, "creation_time": "2013-05-10T09:07:16Z", "is_private": false, "attachment_id": null}, {"count": 9, "tags": [], "creator": "ylavic.dev@gmail.com", "text": "Created attachment 30330\nCompute the cacheable headers once\n\nAn update to the patch since the code has changed in trunk.\n\nAny news here? Maybe I should comment a bit more about the patch, so here...\n\nThis patch (re)associates the cache_request_rec to the request_config, not that I'm nostalgic for the 2.x code (I guess it was avoided in the new code for good reasons), but to compute the cacheable headers once per request (ie. strip CacheIgnoreHeaders/cache-control'ed/hop-by-hop headers once), without breaking the API.\n\nThe new cache_prepare_headers() function does what was done by ap_cache_cacheable_headers_in/out() before and, optionally, also calls cache_accept_headers() to merge the stale response headers.\n\nI'm not sure whether this function should be in cache_storage or cache_util though, and chose the former (near cache_accept_headers()) but that required a move of the static cache_control_remove() from cache_util to there, and #include \"cache_storage.h\" in \"cache_util.c\". The other option is to move cache_accept_headers() to cache_util since \"cache_util.h\" is already included by \"cache_storage.c\", but my feeling is that cacheable headers relate more to storage...\n\nBy keeping the cacheable headers separatly from the request's headers_in/out (actually in the cache_request_rec), the patch fixes the problem raised in comment #3.\n\nIt also fixes the CACHE_SEPARATOR macro which contains multiple spaces and no tabulation (unfortunate ^I replacement?).\n\nFinally, in the case where a revalidated response leads to a 304 (ap_meet_conditions), the patch unsets the entity headers which have been merged from the stale entry before passing the response to the filter stack.\n\nMaybe all this changes should be splitted in different patches, or this patch is broken, let me know...", "id": 167435, "time": "2013-05-27T14:40:03Z", "bug_id": 54706, "creation_time": "2013-05-27T14:40:03Z", "is_private": false, "attachment_id": 30330}, {"count": 10, "tags": [], "bug_id": 54706, "attachment_id": null, "is_private": false, "id": 167462, "time": "2013-05-28T20:37:14Z", "creator": "minfrin@sharp.fm", "creation_time": "2013-05-28T20:37:14Z", "text": "Fixed on trunk, backported to v2.4.5."}]