[{"count": 0, "attachment_id": null, "bug_id": 55696, "text": "Apple appears to have made strcpy() enforce that the src and dest buffers may not overlap. As a result jk_map_get_int() may fail on the line strcpy(but, rc); as rc may be set to but by jk_map_get_string().\n\nAs a work around, I have created a second buffer char buf2[100] and used that for def:\n\n sprintf(buf2, \"%d\", def);\n rc = jk_map_get_string(m, name, buf2);", "id": 170780, "time": "2013-10-23T19:43:11Z", "creator": "sandy@clickshare.com", "creation_time": "2013-10-23T19:43:11Z", "tags": [], "is_private": false}, {"count": 1, "tags": [], "bug_id": 55696, "attachment_id": null, "text": "What is the behavior when source and destination overlap?", "id": 170787, "time": "2013-10-23T21:15:32Z", "creator": "chris@christopherschultz.net", "creation_time": "2013-10-23T21:15:32Z", "is_private": false}, {"count": 2, "tags": [], "creator": "chris@christopherschultz.net", "attachment_id": null, "id": 170803, "time": "2013-10-24T12:21:06Z", "bug_id": 55696, "creation_time": "2013-10-24T12:21:06Z", "is_private": false, "text": "Honestly, I'm not even sure why the code is written this way.\n\n  char buf[];\n  sprintf(buf, \"%d\", default_value);\n  char *rc = jk_map_get_string(m, name, buf);\n  size_t len = strlen(rc);\n  if(len)  {\n     // parse rc -> int_res\n  } else {\n    int_res = default_value;\n  }\n\n  return int_res;\n\nWhy bother at all with the whole default int -> string -> int garbage? Why not simply pass NULL as the default value to jk_map_get_string and check for either NULL or 0==len afterward?"}, {"count": 3, "tags": [], "creator": "sandy@clickshare.com", "text": "The behavior when they overlap:\n\nThe process aborts with a log message: detected source and destination buffer overlap", "id": 170806, "time": "2013-10-24T13:06:44Z", "bug_id": 55696, "creation_time": "2013-10-24T13:06:44Z", "is_private": false, "attachment_id": null}, {"count": 4, "tags": [], "creator": "chris@christopherschultz.net", "attachment_id": null, "id": 170807, "time": "2013-10-24T13:13:08Z", "bug_id": 55696, "creation_time": "2013-10-24T13:13:08Z", "is_private": false, "text": "So, SIGABRT?\n\nI'm trying to reproduce in a test-case, but this doesn't seem to work:\n\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n  char *a = \"Hello, world!\";\n  char buf1[50];\n\n  strcpy(buf1, a);\n\n  strcpy(buf1 + 7, buf1);\n\n  printf(\"buf1 is now %s\\n\", buf1);\n  return 0;\n}"}, {"count": 5, "attachment_id": null, "bug_id": 55696, "text": "strcpy(buf1, buf1) also does not fail.\n\n$ cc --version\nApple LLVM version 4.2 (clang-425.0.28) (based on LLVM 3.2svn)\nTarget: x86_64-apple-darwin12.5.0\nThread model: posix\n\nHmm... did you just upgrade to Mavericks? I haven't yet upgraded so maybe that's the problem.", "id": 170808, "time": "2013-10-24T13:15:31Z", "creator": "chris@christopherschultz.net", "creation_time": "2013-10-24T13:15:31Z", "tags": [], "is_private": false}, {"count": 6, "tags": [], "creator": "sandy@clickshare.com", "attachment_id": null, "id": 170809, "time": "2013-10-24T13:19:26Z", "bug_id": 55696, "creation_time": "2013-10-24T13:19:26Z", "is_private": false, "text": "Yes, this problem is new with Mavericks (10.9). It was working fine on 10.8\n\nI will try to create you a test case... Unfortunately, It has been about 25 years since I did any C memory management -- so it may take me a little while :-)"}, {"count": 7, "attachment_id": null, "bug_id": 55696, "text": "This is the reductive case when m && name returns false in jk_map_get_string() \n\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, const char * argv[])\n{\n    char buf[50] = \"Hello, world\";\n    const char *rc;\n    \n    rc = buf;\n    \n    strcpy(buf, rc);\n}\n\nThread 1: signal SIGABRT in __strcpy_chk()", "id": 170810, "time": "2013-10-24T13:29:56Z", "creator": "sandy@clickshare.com", "creation_time": "2013-10-24T13:29:56Z", "tags": [], "is_private": false}, {"count": 8, "tags": [], "creator": "susanlb@yahoo.com", "attachment_id": null, "id": 170812, "time": "2013-10-24T15:30:35Z", "bug_id": 55696, "creation_time": "2013-10-24T15:30:35Z", "is_private": false, "text": "(In reply to sandy from comment #0)\n> Apple appears to have made strcpy() enforce that the src and dest buffers\n> may not overlap. As a result jk_map_get_int() may fail on the line\n> strcpy(but, rc); as rc may be set to but by jk_map_get_string().\n> \n> As a work around, I have created a second buffer char buf2[100] and used\n> that for def:\n> \n>  sprintf(buf2, \"%d\", def);\n>  rc = jk_map_get_string(m, name, buf2);\n\nI applied this fix after upgrading to Mavericks and it solved the problem."}, {"count": 9, "tags": [], "creator": "chris@christopherschultz.net", "attachment_id": null, "id": 170815, "time": "2013-10-24T18:03:04Z", "bug_id": 55696, "creation_time": "2013-10-24T18:03:04Z", "is_private": false, "text": "(In reply to Susan Burgee from comment #8)\n> (In reply to sandy from comment #0)\n> > Apple appears to have made strcpy() enforce that the src and dest buffers\n> > may not overlap. As a result jk_map_get_int() may fail on the line\n> > strcpy(but, rc); as rc may be set to but by jk_map_get_string().\n> > \n> > As a work around, I have created a second buffer char buf2[100] and used\n> > that for def:\n> > \n> >  sprintf(buf2, \"%d\", def);\n> >  rc = jk_map_get_string(m, name, buf2);\n> \n> I applied this fix after upgrading to Mavericks and it solved the problem.\n\nExactly which fix? Just adding a separate \"buf2[]\"? My fix is likely to remove the use of sprintf and avoid the problem entirely."}, {"count": 10, "tags": [], "creator": "chris@christopherschultz.net", "attachment_id": null, "id": 170820, "time": "2013-10-24T21:14:15Z", "bug_id": 55696, "creation_time": "2013-10-24T21:14:15Z", "is_private": false, "text": "I have verified that this patch works under both Linux and OS X Mavericks. I'll commit shortly.\n\nIndex: native/common/jk_map.c\n===================================================================\n--- native/common/jk_map.c\t(revision 1535519)\n+++ native/common/jk_map.c\t(working copy)\n@@ -183,33 +183,37 @@\n \n int jk_map_get_int(jk_map_t *m, const char *name, int def)\n {\n-    char buf[100];\n     const char *rc;\n-    size_t len;\n     int int_res;\n-    int multit = 1;\n \n-    sprintf(buf, \"%d\", def);\n-    rc = jk_map_get_string(m, name, buf);\n+    rc = jk_map_get_string(m, name, NULL);\n \n-    len = strlen(rc);\n-    if (len) {\n-        char *lastchar = &buf[0] + len - 1;\n-        strcpy(buf, rc);\n-        if ('m' == *lastchar || 'M' == *lastchar) {\n-            *lastchar = '\\0';\n-            multit = 1024 * 1024;\n+    if(NULL == rc) {\n+        int_res = def;\n+    } else {\n+        size_t len = strlen(rc);\n+        int multit = 1;\n+\n+        if (len) {\n+            char buf[100];\n+            char *lastchar;\n+            strncpy(buf, rc, 100);\n+\t    lastchar = buf + len - 1;\n+            if ('m' == *lastchar || 'M' == *lastchar) {\n+                *lastchar = '\\0';\n+                multit = 1024 * 1024;\n+            }\n+            else if ('k' == *lastchar || 'K' == *lastchar) {\n+                *lastchar = '\\0';\n+                multit = 1024;\n+            }\n+            int_res = multit * atoi(buf);\n         }\n-        else if ('k' == *lastchar || 'K' == *lastchar) {\n-            *lastchar = '\\0';\n-            multit = 1024;\n-        }\n-        int_res = atoi(buf);\n+        else\n+            int_res = def;\n     }\n-    else\n-        int_res = def;\n \n-    return int_res * multit;\n+    return int_res;\n }\n \n double jk_map_get_double(jk_map_t *m, const char *name, double def)"}, {"count": 11, "tags": [], "bug_id": 55696, "attachment_id": null, "text": "(In reply to Christopher Schultz from comment #10)\n\nLooks good.\n\nSome style comments\n1. Beware tabs. This line is formatted oddly because it has a tab character:\n> +\t    lastchar = buf + len - 1;\n\n2. \n> +        int multit = 1;\n\nCan be moved several lines below into the if(len) block.\n\nOr definition of \"char buf[100];\" could be moved up just below that line. (see below).\n\n3.\n> +            strncpy(buf, rc, 100);\n\ns/100/sizeof(buf)/ ?\n\n4. strncpy is not a safe function. It the string is longer than 100 characters it will truncate it without setting a 0 byte at the end.\n\nThus in other places it is actually strncpy(..., size-1), and it needs some code to explicitly set the size'th byte of the buffer to 0.\n\nMoreover, you are not recalculating \"len\" after copying thus if len > 100, the lastchar pointer will point to some place outside the buffer:\n\n> +\t    lastchar = buf + len - 1;\n\nThus maybe s/ if(len) / if (len && len < sizeof(buf)-1) / to resort to the defaults in this case.", "id": 170835, "time": "2013-10-25T10:55:20Z", "creator": "knst.kolinko@gmail.com", "creation_time": "2013-10-25T10:55:20Z", "is_private": false}, {"count": 12, "tags": [], "bug_id": 55696, "attachment_id": null, "text": "Konstantin,\n\nYeah, sorry about the tabs. I used vi in stupid-mode. I'll get close cleaned-up before a commit.\n\nAs for the stncpy, I was originally thinking that an int couldn't be longer than a few characters, but on further reflection, it doesn't matter: instead, its the user input that must be fewer than 100 characters if this isn't going to fail.\n\nI decided to use strncpy because the existing code used strcpy which was IMO even worse. I was thinking I might make a bigger change to use strtol() and actually look at the value of 'endptr' after the call. I didn't want a patch that made too many changes at once.\n\nBefore my patch, the strcpy was happening *after* the use of len. I'll clean that up, too.\n\nUsing strtol (instead of atoi) will do a better job of detecting problems with the actual \"value\" coming from the user. Right now, if you say worker.port=abc, then atoi will return an undefined value (probably 0) for that configuration option. I'll fix the other stuff and then look at using strtol.", "id": 170844, "time": "2013-10-25T15:54:18Z", "creator": "chris@christopherschultz.net", "creation_time": "2013-10-25T15:54:18Z", "is_private": false}, {"count": 13, "attachment_id": null, "bug_id": 55696, "text": "A more minimalistic patch would be (untested yet):\n\nIndex: common/jk_map.c\n===================================================================\n--- common/jk_map.c     (revision 1583423)\n+++ common/jk_map.c     (working copy)\n@@ -206,7 +206,6 @@\n     const char *rc;\n     size_t len;\n     int int_res;\n-    int multit = 1;\n\n     sprintf(buf, \"%d\", def);\n     rc = jk_map_get_string(m, name, buf);\n@@ -213,22 +212,21 @@\n\n     len = strlen(rc);\n     if (len) {\n-        char *lastchar = &buf[0] + len - 1;\n-        strcpy(buf, rc);\n+        const char *lastchar = &rc[0] + len - 1;\n+        int multit = 1;\n         if ('m' == *lastchar || 'M' == *lastchar) {\n-            *lastchar = '\\0';\n             multit = 1024 * 1024;\n         }\n         else if ('k' == *lastchar || 'K' == *lastchar) {\n-            *lastchar = '\\0';\n             multit = 1024;\n         }\n-        int_res = atoi(buf);\n+        /* Safe because atoi() will stop at any non-numeric lastchar */\n+        int_res = atoi(rc) * multit;\n     }\n     else\n         int_res = def;\n\n-    return int_res * multit;\n+    return int_res;\n }\n\n double jk_map_get_double(jk_map_t *m, const char *name, double def)\n\n\nThe only reason for using a copy of rc seems to be that we terminate the string after the number in case there was a scaling character (\"k\" or \"M\" etc.). But atoi should stop converting to a number when detecting such a character anyhow, so we don't nee to overwrite it with a zero byte and thus can operate on the original rc. No string copy, no overlap.\n\nMoving the use of multit completely to the non-default value block because it is a bit misleading to multiply in the default case (factor was \"1\" there).", "id": 174200, "time": "2014-04-01T15:55:36Z", "creator": "rainer.jung@kippdata.de", "creation_time": "2014-04-01T15:55:36Z", "tags": [], "is_private": false}, {"count": 14, "tags": [], "bug_id": 55696, "attachment_id": null, "text": "Fixed in 1583726.\nWill be part of version 1.2.40.", "id": 174201, "time": "2014-04-01T16:11:24Z", "creator": "rainer.jung@kippdata.de", "creation_time": "2014-04-01T16:11:24Z", "is_private": false}]