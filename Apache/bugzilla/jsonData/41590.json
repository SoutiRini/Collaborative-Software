[{"count": 0, "attachment_id": null, "bug_id": 41590, "is_private": false, "id": 99235, "time": "2007-02-11T00:24:11Z", "creator": "fly-away@user.i.zabor.com", "creation_time": "2007-02-11T00:24:11Z", "tags": [], "text": "I am testing apache-2.2.4 with mpm worker on FreeBSD 6.1.\nI found the bug when I runned bench mark test using jmeter.\n\nMy settings:\n<IfModule mpm_worker_module>\n    ServerLimit          12\n    MaxClients           768\n    MinSpareThreads      2\n    MaxSpareThreads      5\n    ThreadsPerChild      64\n    MaxRequestsPerChild   1000\n</IfModule>\n\n\nI found a lot of the httpd prosesses more than server-limit \ndirective, somtimes 25 or above.\nAlso server-status page have a lot of threads in \"Sending Reply\" status - \ngenerally for links to .php (used mod_php 5.2.0 and 5.2.1 - no difference)."}, {"count": 1, "tags": [], "creator": "trawick@apache.org", "text": "Read\nhttp://httpd.apache.org/docs/2.2/mod/worker.html\nstarting with\n\"In addition to the set of active child processes...\"\n\nIt seems that the PHP requests aren't finishing, which triggers the growth in\nprocesses.  You hit MaxRequestsPerChild or MaxSpareThreads, but because the PHP\nrequest is still running the child process can't actually exit.\n\nYour MaxSpareThreads and MaxRequestsPerChild values ensure frequent process\ncreation overhead.  I would recommend 192 and 0 for those directives, respectively.", "id": 99237, "time": "2007-02-11T04:57:32Z", "bug_id": 41590, "creation_time": "2007-02-11T04:57:32Z", "is_private": false, "attachment_id": null}, {"count": 2, "tags": [], "text": ">It seems that the PHP requests aren't finishing, which triggers the growth in\nprocesses.\n\nI think it so, but isn't must apache kill his old child follow ServerLimit \ndirective?\n\n>You hit MaxRequestsPerChild or MaxSpareThreads, but because the PHP\n>request is still running the child process can't actually exit.\n\nIs this normal? \nI think, catching all bugs in apache modules (special in mod_php) match more \nhard task then implementation mechanism of harsh killing old child. \n", "attachment_id": null, "id": 99244, "creation_time": "2007-02-11T09:45:43Z", "time": "2007-02-11T09:45:43Z", "creator": "fly-away@user.i.zabor.com", "bug_id": 41590, "is_private": false}, {"count": 3, "tags": [], "creator": "trawick@apache.org", "is_private": false, "text": "There is no limit on how long a request can take, so the server can't abruptly\nterminate requests except for \"apachectl stop\" or \"apachectl restart\"\nprocessing.  The server cannot distinguish a hung request from a lengthy query\nor computation.\n\nIn a scenario where there are many child processes trying to exit but held up by\na small number of long-running requests, exceeding ServerLimit (no longer\ncounting those exiting processes) allows the server to continue to handle the\nallowed load (MaxClients).\n", "id": 99259, "time": "2007-02-11T17:40:47Z", "bug_id": 41590, "creation_time": "2007-02-11T17:40:47Z", "attachment_id": null}, {"count": 4, "tags": [], "bug_id": 41590, "text": ">In a scenario where there are many child processes trying to exit but held up \nby\n>a small number of long-running requests, exceeding ServerLimit (no longer\n>counting those exiting processes) allows the server to continue to handle the\n>allowed load (MaxClients).\n\nMaxClients=ServerLimit*ThreadsPerChild\nThreadsPerChild is a constant.\nWhere can I see the reason to exceeding ServerLimit for \"handle the allowed \nload (MaxClients).\"?\n", "id": 99325, "attachment_id": null, "creator": "fly-away@user.i.zabor.com", "creation_time": "2007-02-13T04:18:28Z", "time": "2007-02-13T04:18:28Z", "is_private": false}, {"count": 5, "attachment_id": null, "bug_id": 41590, "is_private": false, "id": 99326, "time": "2007-02-13T04:39:59Z", "creator": "trawick@apache.org", "creation_time": "2007-02-13T04:39:59Z", "tags": [], "text": ">MaxClients=ServerLimit*ThreadsPerChild\n>ThreadsPerChild is a constant.\n\nIn a child process trying to gracefully exit, there are actually fewer than\nThreadsPerChild  active threads handling requests.  Threads which have finished\ntheir last request will have exited.\n\nMaxClients and the reserved scoreboard space are still a constant.  If there are\ngracefully exiting child processes and a new process is created and there is\nunused process slot in the scoreboard, the new process will share a slot with a\ngracefully exiting child process, and will only be able to create as many\nthreads as have exited from the gracefully exiting process.  So the number of\nthreads in that slot for the two processes doesn't exceed ThreadsPerChild.\n\nI suggest reading/studying/gdb-ing the worker MPM source code if you want more\ninformation."}]