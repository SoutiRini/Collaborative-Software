[{"count": 0, "tags": [], "creator": "apptaro@gmail.com", "attachment_id": null, "id": 144286, "time": "2011-02-15T02:24:09Z", "bug_id": 50779, "creation_time": "2011-02-15T02:24:09Z", "is_private": false, "text": "The following error occurs when reading some Excel file saved with Excel 2003:\n\nException in thread \"main\"\norg.apache.poi.hssf.record.RecordFormatException: Unable to construct record instance\n       at org.apache.poi.hssf.record.RecordFactory$ReflectionConstructorRecordCreator.create(RecordFactory.java:65)\n       at org.apache.poi.hssf.record.RecordFactory.createSingleRecord(RecordFactory.java:300)\n       at org.apache.poi.hssf.record.RecordFactoryInputStream.readNextRecord(RecordFactoryInputStream.java:270)\n       at org.apache.poi.hssf.record.RecordFactoryInputStream.nextRecord(RecordFactoryInputStream.java:236)\n       at org.apache.poi.hssf.record.RecordFactory.createRecords(RecordFactory.java:442)\n       at org.apache.poi.hssf.usermodel.HSSFWorkbook.<init>(HSSFWorkbook.java:263)\n       at org.apache.poi.hssf.usermodel.HSSFWorkbook.<init>(HSSFWorkbook.java:188)\n       at org.apache.poi.hssf.usermodel.HSSFWorkbook.<init>(HSSFWorkbook.java:305)\n       at org.apache.poi.hssf.usermodel.HSSFWorkbook.<init>(HSSFWorkbook.java:286)\n       at aflat4.apps.adr.POITest.main(POITest.java:18)\nCaused by: org.apache.poi.hssf.record.RecordFormatException: Not enough data (1) to read requested (2) bytes\n       at org.apache.poi.hssf.record.RecordInputStream.checkRecordPosition(RecordInputStream.java:216)\n       at org.apache.poi.hssf.record.RecordInputStream.readUShort(RecordInputStream.java:267)\n       at org.apache.poi.util.StringUtil.readUnicodeLE(StringUtil.java:277)\n       at org.apache.poi.hssf.record.common.UnicodeString$ExtRst.<init>(UnicodeString.java:172)\n       at org.apache.poi.hssf.record.common.UnicodeString.<init>(UnicodeString.java:438)\n       at org.apache.poi.hssf.record.SSTDeserializer.manufactureStrings(SSTDeserializer.java:55)\n       at org.apache.poi.hssf.record.SSTRecord.<init>(SSTRecord.java:250)\n       at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n       at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)\n       at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)\n       at java.lang.reflect.Constructor.newInstance(Constructor.java:494)\n       at org.apache.poi.hssf.record.RecordFactory$ReflectionConstructorRecordCreator.create(RecordFactory.java:57)\n       ... 9 more"}, {"count": 1, "tags": [], "creator": "apptaro@gmail.com", "attachment_id": null, "id": 144287, "time": "2011-02-15T02:31:23Z", "bug_id": 50779, "creation_time": "2011-02-15T02:31:23Z", "is_private": false, "text": "This error occurs with some Excel files that have many unicode character strings with phonetic data. Details are described here:\nhttp://thread.gmane.org/gmane.comp.jakarta.poi.user/16008/focus=16077\n\nI have a Excel file that causes the error, but I can put it here because it is confidential. I'm trying to create a test file to duplicate the issue."}, {"count": 2, "tags": [], "bug_id": 50779, "attachment_id": 26658, "text": "Created attachment 26658\nUnicodeStringFailCase1", "id": 144289, "time": "2011-02-15T02:59:39Z", "creator": "apptaro@gmail.com", "creation_time": "2011-02-15T02:59:39Z", "is_private": false}, {"count": 3, "tags": [], "bug_id": 50779, "attachment_id": 26659, "text": "Created attachment 26659\nUnicodeStringFailCase2", "id": 144290, "time": "2011-02-15T03:00:40Z", "creator": "apptaro@gmail.com", "creation_time": "2011-02-15T03:00:40Z", "is_private": false}, {"count": 4, "tags": [], "creator": "apptaro@gmail.com", "text": "Two test files are attached. Both are created in Japanese Excel 2003.\n\nUnicodeStringFailCase1.xls produces the original error. This is the case where a CONTINUE record appears in ExtRst and split two bytes of a unicode character.\n\nUnicode StringFailCase2.xls produces a slightly different error below. This is the case where a CONTINUE record appears in PhRun and split two bytes of a unsigned short value.\n\nException in thread \"main\" org.apache.poi.hssf.record.RecordFormatException: Unable to construct record instance\n       at org.apache.poi.hssf.record.RecordFactory$ReflectionConstructorRecordCreator.create(RecordFactory.java:65)\n       at org.apache.poi.hssf.record.RecordFactory.createSingleRecord(RecordFactory.java:300)\n       at org.apache.poi.hssf.record.RecordFactoryInputStream.readNextRecord(RecordFactoryInputStream.java:270)\n       at org.apache.poi.hssf.record.RecordFactoryInputStream.nextRecord(RecordFactoryInputStream.java:236)\n       at org.apache.poi.hssf.record.RecordFactory.createRecords(RecordFactory.java:442)\n       at org.apache.poi.hssf.usermodel.HSSFWorkbook.<init>(HSSFWorkbook.java:263)\n       at org.apache.poi.hssf.usermodel.HSSFWorkbook.<init>(HSSFWorkbook.java:188)\n       at org.apache.poi.hssf.usermodel.HSSFWorkbook.<init>(HSSFWorkbook.java:305)\n       at org.apache.poi.hssf.usermodel.HSSFWorkbook.<init>(HSSFWorkbook.java:286)\n       at aflat4.apps.adr.POITest.main(POITest.java:18)\n\nCaused by: org.apache.poi.hssf.record.RecordFormatException: Not enough data (1) to read requested (2) bytes\n       at org.apache.poi.hssf.record.RecordInputStream.checkRecordPosition(RecordInputStream.java:216)\n       at org.apache.poi.hssf.record.RecordInputStream.readUShort(RecordInputStream.java:267)\n       at org.apache.poi.hssf.record.common.UnicodeString$PhRun.<init>(UnicodeString.java:309)\n       at org.apache.poi.hssf.record.common.UnicodeString$PhRun.<init>(UnicodeString.java:297)\n       at org.apache.poi.hssf.record.common.UnicodeString$ExtRst.<init>(UnicodeString.java:178)\n       at org.apache.poi.hssf.record.common.UnicodeString.<init>(UnicodeString.java:438)\n       at org.apache.poi.hssf.record.SSTDeserializer.manufactureStrings(SSTDeserializer.java:55)\n       at org.apache.poi.hssf.record.SSTRecord.<init>(SSTRecord.java:250)\n       at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n       at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)\n       at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)\n       at java.lang.reflect.Constructor.newInstance(Constructor.java:494)\n       at org.apache.poi.hssf.record.RecordFactory$ReflectionConstructorRecordCreator.create(RecordFactory.java:57)\n       ... 9 more", "id": 144291, "time": "2011-02-15T03:09:13Z", "bug_id": 50779, "creation_time": "2011-02-15T03:09:13Z", "is_private": false, "attachment_id": null}, {"count": 5, "tags": [], "bug_id": 50779, "attachment_id": null, "text": "Interesting. So far we assumed that for primitive types (short, int, long, etc.) a continue record break always occurs at the type boundary. Your attachments clearly demonstrate that it is not always so and a  CONTINUE break can be in the middle of a primitive type. \n\nI know how to fix it, but I'm hesitating whether this behavior should be default or only applied to this particular case. \n\nInitialization of BIFF records sits on top of the RecordInputStream class which greedily reads the primitive types. To properly handle CONTINUE it needs to reads byte by byte and then make sense of the read data. Something like this:\n        \n        // current version. Does not work if CONTINUE occurs between two bytes.\n\tpublic int readUShort() {\n            checkRecordPosition(LittleEndian.SHORT_SIZE);\n            _currentDataOffset += LittleEndian.SHORT_SIZE;\n            return _dataInput.readUShort();\n\t}\n\n        // Corrected. readByte() rolls over CONTINUE if necessary\n\tpublic int readUShort() {\n            int ch1 = readByte();\n            int ch2 = readByte();\n            return (ch2 << 8) + (ch1 << 0);\n\t}\n\n\nNote that there is at least one case where readShort() must be greedy: for double-byte characters a Continue record  break MUST occur at the double-byte character boundary.\n\nYegor", "id": 144801, "time": "2011-03-07T09:18:34Z", "creator": "yegor@dinom.ru", "creation_time": "2011-03-07T09:18:34Z", "is_private": false}, {"count": 6, "tags": [], "creator": "yegor@dinom.ru", "text": "Created attachment 26740\njunit test to demonsrate the bug\n\nto be included in the poi test collection...", "id": 144802, "time": "2011-03-07T09:20:36Z", "bug_id": 50779, "creation_time": "2011-03-07T09:20:36Z", "is_private": false, "attachment_id": 26740}, {"count": 7, "tags": [], "creator": "yegor@dinom.ru", "text": "Fixed in r1080496, junit added\n\nMy previous comment was not quite correct, I should have read the poi-user thread more thoroughly. \n\nThe fix only applies to the phonetic stuff, it does seem to be special and can contain a CONTINUE break between two bytes of a unicode character or a 'short' data. \n\nThe trick is to pass a decorated LittleEndianInput to the the ExtRst constructor and this decorated instance properly handles  CONTINUE breaks in the middle of primitive data types. \n\nYegor", "id": 144933, "time": "2011-03-11T05:12:54Z", "bug_id": 50779, "creation_time": "2011-03-11T05:12:54Z", "is_private": false, "attachment_id": null}, {"count": 8, "tags": [], "bug_id": 50779, "attachment_id": null, "text": "As a reporter, I built r1080496, tested and confirmed that the bug is resolved. Thank you for fixing!", "id": 144983, "time": "2011-03-13T23:00:03Z", "creator": "apptaro@gmail.com", "creation_time": "2011-03-13T23:00:03Z", "is_private": false}]