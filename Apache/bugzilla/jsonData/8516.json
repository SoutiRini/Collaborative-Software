[{"count": 0, "tags": [], "bug_id": 8516, "attachment_id": null, "text": "The following patch allows the matching of a specific file extension to an \nISAPI dll.\n\nAdding the following conf to your httpd.conf file:\n\n<IfModule mod_isapi.c>\n    MapExtension .wsdl \"C:/Progra~1/Common~1/MSSoap/Binaries/soapisap.dll\"\n    ISAPICacheFile \"C:/Progra~1/Common~1/MSSoap/Binaries/soapisap.dll\"\n    ISAPILogNotSupported off\n</IfModule>\n\nwill map a request of a .wsdl file to the ISAPI module specified on the \nMapExtension command\n\nHere is the patch:\n\n--- mod_isapi.old\tFri Mar 29 01:17:20 2002\n+++ mod_isapi.c\tThu Apr 25 10:02:29 2002\n@@ -134,6 +134,7 @@\n /* Our isapi server config structure */\n \n typedef struct {\n+    apr_array_header_t *dllmap;\n     apr_array_header_t *loaded;\n     DWORD ReadAheadBuffer;\n     int LogNotSupported;\n@@ -141,6 +142,13 @@\n     int AppendLogToQuery;\n } isapi_server_conf;\n \n+/* map from file extension to dll name */\n+\n+typedef struct {\n+    const char *ext;\n+    const char *path;\n+} isapi_dll_map;\n+\n /* Our loaded isapi module description structure */\n \n typedef struct {\n@@ -172,6 +180,7 @@\n {\n     isapi_server_conf *sconf = apr_palloc(p, sizeof(isapi_server_conf));\n     sconf->loaded = apr_array_make(p, 20, sizeof(isapi_loaded*));\n+    sconf->dllmap = apr_array_make(p, 10, sizeof(isapi_dll_map));\n     \n     sconf->ReadAheadBuffer = 49152;\n     sconf->LogNotSupported    = -1;\n@@ -214,14 +223,45 @@\n     return isapi_unload((isapi_loaded*) isa, TRUE);\n }\n \n+/* isapi_get_extension returns the extension of a given filename */\n+\n+static const char *isapi_get_extension(const char *fName)\n+{\n+    const char *retval = strrchr(fName, '.');\n+\n+    return retval != NULL ? retval : \"\";\n+}\n+\n static apr_status_t isapi_load(apr_pool_t *p, isapi_server_conf *sconf, \n                                request_rec *r, const char *fpath, \n-                               isapi_loaded** isa)\n+                               isapi_loaded** isa, int *mapping_done)\n {\n     isapi_loaded **found = (isapi_loaded **)sconf->loaded->elts;\n     apr_status_t rv;\n     int n;\n \n+    const char *ext = isapi_get_extension(fpath);\n+\n+    *mapping_done = FALSE;\n+\n+    /*\n+        if the requested extension is not dll, see if we have a mapping defined\n+        for this extension\n+    */\n+\n+    if (stricmp(ext, \".dll\") != 0) {\n+        int i;\n+        isapi_dll_map *ent = (isapi_dll_map *) sconf->dllmap->elts;\n+\n+        for (i = 0; i < sconf->dllmap->nelts; ++i) {\n+            if (stricmp(ext, ent[i].ext) == 0) {\n+                fpath = ent[i].path;\n+                *mapping_done = TRUE;\n+                break;\n+            }\n+        }\n+    }\n+\n     for (n = 0; n < sconf->loaded->nelts; ++n) {\n         if (strcasecmp(fpath, (*found)->filename) == 0) {\n             break;\n@@ -342,7 +382,8 @@\n     const char *val;\n     DWORD read;\n     int res;\n-    \n+    int mapping_done;\n+\n     if(strcmp(r->handler, \"isapi-isa\"))\n         return DECLINED;    \n \n@@ -368,7 +409,7 @@\n     /* Load the isapi extention without caching (sconf == NULL) \n      * but note that we will recover an existing cached module.\n      */\n-    if (isapi_load(r->pool, sconf, r, r->filename, &isa) != APR_SUCCESS)\n+    if (isapi_load(r->pool, sconf, r, r->filename, &isa, &mapping_done) != \nAPR_SUCCESS)\n         return HTTP_INTERNAL_SERVER_ERROR;\n         \n     /* Set up variables */\n@@ -402,9 +443,11 @@\n     cid->ecb->lpszQueryString = apr_pstrdup(r->pool, \n                                 (char*) apr_table_get(e, \"QUERY_STRING\"));\n     cid->ecb->lpszPathInfo = apr_pstrdup(r->pool, \n-                             (char*) apr_table_get(e, \"PATH_INFO\"));\n+                                         mapping_done ? r->filename \n+                                                      : (char*) apr_table_get\n(e, \"PATH_INFO\"));\n     cid->ecb->lpszPathTranslated = apr_pstrdup(r->pool, \n-                                   (char*) apr_table_get\n(e, \"PATH_TRANSLATED\"));\n+                                               mapping_done ? r->filename \n+                                                            : (char*) \napr_table_get(e, \"PATH_TRANSLATED\"));\n     cid->ecb->lpszContentType = apr_pstrdup(r->pool, \n                                 (char*) apr_table_get(e, \"CONTENT_TYPE\"));\n     /* Set up the callbacks */\n@@ -468,6 +511,7 @@\n         cid->ecb->lpbData = NULL;\n     }\n \n+    cid->complete = CreateEvent(NULL, FALSE, FALSE, NULL);\n     /* All right... try and run the sucker */\n     rv = (*isa->HttpExtensionProc)(cid->ecb);\n \n@@ -510,7 +554,6 @@\n                 }\n             }\n             else {\n-                cid->complete = CreateEvent(NULL, FALSE, FALSE, NULL);\n                 if (WaitForSingleObject(cid->complete, isa->timeout)\n                         == WAIT_TIMEOUT) {\n                     /* TODO: Now what... if this hung, then do we kill our own\n@@ -533,6 +576,9 @@\n             break;\n     }\n \n+\tCloseHandle(cid->complete);\n+\tcid->complete = NULL;\n+\n     /* Set the status (for logging) */\n     if (cid->ecb->dwHttpStatusCode) {\n         cid->r->status = cid->ecb->dwHttpStatusCode;\n@@ -1151,6 +1197,22 @@\n }\n \n /*\n+ * Command handler for the MapExtension directive, which is TAKE2\n+ */\n+static const char *isapi_cmd_mapExtension(cmd_parms *cmd, void *config, const \nchar *ext, const char *path)\n+{\n+    isapi_server_conf *sconf = ap_get_module_config(cmd->server->module_config,\n+                                                    &isapi_module);\n+    isapi_dll_map *newData;\n+\n+    newData = apr_array_push(sconf->dllmap);\n+    newData->ext = ext;\n+    newData->path = ap_server_root_relative(cmd->pool, path);\n+\n+    return NULL;\n+}\n+\n+/*\n  * Command handler for the ISAPIReadAheadBuffer directive, which is TAKE1\n  */\n static const char *isapi_cmd_readaheadbuffer(cmd_parms *cmd, void *config, \n@@ -1235,6 +1297,7 @@\n     apr_finfo_t tmp;\n     apr_status_t rv;\n     char *fspec;\n+\tint   mapping_done;\n     \n     fspec = ap_server_root_relative(cmd->pool, filename);\n     if (!fspec) {\n@@ -1255,7 +1318,7 @@\n     }\n \n     /* Load the extention as cached (passing sconf) */\n-    rv = isapi_load(cmd->pool, sconf, NULL, fspec, &isa); \n+    rv = isapi_load(cmd->pool, sconf, NULL, fspec, &isa, &mapping_done); \n     if (rv != APR_SUCCESS) {\n         ap_log_error(APLOG_MARK, APLOG_WARNING, rv, cmd->server,\n                      \"ISAPI: unable to cache %s, skipping\", fspec);\n@@ -1286,6 +1349,8 @@\n   \"Append Log requests are concatinated to the query args\"),\n AP_INIT_ITERATE(\"ISAPICacheFile\", isapi_cmd_cachefile, NULL, RSRC_CONF,\n   \"Cache the specified ISAPI extension in-process\"),\n+AP_INIT_TAKE2(\"MapExtension\", isapi_cmd_mapExtension, NULL, RSRC_CONF,\n+  \"Maps a file extension to a ISAPI module\"),\n { NULL }\n };", "id": 14730, "time": "2002-04-25T14:23:53Z", "creator": "pierre.bisaillon@ixiasoft.com", "creation_time": "2002-04-25T14:23:53Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 8516, "attachment_id": null, "text": "You might have overlooked one detail.\n\nWithout all of the additional code, you can accomplish what you seek in\nthe following directives;\n\nAddHandler isapi-isa .dll\nISAPICacheFile \"C:/Program Files/Common Files/MSSoap/Binaries/soapisap.dll\"\n\nScriptAlias /cgi-bin/soapisap.dll \"C:/Program Files/Common\nFiles/MSSoap/Binaries/soapisap.dll\"\nAction soap-handler \"/cgi-bin/soapisap.dll\"\n\nAddHandler soap-handler .wsdl\n\nSo I don't see us adopting code that is already covered in existing modules.\n\nPerhaps an alternative Action directive that bypassed URI space, that is,\nwhich could directly reference a cgi file outside of the URI schema\nwithout extra aliasing, would be considered.\n", "id": 14896, "time": "2002-04-27T03:58:04Z", "creator": "wrowe@apache.org", "creation_time": "2002-04-27T03:58:04Z", "is_private": false}, {"count": 2, "tags": [], "creator": "pierre.bisaillon@ixiasoft.com", "text": "I tried your solution, and apparently it does not give the same functionnality.\n\nLet's suppose I request the page http://localhost/virtdir/myfile.wsdl\nand my isapi dll is c:\\mydlldir\\mydll.dll\n\nin my solution, we have:\nlocalhost/virtdir gets resolved to a path (for example c:\\testdir), so I get a \nrequest for file c:\\testdir\\myfile.wsdl\nthen, the isapi module gets called, loads the dll associated with the .wsdl \nextension, and executes the isapi call, passing the file c:\\testdir\\myfile.wsdl \nto the isapi dll.\n\nin your solution, we have:\nSince we have a handler, localhost gets replaced by /cgi-bin/soapisap.dll; we \nnow have the uri /cgi-bin/soapisap.dll/virtdir/myfile.wsdl\n/cgi-bin/soapisap.dll/ gets remapped to \"c:\\mydlldir\\mydll.dll\"\nwe then get a request for the file c:\\mydlldir\\mydll.dll\\virtdir\\myfile.wsdl, \nwhich the isapi module can't handle.\n", "id": 15068, "time": "2002-04-29T19:01:34Z", "bug_id": 8516, "creation_time": "2002-04-29T19:01:34Z", "is_private": false, "attachment_id": null}, {"count": 3, "tags": [], "bug_id": 8516, "attachment_id": null, "text": "\n  I see your issue, although I wouldn't classify it as a problem, I'd\n  suggest we reframe this as an \"Enhancement request to mod_action\" to\n  effectively implement a 'script action' that is hidden from the\n  perspective of the envvars reviewed by the script.\n\n  HOWEVER, SOAPISAP.DLL WAS AN ANALOGY!!!  Suppose the ISAPI will\n  be c:\\mydlldir\\mydll.dll and http://localhost/virtdir/myfile.wsdl\n  will be invoked.\n\n  ScriptAlias /wsdl \"c:/mydlldir/mydll.dll\"\n  Action my-handler \"/wsdl\"\n  AddHandler my-handler .wsdl\n\n  Is a much simpler way of saying things.\n\n  I'd suggest the improvement would be an Action that maps, instead\n  of to a URI, into a File.  Say, a ScriptAction directive (ScriptAlias\n  plus Action, eh?)\n\n  Now this could be applied [explicitly] to cause a certain program or\n  module to be invoked for a given class of requests, as follows;\n\n  ScriptAction my-handler \"c:/mydlldir/mydll.dll\"\n  AddHandler my-handler .wsdl\n\n  I'll ask Josh Slive and others to look at this proposal and tell me\n  why we don't need new directives [surely we can already do this, no?]\n\n", "id": 16117, "time": "2002-05-15T03:12:52Z", "creator": "wrowe@apache.org", "creation_time": "2002-05-15T03:12:52Z", "is_private": false}, {"count": 4, "tags": [], "bug_id": 8516, "attachment_id": null, "text": "\n\n*** This bug has been marked as a duplicate of 7483 ***", "id": 20708, "time": "2002-08-06T16:43:28Z", "creator": "wrowe@apache.org", "creation_time": "2002-08-06T16:43:28Z", "is_private": false}]