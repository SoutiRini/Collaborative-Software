[{"count": 0, "tags": [], "creator": "james.silk@metaswitch.com", "is_private": false, "id": 190646, "creation_time": "2016-04-29T15:04:19Z", "time": "2016-04-29T15:04:19Z", "bug_id": 59398, "text": "(This is the first bug I've raised in Tomcat so apologies if I've missed something out!)\n\nIn responding to a request in tomcat using a HttpServletResponse object, xiResponse, our server create a JSON string to send back and writes it to the response with the following code:\n\n...\n      writer = xiResponse.getWriter();\n      writer.write(jsonToSend);\n      writer.close();\n...\n\nWhich throws the following exception:\n\norg.apache.tomcat.jni.Error: 88: Socket operation on non-socket\nat org.apache.tomcat.jni.Socket.sendbb(Native Method)\nat org.apache.coyote.http11.InternalAprOutputBuffer.writeToSocket(InternalAprOutputBuffer.java:287)\nat org.apache.coyote.http11.InternalAprOutputBuffer.writeToSocket(InternalAprOutputBuffer.java:265)\nat org.apache.coyote.http11.InternalAprOutputBuffer.flushBuffer(InternalAprOutputBuffer.java:213)\nat org.apache.coyote.http11.AbstractOutputBuffer.endRequest(AbstractOutputBuffer.java:378)\nat org.apache.coyote.http11.AbstractHttp11Processor.action(AbstractHttp11Processor.java:726)\nat org.apache.coyote.Response.action(Response.java:177)\nat org.apache.catalina.connector.OutputBuffer.close(OutputBuffer.java:306)\nat org.apache.catalina.connector.CoyoteWriter.close(CoyoteWriter.java:108)\nat dcl.mwp.servlet.EventProcessor.writeResponse(EventProcessor.java:684)\nat dcl.mwp.servlet.EventProcessor.access$100(EventProcessor.java:53)\nat dcl.mwp.servlet.EventProcessor$AsyncListener.commandCompleted(EventProcessor.java:1129)\nat dcl.mwp.cstasoap.CSTASOAPCommandFactory$CSTASOAPAsyncCommand$CSTAAxis2Callback.onMessage(CSTASOAPCommandFactory.java:1754)\nat org.apache.axis2.description.OutInAxisOperationClient$NonBlockingInvocationWorker.run(OutInAxisOperation.java:471)\nat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\nat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\nat java.lang.Thread.run(Thread.java:722)\n\n(Note that dcl.mwp.servlet.EventProcessor.writeResponse is the writer.close() call above)\n\nCatching this in a debugger shows that the writer.close() call failed as the socket we're trying to close is '0' implying that something else has already closed the socket. From this I think the exception thrown by sendbb is perfectly valid but it shouldn't make it all the way up to the print writer.\n\nFrom the PrintWriter docs there should be no exception thrown by this method and more over 'Closing a previously closed stream has no effect'.\n\nGetting network capture from this event shows that the data we're trying to send has been sent over the wire and the far end sent a 'fin' on the TCP connection. Moving the writer.close() call above the writer.write() call results in the same exception, indicating that the client is not responsible for closing this under the feet of tomcat.\n\nI believe something inside tomcat is recycling this socket under our feet but even so I don't believe the writer.close call should fail in this way.", "attachment_id": null}, {"count": 1, "tags": [], "bug_id": 59398, "is_private": false, "id": 190649, "creation_time": "2016-04-29T16:09:11Z", "time": "2016-04-29T16:09:11Z", "creator": "remm@apache.org", "text": "This looks like a combination of using uncontrolled async processing (the Servlet 3.0 specification specified that) and APR, which isn't very nice when something bad happens, but it can't really be fixed.\n\nSince you're using Tomcat 8.0, you can use the default NIO connector which will give reasonable scalability and hopefully better edge case handling.", "attachment_id": null}, {"text": "Thanks for the suggestion. Moving to the NIO connector does get us round this issue but we hit https://bz.apache.org/bugzilla/show_bug.cgi?id=58646 and while we could upgrade to tomcat 8.0.33 to fix this we're nervous about switching from the APR connector to NIO connectors as we moved to APR for performance reasons and at the stage we're at in our release cycle we can't change this. \n\nIt does feel like there is a fairly straight forward issue in tomcat though as calling close on a PrintWriter twice should succeed, and shouldn't throw an exception, as this is the documented behaviour.\n\n(Also I don't feel like the fact that this is difficult to fix makes it 'invalid'... possibly it won't get fixed but we're not doing anything that shouldn't be supported in tomcat as it's currently documented)", "tags": [], "bug_id": 59398, "attachment_id": null, "count": 2, "id": 190786, "time": "2016-05-09T16:56:54Z", "creator": "james.silk@metaswitch.com", "creation_time": "2016-05-09T16:56:54Z", "is_private": false}, {"count": 3, "tags": [], "creator": "markt@apache.org", "attachment_id": null, "id": 190788, "time": "2016-05-09T18:29:33Z", "bug_id": 59398, "creation_time": "2016-05-09T18:29:33Z", "is_private": false, "text": "This looks like application mis-behaviour to me: continuing to access the request/response object (or objects obtained from them) after processing has completed for the original request/response pair. Given what can go wrong in that case, an Exception is the least of your worries.\n\nIf you can provide a simple as possible test case that demonstrates this issue without the application behaving as I describe above then please do re-open this."}, {"count": 4, "tags": [], "creator": "james.silk@metaswitch.com", "attachment_id": null, "id": 191022, "creation_time": "2016-05-17T12:29:36Z", "time": "2016-05-17T12:29:36Z", "bug_id": 59398, "text": "So I've done some more digging into this and the issue is that org.apache.coyote.http11.InternalAprOutputBuffer.recycle is not synchronized. This leaves the door open to the bytebuffer and socket being reset while data is being written to the socket by org.apache.coyote.http11.InternalAprOutputBuffer.writeToSocket, which is synchronized, and this is what was biting me. So I propose the following fix:\n\n--- tomcat-8-28-src/java/org/apache/coyote/http11/InternalAprOutputBuffer.java (revision 10252)\n+++ tomcat-8-28-src/java/org/apache/coyote/http11/InternalAprOutputBuffer.java (working copy)\n@@ -105,7 +105,7 @@\n      * connection.\n      */\n     @Override\n-    public void recycle() {\n+    public synchronized void recycle() {\n\n         super.recycle();\n\n\nNote that I've checked and this method is not synchronized in tomcat 8.0.33 or 8.5 but I believe it should be. This is the first patch I've tried to submit to tomcat so apologies if there is some process I've not followed (and if this is the case please point me at it and I'll be happy to follow it!).", "is_private": false}, {"count": 5, "attachment_id": null, "bug_id": 59398, "text": "Section 2.3.3.4 of the Servlet specification is explicit that thread safe access to container managed objects is the responsibility of the caller. This includes the Writer.", "id": 191023, "time": "2016-05-17T13:04:37Z", "creator": "markt@apache.org", "creation_time": "2016-05-17T13:04:37Z", "tags": [], "is_private": false}, {"attachment_id": null, "tags": [], "bug_id": 59398, "text": "I can sympathize since a lot of the APR code is synced now, but this is really wrong behavior.", "count": 6, "id": 191024, "time": "2016-05-17T13:41:37Z", "creator": "remm@apache.org", "creation_time": "2016-05-17T13:41:37Z", "is_private": false}]