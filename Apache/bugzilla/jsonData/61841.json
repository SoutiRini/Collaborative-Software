[{"count": 0, "text": "Created attachment 35573\nSimple testcase\n\nHi all,\nI spotted a problem in the evaluation of VLOOKUP function when the table area is defined as all column reference.\n\nBasically, when a \"all column\" reference is used, the evaluation code treats the reference as if it's applied to the maximum number of rows available for the workbook version.\n\nIn practice every reference as a $C:$D is translated as a $C$1:$D$1048576.\nWhen such references are used a table argument for a VLOOKUP (exact match) and the value to be searched is not found, the evaluation code loops for 2^20 times.\n\nA proposed fix could be to translate the \"all column\" reference to a reference that goes from row 1 to the maximum row of the considered sheet.\n\nI attached a simple xlsx workbook that takes a *very long* time to evaluate about 300 VLOOKUPs.\n\nA fix could be to enhance the logic of OperationEvaluationContext.getDynamicReference to translate the reference to a narrow area.\nI am available for any clarification.\n\nBest regards,\n    Luca", "bug_id": 61841, "attachment_id": 35573, "id": 202515, "time": "2017-12-01T14:00:29Z", "creator": "lucamartini@tagetik.com", "creation_time": "2017-12-01T14:00:29Z", "tags": [], "is_private": false}, {"count": 1, "text": "Would you be able to put together a patch with the improved logic in?\n\nSee http://poi.apache.org/guidelines.html and http://poi.apache.org/howtobuild.html and http://poi.apache.org/subversion.html for more on building and contributing!", "bug_id": 61841, "attachment_id": null, "id": 202516, "time": "2017-12-01T14:05:27Z", "creator": "apache@gagravarr.org", "creation_time": "2017-12-01T14:05:27Z", "tags": [], "is_private": false}, {"count": 2, "tags": [], "bug_id": 61841, "attachment_id": null, "id": 202518, "time": "2017-12-01T15:35:34Z", "creator": "lucamartini@tagetik.com", "creation_time": "2017-12-01T15:35:34Z", "is_private": false, "text": "Nick,\nI have already contributed some patches in the past. \nHowever I am not sure to have the time to work to this fix at the moment.\nI opened the bug for future reference and to check if someone with more knowledge about evaluators could help.\nIn fact, at a first glance, the current workbook is not easy recoverable from the WorkbookEvaluator without changing its interface and I am not sure that is safe and sound to do so."}, {"count": 3, "text": "Looking at the POI implementation of Vlookup.java, the class currently doesn't have a reference to the sheet that contains the lookup table. This will make a fix non-trivial.\n\nThe function that creates the AreaEval that is passed to the evaluate function might have a reference to the lookup sheet.\nCaveats: lookup table may be contained in a different workbook or sheet than the cell that contains the formula that is being evaluated.", "bug_id": 61841, "attachment_id": null, "id": 202523, "time": "2017-12-01T18:05:44Z", "creator": "onealj@apache.org", "creation_time": "2017-12-01T18:05:44Z", "tags": [], "is_private": false}, {"count": 4, "tags": [], "creator": "gwoolsey@apache.org", "attachment_id": null, "text": "It looks to me like the sheet is available:\n\nVlookup.evalutate() receives a ValueEval that is converted to a TwoDEval via LookupUtils.resolveTableArrayArg().\n\nTwoDEval interface has only one base class implementing it, AreaEvalBase.\n\nAreaEvalBase abstract class has 2 non-test implementations, cached and lazy.  In both cases actual cell ValueEval references are available, which means sheet/row/column eventually.  Seems to me we could augment the TwoDEval interface to indicate the last physical values for rows and columns along with the existing getWidth() and getHeight() methods.  These could be used when creating ValueVector objects for the lookup iterations to reduce the vector size to the maximum defined values, since no matches would exist outside those anyway.", "id": 202582, "time": "2017-12-05T19:53:35Z", "bug_id": 61841, "creation_time": "2017-12-05T19:53:35Z", "is_private": false}, {"count": 5, "tags": [], "creator": "gwoolsey@apache.org", "attachment_id": null, "is_private": false, "id": 202592, "time": "2017-12-06T00:19:12Z", "bug_id": 61841, "creation_time": "2017-12-06T00:19:12Z", "text": "Changes in r1817252\n\nInteresting.  In a local test with the attached sample file, I found these results:\n\n45s (second run) \nwith current codebase issuing FormulaEvaluator.evaluateAll() on the workbook.\n\n19s \nBy just changing XSSFEvaluationSheet.getCell(row, col) to immediately return null if the row index > sheet.getLastRowNum() \n\n14.4s\nwhen XSSFEvaluationSheet caches the value of getLastRowNum(), since it comes from a TreeMap.lastKey() which has to navigate the tree each time to find the last key.\n\n12.1s\nafter optimizing the blank cell tracking a bit to know about the last row with data.\n\nThat's all without changing anything int he VLOOKUP evaluation and still iterating over the max # of rows per column.\n\nOf this remaining time, about 2/3 is taken up in the formula evaluation caching and tracking mechanism.  Bypassing it for null cells causes test failures, which shows it is necessary, but relatively expensive.  It appears to try to optimize and minimize the \"empty cell\" rectangular regions it holds. but assumes processing by row then column.  That may be a memory/time optimization we want to consider allowing additional strategies for.\n\nNote that this shortcut logic doesn't change the result of any methods, only avoids busywork that didn't apply to the \"nonexistent cell\" cases.\n\nThis doesn't optimize VLOOKUP directly, but is about 70% improvement sufficient?\n\nChanging the VLOOKUP code itself is actually significantly more complex, because POI handles sheets by row internally, and columns are second-class constructs.  There is no easy way to determine the last row with data in a column other than iterating over all defined rows.  With these optimizations, the extra iterations should fail fast."}, {"count": 6, "tags": [], "bug_id": 61841, "attachment_id": null, "id": 202593, "time": "2017-12-06T09:56:36Z", "creator": "onealj@apache.org", "creation_time": "2017-12-06T09:56:36Z", "is_private": false, "text": "(In reply to Greg Woolsey from comment #5)\n> 14.4s\n> when XSSFEvaluationSheet caches the value of getLastRowNum(), since it comes\n> from a TreeMap.lastKey() which has to navigate the tree each time to find\n> the last key.\n\nSide-note: should XSSFSheet cache the last row rather than iterating over the TreeMap for every call? Hopefully we could drop in a better Sorted map implementation, one that keeps a pointer to the first and last keys."}, {"count": 7, "attachment_id": null, "bug_id": 61841, "is_private": false, "id": 202595, "time": "2017-12-06T10:52:36Z", "creator": "fanningpj@yahoo.com", "creation_time": "2017-12-06T10:52:36Z", "tags": [], "text": "Can we call the new method getLastRowNum instead of getlastRowNum?\nAlso, a lot of public methods have had their signatures changed. Do we need to keep the existing signatures too and deprecate the old versions of the methods?"}, {"count": 8, "tags": [], "bug_id": 61841, "attachment_id": null, "id": 202604, "time": "2017-12-06T14:28:19Z", "creator": "lucamartini@tagetik.com", "creation_time": "2017-12-06T14:28:19Z", "is_private": false, "text": "(In reply to Greg Woolsey from comment #5)\n> Changes in r1817252\n> \n\nThank you very much Greg.\n\n\n> Of this remaining time, about 2/3 is taken up in the formula evaluation\n> caching and tracking mechanism.  Bypassing it for null cells causes test\n> failures, which shows it is necessary, but relatively expensive.  It appears\n> to try to optimize and minimize the \"empty cell\" rectangular regions it\n> holds. but assumes processing by row then column.  That may be a memory/time\n> optimization we want to consider allowing additional strategies for.\n> \n> Note that this shortcut logic doesn't change the result of any methods, only\n> avoids busywork that didn't apply to the \"nonexistent cell\" cases.\n> \n> This doesn't optimize VLOOKUP directly, but is about 70% improvement\n> sufficient?\n\nI think so. That's more or less the fix I had in mind.\n\n> \n> Changing the VLOOKUP code itself is actually significantly more complex,\n> because POI handles sheets by row internally, and columns are second-class\n> constructs.  There is no easy way to determine the last row with data in a\n> column other than iterating over all defined rows.  With these\n> optimizations, the extra iterations should fail fast.\n\nI know, and I think that with current state of the data structure, iterating over every defined row could be worse than your current solution.\nHere we are still on POI 3.x, but it should not be difficult to integrate your changes in our forked version.\n\nFor me the bug is considered as resolved. I still do not change its status because others have still pending comments.\n\nBest regards,\n    Luca"}, {"count": 9, "tags": [], "bug_id": 61841, "attachment_id": null, "id": 202613, "time": "2017-12-06T23:55:05Z", "creator": "gwoolsey@apache.org", "creation_time": "2017-12-06T23:55:05Z", "is_private": false, "text": "(In reply to PJ Fanning from comment #7)\n> Can we call the new method getLastRowNum instead of getlastRowNum?\n> Also, a lot of public methods have had their signatures changed. Do we need\n> to keep the existing signatures too and deprecate the old versions of the\n> methods?\n\nArgh, hate it when I miss things like that.  Yes, fixed it in r1817325.\n\nThe \"public\" methods here are either in classes marked in docs as \"POI internal\" or called only from methods similarly documented, so I think changing their signatures is fine.  I'm not aware of anyone trying to hook into formula evaluation down at the internal WorkbookEvaluator level.\n\nI'm not opposed to duplicating and deprecating, but in this case I don't think it's needed."}, {"count": 10, "attachment_id": null, "bug_id": 61841, "is_private": false, "id": 202615, "time": "2017-12-07T01:30:10Z", "creator": "onealj@apache.org", "creation_time": "2017-12-07T01:30:10Z", "tags": [], "text": "Throw in some @Override's for good measure"}]