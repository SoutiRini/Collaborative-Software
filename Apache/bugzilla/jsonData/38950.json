[{"count": 0, "tags": [], "text": "I have a servlet which has a background thread.  This thread does some database \nwork, using the Postgresql JDBC-3 driver.  This driver uses PhantomReference \nobjects, and when it come to create the first of these I get a ThreadDeath \nexception which seems to come from the check at the top of the loadClass to \nmake sure the class loader is started (I am using 5.5.9 so the source does\nnot quite match the line numbers, but given that there are two loadClass \nfunctions I adjusted the line numbers).\nNow this exception should not cause the loadClass to fail, it is merely to log\nthe fact that the ClassLoader is not started.  So maybe this is symptomatic of\na deaper problem.\nSo I tried using the Thread.getContextClassLoader method which got me a \nWebappClassLoader and using the start method, but this threw a \nLifecyleException.\nI am running on the Sun SDK 1.5 with update 4 under Linux.\nLooking at the list of known problems with the WebappClassLoader I could not \nsee anything that suggested this was a known problem.", "is_private": false, "bug_id": 38950, "id": 86763, "time": "2006-03-13T11:20:55Z", "creator": "david.goodenough@linkchoose.co.uk", "creation_time": "2006-03-13T11:20:55Z", "attachment_id": null}, {"count": 1, "attachment_id": null, "bug_id": 38950, "text": "I have not fully understand and taken in your situation so please forgive me if\nI have glossed over some details.  My understanding of Tomcat and ThreadDeath\nexception generation is that it occurs when the WebappClassLoader has shutdown\nbecause the Context is was created for has completed undeployment and so from a\nContext lifecycle point of view everything should now be dead.\n\nBut some active thread is still doing work and may run for sometime before\nultimatly calling on the services of WebappClassLoader to load a new class, but\nall the supporting infrastructure to do that job has now been cut away and\ndisposed of by TC (because the context is dead).\n\nAll of the code and execution threads that make up a Context instance MUST\nadhere to the lifecycle of that Context as defined by the respective \nspecification, this includes background threads.\n\n\nHere are some of my best practices on the use of background threads within\nwebapp context's:\n\n* You must be able to signal a thread cancellation to be able to control the\nshutdown part of the background thread lifecycle. \n\n* You must put code into your ServletContextListener.destroyContext() that\nbroadcasts a controlled Thread cancellation to all background threads.\n\n* Your must then reap (wait for the termination of) every single background\nthread before allowing the #destroyContext() to return control back to the\ncontainer.\n\n* It is advisable that all background threads must be able to detect their\ncancellation signal, cleanup and terminate within a short period of time.  Maybe\nrealistic goals are in the order of 5 seconds to detect, 2 seconds to terminate.\n This means that your threads should not use design patterns that would put them\nin a blocking state that would exceed these goals.\n\n\n\nTo help understand your problem better can you provide some details:\n\n* The execution path to the ThreadDeath Exception.\n\n* Is your JDBC driver in the $CATALINA_HOME/commons/ hiearachy ?\n\n* Does your JDBC driver use or create any Singleton strong references ?\n\n* Do you ever get this problem on first use after a container restart ?\n\n* Are you only seeing this problem after at least on webapp/context reload has\ntaken place on the affected webapp ?\n\n* Is a PhantomReference another name for a Weak Reference ?  What is that for\nthe technicaly naive.\n\n* How do you create and setup your JDBC connection ?  Does the container manager\nthe connection instances or do you create them manually within the web-app ?\n\n\nI can see how any code path could allow the execution of classes loaded from\nWebappClassLoader before the class loader instance itself has been setup.  But I\ncan imagine a situation where you access an object that was created by a\nprevious instance that is now a zombie.  If this is what I think you are seeing\nthen you should be unable to re-create the problem of you restart the entire\ncontainer and deploy the web-app for the first time.\n\nCan you use a container managed JDBC connection (if not already doing so).", "id": 86785, "time": "2006-03-13T19:16:24Z", "creator": "darryl@darrylmiles.org", "creation_time": "2006-03-13T19:16:24Z", "tags": [], "is_private": false}, {"count": 2, "attachment_id": null, "creator": "yoavs@computer.org", "text": "Daryl's comments are right on -- generally you're cruising for a bruising when\nyou spawn background threads in your servlets.  Please reply to his suggestions...", "id": 88002, "time": "2006-04-13T21:05:14Z", "bug_id": 38950, "creation_time": "2006-04-13T21:05:14Z", "tags": [], "is_private": false}, {"count": 3, "attachment_id": null, "bug_id": 38950, "text": "Reading the comments it is obvious to me that it is thought that using \nbackground threads is a bad thing.  This is odd, because many of the books I \nhave read on using servlets suggest using threads.  So I suppose the real \nquestion is how do I do some action in the background in a Tomcat environment \non a timer (as this is what I need to do) in addition to the \"foreground\" \nregular Http request handling.\n\nThis problem is occuring right when I start the thread, we are not here talking \nabout something that happens when a servlet is being reloaded or tomcat is \nbeing shut down.  So while the particular http request that started the thread \nmay have gone away, the servlet itself is still alive (that is init has run, \nand destroy had not been called).\n\nThe JDBC driver is in the WebApp WEB-INF/lib directory, although it makes no \ndifference to the problem if it is in the common/lib directory.\n\nThe particular function I am doing here is a request queue, to remote servers \nwhich may or may not be available.  The foreground requests put entries in a \nPostgresql table which the background thread tries to pass on to remote servers \n(which are not under my control).  Normally they go through on first request \nbut may take some time to respond, but sometimes the requests hang around for \ndays on end (typically over weekends).  My background thread wakes up, takes \nall pending requests, tries each, if they success marks them as complete in the \ntable otherwise leaves them for next time.  When it runs out of this batch it \ngoes to sleep for a minute or so and then tries again.\n\nCurrently, as I can not get Tomcat 5.5 to handle this as a background thread, I \nhave split this out as a separate long running process, but this is not the way \nI want to proceed as it makes managing the system much more difficult.\n\nI can not believe that my need is a unique one, in fact a Google search shows \nmany tutorials and the like which identify this senario, say that there is no \narchitected way to do this, and then suggest using a background thread.  Up \nuntil Postgresql 8.1 and Tomcat 5.5 this worked just fine, but the current \ncombination simply does not work.  Perhaps what is needed is an architected way \nof building timed requests into the Servlet framework.  There would seem to be \ntwo obvious ways to do this.  The first would be a configuration option that \nallowed a logical http request to be injected into the system periodically, and \nthe second would be a API request that invoked some other method either after \nsome interval or periodically but in both cases using the a valid context (in \nthe broader sense of the word) for things like the Postgresql JDBC driver to \nwork. ", "id": 88040, "time": "2006-04-14T09:57:03Z", "creator": "david.goodenough@linkchoose.co.uk", "creation_time": "2006-04-14T09:57:03Z", "tags": [], "is_private": false}, {"attachment_id": null, "tags": [], "bug_id": 38950, "is_private": false, "count": 4, "id": 88571, "time": "2006-04-27T17:07:02Z", "creator": "darryl@darrylmiles.org", "creation_time": "2006-04-27T17:07:02Z", "text": "(In reply to comment #3)\n> Reading the comments it is obvious to me that it is thought that using \n> background threads is a bad thing.\n\nA servlet container is not the same as a desktop application, this makes the\napproach to the problem different.  If you play by some realistic rules\nbackground threads are no longer a bad thing, I have web-app with ~20 HTTP\nclient thread workers and ~40 other threads.\n\n\n> This problem is occuring right when I start the thread, we are not here talking \n> about something that happens when a servlet is being reloaded or tomcat is \n> being shut down.  So while the particular http request that started the thread \n> may have gone away, the servlet itself is still alive (that is init has run, \n> and destroy had not been called).\n\nThis supprises me.\n\nIf I understand correctly you are saying you start up TC and deploy the web-app\n(for the first time).  Then as soon as you create your background thread that\nstarts using the JDBC driver you get PhantomReference you get ThreadDeath's. \nCan you explain the \"PhantomReference\" concept to the technically naive ?\n\nI can only suggest trying another approach.\n\nThe lifecycle of the attached example works differently, it does not use a\nServlet#init() method.  It would be possible to adapt the example so that a\n#init() can kick-start the thread (if you dont want it automatically started at\nweb-app startup).\n\nBut if you are using #init() are you also using #destroy() to shutdown the\nthread ?   And have you confirmed TC is calling #destroy() when you expect ?\n\nMaybe using the Servlet lifecycle is not actually the best solution for you\nanyway, it relies on a request coming in or you to load-on-startup to get going.\n\n\n> The JDBC driver is in the WebApp WEB-INF/lib directory, although it makes no \n> difference to the problem if it is in the common/lib directory.\n\nOkay this point confirms that you are creating your own JDBC connection and not\nusing a container mananged one, as for a container managed one to work you must\nmake the driver JAR visible to TC.  May I suggest you look at the\nMETA-INF/context.xml file (in attached WAR) and copy/adapt it into your own\nproject and pickup a container managed connection.  This may address the\nPhantomReferences problem within the JDBC driver.\n\n\n> The particular function I am doing here is a request queue, to remote servers \n> which may or may not be available. ...SNIP...\n\nYes this is a trivial problem to address under TC as a background thread, once\nprogrammed correctly.\n\n\nPlease take a look and fully understand the attached example of background\nthread control under a servlet container.\n\nPlease close this report if no underlying bug exists.\n\nI'd also suggest upgrading from 5.5.9 if you can, this was a particular bad\nversion in my experience.\n"}, {"count": 5, "tags": [], "bug_id": 38950, "attachment_id": 18194, "text": "Created attachment 18194\nExample WAR of good background thread lifecycle practice", "id": 88572, "time": "2006-04-27T17:10:42Z", "creator": "darryl@darrylmiles.org", "creation_time": "2006-04-27T17:10:42Z", "is_private": false}, {"count": 6, "tags": [], "creator": "markt@apache.org", "text": "The original report  indicates that the class loader is not started when the background thread tries to do some work. This strongly suggests that the lifecycle of the background thread is not being managed correctly. In the absence of a test case that demonstrates otherwise, I am closing this as invalid.", "id": 124744, "time": "2009-02-09T11:10:06Z", "bug_id": 38950, "creation_time": "2009-02-09T11:10:06Z", "is_private": false, "attachment_id": null}]