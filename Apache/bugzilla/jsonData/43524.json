[{"count": 0, "tags": [], "bug_id": 43524, "attachment_id": null, "id": 108853, "time": "2007-10-01T07:50:17Z", "creator": "Arne.vonIrmer@uni-dortmund.de", "creation_time": "2007-10-01T07:50:17Z", "is_private": false, "text": "ClusterCacheRefreshing has to be enabled. Trying to do so\nI found some bugs, that I fixed for Slide 2.1. (I attach a patch for the\nwebdavclientlib and slide-core)\n\nHere are the found problems:\n- The connection between slides in a cluster isn't established\nOnly the last started slide is able to send messages to the other,\nbecause reading and parsing messages (UDP) was performed only one time.\nI put it in an infinite loop. (Notifcationlistener)\n\n- If connection is broken no reconnect is done.\nI took the subscription out of the ClustercacheRefresh into a\nSubscriberBean that will be instantiated in the ClusterCacheRefresher\nand in the NotifcationListener if an IOException in the communication\nwith another Silde happens.\n\n- Cache isn't refreshed (Maybe only with FileStores)\nThe cache is organized to store URIs. The ClustercacheRefresher tried to\nremove URLs from cache that aren't stored there. So even if a message\nwas able to come to that point no refresh is performed. To have URIs the\nBindingStore has to be used. It must implement the removeObjectFromCache\nmethod and the cast in the ClustercacheRefresher has to be changed.\n\n- The move-event isn't published\nThe Notificationtrigger is filtering ContensEvents for changing,\ncreating and removing events. This does not include the case that the\nuser makes a webdav move. The problem here is, that this isn't a content\nevent, because content isn't touched. But all the rest is done with\nContentEvents. The filter finds a WebDAVEvent and a MacroEvent in the\ncase of a file movement. Working with WebDAVEvents is very complicated\nat this point, because an trap dependency between the modules will be\nthe consequence of using this class here and the WebDAVEvent has but\ndoesn't give source and destination Urls. Instead the MacroEvent is\nworking fine.\nSo the new CollectionFilter now has to do two things:\n1. find the MacroEvent\n2. convert one MacroEvent into two ContentEvents. One for the source and\none for the destination.(EventCollectionFilter). Here I don't know if my\nsolution works with revisioning...\n\n- In the case the slide runs as root-servlet the url for the connection\nisn't calculated correctly\nThe ClusterCacheRefresher just cuts the part form the url. Here the\nmethod stripUrl is now looking at the repository domain. If it is not\n\"/\" the cutting of the servlet name is performed.\n\nAfter fixing these \"bugs\" now ClusterCacheRefreshing is working with\nsome slides on one file store. Other constellations weren't tested. But\nmaybe these fixes can help there, too.\n\ndiff -bur\njakarta-slide-server-src-2.1/src/share/org/apache/slide/cluster/ClusterCacheRefresher.java\njakarta-slide-server-src-2.1_fixed/src/share/org/apache/slide/cluster/ClusterCacheRefresher.java\n---\njakarta-slide-server-src-2.1/src/share/org/apache/slide/cluster/ClusterCacheRefresher.java\n2004-12-23 22:08:00.000000000 +0100\n+++\njakarta-slide-server-src-2.1_fixed/src/share/org/apache/slide/cluster/ClusterCacheRefresher.java\n2007-09-28 10:46:55.000000000 +0200\n@@ -30,7 +30,7 @@\n import org.apache.slide.common.NamespaceAccessToken;\n import org.apache.slide.common.SlideTokenImpl;\n import org.apache.slide.common.Uri;\n-import org.apache.slide.store.ExtendedStore;\n+import org.apache.slide.store.BindingStore;\n import org.apache.slide.store.Store;\n import org.apache.slide.util.conf.Configurable;\n import org.apache.slide.util.conf.Configuration;\n@@ -38,6 +38,7 @@\n import org.apache.slide.util.logger.Logger;\n import org.apache.webdav.lib.NotificationListener;\n import org.apache.webdav.lib.Subscriber;\n+import org.apache.webdav.lib.SubscriberBean;\n import org.apache.webdav.lib.methods.DepthSupport;\n \n /**\n@@ -178,7 +179,6 @@\n public class ClusterCacheRefresher implements EventListener, Configurable {\n     protected static final String LOG_CHANNEL =\nClusterCacheRefresher.class.getName();\n \n-    protected NotificationListener listener;\n \n     public ClusterCacheRefresher() {\n         Domain.log(\"Creating ClusterCacheRefresher\", LOG_CHANNEL, Logger.INFO);\n@@ -222,11 +222,11 @@\n                         while (keys.hasNext()) {\n                             String key = keys.next().toString();\n                             if (\"uri\".equals(key)) {\n-                                Uri theUri = nat.getUri(new SlideTokenImpl(new\nCredentialsToken(\"\")), stripUri(information.get(key).toString()));\n+                                Uri theUri = nat.getUri(new SlideTokenImpl(new\nCredentialsToken(\"\")), stripUri(information.get(key).toString(),repositoryDomain));\n                                 Store store = theUri.getStore();\n-                                if (store instanceof ExtendedStore) {\n+                                if (store instanceof BindingStore) {\n                                     Domain.log(\"Resetting cache for \" + theUri,\nLOG_CHANNEL, Logger.INFO);\n-                                    ((ExtendedStore)\nstore).removeObjectFromCache(theUri);\n+                                    ((BindingStore)\nstore).removeObjectFromCache(theUri);\n                                 }\n                             }\n                         }\n@@ -249,11 +249,11 @@\n \t                    while (keys.hasNext()) {\n \t                        String key = keys.next().toString();\n \t                        if (\"uri\".equals(key)) {\n-\t                            Uri theUri = nat.getUri(new SlideTokenImpl(new\nCredentialsToken(\"\")), stripUri(information.get(key).toString()));\n+\t                            Uri theUri = nat.getUri(new SlideTokenImpl(new\nCredentialsToken(\"\")), stripUri(information.get(key).toString(),repositoryDomain));\n \t                            Store store = theUri.getParentUri().getStore();\n-\t                            if (store instanceof ExtendedStore) {\n+\t                            if (store instanceof BindingStore) {\n \t                                Domain.log(\"Resetting cache for \" +\ntheUri.getParentUri(), LOG_CHANNEL, Logger.INFO);\n-\t                                ((ExtendedStore)\nstore).removeObjectFromCache(theUri.getParentUri());\n+\t                                ((BindingStore)\nstore).removeObjectFromCache(theUri.getParentUri());\n \t                            }\n \t                        }\n \t                    }\n@@ -281,58 +281,36 @@\n              *    a server is down and NotificationListener.subscribe() can't\n              *    reach it.\n              */\n-            Thread t = new Thread(new Runnable() {\n             \t\n-            \tprivate boolean success;\n-            \t\n-                public void run() {\n-                \tsuccess = true;\n-                    listener = new NotificationListener(host, port,\nrepositoryHost, repositoryPort, protocol, credentials,\n-                        repositoryDomain, pollInterval, udp);\n-\n-                    success = listener.subscribe(\"Update\", uri, depth,\nlifetime, notificationDelay, contentSubscriber, credentials);\n-                    success = listener.subscribe(\"Update/newmember\", uri,\ndepth, lifetime, notificationDelay, structureSubscriber, credentials);\n-                    success = listener.subscribe(\"Delete\", uri, depth,\nlifetime, notificationDelay, structureSubscriber, credentials);\n-                    success = listener.subscribe(\"Move\", uri, depth, lifetime,\nnotificationDelay, structureSubscriber, credentials);\n-                    \n-                    if ( !success ) {\n-\t\t\t\t\t\t// try again quickly\n-                    \ttry {\n-\t\t\t\t\t\t\tThread.sleep(10000);\n-\t\t\t\t\t\t} catch (InterruptedException e) {\n-\t\t\t\t\t\t\t// ignore\n-\t\t\t\t\t\t}\n-                    } else {\n-\t\t\t\t\t\t// try again before the subscriptions expire\n-                    \ttry {\n-\t\t\t\t\t\t\tThread.sleep(lifetime*1000-60);\n-\t\t\t\t\t\t} catch (InterruptedException e) {\n-\t\t\t\t\t\t\t// ignore\n-\t\t\t\t\t\t}\n-                    }\n-                }\n-            });\n-            t.setDaemon(true);\n-            t.start();\n+           SubscriberBean sb=new SubscriberBean(new NotificationListener(host,\nport, repositoryHost, repositoryPort, protocol, credentials,\n+    \t\t\t\trepositoryDomain, pollInterval, udp,uri, depth, lifetime,\nnotificationDelay));\n+            sb.add(sb.new Sub(\"Update\",contentSubscriber));\n+            sb.add(sb.new Sub(\"Update/newmember\",structureSubscriber));\n+            sb.add(sb.new Sub(\"Delete\",structureSubscriber));\n+            sb.add(sb.new Sub(\"Move\",structureSubscriber));\n+            sb.subscribe();\n         }\n     }\n     \n     /**\n      * Removes the first segment of a uri. \"/slide/files/foo\" becomes\n      * \"/files/foo\".\n-     * \n+     * This is intended to remove the servlet path.\n      * @param uri the uri to strip\n+     * @param repositoryDomain The servlet path \n      * @return the stipped uri\n      */\n-    private String stripUri(String uri) {\n-        // FIXME: if this is intended to remove the servlet path this will \n-        // NOT work if the servlet is not default-servlet or is the root servlet\n+    private String stripUri(String uri,String repositoryDomain) {\n+    \t//Is the remote servlet the default ROOT servlet?\n+    \tif(!repositoryDomain.equals(\"/\")){\n     \tif ( uri.indexOf(\"/\") == 0 ) {\n     \t\turi = uri.substring(1);\n     \t}\n     \tif ( uri.indexOf(\"/\") > -1 ) {\n     \t\turi = uri.substring(uri.indexOf(\"/\"));\n     \t}\n+    \t}\n     \treturn uri;\n     }\n-}\n\\ Kein Zeilenumbruch am Dateiende.\n+    \n+ }\n\\ Kein Zeilenumbruch am Dateiende.\ndiff -bur\njakarta-slide-server-src-2.1/src/share/org/apache/slide/event/EventCollectionFilter.java\njakarta-slide-server-src-2.1_fixed/src/share/org/apache/slide/event/EventCollectionFilter.java\n---\njakarta-slide-server-src-2.1/src/share/org/apache/slide/event/EventCollectionFilter.java\n2004-12-23 22:07:59.000000000 +0100\n+++\njakarta-slide-server-src-2.1_fixed/src/share/org/apache/slide/event/EventCollectionFilter.java\n2007-09-28 09:29:56.000000000 +0200\n@@ -23,9 +23,11 @@\n \n package org.apache.slide.event;\n \n-import java.util.List;\n-import java.util.Iterator;\n import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.slide.content.NodeRevisionDescriptors;\n \n /**\n  * @version $Revision: 1.5.2.1 $\n@@ -89,6 +91,54 @@\n         return (ContentEvent [])changedContents.toArray(changedContentEvents);\n     }\n \n+    /**\n+     * Filter all events, that indicate a movement of a file\n+     * @param collection All events coming from the event dispatcher\n+     * @return The events that are found\n+     */\n+    public static ContentEvent[] getMovedContents(EventCollection collection) {\n+       /* The move event can only be found as a WebDAVEvent or MacroEvent not\nas a ContentEvent.\n+    \t* The WebDAVEvent doesn't have getters for source-URL and destination-URL\n+    \t* so the MacroEvent will do the trick. What has to be done is to convert \n+    \t* one MacroEvent for movement into two ContentEvents for source-URL and \n+    \t* destination-URL. Both will be returned.*/\n+        List changedContents = new ArrayList();\n+        if (collection != null)\n+        {\n+            List collectedEvents = collection.getCollection();\n+            for ( Iterator i = collectedEvents.iterator(); i.hasNext(); ) {\n+                EventCollection.Event event = (EventCollection.Event)i.next();\n+                if ( event.getMethod() == MacroEvent.MOVE) {\n+                \t//Get the MacroEvent\n+                \tMacroEvent w_event=(MacroEvent)event.getEvent();\n+                \t//Get both URLs\n+                \tString source=w_event.getSourceURI();\n+                \tString destination=w_event.getTargetURI();\n+                    removeContentEvents(changedContents,source);\n+                    removeContentEvents(changedContents,destination);\n+                    \n+                    /* Generate new ContentEvents Source,Token and Namespace \n+                     * can be taken from the MacroEvent. They do not have implicit \n+                     * information about the URL the ContentEvent is for. */\n+                    changedContents.add(new\nContentEvent(event.getEvent().getSource(),\n+                    \t\tw_event.getToken(),\n+                    \t\tw_event.getNamespace(),\n+                    \t\tsource, //source-URL\n+                    \t\tnew NodeRevisionDescriptors() //TODO: Is this enough to\nwork with revisions?\n+                    ));\n+                    changedContents.add(new\nContentEvent(event.getEvent().getSource(),\n+                    \t\tw_event.getToken(),\n+                    \t\tw_event.getNamespace(),\n+                    \t\tdestination, //destination-URL\n+                    \t\tnew NodeRevisionDescriptors() //TODO: Is this enough to\nwork with revisions?\n+                    ));\n+                } \n+            }\n+        }\n+        ContentEvent[] changedContentEvents = new\nContentEvent[changedContents.size()];\n+        return (ContentEvent [])changedContents.toArray(changedContentEvents);\n+    }\n+\n     private static void removeContentEvents(List changedContents, String uri) {\n         for ( Iterator i = changedContents.iterator(); i.hasNext(); ) {\n             ContentEvent event = (ContentEvent)i.next();\ndiff -bur\njakarta-slide-server-src-2.1/src/share/org/apache/slide/store/BindingStore.java\njakarta-slide-server-src-2.1_fixed/src/share/org/apache/slide/store/BindingStore.java\n---\njakarta-slide-server-src-2.1/src/share/org/apache/slide/store/BindingStore.java\n2004-12-23 22:08:00.000000000 +0100\n+++\njakarta-slide-server-src-2.1_fixed/src/share/org/apache/slide/store/BindingStore.java\n2007-09-27 16:43:39.000000000 +0200\n@@ -56,6 +56,20 @@\n  * @version   $Revision: 1.3.2.1 $\n  */\n public class BindingStore extends ExtendedStore {\n+    // overwrites inherited\n+\tpublic void removeObjectFromCache( Object key ) {\n+\t\tif (key instanceof ResourceId) {\n+\t\t\tsuper.removeObjectFromCache(key);\n+\t\t}else if(key instanceof Uri){\n+\t\t\tResourceId resourceId=null;\n+\t\t\ttry {\n+\t\t\t\tresourceId = obtainResourceId((Uri) key);\n+\t\t\t\tsuper.removeObjectFromCache(resourceId);\n+\t\t\t} catch (ObjectNotFoundException e) {\n+\t\t\t} catch (ServiceAccessException e) {\n+\t\t\t}\n+\t\t}\t\t\n+\t}   \n     \n     // overwrites inherited\n     public ObjectNode retrieveObject(Uri uri)\ndiff -bur\njakarta-slide-server-src-2.1/src/webdav/server/org/apache/slide/webdav/event/NotificationTrigger.java\njakarta-slide-server-src-2.1_fixed/src/webdav/server/org/apache/slide/webdav/event/NotificationTrigger.java\n---\njakarta-slide-server-src-2.1/src/webdav/server/org/apache/slide/webdav/event/NotificationTrigger.java\n2004-12-23 22:07:59.000000000 +0100\n+++\njakarta-slide-server-src-2.1_fixed/src/webdav/server/org/apache/slide/webdav/event/NotificationTrigger.java\n2007-09-28 09:24:59.000000000 +0200\n@@ -182,7 +182,11 @@\n         for ( int i = 0; i < delete.length; i++ ) {\n             matchingSubscribers.addAll(getSubscribers(Subscriber.DELETE,\ndelete[i]));\n         }\n-        // FIXME: Add methods for MOVE, and NEW_MAIL (??) to get full exchange\nnotification compliance\n+        //Filter for MOVE-Events\n+        ContentEvent[] move = EventCollectionFilter.getMovedContents(collection);\n+        for ( int i = 0; i < move.length; i++ ) {\n+            matchingSubscribers.addAll(getSubscribers(Subscriber.MOVE, move[i]));\n+        }\n         \n         // notifiy subscribers\n         for ( Iterator i = matchingSubscribers.iterator(); i.hasNext(); ) {\n\n\ndiff -Naur\njakarta-slide-webdavclient-src-2.1/clientlib/src/java/org/apache/webdav/lib/NotificationListener.java\njakarta-slide-webdavclient-src-2.1_fixed/clientlib/src/java/org/apache/webdav/lib/NotificationListener.java\n---\njakarta-slide-webdavclient-src-2.1/clientlib/src/java/org/apache/webdav/lib/NotificationListener.java\n2004-12-23 22:08:47.000000000 +0100\n+++\njakarta-slide-webdavclient-src-2.1_fixed/clientlib/src/java/org/apache/webdav/lib/NotificationListener.java\n2007-09-28 10:03:36.000000000 +0200\n@@ -79,7 +79,10 @@\n     \n     private List subscribers = new ArrayList();\n     private String subscribersAsString;\n-\n+    private String uri=null;\n+    private int depth;\n+    private int lifetime;\n+    private int notificationDelay;\n     /**\n      * \n      * @param host The ip-address or hostname on which the udp or http-server\nis running (e.g. \"myhost.mydomain.mytld\")\n@@ -92,7 +95,19 @@\n      * @param pollInterval The poll interval that will be used if no\nnotifications are revieved via UDP/TCP (in milliseconds)\n      * @param udp If set to true, UDP server will be started, otherwise TCP\nserver (must match the repository notification mode)\n      */\n-    public NotificationListener(String host, int port, String repositoryHost,\nint repositoryPort, Protocol protocol, Credentials credentials, String\nrepositoryDomain, int pollInterval, boolean udp) {\n+    public NotificationListener(String host, \n+    \t\tint port, \n+    \t\tString repositoryHost,\n+    \t\tint repositoryPort, \n+    \t\tProtocol protocol, \n+    \t\tCredentials credentials, \n+    \t\tString repositoryDomain, \n+    \t\tint pollInterval, \n+    \t\tboolean udp,\n+    \t\tString uri, \n+    \t\tint depth, \n+    \t\tint lifetime, \n+    \t\tint notificationDelay) {\n     \tthis.credentials = credentials;\n     \tthis.notificationHost = host;\n         this.notificationPort = port;\n@@ -101,13 +116,18 @@\n         this.protocol = protocol;\n         this.repositoryDomain = repositoryDomain;\n         this.udp = udp;\n-        \n+        this.uri=uri;\n+        this.depth=depth;\n+        this.lifetime=lifetime;\n+        this.notificationDelay=notificationDelay;\n+       \n         if ( udp ) {\n             Thread listenerThread = new Thread(new Runnable() {\n                 public void run() {\n                     DatagramSocket serverSocket = null;\n                     try {\n                         serverSocket = new DatagramSocket(notificationPort);\n+                        //Read and parse messages unlimited \n                         while (true) {\n                             byte[] buf = new byte[256];\n                             DatagramPacket packet = new DatagramPacket(buf,\nbuf.length);\n@@ -121,6 +141,7 @@\n                 }\n             });\n             listenerThread.setDaemon(true);\n+            listenerThread.setName(\"NL-ListeningThread\");\n             listenerThread.start();\n         } else {\n             Thread listenerThread = new Thread(new Runnable() {\n@@ -136,6 +157,7 @@\n                     }\n                 }\n             });\n+            listenerThread.setName(\"listenerThread\");\n             listenerThread.setDaemon(true);\n             listenerThread.start();\n         }\n@@ -169,7 +191,7 @@\n      * @see WebdavResource#subscribeMethod\n      * @see\nhttp://msdn.microsoft.com/library/default.asp?url=/library/en-us/e2k3/e2k3/_webdav_subscribe.asp\n      */\n-    public boolean subscribe(String method, String uri, int depth, int\nlifetime, int notificationDelay, Subscriber listener, Credentials credentials) {\n+    public boolean subscribe(String method,Subscriber listener) {\n         SubscribeMethod subscribeMethod = new\nSubscribeMethod(repositoryDomain+uri);\n         subscribeMethod.addRequestHeader(SubscribeMethod.H_NOTIFICATION_TYPE,\nmethod);\n         if ( udp ) {\n@@ -192,7 +214,7 @@\n                 logger.log(Level.INFO, \"Received subscription\nid=\"+subscriptionId+\", listener: \"+listener);\n                 int id = Integer.valueOf(subscriptionId).intValue();\n                 synchronized ( subscribers ) {\n-                    subscribers.add(new Subscription(id, uri, listener));\n+                    subscribers.add(new Subscription(id, uri, listener, method));\n                 }\n                 if ( subscribersAsString == null ) {\n                     subscribersAsString = String.valueOf(id);\n@@ -307,8 +329,20 @@\n                     logger.log(Level.SEVERE, \"Poll failed. State: \"+state);\n                 }\n             } catch (IOException e) {\n-                logger.log(Level.SEVERE, \"Poll for subscribers\n'\"+subscribers+\"' failed!\");\n-            }\n+                logger.log(Level.SEVERE, \"Poll for subscribers failed on host\n\"+this.notificationHost+\":\"+this.notificationPort);\n+                logger.log(Level.SEVERE, \"Try to reconnect.\");\n+            \t//The other slide in cluster is gone. \n+            \t//Get CCL-Subscriber and method\n+            \tSubscriberBean sb=new SubscriberBean(this);\n+                for ( Iterator i = subscribers.iterator(); i.hasNext(); ) {\n+                    Subscription subscriber = (Subscription)i.next();\n+                    sb.add(sb.new\nSub(subscriber.method,subscriber.getSubscriber()));\n+                \t//Remove that subscriber\n+                    unsubscribe(subscriber.uri, subscriber.getSubscriber(),\ncredentials);\n+                }\n+            \t//Start a new thread to subscribe that node.\n+                sb.subscribe();\n+             }\n         }\n     }\n     \n@@ -372,11 +406,13 @@\n         private int id;\n \t\tprivate String uri;\n         private Subscriber subscriber;\n+        private String method;\n \n-        public Subscription(int id, String uri, Subscriber subscriber) {\n+        public Subscription(int id, String uri, Subscriber subscriber,String\nmethod) {\n             this.id = id;\n             this.uri = uri;\n             this.subscriber = subscriber;\n+            this.method=method;\n         }\n \n         public void fireEvent(Map information) {\ndiff -Naur\njakarta-slide-webdavclient-src-2.1/clientlib/src/java/org/apache/webdav/lib/Subscription.java\njakarta-slide-webdavclient-src-2.1_fixed/clientlib/src/java/org/apache/webdav/lib/Subscription.java\n---\njakarta-slide-webdavclient-src-2.1/clientlib/src/java/org/apache/webdav/lib/Subscription.java\n1970-01-01 01:00:00.000000000 +0100\n+++\njakarta-slide-webdavclient-src-2.1_fixed/clientlib/src/java/org/apache/webdav/lib/Subscription.java\n2004-12-23 22:08:47.000000000 +0100\n@@ -0,0 +1,58 @@\n+// vi: set ts=3 sw=3:\n+package org.apache.webdav.lib;\n+\n+/**\n+ * Object that holds information about a single WebDAV subscription.\n+ * \n+ * @see org.apache.webdav.lib.WebdavResource#subscribeMethod(String, String,\nString, long, int, long)\n+ */\n+public class Subscription\n+{\n+   public static final String UPDATE_NOTIFICATION = \"update\";\n+   public static final String NEW_MEMBER_NOTIFICATION = \"update/newmember\";\n+   public static final String DELETE_NOTIFICATION = \"delete\";\n+   public static final String MOVE_NOTIFICATION = \"move\";\n+   \n+   private int id;\n+   private long lifetime;\n+   private String callback;\n+   private String contentLocation;\n+   private String notificationType;\n+   private String path;\n+   \n+   public Subscription(String path, int id, String callback, long lifetime, \n+         String contentLocation, String notificationType)\n+   {\n+      this.path = path;\n+      this.id = id;\n+      this.callback = callback;\n+      this.lifetime = lifetime;\n+      this.contentLocation = contentLocation;\n+      this.notificationType = notificationType;\n+   }\n+   \n+   public String getCallback()\n+   {\n+      return callback;\n+   }\n+   public String getContentLocation()\n+   {\n+      return contentLocation;\n+   }\n+   public int getId()\n+   {\n+      return id;\n+   }\n+   public long getLifetime()\n+   {\n+      return lifetime;\n+   }\n+   public String getNotificationType()\n+   {\n+      return notificationType;\n+   }\n+   public String getPath() \n+   {\n+      return path;\n+   }\n+}"}]