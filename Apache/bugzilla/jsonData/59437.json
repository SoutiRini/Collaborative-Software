[{"attachment_id": 33828, "tags": [], "bug_id": 59437, "text": "Created attachment 33828\npatch against trunk\n\n[This isn't a report from a concurrency-checking tool, it's just me looking at\nthe code, so I may be missing something, but...]\n\norg.apache.catalina.authenticator.jaspic.CallbackHandlerImpl uses mutable\ninstance variables, so it definitely can't be used concurrently.\n\norg.apache.catalina.authenticator.AuthenticatorBase _looks_ as though it's OK:\nfor each request it creates a new CallbackHandlerImpl instance and uses it in\na fresh getServerAuthConfig() invocation to obtain a ServerAuthConfig instance\nthat encapsulates the callback handler.\n\nBut SimpleAuthConfigProvider.getServerAuthConfig() caches its result (the\nServerAuthConfig) in an instance variable;  on the second and subsequent\ninvocations it ignores the input arguments (including the CallbackHandler)\nand returns the cached ServerAuthConfig instance.\n\nThe result, I believe, is that an AuthenticatorBase instance will end up\nusing that same, cached, ServerAuthConfig instance to process every request\n(including any concurrent requests).  That's right w.r.t. performance (and\nI certainly wouldn't want to abolish SimpleAuthConfigProvider's instance\ncache), but nasty w.r.t. MT-safety.\n\nThe guilty party, I believe, is CallbackHandlerImpl -- it ought to be safe\nfor concurrent use.\n\n[Aside:  I wish that JSR 196 hadn't reused the CallbackHandler API here,\nbecause while the method signatures are the same, the way it is used runs\ncounter to the mental model that everyone has from JAAS, and it has\ndiscombobulated multiple JASPIC implementations].\n\nI have attached a possible patch for CallbackHandlerImpl.\n\nThe good:  it fixes the MT-safety problem, and also means that if\nAuthenticatorBase wanted to, it could obtain the ServerAuthConfig\ninstance once (as it currently does for the AuthConfigProvider)\nand use that ServerAuthConfig instance for all requests.\n[But yes, it should still generate a new authContextID and\nServerAuthContext for each request].\n\nThe bad:  if there are any ServerAuthModule implementations out there\nthat invoke the CallbackHandler twice (once for CallerPrincipalCallback\nand once for GroupPrincipalCallback) then CallbackHandlerImpl's current\ncode may kinda sorta work (never mind MT-safety) whereas the patch that\nI'm suggesting would not.\n\nThe ugly:  I opted for minimum # lines in the diff;  the result is more\ncheesy than necessary.", "count": 0, "id": 190759, "time": "2016-05-08T01:18:36Z", "creator": "thomas.mpp.maslen@gmail.com", "creation_time": "2016-05-08T01:18:36Z", "is_private": false}, {"count": 1, "tags": [], "text": "Thanks for the report and the patch.\n\nWorking through putting together a simple test case found a handful of additional JASPIC related issues that have also been fixed.\n\nMy reading of the spec is that state is maintained by the modules, not the CallbackHandler so making this thread-safe is the way to go.\n\nI have applied a patch for this to trunk for 9.0.0.M5 onwards and 8.5.x for 8.5.1 onwards. I went for a slightly different approach than the one you proposed since minimising the diff was not my primary concern.", "is_private": false, "id": 190787, "creator": "markt@apache.org", "time": "2016-05-09T18:24:40Z", "bug_id": 59437, "creation_time": "2016-05-09T18:24:40Z", "attachment_id": null}, {"attachment_id": null, "tags": [], "bug_id": 59437, "text": ">The guilty party, I believe, is CallbackHandlerImpl -- it ought to be safe\nfor concurrent use.\n\nIndeed, I explicitly asked the spec lead for clarification about this a while and the CallbackHandler has to be thread-safe. It would even be allowed to have one global instance of the SAM that handles all requests, which keeps re-using a single CallbackHandler instance.\n\n>if there are any ServerAuthModule implementations out there\nthat invoke the CallbackHandler twice [...]\n\nHmmm, Soteria does just that:\n\n   public static void notifyContainerAboutLogin(Subject clientSubject, CallbackHandler handler, Principal callerPrincipal, List<String> roles) {\n        \n       try {\n           \n            handler.handle(new Callback[] { new CallerPrincipalCallback(clientSubject, callerPrincipal) });\n            \n            if (!isEmpty(roles)) {\n                  handler.handle(new Callback[] { new GroupPrincipalCallback(clientSubject, roles.toArray(new String[roles.size()])) });\n            }\n            \n        } catch (IOException | UnsupportedCallbackException e) {\n            // Should not happen\n            throw new IllegalStateException(e);\n        }\n    }", "count": 2, "id": 190794, "time": "2016-05-09T22:39:13Z", "creator": "arjan.tijms@gmail.com", "creation_time": "2016-05-09T22:39:13Z", "is_private": false}, {"attachment_id": null, "tags": [], "bug_id": 59437, "text": "(In reply to Arjan Tijms from comment #2)\n> Hmmm, Soteria does just that:\n\nShould be fine. That is no different to what a CallbackHandler implementation is going to have to do under the covers. State is maintained in clientSubject.", "count": 3, "id": 190801, "time": "2016-05-10T07:28:10Z", "creator": "markt@apache.org", "creation_time": "2016-05-10T07:28:10Z", "is_private": false}]