[{"count": 0, "tags": [], "text": "(Initially reported as SITIC Vulnerability Advisory SA04-004, redefined as bug \nafter discussion with ASF httpd security team)\n\nApache's htdbm utility suffers from various buffer overflows and potential\nformat string bugs when listing or verifying database contents. This could be\nan issue when several system administrators handle the same Apache\ninstallation. Administrator A could store malicious data in a database and\nAdministrator B could list or verify that database, causing actions to be\ncarried out in Administrator B's name.\n\nThis bug was discovered by Ulf Harnhammar for SITIC, Swedish IT \nIncident Centre.\n\nThe included patch is our attempt at correcting this issue:\n\n--- support/htdbm.c\t2004-03-30 01:07:46.000000000 +0200\n+++ support/htdbm.c.ulf\t2004-08-02 13:14:52.000000000 +0200\n@@ -225,6 +225,8 @@\n     if (apr_dbm_fetch(htdbm->dbm, key, &val) != APR_SUCCESS)\n         return APR_ENOENT;\n     rec = apr_pstrndup(htdbm->pool, val.dptr, val.dsize);\n+    if (strlen(rec) > MAX_STRING_LEN)\n+        return APR_EINVAL; /* buffer overflow */\n     cmnt = strchr(rec, ';');\n     if (cmnt)\n         strncpy(pwd, rec, cmnt - rec);\n@@ -240,6 +242,7 @@\n     char *rec, *cmnt;\n     char kb[MAX_STRING_LEN];\n     int i = 0;\n+    unsigned int copylen;\n \n     rv = apr_dbm_firstkey(htdbm->dbm, &key);\n     if (rv != APR_SUCCESS) {\n@@ -256,14 +259,20 @@\n             fprintf(stderr, \"Failed getting data from %s\\n\", htdbm->filename);\n             return APR_EGENERAL;\n         }\n-        strncpy(kb, key.dptr, key.dsize);\n-        kb[key.dsize] = '\\0';\n+        copylen = (key.dsize > sizeof(kb)) ?\n+                  sizeof(kb) :\n+                  key.dsize;\n+        strncpy(kb, key.dptr, copylen);\n+        kb[copylen] = '\\0';\n         fprintf(stderr, \"    %-32s\", kb);\n-        strncpy(rec, val.dptr, val.dsize);\n-        rec[val.dsize] = '\\0';\n+        copylen = (val.dsize > HUGE_STRING_LEN) ?\n+                  HUGE_STRING_LEN :\n+                  val.dsize;\n+        strncpy(rec, val.dptr, copylen);\n+        rec[copylen] = '\\0';\n         cmnt = strchr(rec, ':');\n         if (cmnt)\n-            fprintf(stderr, cmnt + 1);\n+            fprintf(stderr, \"%s\", cmnt + 1);\n         fprintf(stderr, \"\\n\");\n         rv = apr_dbm_nextkey(htdbm->dbm, &key);\n         if (rv != APR_SUCCESS)", "attachment_id": null, "id": 61806, "creator": "sitic@pts.se", "time": "2004-08-11T11:49:04Z", "bug_id": 30586, "creation_time": "2004-08-11T11:49:04Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 30586, "is_private": false, "id": 127284, "attachment_id": null, "creator": "poirier@pobox.com", "creation_time": "2009-05-22T07:38:14Z", "time": "2009-05-22T07:38:14Z", "text": "It looks like this is still a potential issue in trunk.\n\nThe patch is not quite right.  These lines:\n\n   kb[copylen] = '\\0';\n\n   rec[copylen] = '\\0';\n\ncould write past the end of buffers, as copylen can\nbe set to the full length of the buffer.  Either copylen\nshould be restricted to one less than the buffer size,\nor maybe we should just allocate these buffers dynamically."}, {"count": 2, "tags": [], "bug_id": 30586, "attachment_id": null, "is_private": false, "id": 129126, "time": "2009-07-24T10:17:30Z", "creator": "poirier@pobox.com", "creation_time": "2009-07-24T10:17:30Z", "text": "Fixed in trunk\nRev 797563\n\nThanks for the report."}, {"count": 3, "text": "Fixed in 2.2.14 as r814852", "bug_id": 30586, "is_private": false, "id": 149387, "time": "2011-09-17T15:45:56Z", "creator": "sf@sfritsch.de", "creation_time": "2011-09-17T15:45:56Z", "tags": [], "attachment_id": null}]