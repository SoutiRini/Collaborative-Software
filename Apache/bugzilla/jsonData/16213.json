[{"count": 0, "attachment_id": null, "creator": "jasonsalter@hotmail.com", "is_private": false, "id": 29616, "time": "2003-01-17T16:19:18Z", "bug_id": 16213, "creation_time": "2003-01-17T16:19:18Z", "tags": [], "text": "The <unzip> task fails silently in when trying to expand self-extracting \narchive files. The problem appears to be in \norg/apache/tools/ant/taskdefs/Expand.java in the expandFile() method. \n\nThe java.util.zip.ZipInputStream class is the real culprit I suspect, but there \nis a workaround.\n\nA normal zip archive file starts with the following 4 byte marker '504b0304'. \nIn a self-extracting archive, these bytes appear further in (after the \nextracting code). Even though the self-extracting archive is platform specific \n(ie. Windows), we could still get at the archive data if we skip past the \nexecutable section.\n\nI've attached a suggested patch for Expand.java that looks for the marker in \nthe source archive file (up to a maximum of 50K or EOF) and skips forward to \nthe correct place in the file if necessary before it is presented to \nZipInputStream for expanding.\n\n/*\n * The Apache Software License, Version 1.1\n *\n * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * 3. The end-user documentation included with the redistribution, if\n *    any, must include the following acknowlegement:\n *       \"This product includes software developed by the\n *        Apache Software Foundation (http://www.apache.org/).\"\n *    Alternately, this acknowlegement may appear in the software itself,\n *    if and wherever such third-party acknowlegements normally appear.\n *\n * 4. The names \"The Jakarta Project\", \"Ant\", and \"Apache Software\n *    Foundation\" must not be used to endorse or promote products derived\n *    from this software without prior written permission. For written\n *    permission, please contact apache@apache.org.\n *\n * 5. Products derived from this software may not be called \"Apache\"\n *    nor may \"Apache\" appear in their names without prior written\n *    permission of the Apache Group.\n *\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n * ====================================================================\n *\n * This software consists of voluntary contributions made by many\n * individuals on behalf of the Apache Software Foundation.  For more\n * information on the Apache Software Foundation, please see\n * <http://www.apache.org/>.\n */\n\npackage org.apache.tools.ant.taskdefs;\n\nimport org.apache.tools.ant.BuildException;\nimport org.apache.tools.ant.DirectoryScanner;\nimport org.apache.tools.ant.Project;\nimport org.apache.tools.ant.Task;\nimport org.apache.tools.ant.types.FileSet;\nimport org.apache.tools.ant.types.PatternSet;\nimport org.apache.tools.ant.util.FileUtils;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.RandomAccessFile;\nimport java.io.FileOutputStream;\nimport java.io.FileNotFoundException;\nimport java.io.InputStream;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.Vector;\nimport java.util.zip.ZipInputStream;\nimport java.util.zip.ZipEntry;\n\n/**\n * Unzip a file.\n *\n * @author costin@dnt.ro\n * @author <a href=\"mailto:stefan.bodewig@epost.de\">Stefan Bodewig</a>\n * @author <a href=\"mailto:umagesh@apache.org\">Magesh Umasankar</a>\n *\n * @since Ant 1.1\n *\n * @ant.task category=\"packaging\"\n *           name=\"unzip\"\n *           name=\"unjar\"\n *           name=\"unwar\"\n */\npublic class Expand extends Task {\n    private File dest; //req\n    private File source; // req\n    private boolean overwrite = true;\n    private Vector patternsets = new Vector();\n    private Vector filesets = new Vector();\n    private static final byte[] ZIPMARKER = {0x50,0x4b,0x03,0x04};\n    private static final int MARKER_SIZE = ZIPMARKER.length;                  \n    private static final int MAX_LOOKAHEAD = 50 * 1024; // 50K.\n\n    /**\n     * Do the work.\n     *\n     * @exception BuildException Thrown in unrecoverable error.\n     */\n    public void execute() throws BuildException {\n        if (\"expand\".equals(taskType)) {\n            log(\"!! expand is deprecated. Use unzip instead. !!\");\n        }\n\n        if (source == null && filesets.size() == 0) {\n            throw new BuildException(\"src attribute and/or filesets must be \"\n                                     + \"specified\");\n        }\n\n        if (dest == null) {\n            throw new BuildException(\n                \"Dest attribute must be specified\");\n        }\n\n        if (dest.exists() && !dest.isDirectory()) {\n            throw new BuildException(\"Dest must be a directory.\", location);\n        }\n\n        FileUtils fileUtils = FileUtils.newFileUtils();\n\n        if (source != null) {\n            if (source.isDirectory()) {\n                throw new BuildException(\"Src must not be a directory.\" +\n                    \" Use nested filesets instead.\", location);\n            } else {\n                expandFile(fileUtils, source, dest);\n            }\n        }\n        if (filesets.size() > 0) {\n            for (int j = 0; j < filesets.size(); j++) {\n                FileSet fs = (FileSet) filesets.elementAt(j);\n                DirectoryScanner ds = fs.getDirectoryScanner(project);\n                File fromDir = fs.getDir(project);\n\n                String[] files = ds.getIncludedFiles();\n                for (int i = 0; i < files.length; ++i) {\n                    File file = new File(fromDir, files[i]);\n                    expandFile(fileUtils, file, dest);\n                }\n            }\n        }\n    }\n\n    /*\n     * This method is to be overridden by extending unarchival tasks.\n     */\n    protected void expandFile(FileUtils fileUtils, File srcF, File dir) {\n        log(\"Expanding: \" + srcF + \" into \" + dir, Project.MSG_INFO);        \n        ZipInputStream zis = null;\n        FileInputStream fis = null;\n        RandomAccessFile raf = null;                \n        byte[] buff = new byte[MARKER_SIZE];                                   \n        try {            \n            fis = new FileInputStream(srcF);\n            raf = new RandomAccessFile(srcF,\"r\");                        \n            long offset = 0;            \n            int more = 0;            \n            while(((more = raf.read(buff)) != -1) || (offset < MAX_LOOKAHEAD)) \n{                               \n                raf.seek(++offset);\n                if(Arrays.equals(buff,ZIPMARKER)) {                      \n                    if(offset > 0) { \n                        fis.skip(offset - 1);                        \n                    }                                \n                break;\n                }\n            }               \n            log(offset <=1 ? \"Looks like a normal archive\" : \n                              \"Looks like a self-extracting \narchive\",Project.MSG_INFO);            \n            zis = new ZipInputStream(fis);\n            ZipEntry ze = null;\n            while ((ze = zis.getNextEntry()) != null) {\n                extractFile(fileUtils, srcF, dir, zis,\n                            ze.getName(), new Date(ze.getTime()),\n                            ze.isDirectory());\n            }\n\n            log(\"expand complete\", Project.MSG_VERBOSE);\n        } catch (IOException ioe) {\n            throw new BuildException(\"Error while expanding \" + srcF.getPath(),\n                                     ioe);\n        } finally {\n            if (zis != null) {\n                try {\n                    zis.close();\n                } catch (IOException e) {}\n            }\n        }\n    }\n\n    protected void extractFile(FileUtils fileUtils, File srcF, File dir,\n                               InputStream compressedInputStream,\n                               String entryName,\n                               Date entryDate, boolean isDirectory)\n                               throws IOException {\n\n        if (patternsets != null && patternsets.size() > 0) {\n            String name = entryName;\n            boolean included = false;\n            for (int v = 0; v < patternsets.size(); v++) {\n                PatternSet p = (PatternSet) patternsets.elementAt(v);\n                String[] incls = p.getIncludePatterns(project);\n                if (incls != null) {\n                    for (int w = 0; w < incls.length; w++) {\n                        boolean isIncl =\n                            DirectoryScanner.match(incls[w], name);\n                        if (isIncl) {\n                            included = true;\n                            break;\n                        }\n                    }\n                }\n                String[] excls = p.getExcludePatterns(project);\n                if (excls != null) {\n                    for (int w = 0; w < excls.length; w++) {\n                        boolean isExcl =\n                            DirectoryScanner.match(excls[w], name);\n                        if (isExcl) {\n                            included = false;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (!included) {\n                //Do not process this file\n                return;\n            }\n        }\n\n        File f = fileUtils.resolveFile(dir, entryName);\n        try {\n            if (!overwrite && f.exists()\n                && f.lastModified() >= entryDate.getTime()) {\n                log(\"Skipping \" + f + \" as it is up-to-date\",\n                    Project.MSG_DEBUG);\n                return;\n            }\n\n            log(\"expanding \" + entryName + \" to \" + f,\n                Project.MSG_VERBOSE);\n            // create intermediary directories - sometimes zip don't add them\n            File dirF = fileUtils.getParentFile(f);\n            if ( dirF != null ) {\n                dirF.mkdirs();\n            }\n\n            if (isDirectory) {\n                f.mkdirs();\n            } else {\n                byte[] buffer = new byte[1024];\n                int length = 0;\n                FileOutputStream fos = null;\n                try {\n                    fos = new FileOutputStream(f);\n\n                    while ((length =\n                            compressedInputStream.read(buffer)) >= 0) {\n                        fos.write(buffer, 0, length);\n                    }\n\n                    fos.close();\n                    fos = null;\n                } finally {\n                    if (fos != null) {\n                        try {\n                            fos.close();\n                        } catch (IOException e) {}\n                    }\n                }\n            }\n\n            fileUtils.setFileLastModified(f, entryDate.getTime());\n        } catch (FileNotFoundException ex) {\n            log(\"Unable to expand to file \" + f.getPath(), Project.MSG_WARN);\n        }\n\n    }\n\n    /**\n     * Set the destination directory. File will be unzipped into the\n     * destination directory.\n     *\n     * @param d Path to the directory.\n     */\n    public void setDest(File d) {\n        this.dest = d;\n    }\n\n    /**\n     * Set the path to zip-file.\n     *\n     * @param s Path to zip-file.\n     */\n    public void setSrc(File s) {\n        this.source = s;\n    }\n\n    /**\n     * Should we overwrite files in dest, even if they are newer than\n     * the corresponding entries in the archive?\n     */\n    public void setOverwrite(boolean b) {\n        overwrite = b;\n    }\n\n    /**\n     * Add a patternset\n     */\n    public void addPatternset(PatternSet set) {\n        patternsets.addElement(set);\n    }\n\n    /**\n     * Add a fileset\n     */\n    public void addFileset(FileSet set) {\n        filesets.addElement(set);\n    }\n\n}"}, {"count": 1, "tags": [], "text": "I'm going to mark as an enhancement for now.", "is_private": false, "bug_id": 16213, "id": 29676, "time": "2003-01-19T13:00:33Z", "creator": "conor@apache.org", "creation_time": "2003-01-19T13:00:33Z", "attachment_id": null}, {"count": 2, "attachment_id": 4563, "bug_id": 16213, "is_private": false, "id": 30120, "time": "2003-01-27T17:33:49Z", "creator": "levylambert@tiscali-dsl.de", "creation_time": "2003-01-27T17:33:49Z", "tags": [], "text": "Created attachment 4563\nupdated the fix of Jason Salter"}, {"count": 3, "tags": [], "creator": "levylambert@tiscali-dsl.de", "attachment_id": 4564, "is_private": false, "id": 30121, "time": "2003-01-27T17:36:46Z", "bug_id": 16213, "creation_time": "2003-01-27T17:36:46Z", "text": "Created attachment 4564\nupdated patch of Jason Salter"}, {"count": 4, "attachment_id": 4565, "bug_id": 16213, "is_private": false, "id": 30122, "time": "2003-01-27T17:50:39Z", "creator": "levylambert@tiscali-dsl.de", "creation_time": "2003-01-27T17:50:39Z", "tags": [], "text": "Created attachment 4565\nsample self-extractible zip file for tests"}, {"count": 5, "tags": [], "creator": "bodewig@apache.org", "text": "should be fixed with nightly build 2003-04-25, thanks.", "id": 35981, "time": "2003-04-24T13:04:54Z", "bug_id": 16213, "creation_time": "2003-04-24T13:04:54Z", "is_private": false, "attachment_id": null}]