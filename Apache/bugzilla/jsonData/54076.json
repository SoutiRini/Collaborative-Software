[{"count": 0, "tags": [], "bug_id": 54076, "is_private": false, "id": 163066, "attachment_id": null, "creator": "1983-01-06@gmx.net", "creation_time": "2012-10-30T13:49:27Z", "time": "2012-10-30T13:49:27Z", "text": "At the moment, Tomcat is not able to store connection-level information to support stateful authentication mechanisms. This has been confirmed on the mailinglist: http://www.mail-archive.com/users@tomcat.apache.org/msg102169.html\n\nUnfortunately, a client which observes that, like Apache HTTPComponents or libserf (used in Apache Subversion) with authenticate only the first the request and expect the server to cache that for the connection. Subsequent comm will end in an endless loop. See here http://serf.googlecode.com/issues/attachment?aid=770006001&name=tomcat-serf-spnego-response.png&token=GDWvY5f7eMDzDGwtg1tD5N_MUXY%3A1351604707042&inline=1 and here http://serf.googlecode.com/issues/attachment?aid=770006002&name=serf-endless-loop.png&token=cHvvfubJuAHDuTMjG_OHOaps5hQ%3A1351604707042&inline=1\n\nA simple hint can tell the client that the server does not support stateful auth on a connection-level. Add here http://svn.apache.org/viewvc/tomcat/tc7.0.x/trunk/java/org/apache/catalina/authenticator/SpnegoAuthenticator.java?view=markup#l272 before line 272 \"response.addHeader(\"Connection\", \"close\");\" and the client will open a new connection and reauth further requests.\n\nNot doing so makes the Tomcat server vulnerable to DoS as you can see in the second screenshot."}, {"count": 1, "tags": [], "bug_id": 54076, "attachment_id": null, "is_private": false, "id": 163068, "time": "2012-10-30T16:34:59Z", "creator": "markt@apache.org", "creation_time": "2012-10-30T16:34:59Z", "text": "Is that really a DoS (in that the server is unavailable to other clients) or do you mean that the client gets stuck in an infinite loop?\n\nFor a DoS, the resources used by Tomcat need to be out of proportion to the number of requests. i.e. If a client just sending a request again and again uses roughly the same server resources as this case then it is not a DoS. The report does not (at this point) sound like a DoS."}, {"count": 2, "tags": [], "bug_id": 54076, "attachment_id": null, "id": 163069, "time": "2012-10-30T16:59:36Z", "creator": "1983-01-06@gmx.net", "creation_time": "2012-10-30T16:59:36Z", "is_private": false, "text": "Well, I guess the latter applies but I have tried only one client at the same time. I was able to loop client and server within seconds for tens of thousands of requests (as you have seen in the screenshot). I guess if you scale to 100 parallel connections or more what would happen to a Tomcat instance?\n\nMay this lead to a DoS?"}, {"count": 3, "tags": [], "bug_id": 54076, "attachment_id": null, "is_private": false, "id": 163157, "time": "2012-11-03T20:59:57Z", "creator": "markt@apache.org", "creation_time": "2012-11-03T20:59:57Z", "text": "There is no evidence of a DoS in this report."}, {"count": 4, "tags": [], "creator": "markt@apache.org", "attachment_id": null, "text": "There is one work-around already available. Set alwaysUseSession on the Authenticator Valve.\n\nI have added support for a second work-around to trunk and 7.0.x. This work-around enables HTTP keep-alive to be disabled for specified user-agents if they attempt to use SPNEGO. This will be included in 7.0.33 onwards.\n\nI'm not a huge fan of adding the ability to cache information per connection as that goes against the stateless nature of HTTP. That said, I'd be prepared to look at a patch that did this and, depending on how invasive it was, would consider such a patch for 8.0.x.", "id": 163158, "time": "2012-11-03T22:38:13Z", "bug_id": 54076, "creation_time": "2012-11-03T22:38:13Z", "is_private": false}, {"count": 5, "tags": [], "bug_id": 54076, "is_private": false, "id": 163161, "attachment_id": null, "creator": "1983-01-06@gmx.net", "creation_time": "2012-11-04T16:52:23Z", "time": "2012-11-04T16:52:23Z", "text": "(In reply to comment #4)\n> There is one work-around already available. Set alwaysUseSession on the\n> Authenticator Valve.\n\nThis isn't even a workaround for me. You cannot guarantee that the client will respond with the JSESSIONID cookie. You could end up with generating a huge amount of empty sessions.\n \n> I have added support for a second work-around to trunk and 7.0.x. This\n> work-around enables HTTP keep-alive to be disabled for specified user-agents\n> if they attempt to use SPNEGO. This will be included in 7.0.33 onwards.\n\nWell, the server admin needs to know the client's UA preemptively. Is this really feasable?\nThe client cannot know that the server is incapable of performing stateful auth.\nI'd rather always write \"Connection: close\" for general safety.\n \n> I'm not a huge fan of adding the ability to cache information per connection\n> as that goes against the stateless nature of HTTP. That said, I'd be\n> prepared to look at a patch that did this and, depending on how invasive it\n> was, would consider such a patch for 8.0.x.\n\nWe have discussed this already on the mailing list. Yes, HTTP is stateless but some auth mechs are stateful. This means that HTTP has to be stateful somehow. Since this is done on the connection-level, you already have the statefulness w/o tampering of the HTTP model. Consider that SSL is stateful too and simply wraps HTTP messages."}, {"count": 6, "text": "(In reply to comment #5)\n> (In reply to comment #4)\n> > There is one work-around already available. Set alwaysUseSession on the\n> > Authenticator Valve.\n> \n> This isn't even a workaround for me. You cannot guarantee that the client\n> will respond with the JSESSIONID cookie. You could end up with generating a\n> huge amount of empty sessions.\n\nWhile it might not be a valid work-around for you it may well work for others. One of the purposes of Bugzilla is to provide useful information to others that stumble across an issue, not just to fix the issue for the original reporter.\n\n> > I have added support for a second work-around to trunk and 7.0.x. This\n> > work-around enables HTTP keep-alive to be disabled for specified user-agents\n> > if they attempt to use SPNEGO. This will be included in 7.0.33 onwards.\n> \n> Well, the server admin needs to know the client's UA preemptively. Is this\n> really feasable?\n\nYes, in some circumstances.\n1. In many environments where SPNEGO is used (I am thinking corporate environments) the user agents are fixed, known and controlled.\n2. You can always write the regular expression to not match known 'safe' UAs (an inverse match is harder but not impossible to write).\n3. Analysis of your access logs will tell you which user agents you are seeing.\n\n> The client cannot know that the server is incapable of performing stateful\n> auth.\n> I'd rather always write \"Connection: close\" for general safety.\n\nIf you prefer to significantly reduce performance for all UAs that wish to use SPNEGO then you are free to use \".*\" as your regular expression and send \"Connection: close\" to all UAs.\n\n> > I'm not a huge fan of adding the ability to cache information per connection\n> > as that goes against the stateless nature of HTTP. That said, I'd be\n> > prepared to look at a patch that did this and, depending on how invasive it\n> > was, would consider such a patch for 8.0.x.\n> \n> We have discussed this already on the mailing list. Yes, HTTP is stateless\n> but some auth mechs are stateful. This means that HTTP has to be stateful\n> somehow. Since this is done on the connection-level, you already have the\n> statefulness w/o tampering of the HTTP model. Consider that SSL is stateful\n> too and simply wraps HTTP messages.\n\nSSL is not SPNEGO. That is comparing apples and oranges. The complication factor with SPNEGO is that the handshake occurs at layer 7 but the caching needs to be at layer 6. With SSL/TLS everything happens at layer 6. I'm not saying it is impossible, nor am I saying Tomcat would never implement such a scheme. I am saying I don't particularly like the idea but am prepared to consider any patch proposed.", "creator": "markt@apache.org", "is_private": false, "id": 163163, "time": "2012-11-04T19:24:34Z", "bug_id": 54076, "creation_time": "2012-11-04T19:24:34Z", "tags": [], "attachment_id": null}, {"count": 7, "tags": [], "text": "(In reply to comment #6)\n> (In reply to comment #5)\n> > (In reply to comment #4)\n> > > There is one work-around already available. Set alwaysUseSession on the\n> > > Authenticator Valve.\n> > \n> > This isn't even a workaround for me. You cannot guarantee that the client\n> > will respond with the JSESSIONID cookie. You could end up with generating a\n> > huge amount of empty sessions.\n> \n> While it might not be a valid work-around for you it may well work for\n> others. One of the purposes of Bugzilla is to provide useful information to\n> others that stumble across an issue, not just to fix the issue for the\n> original reporter.\n> \n> > > I have added support for a second work-around to trunk and 7.0.x. This\n> > > work-around enables HTTP keep-alive to be disabled for specified user-agents\n> > > if they attempt to use SPNEGO. This will be included in 7.0.33 onwards.\n> > \n> > Well, the server admin needs to know the client's UA preemptively. Is this\n> > really feasable?\n> \n> Yes, in some circumstances.\n> 1. In many environments where SPNEGO is used (I am thinking corporate\n> environments) the user agents are fixed, known and controlled.\n\nI would object at least this one. Given a realistic example: We have more than 50 domains in our forest with around 1000 DCs or more. Try too find someone who is responsible for a buggy server who will alter the config for you. Good luck.", "attachment_id": null, "id": 163176, "creator": "1983-01-06@gmx.net", "time": "2012-11-05T09:37:27Z", "bug_id": 54076, "creation_time": "2012-11-05T09:37:27Z", "is_private": false}]