[{"count": 0, "tags": [], "creator": "kiyolee@hotmail.com", "text": "APR interpret WAIT_ABANDONED as equivalent to WAIT_OBJECT_0 and this is not\ncorrect. See apr_proc_mutex_lock() and apr_proc_mutex_trylock().\nAccording to doco from MS, WAIT_ABANDONED only means the ownership of the mutex\nhas been changed. The mutex is remain **non-signaled** (or becomes so if it was\nsignaled), i.e. while one thread get the return code WAIT_ABANDONED, it is\npossible that another thread would get the mutex signaled instead. So we can't\nsimple return APR_SUCCESS as described in this notes in the CHANGES file:\n\n  *) Win32: apr_proc_mutex_trylock and apr_proc_mutex_lock were\n     incorrectly returning APR_BUSY if the lock was previously\n     held by a thread that exited before releasing the lock\n     (ie, if the process holding the lock segfaults). The MSDN\n     doc says when WaitForSingleObject returns WAIT_ABANDONED,\n     the calling thread takes ownership of the mutex, so these\n     two routines should return APR_SUCCESS in this case, not\n     APR_BUSY. [Bill Stoddard]\n\nHowever, we shouldn't return APR_BUSY either.\n\nThe normal proper way to handle WAIT_ABANDONED is to put the\nWaitForSingleObject() (or any other equivalent API) in a loop, e.g.:\n\n    do {\n        rc = WaitForSingleObject(mutex, INFINITE);\n    } while (rc == WAIT_ABANDONED);", "id": 85079, "time": "2006-01-27T01:20:36Z", "bug_id": 38410, "creation_time": "2006-01-27T01:20:36Z", "is_private": false, "attachment_id": null}, {"count": 1, "attachment_id": null, "bug_id": 38410, "text": "Just tagging this bug for my own followup.\n\nThank you for your comments; I need to research that this isn't a duplicate\nissue.", "id": 85135, "time": "2006-01-27T21:45:45Z", "creator": "wrowe@apache.org", "creation_time": "2006-01-27T21:45:45Z", "tags": [], "is_private": false}, {"count": 2, "attachment_id": null, "bug_id": 38410, "text": "Your proposed code;\n\n    do {\n        rc = WaitForSingleObject(mutex, INFINITE);\n    } while (rc == WAIT_ABANDONED);\n\nlooks like an infinte loop waiting to happen.\n\nWould returing APR_EAGAIN on WAIT_ABANDONED map appropriately to the condition?", "id": 85184, "time": "2006-01-30T06:34:54Z", "creator": "wrowe@apache.org", "creation_time": "2006-01-30T06:34:54Z", "tags": [], "is_private": false}, {"count": 3, "tags": [], "bug_id": 38410, "attachment_id": null, "text": "I am sure that's not the case.\nNormally WaitForSingleObject() will return WAIT_OBJECT_0 and get out of the loop.\nOnly when the current owner got terminated (usually abnormally like crashing),\nthen it will return WAIT_ABANDONED and try again.\nIt is very unlikely all other potential owners got terminated so abnormally all\nat the same time. Even when that happens, the current loop would become the\nowner and no way it will get WAIT_ABANDONED and definitely it will break out of\nthe loop.\nIn other words, the loop will loop only for at maximum the number of processes\nusing the mutex minus 1.\nReminded WAIT_ABANDONED is an abnormal case and should rarely happen and the\nloop is mainly to handle that properly. Anyway, the current implementation is\ndefinitely wrong (returning APR_SUCCESS when the mutex is not actually\nsignalled) when that happens.\nIf APR_EAGAIN means that the user needs to call mutex_lock() again to really\nacquire the mutex, then that is logically correct.\nHowever, I would rather like to have the lower level code handle the abnormal\ncase. The application code calling mutex_lock() would be much simplier to worry\nabout only 2 return codes (APR_SUCCESS or APR_BUSY) instead of 3 (plus\nAPR_EAGAIN). Also consider everywhere calling mutex_lock() would then need to\nhave a loop handling APR_EAGAIN as the error code just can't be ignored.", "id": 85299, "time": "2006-02-01T14:05:08Z", "creator": "kiyolee@hotmail.com", "creation_time": "2006-02-01T14:05:08Z", "is_private": false}, {"count": 4, "tags": [], "creator": "kiyolee@hotmail.com", "text": "Forget to mention, even the timeout is INFINITE, WaitForSingleObject() will\nreturn whenever the current owner of the mutex gets terminated.\n\nAlso notice that the loop to handle APR_EAGAIN may actually be redundant for\nnon-win32 platforms which never return anything like WAIT_ABANDONED. So the\ntighter loop inside the win32 specific code implies much less overhead to the\nmutex api.", "id": 85300, "time": "2006-02-01T14:20:38Z", "bug_id": 38410, "creation_time": "2006-02-01T14:20:38Z", "is_private": false, "attachment_id": null}, {"count": 5, "tags": [], "bug_id": 38410, "attachment_id": null, "id": 85718, "time": "2006-02-11T22:42:08Z", "creator": "wrowe@apache.org", "creation_time": "2006-02-11T22:42:08Z", "is_private": false, "text": "KB 105678 points out;\n\n\n  Deadlock. The Synchronization overview says the following about mutexes: \n  If a thread terminates without releasing its ownership of a mutex object, the \n  mutex is considered to be abandoned. A waiting thread can acquire ownership of \n  an abandoned mutex, but the wait function's return value indicates that the \n  mutex is abandoned. \n\n  WaitForSingleObject() will return WAIT_ABANDONED for a mutex that has been \n  abandoned. However, the resource that the mutex is protecting is left in an \n  unknown state. \n\n  There is no way to tell whether a critical section has been abandoned.\n\nSo for the mutex case, it appears we cannot trust the mutex at this point?\n\nPlease provide citations for more recent commentary from Microsoft.  Thanks"}, {"count": 6, "tags": [], "creator": "wrowe@apache.org", "text": "Ok, here's how I read this from WaitForXxx documentation;\n\n  WAIT_ABANDONED\n  The specified object is a mutex object that was not released by the thread that \n  owned the mutex object before the owning thread terminated. Ownership of the \n  mutex object is granted to the calling thread, and the mutex is set to \n  nonsignaled. \n\nSo, threads A, B, and C exist.  Thread A created the mutex, while B and C are \nwaiting on the mutex.  Thread A exits, thread B is notified WAIT_ABANDONED and\nliterally now owns the non-signaled mutex.  Thread C must therefore immediately\nacquire the mutex (as it is waiting and MS can't be granting ownership to mult\nthreads, obviously), so thread B should loop and wait again.\n\nSure sounds like a potential starvation situation if creating threads frequently\nterminate, but let's presume sane authors don't kick around mutexes that way :)\n\nI'll apply the patch after reviewing all the places it must go.\n", "id": 85719, "time": "2006-02-11T22:50:05Z", "bug_id": 38410, "creation_time": "2006-02-11T22:50:05Z", "is_private": false, "attachment_id": null}, {"count": 7, "tags": [], "bug_id": 38410, "attachment_id": null, "text": "FYI Applied to apr_file_read/write, still many more spots this logic should go.", "id": 87627, "time": "2006-04-06T11:55:21Z", "creator": "wrowe@apache.org", "creation_time": "2006-04-06T11:55:21Z", "is_private": false}, {"count": 8, "tags": [], "bug_id": 38410, "attachment_id": null, "text": "Mass reassign the 44 open apr-bugs to apr bug list", "id": 93825, "time": "2006-09-19T19:54:34Z", "creator": "wrowe@apache.org", "creation_time": "2006-09-19T19:54:34Z", "is_private": false}]