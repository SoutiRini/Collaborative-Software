[{"count": 0, "tags": [], "creator": "soloshenko@writeme.com", "attachment_id": null, "is_private": false, "id": 113529, "time": "2008-02-07T07:47:05Z", "bug_id": 44374, "creation_time": "2008-02-07T07:47:05Z", "text": "Trying to run test with constant throughput higher than 60000 executions per\nminute leads to uncontrolled throughtput increase. It happens because of\nmillisecond level of delay granularity and due to usage of\nSystem.currentTimeMillis() calls for delay calculations. Because in one minute\nthere are only 60 000 milliseconds and due to integer arithmetics for delay\ncalculation, delay() method always returns 0 if throughput is greater than 60000\nsamples per minute. However, nowadays it is not unusual to have tens of millions\nexecutions per hour on SMP systems. I am testing Telecommunication platform\nwhich intended to handle 50-60 milllions calls per hour."}, {"count": 1, "tags": [], "creator": "sebb@apache.org", "text": "But can a single JMeter instance approach 60 thousand transactions per second?\n\nI very much doubt it, so it seems to me that there is no point in allowing for this.", "id": 113530, "time": "2008-02-07T07:54:54Z", "bug_id": 44374, "creation_time": "2008-02-07T07:54:54Z", "is_private": false, "attachment_id": null}, {"count": 2, "tags": [], "text": "(In reply to comment #1)\n> But can a single JMeter instance approach 60 thousand transactions per second?\n> \n> I very much doubt it, so it seems to me that there is no point in allowing for\nthis.\n\nThe problem is that all calculations are done on PER MINUTE basis. Here the code:\nlong msPerRequest = (long) (MILLISEC_PER_MIN / getThroughput());\nwhere MILLISEC_PER_MIN is a constant and equals to 60000. If getThroughput()\nreturns the value greater than 60000 the result will be 0. And throughput is\ndefined on PER MINUTE basis. Thus we can talk about 1000 executions per second\nONLY, NOT about 60000 per second.\n\nMay be Java 1.5 method: System.nanoTime() could help to solve this problem?\n", "is_private": false, "bug_id": 44374, "id": 113531, "time": "2008-02-07T08:10:33Z", "creator": "soloshenko@writeme.com", "creation_time": "2008-02-07T08:10:33Z", "attachment_id": null}, {"count": 3, "tags": [], "creator": "soloshenko@writeme.com", "attachment_id": null, "is_private": false, "id": 113532, "time": "2008-02-07T08:24:04Z", "bug_id": 44374, "creation_time": "2008-02-07T08:24:04Z", "text": "At least, the following statement is wrong (IMHO):\n\nlong msPerRequest = (long) (MILLISEC_PER_MIN / getThroughput());\n\nthe result shoud be of floating point type (i.e. double), NOT integer (long) and\nONLY after in subsequent calculations like:\n\ndelay = JMeterContextService.getNumberOfThreads() * msPerRequest;\n\nit is OK to cast floating point result to cast to integer (of long type).\nOtherwise, all the requested throughputs more than 60000 will result to  zero\ndalay for every interation. But 60000 samples per minute not to much, especially\nif you configure this throughput for all threads!\n\n"}, {"count": 4, "tags": [], "text": "Thanks for the suggestion, I've changed the calculation to use double.\n\nThe updated test suite shows that larger throughputs are now supported with more threads.\n\nChange was committed to SVN in r632690.", "is_private": false, "bug_id": 44374, "id": 114167, "time": "2008-03-01T17:41:56Z", "creator": "sebb@apache.org", "creation_time": "2008-03-01T17:41:56Z", "attachment_id": null}]