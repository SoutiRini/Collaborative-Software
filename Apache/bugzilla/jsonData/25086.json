[{"count": 0, "tags": [], "creator": "mm_aa@yahoo.com", "attachment_id": null, "text": "java.lang.RuntimeException: Mismatch - popped element = [target: null] finished\ntarget element = [target: null]\n\tat org.apache.tools.ant.XmlLogger.targetFinished(XmlLogger.java:292)\n\tat org.apache.tools.ant.Project.fireTargetFinished(Project.java:1865)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:368)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1237)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1094)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:669)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:220)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:215)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:90) \n\nAfter small debugging, I've found that this isn't the first exception in\nXmlLogger. The first one - the same - is being fired in taskFinished, but eaten.\n\nThe problem occurs, if OOM error occures inside the antcall tasks (we have them\nnested several times).", "id": 48304, "time": "2003-11-29T15:07:15Z", "bug_id": 25086, "creation_time": "2003-11-29T15:07:15Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 25086, "attachment_id": null, "is_private": false, "id": 48648, "time": "2003-12-07T22:32:19Z", "creator": "conor@apache.org", "creation_time": "2003-12-07T22:32:19Z", "text": "In general, when an \"out of memory\" occurs there is a good chance that things\nwill be hosed from thereon due to the failure in some operations. This will\napply to far more than the XMLLogger. I would guess that in this case the\nXMLLogger has failed to push a context onto the element stack due to the OOM and\nthis causes the POP failure. \n\nI think you need to address the root cause of the OOM, rather than try to\naddress it in the XMLLogger. Is the OOM being reported properly? Is that the issue?"}, {"count": 2, "tags": [], "bug_id": 25086, "attachment_id": null, "id": 49452, "creation_time": "2003-12-19T18:07:04Z", "time": "2003-12-19T18:07:04Z", "creator": "mm_aa@yahoo.com", "text": "The problem is that I never saw the OOM. What I saw is this RuntimeException.\nAnd it cost me several hours of debugging to find that the exception occures\nduring OOM exception handling.", "is_private": false}, {"count": 3, "tags": [], "creator": "artur.lorincz@kiq.com", "is_private": false, "text": "Running Ant from Cruisecontrol(http://cruisecontrol.sourceforge.net/) often\ngives OOM because of the XmlLogger. \n\nI checked the implementation of the logger and observed the followings:\n - at each target/task starting event a corresponding TimedElement instance is\nput in the tasks/targets hashtables\n - at each target/task finished event the TimedElement instance is looked up,\nits and its corresponding \"element\"(org.w3c.dom.Element) field is completed.\n\nI think, that at the target/task finished events, that is, targetFinished(...),\ntaskFinished(...) methods, after all relevant information has been extracted\nfrom the timedElement, this can be removed from the tasks or target hashtables.\nAfter removing it and setting explicitely the instance to null, we make it\neligible for GC.\n\nHere is the patch: the lines marked /* newly added */ represent the changes.\n\n public void taskFinished(BuildEvent event) {\n        Task task = event.getTask();\n        TimedElement taskElement = (TimedElement) tasks.get(task);\n        if (taskElement != null) {\n            long totalTime = System.currentTimeMillis() - taskElement.startTime;\n            taskElement.element.setAttribute(TIME_ATTR,\n                    DefaultLogger.formatTime(totalTime));\n            Target target = task.getOwningTarget();\n            TimedElement targetElement = null;\n            if (target != null) {\n                targetElement = (TimedElement) targets.get(target);\n            }\n            if (targetElement == null) {\n                buildElement.element.appendChild(taskElement.element);\n            } else {\n                targetElement.element.appendChild(taskElement.element);\n            }\n            Stack threadStack = getStack();\n            if (!threadStack.empty()) {\n                TimedElement poppedStack = (TimedElement) threadStack.pop();\n                if (poppedStack != taskElement) {\n                    throw new RuntimeException(\"Mismatch - popped element = \"\n                            + poppedStack.element + \" finished task element = \"\n                            + taskElement.element);\n                }\n            }\n            tasks.remove(task); /* newly added */\n            task = null;        /* newly added */  \n        }\n    }\n\npublic void targetFinished(BuildEvent event) {\n        Target target = event.getTarget();\n        TimedElement targetElement = (TimedElement) targets.get(target);\n        if (targetElement != null) {\n            long totalTime\n                    = System.currentTimeMillis() - targetElement.startTime;\n            targetElement.element.setAttribute(TIME_ATTR,\n                    DefaultLogger.formatTime(totalTime));\n\n            TimedElement parentElement = null;\n            Stack threadStack = getStack();\n            if (!threadStack.empty()) {\n                TimedElement poppedStack = (TimedElement) threadStack.pop();\n                if (poppedStack != targetElement) {\n                    throw new RuntimeException(\"Mismatch - popped element = \"\n                            + poppedStack.element\n                            + \" finished target element = \"\n                            + targetElement.element);\n                }\n                if (!threadStack.empty()) {\n                    parentElement = (TimedElement) threadStack.peek();\n                }\n            }\n            if (parentElement == null) {\n                buildElement.element.appendChild(targetElement.element);\n            } else {\n                parentElement.element.appendChild(targetElement.element);\n            }\n         targets.remove(target); /* newly added */\n         target = null;  /* newly added */\n        }\n    }\n\n", "id": 51975, "time": "2004-02-09T07:16:18Z", "bug_id": 25086, "creation_time": "2004-02-09T07:16:18Z", "attachment_id": null}, {"count": 4, "tags": [], "bug_id": 25086, "is_private": false, "text": "Applied Artur's patch. It should reduce the possibilly of\nOOM problems for nested ant-calls, but does not change\nthe mis?reporting of the OOM.\n", "id": 51989, "time": "2004-02-09T14:04:03Z", "creator": "peter.reilly@corvil.com", "creation_time": "2004-02-09T14:04:03Z", "attachment_id": null}, {"count": 5, "tags": [], "bug_id": 25086, "is_private": false, "text": "*** Bug 40209 has been marked as a duplicate of this bug. ***", "id": 118480, "time": "2008-07-10T08:41:26Z", "creator": "bodewig@apache.org", "creation_time": "2008-07-10T08:41:26Z", "attachment_id": null}, {"count": 6, "tags": [], "bug_id": 25086, "is_private": false, "id": 121954, "creation_time": "2008-10-28T07:32:42Z", "time": "2008-10-28T07:32:42Z", "creator": "bodewig@apache.org", "text": "We will most likely hit the OOM during the buildFinished event, I've added a few guards to write to System.err in that case, so we have a chance to get the root cause.\n\nany error that happens during any other logging is almost impossible to report because it would require a working logging system.\n\nsvn revision 708584", "attachment_id": null}]