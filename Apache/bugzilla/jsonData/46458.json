[{"count": 0, "tags": [], "bug_id": 46458, "attachment_id": null, "id": 123665, "time": "2008-12-31T06:13:30Z", "creator": "postmaster@sebn.us.to", "creation_time": "2008-12-31T06:13:30Z", "is_private": false, "text": "I would suggest a enhancement to mod_ssl, allowing people to specify SSLCertificateFile in this way:\n\nSSLCertificateFile exec:/path/to/script/or/program\n\nexample:\n\nSSLCertificateFile exec:/usr/bin/certgenerate %{SERVER_ADDR}\nor\nSSLCertificateFile exec:/usr/bin/certgenerate %{SERVER_PORT} %{SERVER_ADDR} %{REMOTE_PORT} %{REMOTE_ADDR}\n\nThe intent is that the server administrator should be able to specify a script or a program, that dynamically generates the certificate.\nOf course all variables that is available prior SSL handshake should of course be able to use in the SSLCertificateFile statement.\n\nThe script or program only needs to output the certificate on STDOUT and then simply exit.\n\nExample of uses, is for example a server administrator which have many IPs for the same server, and then wants to give each IP number a own certificate without having to create a VirtualHost for each IP.\nBy using a program, it would then be possible to fetch the correct certificate based on the target IP of the request.\n\nAnother use would be the people who use Apache as either a forward proxy, or a reverse proxy. The certgenerate software can then fetch the certificate from the target IP by doing a SSL handshake with the IP, and then resigning the certificate with a own CA key, and then priting the certificate on STDOUT.\n\nThis can for example be good for making a SSL scanning forward proxy, in enviroments where security scanning of outgoing SSL traffic is required."}, {"count": 1, "tags": [], "creator": "jorton@redhat.com", "text": "1) if you know the set of hostnames which can be used ahead of time then you can pregenerate the cert(s) and avoid having ugly hacks in mod_ssl.\n\n2) if you don't know you'll need a wildcard cert anyway.", "id": 123705, "time": "2009-01-02T08:58:34Z", "bug_id": 46458, "creation_time": "2009-01-02T08:58:34Z", "is_private": false, "attachment_id": null}, {"count": 2, "tags": [], "bug_id": 46458, "text": "But I mean if I only know the hostname at the time of the request, before SSL-handshake.\n\nOr if I generate domains on-the-fly tied to a specific IP-adress, and want to lookup the correct domain given a specific IP-adress, and then load the correct certificate.\n\nLets say I have 50 IPs. Then lets say I have 50 different subdomains connected to each IP.\nInstead of creating 50 VirtualHosts with its own certificate, I could simply have one virtualhost with SSLCertificateFile exec:/usr/bin/cat /etc/httpd/certificates/%{SERVER_ADDR}.crt\n\nAnd Apache would for the request with the target ip \"213.12.14.56\" execute \"/usr/bin/cat /etc/httpd/certificates/213.12.14.56.crt\" (which would be a certificate with its DN set to the correct domain)\nand use the certificate it gets on STDOUT for the current SSL request.\n\nThats one example.\n\nThe following enviroment vars are available before handshake:\nall SERVER_ variables\nall REMOTE_ variables except REMOTE_USER\nall TIME_ variables\nand the HTTPS variable (which in this case always is \"on\")\n\nAnother example is in a corporate proxy situation, where you want to do SSL scanning of all SSL requests made from inside firewall.\nYou can set up a DNS which delivers the IP 10.1.1.1 to 10.1.254.254 sequentally, for each domain requested, and then store which domain that was requested when the IP x.x.x.x was returned, in a database...\n\nSo when a client with the IP 10.2.1.2 request:\nwww.google.se from the DNS, it would return \"www.google.se IN A 10.1.1.1\" , and then store in database:\n\"UPDATE domaintable SET domain='www.google.se' WHERE ip='10.1.1.1' AND clientip='10.2.1.2'\"\n\nnext the same client request www.gmail.com, it would get \"www.gmail.com IN A 10.1.1.2\" from the DNS, and then it store:\n\"UPDATE domaintable SET domain='www.gmail.com' WHERE ip='10.1.1.2' AND clientip='10.2.1.2'\"\n\nThen you can have a CA certificate with its corresponding private key, and then have a normal certificate with a specific publickey and private key.\n\nThen you can have:\nSSLCertificateFile /usr/bin/certgenerate %{SERVER_ADDR} %{REMOTE_ADDR}\n\nAnd the script could look something like this (pseudocode)\nGet Argument1 and Argument2 from commandline\nVariable1 = \"SELECT domain FROM domaintable WHERE ip='Argument1' AND clientip='Argument2'\"\nLoad /etc/certificates/cert.pem\nReplace current DN with Variable1\nResign certificate with the CA private key\nprint certificate on STDOUT\n\nSo this is the 2 examples I could come up with.\n\nAnd I think this would be pretty easy to implement. The only thing that needs to be changed, is to load the certificate for each request instead of server start, and then allow the use of SSLCertificateFile exec:/path/to/program which executes the program with specified arguments, and then reads from the STDOUT, and a function to resolve variable names like %{REMOTE_ADDR}, %{SERVER_ADDR} and such.\n\nI think it would be a good interface to those that want to do some more advanced certificate management than loading from a simple file.", "id": 123709, "time": "2009-01-02T09:50:29Z", "creator": "postmaster@sebn.us.to", "creation_time": "2009-01-02T09:50:29Z", "is_private": false, "attachment_id": null}, {"attachment_id": null, "tags": [], "bug_id": 46458, "text": "Closing this enhancement request WONTFIX, too hairy and of limited usefulness.  If you want to propose an interface in mod_ssl to make this possible outside of mod_ssl, that is a possible alternative.", "count": 3, "id": 148452, "time": "2011-08-07T00:24:19Z", "creator": "covener@gmail.com", "creation_time": "2011-08-07T00:24:19Z", "is_private": false}]