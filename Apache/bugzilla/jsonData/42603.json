[{"count": 0, "attachment_id": null, "creator": "christof.engel@web.de", "is_private": false, "id": 104120, "time": "2007-06-06T02:23:08Z", "bug_id": 42603, "creation_time": "2007-06-06T02:23:08Z", "tags": [], "text": "As I use ant to syncronize my buildprocess over seperated computers, I need to\nknow, if some is still building or not. I do that over filesystem with files\nlike \"abc.building\" \"def.building\" etc.\n\nNow, the main task should wait until none of the others is building any more. \nUntil today (I modified my ant version today to achieve the goal) I have to\nwrite it like this:\n    <waitfor maxwait=\"60\" maxwaitunit=\"minute\" checkevery=\"5\"\ncheckeveryunit=\"second\" timeoutproperty=\"waitforOthersTimeout\">\n      <not>\n        <or>\n      <available file=\"${buildsrv_exchange}\\list_abc.building\"/>\n      <available file=\"${buildsrv_exchange}\\list_def.building\"/>\n      <available file=\"${buildsrv_exchange}\\list_something.building\"/>\n      <available file=\"${buildsrv_exchange}\\list_abc.shouldstart\"/>\n      <available file=\"${buildsrv_exchange}\\list_def.shouldstart\"/>\n      <available file=\"${buildsrv_exchange}\\list_something.shouldstart\"/>\n        </or>\n      </not>\n    </waitfor>\n\nI now can write this like this:\n <available MatchFilename=\"list*.building\" MatchFilepath=\"${buildsrv_exchange}\"/>\n <available MatchFilename=\"list*.shouldstart\"     \nMatchFilepath=\"${buildsrv_exchange}\"/>\n\nI have not only 2 tasks to wait for, but many, so it is in deed a gread\nenhancement if I can be able to use wildcards like '*\" and '?'.\n\nThe code is not perfect, but a quick-and-dirty hack for <available>, the\n\"MatchFilepath\" must be set in that case, you can do that better and use the\nexistend \"filepath\" instead of introducing a new \"MatchFilepath\". You can also\neasyly add a \"scanSubdir\" feature.\nBut here it is (additional lines for Available.java (in v.1.6.5):\nadd:\n    private String matchFilepath = null;\nenhance:\n    private boolean checkFile() {\n        if (matchFilepath != null) {\n            return checkMatchFilePath(file, false);\n        }\n\nadd:\n  /**\n   * Check if a given filename exists and matches the pattern (no RegEx)\n   */\n\n  public void setMatchFilename(String filename) {\n    this.filename = filename;\n  }\n  public void setMatchFilepath(String path) {\n    this.matchFilepath = path;\n    this.file = new File(path);\n  }\n\n\tprivate boolean stringCompare(String strCompare, String strSource) {\n\t\tint i = 0;\n\t\tint l = strCompare.length();\n\t\tif (strSource.length() < l) {\n\t\t\treturn false;\n\t\t}\n\t\tif (strCompare.equalsIgnoreCase(strSource)) {\n\t\t\treturn true;\n\t\t}\n\t\tboolean bMatch = true;\n\t\twhile (bMatch && (i < l)) {\n\t\t\tswitch (strCompare.charAt(i)) {\n\t\t\tcase '?':\n\t\t\t\tbreak; // ignore single char\n\t\t\tcase '*':\n\t\t\t\ti = l; // ignore rest\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (strCompare.charAt(i) != strSource.charAt(i)) {\n\t\t\t\t\tbMatch = false; // Stop here.\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn bMatch;\n\t}\n\n\tprivate boolean filenameMatchesFilter(String sFilename, String sFilter) {\n\t\tif (sFilter.length() == 0) \n\t\t  return true;\n\t\tint i = sFilter.lastIndexOf(\".\");\n\t\tint j;\n\t\t// filter has file extension?\n\t\tif (i > 0) {\n\t\t\tj = sFilename.lastIndexOf(\".\");\n\t\t\tif (j > 0) {\n\t\t\t\t// check file extension seperatly\n\t\t\t\tif (stringCompare(sFilter.substring(i + 1), sFilename.substring(j + 1))) {\n\t\t\t\t\t// check filename (without ext)\n\t\t\t\t\treturn (stringCompare(sFilter.substring(0, i), sFilename.substring(0, j)));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// file has no extension, check filter extension is .*\n\t\t\t\tif (stringCompare(sFilter.substring(i + 1), \"*\")) {\n\t\t\t\t\t// check filename (without ext)\n\t\t\t\t\treturn (stringCompare(sFilter.substring(0, i - 1), sFilename));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// filter without file extension\n\t\t\treturn (stringCompare(sFilter, sFilename));\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean fileMatchFilter(String fi, String filename) {\n\t\tif (fi != null) {\n\t\t\tif ((fi == \"*.*\") || (fi == \"*\")) {\n\t\t\t\t// this normally means \"all files\"\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (filenameMatchesFilter(filename.toUpperCase(), fi.toUpperCase())) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n  private boolean checkMatchFilePath(File recurDir, boolean scanSubdirs) {\n    if ((!recurDir.exists()) || (!recurDir.isDirectory())) {\n      return false;\n    }\n    int i;\n    File aDirectory = null;\n    File[] aDirList = recurDir.listFiles();\n    if (aDirList != null && aDirList.length > 0) {\n      for (i = 0; i < aDirList.length; i++) {\n        aDirectory = aDirList[i];\n        if (aDirectory.canRead()) {\n          if (aDirectory.isDirectory()) {\n            if (scanSubdirs) {\n              if (checkMatchFilePath(aDirectory, true)) {\n                return true;\n              }\n            }\n          } else {\n            if (fileMatchFilter(this.filename, aDirectory.getName())) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }"}, {"count": 1, "tags": [], "bug_id": 42603, "attachment_id": null, "text": "I dont think this should go in available, as available is overloaded. But a\nseparate findfile task might be useful, especially if it sets a property to the\nname of the file that matches. \n\nI think you may be able to play games with selectors and filesets to achieve the\nsame result.", "id": 104127, "time": "2007-06-06T05:05:05Z", "creator": "stevel@apache.org", "creation_time": "2007-06-06T05:05:05Z", "is_private": false}, {"text": "Available already accepts a nested path structure, which in turn accepts a\nnested fileset, which in turn already accepts wildcards.\n\nSo basically, you can already do this today without any modifications to Ant;\nmaybe check the user list next time?", "tags": [], "bug_id": 42603, "attachment_id": null, "count": 2, "id": 104128, "time": "2007-06-06T05:12:21Z", "creator": "carej@us.ibm.com", "creation_time": "2007-06-06T05:12:21Z", "is_private": false}, {"count": 3, "tags": [], "text": "indeed; I don't see anything here that can't be done in Ant 1.7.  Start with the following, and if you get \nstuck, bring it to user@ant.apache.org:\n\n<waitfor>\n  <resourcecount count=\"0\">\n    <fileset dir=\"${buildsrv_exchange}\" includes=\"**/list_*.building,**/list_*.shouldstart\" />\n  </resourcecount>\n</waitfor>\n\n", "is_private": false, "id": 104138, "creator": "mbenson@apache.org", "time": "2007-06-06T07:18:15Z", "bug_id": 42603, "creation_time": "2007-06-06T07:18:15Z", "attachment_id": null}, {"count": 4, "attachment_id": null, "creator": "christof.engel@web.de", "is_private": false, "id": 104140, "time": "2007-06-06T08:11:36Z", "bug_id": 42603, "creation_time": "2007-06-06T08:11:36Z", "tags": [], "text": "OK, I don't have tried ANT v1.7 so far, the resourcecount tag was not present in\nAnt 1.6.5, so I will try switching to ANT 1.7 and use that.\nThanks so far.\n\n> <waitfor>\n>   <resourcecount count=\"0\">\n>     <fileset dir=\"${buildsrv_exchange}\"\nincludes=\"**/list_*.building,**/list_*.shouldstart\" />\n>   </resourcecount>\n> </waitfor>\n> \n\n"}]