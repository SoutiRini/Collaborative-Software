[{"count": 0, "tags": [], "creator": "fvoznika@hotmail.com", "attachment_id": null, "text": "The attribute \"javax.servlet.request.X509Certificate\" doesn't get copied with\nthe request when the request is forwarded. To reproduce it, follow these steps:\n\n- Create an HTTPS connector and enable client authentication.\n    <Connector className=\"org.apache.coyote.tomcat4.CoyoteConnector\"\n               port=\"8443\" minProcessors=\"5\" maxProcessors=\"75\"\n               enableLookups=\"true\"\n\t       acceptCount=\"10\" debug=\"0\" scheme=\"https\" secure=\"true\"\n               useURIValidationHack=\"false\">\n      <Factory className=\"org.apache.coyote.tomcat4.CoyoteServerSocketFactory\"\n               keystoreFile=\"conf/server.jks\" keystorePass=\"changeit\"\n               clientAuth=\"true\" protocol=\"TLS\" />\n    </Connector>\n\n- Generate a CA certificate for the server:\n    > openssl -genrsa -out ca.key 1024\n    > openssl req -new -key ca.key -out ca.csr\n    > openssl x509 -req -days 365 -in ca.csr -signkey ca.key -out ca.crt\n\n- Import the CA certificate (ca.crt) to the tru sted CA certificates keystore in\nyour JVM:\n    > keytool -import -file ca.crt -keystore <JAVA_HOME>/lib/security/cacerts\n\n- Generate a certificate to the client:\n    > openssl -genrsa -out client.key 1024\n    > openssl req -new -key client.key -out client.csr\n    > openssl x509 -req -days 365 -CA ca.crt -CAkey ca.key -CAcreateserial -in\nclient.csr -out client.crt\n(you may want to leave -CAcreateserial out).\n    > openssl pkcs12 -export -clcerts -in client.crt -inkey client.key -out\nclient.p12\n\n- Import the client certificate and key (client.p12) into the browser.\n- Import the CA certificate (ca.crt) into the browser.\n- Generate a certificate for the server:\n    > keytool -genkey -keystore server.jks -alias tomcat\n\n- Run the following servlet:\n\npackage test;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.*;\nimport java.io.*;\n\npublic class TestCertServlet extends HttpServlet {\n\n    protected void service(HttpServletRequest req, HttpServletResponse res)\nthrows ServletException, IOException {\n        Integer curTmp = (Integer)req.getAttribute(\"value\");\n        int cur = curTmp == null ? 0 : curTmp.intValue()+1;\n\n        Object certs = req.getAttribute(\"javax.servlet.request.X509Certificate\");\n        //System.out.println(\"Cur: \"+cur+\" - certs: \"+certs);\n\n        if(cur==5) {\n            printInfo(res, req, cur);\n            return;\n        }\n\n        req.setAttribute(\"Other\"+cur, \"Set\");\n        req.setAttribute(\"Certs\"+cur, certs);\n        req.setAttribute(\"value\", new Integer(cur));\n        this.getServletContext().getRequestDispatcher(\"/TestCert\").forward(req,\nres);\n    }\n\n    private void printInfo(HttpServletResponse res, HttpServletRequest req, int\ncur) throws IOException {\n        PrintWriter w = res.getWriter();\n        w.write(\"<html><title>Testing...</title><body>\");\n        for(int i=0; i<cur; i++) {\n            w.write(\"<p><b>\"+i+\"</b><br>\");\n            w.write(\"Other\"+i+\"=\"+req.getAttribute(\"Other\"+i)+\"<br>\");\n            w.write(\"Certs\"+i+\"=\"+req.getAttribute(\"Certs\"+i)+\"<br>\");\n        }\n        w.write(\"</body></html>\");\n    }\n}\n\nThe output will be this:\n0\nOther0=Set\nCerts0=[Ljava.security.cert.X509Certificate;@1ae939f\n\n1\nOther1=Set\nCerts1=null\n...\n\nThe attribute \"javax.servlet.request.X509Certificate\" is not set after the\nrequest is forwarded. This makes our login schema fail, as we would always\nforward the request to the login servlet if the user has not been authenticated\nyet. Note that optionally we could redirect the page to the login servlet and\nthen redirect it back to the requested page after authentication, however as we\ndon't need any information from the user other than the certificate (already\nsent in SSL handshake), there would be no need for redirection, as it would have\nbeen the case if the user had to type his/her username and password.\n\nWorkaround\n\nA quick fix for this problem is to set the attribute \"again\" in a filter for\neverypage (refer to Solution to understand why):\n\n    public void doFilter(ServletRequest req, ServletResponse res, FilterChain\nchain) throws IOException, ServletException {\n        req.setAttribute(\"javax.servlet.request.X509Certificate\",\nreq.getAttribute(\"javax.servlet.request.X509Certificate\"));\n        chain.doFilter(req, res);\n    }\n\n\nSolution\n\nThe attribute \"javax.servlet.request.X509Certificate\" is set in a Request\nobject. This object is wrapped by a CoyoteRequest object, which is wrapped by\nCoyoteRequestFacade. CoyoteRequestFacade only forwards all calls. CoyoteRequest\nstores attribute sets to this object and getAttribute(String) first looks up on\nits own attribute map and then forward the call to the Request. When the request\nis forwarded, a ApplicationHttpRequest is created as the new request and it's\nwrapped around the CoyoteRequestFacade. The ApplicationHttpRequest works a\nlittle differently, instead of forwarding the calls to get attribute, it copies\nall attributes to its own attribute map, making minor modifications to it (see\nsetRequest(HttpServletRequest)). The problem is that\nCoyoteRequest.getAttributeNames() doesn't take the underlying request into\naccount and return only its own names (which in this case, doesn't include\n\"javax.servlet.request.X509Certificate\").\n    Setting the attribute again, will make CoyoteRequest stores it in its own\nmap and make getAttributeNames() works for this attribute. The fix would be\nsomething like:\n\npublic class CoyoteRequest\n    implements HttpRequest, HttpServletRequest {\n...\n    public Enumeration getAttributeNames() {\n         HashSet keys = new HashSet(this.attributes.keySet());\n         keys.add(Constants.SSL_CERTIFICATE_ATTR);    // Check whether this is\nneeded/right.\n         keys.addAll(this.coyoteRequest.getAttributes().keySet());\n         return (new Enumerator(keys));\n    }\n...\n    public void removeAttribute(String name) {\n        if(attributes.remove(name) == null) {\n              this.coyoteRequest.getAttributes().remove(name);\n          }\n    }\n...\n}\n\n     I would also suggest to add comments to getAttribute(String) advising to\nupdate getAttributeNames() in case of change.\n     Thought: I'm not sure why CoyoteRequest is not using the Request to store\nit's own attributes. The only thing that comes to my mind is that, maybe the\nRequest is being shared with other objects (it's not thread-safe though). If\nthis is the case, removeAttribute(String) would affect all others, so changes\nwould have to be made to that method. If not, wouldn't it just be much easier to\nuse the Request or to not use it at?\n\n\nNOTE: It's the first time I debug Tomcat and report a bug, so I apologize for\nany mistake I might have made. Please, let me know if there is any other\ninformation you need.", "id": 29282, "time": "2003-01-13T16:56:58Z", "bug_id": 16032, "creation_time": "2003-01-13T16:56:58Z", "is_private": false}, {"count": 1, "tags": [], "text": "This is probably fixed in the later 4.1.X versions.\n\nhttp://nagoya.apache.org/bugzilla/show_bug.cgi?id=16032 ", "attachment_id": null, "bug_id": 16032, "id": 38038, "time": "2003-05-30T12:06:23Z", "creator": "funkman@joedog.org", "creation_time": "2003-05-30T12:06:23Z", "is_private": false}]