[{"count": 0, "tags": [], "bug_id": 28541, "text": "JMeter can only measure methods\nin multiplies of 1MS in Linux\nand 10MS in WinXP ...\n\nJMeter measures time between\ncall begining and call end\n\nDue the fact that durring stress \ntesting number of queries migh \nrun about several thousands of \nqueries per second this resolution \nis unsufficient\n\nThis renders JMeter useless for\nstresstesting ...\n\nSolution: Implement alternative\ntimer with better resolution \n(1/100 of second or simmilar)", "id": 56255, "time": "2004-04-22T15:17:58Z", "creator": "beapetrovicova@yahoo.com", "creation_time": "2004-04-22T15:17:58Z", "is_private": false, "attachment_id": null}, {"count": 1, "attachment_id": null, "creator": "woolfel@yahoo.com", "text": "This isn't a bug of JMeter. It is a limitation of JVM implementation. What ever \nmillisecond time the vm returns is the granularity JMeter uses. If you're \nwilling to write a high performance timer, we will gladly use it. This is true \nof many languages and often require writing a timer in C++ to access system \nlevel timers. I know C# has the same problem. The default timer in C# has even \nless granularity than Java. I discovered while stress testing C# applications. \nThere might be an existing timer that is released under BSD license, but I'm \nnot aware of any.", "id": 56263, "time": "2004-04-22T16:43:06Z", "bug_id": 28541, "creation_time": "2004-04-22T16:43:06Z", "tags": [], "is_private": false}, {"count": 2, "tags": [], "bug_id": 28541, "text": "It is still possible to use JMeter to stress test an application without \nknowing the exact times for each individual request.\n\ne.g. by increasing the load to see when the throughput drops or the application \nunder test crashes - or whatever.", "id": 56265, "time": "2004-04-22T17:25:23Z", "creator": "sebb@apache.org", "creation_time": "2004-04-22T17:25:23Z", "is_private": false, "attachment_id": null}, {"count": 3, "tags": [], "bug_id": 28541, "text": "I would second Sebastian statement. Most of the time, the transport of the \npages decreases the throughput of the server. Therefore, unless your server \nhappens to sit at a Level3 facility and all your users are using T3 connections \nor faster, the thread handling the request is going to have to wait until the \nresponse was completely transmitted. At that point, the granularity of the \nserver's response is going to be less than a half second. ", "id": 56266, "time": "2004-04-22T17:32:50Z", "creator": "woolfel@yahoo.com", "creation_time": "2004-04-22T17:32:50Z", "is_private": false, "attachment_id": null}, {"count": 4, "tags": [], "creator": "woolfel@yahoo.com", "attachment_id": null, "text": "changing the status to invalid, since this is the default behavior of Java and \nthe JVM. It is not a JMeter specific bug.", "id": 58863, "time": "2004-06-08T12:49:21Z", "bug_id": 28541, "creation_time": "2004-06-08T12:49:21Z", "is_private": false}]