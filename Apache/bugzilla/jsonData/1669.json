[{"count": 0, "tags": [], "bug_id": 1669, "attachment_id": null, "is_private": false, "id": 2341, "time": "2001-05-08T18:28:16Z", "creator": "joelr@viair.com", "creation_time": "2001-05-08T18:28:16Z", "text": "Environment:\njdk1.2.2 and jdk1.3\n\nSteps to repro:\n1. Create an AsyncAppender.\n2. Add several appenders to it.\n2. Create a for loop for (int i = 0; i < 200000; i++) and call cat.info(o);\n3. At ~104000 logged events, the AsyncAppender enters deadlock.\n\nIt appears to deadlock around:\nsynchronized(container) { --> in AsyncAppender.java\n\nResults:\nVM deadlocks.\n\nExpected:\nVM should log all events without deadlock.\n\nNote: removing the (synchronized(container) code) allows the VM to continue to \ncompletion, but there is some question as to the correctness/consequences of \ndoing this."}, {"count": 1, "tags": [], "bug_id": 1669, "attachment_id": null, "is_private": false, "id": 2342, "time": "2001-05-08T23:00:41Z", "creator": "bugzilla@apache.org", "creation_time": "2001-05-08T23:00:41Z", "text": "\nIndeed. This has been fixed in the latest code in our CVS rep."}, {"count": 2, "tags": [], "creator": "joelr@viair.com", "attachment_id": null, "text": "This is still not fixed.  I downloaded the latest src (1.17) and repeated the \ntest.  It deadlocked at log entry #100115.\n\n", "id": 2357, "time": "2001-05-09T10:16:13Z", "bug_id": 1669, "creation_time": "2001-05-09T10:16:13Z", "is_private": false}, {"count": 3, "tags": [], "bug_id": 1669, "text": "The code doesn't appear to match the comment:\n// The synchronization on parent is necessary to protect against\n// operations on the aai object of the parent\nWhy not just synchronize on the parent's aai object directly if that is the \nsource of contention here.\nAt line #402,\nUse:\n  synchronized(aai) {\nRather than:\n  synchronized(container) {\n\nThe test went to completion using this code.", "id": 2360, "time": "2001-05-09T10:39:39Z", "creator": "joelr@viair.com", "creation_time": "2001-05-09T10:39:39Z", "is_private": false, "attachment_id": null}, {"count": 4, "tags": [], "bug_id": 1669, "attachment_id": null, "id": 2363, "creation_time": "2001-05-09T12:01:25Z", "time": "2001-05-09T12:01:25Z", "creator": "bugzilla@apache.org", "text": "\nI should be fixed now.", "is_private": false}, {"count": 5, "tags": [], "bug_id": 1669, "is_private": false, "text": "I've been looking at the code as part of a research project, and I have some\nquestions about this bug.  Frankly, from the provided information, I don't see\nhow a deadlock would have been possible in the \"unfixed\" code (version 1.17 of \nAsyncAppender.java and 1.28 of Category.java).  The scenario suggested contains\ntwo threads: (1) the main thread that invokes cat.info, and (2) the Dispatcher\nthread from the AsyncAppender.  The first is going to cause the nested\nacquisition of two locks: first the lock on the Category, \"cat,\" and then, via a call to appenderLoopOnAppenders, which in turn calls append on the\nAsyncAppender, the lock on the BoundedFIFO, \"bf,\" used between AsyncAppender\nand the Dispatcher.\n\nThe Dispatcher thread is going to repeatedly acquire the lock \"bf\", get an\nevent, release the lock \"bf,\" and then acquire the lock on the AsyncAppender \nobject, \"aa,\" which it released after invoking appendLoopOnAppenders on its\ndistinct AppenderAttachableImpl object.  \n\nThe changes made between versions 1.17 and 1.18 of AsyncAppender.java just\nalter the lock \"aa\" to have a different identity.  This ought to be irrelevant\nbecause no other entity in the scenario is trying to acquire that lock.\n\nNow, I can imagine that a deadlock could arrise if one of the Appenders\nattached to the AsyncAppender made some callbacks to the original Category or\nthe AsyncAppender object, but none of the standard Appenders appear to do that.\n\nI do not dispute that something went wrong for joelr@viair.com, but I was\nunable to produce a deadlock using the given instructions with version 1.1b5\nof Log4j, and I remain unconvinced that the specific scenario provided can ever\nresult in a deadlock.  I would like to see the testing code joelr@viair.com\nused to determine that the bug was actually fixed by this solution.  I can't\nhelp but thing that something else is as fault, and that it may reemerge at\na later date.\n\n\n", "id": 6555, "time": "2001-10-10T11:28:29Z", "creator": "aarong@cs.cmu.edu", "creation_time": "2001-10-10T11:28:29Z", "attachment_id": null}, {"count": 6, "tags": [], "bug_id": 1669, "attachment_id": null, "text": "  The bug is still open, but it's not a deadlock problem.\n\n  If one SocketAppender attached to the AsyncAppender gets hung, I mean the \nclient get hung or it's waiting for an I/O, then the AsyncAppender gets block \nwhen the queue is full. And that's why main thread gets block.\n\n  The real problem is that AsyncAppender is not totally asynchrous. If the \nqueue is full, the AsyncAppender executes a wait() statement. And because the \ndispacher can obtain a resource (container.aai) and don't free them (if the \nsocket appender is blocked) Then the dispacher gets block, it will never empty \nthe queue, the AsyncAppender gets block, and finally the user thread trying to \nwrite into the AsyncAppender gets block.\n\n  Good luck,\n           Marc", "id": 9647, "time": "2002-01-15T04:08:25Z", "creator": "mcarrion@opfactory.com", "creation_time": "2002-01-15T04:08:25Z", "is_private": false}]