[{"count": 0, "tags": [], "text": "I am trying to connect to a IIS server that has the \"VeriSign Class 3 Public Primary Certification Authority - G5\" root certificate and intermediates. It has been configured to only send the root CA's when the client (httpd) asks for it.\n\nMy Client Certificate was signed by an Intermediate Certificate \"VeriSign Class 3 International Server CA - G3\" which was signed by \"VeriSign Class 3 Public Primary Certification Authority - G5\"\n\nI can manually create the connection with the client certificate using 'openssl s_client' and chat to the sever manually with the same configuration as the VirtualHost.\n\nI have configured my Apache server to ProxySSL our requests to this server.\n\nYet I see 403.7 errors when I try and connect to the server via httpd.\n\nHere is my VirtualHost.\n\n<VirtualHost *:8075>\n  DocumentRoot \"/www/proxy-a.provider/htdocs\"\n  ServerName *:8075\n\n#  LogLevel info\n  LogLevel debug\n  ErrorLog /var/log/www/proxy-a.provider/error_log\n  CustomLog /var/log/www/proxy-a.provider/access_log timed\n\n  <IfModule mod_ssl.c>\n    SSLEngine off\n    SSLProxyEngine on\n    SSLCipherSuite ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP\n    SSLCACertificatePath /www/proxy-a.provider/conf/ssl/CA\n    SSLProxyCACertificatePath /www/proxy-a.provider/conf/ssl/CA\n    SSLProxyMachineCertificateFile /www/proxy-a.provider/conf/ssl/certs/client.crt\n  </IfModule>\n\n\n  <IfModule mod_proxy.c>\n    ProxyRequests    Off\n    RewriteEngine    On\n    RewriteLogLevel  1\n    RewriteLog       /var/log/www/proxy-a.provider/rewrite_log\n\n## Added following line to skip rewrite for error documents.\n    RewriteCond %{REQUEST_URI} !^/error\n    RewriteRule      ^/(.*)$ https://provder.a/$1 [E=SERVER:provder.a,P,L]\n    RewriteRule      .* - [F]\n    ProxyPassReverse / https://provder.a\n  </IfModule>\n</VirtualHost>\n\nThe Debug logs has \n\n[Mon Feb 21 12:32:18 2011] [debug] ssl_engine_kernel.c(1760): OpenSSL: Loop: SSLv3 write client certificate A\n[Mon Feb 21 12:32:18 2011] [debug] ssl_engine_kernel.c(1760): OpenSSL: Loop: SSLv3 write client key exchange A\n[Mon Feb 21 12:32:18 2011] [debug] ssl_engine_kernel.c(1760): OpenSSL: Loop: SSLv3 write change cipher spec A\n[Mon Feb 21 12:32:18 2011] [debug] ssl_engine_kernel.c(1760): OpenSSL: Loop: SSLv3 write finished A\n[Mon Feb 21 12:32:18 2011] [debug] ssl_engine_kernel.c(1760): OpenSSL: Loop: SSLv3 flush data\n[Mon Feb 21 12:32:18 2011] [debug] ssl_engine_kernel.c(1760): OpenSSL: Loop: SSLv3 read server certificate request A\n[Mon Feb 21 12:32:18 2011] [debug] ssl_engine_kernel.c(1760): OpenSSL: Loop: SSLv3 read server done A\n[Mon Feb 21 12:32:18 2011] [debug] ssl_engine_kernel.c(1526): Proxy client certificate callback: (*:8075) entered\n[Mon Feb 21 12:32:18 2011] [debug] ssl_engine_kernel.c(1571): Proxy client certificate callback: (*:8075) no client certificate found!\n\n\nThe Servers Acceptable client certificate CA names as are follows \n\n\n\n/C=US/O=VeriSign, Inc./OU=Class 1 Public Primary Certification Authority - G2/OU=(c) 1998 VeriSign, Inc. - For authorized use only/OU=VeriSign Trust Network\n\n/C=US/O=VeriSign, Inc./OU=Class 4 Public Primary Certification Authority - G2/OU=(c) 1998 VeriSign, Inc. - For authorized use only/OU=VeriSign Trust Network\n\n/C=US/O=VeriSign, Inc./OU=VeriSign Trust Network/OU=(c) 2006 VeriSign, Inc. - For authorized use only/CN=VeriSign Class 3 Public Primary Certification Authority - G5\n\n/C=US/O=VeriSign, Inc./OU=Class 3 Public Primary Certification Authority\n\n\n\n\nThe problem occurs in this code snippit /modules/ssl/ssl_engine_kernel.c  in that it does not check the CA chain higher than just the parent.\n\nint ssl_callback_proxy_cert(SSL *ssl, MODSSL_CLIENT_CERT_CB_ARG_TYPE **x509, EVP_PKEY **pkey)\n{\n    conn_rec *c = (conn_rec *)SSL_get_app_data(ssl);\n    server_rec *s = c->base_server;\n    SSLSrvConfigRec *sc = mySrvConfig(s);\n    X509_NAME *ca_name, *issuer;\n    X509_INFO *info;\n    STACK_OF(X509_NAME) *ca_list;\n    STACK_OF(X509_INFO) *certs = sc->proxy->pkp->certs;\n    int i, j;\n\n    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,\n                 SSLPROXY_CERT_CB_LOG_FMT \"entered\",\n                 sc->vhost_id);\n\n    if (!certs || (sk_X509_INFO_num(certs) <= 0)) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,\n                     SSLPROXY_CERT_CB_LOG_FMT\n                     \"downstream server wanted client certificate \"\n                     \"but none are configured\", sc->vhost_id);\n        return FALSE;\n    }\n\n    ca_list = SSL_get_client_CA_list(ssl);\n\n    if (!ca_list || (sk_X509_NAME_num(ca_list) <= 0)) {\n        /*\n         * downstream server didn't send us a list of acceptable CA certs,\n         * so we send the first client cert in the list.\n         */\n        info = sk_X509_INFO_value(certs, 0);\n\n        modssl_proxy_info_log(s, info, \"no acceptable CA list\");\n\n        modssl_set_cert_info(info, x509, pkey);\n\n        return TRUE;\n    }\n\n    for (i = 0; i < sk_X509_NAME_num(ca_list); i++) {\n        ca_name = sk_X509_NAME_value(ca_list, i);\n\n        for (j = 0; j < sk_X509_INFO_num(certs); j++) {\n            info = sk_X509_INFO_value(certs, j);\n            issuer = X509_get_issuer_name(info->x509);\n\n            if (X509_NAME_cmp(issuer, ca_name) == 0) {\n                modssl_proxy_info_log(s, info, \"found acceptable cert\");\n\n                modssl_set_cert_info(info, x509, pkey);\n\n                return TRUE;\n            }\n        }\n    }\n\n    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s,\n                 SSLPROXY_CERT_CB_LOG_FMT\n                 \"no client certificate found!?\", sc->vhost_id);\n\n    return FALSE;\n}", "attachment_id": null, "bug_id": 50812, "id": 144441, "time": "2011-02-20T22:44:46Z", "creator": "will.dutt+httpd@gmail.com", "creation_time": "2011-02-20T22:44:46Z", "is_private": false}, {"count": 1, "tags": [], "creator": "jorton@redhat.com", "attachment_id": null, "id": 144540, "time": "2011-02-25T12:06:49Z", "bug_id": 50812, "creation_time": "2011-02-25T12:06:49Z", "is_private": false, "text": "The code is working as designed; the IIS server should be configured to send the intermediate G3 CA cert in the list of acceptable CA names in the client cert request."}, {"count": 2, "text": "@Joe Orton:\nThe TLS specification indicates that it's acceptable for the server to simply send a root CA and expect a client CA falling under that root.\n\nSee http://tools.ietf.org/html/rfc5246\n\nSection 7.4.4, in reference to the list of CA names in the client certificate request, provides that\n\"These distinguished names may specify a desired distinguished name for a root CA or for a subordinate CA; thus, this message can be used to describe known roots as well as a desired authorization space.\"\n\nSection 7.4.6, in reference to the client certificate message, provides that \n\"This message conveys the client's certificate chain to the server\"\nand\n\"If the certificate_authorities list in the certificate request message was non-empty, one of the certificates in the certificate chain SHOULD be issued by one of the listed CAs.\"\n\nThese references strongly suggest that the list of acceptable CAs does not need to include every level of the certificate chain; it can simply include the root and let the client determine which certificates ultimately come under that root.\n\nIf searching multiple levels of the certificate chain is too complex, then I recommend as a minimum that the fallback action, when 'ssl_callback_proxy_cert' does not find a client certificate matching any on the acceptable CA list, should be to send the first configured client certificate, as if the acceptable CA list were empty.", "bug_id": 50812, "attachment_id": null, "id": 146236, "time": "2011-05-10T06:57:16Z", "creator": "shell_layer-apachesf@yahoo.com.au", "creation_time": "2011-05-10T06:57:16Z", "tags": [], "is_private": false}, {"count": 3, "tags": [], "creator": "keith@burdis.org", "text": "If we don't want to change the existing behaviour, perhaps an additional ForceSendClientCert option (or similar) could be added to SSLOptions to force sending the first configured client certificate if no acceptable client certs could be found.", "id": 146300, "time": "2011-05-13T09:23:03Z", "bug_id": 50812, "creation_time": "2011-05-13T09:23:03Z", "is_private": false, "attachment_id": null}, {"count": 4, "tags": [], "bug_id": 50812, "attachment_id": null, "text": "I agree with Keith Burdis\n\nPlease add ForceSendClientCert option (or similar)  to SSLOptions", "id": 146438, "time": "2011-05-19T01:06:03Z", "creator": "will.dutt+httpd@gmail.com", "creation_time": "2011-05-19T01:06:03Z", "is_private": false}, {"count": 5, "tags": [], "creator": "chicagozer@comcast.net", "attachment_id": null, "id": 148669, "time": "2011-08-17T20:27:01Z", "bug_id": 50812, "creation_time": "2011-08-17T20:27:01Z", "is_private": false, "text": "Hit this problem today too. I'm all for any solution that let's us force send the Client Certificate. It looks like the code is already setup to do this in the absence of any CAs coming from the server side."}, {"count": 6, "tags": [], "text": "Hello;\n   The following patches should add a new directive. The file should contain all intermediary CA's used by all of your clients. On init, a chain for each certificate will be created and mod_proxy will use that chain if it finds an issuing name that is not a direct signer of a client cert.\n\nI have tested and confirmed this works on Linux for configurations using one or more client certificate with a chain to one or more different root CA's\n  http://people.apache.org/~druggeri/patches/httpd-2.2.19-SSLProxyMachineCertificateChainFile.patch\n  http://people.apache.org/~druggeri/patches/httpd-trunk-SSLProxyMachineCertificateChainFile.patch\n\nFWIW, the trunk patch has been applied.", "is_private": false, "bug_id": 50812, "id": 148791, "time": "2011-08-23T20:07:39Z", "creator": "DRuggeri@primary.net", "creation_time": "2011-08-23T20:07:39Z", "attachment_id": null}, {"count": 7, "tags": [], "creator": "DRuggeri@primary.net", "text": "The SSLProxyMachineCertificateChainFile directive new in 2.2.22 addresses this problem.", "id": 167138, "time": "2013-05-10T21:26:59Z", "bug_id": 50812, "creation_time": "2013-05-10T21:26:59Z", "is_private": false, "attachment_id": null}]