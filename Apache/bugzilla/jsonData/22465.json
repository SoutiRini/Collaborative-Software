[{"count": 0, "tags": [], "creator": "sandman2012@rambler.ru", "attachment_id": null, "is_private": false, "id": 42812, "time": "2003-08-15T16:27:43Z", "bug_id": 22465, "creation_time": "2003-08-15T16:27:43Z", "text": "If we use fixed row height than at the end of the page cells in pdf are broken \nand some information is lost. The cells is layed on the page even its height \nis greater than space left on the page.\n\nI have the following solution: add these lines in the layout(Area area) \nfunction of org.apache.fop.fo.flow.TableRow.java\n        if (minHeight > spaceLeft)\n            return Status.AREA_FULL_NONE;\n\nComplete file:\n/*\n * -- $Id: TableRow.java,v 1.51.2.9 2002/12/01 11:55:56 klease Exp $ --\n * Copyright (C) 2001 The Apache Software Foundation. All rights reserved.\n * For details on use and redistribution please refer to the\n * LICENSE file included with these sources.\n */\n\npackage org.apache.fop.fo.flow;\n\n// FOP\nimport org.apache.fop.fo.*;\nimport org.apache.fop.fo.properties.*;\nimport org.apache.fop.datatypes.*;\nimport org.apache.fop.layout.*;\nimport org.apache.fop.apps.FOPException;\n\n// Java\nimport java.util.ArrayList;\n\npublic class TableRow extends FObj {\n\n    public static class Maker extends FObj.Maker {\n        public FObj make(FObj parent,\n                         PropertyList propertyList) throws FOPException {\n            return new TableRow(parent, propertyList);\n        }\n\n    }\n\n    public static FObj.Maker maker() {\n        return new TableRow.Maker();\n    }\n\n    boolean setup = false;\n\n    int breakAfter;\n    String id;\n\n    KeepValue keepWithNext;\n    KeepValue keepWithPrevious;\n    KeepValue keepTogether;\n\n    int widthOfCellsSoFar = 0;\n    int largestCellHeight = 0;\n    int minHeight = 0;    // force row height\n    ArrayList columns;\n\n    AreaContainer areaContainer;\n\n    boolean areaAdded = false;\n    \n    boolean bIgnoreKeepTogether = false;\n    \n    private RowSpanMgr rowSpanMgr = null;\n    private CellArray cellArray = null;\n\n    private static class CellArray {\n        public static final byte EMPTY = 0;\n        public static final byte CELLSTART = 1;\n        public static final byte CELLSPAN = 2;\n\n        private TableCell[] cells;\n        private byte[] states;\n\n        public CellArray(RowSpanMgr rsi, int numColumns) {\n            // Initialize the cell array by marking any cell positions\n            // occupied by spans from previous rows\n            cells = new TableCell[numColumns];\n            states = new byte[numColumns];\n            for (int i = 0; i < numColumns; i++) {\n                if (rsi.isSpanned(i + 1)) {\n                    cells[i] = rsi.getSpanningCell(i + 1);\n                    states[i] = CELLSPAN;\n                } else\n                    states[i] = EMPTY;\n            }\n        }\n\n        /**\n         * Return column which doesn't already contain a span or a cell\n         * If past the end or no free cells after colNum, return -1\n         * Otherwise return value >= input value.\n         */\n        int getNextFreeCell(int colNum) {\n            for (int i = colNum - 1; i < states.length; i++) {\n                if (states[i] == EMPTY)\n                    return i + 1;\n            }\n            return -1;\n        }\n\n\n        /**\n         * Return type of cell in colNum (1 based)\n         */\n        int getCellType(int colNum) {\n            if (colNum > 0 && colNum <= cells.length) {\n                return states[colNum - 1];\n            } else\n                return -1;    // probably should throw exception\n        }\n\n        /**\n         * Return cell in colNum (1 based)\n         */\n        TableCell getCell(int colNum) {\n            if (colNum > 0 && colNum <= cells.length) {\n                return cells[colNum - 1];\n            } else\n                return null;    // probably should throw exception\n        }\n\n        /**\n         * Store cell starting at cellColNum (1 based) and spanning numCols\n         * If any of the columns is already occupied, return false, else true\n         */\n        boolean storeCell(TableCell cell, int colNum, int numCols) {\n            boolean rslt = true;\n            int index = colNum - 1;\n            for (int count = 0; index < cells.length && count < numCols;\n                    count++, index++) {\n                if (cells[index] == null) {\n                    cells[index] = cell;\n                    states[index] = (count == 0) ? CELLSTART : CELLSPAN;\n                } else {\n                    rslt = false;\n                    // print a message but continue!!!\n                }\n            }\n            return rslt;\n        }\n    }\n\n\n    public TableRow(FObj parent, PropertyList propertyList)\n        throws FOPException {\n        super(parent, propertyList);\n        if (!(parent instanceof AbstractTableBody)) {\n            throw new FOPException(\"A table row must be child of fo:table-\nbody,\"\n                                   + \" fo:table-header or fo:table-footer, \nnot \"\n                                   + parent.getName());\n        }\n    }\n\n    public String getName() {\n        return \"fo:table-row\";\n    }\n\n    public void setColumns(ArrayList columns) {\n        this.columns = columns;\n    }\n\n    public KeepValue getKeepWithPrevious() {\n        return keepWithPrevious;\n    }\n\n    public void doSetup(Area area) throws FOPException {\n\n        // Common Accessibility Properties\n        AccessibilityProps mAccProps = propMgr.getAccessibilityProps();\n            \n        // this.properties.get(\"block-progression-dimension\");\n\n        // Common Aural Properties\n        AuralProps mAurProps = propMgr.getAuralProps();\n\n        // Common Border, Padding, and Background Properties\n        // only background apply, border apply if border-collapse\n        // is collapse.\n        BorderAndPadding bap = propMgr.getBorderAndPadding();\n        BackgroundProps bProps = propMgr.getBackgroundProps();\n\n        // Common Relative Position Properties\n        RelativePositionProps mRelProps = propMgr.getRelativePositionProps();\n                    \n        // this.properties.get(\"break-before\");\n        // this.properties.get(\"break-after\");\n        // this.properties.get(\"id\");\n        // this.properties.get(\"height\");\n        // this.properties.get(\"keep-together\");\n        // this.properties.get(\"keep-with-next\");\n        // this.properties.get(\"keep-with-previous\");\n\n\n        this.breakAfter = this.properties.get(\"break-after\").getEnum();\n\n        this.keepTogether = getKeepValue(\"keep-together.within-column\");\n        this.keepWithNext = getKeepValue(\"keep-with-next.within-column\");\n        this.keepWithPrevious =\n            getKeepValue(\"keep-with-previous.within-column\");\n\n        this.id = this.properties.get(\"id\").getString();\n        this.minHeight = this.properties.get(\"height\").getLength().mvalue();\n        setup = true;\n    }\n\n    private KeepValue getKeepValue(String sPropName) {\n        Property p = this.properties.get(sPropName);\n        Number n = p.getNumber();\n        if (n != null)\n            return new KeepValue(KeepValue.KEEP_WITH_VALUE, n.intValue());\n        switch (p.getEnum()) {\n        case Constants.ALWAYS:\n            return new KeepValue(KeepValue.KEEP_WITH_ALWAYS, 0);\n        // break;\n        case Constants.AUTO:\n        default:\n            return new KeepValue(KeepValue.KEEP_WITH_AUTO, 0);\n        // break;\n        }\n    }\n\n    public int layout(Area area) throws FOPException {\n        if (this.marker == BREAK_AFTER) {\n            return Status.OK;\n        }\n\n        // Layout the first area for this FO\n        if (this.marker == START) {\n            if (!setup)\n                doSetup(area);\n\n                // Only do this once. If the row is \"thrown\" and we start\n                // layout over again, we can skip this.\n            if (cellArray == null) {\n                initCellArray();\n                // check to make sure this row hasn't been partially\n                // laid out yet (with an id created already)\n            }\n            // create ID also in case the row has been reset\n            area.getIDReferences().createID(id);\n\n            this.marker = 0;\n            int breakStatus = propMgr.checkBreakBefore(area);\n            if (breakStatus != Status.OK)\n                return breakStatus;\n        }\n\n        if (marker == 0) {    // KDL: need to do this if thrown or if split?\n            // configure id\n            area.getIDReferences().configureID(id, area);\n        }\n\n        int spaceLeft = area.spaceLeft();\n\n        this.areaContainer =\n            new AreaContainer(propMgr.getFontState(area.getFontInfo()), 0, 0,\n                              area.getContentWidth(), spaceLeft,\n                              Position.RELATIVE);\n        areaContainer.foCreator = this;    // G Seshadri\n        areaContainer.setPage(area.getPage());\n        areaContainer.setParent(area);\n\n        areaContainer.setBackground(propMgr.getBackgroundProps());\n        areaContainer.start();\n\n        areaContainer.setAbsoluteHeight(area.getAbsoluteHeight());\n        areaContainer.setIDReferences(area.getIDReferences());\n\n        largestCellHeight = minHeight;\n\n        if (minHeight > spaceLeft)\n            return Status.AREA_FULL_NONE;\n        // Flag indicaing whether any cell didn't fit in available space\n        boolean someCellDidNotLayoutCompletely = false;\n\n        /*\n         * If it takes multiple calls to completely layout the row,\n         * we need to process all of the children (cells)\n         * not just those from the marker so that the borders\n         * will be drawn properly.\n         */\n        int offset = 0;       // Offset of each cell from table start edge\n        int iColIndex = 0;    // 1-based column index\n        /*\n         * Ideas: set offset on each column when they are initialized\n         * no need to calculate for each row.\n         * Pass column object to cell to get offset and width and border\n         * info if borders are \"collapsed\".\n         */\n        for (int i = 0; i < columns.size(); i++) {\n            TableCell cell;\n            ++iColIndex;\n            TableColumn tcol = (TableColumn)columns.get(i);\n            int colWidth = tcol.getColumnWidth();\n            if (cellArray.getCellType(iColIndex) == CellArray.CELLSTART) {\n                cell = cellArray.getCell(iColIndex);\n            } else {\n                /*\n                 * If this cell is spanned from a previous row,\n                 * and this is the last row, get the remaining height\n                 * and use it to increase maxCellHeight if necessary\n                 */\n                if (rowSpanMgr.isInLastRow(iColIndex)) {\n                    int h = rowSpanMgr.getRemainingHeight(iColIndex);\n                    if (h > largestCellHeight)\n                        largestCellHeight = h;\n                }\n                offset += colWidth;\n                continue;\n            }\n            // cell.setTableColumn(tcol);\n            cell.setStartOffset(offset);\n            offset += colWidth;\n\n\n            int rowSpan = cell.getNumRowsSpanned();\n            int status;\n            if (Status.isIncomplete((status = cell.layout(areaContainer)))) {\n               if ((keepTogether.getType() == KeepValue.KEEP_WITH_ALWAYS && \nbIgnoreKeepTogether==false)\n                        || (status == Status.AREA_FULL_NONE)\n                        || rowSpan > 1) {\n                    // We will put this row into the next column/page\n                    // Note: the only time this shouldn't be honored is\n                    // if this row is at the top of the column area.\n                    // Remove spanning cells from RowSpanMgr?\n                    this.resetMarker();\n                    this.removeID(area.getIDReferences());\n                    return Status.AREA_FULL_NONE;\n                } else if (status == Status.AREA_FULL_SOME) {\n                    /*\n                     * Row is not keep-together, cell isn't spanning\n                     * and part of it fits. We can break the cell and\n                     * the row.\n                     */\n                    someCellDidNotLayoutCompletely = true;\n                }\n            }                            // else {\n             // layout was complete for a particular cell\n            int h = cell.getHeight();    // allocation height of cell\n            if (rowSpan > 1) {           // pass cell fo or area???\n                rowSpanMgr.addRowSpan(cell, iColIndex,\n                                      cell.getNumColumnsSpanned(), h,\n                                      rowSpan);\n            } else if (h > largestCellHeight) {\n                largestCellHeight = h;\n            }\n            // }\n        }                                // end of loop over all columns/cells\n\n        // This is in case a float was composed in the cells\n        area.setMaxHeight(area.getMaxHeight() - spaceLeft\n                          + this.areaContainer.getMaxHeight());\n\n        // Only do this for \"STARTCELL\", ending spans are handled separately\n        // What about empty cells? Yes, we should set their height too!\n        for (int iCol = 1; iCol <= columns.size(); iCol++) {\n            if (cellArray.getCellType(iCol) == CellArray.CELLSTART\n                    && rowSpanMgr.isSpanned(iCol) == false) {\n                cellArray.getCell(iCol).setRowHeight(largestCellHeight);\n            }\n        }\n\n        // Adjust spanning row information\n        // ??? what if some cells are broken???\n        rowSpanMgr.finishRow(largestCellHeight);\n\n        area.addChild(areaContainer);\n        areaContainer.setHeight(largestCellHeight);\n        areaAdded = true;\n        areaContainer.end();\n\n        /*\n         * The method addDisplaySpace increases both the content\n         * height of the parent area (table body, head or footer) and\n         * also its \"absolute height\". So we don't need to do this\n         * explicitly.\n         *\n         * Note: it doesn't look from the CR as though we should take\n         * into account borders and padding on rows, only background.\n         * The exception is perhaps if the borders are \"collapsed\", but\n         * they should still be rendered only on cells and not on the\n         * rows themselves. (Karen Lease - 01may2001)\n         */\n        area.addDisplaySpace(largestCellHeight\n                             + areaContainer.getPaddingTop()\n                             + areaContainer.getBorderTopWidth()\n                             + areaContainer.getPaddingBottom()\n                             + areaContainer.getBorderBottomWidth());\n\n\n        // replaced by Hani Elabed 11/27/2000\n        // return new Status(Status.OK);\n\n        if (someCellDidNotLayoutCompletely) {\n            return Status.AREA_FULL_SOME;\n        } else {\n            if (rowSpanMgr.hasUnfinishedSpans()) {\n                // Ignore break after if row span!\n                return Status.KEEP_WITH_NEXT;\n            }\n            if (breakAfter == BreakAfter.PAGE) {\n                this.marker = BREAK_AFTER;\n                return Status.FORCE_PAGE_BREAK;\n            }\n\n            if (breakAfter == BreakAfter.ODD_PAGE) {\n                this.marker = BREAK_AFTER;\n                return Status.FORCE_PAGE_BREAK_ODD;\n            }\n\n            if (breakAfter == BreakAfter.EVEN_PAGE) {\n                this.marker = BREAK_AFTER;\n                return Status.FORCE_PAGE_BREAK_EVEN;\n            }\n\n            if (breakAfter == BreakAfter.COLUMN) {\n                this.marker = BREAK_AFTER;\n                return Status.FORCE_COLUMN_BREAK;\n            }\n            if (keepWithNext.getType() != KeepValue.KEEP_WITH_AUTO) {\n                return Status.KEEP_WITH_NEXT;\n            }\n            return Status.OK;\n        }\n\n    }\n\n    public int getAreaHeight() {\n        return areaContainer.getHeight();\n    }\n\n    public void removeLayout(Area area) {\n        if (areaAdded) {\n            area.removeChild(areaContainer);\n            areaAdded = false;\n        }\n        this.resetMarker();\n        this.removeID(area.getIDReferences());\n    }\n\n    public void resetMarker() {\n        super.resetMarker();\n        // Just reset all the states to not laid out and fix up row spans\n    }\n\n    /**\n     * Called by parent FO to initialize information about\n     * cells started in previous rows which span into this row.\n     * The layout operation modifies rowSpanMgr\n     */\n    public void setRowSpanMgr(RowSpanMgr rowSpanMgr) {\n        this.rowSpanMgr = rowSpanMgr;\n    }\n\n    /**\n     * Before starting layout for the first time, initialize information\n     * about spanning rows, empty cells and spanning columns.\n     */\n    private void initCellArray() {\n        cellArray = new CellArray(rowSpanMgr, columns.size());\n        int colNum = 1;\n        for (int i = 0; i< children.size(); i++) {\n            colNum = cellArray.getNextFreeCell(colNum);\n            // If off the end, the rest of the cells had better be\n            // explicitly positioned!!! (returns -1)\n\n            TableCell cell = (TableCell)children.get(i);\n            int numCols = cell.getNumColumnsSpanned();\n            int numRows = cell.getNumRowsSpanned();\n            int cellColNum = cell.getColumnNumber();\n\n            if (cellColNum == 0) {\n                // Not explicitly specified, so put in next available colummn\n                // cell.setColumnNumber(colNum);\n                // If cellColNum \"off the end\", this cell is in limbo!\n                if (colNum < 1) {\n                    // ERROR!!!\n                    continue;\n                } else\n                    cellColNum = colNum;\n            } else if (cellColNum > columns.size()) {\n                // Explicit specification out of range!\n                // Skip it and print an ERROR MESSAGE\n                continue;\n            }\n            // see if it fits and doesn't overwrite anything\n            if (cellColNum + numCols - 1 > columns.size()) {\n                // MESSAGE: TOO MANY COLUMNS SPANNED!\n                numCols = columns.size() - cellColNum + 1;\n            }\n            // Check for overwriting other cells (returns false)\n            if (cellArray.storeCell(cell, cellColNum, numCols) == false) {\n                // Print out some kind of warning message.\n            }\n            if (cellColNum > colNum) {\n                // Cells are initialized as empty already\n                colNum = cellColNum;\n            } else if (cellColNum < colNum) {\n                // MESSAGE ? cells out of order?\n                colNum = cellColNum;    // CR \"to the letter\"!\n            }\n            int cellWidth = getCellWidth(cellColNum, numCols);\n            cell.setWidth(cellWidth);\n            colNum += numCols;          // next cell in this column\n        }\n    }\n\n    // ATTENTION if startCol + numCols > number of columns in table!\n    private int getCellWidth(int startCol, int numCols) {\n        int width = 0;\n        for (int count = 0; count < numCols; count++) {\n            width += ((TableColumn)columns.get(startCol + count\n                                                     - 1)).getColumnWidth();\n        }\n        return width;\n    }\n    \n    void setIgnoreKeepTogether(boolean bIgnoreKeepTogether) {\n        this.bIgnoreKeepTogether = bIgnoreKeepTogether;\n    }\n\n}"}, {"count": 1, "tags": [], "creator": "pascal.sancho@takoma.fr", "attachment_id": null, "is_private": false, "id": 110762, "time": "2007-11-20T00:33:28Z", "bug_id": 22465, "creation_time": "2007-11-20T00:33:28Z", "text": "Fixed in FOP 0.94 and probably earlier versions"}, {"count": 2, "tags": [], "bug_id": 22465, "text": "batch transition pre-FOP1.0 resolved+fixed bugs to closed+fixed", "id": 155671, "time": "2012-04-01T06:34:38Z", "creator": "gadams@apache.org", "creation_time": "2012-04-01T06:34:38Z", "is_private": false, "attachment_id": null}]