[{"count": 0, "tags": [], "creator": "bjkail@gmail.com", "text": "ThreadLocal$ThreadLocalMap weakly references keys but strongly references values.  However, it appears the checkThreadLocalMapForLeaks checking reports false positives if the key is a ThreadLocal subclass (e.g., anonymous class) but the value does not strongly reference the class loader (e.g., Integer, int[], List<SimpleDateFormatter>, etc.).  Example output:\n\n07-Mar-2016 11:27:08.258 SEVERE [localhost-startStop-2] org.apache.catalina.loader.WebappClassLoaderBase.checkThreadLocalMapForLeaks The web application [servlettest-0.1] created a ThreadLocal with key of type [servlettest.TestServlet$1] (value [servlettest.TestServlet$1@40d92399]) and a value of type [java.lang.Integer] (value [1]) but failed to remove it when the web application was stopped. Threads are going to be renewed over time to try and avoid a probable memory leak.\n\nFor large web applications with many such false positives, this output makes tracking down (or even noticing new) real issues more difficult.  Third party libraries refuse to adjust their use of ThreadLocal because they believe (IMO rightly) their code is not causing leaks.  I have read bug 50175 comment 6, but given that the current heuristic has false positives, can some compromise be reached?  Perhaps some configuration for stifling the warning on a per key class name basis could be added?  It would even be acceptable for us if that configuration hid the per-instance message but issued a single overall \"suppressing N ThreadLocal warnings based on config\" info/warning message.", "id": 189221, "time": "2016-03-07T17:48:07Z", "bug_id": 59138, "creation_time": "2016-03-07T17:48:07Z", "is_private": false, "attachment_id": null}, {"count": 1, "tags": [], "creator": "markt@apache.org", "text": "The situation described is a memory leak.\n\nThe problem is not the value but the anonymous class. It is loaded by the web application class loader. That pins the web application class loader in memory creating the memory leak.\n\nThe Tomcat code has been carefully written to avoid false positives. Tomcat checks the implementing class of the key and the value and if either of them have been loaded by the web application class loader then there is a memory leak and it will be reported. \n\nThe current code errs on the side of false negatives. It is possible to construct a memory leak that this code won't spot but, given how the code is written, a false positive could only occur as a result of a bug. There has been no such bug reported in the previous 5+ years that this code has been in place in this form (I could have gone back further but 5 years seem long enough to make my point).\n\nIf you see a warning, it is extremely likely that you have a memory leak.\n\nIf a 3rd-party library believes Tomcat is falsely reporting a false positive for a ThreadLocal that that library creates and it has been checked with a profiler that the implementing classes for both the key and the value have not been loaded by the web application class loader (or a child class loader) then I'll happily take a look and fix any bug. But experience tells me that it is far more likely that the library does have a memory leak.", "id": 189227, "time": "2016-03-07T20:19:06Z", "bug_id": 59138, "creation_time": "2016-03-07T20:19:06Z", "is_private": false, "attachment_id": null}, {"count": 2, "tags": [], "bug_id": 59138, "attachment_id": null, "text": "And for the record while I was 99% sure just from reading the description what the problem was I did go to the trouble of building a simple test case and confirming the memory leak with a profiler.", "id": 189228, "time": "2016-03-07T20:20:10Z", "creator": "markt@apache.org", "creation_time": "2016-03-07T20:20:10Z", "is_private": false}, {"count": 3, "tags": [], "bug_id": 59138, "attachment_id": null, "id": 189241, "time": "2016-03-07T21:37:18Z", "creator": "bjkail@gmail.com", "creation_time": "2016-03-07T21:37:18Z", "is_private": false, "text": "Entries in ThreadLocalMap weakly reference the key, which is the ThreadLocal subclass that is loaded by the application class loader.  Assuming there are no other retained references to the application class loader, the JVM will clear this weak reference at the next GC.  This is basically the same as a WeakHashMap, and the javadoc there describes the same semantics: in order for the entry to be cleared, you need to ensure the value does not refer to the key.  Assuming the ThreadLocal subclass is held in a static variable (common case), that means the value must not reference anything that directly/indirectly references the application class loader.  In this case, the value refers to the bootstrap class loader only, so the ThreadLocal entry does not pin the application class loader.\n\nI cannot reproduce a memory leak, but I can reproduce the false positive:\n\n1.  Start an empty Tomcat instance (no webapps)\n2.  Use jvisualvm, collect a heapdump, run the \"select x from org.apache.catalina.loader.WebappClassLoader x\" OQL, and see \"The query returned no results\" (baseline)\n3.  Deploy a WAR that contains a servlet with a static ThreadLocal subclass, and have the doGet method set the ThreadLocal to an integer.\n5.  Use jvisualvm again, and see there is one class loader\n6.  Ping the servlet so that the ThreadLocal is loaded\n7.  Undeploy the WAR, and see the checkThreadLocalMapForLeaks message\n8.  Use jvisualvm again, and see there are no class loaders\n\nIn this case, the message is a false positive.  The presence of the ThreadLocal does not prevent the class loader from being garbage collected.  However, if I change step #3 to set the ThreadLocal to the servlet instance itself, then I see the class loaders accumulate as I repeat this process.\n\nAre you able to reproduce these steps?  Can you provide more details on what you did to create the memory leak?"}, {"count": 4, "tags": [], "creator": "markt@apache.org", "text": "Hmm. The profiler was showing the key as strongly reachable. That explains why it wasn't collected but not why it was strongly reachable. Let me take another look at the results.", "id": 189242, "time": "2016-03-07T22:53:03Z", "bug_id": 59138, "creation_time": "2016-03-07T22:53:03Z", "is_private": false, "attachment_id": null}, {"count": 5, "text": "I still had the memory dump so I was able to confirm that the key was strongly reachable.\n\nThere were a number of GC roots listed of which one was the ThreadLocal map. Digging into the GC roots found the problem. Somehow (and I haven't figured out how to reproduce this yet) one of the profiler's classes was loaded by the WebappClassLoader. That was pinning the class loader in memory hence the ThreadLocal key was strongly held.\n\nI'm as sure as I can be that this is what I was seeing previously. If I run the test all the way through then attach the profiler (rather than attaching at the start so I can monitor what is going on) then the key is not strongly held, the garbage collector does it's job after which the class loader is released.\n\nI am therefore re-opening this issue.\n\nAt first glance, the fix appears to be as simple as removing the class loader check for the ThreadLocal key.\n\nHowever, we have had issues reported where objects being retained after web application stop until the next GC has been sufficient to cause problems. If memory serves me correctly, those were all JDBC related. In this case, I don't think that will be an issue. Currently, ThreadLocal issues are cleaned up by renewing the thread pool and that won't change with the proposed change. All that changes is that keys won't trigger the warning messages.\n\nWe could log issues with keys at debug level on the grounds that users might find it useful. That will complicate the code though. I'm not sure that is worth doing. I'll think about it over night and come back to this tomorrow.", "bug_id": 59138, "attachment_id": null, "id": 189246, "time": "2016-03-07T23:51:17Z", "creator": "markt@apache.org", "creation_time": "2016-03-07T23:51:17Z", "tags": [], "is_private": false}, {"count": 6, "tags": [], "bug_id": 59138, "attachment_id": null, "id": 189263, "time": "2016-03-08T14:24:49Z", "creator": "chris@christopherschultz.net", "creation_time": "2016-03-08T14:24:49Z", "is_private": false, "text": "(In reply to Mark Thomas from comment #5)\n>\n> However, we have had issues reported where objects being retained after web\n> application stop until the next GC has been sufficient to cause problems. If\n> memory serves me correctly, those were all JDBC related. In this case, I\n> don't think that will be an issue. Currently, ThreadLocal issues are cleaned\n> up by renewing the thread pool and that won't change with the proposed\n> change. All that changes is that keys won't trigger the warning messages.\n> \n> We could log issues with keys at debug level on the grounds that users might\n> find it useful. That will complicate the code though. I'm not sure that is\n> worth doing. I'll think about it over night and come back to this tomorrow.\n\nI think a downgrade from SEVERE to ... something else is appropriate. Maybe not as low as DEBUG; perhaps INFO? AFAIK, there's no way for Java code to ask the JVM if a reference is only strongly reachable from a particular root (e.g. the ThreadLocalMap itself), so there's no way for Tomcat to prove that the application-loaded ThreadLocal can be collected after the ClassLoader is (otherwise) free. So there is certainly ample opportunity for a memory leak, here, and users should be notified about it."}, {"count": 7, "tags": [], "creator": "markt@apache.org", "text": "This has been fixed in 9.0.x for 9.0.0.M4 onwards, 8.0.x for 8.0.33 onwards, 7.0.x for 7.0.69 onwards and 6.0.x for 6.0.46 onwards.\n\nI have down-graded this to DEBUG. After the 'fun' with the profiler I've double checked this and also confirmed that the JRE implementation is fundamentally the same. There is no chance of a memory leak just because the key for a ThreadLocal was loaded by the web application.\n\nThe logging is only useful and will only serve its intended purpose (fixing memory leaks) if it is accurate. Logging non-issues at anything above debug is just going to annoy people.", "id": 189274, "time": "2016-03-08T20:18:29Z", "bug_id": 59138, "creation_time": "2016-03-08T20:18:29Z", "is_private": false, "attachment_id": null}]