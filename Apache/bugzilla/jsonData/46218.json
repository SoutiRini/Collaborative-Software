[{"count": 0, "attachment_id": null, "creator": "mike@vee.net", "is_private": false, "id": 122524, "time": "2008-11-15T18:41:49Z", "bug_id": 46218, "creation_time": "2008-11-15T18:41:49Z", "tags": [], "text": "When running Xindice using the shipped copy of Jetty (and probably any kind of servlet container that installs its own shutdown hook), a race exists on shutdown which can lead to deadlock.\n\nUsing the xindice script to stop a running instances sends a TERM to the JVM, thus causing all hooks registered with Runtime.addShutdownHook() to be executed. Both Xindice and Jetty register hooks - DatabaseShutdownHandler and in org.mortbay.jetty.Server respectively.\n\nDeadlock occurs in at least this situation: Jetty's shutdown hook thread starts running, calls XindiceServlet.destroy(), which calls Database.close(boolean) on an instance, synchronizing on that instance. DatabaseShutdownHandler's thread starts running and synchronizes on its set of databases. Jetty's thread in Database.close(boolean) calls DatabaseShutdownHandler.removeDatabase(), tries to also synchronize on the handler's set of instances but is blocked, since the handler has already done so. The handler tries to synchronize on the Database instance, but is blocked since the Jetty thread has already done so. Bam! Deadlock.\n\nThere may be other orderings of operations that exhibit the same problem.\n\nI'm seeing this once in every 10-20 shutdowns on a RHEL 5 box w/ Java 1.6.0_07.\n\nThis can be worked-around by disabling Jetty's shutdown hook, for example, by passing \"-DJETTY_NO_SHUTDOWN_HOOK=true\" as an argument to the JVM on startup, but that could be problematic if any requests are in progress on shutdown.\n\nDisabling Xindice's handler would probably be the correct thing to do when running embedded in a servlet container that reliably manages its own lifecycle, but this does not appear possible without with code changes.\n\nA fix might be to add a synchronized shutdown() method somewhere that both XindiceServlet and DatabaseShutdownHandler can call, thus ensuring that only one can enter it at a time, and obviating the problem of both trying to do so at the same time."}, {"count": 1, "tags": [], "creator": "mike@vee.net", "attachment_id": null, "id": 122525, "time": "2008-11-15T18:45:03Z", "bug_id": 46218, "creation_time": "2008-11-15T18:45:03Z", "is_private": false, "text": "I should note that this is can cause data loss, since the deadlock occurs before the database instance is actually closes."}, {"count": 2, "tags": [], "bug_id": 46218, "is_private": false, "id": 122526, "creation_time": "2008-11-15T20:43:06Z", "time": "2008-11-15T20:43:06Z", "creator": "vgritsenko@apache.org", "text": "Thanks for the detailed bug report. I think it might be better just to change synchronization sequence in Database.close(); so i went ahead and changed it in r717978 on trunk. Would you mind testing it on your system? Thanks.", "attachment_id": null}, {"attachment_id": null, "tags": [], "bug_id": 46218, "text": "I can't test it out right now since I had to put that machine back into production for use tomorrow (Monday AEST).\n\nTo reproduce, on a reasonably fast dual-core machine, just continually start and stop Xindice. I was effectively doing:\n\nwhile true; do\n   xindiced start\n   sleep 5\n   xindice ld -c /db/some/10k+collection\n   xindice stop\n   sleep 5\ndone\n\nIf this is still a problem, you'll see instances of xindice slowly piling up. New ones can start even though the old ones are hanging around since the Jetty handler will have stopped it listening on whatever port is is configured to do so.\n\nNote this might also indicate the \"db.lock\" database lock mechanism isn't actually functioning.\n\nWhat are the odds of this getting applied to 1.1 and having a 1.1.1 release? I don't want to move to 1.2 on this machine yet.", "count": 3, "id": 122531, "time": "2008-11-16T04:52:19Z", "creator": "mike@vee.net", "creation_time": "2008-11-16T04:52:19Z", "is_private": false}]