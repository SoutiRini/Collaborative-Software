[{"count": 0, "tags": [], "bug_id": 9305, "attachment_id": null, "id": 16525, "time": "2002-05-22T06:41:13Z", "creator": "starksm@starkinternational.com", "creation_time": "2002-05-22T06:41:13Z", "is_private": false, "text": "The current use of Class.forName in classes like \norg.apache.log4j.xml.DOMConfigurator restrict flexibility of how appenders, \nfilters, etc. may be loaded into the VM. When used in an application server \nthis forces all dynamcially loaded objects to be in the same classpath \nnamespace that loaded the log4j.jar. There is no drawback to using the thread \ncontext class loader instance of Class.forName and there are many advantages."}, {"count": 1, "tags": [], "bug_id": 9305, "attachment_id": null, "id": 16528, "time": "2002-05-22T07:12:26Z", "creator": "starksm@starkinternational.com", "creation_time": "2002-05-22T07:12:26Z", "is_private": false, "text": "There is one drawback to accessing the thread context class loader. It is a \nprivaledged operation that can result in a SecurityException. The same \nflexibility can be achieved by allowing one to set the ClassLoader the \nconfigurator uses to load classes. Then the caller can decide to use the\nthread context class loader or whatever loader they choose."}, {"count": 2, "tags": [], "bug_id": 9305, "attachment_id": null, "is_private": false, "id": 16531, "time": "2002-05-22T08:29:23Z", "creator": "ceki@apache.org", "creation_time": "2002-05-22T08:29:23Z", "text": "\nScott,\n\nI'm on this. Will reply fully in 30 minutes.\n\n--\nCeki"}, {"count": 3, "tags": [], "bug_id": 9305, "attachment_id": null, "is_private": false, "id": 16532, "time": "2002-05-22T09:22:45Z", "creator": "ceki@apache.org", "creation_time": "2002-05-22T09:22:45Z", "text": "Scott,\n\nThis what I started writing:\n\n--- BEGIN ----------------\nThe following is from the docs/HISTORY file\n\n  Release of log4j-1.2beta4\n\n  - Replaced the custom class loading based on the thread context class\n    loader with a simple Class.forName() call. This solves two allied\n    but distinct problems encountered when using Ant with JUnit\n    although the bug is more general. In one instance of the\n    problem, log4j would throw java.lang.NoClassDefFoundError for\n    org/apache/log4j/AppenderSkeleton where log4j.jar and related\n    classes were clearly available to the Ant classloader. In another\n    incarnation, log4j would reject a custom appender claiming that it is\n    not assignable to a org.apache.log4j.Appender variable. This would\n    occur when log4j.jar was available to both the Ant classloader and the\n    system classloader. \n    \n    Thanks to Dave Herman for providing detailed scenarios exposing\n    the issues involved. See\n      http://forum.java.sun.com/thread.jsp?forum=38&thread=70946\n      http://forum.java.sun.com/thread.jsp?forum=38&thread=70946#479697\n      http://marc.theaimsgroup.com/?l=ant-user&m=101139178705895&w=2\n    for more details. [*]\n\nIn conclusion, while loading classes through the context class loader\nhas advantages, it also has disadvantages. I would like to learn more\nabout the exact scenario you are confronted with before making a\ndecision. Moreover, please be more specific about the \"many\nadvantages\" you see.\n\n--- END ---------------------\n\nThen I started reading the discussion threads on forum.java.sun.com to\ncheck whether the fix in log4j-1.2beta4 still made sense. (Until\nlog4j-1.2beta4, alpha and beta versions of log4j used the context\nclass loader.)\n\nFortunately, I also had test cases reproducing the issues that Dave\nHerman had observed. In one scenario, log4j-1.2beta2.jar was available\nto the ANT class loader but not to the system class loader. Still in\nthe same scenario, a custom appender, named foo.MyAppender, would be\navailable to system class loader but not to the ANT class loader.\n\nIn this scenario, running a simple test case that tried to configure\nlog4j by instantiating foo.MyAppender and adding it to the root logger\nwould fail with the following error.\n\njunit:\n    [junit] Running foo.junit.MyTestCase\n    [junit] Tests run: 1, Failures: 0, Errors: 1, Time elapsed: 0.05 sec\n    [junit] Output:\n    [junit] debug: Test case <= org.apache.tools.ant.AntClassLoader\n    [junit] debug: Thread context <= sun.misc.Launcher$AppClassLoader\n    [junit]\n    [junit] Testsuite: foo.junit.MyTestCase\n    [junit] Tests run: 1, Failures: 0, Errors: 1, Time elapsed: 0.05 sec\n    [junit] ------------- Standard Output ---------------\n    [junit] debug: Test case <= org.apache.tools.ant.AntClassLoader\n    [junit] debug: Thread context <= sun.misc.Launcher$AppClassLoader\n    [junit] ------------- ---------------- ---------------\n    [junit]\n    [junit] Testcase: testCustomAppender took 0.04 sec\n    [junit]     Caused an ERROR\n    [junit] org/apache/log4j/AppenderSkeleton\n    [junit] java.lang.NoClassDefFoundError: org/apache/log4j/AppenderSkeleton\n    [junit]     at java.lang.ClassLoader.defineClass0(Native Method)\n  <snip>\n    [junit]     at java.security.AccessController.doPrivileged(Native Method)\n    [junit]     at java.net.URLClassLoader.findClass(URLClassLoader.java:188)\n    [junit]     at java.lang.ClassLoader.loadClass(ClassLoader.java:297)\n    [junit]     at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:286)\n    [junit]     at java.lang.ClassLoader.loadClass(ClassLoader.java:253)\n    [junit]     at org.apache.log4j.helpers.Loader.loadClass(Loader.java:124)\n    [junit]     at \norg.apache.log4j.helpers.OptionConverter.instantiateByClassName\n(OptionConverter.java:313)\n    [junit]     at org.apache.log4j.helpers.OptionConverter.instantiateByKey\n(OptionConverter.java:116)\n    [junit]     at org.apache.log4j.PropertyConfigurator.parseAppender\n(PropertyConfigurator.java:619)\n  <snip>\n\nSo AppenderSkeleton could not be found because log4j-1.2beta2.jar was\nnot available to the system class loader and as no context class loader\nwas set, the context class loader used defaulted to the system\nclass loader.\n\nAs I said previously, changing log4j code to use only Class.forName\nfor class loading solves the above problem since both\nlog4j-1.2beta2.jar and foo.MyAppender are available to the ANT\nclass loader and its parent the system class loader.\n\nIn the original scenario that Dave Herman had in mind, both the system\nclass loader and the ANT class loader had log4j-1.2beta2.jar available\nto them but only the system class loader had foo.MyAppender\navailable. Running this would result in the following error:\n\njunit:\n    [junit] Running foo.junit.MyTestCase\n    [junit] Tests run: 1, Failures: 1, Errors: 0, Time elapsed: 0.05 sec\n    [junit] Error:\n    [junit] debug: Test case <= org.apache.tools.ant.AntClassLoader\n    [junit] debug: Thread context <= sun.misc.Launcher$AppClassLoader\n    [junit] log4j:ERROR A \"foo.MyAppender\" object is not assignable to \na \"org.apache.log4j.Appender\" variable.\n    [junit] log4j:ERROR Could not instantiate appender named \"Foo\".\n     <snip>\n\nIn this case, log4j refused to use foo.MyAppender because it was not\nassignable to o.a.log4j.Appender. This can be explained by the fact\nthat log4j's copy of o.a.log4j.Appender was loaded by the ANT class\nloader whereas the foo.MyAppender was loaded by the system class\nloader. \n\nSimply ignoring the context loader and using only Class.forName also\nfixed this scenario.\n\nSo I was \"tricked\" into thinking that Class.forName was the way to\ngo. What I did not realize was that there was a bug in our\nimplementation of o.a.log4j.helpers.Loader.loadClass() method which\nwas ultimately responsible to loading classes.\n\nThe implementation was:\n\n /**\n     Load the specified class using the <code>Thread</code>\n     <code>contextClassLoader</code> if running under Java2 or current\n     class loader if running under JDK 1.1.\n  */\n  static\n  public \n  Class loadClass (String clazz) throws ClassNotFoundException {\n    if(java1) {\n      return Class.forName(clazz);\n    } else {\n      try {\n\treturn Thread.currentThread().getContextClassLoader().loadClass(clazz);\n      } catch(Exception e) {\n\t// we reached here because\n\t// currentThread().getContextClassLoader() is null or because\n\t// of a security exceptio, or because clazz could not be\n\t// loaded, in any case we now try one more time\n\treturn Class.forName(clazz);\n      }\n    }\n  } \n\nThis implementation is sub optimal first because it does not compile\nwith JDK 1.1 and more importantly because it is buggy. The\njava.lang.NoClassDefFoundError (see first scenario above) is not an\nException but an Error. This means that the code within the catch\nblock will never be executed. \n\nChanging the Loader.loadClass code to\n\n  static\n  public \n  Class loadClass (String clazz) throws ClassNotFoundException {\n    if(java1) {\n      return Class.forName(clazz);\n    } else {\n      try {\n\treturn Thread.currentThread().getContextClassLoader().loadClass(clazz);\n      } catch(Throwable e) {  // <-- was originally Exception\n\treturn Class.forName(clazz);\n      }\n    }\n  } \n}\n\nsolves the problem encountered in scenario one. It does not solve the\nproblem encountered in the second scenario.\n\nMore generally, if log4j-XX.jar is available to both the context class\nloader as well as to the class loader that loaded the code currently\nbeing executed, then a log4j component (e.g. an appender) may be\nloaded by the context class loader such that it is incompatible with\nthe log4j classes loaded by the class loader that loaded the code\ncurrently being executed.\n\nHow far fetched is this scenario? Well, I am almost convinced that\nsomeone will come up with a case where it looks perfectly legitimate.\n\nTo make a long story short, I still would like to learn more about the\nexact scenario you are confronted with before making a decision.\n"}, {"count": 4, "tags": [], "creator": "starksm@starkinternational.com", "is_private": false, "text": "My response is that there is no need to choose Class.forName or the TCL. Simply\nadd a setClassLoader(ClassLoader loader) method to the configurator and then it \nis the framework user's choice of how the framework integrates with its usage \ncontext class loading policy. Default the configurator loader to getClass\n().getClassLoader() and there is no change in behavior by default.\n\nAs to examples of where Class.forName fails:\n1. Bootstrap a minimal app server with a minimal configuration with the \nlog4j.jar in the classpath\n2. Load the full app server configuration from a remote web server. This \nincludes an extended log4j configuration and any number of filters, appenders, \netc. that are loaded by the URLClassLoader associated with the web server. This \nis a child of the class loader used during the bootstrap and so its classes are \nnot visible to Class.forName invocations made from the log4j.jar classes.\n", "id": 16534, "time": "2002-05-22T09:35:48Z", "bug_id": 9305, "creation_time": "2002-05-22T09:35:48Z", "attachment_id": null}, {"count": 5, "tags": [], "creator": "ceki@apache.org", "is_private": false, "text": "> My response is that there is no need to choose Class.forName or the\n> TCL. Simply add a setClassLoader(ClassLoader loader) method to the\n> configurator and then it is the framework user's choice of how the\n> framework integrates with its usage context class loading\n> policy. Default the configurator loader to getClass\n> ().getClassLoader() and there is no change in behavior by default.\n\nSounds very reasonable.\n \n> As to examples of where Class.forName fails: 1. Bootstrap a minimal\n> app server with a minimal configuration with the log4j.jar in the\n> classpath 2. Load the full app server configuration from a remote web\n> server. This includes an extended log4j configuration and any number\n> of filters, appenders, etc. that are loaded by the URLClassLoader\n> associated with the web server. This is a child of the class loader\n> used during the bootstrap and so its classes are not visible to\n> Class.forName invocations made from the log4j.jar classes.\n\nIf I undestand correctly, the bootstrap server will load a simple\nlog4j config, create a URLClassLoader, and reconconfigure log4j with a\nmore sophisticated configuration loaded by the URLClassLoader.  Is\nthat correct?\n\nNow, assuming the TCL was set to the URLClassLoader, if log4j\nconfigurators used the TCL to load and instantiate classes by name,\nthis would also work for you. Yes?\n\nThus, we have three alternatives.\n\n1) Log4j configurators use the class loader specified by the user, as\nyou just suggested.\n\n2) Log4j configurators use the TCL as a first alternative and only\nthen Class.forName.\n\n3) Use the CL specified by the user. If none is specified, revert to\n2.\n\nI am inclined to offer just 2 immediately and 3 at a later\nstage. Would that be good enough for you?\n", "id": 16535, "time": "2002-05-22T10:35:02Z", "bug_id": 9305, "creation_time": "2002-05-22T10:35:02Z", "attachment_id": null}, {"count": 6, "tags": [], "bug_id": 9305, "attachment_id": null, "is_private": false, "id": 16556, "time": "2002-05-22T16:00:48Z", "creator": "starksm@starkinternational.com", "creation_time": "2002-05-22T16:00:48Z", "text": "Option 2 works fine as I can just as easily ensure the TCL is correct."}, {"count": 7, "tags": [], "creator": "ceki@apache.org", "is_private": false, "text": "\nNo news, good news. Closing the report.", "id": 17502, "time": "2002-06-10T17:31:08Z", "bug_id": 9305, "creation_time": "2002-06-10T17:31:08Z", "attachment_id": null}]