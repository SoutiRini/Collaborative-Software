[{"count": 0, "tags": [], "creator": "Gerd.Castan@z.zgs.de", "is_private": false, "text": "Hi,\n\nI get a ClassCastException on\nMac OS X 10.1 (with the update that fixes the famous String.equals() bug)\nI don't think that the OS is relevant.\n\njava.lang.ClassCastException: \norg.apache.xerces.validators.dtd.DTDGrammar\n\tat \norg.apache.xerces.validators.schema.TraverseSchema.traverseAttributeG\nroupDeclFromAnotherSchema(TraverseSchema.java:6410)\n\tat \norg.apache.xerces.validators.schema.TraverseSchema.traverseAttributeG\nroupDecl(TraverseSchema.java:6329)\n\tat \norg.apache.xerces.validators.schema.TraverseSchema.processAttributes\n(TraverseSchema.java:4410)\n\tat \norg.apache.xerces.validators.schema.TraverseSchema.processComplex\nContent(TraverseSchema.java:4376)\n\tat \norg.apache.xerces.validators.schema.TraverseSchema.traverseComplex\nContentDecl(TraverseSchema.java:3950)\n\tat \norg.apache.xerces.validators.schema.TraverseSchema.traverseComplex\nTypeDecl(TraverseSchema.java:3401)\n\tat \norg.apache.xerces.validators.schema.TraverseSchema.traverseComplex\nTypeDecl(TraverseSchema.java:3258)\n\tat \norg.apache.xerces.validators.schema.TraverseSchema.doTraverseSche\nma(TraverseSchema.java:740)\n\tat org.apache.xerces.validators.schema.TraverseSchema.<init>\n(TraverseSchema.java:541)\n\tat \norg.apache.xerces.validators.common.XMLValidator.resolveSchemaGra\nmmar(XMLValidator.java:2783)\n\tat \norg.apache.xerces.validators.common.XMLValidator.parseSchemas(XML\nValidator.java:2669)\n\tat \norg.apache.xerces.validators.common.XMLValidator.bindNamespacesTo\nElementAndAttributes(XMLValidator.java:2551)\n\tat \norg.apache.xerces.validators.common.XMLValidator.callStartElement(XM\nLValidator.java:1152)\n\tat \norg.apache.xerces.framework.XMLDocumentScanner.scanElement(XML\nDocumentScanner.java:1806)\n\tat \norg.apache.xerces.framework.XMLDocumentScanner$ContentDispatcher\n.dispatch(XMLDocumentScanner.java:949)\n\tat \norg.apache.xerces.framework.XMLDocumentScanner.parseSome(XMLDo\ncumentScanner.java:381)\n\tat org.apache.xerces.framework.XMLParser.parse(XMLParser.java:1081)\n\tat \nde.gerdcastan.fsc.parserAdapter.SAXParserFacade.getSAXFSC(SAXPars\nerFacade.java:174)\n\tat de.gerdcastan.fsc.tables.TablesFacade.load(TablesFacade.java:229)\n\tat de.gerdcastan.fsc.basic.FSCFacade.loadTables(FSCFacade.java:101)\n\tat de.gerdcastan.fsc.Explorer.<init>(Explorer.java:37)\n\tat Main.main(Main.java:12)\n\tat java.lang.reflect.Method.invoke(Native Method)\n\tat com.apple.buckyball.app.LaunchRunner.run(LaunchRunner.java:91)\n\tat java.lang.Thread.run(Thread.java:496)\n\nThe example where this exception appears is absolutely work in \nprogress.  The validated instance shouldn't have to do anything with the \nschema. Xerces should report that it isn't a valid instance.\n\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<!DOCTYPE tables SYSTEM \"FSC.DTD\">\n<tables></tables>\n\n\nSchema:\n\n<xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\n            targetNamespace=\"http://www.gerdcastan.de/MusiXML\"\n            xmlns:MusiXML=\"http://www.gerdcastan.de/MusiXML\">\n\n<!-- \t\t\txmlns:xml=\"http://www.w3.org/XML/1998/namespace\"  -->\n\n\n<!-- update 11. April 2000: key/keyref example for stRef \n\tupdate 16. April 2000: included MFraction and Duration, added some \nattribute defaults.\n     20010902 extract must start with a bibdata element that describes for \nwhich part/instrument \n              this extract is intended. Example: Violin 1 or Score\n     20010904 removed lines from thRef. lines in staff is enough.\n     20010904 removed voice from thRef. If something human readable is \nnecesary, make it language independant\n     20010907 replaced t by tm, tn, td. My Java application had no problem, \nbut avoiding microparsing makes MusiXML XSLT friendly\n     20010907 same vor staff.start\n     20010908 replaced level by breakLevel\n     20010908 resetPageNo\n     20010910 extractId\n     20011016 changed syntax to xml schema 1.0;\n     20011016 changed xml:lang to lang until I get it running with Xerces\n\n-->\n\n<!--\n<xsd:import namespace=\"http://www.w3.org/XML/1998/namespace\" \nschemaLocation=\"http://www.w3.org/2001/xml.xsd\"/>\n<xsd:attributeGroup name=\"xml-atts\">\n\t<xsd:attribute ref=\"xml:lang\"/>\n\t<xsd:attribute ref=\"xml:space\"/>\n</xsd:attributeGroup> \n-->\n\n<!-- Bug: If you derive a complexType B from A and B has an attribute with \na default, then\nall Typed derived from A return this default as an attribute. This happens \nseveral times \n-->\n\n<!-- oracle schema parser doesn't like annotations:\n<xsd:annotation>\n\t<xsd:documentation>\n\tMusiXML schema v0.9 for music notation.\n\tExperimental implementation\n\tCopyright 1999 - 2000 Gerd Castan.\n\t</xsd:documentation>\n</xsd:annotation>\n-->\n<!-- XXX the src attribute in an stRef element has to refer to a unique staff \nelement.\n\tIt was not possible to express this in a DTD with ID/IDREF:\n\n\tstRef.src -> staff.id\n\tthRef.src -> thread.id\n\tbracket.start -> staff.id\n\tbracket.end -> staff.id\n\tconRef.src -> con.id\n\tlasting.tupletID -> tuplet.id (elements derived from lasting: chord and \nnote)\n\tlasting.beam -> beam.id (elements derived from lasting: chord and note)\n\tbarRef.barID -> bar.id\n\tslur.left -> note.id\n\tslur.right -> note.id\n\t\n\tI will use key/keyref pairs for this, but this means that I have to drop the\n\tID/IDREF mechanism in the DTD, too.\n\t\n\tSee the stRef key below.\n-->\n\n<!-- main hierarchy: use anonymous types where elements are used only \nonce -->\n<xsd:element name=\"work\">\n\t<xsd:complexType>\n\t<xsd:complexContent>\n\t<xsd:extension base=\"core\">\n\t<xsd:sequence>\n\t\t<xsd:element ref=\"bibdata\" minOccurs=\"0\" />\n\n\t\t<xsd:element name=\"body\" minOccurs=\"1\" maxOccurs=\"1\" >\n\t\t\t<xsd:complexType>\n\t        <xsd:complexContent>\n\t\t\t<xsd:extension base=\"core\">\n\t\t\t<xsd:sequence>\n\t\t\t\t<xsd:element name=\"workSeg\" minOccurs=\"1\">\n\t\t\t\t\t<xsd:complexType>\n        \t        <xsd:complexContent>\n\t\t\t\t\t<xsd:extension base=\"core\">\n\t\t\t\t\t<xsd:sequence>\n\t\t\t\t\t\t<xsd:element name=\"masterThread\" minOccurs=\"1\" maxOccurs=\"1\">\n\t\t\t\t\t\t\t<!-- time dependant elements that occur only once per score -->\n\t\t\t\t\t\t\t<!-- and influence each extract -->\n\t\t\t\t\t\t\t<xsd:complexType>\n\t\t        \t        <xsd:complexContent>\n\t\t\t\t\t\t\t<xsd:extension base=\"core\">\n\t\t\t\t\t\t\t\t<xsd:choice maxOccurs=\"unbounded\">\n\t\t\t\t\t\t\t\t\t<xsd:element ref=\"masterSymbol\" />  <!-- abstract -->\n\t\t\t\t\t\t\t\t\t<xsd:element ref=\"sharedSymbol\" />  <!-- abstract -->\n\t\t\t\t\t\t\t\t</xsd:choice>\n\t\t\t\t\t\t\t</xsd:extension>\n\t\t        \t        </xsd:complexContent>\n\t\t\t\t\t\t\t</xsd:complexType>\n\t\t\t\t\t\t</xsd:element>\n\t\t\t\t\t\t<!-- A program in LISP ;-) uses the word \"Musician\" for a similar (not \nexactly the same) thing. -->\n\t\t\t\t\t\t<xsd:element name=\"thread\" minOccurs=\"1\" maxOccurs=\n\"unbounded\">\n\t\t\t\t\t\t\t<xsd:complexType>\n\t\t        \t        <xsd:complexContent>\n\t\t\t\t\t\t\t<xsd:extension base=\"core\">\n\t\t\t\t\t\t\t\t<xsd:choice maxOccurs=\"unbounded\">\n\t\t\t\t\t\t\t\t\t<xsd:element ref=\"threadSymbol\" />  <!-- abstract -->\n\t\t\t\t\t\t\t\t\t<xsd:element ref=\"sharedSymbol\" />  <!-- abstract -->\n\t\t\t\t\t\t\t\t</xsd:choice>\n\t\t\t\t\t\t\t</xsd:extension>\n\t\t        \t        </xsd:complexContent>\n\t\t\t\t\t\t\t</xsd:complexType>\n\t\t\t\t\t\t</xsd:element> <!-- thread -->\n\t\t\t\t\t</xsd:sequence>\n\t\t\t\t\t</xsd:extension>\n        \t        </xsd:complexContent>\n\t\t\t\t\t</xsd:complexType>\n\t\t\t\t</xsd:element> <!-- workSeg -->\n\t\t\t</xsd:sequence>\n\t\t\t</xsd:extension>\n\t        </xsd:complexContent>\n\t\t\t</xsd:complexType>\n\t\t</xsd:element> <!-- body -->\n\n\t\t<xsd:element name=\"filter\" minOccurs=\"1\" maxOccurs=\"1\" >\n\t\t\t<xsd:complexType>\n\t\t    <xsd:complexContent>\n\t\t\t<xsd:extension base=\"core\">\n\t\t\t<xsd:sequence>\n\n\t\t\t\t<xsd:element name=\"extract\" minOccurs=\"0\" maxOccurs=\"unbounded\" \n>\n\t\t\t\t\t<xsd:complexType>\n\t\t\t\t    <xsd:complexContent>\n\t\t\t\t\t<xsd:extension base=\"core\">\n\t\t\t\t\t<xsd:sequence>\n\t\t\t\t\t\t<xsd:element ref=\"bibdata\" minOccurs=\"1\"/>\n\t\t\t\t\t\t<xsd:element name=\"paragraph\" minOccurs=\"1\" maxOccurs=\n\"unbounded\" >\n\t\t\t\t\t\t\t<xsd:complexType>\n\t\t\t\t\t\t    <xsd:complexContent>\n\t\t\t\t\t\t\t<xsd:extension base=\"core\">\n\t\t\t\t\t\t\t<xsd:sequence>\n\t\t\t\t\t\t\t\t<xsd:element ref=\"bibdata\" minOccurs=\"0\" maxOccurs=\"1\" />\n\t\t\t\t\t\t\t\t<xsd:element name=\"bracket\" minOccurs=\"0\" maxOccurs=\"1\">\n\t\t\t\t\t\t\t\t\t<xsd:complexType>\n\t\t\t\t\t\t\t\t    <xsd:complexContent>\n\t\t\t\t\t\t\t\t\t<xsd:extension base=\"core\">\n\t\t\t\t\t\t\t\t\t\t<xsd:attribute name=\"type\" type=\"xsd:string\"  />   <!-- XXX (bracket|\nbrace)    \"bracket\"  -->\n\t\t\t\t\t\t\t\t\t\t<xsd:attribute name=\"start\" type=\"xsd:IDREF\" use=\"required\" />\n\t\t\t\t\t\t\t\t\t\t<xsd:attribute name=\"end\" type=\"xsd:IDREF\" use=\"required\"  />\n\t\t\t\t\t\t\t\t\t</xsd:extension>\n\t\t\t\t\t\t\t\t\t</xsd:complexContent>\n\t\t\t\t\t\t\t\t\t</xsd:complexType>\n\t\t\t\t\t\t\t\t</xsd:element>\n\t\t\t\t\t\t\t\t<xsd:element name=\"break\" minOccurs=\"0\" maxOccurs=\n\"unbounded\">\n\t\t\t\t\t\t\t\t\t<xsd:complexType>\n\t\t\t\t\t\t\t\t    <xsd:complexContent>\n\t\t\t\t\t\t\t\t\t<xsd:extension base=\"core\">\n\t\t\t\t\t\t\t\t\t\t<xsd:attribute name=\"breakLevel\" type=\"xsd:NMTOKEN\" />   <!-- XXX \n(dontBreak|lineBreak|pageBreak)    \"lineBreak\"  -->\n\t\t\t\t\t\t\t\t\t\t<xsd:attribute name=\"resetPageNo\" type=\"xsd:integer\" /> \n\t\t\t\t\t\t\t\t\t\t<xsd:attribute name=\"man_pg\" type=\"xsd:integer\" /> \n\t\t\t\t\t\t\t\t\t\t<xsd:attribute name=\"man_ln\" type=\"xsd:integer\" /> \n\t\t\t\t\t\t\t\t\t\t<xsd:attribute name=\"aut_pg\" type=\"xsd:integer\" /> \n\t\t\t\t\t\t\t\t\t\t<xsd:attribute name=\"aut_ln\" type=\"xsd:integer\" /> \n\t\t\t\t\t\t\t\t\t</xsd:extension>\n\t\t\t\t\t\t\t\t\t</xsd:complexContent>\n\t\t\t\t\t\t\t\t\t</xsd:complexType>\n\t\t\t\t\t\t\t\t</xsd:element>\n\t\t\t\t\t\t\t\t<xsd:element name=\"stRef\" minOccurs=\"0\" maxOccurs=\n\"unbounded\">\n\t\t\t\t\t\t\t\t\t<xsd:complexType>\n\t\t\t\t\t\t\t\t    <xsd:complexContent>\n\t\t\t\t\t\t\t\t\t<xsd:extension base=\"core\">\n\t\t\t\t\t\t\t\t\t\t<xsd:attribute name=\"src\" type=\"xsd:IDREF\" use=\"required\"  />\n\t\t\t\t\t\t\t\t\t</xsd:extension>\n\t\t\t\t\t\t\t\t\t</xsd:complexContent>\n\t\t\t\t\t\t\t\t\t</xsd:complexType>\n\t\t\t\t\t\t\t\t</xsd:element>\n\t\t\t\t\t\t\t</xsd:sequence>\n\t\t\t\t\t\t\t\t<xsd:attribute name=\"type\" type=\"xsd:string\" use=\"required\"  /> \n\t\t\t\t\t\t\t</xsd:extension>\n\t\t\t\t\t\t\t</xsd:complexContent>\n\t\t\t\t\t\t\t</xsd:complexType>\n\t\t\t\t\t\t</xsd:element>\n\t\t\t\t\t</xsd:sequence>\n\n\t\t\t\t\t\t<xsd:attribute name='extractId' type=\"xsd:NMTOKEN\" use=\"required\"/>\n\t\t\t\t\t</xsd:extension>\n\t\t\t\t\t</xsd:complexContent>\n\t\t\t\t\t</xsd:complexType>\n\t\t\t\t</xsd:element> <!-- extract -->\n\t\t\t\t\n\t\t\t\t<xsd:element name=\"staff\" minOccurs=\"0\" maxOccurs=\"unbounded\" >\n\t\t\t\t\t<xsd:complexType>\n\t\t\t\t    <xsd:complexContent>\n\t\t\t\t\t<xsd:extension base=\"core\">\n\t\t\t\t\t<xsd:sequence>\n\t\t\t\t\t\t<xsd:element name=\"thRef\" minOccurs=\"0\" maxOccurs=\"unbounded\" \n>\n\t\t\t\t\t\t\t<xsd:complexType>\n\t\t\t\t\t\t    <xsd:complexContent>\n\t\t\t\t\t\t\t<xsd:extension base=\"core\">\n\t\t\t\t\t\t\t\t<xsd:attribute name=\"src\" type=\"xsd:IDREF\" use=\"required\"  /> \n\t\t\t\t\t\t\t\t<xsd:attribute name=\"stem\" type=\"xsd:NMTOKEN\" /> <!-- XXX (auto|\nup|down)     \"auto\" -->\n\t\t\t\t\t\t\t</xsd:extension>\n\t\t\t\t\t\t\t</xsd:complexContent>\n\t\t\t\t\t\t\t</xsd:complexType>\n\t\t\t\t\t\t</xsd:element>\n\t\t\t\t\t\t<xsd:element name=\"conRef\" minOccurs=\"0\" maxOccurs=\n\"unbounded\" >\n\t\t\t\t\t\t\t<xsd:complexType>\n\t\t\t\t\t\t    <xsd:complexContent>\n\t\t\t\t\t\t\t<xsd:extension base=\"Con\">\n\t\t\t\t\t\t\t\t<xsd:attribute name=\"src\" type=\"xsd:IDREF\" use=\"required\"  /> \n\t\t\t\t\t\t\t</xsd:extension>\n\t\t\t\t\t\t\t</xsd:complexContent>\n\t\t\t\t\t\t\t</xsd:complexType>\n\t\t\t\t\t\t</xsd:element>\n\t\t\t\t\t</xsd:sequence>\n\t\t\t\t\t\t<xsd:attribute name=\"name\" type=\"xsd:NMTOKEN\" /> <!-- new key, \nreplacement for id in DTD -->\n\t\t\t\t\t</xsd:extension>\n\t\t\t\t    </xsd:complexContent>\n\t\t\t\t\t</xsd:complexType>\n\t\t\t\t</xsd:element> <!-- staff -->\n\t\t\t</xsd:sequence>\n\t\t\t</xsd:extension>\n\t\t    </xsd:complexContent>\n\t\t\t</xsd:complexType>\n\n\t\t\t<key name=\"stRef\">\n\t\t\t\t<selector>extract/staff</selector>\n\t\t\t\t<field>@name</field>\n\t\t\t</key>\n\t\t\t<keyref refer=\"stRef\">\n\t\t\t\t<selector>extract/paragraph/stRef</selector>\n\t\t\t\t<field>@src</field>\n\t\t\t</keyref>\n\t\t\t<key name=\"extractRef\">\n\t\t\t\t<selector>extract</selector>\n\t\t\t\t<field>@extractId</field>\n\t\t\t</key>\n\t\t\t\n\t\t</xsd:element> <!-- filter -->\n\t</xsd:sequence>\n\t</xsd:extension>\n\t</xsd:complexContent>\n\t</xsd:complexType>\t\n\n</xsd:element> <!-- work -->\n\n\n\n<!-- ======================================================\n=========================== -->\n<!--core type                                                                          -->\n<!-- ======================================================\n=========================== -->\n\n<!-- everything but localText is derived by core -->\n<xsd:complexType name=\"core\">\n\t<xsd:attribute name=\"lang\" />\n\t<xsd:attribute name=\"id\" type=\"xsd:ID\" />\n</xsd:complexType>\n\n\n\n<!-- ======================================================\n=========================== -->\n<!-- types                                                                             -->\n<!-- ======================================================\n=========================== -->\n\n<!-- everything child of masterThread and thread is derived by \nmomentOfTime -->\n<xsd:complexType name=\"momentOfTime\">\n<xsd:complexContent>\n<xsd:extension base=\"core\">\n\t<xsd:attribute name=\"tm\" type=\"xsd:short\" /> \n\t<xsd:attribute name=\"tn\" type=\"xsd:short\" /> \n\t<xsd:attribute name=\"td\" type=\"xsd:short\" /> \n</xsd:extension>\n</xsd:complexContent>\n</xsd:complexType>\n\n<!-- Duration\n\tfirst number: enumerator (1 if omitted)\n\tsecond number: denominator (4 if omitted)\n\tdots: number of dots\n-->\n<xsd:simpleType name=\"Duration\">\n\t<xsd:restriction base=\"xsd:string\">\n    \t<xsd:pattern value=\"[0-9]*(:[0-9]*)?\\.*\"/>\n\t</xsd:restriction>\n</xsd:simpleType>\n\n<!-- XXX chord and note are derived by lasting -->\n<xsd:complexType name=\"lasting\">\n<xsd:complexContent>\n<xsd:extension base=\"momentOfTime\">\n\t<xsd:attribute name=\"dots\" type=\"xsd:integer\" />   <!-- XXX restrict -->\n\t<xsd:attribute name=\"dur\" type=\"MusiXML:Duration\" />\n\t<xsd:attribute name=\"tupletID\" type=\"xsd:IDREF\" />  <!-- XXX referential \nintegrity --> \n\t<xsd:attribute name=\"beam\" type=\"xsd:IDREF\" />  <!-- XXX referential \nintegrity --> \n\t<xsd:attribute name=\"leftBeams\" type=\"xsd:integer\" />   \n\t<xsd:attribute name=\"rightBeams\" type=\"xsd:integer\" />   \n\t<xsd:attribute name=\"abbrev\" type=\"xsd:integer\" />   \n\t<!-- XXX articulation -->\n\t<xsd:attributeGroup ref=\"articulation\" />\n</xsd:extension>\n</xsd:complexContent>\n</xsd:complexType>\n\n<!-- articulation:\n     staccato=\"1\" finger1=\"2\" means the first sign above the note is a \nstaccato point \n     and the second is a \"1\" (finger 1). The same holds with negative \nnumbers under\n     the note. \n     Exception: numtonguing is the number of points whereas tonguing \nindicates the \n     position of these tonguing points. \n  -->\n<xsd:attributeGroup name=\"articulation\">\n\t<xsd:attribute name=\"strongaccent\" type=\"xsd:integer\" />   \n\t<xsd:attribute name=\"mediumaccent\" type=\"xsd:integer\" />   \n\t<xsd:attribute name=\"portato\" type=\"xsd:integer\" />   \n\t<xsd:attribute name=\"staccato\" type=\"xsd:integer\" />   \n\t<xsd:attribute name=\"downbow\" type=\"xsd:integer\" />   \n\t<xsd:attribute name=\"upbow\" type=\"xsd:integer\" />   \n\t<xsd:attribute name=\"harmonic\" type=\"xsd:integer\" />   \n\t<xsd:attribute name=\"fermata\" type=\"xsd:integer\" />   \n\t<xsd:attribute name=\"arsis\" type=\"xsd:integer\" />   \n\t<xsd:attribute name=\"thesis\" type=\"xsd:integer\" />   \n\t<xsd:attribute name=\"plus\" type=\"xsd:integer\" />   \n\t<xsd:attribute name=\"staccatissimo\" type=\"xsd:integer\" />   \n\t<xsd:attribute name=\"tonguing\" type=\"xsd:integer\" />   \n\t<xsd:attribute name=\"numtonguing\" type=\"xsd:integer\" />   \n\t<xsd:attribute name=\"pizzicato\" type=\"xsd:integer\" />   \n\t<xsd:attribute name=\"finger1\" type=\"xsd:integer\" />   \n\t<xsd:attribute name=\"finger2\" type=\"xsd:integer\" />   \n\t<xsd:attribute name=\"finger3\" type=\"xsd:integer\" />   \n\t<xsd:attribute name=\"finger4\" type=\"xsd:integer\" />   \n\t<xsd:attribute name=\"finger5\" type=\"xsd:integer\" />   \n</xsd:attributeGroup>\n\n<!-- Bar is used for elements bar and barRef -->\n<xsd:complexType name=\"Bar\">\n<xsd:complexContent>\n<xsd:extension base=\"momentOfTime\">\n\t<xsd:attribute name=\"type\">\n\t\t<simpleType>\n\t\t\t<xsd:restriction base=\"xsd:NMTOKEN\">\n\t\t\t\t<enumeration value=\"standard\"/>\n\t\t\t\t<enumeration value=\"invisible\"/>\n\t\t\t\t<enumeration value=\"tactus\"/>\n\t\t\t\t<enumeration value=\"double\"/>\n\t\t\t\t<enumeration value=\"fat\"/>\n\t\t\t\t<enumeration value=\"fatthin\"/>\n\t\t\t</xsd:restriction>\n\t\t</simpleType>\n\t</xsd:attribute>\n\n\t<xsd:attribute name=\"type\" type=\"xsd:NMTOKEN\" />\n\t<xsd:attribute name=\"leftRepeat\" type=\"xsd:integer\" />\n\t<xsd:attribute name=\"rightRepeat\" type=\"xsd:integer\" />\n\t<xsd:attribute name=\"count\" type=\"boolean\" />\n</xsd:extension>\n</xsd:complexContent>\n</xsd:complexType>\n\n\n<xsd:complexType name=\"Con\">\n<xsd:complexContent>\n<xsd:extension base=\"momentOfTime\">\n\t<xsd:attribute name=\"vis\" type=\"xsd:NMTOKEN\" />    <!-- XXX (nothing|clef|\nkey) -->\n\t<xsd:attribute name=\"cname\" type=\"xsd:string\" />\n\t<xsd:attribute name=\"coct\" type=\"xsd:NMTOKEN\" />   <!-- XXX (S|s|K|g|k|1|\n2|3|4|5) -->\n\t<xsd:attribute name=\"clefLine\" type=\"xsd:integer\" /> <!-- XXX short? -->\n\t<xsd:attribute name=\"kacc\" type=\"xsd:integer\" />    <!-- XXX (-7|-6|-5|-4|-3|-\n2|-1|0|1|2|3|4|5|6|7) -->\n\t<xsd:attribute name=\"kname\" type=\"xsd:string\" />\n\t<xsd:attribute name=\"sign1\" type=\"xsd:string\" />    <!-- XXX notename -->\n\t<xsd:attribute name=\"sign2\" type=\"xsd:string\" />    <!-- XXX notename -->\n\t<xsd:attribute name=\"sign3\" type=\"xsd:string\" />    <!-- XXX notename -->\n\t<xsd:attribute name=\"sign4\" type=\"xsd:string\" />    <!-- XXX notename -->\n\t<xsd:attribute name=\"sign5\" type=\"xsd:string\" />    <!-- XXX notename -->\n\t<xsd:attribute name=\"sign6\" type=\"xsd:string\" />    <!-- XXX notename -->\n\t<xsd:attribute name=\"sign7\" type=\"xsd:string\" />    <!-- XXX notename -->\n</xsd:extension>\n</xsd:complexContent>\n</xsd:complexType>\n\n\n\n\n<!-- ======================================================\n=========================== -->\n<!-- masterSymbol and equivalent classes                                               -->\n<!-- ======================================================\n=========================== -->\n\n<!-- a masterSymbol is an element that may only occur as child of \nmasterThread -->\n<xsd:element name=\"masterSymbol\" abstract=\"true\" type=\n\"momentOfTime\" />\n\n<xsd:element name=\"bar\" equivClass=\"masterSymbol\" type=\"Bar\" />\n\n\n\n\n<!-- ======================================================\n=========================== -->\n<!-- sharedSymbol and equivalent classes                                               -->\n<!-- ======================================================\n=========================== -->\n\n<!-- a sharedSymbol is an element that may occur as child of \nmasterThread or thread respectively -->\n<xsd:element name=\"sharedSymbol\" abstract=\"true\" type=\n\"momentOfTime\" />\n\n<xsd:element name=\"dynamics\" equivClass=\"sharedSymbol\" >\n\t<xsd:complexType>\n\t<xsd:complexContent>\n\t<xsd:extension base=\"momentOfTime\">\n\t\t<xsd:attribute name=\"name\" type=\"xsd:string\" />   <!-- XXX replace string \nenum -->\n\t</xsd:extension>\n\t</xsd:complexContent>\n\t</xsd:complexType>\n</xsd:element>\n\n\n<!-- repeat can contain all signs related to repetitions or omissions.\n     The only exception are the repeat signs around the bar.\n     Text positioning depends on the sign.\n  -->\n<xsd:element name=\"repeat\" equivClass=\"sharedSymbol\" >\n\t<xsd:complexType>\n\t<xsd:complexContent>\n\t<xsd:extension base=\"momentOfTime\">\n\t\t<xsd:attribute name=\"sign\" type=\"xsd:NMTOKEN\" default=\"empty\" />   <!-- \nXXX replace by (empty|segno|dalsegno|coda|tocoda|start_klammer|\nend_klammer|dacapo|fine|dcalfinesenzarep|dcalfine|dcsenzarep|vi|de) \n\"empty\"  -->\n\t\t<xsd:sequence>\n\t\t<element name=\"localText\" type=\"LocalTextType\" minOccurs=\"0\" \nmaxOccurs=\"1\" />\n\t\t</xsd:sequence>\n\t</xsd:extension>\n\t</xsd:complexContent>\n\t</xsd:complexType>\n</xsd:element>\n\n\n<!-- chordSymbol: a text String that describes a chord -->\n<xsd:element name=\"chordSymbol\" equivClass=\"sharedSymbol\">\n\t<xsd:complexType>\n\t<xsd:complexContent>\n\t<xsd:extension base=\"momentOfTime\">\n\t\t<xsd:attribute name=\"name\" type=\"xsd:string\" />   <!-- XXX replace by \nregular expression -->\n\t</xsd:extension>\n\t</xsd:complexContent>\n\t</xsd:complexType>\n</xsd:element>\n\n<!-- register:\n     name: machine readable, language independant name\n     style: some register signs can be rendered with a square or a circle \naround.\n  -->\n<xsd:element name=\"register\" equivClass=\"sharedSymbol\">\n\t<xsd:complexType>\n\t<xsd:complexContent>\n\t<xsd:extension base=\"momentOfTime\">\n\t\t<xsd:attribute name=\"pipeLen\" type=\"xsd:string\" /> \n\t\t<xsd:attribute name=\"style\" type=\"xsd:NMTOKEN\" default=\"empty\" /> <!-- \nXXX replace by (none|square|circle) \"none\" -->\n\t\t<xsd:sequence>\n\t\t<element   ref=\"description\" minOccurs=\"0\" maxOccurs=\"unbounded\" />\n\t\t</xsd:sequence>\n\t</xsd:extension>\n\t</xsd:complexContent>\n\t</xsd:complexType>\n</xsd:element>\n\n\n\n\n<!-- ======================================================\n=========================== -->\n<!-- threadSymbol and equivalent classes                                               -->\n<!-- ======================================================\n=========================== -->\n\n<!-- a threadSymbol is an element that may occur as child of thread -->\n<xsd:element name=\"threadSymbol\" abstract=\"true\" type=\n\"momentOfTime\" />\n\n<xsd:element name=\"barRef\" equivClass=\"threadSymbol\" >\n\t<xsd:complexType>\n\t<xsd:complexContent>\n\t<xsd:extension base=\"Bar\">\n\t\t<xsd:attribute name=\"barID\" type=\"xsd:IDREF\" />\n\t</xsd:extension>\n\t</xsd:complexContent>\n\t</xsd:complexType>\n</xsd:element>\n\n\n<!-- con:\n     context definition: one tag for key and clef.\n     the reason to put key and clef together is that there are clefs like S\n     which define clef and key together.\n     vis indicates whether a clef or a key (or nothing) is visually rendered.\n     NB: it is allowed to set the context without rendering. \n     cname, coct: name of a clef. Some, like \"G\" \n     TODO: allow an additional parameter for octave shifts.\n     clefLine: allows to assign a \"G\" key to a line different from 2\n     kacc: key accidentals\n     kname: key name\n\t * examples:\n\t * kacc=0 & name = \"C\"   -> c Major\n\t * kacc=0 & name = \"a\"   -> a Minor\n\t * kacc=0 & name = ... -> church keys\n\t sign1 ... sign7:\n\t * acc and name can't represent the examples in Gardner Read: Music \nNotation Chapter 9 page 141ff (second edition)\n\t * so you can provide seven independant note names instead of\n\t * counting sharps or flats with kacc\n\n  -->\n<xsd:element name=\"con\" equivClass=\"threadSymbol\" type=\"Con\" >\n</xsd:element>\n\n<!-- chord:\n     each note is encapsulated by a chord. This makes programming \neasier.\n  -->\n<xsd:element name=\"chord\" equivClass=\"threadSymbol\">\n\t<xsd:complexType>\n\t<xsd:complexContent>\n\t<xsd:extension base=\"lasting\">\n\t\t<xsd:sequence>\n\t\t<element   ref=\"note\" minOccurs=\"1\" maxOccurs=\"unbounded\" />\n\t\t</xsd:sequence>\n\t</xsd:extension>\n\t</xsd:complexContent>\n\t</xsd:complexType>\n</xsd:element>\n\n\n<!-- note:\n  -->\n<xsd:element name=\"note\">\n\t<xsd:complexType>\n\t<xsd:complexContent>\n\t<xsd:extension base=\"lasting\">\n\t\t<xsd:attribute name=\"name\" type=\"xsd:string\" /> <!-- XXX %noteName; --\n>\n\t\t<xsd:attribute name=\"oct\" type=\"xsd:NMTOKEN\" /> <!-- XXX replace by (S|\ns|K|g|k|1|2|3|4|5) -->\n\t\t<xsd:attribute name=\"chord\" type=\"xsd:string\" /> <!-- XXX %chordString; --\n>\n\t</xsd:extension>\n\t</xsd:complexContent>\n\t</xsd:complexType>\n</xsd:element>\n\n\n<!-- beam:\n     defines an ID that groups chords/notes together\n  -->\n<xsd:element name=\"beam\" equivClass=\"threadSymbol\" type=\n\"momentOfTime\">\n</xsd:element>\n\n<!-- slur:\n     groups notes left and (right) together\n     if tie = \"false\", right mus be provided\n  -->\n<xsd:element name=\"slur\" equivClass=\"threadSymbol\" >\n\t<xsd:complexType>\n\t<xsd:complexContent>\n\t<xsd:extension base=\"momentOfTime\">\n\t\t<xsd:attribute name=\"left\" type=\"xsd:IDREF\" use=\"required\" />\n\t\t<xsd:attribute name=\"right\" type=\"xsd:IDREF\"  />\n\t\t<xsd:attribute name=\"tie\" type=\"boolean\" />\n\t</xsd:extension>\n\t</xsd:complexContent>\n\t</xsd:complexType>\n</xsd:element>\n\n\n\n<!-- ======================================================\n=========================== -->\n<!-- general elements bibdata, description and LocalTextType                           \n-->\n<!-- ======================================================\n=========================== -->\n\n<!-- bibdata is referred several times and provides an aothors name and \ninternationalized text\n     it is a referred element instead of a complex type since its name \n     should not be changed for readability of the instance\n  -->\n<xsd:element name=\"bibdata\" minOccurs=\"0\" maxOccurs=\"1\">\n\t<xsd:complexType>\n\t<xsd:complexContent>\n\t<xsd:extension base=\"core\">\n\t\t<!-- xsd:attribute name=\"author\" type=\"xsd:string\" / -->\n\t\t<xsd:attribute name=\"author\" type=\"xsd:string\" />\n\t\t<xsd:sequence>\n\t\t<xsd:element name=\"localText\" type=\"LocalTextType\" maxOccurs=\n\"unbounded\" />  <!-- XXX change name for readability -->\n\t\t</xsd:sequence>\n\t</xsd:extension>\n\t</xsd:complexContent>\n\t</xsd:complexType>\n</xsd:element>\n\n\n<xsd:element name=\"description\" minOccurs=\"0\" maxOccurs=\"1\">\n\t<xsd:complexType>\n\t<xsd:complexContent>\n\t<xsd:extension base=\"core\">\n\t\t<xsd:attribute name=\"align\" type=\"xsd:string\" default=\"right\" /> <!-- XXX \n(left|right|bottom|top) \"right\" -->\n\t\t<xsd:sequence>\n\t\t<xsd:element name=\"localText\" type=\"LocalTextType\" />  <!-- XXX change \nname for readability -->\n\t\t</xsd:sequence>\n\t</xsd:extension>\n\t</xsd:complexContent>\n\t</xsd:complexType>\n</xsd:element>\n\n\n<!-- LocalTextType is referred several times and provides internationalized \ntext -->\n<xsd:complexType>\n\t<xsd:complexContent>\n\t<xsd:extension base=\"xsd:string\">\n\t<!-- no coreattrs -->\n\t</xsd:extension>\n\t</xsd:complexContent>\n <!--\t<xsd:attribute ref=\"lang\" /> XXX a LanguageCode, as per [RFC1766] -\n->\n\t<xsd:attribute name=\"lang\" type=\"xsd:string\" />\n</xsd:complexType>\n\n\n\n<!-- ======================================================\n=========================== -->\n<!-- Test                                                                              -->\n<!-- ======================================================\n=========================== -->\n\n</xsd:schema>\n\n\n\nBest regards,\n  Gerd", "id": 6805, "time": "2001-10-17T13:19:29Z", "bug_id": 4246, "creation_time": "2001-10-17T13:19:29Z", "attachment_id": null}, {"count": 1, "tags": [], "bug_id": 4246, "attachment_id": null, "id": 7323, "time": "2001-10-30T13:13:27Z", "creator": "sandygao@ca.ibm.com", "creation_time": "2001-10-30T13:13:27Z", "is_private": false, "text": "Added a check before the casting."}]