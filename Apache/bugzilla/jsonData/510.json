[{"count": 0, "tags": [], "text": "If for some reason the tomcat connector closes its ajp connection to\nmod_jk before sending the header, mod_jk will spin in an infinite\nloop looking for a never to come newline character.\n\nHere is a patch to fix this problem:\n\n--- jk_sockbuf.c.orig\tThu Feb 01 16:02:47 2001\n+++ jk_sockbuf.c\tThu Feb 01 16:02:28 2001\n@@ -56,7 +56,7 @@\n /***************************************************************************\n  * Description: Simple buffer object to handle buffered socket IO          *\n  * Author:      Gal Shachor <shachor@il.ibm.com>                           *\n- * Version:     $Revision: 1.1.2.1 $                                            \n   *\n+ * Version:     $Revision: 1.1 $                                               \n*\n  ***************************************************************************/\n \n #include \"jk_global.h\"\n@@ -90,7 +90,7 @@\n                 return JK_FALSE;\n             }\n             if(sz > SOCKBUF_SIZE) {\n-                return (send(sb->sd, (char *)buf, sz, 0) == (int)sz);\n+                return (send(sb->sd, buf, sz, 0) == (int)sz);\n             } \n             \n             memcpy(sb->buf + sb->end, buf, sz);\n@@ -131,7 +131,7 @@\n \n         if(sb->end == sb->start) {\n             sb->end = sb->start = 0;\n-            if(!fill_buffer(sb)) {\n+            if(fill_buffer(sb) < 0) {\n                 return JK_FALSE;\n             }\n         }\n@@ -154,6 +154,7 @@\n int jk_sb_gets(jk_sockbuf_t *sb,\n                char **ps)\n {\n+    int ret;\n     if(sb) {\n         while(1) {\n             unsigned i;\n@@ -169,8 +170,16 @@\n                     return JK_TRUE;\n                 }\n             }\n-            if(!fill_buffer(sb)) {\n+            if((ret = fill_buffer(sb)) < 0) {\n                 return JK_FALSE;\n+            } else if (ret == 0) {\n+                *ps = sb->buf + sb->start;\n+  \t\tif ((SOCKBUF_SIZE - sb->end) > 0) {\n+                    sb->buf[sb->end] = '\\0';\n+                } else {\n+                    sb->buf[sb->end-1] = '\\0';\n+                }\n+                return JK_TRUE;\n             }\n         }\n     }\n@@ -198,18 +207,26 @@\n     }\n \n     /*\n-     * Now, read more data\n+     * In the unlikely case where the buffer is already full,\n+     * we won't be reading anything and we'd be calling recv with\n+     * a 0 count.\n      */\n-    ret = recv(sb->sd, \n-               sb->buf + sb->end, \n-               SOCKBUF_SIZE - sb->end, 0);   \n+    if ((SOCKBUF_SIZE - sb->end) > 0) {\n+\t/*\n+\t* Now, read more data\n+\t*/\n+\tret = recv(sb->sd, \n+\t       sb->buf + sb->end, \n+\t       SOCKBUF_SIZE - sb->end, 0);   \n+\n+\t// 0 is EOF/SHUTDOWN, -1 is SOCK_ERROR\n+\tif (ret <= 0) {\n+\t    return ret;\n+\t} \n \n-    if(ret < 0) {\n-        return JK_FALSE;\n-    } \n-\n-    sb->end += ret;\n+\tsb->end += ret;\n+    }\n \n-    return JK_TRUE;\n+    return 1;\n }", "attachment_id": null, "bug_id": 510, "id": 486, "time": "2001-02-01T14:17:20Z", "creator": "bjv@motive.com", "creation_time": "2001-02-01T14:17:20Z", "is_private": false}]