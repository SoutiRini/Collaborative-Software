[{"count": 0, "tags": [], "text": "If a developer sets a custom selector which has no defaultRepository set, the \nselector is accepted and used.  When logging commences a NullPointerException \nis thrown from LogManager.getLogger.  This is confusing to the user.  \n\nDiscussions on log4j-dev list have considered three solutions: \n(http://nagoya.apache.org/eyebrowse/BrowseList?listName=log4j-\ndev@logging.apache.org&by=thread&from=945266)\n\n1.  LogManager imposes its default LoggerRepository on the selector which \ndidn't have one.  \n2.  LogManager.setRepositorySelector traps the error and throws a \nRuntimeException pointing more accurately to the error.  \n3.  LogManager.setRepositorySelector traps the error and throws a custom \nchecked exception.  \n\nHaving previously suggested solution 3, I now believe solution 2 to be correct \nfor a number of reasons:\n\nIt is declared in the general contract of the getDefaultRepository method of \nthe RepositorySelector interface that: \n\"In the initial phases of configration, the returned value may be null. \nHowever, after the RepositorySelector is properly registered with LogManager, \nthe returned value should never be null.\"  \n\nThis is clear warning to someone writing a custom selector.  \n\nThrowing a custom checked exception will force the user to catch that exception \nin her code for something that she should only ever experience once.  \n\nExisting code in the LogManager.setRepositorySelector method throws \nIllegalArgumentException's if either the selector or guard object are null\n\t(or if the guard is not correct).  \nThis behaviour should be extended to check the defaultRepository of the passed \nin selector and throw an IllegalArgumentException if it is null.  \n\nThe attached patch (full file and diff) makes this change to LogManager which \nmakes it very explicit what the error is: \n\njava.lang.IllegalArgumentException: RepositorySelector must have a non-null \ndefaultRepository.\n\tat org.apache.log4j.LogManager.setRepositorySelector\n(LogManager.java:154)\n\tat org.apache.log4j.test.MyCustomSelector.main(MyCustomSelector.java:57)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke\n(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke\n(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:324)\n\n\nI am also attaching a second patch which is a (very basic!) unit test to cover \nthe proposed changes.  \n\nRegards\n\nAndy", "attachment_id": null, "id": 67964, "creator": "andy.mcbride@pcmsgroup.com", "time": "2004-12-06T03:30:34Z", "bug_id": 32536, "creation_time": "2004-12-06T03:30:34Z", "is_private": false}, {"count": 1, "attachment_id": 13651, "bug_id": 32536, "is_private": false, "id": 67965, "time": "2004-12-06T03:34:45Z", "creator": "andy.mcbride@pcmsgroup.com", "creation_time": "2004-12-06T03:34:45Z", "tags": [], "text": "Created attachment 13651\nzip file containing modification to LogManager.java in both full and unified diff\n\nadded attachment with patch to current LogManager.java HEAD revision"}, {"count": 2, "tags": [], "bug_id": 32536, "is_private": false, "text": "Created attachment 13652\nzip file containing new unit test for modification to LogManager.java\n\nAdds a new unit test which verifies the expected behaviour of the patch to\nLogManager.", "id": 67966, "time": "2004-12-06T03:37:39Z", "creator": "andy.mcbride@pcmsgroup.com", "creation_time": "2004-12-06T03:37:39Z", "attachment_id": 13652}, {"count": 3, "tags": [], "text": "I still think 2 is probably fine as a backstop, but I'm not sure I'd call\npreventing a NullPointerException an \"imposition\" as you described in proposal\n#1.  To me, its expected behavior.  After all, if the original default\nrepository was configured with the user's full intention (by providing a config\nfile in the classpath) that it be used for logging, why wouldn't they want it to\ncontinue to be used for logging?  Why would we assume that they chose to discard\nit?  I would think the act of providing a repository that isn't the current\ndefault would be the *only* way to \"imply\" intention for discarding the current\nrepository.  In fact, anything else should be considered an unexpected \"side\neffect\".  Only true intention should change the existing default repository.\n\nCeki has spoken about \"side effects\" and that we don't want to have hidden\nbehavior that the user ends up counting on, but then changes as Log4j is\nredesigned or some other related aspect changes.  The argument is valid, in\nprincipal.  However, strict adherence to this is impractical.  Imagine all the\n\"side effects\" Log4j, or any other piece of software, has right now.  Imagine if\nwe removed all these \"side effects\" and imposed them on the user.  These types\nof \"side effects\" are better termed as \"common sense, predictable defaults\".  I\ndon't see why the current situation is any different.  Proposal #1 is a common\nsense, predictable default.\n\n\nSpeaking of \"side effects\", how's this for one?  If things stay the way they are\nnow and one wishes to attempt a transfer of the current default logger\nrepository to a new selector to be istalled, there is no guarantee that the\nlogger repository the user attempts to obtain will be that of the current\ndefault logger repository.  Why you ask?  Note the sample code below...\n\nRepositorySelector repositorySelector = new MyRepositorySelector();\nrepositorySelector.setDefaultRepository(LogManager.getLoggerRepository()); \nLogManager.setRepositorySelector(repositorySelector, new Object());\n\nThere's an assumption here that LogManager.getLoggerRepository() will return the\ncurrent default logger repository.  However, that is entirely up to the\ncurrently installed repository selector.  The assumption holds true in the case\nof the DefaultRepositorySelector which only has one logger repository, the\ndefault.  However, what if at some future date, we chose a different default\nselector such as a ContextClassLoaderSelector (unlikely) or the\nContextJNDISelector (very possible)?  LogManager.getLoggerRepository() would\nreturn the logger repository for the current context, not the default.  Talk\nabout \"side effects\".  This one makes my proposal look entirely non-controversial.\n\nOf course we can fix this by providing another method on the LogManager class\nsuch as LogManager.getDefaultRepository() which, instead of this...\n\n  public static LoggerRepository getLoggerRepository() {\n    return repositorySelector.getLoggerRepository();\n  }\n\nwould look like this...\n\n  public static LoggerRepository getDefaultRepository() {\n    return repositorySelector.getDefaultRepository();\n  }\n\nWith that change, I'm done with this argument.  I still think a good\ncommon-sense non-NullPointerException-causing default is perfectly fine and\ndesireable, but I'd settle for being required to set it manually if I can\nactually have a guarantee that the logger repository I am retrieving from the\nexisting respository selector is exactly what I expect it to be.  This is\nimpossible to know with certainty unless the LogManager.getDefaultRepository()\nmethod is added.  I'll let everyone else hash out whether null pointers should\nbe caught and rethrown with a clear message as a RuntimeException.\n\n\nJake", "attachment_id": null, "id": 67969, "creator": "hoju@visi.com", "time": "2004-12-06T07:08:53Z", "bug_id": 32536, "creation_time": "2004-12-06T07:08:53Z", "is_private": false}, {"count": 4, "tags": [], "bug_id": 32536, "attachment_id": null, "id": 98596, "time": "2007-01-26T19:58:04Z", "creator": "genman@noderunner.net", "creation_time": "2007-01-26T19:58:04Z", "is_private": false, "text": "\nI committed most of the patch, which was for solution #2.  It appears the patch\nwas out-of-date with respect to method names, etc.  I added JavaDoc about the\nrestricted contract when setting the repository selector.\n\nThe test cases went in LogManagerTest, since we're testing its implementation,\nnot the interface.\n\nThanks for the patch.\n"}, {"count": 5, "tags": [], "bug_id": 32536, "attachment_id": null, "id": 98786, "time": "2007-01-30T13:46:21Z", "creator": "carnold@apache.org", "creation_time": "2007-01-30T13:46:21Z", "is_private": false, "text": "Committed by eross in rev 500473"}, {"count": 6, "tags": [], "bug_id": 32536, "attachment_id": null, "is_private": false, "id": 98787, "time": "2007-01-30T13:50:37Z", "creator": "carnold@apache.org", "creation_time": "2007-01-30T13:50:37Z", "text": "Committed by eross in rev 500473"}]