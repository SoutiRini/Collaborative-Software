[{"count": 0, "tags": [], "bug_id": 50571, "text": "Created attachment 26476\nCreated against http://svn.apache.org/repos/asf/tomcat/trunk on 20110111\n\nI am working with the new JDBC connection pool in Tomcat 7, and it's great!  Nice work.\n\nOnce enhancement I would like to suggest is more control over the SQLException's that come out of the DataSource.  Certain interceptors (eg: ConnectionState) catch SQLException's and log them, thereby preventing the layer above DataSource from being able to detect and handle SQL problems.\n\nFor example, if a DataSource.getConnection() is created with an invalid database name, the ConnectionState interceptor will catch and log (eg: reset()), leaving the caller with no control over log output or knowing what the specific problem with the DataSource was.  I am working on an application where the datasources are more dynamic than the typical statically defined datasources in managed application servers, therefore I want to be able to detect and handle SQLException's that are raised from the ConnectionPool.\n\nI have provided a patch that illustrates the type of change I'm talking about.  As you can see, this causes SQLExceptions to propagate through several other APIs, but I think this is an improvement.  This different exception handling strategy could also be enabled with a property.\n\nThoughts?", "id": 143268, "time": "2011-01-11T12:29:56Z", "creator": "jnorris10@gmail.com", "creation_time": "2011-01-11T12:29:56Z", "is_private": false, "attachment_id": 26476}, {"count": 1, "attachment_id": null, "bug_id": 50571, "text": "hi Jeremy,\nI'm looking at your patch, and I will take a look at the connection state interceptor. most SQL exceptions, as you say, should percolate through when it makes sense.\n\nI wont apply the patch as it is, as I don't understand why most of the methods just change the signature of the method by adding \"throws SQLException\".\n\nfor example ConnectionPool.abandon doesn't really need to throw a SQLException\n\nbest\nFilip", "id": 143275, "time": "2011-01-11T16:47:08Z", "creator": "fhanik@apache.org", "creation_time": "2011-01-11T16:47:08Z", "tags": [], "is_private": false}, {"count": 2, "tags": [], "creator": "jnorris10@gmail.com", "attachment_id": null, "text": "Hello,\n\nThis initial use-case I was needing was for SQLExceptions originating in ConnectionState.reset() to propagate out of ConnectionPool.getConnection().\n\nThe rest of the changes cascaded from this:  eg: ConnectionPool.abandon() -> ConnectionPool.release() -> PooledConnection.setHandler() -> JdbcInterceptor.reset().\n\nI suspect there will be more and that most APIs will possibly throw SQLException...\n\nThanks.", "id": 143281, "time": "2011-01-11T18:36:33Z", "bug_id": 50571, "creation_time": "2011-01-11T18:36:33Z", "is_private": false}, {"count": 3, "tags": [], "creator": "fhanik@apache.org", "attachment_id": null, "id": 143282, "creation_time": "2011-01-11T19:02:44Z", "time": "2011-01-11T19:02:44Z", "bug_id": 50571, "text": "I see, exceptions can't simply be propagated like that, since that would cancel out events/code that needs to run.\n\n    protected void finalize(PooledConnection con) {\n        JdbcInterceptor handler = con.getHandler();\n        while (handler!=null) {\n            handler.reset(null, null);\n            handler=handler.getNext();\n        }\n    }\n\nIf a reset() throws an exception, the rest of the interceptors wouldn't be notified here, and the exception would not mean very much.\n\nSo, probably better to address case by case, and see what needs to be done\n\nbest\nFilip", "is_private": false}, {"count": 4, "tags": [], "creator": "jnorris10@gmail.com", "attachment_id": null, "text": "(In reply to comment #3)\n>     protected void finalize(PooledConnection con) {\n>         JdbcInterceptor handler = con.getHandler();\n>         while (handler!=null) {\n>             handler.reset(null, null);\n>             handler=handler.getNext();\n>         }\n>     }\n> \n> If a reset() throws an exception, the rest of the interceptors wouldn't be\n> notified here, and the exception would not mean very much.\n\nCurrently, if a connection pool is configured for a database that does not exist, the first place a SQLException occurs is reset() (with the following call stack for mysql):\n\nCaused by: com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: Unknown database 'db_name'\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)\n\tat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)\n\tat java.lang.reflect.Constructor.newInstance(Constructor.java:513)\n\tat com.mysql.jdbc.Util.handleNewInstance(Util.java:407)\n\tat com.mysql.jdbc.Util.getInstance(Util.java:382)\n\tat com.mysql.jdbc.SQLError.createSQLException(SQLError.java:1052)\n\tat com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:3593)\n\tat com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:3525)\n\tat com.mysql.jdbc.MysqlIO.sendCommand(MysqlIO.java:1986)\n\tat com.mysql.jdbc.MysqlIO.sqlQueryDirect(MysqlIO.java:2140)\n\tat com.mysql.jdbc.ConnectionImpl.execSQL(ConnectionImpl.java:2620)\n\tat com.mysql.jdbc.ConnectionImpl.setCatalog(ConnectionImpl.java:5116)\n\tat org.apache.tomcat.jdbc.pool.interceptor.ConnectionState.reset(ConnectionState.java:95)\n\tat org.apache.tomcat.jdbc.pool.ConnectionPool.setupConnection(ConnectionPool.java:280)\n\tat org.apache.tomcat.jdbc.pool.ConnectionPool.getConnection(ConnectionPool.java:169)\n\tat org.apache.tomcat.jdbc.pool.DataSourceProxy.getConnection(DataSourceProxy.java:111)\n\nIf reset() swallows and logs this and we don't propagate it, then the upper layer has no way of acting on this (or controlling the log output).\n\nWe can try finishing executing the interceptor stack, ie:\n\nprotected void finalize(PooledConnection con) {\n    JdbcInterceptor handler = con.getHandler();\n    Exception exception = null;\n    while (handler!=null) {\n        try {\n            handler.reset(null, null);\n        } catch (SQLException e) {\n            exception = e;\n        }\n        handler=handler.getNext();\n    }\n    if (exception != null) {\n        throw exception\n    }\n}\n\nbut, if more exceptions are thrown from additional interceptors, what exception should ultimately be thrown from finalize()?\n\nOne solution is to NOT continue processing the interceptor stack.  If interceptors need to be notified, we could use another event.\n\nThoughts?", "id": 143283, "time": "2011-01-11T20:52:34Z", "bug_id": 50571, "creation_time": "2011-01-11T20:52:34Z", "is_private": false}, {"count": 5, "tags": [], "creator": "jnorris10@gmail.com", "attachment_id": null, "text": "Sorry, the example code above should be for ConnectionPool.setupConnection().  The problem is the same though; do we continue invoking the interceptors on an exception or not.", "id": 143285, "time": "2011-01-11T21:18:57Z", "bug_id": 50571, "creation_time": "2011-01-11T21:18:57Z", "is_private": false}, {"count": 6, "tags": [], "creator": "fhanik@apache.org", "attachment_id": null, "text": "What I propose, is to fix the actual bug, of ConnectionState swallowing the exception on pool startup.\nAnd we fix this bug, without introducing new bugs by changing too many signatures.", "id": 143308, "time": "2011-01-12T11:11:22Z", "bug_id": 50571, "creation_time": "2011-01-12T11:11:22Z", "is_private": false}, {"count": 7, "tags": [], "creator": "jnorris10@gmail.com", "attachment_id": null, "id": 143314, "creation_time": "2011-01-12T12:37:33Z", "time": "2011-01-12T12:37:33Z", "bug_id": 50571, "text": "Agreed, the actual bug is ConnectionState swallowing the exception on pool startup, however I suspect that fixing it properly will require some of the signatures to change.\n\nIn my opinion, SQLException's needs to propagate all the way up to ConnectionPool.getConnection().  SQLException is a checked exception so when we propagate it from JdbcInterceptor, it will affect the callers signature unless that caller swallows it (not what we want) or wraps it in a RuntimeException (a bit clumsy).\n\nThanks for your time and discussion, it's very appreciated.", "is_private": false}]