[{"attachment_id": null, "tags": [], "creator": "andreas.zielke@gmx.net", "text": "Hi *,\n\nthere's a synchronization problem in HSSFDataFormat.\nThe populating of the formats array list is static synchronized,\nbut not all accesses are synchronized.\nTwo concurrent threads may enter one of the methods; the first will be\nstopped immedeately after entering the method. The second one will enter\na method and see the formats as null. It now enters the static populate \nmethod and will create a List and start to add formats to it. The scheduler\nwill then interrupt the thread. Now the bug happens: The first thread will\nsee the (not-fully) initialized List (which is not null!) and try to access\nit. This'll lead to an IndexOutOfBoundsException.\nI ran into this situation while unit-testing one of my classes.\n\nThe solution is simple. Do the populating of the formats list as static\ninitialization. This way the vm guarantees, that the list will be populated\nbefore any methods of the class are called.\n\nBelow is the fixed (but untested) version of the class...\n\nRegards and keep up the good work; I really enjoy using POI!!!\n\nAndreas\n\n\n\npackage org.apache.poi.hssf.usermodel;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Utility to identify builin formats.  The following is a list of the formats as\n * returned by this class.<P>\n *<P>\n *       0, \"General\"<P>\n *       1, \"0\"<P>\n *       2, \"0.00\"<P>\n *       3, \"#,##0\"<P>\n *       4, \"#,##0.00\"<P>\n *       5, \"($#,##0_);($#,##0)\"<P>\n *       6, \"($#,##0_);[Red]($#,##0)\"<P>\n *       7, \"($#,##0.00);($#,##0.00)\"<P>\n *       8, \"($#,##0.00_);[Red]($#,##0.00)\"<P>\n *       9, \"0%\"<P>\n *       0xa, \"0.00%\"<P>\n *       0xb, \"0.00E+00\"<P>\n *       0xc, \"# ?/?\"<P>\n *       0xd, \"# ??/??\"<P>\n *       0xe, \"m/d/yy\"<P>\n *       0xf, \"d-mmm-yy\"<P>\n *       0x10, \"d-mmm\"<P>\n *       0x11, \"mmm-yy\"<P>\n *       0x12, \"h:mm AM/PM\"<P>\n *       0x13, \"h:mm:ss AM/PM\"<P>\n *       0x14, \"h:mm\"<P>\n *       0x15, \"h:mm:ss\"<P>\n *       0x16, \"m/d/yy h:mm\"<P>\n *<P>\n *       // 0x17 - 0x24 reserved for international and undocumented\n *       0x25, \"(#,##0_);(#,##0)\"<P>\n *       0x26, \"(#,##0_);[Red](#,##0)\"<P>\n *       0x27, \"(#,##0.00_);(#,##0.00)\"<P>\n *       0x28, \"(#,##0.00_);[Red](#,##0.00)\"<P>\n *       0x29, \"_(*#,##0_);_(*(#,##0);_(* \\\"-\\\"_);_(@_)\"<P>\n *       0x2a, \"_($*#,##0_);_($*(#,##0);_($* \\\"-\\\"_);_(@_)\"<P>\n *       0x2b, \"_(*#,##0.00_);_(*(#,##0.00);_(*\\\"-\\\"??_);_(@_)\"<P>\n *       0x2c, \"_($*#,##0.00_);_($*(#,##0.00);_($*\\\"-\\\"??_);_(@_)\"<P>\n *       0x2d, \"mm:ss\"<P>\n *       0x2e, \"[h]:mm:ss\"<P>\n *       0x2f, \"mm:ss.0\"<P>\n *       0x30, \"##0.0E+0\"<P>\n *       0x31, \"@\"<P>\n *\n *\n * @author  Andrew C. Oliver (acoliver at apache dot org)\n */\n\npublic class HSSFDataFormat\n{\n    private static ArrayList formats;\n\n    static {\n        formats = new ArrayList();\n        formats.add(0, \"General\");\n        formats.add(1, \"0\");\n        formats.add(2, \"0.00\");\n        formats.add(3, \"#,##0\");\n        formats.add(4, \"#,##0.00\");\n        formats.add(5, \"($#,##0_);($#,##0)\");\n        formats.add(6, \"($#,##0_);[Red]($#,##0)\");\n        formats.add(7, \"($#,##0.00);($#,##0.00)\");\n        formats.add(8, \"($#,##0.00_);[Red]($#,##0.00)\");\n        formats.add(9, \"0%\");\n        formats.add(0xa, \"0.00%\");\n        formats.add(0xb, \"0.00E+00\");\n        formats.add(0xc, \"# ?/?\");\n        formats.add(0xd, \"# ??/??\");\n        formats.add(0xe, \"m/d/yy\");\n        formats.add(0xf, \"d-mmm-yy\");\n        formats.add(0x10, \"d-mmm\");\n        formats.add(0x11, \"mmm-yy\");\n        formats.add(0x12, \"h:mm AM/PM\");\n        formats.add(0x13, \"h:mm:ss AM/PM\");\n        formats.add(0x14, \"h:mm\");\n        formats.add(0x15, \"h:mm:ss\");\n        formats.add(0x16, \"m/d/yy h:mm\");\n\n        // 0x17 - 0x24 reserved for international and undocumented\n        formats.add(0x17, \"0x17\");\n        formats.add(0x18, \"0x18\");\n        formats.add(0x19, \"0x19\");\n        formats.add(0x1a, \"0x1a\");\n        formats.add(0x1b, \"0x1b\");\n        formats.add(0x1c, \"0x1c\");\n        formats.add(0x1d, \"0x1d\");\n        formats.add(0x1e, \"0x1e\");\n        formats.add(0x1f, \"0x1f\");\n        formats.add(0x20, \"0x20\");\n        formats.add(0x21, \"0x21\");\n        formats.add(0x22, \"0x22\");\n        formats.add(0x23, \"0x23\");\n        formats.add(0x24, \"0x24\");\n\n        // 0x17 - 0x24 reserved for international and undocumented\n        formats.add(0x25, \"(#,##0_);(#,##0)\");\n        formats.add(0x26, \"(#,##0_);[Red](#,##0)\");\n        formats.add(0x27, \"(#,##0.00_);(#,##0.00)\");\n        formats.add(0x28, \"(#,##0.00_);[Red](#,##0.00)\");\n        formats.add(0x29, \"_(*#,##0_);_(*(#,##0);_(* \\\"-\\\"_);_(@_)\");\n        formats.add(0x2a, \"_($*#,##0_);_($*(#,##0);_($* \\\"-\\\"_);_(@_)\");\n        formats.add(0x2b, \"_(*#,##0.00_);_(*(#,##0.00);_(*\\\"-\\\"??_);_(@_)\");\n        formats.add(0x2c,\n                    \"_($*#,##0.00_);_($*(#,##0.00);_($*\\\"-\\\"??_);_(@_)\");\n        formats.add(0x2d, \"mm:ss\");\n        formats.add(0x2e, \"[h]:mm:ss\");\n        formats.add(0x2f, \"mm:ss.0\");\n        formats.add(0x30, \"##0.0E+0\");\n        formats.add(0x31, \"@\");\n    }\n\n    public static List getFormats()\n    {\n        return formats;\n    }\n\n    /**\n     * get the format index that matches the given format string\n     * @param format string matching a built in format\n     * @return index of format or -1 if undefined.\n     */\n\n    public static short getFormat(String format)\n    {\n        short retval = -1;\n\n        for (short k = 0; k < 0x31; k++)\n        {\n            String nformat = ( String ) formats.get(k);\n\n            if ((nformat != null) && nformat.equals(format))\n            {\n                retval = k;\n                break;\n            }\n        }\n        return retval;\n    }\n\n    /**\n     * get the format string that matches the given format index\n     * @param index of a built in format\n     * @return string represented at index of format or null if there is not a builtin format at that index\n     */\n\n    public static String getFormat(short index)\n    {\n        return ( String ) formats.get(index);\n    }\n\n    /**\n     * get the number of builtin and reserved formats\n     * @return number of builtin and reserved formats\n     */\n\n    public static int getNumberOfBuiltinFormats()\n    {\n        return formats.size();\n    }\n}", "count": 0, "id": 42803, "time": "2003-08-15T13:18:22Z", "bug_id": 22456, "creation_time": "2003-08-15T13:18:22Z", "is_private": false}, {"count": 1, "tags": [], "creator": "jheight@apache.org", "attachment_id": null, "text": "Current SVN code would have been OK for this bug, but i cleaned it up a little.\nNow totally squashed.\n\nBTW i dont really like anonymous static initialisation blocks i much prefer:\n\nprivate static List someVar = initialiseSomeVar();\n\nprivate static List initialiseSomeVar() {\n  List myList = new ArrayList();\n  ....\n  return myList;\n}\n\njust feels like i have more control.....", "id": 91571, "time": "2006-07-25T11:51:06Z", "bug_id": 22456, "creation_time": "2006-07-25T11:51:06Z", "is_private": false}]