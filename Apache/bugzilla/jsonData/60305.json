[{"attachment_id": null, "tags": [], "creator": "tallison@mitre.org", "text": "On TIKA-2142, Seva Alekseyev shared a PPT that causes an AIOOBE when reading the \"Pictures\" stream.  When the exception is hit, the parser has read in 81 pictures.  However, when we open the file in PPT and count the number of images and when we count the number of HSLFPictureShapes we get when we iterate through the slides programmatically, there are only 78 images.\n\nIf I understand correctly, when we read the \"Pictures\" stream, we don't know how many records to expect.  We read the Pictures stream before we parse the slides and determine which are most recent etc., and there is no header on the Picture stream (OfficeArtBStoreDelay). \n\nI propose we check for an AIOOBE in 'readPictures' within HSLFSlideShowImpl and log a warning if we would have hit one.", "count": 0, "id": 194669, "time": "2016-10-25T12:56:17Z", "bug_id": 60305, "creation_time": "2016-10-25T12:56:17Z", "is_private": false}, {"count": 1, "tags": [], "creator": "tallison@mitre.org", "attachment_id": null, "is_private": false, "id": 194697, "time": "2016-10-28T13:40:51Z", "bug_id": 60305, "creation_time": "2016-10-28T13:40:51Z", "text": "r1767023\n\nI did a bit of testing, and if the pictstream is truncated on an image that _should_ appear in a slide, the consumer will get a null when retrieving the missing image's pictdata."}, {"attachment_id": null, "tags": [], "creator": "tallison@mitre.org", "text": "r1767023\n\nI did a bit of testing, and if the pictstream is truncated on an image that _should_ appear in a slide, the consumer will get a null when retrieving the missing image's pictdata.", "count": 2, "id": 194698, "time": "2016-10-28T13:41:17Z", "bug_id": 60305, "creation_time": "2016-10-28T13:41:17Z", "is_private": false}, {"count": 3, "tags": [], "creator": "kiwiwings@apache.org", "attachment_id": null, "is_private": false, "id": 194712, "time": "2016-10-28T22:07:49Z", "bug_id": 60305, "creation_time": "2016-10-28T22:07:49Z", "text": "The wrong imagesize is based on a premature end of reading the last picture and then the imagesize is just some garbage at the end of that picture.\nWe shouldn't yet close this issue ..."}, {"attachment_id": null, "tags": [], "creator": "tallison@mitre.org", "text": "Doh.  Thank you.", "count": 4, "id": 194713, "time": "2016-10-28T22:14:03Z", "bug_id": 60305, "creation_time": "2016-10-28T22:14:03Z", "is_private": false}, {"count": 5, "tags": [], "creator": "tallison@mitre.org", "attachment_id": null, "is_private": false, "id": 194742, "time": "2016-10-31T20:04:47Z", "bug_id": 60305, "creation_time": "2016-10-31T20:04:47Z", "text": "Does that mean that the previous image's length is wrong?\n\nIf I understand correctly, there are two faulty png headers at the end of the stream.  The first one says the image should be 414273 (065241) bytes long.  Then ~75 bytes later, there's another PNG signature, and its header says that the image should be 273665 (042D01).  If I copy and paste from the second PNG signature to the end (042D09), I get a png file that I can open.  If I actually truncate it to 273665 (042D01), I get a corrupt file."}, {"attachment_id": null, "tags": [], "creator": "kiwiwings@apache.org", "text": "I can confirm your comment #5, i.e. I was wrong in #3.\nI guess this truncated picture is a rare case, and we don't need to try harder  to find the next pictures in the sequence.\n\nIf this would happen more often in the corpus, we could try to check, if we point beyond EOF (= the current patch) or if the referenced address contains a invalid signature. In both cases, we could then scan through the byte array to find a valid signature and continue from there.\n\nI guess you don't object, if I close the bug with your resolution.", "count": 6, "id": 194787, "time": "2016-11-02T23:12:25Z", "bug_id": 60305, "creation_time": "2016-11-02T23:12:25Z", "is_private": false}, {"count": 7, "tags": [], "bug_id": 60305, "is_private": false, "text": "No objection resolving as fixed.  \n\nI agree that the image stream is truly corrupt in this one file. We will likely run into cases where the image stream is corrupted/truncated _and_ there is actually a reference to the corrupted/truncated in a slide.  In that case, there will be an NPE when the user tries to get the image data. \n\nGiven the craziness in the world, I'm ok with that.  I'd far prefer to prevent an OOM/AIOOBE if the data is corrupt.\n\nThank you for looking into this!", "id": 194792, "time": "2016-11-03T11:33:28Z", "creator": "tallison@mitre.org", "creation_time": "2016-11-03T11:33:28Z", "attachment_id": null}]