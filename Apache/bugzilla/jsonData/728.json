[{"count": 0, "tags": [], "text": "This problem occurs with jakarta-tomcat-3.2.2b1, also with jakarta-tomcat-3.2.1\nIf I start several threads each of which continually makes POST requests to the\n8080 port, after a few thousand requests tomcat will start throwing\nNullPointerExceptions:\n2001-02-27 11:07:03 - ContextManager: Error reading request, ignored -\njava.lang.NullPointerException\n        at\norg.apache.tomcat.service.http.HttpConnectionHandler.processConnection(HttpConnectionHandler.java:191)\n        at\norg.apache.tomcat.service.TcpWorkerThread.runIt(PoolTcpEndpoint.java:416)\n        at\norg.apache.tomcat.util.ThreadPool$ControlRunnable.run(ThreadPool.java:498)\n        at java.lang.Thread.run(Thread.java:484)\n\nThe problem occurs on this line of code (line 191 above):\n            connection.getEndpoint().getServerSocketFactory().preProcessRequest(\nsocket, reqA );\nand I have traced it as far as determining that connection.getEndpoint() returns\nnull.  Looking at TcpConnection (type of connection var) it looks likely that\nthere is a flaw in the way that TcpConnections are recycled such that sometimes\nthe endpoint property is not set.\nThe client thread making the POST ends up with a broken pipe exception.\nThis problem occurs with my own simple test servlets and calling the provided\nexample RequestInfo servlet.\nThis bug means that tomcat cannot be relied on for high load servlet work so I\nassigned it a high priority.  I am not on the mailing lists but feel free to\nemail me directly for further info.  I can give you my test program if you like.", "attachment_id": null, "bug_id": 728, "id": 878, "time": "2001-02-27T08:29:42Z", "creator": "lindsay@roguewave.com", "creation_time": "2001-02-27T08:29:42Z", "is_private": false}, {"count": 1, "text": "Created attachment 25\nProgram for multithreaded POST load testing", "bug_id": 728, "attachment_id": 25, "id": 880, "time": "2001-02-27T08:57:31Z", "creator": "lindsay@roguewave.com", "creation_time": "2001-02-27T08:57:31Z", "tags": [], "is_private": false}, {"count": 2, "tags": [], "creator": "lindsay@roguewave.com", "attachment_id": 26, "is_private": false, "id": 881, "time": "2001-02-27T09:00:01Z", "bug_id": 728, "creation_time": "2001-02-27T09:00:01Z", "text": "Created attachment 26\nSample input file test program - content doesn't really matter."}, {"count": 3, "tags": [], "creator": "lindsay@roguewave.com", "attachment_id": null, "is_private": false, "id": 882, "time": "2001-02-27T09:04:36Z", "bug_id": 728, "creation_time": "2001-02-27T09:04:36Z", "text": "The bug shows up most reliably for me when I run tomcat on a slow machine and\nrun the client test program on a fast duel processor machine.  I had difficulty\ngetting it to show up when running both tomcat and the test program on the slow\nmachine."}, {"count": 4, "tags": [], "text": "The following code in org/apache/tomcat/service/PoolTcpEndpoint.java (line 418)\nseems to be incorrect:\n                } finally {\n                    con.recycle();\n                    if( usePool && con != null ) connectionCache.put(con);\n                }\ncon cannot be null in the if statement because a NullPointerException would have\nbeen thrown on the previous line if it were.  The following would be better:\n                } finally {\n                    if( con != null ) {\n                        con.recycle();\n                        if( usePool ) connectionCache.put(con);\n                    }\n                }\nThis does not explain the bug but it would appear that the bug can only occur if\ntwo threads are using con at once.  In the code:\n            if(null != s) {\n                // Continue accepting on another thread...\n                endpoint.tp.runIt(this);\n\n                try {\n                    if( usePool ) {\n                        con=(TcpConnection)connectionCache.get();\n                        if( con == null )\n                            con = new TcpConnection();\n                    }\n\n                    con.setEndpoint(endpoint);\n                    con.setSocket(s);\n                    endpoint.getConnectionHandler().processConnection(con,\nperThrData);\n\nwe know that endpoint is not null when used in con.setEndpoint(endpoint) or a\nNullPointerException would have occured when endpoint.tp.runIt(this) executed.\nWe know that it is null when used in the processConnection method so, either\nthere is a thread someplace that called con.recycle() or con.setEndpoint(null)\nafter it had already returned con to the pool, or there is an error in the pool\ncode and the same con got used in more than one thread.  Since the pool is local\nto PoolTcpEndpoint and not passed anywhere it seems most likely that the problem\nis in the SimplePool code.\n\nNote that the data members \n    private int minSpare;\n    private int maxSpare;\nare never used in SimplePool, and that the import statements aren't used.\nIn the SimplePool put method:\n    public  void put(Object o) {\n        int idx=-1;\n        synchronized( lock ) {\n            if( current < max )\n                idx=++current;\n        }\n        if( idx > 0 ) \n            pool[idx]=o;\n    }\nif current == max - 1 then idx will be become max and pool[max] will cause an\nerror since the last array element is at max - 1.\n\nHmm, after banging my head against this for a while I still can't see how it is\ngoing wrong but, the problem is that an item in the pool can be returned more\nthan once.  A *workaround* for this is to set the array element that a returned\nitem is retrieved from to null before returning.  The code will still\nincorrectly return the array element (now null), but the calling code checks for\na null return and creates a new object so instead of the occassional null\npointer exception you get an occassional extra object creation, not satisfying\nbut an improvement.  There are also a few bounds checks that aren't quite\ncorrect.  Here are the diffs:\n< import java.util.zip.*;\n< import java.net.*;\n< import java.util.*;\n< import java.io.*;\n< \n86,88d80\n<     private int minSpare;\n<     private int maxSpare;\n< \n108c100\n<           if( current < max )\n---\n>           if( current < (max-1) )\n111c103\n<       if( idx > 0 ) \n---\n>       if( idx >= 0 ) \n124,125c116,120\n<       if( idx >= 0  ) \n<           return pool[idx];\n---\n>       if( idx >= 0  ) {\n>             Object item = pool[idx];\n>             pool[idx] = null;\n>           return item;\n>         }\n\n", "is_private": false, "bug_id": 728, "id": 892, "time": "2001-02-27T12:54:39Z", "creator": "lindsay@roguewave.com", "creation_time": "2001-02-27T12:54:39Z", "attachment_id": null}, {"attachment_id": 27, "tags": [], "creator": "lindsay@roguewave.com", "is_private": false, "count": 5, "id": 897, "time": "2001-02-28T05:14:40Z", "bug_id": 728, "creation_time": "2001-02-28T05:14:40Z", "text": "Created attachment 27\nPatch that fixes the bug."}, {"count": 6, "tags": [], "text": "The problem was caused by placing assignments and accesses to the array outside\nof the synchronized block.  This meant that a thread adding an object could be\npreempted after the current variable was updated but before the value was\nactually written to the array, so another thread might then read the value\npointed at by the current variable which has not yet been written.  In the\noriginal code this would result in the value previously in that array element\nbeing returned, that value would be a value that had already been returned\nso two threads would be using the same pooled object.  Not only would the two\nthreads be overwriting one another's properties on the object, likely causing\nerrors, but one of the threads would null out the endpoint property when it\ncompleted and the other thread would then attempt to use the now null endpoint\nproperty and cause a NullPointerException.  The race can also work in the other\ndirection with one thread updating current to indicate that an element had been\nremoved but get preempted before it actually read the value, another thread\nmight then write a new value before the read actually occured.\n", "attachment_id": null, "id": 898, "creation_time": "2001-02-28T05:33:23Z", "time": "2001-02-28T05:33:23Z", "creator": "lindsay@roguewave.com", "bug_id": 728, "is_private": false}, {"count": 7, "text": "A similar patch was already present in Tomcat 3.3.  Since this patch cleaned\nup the code a little better, it has been applied to both Tomcat 3.2.2 and\nTomcat 3.3.  Thanks for the patch.\n\nFor query purposes, mark as fixed in Tomcat 3.2.2 and Tomcat 3.3\nFixed in Tomcat 3.2.2\nFixed in Tomcat 3.3", "bug_id": 728, "attachment_id": null, "id": 910, "time": "2001-02-28T11:30:40Z", "creator": "Larry.Isaacs@sas.com", "creation_time": "2001-02-28T11:30:40Z", "tags": [], "is_private": false}]