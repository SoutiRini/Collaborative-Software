[{"count": 0, "tags": [], "text": "The current implementation allows only to activate document protection without password.\nThis patch allows to set a password when activating document protection. This password needs to be provided as tuple (hashAlgortihmId, salt, hash). There is no code yet that creates the hash value depending on a provided plain text password and salt.\n\nI tried to create a hash value as described in \"Office Open XML, Part 4: Markup Language Reference, December 2006\", but failed. The calculated hash value did not match the value calculated by MS Office 2010 :-(\n\nI hope taht I can provide this later.", "is_private": false, "id": 172734, "creator": "stefan.kopf@alfresco.com", "time": "2014-01-28T13:41:42Z", "bug_id": 56076, "creation_time": "2014-01-28T13:41:42Z", "attachment_id": null}, {"count": 1, "attachment_id": 31257, "bug_id": 56076, "is_private": false, "id": 172735, "time": "2014-01-28T13:43:35Z", "creator": "stefan.kopf@alfresco.com", "creation_time": "2014-01-28T13:43:35Z", "tags": [], "text": "Created attachment 31257\nPatch file created by patch.xml to add document protection with password to XWPF"}, {"count": 2, "tags": [], "creator": "kiwiwings@apache.org", "attachment_id": null, "is_private": false, "id": 172961, "time": "2014-02-09T01:36:32Z", "bug_id": 56076, "creation_time": "2014-02-09T01:36:32Z", "text": "Please attach an example word document (with an example password ;) ).\n\nIf we are lucky, it's the same algo as in http://thread.gmane.org/gmane.comp.jakarta.poi.devel/25831"}, {"count": 3, "attachment_id": 31316, "bug_id": 56076, "is_private": false, "id": 173067, "time": "2014-02-17T10:40:07Z", "creator": "stefan.kopf@alfresco.com", "creation_time": "2014-02-17T10:40:07Z", "tags": [], "text": "Created attachment 31316\nPassword protected OOXML Word Document (Password \"Example\")\n\nHere is a Word document protected with the password \"Example\".\n\nThe protection data written into this document by Word is:\n<w:documentProtection\n  w:edit=\"trackedChanges\"\n  w:enforcement=\"1\"\n  w:cryptProviderType=\"rsaFull\"\n  w:cryptAlgorithmClass=\"hash\"\n  w:cryptAlgorithmType=\"typeAny\"\n  w:cryptAlgorithmSid=\"4\"\n  w:cryptSpinCount=\"100000\"\n  w:hash=\"MUHbcmpC9AnlLsd9v3lW0j30y6E=\"\n  w:salt=\"2Z+i7o/0EZyUNakVeWzU/w==\"/>\n\nThe algorithm sid 4 references the SHA-1 algorithm."}, {"count": 4, "tags": [], "text": "Andreas,\n\nThe algorithm is different from the one you referenced here :-(.\n\nIt is defined in \"Office Open XML Part 4 - Markup Language Reference\" chapter 2.15.1.28 on page 1158.\n\nAt first, the password is hashed with the legacy algortithm used in .doc files. I have provided an implementation of this algorithm in bug 56077. I can tell that this algorithm is correct by comparing my results to the example given in the spec.\n\nNext, the result of this is hashed by the hash algorithm (SHA-1 in the example above) with the salt prependen. The output of this is used as input  for the next round of hashing (without a round key prepended). This is repeated for spin-count rounds.\n\nBut the result of this does not match the hash calculated by MS Office.\n\nHere is the implementation I used to test it:\n\npackage com.alfresco.sparta.research.office.changetracking;\n\nimport java.security.MessageDigest;\n\nimport org.apache.commons.codec.binary.Base64;\nimport org.apache.poi.util.LittleEndian;\nimport org.apache.poi.util.LittleEndianConsts;\n\npublic class TestSha1\n{\n\n    public static void main(String[] args) throws Exception\n    {\n\n        String password = \"Example\";\n        byte[] salt = Base64.decodeBase64(\"2Z+i7o/0EZyUNakVeWzU/w==\");\n        byte[] expectedHash = Base64.decodeBase64(\"MUHbcmpC9AnlLsd9v3lW0j30y6E=\");\n        int rounds = 100000;\n\n        System.out.println(\"Salt: \"  +  hexBytes(salt));\n        System.out.println(\"ExpectedHash: \"  +  hexBytes(expectedHash));\n\n        \n        int wordHash = wordPasswordHash(password);\n        System.out.print(\"WordHash: 0x\");\n        System.out.format(\"%H\",wordHash);\n        System.out.println();\n        \n        byte[] reversedWordHash = new byte[4];\n        reversedWordHash[0] = (byte) (wordHash & 0x000000FF);\n        reversedWordHash[1] = (byte) ( (wordHash & 0x0000FF00) >> 8);\n        reversedWordHash[2] = (byte) ( (wordHash & 0x00FF0000) >> 16);\n        reversedWordHash[3] = (byte) ( (wordHash & 0xFF000000) >> 24);\n        System.out.println(\"ReversedWordHash: \"  +  hexBytes(reversedWordHash));\n        \n        MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n        \n        md.update(salt);\n        byte[] hash = md.digest(reversedWordHash);\n        \n        byte[] iterator = new byte[LittleEndianConsts.INT_SIZE];\n        for(int i = 0; i < rounds; i++)\n        {\n            LittleEndian.putInt(iterator, 0, i);\n            md.reset();\n            //md.update(iterator);\n            md.update(hash);\n            md.digest(hash, 0, hash.length);\n        }\n        System.out.println(\"GeneratedHash: \"  +  hexBytes(hash));\n    }\n    \n    static String hexBytes(byte[] b)\n    {\n        StringBuilder result = new StringBuilder(\"0x\");\n        for(int i = 0; i < b.length;  i++)\n        {            \n            String s = String.format(\"%02X\", b[i]);\n            result.append(s);\n        }\n        return result.toString();\n    }\n\n    \n    private static char[] initialValue = { 0xE1F0, 0x1D0F, 0xCC9C, 0x84C0, 0x110C, 0x0E10, 0xF1CE, 0x313E,\n            0x1872, 0xE139, 0xD40F, 0x84F9, 0x280C, 0xA96A, 0x4EC3 };\n    \n    private static char[][] encryptionMatrix =\n      { { 0xAEFC, 0x4DD9, 0x9BB2, 0x2745, 0x4E8A, 0x9D14, 0x2A09 },\n        { 0x7B61, 0xF6C2, 0xFDA5, 0xEB6B, 0xC6F7, 0x9DCF, 0x2BBF },\n        { 0x4563, 0x8AC6, 0x05AD, 0x0B5A, 0x16B4, 0x2D68, 0x5AD0 },\n        { 0x0375, 0x06EA, 0x0DD4, 0x1BA8, 0x3750, 0x6EA0, 0xDD40 },\n        { 0xD849, 0xA0B3, 0x5147, 0xA28E, 0x553D, 0xAA7A, 0x44D5 },\n        { 0x6F45, 0xDE8A, 0xAD35, 0x4A4B, 0x9496, 0x390D, 0x721A },\n        { 0xEB23, 0xC667, 0x9CEF, 0x29FF, 0x53FE, 0xA7FC, 0x5FD9 },\n        { 0x47D3, 0x8FA6, 0x0F6D, 0x1EDA, 0x3DB4, 0x7B68, 0xF6D0 },\n        { 0xB861, 0x60E3, 0xC1C6, 0x93AD, 0x377B, 0x6EF6, 0xDDEC },\n        { 0x45A0, 0x8B40, 0x06A1, 0x0D42, 0x1A84, 0x3508, 0x6A10 },\n        { 0xAA51, 0x4483, 0x8906, 0x022D, 0x045A, 0x08B4, 0x1168 },\n        { 0x76B4, 0xED68, 0xCAF1, 0x85C3, 0x1BA7, 0x374E, 0x6E9C },\n        { 0x3730, 0x6E60, 0xDCC0, 0xA9A1, 0x4363, 0x86C6, 0x1DAD },\n        { 0x3331, 0x6662, 0xCCC4, 0x89A9, 0x0373, 0x06E6, 0x0DCC },\n        { 0x1021, 0x2042, 0x4084, 0x8108, 0x1231, 0x2462, 0x48C4 } };\n    \n    public static int wordPasswordHash(String password)\n    {\n        if( (password == null) || (password.length() == 0) )\n        {\n            return 0x00000000;\n        }\n        // prepare password bytes from unicode string\n        if(password.length() > 15)\n        {\n            password = password.substring(0, 15);\n        }\n        byte[] passwordBytes = new byte[password.length()];\n        for(int i = 0; i < password.length(); i++)\n        {\n            char c = password.charAt(i);\n            byte lowByte = (byte)(c & 0x00FF);\n            if(lowByte != 0)\n            {\n                passwordBytes[i] = lowByte;\n            }\n            else\n            {\n                byte highByte = (byte)((c & 0xFF00) >> 8);\n                passwordBytes[i] = highByte;\n            }\n        }\n        // Compute the high-order word\n        char highOrderWord = initialValue[passwordBytes.length-1];\n        for(int pos = 0; pos < passwordBytes.length; pos++)\n        {\n            int matrixRow = 14 - (passwordBytes.length - 1 - pos);\n            char[] encryptionVector = encryptionMatrix[matrixRow];\n            for(int bitPos = 0; bitPos  < 7; bitPos++)\n            {\n                if((passwordBytes[pos] & (1 << bitPos)) != 0)\n                {\n                    highOrderWord = (char)(highOrderWord ^ encryptionVector[bitPos]);\n                }\n            }\n        }\n        // compute low-order word\n        char lowOrderWord = 0;\n        for(int pos = passwordBytes.length-1; pos >= 0; pos--)\n        {\n            lowOrderWord = (char) ((((lowOrderWord >> 14) & 0x0001) | ((lowOrderWord << 1) & 0x7FFF)) ^ passwordBytes[pos]);\n        }\n        lowOrderWord = (char) ((((lowOrderWord >> 14) & 0x0001) | ((lowOrderWord << 1) & 0x7FFF)) ^ passwordBytes.length ^ 0xCE4B);\n        return (highOrderWord << 16) | lowOrderWord;\n    }\n\n}", "attachment_id": null, "id": 173068, "creator": "stefan.kopf@alfresco.com", "time": "2014-02-17T10:53:49Z", "bug_id": 56076, "creation_time": "2014-02-17T10:53:49Z", "is_private": false}, {"count": 5, "tags": [], "bug_id": 56076, "attachment_id": 31327, "text": "Created attachment 31327\nWorking example\n\nThank you for the example file.\nAfter googling for your documentation/code, I found probably the original sources @ [1]\n\nRunning the C# version side-by-side the Java version, I managed to get the example working.\nBefore I implement it into POI, I'd like to find out what's the meaning of the other cryptAlgorithmSid [2] ... but that won't be tonight anymore ;)\n\n\n[1] http://blogs.msdn.com/b/vsod/archive/2010/04/05/how-to-set-the-editing-restrictions-in-word-using-open-xml-sdk-2-0.aspx\n[2] http://msdn.microsoft.com/en-us/library/ff535662(v=office.12).aspx", "id": 173344, "time": "2014-02-19T00:22:52Z", "creator": "kiwiwings@apache.org", "creation_time": "2014-02-19T00:22:52Z", "is_private": false}, {"count": 6, "tags": [], "bug_id": 56076, "attachment_id": null, "text": "Thanks for the patch.\nApplied with SVN ver r1570750 with quite some changes.", "id": 173427, "time": "2014-02-21T23:25:33Z", "creator": "kiwiwings@apache.org", "creation_time": "2014-02-21T23:25:33Z", "is_private": false}]