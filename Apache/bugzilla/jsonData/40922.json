[{"count": 0, "tags": [], "text": "As of MySQL 5.0 triggers and stored procedures have been introduced. The mysql\ndump syntax uses the DELIMITER command multiple times in a file. \n\nThis patch improves compatibility with MySQL dump in two ways:\n1. It handles the delimiter statement, its just way too much work to work around\nnot having it.\n\n2. It cleanly handles cases when xml <!-- and its comments --> is stored in\nvarchar fields causing the ant interpretation of -- to choke.", "is_private": false, "id": 95546, "creator": "hunterp@deepwebtech.com", "time": "2006-11-07T17:41:58Z", "bug_id": 40922, "creation_time": "2006-11-07T17:41:58Z", "attachment_id": null}, {"count": 1, "tags": [], "bug_id": 40922, "attachment_id": null, "id": 95547, "time": "2006-11-07T17:42:15Z", "creator": "hunterp@deepwebtech.com", "creation_time": "2006-11-07T17:42:15Z", "is_private": false, "text": "Oh and row counting is added from my other patch"}, {"count": 2, "tags": [], "bug_id": 40922, "is_private": false, "text": "Created attachment 19098\ncopy SQLExec.java from ant 1.6.5 with changes to make mysql not fail", "id": 95548, "time": "2006-11-07T17:43:39Z", "creator": "hunterp@deepwebtech.com", "creation_time": "2006-11-07T17:43:39Z", "attachment_id": 19098}, {"count": 3, "tags": [], "text": "Also another reason i removed ant's processing of the -- syntax is because of\nthis  http://dev.mysql.com/doc/refman/5.0/en/ansi-diff-comments.html", "attachment_id": null, "id": 95551, "creator": "hunterp@deepwebtech.com", "time": "2006-11-07T17:50:22Z", "bug_id": 40922, "creation_time": "2006-11-07T17:50:22Z", "is_private": false}, {"count": 4, "tags": [], "text": "Comment on attachment 19098\ncopy SQLExec.java from ant 1.6.5 with changes to make mysql not fail\n\n>package org.apache.tools.ant.taskdefs;\n>\n>/*\n> * Copyright  2000-2005 The Apache Software Foundation\n> *\n> *  Licensed under the Apache License, Version 2.0 (the \"License\");\n> *  you may not use this file except in compliance with the License.\n> *  You may obtain a copy of the License at\n> *\n> *      http://www.apache.org/licenses/LICENSE-2.0\n> *\n> *  Unless required by applicable law or agreed to in writing, software\n> *  distributed under the License is distributed on an \"AS IS\" BASIS,\n> *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n> *  See the License for the specific language governing permissions and\n> *  limitations under the License.\n> *\n> */\n>\n>\n>\n>import java.io.BufferedOutputStream;\n>import java.io.BufferedReader;\n>import java.io.File;\n>import java.io.FileInputStream;\n>import java.io.FileOutputStream;\n>import java.io.FileReader;\n>import java.io.IOException;\n>import java.io.InputStreamReader;\n>import java.io.PrintStream;\n>import java.io.Reader;\n>import java.io.StringReader;\n>import java.sql.Connection;\n>import java.sql.ResultSet;\n>import java.sql.ResultSetMetaData;\n>import java.sql.SQLException;\n>import java.sql.SQLWarning;\n>import java.sql.Statement;\n>import java.util.Enumeration;\n>import java.util.StringTokenizer;\n>import java.util.Vector;\n>\n>import org.apache.tools.ant.BuildException;\n>import org.apache.tools.ant.DirectoryScanner;\n>import org.apache.tools.ant.Project;\n>import org.apache.tools.ant.taskdefs.JDBCTask;\n>import org.apache.tools.ant.types.EnumeratedAttribute;\n>import org.apache.tools.ant.types.FileSet;\n>\n>/**\n> * Copied from ant's 1.6.5 SQLExec.java\n> * Executes a series of SQL statements on a database using JDBC.\n> *\n> * <p>Statements can\n> * either be read in from a text file using the <i>src</i> attribute or from\n> * between the enclosing SQL tags.</p>\n> *\n> * <p>Multiple statements can be provided, separated by semicolons (or the\n> * defined <i>delimiter</i>). Individual lines within the statements can be\n> * commented using either --, // or REM at the start of the line.</p>\n> *\n> * <p>The <i>autocommit</i> attribute specifies whether auto-commit should be\n> * turned on or off whilst executing the statements. If auto-commit is turned\n> * on each statement will be executed and committed. If it is turned off the\n> * statements will all be executed as one transaction.</p>\n> *\n> * <p>The <i>onerror</i> attribute specifies how to proceed when an error occurs\n> * during the execution of one of the statements.\n> * The possible values are: <b>continue</b> execution, only show the error;\n> * <b>stop</b> execution and commit transaction;\n> * and <b>abort</b> execution and transaction and fail task.</p>\n> *\n> * @since Ant 1.2\n> *\n> * @ant.task name=\"sql\" category=\"database\"\n> */\n>public class MySQLExec extends JDBCTask {\n>\n>    /**\n>     * delimiters we support, \"normal\" and \"row\"\n>     */\n>    public static class DelimiterType extends EnumeratedAttribute {\n>        public static final String NORMAL = \"normal\";\n>        public static final String ROW = \"row\";\n>        public String[] getValues() {\n>            return new String[] {NORMAL, ROW};\n>        }\n>    }\n>\n>\n>\n>    private int goodSql = 0;\n>\n>    private int totalSql = 0;\n>\n>    /**\n>     * Database connection\n>     */\n>    private Connection conn = null;\n>\n>    /**\n>     * files to load\n>     */\n>    private Vector filesets = new Vector();\n>\n>    /**\n>     * SQL statement\n>     */\n>    private Statement statement = null;\n>\n>    /**\n>     * SQL input file\n>     */\n>    private File srcFile = null;\n>\n>    /**\n>     * SQL input command\n>     */\n>    private String sqlCommand = \"\";\n>\n>    /**\n>     * SQL transactions to perform\n>     */\n>    private Vector transactions = new Vector();\n>\n>    /**\n>     * SQL Statement delimiter\n>     */\n>    private String delimiter = \";\";\n>\n>    /**\n>     * The delimiter type indicating whether the delimiter will\n>     * only be recognized on a line by itself\n>     */\n>    private String delimiterType = DelimiterType.NORMAL;\n>\n>    /**\n>     * Print SQL results.\n>     */\n>    private boolean print = false;\n>\n>    /**\n>     * Print header columns.\n>     */\n>    private boolean showheaders = true;\n>\n>    /**\n>     * Results Output file.\n>     */\n>    private File output = null;\n>    \n>    /**\n>     * Property that receives the number of rows returned\n>     */\n>    private String rowCountProp = null;\n>    \n>    /**\n>     * Action to perform if an error is found\n>     **/\n>    private String onError = \"abort\";\n>\n>    /**\n>     * Encoding to use when reading SQL statements from a file\n>     */\n>    private String encoding = null;\n>\n>    /**\n>     * Append to an existing file or overwrite it?\n>     */\n>    private boolean append = false;\n>\n>    /**\n>     * Keep the format of a sql block?\n>     */\n>    private boolean keepformat = false;\n>\n>    /**\n>     * Argument to Statement.setEscapeProcessing\n>     *\n>     * @since Ant 1.6\n>     */\n>    private boolean escapeProcessing = true;\n>\n>    /**\n>     * Set the name of the SQL file to be run.\n>     * Required unless statements are enclosed in the build file\n>     */\n>    public void setSrc(File srcFile) {\n>        this.srcFile = srcFile;\n>    }\n>\n>    /**\n>     * Set an inline SQL command to execute.\n>     * NB: Properties are not expanded in this text.\n>     */\n>    public void addText(String sql) {\n>        this.sqlCommand += sql;\n>    }\n>\n>    /**\n>     * Adds a set of files (nested fileset attribute).\n>     */\n>    public void addFileset(FileSet set) {\n>        filesets.addElement(set);\n>    }\n>\n>\n>    /**\n>     * Add a SQL transaction to execute\n>     */\n>    public Transaction createTransaction() {\n>        Transaction t = new Transaction();\n>        transactions.addElement(t);\n>        return t;\n>    }\n>\n>    /**\n>     * Set the file encoding to use on the SQL files read in\n>     *\n>     * @param encoding the encoding to use on the files\n>     */\n>    public void setEncoding(String encoding) {\n>        this.encoding = encoding;\n>    }\n>\n>    /**\n>     * Set the delimiter that separates SQL statements. Defaults to &quot;;&quot;;\n>     * optional\n>     *\n>     * <p>For example, set this to \"go\" and delimitertype to \"ROW\" for\n>     * Sybase ASE or MS SQL Server.</p>\n>     */\n>    public void setDelimiter(String delimiter) {\n>        this.delimiter = delimiter;\n>    }\n>\n>    /**\n>     * Set the delimiter type: \"normal\" or \"row\" (default \"normal\").\n>     *\n>     * <p>The delimiter type takes two values - normal and row. Normal\n>     * means that any occurrence of the delimiter terminate the SQL\n>     * command whereas with row, only a line containing just the\n>     * delimiter is recognized as the end of the command.</p>\n>     */\n>    public void setDelimiterType(DelimiterType delimiterType) {\n>        this.delimiterType = delimiterType.getValue();\n>    }\n>\n>    /**\n>     * Print result sets from the statements;\n>     * optional, default false\n>     */\n>    public void setPrint(boolean print) {\n>        this.print = print;\n>    }\n>\n>    /**\n>     * Print headers for result sets from the\n>     * statements; optional, default true.\n>     */\n>    public void setShowheaders(boolean showheaders) {\n>        this.showheaders = showheaders;\n>    }\n>\n>    /**\n>     * Set the output file;\n>     * optional, defaults to the Ant log.\n>     */\n>    public void setOutput(File output) {\n>        this.output = output;\n>    }\n>    /**\n>     *  @param rowCountProp\n>     * Sets a given property (overwriting if set) to the number of rows in \n>     * the last most statement \n>     */\n>    \n>    public void setRowCountProperty(String rowCountProp) {\n>        this.rowCountProp = rowCountProp;\n>    }\n>    /**\n>     * whether output should be appended to or overwrite\n>     * an existing file.  Defaults to false.\n>     *\n>     * @since Ant 1.5\n>     */\n>    public void setAppend(boolean append) {\n>        this.append = append;\n>    }\n>\n>\n>    /**\n>     * Action to perform when statement fails: continue, stop, or abort\n>     * optional; default &quot;abort&quot;\n>     */\n>    public void setOnerror(OnError action) {\n>        this.onError = action.getValue();\n>    }\n>\n>    /**\n>     * whether or not format should be preserved.\n>     * Defaults to false.\n>     *\n>     * @param keepformat The keepformat to set\n>     */\n>    public void setKeepformat(boolean keepformat) {\n>        this.keepformat = keepformat;\n>    }\n>\n>    /**\n>     * Set escape processing for statements.\n>     *\n>     * @since Ant 1.6\n>     */\n>    public void setEscapeProcessing(boolean enable) {\n>        escapeProcessing = enable;\n>    }\n>\n>    /**\n>     * Load the sql file and then execute it\n>     */\n>    public void execute() throws BuildException {\n>        Vector savedTransaction = (Vector) transactions.clone();\n>        String savedSqlCommand = sqlCommand;\n>\n>        sqlCommand = sqlCommand.trim();\n>\n>        try {\n>            if (srcFile == null && sqlCommand.length() == 0\n>                && filesets.isEmpty()) {\n>                if (transactions.size() == 0) {\n>                    throw new BuildException(\"Source file or fileset, \"\n>                                             + \"transactions or sql statement \"\n>                                             + \"must be set!\", getLocation());\n>                }\n>            }\n>\n>            if (srcFile != null && !srcFile.exists()) {\n>                throw new BuildException(\"Source file does not exist!\", getLocation());\n>            }\n>\n>            // deal with the filesets\n>            for (int i = 0; i < filesets.size(); i++) {\n>                FileSet fs = (FileSet) filesets.elementAt(i);\n>                DirectoryScanner ds = fs.getDirectoryScanner(getProject());\n>                File srcDir = fs.getDir(getProject());\n>\n>                String[] srcFiles = ds.getIncludedFiles();\n>\n>                // Make a transaction for each file\n>                for (int j = 0; j < srcFiles.length; j++) {\n>                    Transaction t = createTransaction();\n>                    t.setSrc(new File(srcDir, srcFiles[j]));\n>                }\n>            }\n>\n>            // Make a transaction group for the outer command\n>            Transaction t = createTransaction();\n>            t.setSrc(srcFile);\n>            t.addText(sqlCommand);\n>            conn = getConnection();\n>            if (!isValidRdbms(conn)) {\n>                return;\n>            }\n>            try {\n>                statement = conn.createStatement();\n>                statement.setEscapeProcessing(escapeProcessing);\n>\n>                PrintStream out = System.out;\n>                try {\n>                    if (output != null) {\n>                        log(\"Opening PrintStream to output file \" + output,\n>                            Project.MSG_VERBOSE);\n>                        out = new PrintStream(\n>                                  new BufferedOutputStream(\n>                                      new FileOutputStream(output\n>                                                           .getAbsolutePath(),\n>                                                           append)));\n>                    }\n>\n>                    // Process all transactions\n>                    for (Enumeration e = transactions.elements();\n>                         e.hasMoreElements();) {\n>\n>                        ((Transaction) e.nextElement()).runTransaction(out);\n>                        if (!isAutocommit()) {\n>                            log(\"Committing transaction\", Project.MSG_VERBOSE);\n>                            conn.commit();\n>                        }\n>                    }\n>                } finally {\n>                    if (out != null && out != System.out) {\n>                        out.close();\n>                    }\n>                }\n>            } catch (IOException e) {\n>                if (!isAutocommit() && conn != null && onError.equals(\"abort\")) {\n>                    try {\n>                        conn.rollback();\n>                    } catch (SQLException ex) {\n>                        // ignore\n>                    }\n>                }\n>                throw new BuildException(e, getLocation());\n>            } catch (SQLException e) {\n>                if (!isAutocommit() && conn != null && onError.equals(\"abort\")) {\n>                    try {\n>                        conn.rollback();\n>                    } catch (SQLException ex) {\n>                        // ignore\n>                    }\n>                }\n>                throw new BuildException(e, getLocation());\n>            } finally {\n>                try {\n>                    if (statement != null) {\n>                        statement.close();\n>                    }\n>                    if (conn != null) {\n>                        conn.close();\n>                    }\n>                } catch (SQLException ex) {\n>                    // ignore\n>                }\n>            }\n>\n>            log(goodSql + \" of \" + totalSql\n>                + \" SQL statements executed successfully\");\n>        } finally {\n>            transactions = savedTransaction;\n>            sqlCommand = savedSqlCommand;\n>        }\n>    }\n>\n>    /**\n>     * read in lines and execute them\n>     */\n>    protected void runStatements(Reader reader, PrintStream out)\n>        throws SQLException, IOException {\n>        StringBuffer sql = new StringBuffer();\n>        String line = \"\";\n>\n>        BufferedReader in = new BufferedReader(reader);\n>\n>        while ((line = in.readLine()) != null) {\n>            if (!keepformat) {\n>                line = line.trim();\n>            }\n>            line = getProject().replaceProperties(line);\n>            if (!keepformat) {\n>                if (line.startsWith(\"//\")) {\n>                    continue;\n>                }\n>                if (line.startsWith(\"--\")) {\n>                    continue;\n>                }\n>                //Handle MySQL specific lines that begin with DELIMITER \n>                if(line.length() > 8) {\n>                    if (line.substring(0,9).equalsIgnoreCase(\"DELIMITER\")) {\n>                        StringTokenizer st = new StringTokenizer(line);\n>                        st.nextToken(); //get past DELIMITER\n>                        String newDelim = st.nextToken();\n>                        delimiter=newDelim;\n>                        continue;\n>                    }\n>                }\n>\n>                StringTokenizer st = new StringTokenizer(line);\n>                if (st.hasMoreTokens()) {\n>                    String token = st.nextToken();\n>                    if (\"REM\".equalsIgnoreCase(token)) {\n>                        continue;\n>                    }\n>                }\n>            }\n>\n>            if (!keepformat) {\n>                sql.append(\" \" + line);\n>            } else {\n>                sql.append(\"\\n\" + line);\n>            }\n>            \n>            // SQL defines \"--\" as a comment to EOL. But mysql doesnt so do nothing.\n>\n>            if ((delimiterType.equals(DelimiterType.NORMAL)\n>                 && sql.toString().endsWith(delimiter))\n>                ||\n>                (delimiterType.equals(DelimiterType.ROW)\n>                 && line.equals(delimiter))) {\n>                execSQL(sql.substring(0, sql.length() - delimiter.length()),\n>                        out);\n>                sql.replace(0, sql.length(), \"\");\n>            }\n>        }\n>        // Catch any statements not followed by ;\n>        if (!sql.equals(\"\")) {\n>            execSQL(sql.toString(), out);\n>        }\n>    }\n>\n>\n>    /**\n>     * Exec the sql statement.\n>     */\n>    protected void execSQL(String sql, PrintStream out) throws SQLException {\n>        // Check and ignore empty statements\n>        if (\"\".equals(sql.trim())) {\n>            return;\n>        }\n>\n>        ResultSet resultSet = null;\n>        try {\n>            totalSql++;\n>            log(\"SQL: \" + sql, Project.MSG_VERBOSE);\n>\n>            boolean ret;\n>            int updateCount = 0, updateCountTotal = 0;\n>\n>            ret = statement.execute(sql);\n>            updateCount = statement.getUpdateCount();\n>            resultSet = statement.getResultSet();\n>            do {\n>                if (!ret) {\n>                    if (updateCount != -1) {\n>                        updateCountTotal += updateCount;\n>                    }\n>                } else {\n>          \n>                    if (print) {\n>                        printResults(resultSet, out);\n>                    }\n>                    else if (rowCountProp != null) {\n>                        countResults(resultSet);\n>                    }\n>                }\n>                ret = statement.getMoreResults();\n>                if (ret) {\n>                    updateCount = statement.getUpdateCount();\n>                    resultSet = statement.getResultSet();\n>                }\n>            } while (ret);\n>\n>            log(updateCountTotal + \" rows affected\",\n>                Project.MSG_VERBOSE);\n>            \n>\n>            \n>            if (print) {\n>                StringBuffer line = new StringBuffer();\n>                line.append(updateCountTotal + \" rows affected\");\n>                out.println(line);\n>            }\n>\n>            SQLWarning warning = conn.getWarnings();\n>            while (warning != null) {\n>                log(warning + \" sql warning\", Project.MSG_VERBOSE);\n>                warning = warning.getNextWarning();\n>            }\n>            conn.clearWarnings();\n>            goodSql++;\n>        } catch (SQLException e) {\n>            log(\"Failed to execute: \" + sql, Project.MSG_ERR);\n>            if (!onError.equals(\"continue\")) {\n>                throw e;\n>            }\n>            log(e.toString(), Project.MSG_ERR);\n>        } finally {\n>            if (resultSet != null) {\n>                resultSet.close();\n>            }\n>        }\n>    }\n>\n>    /**\n>     * print any results in the statement\n>     * @deprecated use {@link #printResults(java.sql.ResultSet, java.io.PrintStream)\n>     *             the two arg version} instead.\n>     * @param out the place to print results\n>     * @throws SQLException on SQL problems.\n>     */\n>    protected void printResults(PrintStream out) throws SQLException {\n>        ResultSet rs = null;\n>        rs = statement.getResultSet();\n>        try {\n>            printResults(rs, out);\n>        } finally {\n>            if (rs != null) {\n>                rs.close();\n>            }\n>        }\n>    }\n>\n>    /**\n>     * print any results in the result set.\n>     * @param rs the resultset to print information about\n>     * @param out the place to print results\n>     * @throws SQLException on SQL problems.\n>     * @since Ant 1.6.3\n>     */\n>    protected void printResults(ResultSet rs, PrintStream out) throws SQLException {\n>        int rowCount =0;\n>        if (rs != null) {\n>            log(\"Processing new result set.\", Project.MSG_VERBOSE);\n>            ResultSetMetaData md = rs.getMetaData();\n>            int columnCount = md.getColumnCount();\n>            StringBuffer line = new StringBuffer();\n>            if (showheaders) {\n>                for (int col = 1; col < columnCount; col++) {\n>                     line.append(md.getColumnName(col));\n>                     line.append(\",\");\n>                }\n>                line.append(md.getColumnName(columnCount));\n>                out.println(line);\n>                line = new StringBuffer();\n>            }\n>            while (rs.next()) {\n>                rowCount++;\n>                boolean first = true;\n>                for (int col = 1; col <= columnCount; col++) {\n>                    String columnValue = rs.getString(col);\n>                    if (columnValue != null) {\n>                        columnValue = columnValue.trim();\n>                    }\n>\n>                    if (first) {\n>                        first = false;\n>                    } else {\n>                        line.append(\",\");\n>                    }\n>                    line.append(columnValue);\n>                }\n>                out.println(line);\n>                line = new StringBuffer();\n>            }\n>        }\n>        if (rowCountProp != null) {\n>            getProject().setProperty(rowCountProp,Integer.toString(rowCount));\n>        }\n>        out.println();\n>    }\n>    /**\n>     * \n>     * @param rs ResultSet\n>     * @throws SQLException\n>     *  \n>     * Sets the rowCountProp in the case that printing isnt selected\n>     */\n>    protected void countResults(ResultSet rs) throws SQLException {\n>        int rowCount =0;\n>        if (rs != null) {\n>            log(\"Processing new result set.\", Project.MSG_VERBOSE);\n>            while (rs.next()) {\n>                rowCount++;\n>            }\n>        }\n>        if (rowCountProp != null) {\n>            getProject().setProperty(rowCountProp,Integer.toString(rowCount));\n>        }\n>    }\n>    /**\n>     * The action a task should perform on an error,\n>     * one of \"continue\", \"stop\" and \"abort\"\n>     */\n>    public static class OnError extends EnumeratedAttribute {\n>        public String[] getValues() {\n>            return new String[] {\"continue\", \"stop\", \"abort\"};\n>        }\n>    }\n>\n>    /**\n>     * Contains the definition of a new transaction element.\n>     * Transactions allow several files or blocks of statements\n>     * to be executed using the same JDBC connection and commit\n>     * operation in between.\n>     */\n>    public class Transaction {\n>        private File tSrcFile = null;\n>        private String tSqlCommand = \"\";\n>\n>        /**\n>         *\n>         */\n>        public void setSrc(File src) {\n>            this.tSrcFile = src;\n>        }\n>\n>        /**\n>         *\n>         */\n>        public void addText(String sql) {\n>            this.tSqlCommand += sql;\n>        }\n>\n>        /**\n>         *\n>         */\n>        private void runTransaction(PrintStream out)\n>            throws IOException, SQLException {\n>            if (tSqlCommand.length() != 0) {\n>                log(\"Executing commands\", Project.MSG_INFO);\n>                runStatements(new StringReader(tSqlCommand), out);\n>            }\n>\n>            if (tSrcFile != null) {\n>                log(\"Executing file: \" + tSrcFile.getAbsolutePath(),\n>                    Project.MSG_INFO);\n>                Reader reader =\n>                    (encoding == null) ? new FileReader(tSrcFile)\n>                                       : new InputStreamReader(\n>                                             new FileInputStream(tSrcFile),\n>                                             encoding);\n>                try {\n>                    runStatements(reader, out);\n>                } finally {\n>                    reader.close();\n>                }\n>            }\n>        }\n>    }\n>\n>}", "attachment_id": 19098, "bug_id": 40922, "id": 95552, "time": "2006-11-07T17:54:42Z", "creator": "hunterp@deepwebtech.com", "creation_time": "2006-11-07T17:54:42Z", "is_private": false}]