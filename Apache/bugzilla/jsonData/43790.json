[{"count": 0, "tags": [], "bug_id": 43790, "attachment_id": null, "is_private": false, "id": 110208, "time": "2007-11-03T07:09:17Z", "creator": "michael.mao@achievo.com", "creation_time": "2007-11-03T07:09:17Z", "text": "when doing performance test, i found the concurrent acess lock issue about JSP \ntag. Many threads are waiting for TagHandlerPool object, such as \nTagHandlerPool.reuse, TagHandlerPool.get. \nIn TagHandlerPool and PerThreadTagHandlerPool class, object pool was used, but \nits synchronization cause the thread waiting/lock issue when a lot of JSP tags \nare using. Later, I test a ThreadLocal based TagHandler object instead of \nTagHandlerPool, the response time was reduced to 5s from 30s against 50 \nconcurrent user. \nAs a suggestion, please remove object pool to replace with simple ThreadLocal \nsolution. The same issues exist both Tomcat 5.X and 6.0."}, {"count": 1, "attachment_id": null, "bug_id": 43790, "is_private": false, "id": 112372, "time": "2008-01-01T09:44:21Z", "creator": "markt@apache.org", "creation_time": "2008-01-01T09:44:21Z", "tags": [], "text": "I am marking this as an enhancement.\n\nCould you clarify how your solution is different to the PerThreadTagHandlerPool?\n\nIf you attach our proposed solution to this bug then it will be reviewed for\ninclusion."}, {"count": 2, "tags": [], "creator": "michael.mao@achievo.com", "attachment_id": null, "text": "(In reply to comment #1)\n> I am marking this as an enhancement.\n> Could you clarify how your solution is different to the \nPerThreadTagHandlerPool?\n> If you attach our proposed solution to this bug then it will be reviewed for\n> inclusion.\n\nWith threadLocal variable, we don't need to create object pool again.\nThere is the following code snippet for your reference.\n    private ThreadLocal<Tag> perThread = new ThreadLocal<Tag>();\n    protected void init(ServletConfig config) \n    {\n    }\n    public Tag get(Class handlerClass) throws JspException \n    {\n    \tTag jspTag = perThread.get();\n    \tif (jspTag == null)\n    \t{\n            try \n            {\n            \tjspTag = (Tag) handlerClass.newInstance();\n            \tperThread.set(jspTag);\n            } \n            catch (Exception e) \n            {\n                throw new JspException(e.getMessage(), e);\n            }\n\t\t}\n    \telse\n    \t{\n    \t\t//System.out.println(\"Reset tag:\" + handlerClass);\n    \t\tjspTag.release();\n    \t}\n    \treturn jspTag;\n    }\n    public void reuse(Tag handler) \n    {\n    \t//Do nothing.\n    }\n    public void release() \n    {\n    \t//Do nothing.\n    }\n", "id": 112726, "time": "2008-01-10T03:25:01Z", "bug_id": 43790, "creation_time": "2008-01-10T03:25:01Z", "is_private": false}, {"count": 3, "tags": [], "text": "Created attachment 21404\nSimple threadLocal based TagHandler", "is_private": false, "id": 112977, "creator": "michael.mao@achievo.com", "time": "2008-01-18T01:37:15Z", "bug_id": 43790, "creation_time": "2008-01-18T01:37:15Z", "attachment_id": 21404}, {"count": 4, "tags": [], "bug_id": 43790, "attachment_id": null, "id": 147301, "time": "2011-06-20T23:01:48Z", "creator": "markt@apache.org", "creation_time": "2011-06-20T23:01:48Z", "is_private": false, "text": "ThreadLocal isn't the way to do this. That is likely to trigger memory leaks.\n\nA better solution would be to replace the syncs in the TagHandlerPool with a solution based on a LinkedBlockingQueue.\n\nThe PerThreadTagHandlerPool needs to be deprecated."}, {"count": 5, "tags": [], "creator": "markt@apache.org", "attachment_id": 27184, "text": "Created attachment 27184\nPatche based on LinkedBlockingQueue\n\nWhile switching to LinkedBlockingQueue allows concurrent get and reuse, that appears to be balanced by the additional complexity over the current implementation.\n\nTesting with JMeter showed no measurable performance benefit of the current implementation over the patch. I have attached the patch for future reference.\n\nI would like to see a test case that demonstrates a clear performance benefit before applying this or any other patch.", "id": 147302, "time": "2011-06-21T00:28:33Z", "bug_id": 43790, "creation_time": "2011-06-21T00:28:33Z", "is_private": false}, {"count": 6, "tags": [], "text": "Comment on attachment 21404\nSimple threadLocal based TagHandler\n\nThreadLocal is not an option due to the memory leaks it triggers.", "is_private": false, "id": 147303, "creator": "markt@apache.org", "time": "2011-06-21T00:28:59Z", "bug_id": 43790, "creation_time": "2011-06-21T00:28:59Z", "attachment_id": 21404}, {"count": 7, "tags": [], "bug_id": 43790, "attachment_id": null, "id": 147304, "time": "2011-06-21T00:33:04Z", "creator": "markt@apache.org", "creation_time": "2011-06-21T00:33:04Z", "is_private": false, "text": "ThreadLocals aren't an option, LinkedBlockingQueue appears to provide no performance benefit, the current code is fairly efficient given the constraints it has to work with and there is no obvious, safe way to speed this up so resolving as WONTFIX. It can always be re-opened if a potential test case and patch is identified."}, {"count": 8, "tags": [], "bug_id": 43790, "attachment_id": null, "id": 155117, "time": "2012-03-20T14:57:07Z", "creator": "ian.hartney@gmail.com", "creation_time": "2012-03-20T14:57:07Z", "is_private": false, "text": "There does appear to be a concurrency issue with the synchronized block approach when using Java 5.  However in Java 6 the synchronized block approach appears faster than the LinkedBlockingQueue approach.\n\nI have a little test harness that used 250 threads to concurrently access a queue in the same manner as the TagPoolHandler.  Each loop does a get of an object, then a reuse call on the object 10000 times.  It runs the same test using the synchronized block approach, then another using the LinkedBlockingQueue (LBQ) approach.\n\nOn Java 5 the test takes around 11000 ms to complete for the synchronized block approach, the LBQ approach takes 700 ms.  Conversely on Java 6 the synchronized block approach is much improved, taking around 450 ms whereas the LBQ approach takes 750 ms.\n\nSo when using Java 5 it does appear that the LBQ approach has some significant performance advantages to the synchronized block approach.\n\nThe tested versions of java were 1.5.0_22 and 1.6.0_23"}]