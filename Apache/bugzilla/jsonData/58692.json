[{"count": 0, "tags": [], "bug_id": 58692, "attachment_id": 33326, "is_private": false, "id": 186799, "time": "2015-12-04T23:40:41Z", "creator": "derek.abdine@gmail.com", "creation_time": "2015-12-04T23:40:41Z", "text": "Created attachment 33326\nTest class for StandardJarScanner\n\nAn application was created with Tomcat 8 and Apache Felix both embedded on the same JVM. Apache felix happens to add a URL to the application classloader's classpath via it's extension manager, which is used to support bundle fragment/extension features of the OSGi spec:\n\nhttps://github.com/apache/felix/blob/ac5ec40ee40ec92dc8124e22afa855ab2c4a850f/framework/src/main/java/org/apache/felix/framework/ExtensionManager.java#L106\n\nWhen Tomcat is started on the same JVM and a context is created, Tomcat will attempt to perform a jar scan on the classloader's classpath. It will call getURLs to enumerate all classpath URLs and peek inside for pluggability purposes:\n\nhttps://github.com/apache/tomcat/blob/trunk/java/org/apache/tomcat/util/scan/StandardJarScanner.java#L221\n\nFor each URL enumerated from the classloader Tomcat attempts to transform it into a ClassPathEntry. For the special URL that Apache Felix adds, ClassPathEntry's getName method will return the empty string, as there is no file part in the URL itself:\n\nhttps://github.com/apache/tomcat/blob/trunk/java/org/apache/tomcat/util/scan/StandardJarScanner.java#L353\n\nThere is no way to prevent this issue with a JarScanFilter, since the check method called here will use the empty string file name, which can't be matched using the glob matching algorithm:\n\nhttps://github.com/apache/tomcat/blob/trunk/java/org/apache/tomcat/util/scan/StandardJarScanner.java#L237\n\nEventually this falls through to the process() method through this call:\nhttps://github.com/apache/tomcat/blob/trunk/java/org/apache/tomcat/util/scan/StandardJarScanner.java#L244\n\nSince the URL \"http://felix.extensions:9/\" has a compatible scheme (http) but no file part (it doesn't match the jar extension) we fall through to the else condition in the process method, which will attempt to call new File(new URL(\"http://felix.extensions:9\")) and fail, because the File(URL) constructor requires that the URL start with \"file:/\":\n\nhttps://github.com/apache/tomcat/blob/trunk/java/org/apache/tomcat/util/scan/StandardJarScanner.java#L317\n\nThis has the effect of bailing out the entire webapp loading.\n\nSteps to reproduce:\nI've created a test case which demonstrates the bug. I added this test case to TestStandardJarScanner to validate against 9.0 TRUNK, though the original bug was found on tomcat 8x.\n\nFor convenience i've attached a copy of the test class with this test case embedded in it.\n\n    /**\n     * Tomcat should ignore URLs which do not have a file part and do not use the file scheme.\n     */\n    @Test\n    public void skipsInvalidClasspathURLNoFilePartNoFileScheme() {\n        StandardJarScanner scanner = new StandardJarScanner();\n        LoggingCallback callback = new LoggingCallback();\n        TesterServletContext context = new TesterServletContext() {\n            @Override\n            public ClassLoader getClassLoader() {\n                URLClassLoader urlClassLoader;\n                try\n                {\n                    urlClassLoader = new URLClassLoader(new URL[] { new URL(\"http://felix.extensions:9/\") });\n                }\n                catch (MalformedURLException e)\n                {\n                    throw new RuntimeException(e);\n                }\n                return urlClassLoader;\n            }\n        };\n        scanner.scan(JarScanType.PLUGGABILITY, context, callback);\n    }\n\nWORKAROUNDS:\n1. Disable classpath scanning in context.xml. This is a bit cumbersome for war files which contain their own context.xml as it requires a rebuild of all those downstream modules.\n2. Add a LifecycleListener to hook into context creation events before they are initialized and set the jar filter to ignore empty string file names (due to the missing file name part of the class path entry)."}, {"count": 1, "tags": [], "bug_id": 58692, "text": "Here's the stack trace from the attached test case / unit test:\njava.lang.IllegalArgumentException: URI scheme is not \"file\"\n\tat java.io.File.<init>(File.java:421)\n\tat org.apache.tomcat.util.scan.StandardJarScanner.process(StandardJarScanner.java:317)\n\tat org.apache.tomcat.util.scan.StandardJarScanner.scan(StandardJarScanner.java:244)\n\tat org.apache.tomcat.util.scan.TestStandardJarScanner.test(TestStandardJarScanner.java:83)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:483)\n\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)\n\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)\n\tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n\tat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:675)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)", "id": 186800, "time": "2015-12-04T23:43:00Z", "creator": "derek.abdine@gmail.com", "creation_time": "2015-12-04T23:43:00Z", "is_private": false, "attachment_id": null}, {"count": 2, "tags": [], "bug_id": 58692, "attachment_id": null, "id": 186801, "time": "2015-12-04T23:44:46Z", "creator": "derek.abdine@gmail.com", "creation_time": "2015-12-04T23:44:46Z", "is_private": false, "text": "Just a slight correction: I mentioned in the description\n\n   \"There is no way to prevent this issue with a JarScanFilter\"\n\nJust to clarify, there is no way to prevent this with the built in StandardJarScanFilter. As the workaround states, you can subclass and create your own to do this."}, {"count": 3, "tags": [], "bug_id": 58692, "attachment_id": null, "is_private": false, "id": 186989, "time": "2015-12-16T21:03:22Z", "creator": "markt@apache.org", "creation_time": "2015-12-16T21:03:22Z", "text": "Thanks for the report and the test case. It made investigating this really simple.\n\nThe fix and test case have been applied to 9.0.x and 8.0.x. Just the fix was applied to 7.0.x due to the refactoring of StandardJarScanner that took place between 7.0.x and 8.0.x."}]