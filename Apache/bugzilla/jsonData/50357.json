[{"count": 0, "tags": [], "bug_id": 50357, "attachment_id": null, "text": "Hi.\n\nAs far as I understand RFC 2161 allow:\n- exactly one Content-Type (optionally with params like charset), describing the actual data\n- Content-Language, describing the actual data\n- one or more Content-Encodings, describing the encodings of the actual data\n\nThus e.g.:\n- x.pdf.html => should be just type text/html\n- x.gz.Z => should have _no_ type (or application/octet-stream) and encoding \"gzip, compress\"\n- x.html.gz.Z => should have type text/html and encoding \"gzip, compress\"\n- x.html.Z.gz => should have type text/html and encoding \"compress, gzip\"\n\nIMHO the following should also be right:\n- x.gz.Z.html => should have type text/html and _no_ encoding\n- x.Z.gz.html => should have type text/html and _no_ encoding\n\nWith the current way how the Add* directives from mod_mime work, even when used together with <Files> and/or <FilesMatch> it's nearly impossible to implement this correctly, aspecially when considering crazy things like:\nx.Z.gz.html.gz.Z.gz.gz\n(which should be IMHO type text/html + encoding \"gzip, compress, gzip, gzip\")\n\n\nAs far as I can see, things like \"x.pdf.html\" are already handled correctly, as the most right type takes precedence,...\nHow ever, currently, with having:\nAddEncoding compress Z\nAddEncoding compress gz\none would get\n\"compress, gzip, gzip, compress, gzip, gzip\" in th above example, instead of:\n\"                gzip, compress, gzip, gzip\"\n\nSo IMHO, a possible solution would be, that AddEncoding matches only such extensions, after the last (most right) extension that is identified as type extension.\n\n\nI'm however not sure how to best handle charset and language with this.\nProbably on should simply allow them at any position, so that we'd get the following to match:\n\nname.(lang|charset)*.(type)*.(lang|charset)*.(encoding)*\n\nwith * = zero or more\n\nWhich should mena:\n- type = the most right defined type at allowed positions from above\n- charset = the most right defined charset at allowed positions from above\n- lang = all langs from the allowed positions above, in that order\n- encoding = all encodings from the allowed positions above, in that order\n\n\nAs I already describe in #50356 we currently also map files like:\n\".html\" (I do mean \"^.html$ - exactly that name) to type \"text/html\", but not files of them name \"html\", right?\n\nIMHO even the former case, \".html\" should _not_ be matched.\nSo I propose, that the definition of \"name\" from above is (in regular expression):\n*$\nmeaning, any number of characters but at least one.\n\n\n\nmod_mime_magic should be adapted as required.\n\n\nWhat do you think?", "id": 142075, "time": "2010-11-28T16:56:24Z", "creator": "calestyo@scientia.net", "creation_time": "2010-11-28T16:56:24Z", "is_private": false}, {"count": 1, "attachment_id": null, "bug_id": 50357, "is_private": false, "id": 142079, "time": "2010-11-28T17:42:07Z", "creator": "calestyo@scientia.net", "creation_time": "2010-11-28T17:42:07Z", "tags": [], "text": "IMHO the best way to implement this is by adding a new directive which allows to set a format string\" that defines how matching is done.\nThe default string could be one which is just equal to the current behaviour off matching anything at any position.\n\nMaybe something like this:\n1) ExtensionsMatchFormat \"formatstring\"\n\nWhere formatstring is a PCRE with the following additional special symbols:\n\n%t = _one_ previously defined type\n%c = _one_ previously defined charset\n%e = _one_ previously defined encoding\n%l = _one_ previously defined language\n%h = _one_ previously defined handler\n%i = _one_ previously defined input filter\n%o = _one_ previously defined output filter\n\nCurrently this is, as far as I can see, something like this:\n(?i)(.%t|.%c|.%e|.%l|.%h|.%i|.%o)*\nmeaning, any number of extensions of any given type at any position.\n\nNote that this allows to change the separation character (\".\"), and to make it case-insensitive or not.\n\n\n2) One needs further Directives which specify which matches are to be used.\nExamples for type, charset, encoding, language could be:\n\nTypeMatch formatstring1 formatstring2\nCharsetMatch formatstring1 formatstring2\n...\nwhere:\nformatstring1 determines which of the %t's (extensions-groups) from above to use with formatstring2, with:\n\\* => Use all\n\\n => Use the n-th one\ne.g. in \"(?i)(.%t|.%c|.%e|.%l|.%h|.%i|.%o)*\" from above:\nTypesMatch \"\\*\" ...\nwould mean, consider all (valid) %t-groups with when matching formatstring2\nTypesMatch \"\\1\\3\" ...\nwould mean, consider the (valid) 1st and the (valid) 3rd when matching formatstring2\nSo \".pdf.gz.html.Z.png.Z.Z.txt\" would yield the following:\nwith \"\\*\": \".pdf.html.png.txt\"\nwith \"\\1\\3\" \".pdf.png\"\n\nformatstring2 decides which of the result from formatstring1 should be actually and finally be used, with (again some kind of a PCRE):\n\"*\" => use all\n\"($U)\\.*$\" => use the last (most right) extension (I hope my ungreedy PCRE is correct)\n\n\n\n\nSo my proposal from comment #1 could look like the following (I hope my PCREs are correct ;) ):\nExtensionsMatchFormat \"^.*.+(\\.%l|\\.%c)*(\\.%t)*(\\.%l|\\.%c)*(\\.%e)*$\"\n\n\nTypesMatch \"\\*\" \"($U)\\.*$\"\n=> concatenate all %t-groups\n=> take the last one form them\n\nCharsetMatch \"\\*\" \"($U)\\.*$\"\n=> concatenate all %c-groups\n=> take the last one form them\n\n\nLangMatch \"\\*\" \"*\"\n=> concatenate all %l-groups\n=> take all of them\n\nEncodingMatch \"\\*\" \"*\"\n=> concatenate all %e-groups\n=> take all of them"}, {"count": 2, "tags": [], "creator": "calestyo@scientia.net", "attachment_id": null, "id": 142091, "time": "2010-11-28T19:02:42Z", "bug_id": 50357, "creation_time": "2010-11-28T19:02:42Z", "is_private": false, "text": "This should also make it easier to handle (arguably stupid) cases like\nx.tgz.Z, which should become\ntype: application/x-tar\nencoding: gzip, compress"}]