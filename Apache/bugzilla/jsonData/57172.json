[{"count": 0, "tags": [], "creator": "jhuxhorn@googlemail.com", "is_private": false, "id": 178867, "attachment_id": null, "bug_id": 57172, "creation_time": "2014-10-31T12:24:40Z", "time": "2014-10-31T12:24:40Z", "text": "Enumeration<URL> findResources(String name) of class org.apache.catalina.loader.WebappClassLoaderBase (for Tomcat 8.0.14, the code was located in org.apache.catalina.loader.WebappClassLoader for Tomcat 8.0.12) throws a NullPointerException if the \"resources\" attribute is null.\n\nI'm unsure why it is null in some cases (restarting the server, instead of simply redeploying one of our apps, fixes the issue for us) but this should be fixed in the classloader implementation anyway.\n\nThe code looks like this\n\n        WebResource[] webResources = resources.getClassLoaderResources(path);\n        for (WebResource webResource : webResources) {\n            if (webResource.exists()) {\n                result.add(webResource.getURL());\n            }\n        }\n\nand should be replaced by\n\n        if (resources != null) {\n            WebResource[] webResources = resources.getClassLoaderResources(path);\n            for (WebResource webResource : webResources) {\n                if (webResource.exists()) {\n                    result.add(webResource.getURL());\n                }\n            }\n        }\n\nSearching for this problem returns results as old as 2006.\n\nOther code that's using \"resources\" without null check:\n    public boolean modified()\n    public void start()\n    protected ResourceEntry findResourceInternal(final String name, final String path)\n\nCode that already acknowledges that \"resources\" may be null:\n    public String getContextName() {\n        if (resources == null) {\n            return \"Unknown\";\n        } else {\n            return resources.getContext().getName();\n        }\n    }\n\nFull stacktrace of our specific issue (running on Tomcat 8.0.12):\njava.lang.NullPointerException\n\tat org.apache.catalina.loader.WebappClassLoader.findResources(WebappClassLoader.java:998)\n\tat java.lang.ClassLoader.getResources(ClassLoader.java:1139)\n\tat java.util.ServiceLoader$LazyIterator.hasNextService(ServiceLoader.java:348)\n\tat java.util.ServiceLoader$LazyIterator.hasNext(ServiceLoader.java:393)\n\tat java.util.ServiceLoader$1.hasNext(ServiceLoader.java:474)\n\tat javax.xml.stream.FactoryFinder$1.run(FactoryFinder.java:352)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat javax.xml.stream.FactoryFinder.findServiceProvider(FactoryFinder.java:341)\n\tat javax.xml.stream.FactoryFinder.find(FactoryFinder.java:313)\n\tat javax.xml.stream.FactoryFinder.find(FactoryFinder.java:227)\n\tat javax.xml.stream.XMLInputFactory.newFactory(XMLInputFactory.java:205)\n\nThe XMLInputFactory.newFactory() is executed in initialValue() of a ThreadLocal<XMLInputFactory>."}, {"count": 1, "tags": [], "bug_id": 57172, "is_private": false, "id": 178882, "attachment_id": null, "creator": "markt@apache.org", "creation_time": "2014-11-01T16:46:40Z", "time": "2014-11-01T16:46:40Z", "text": "resources should only be null when the web application class loader is not running. Methods that may be called when the class loader is stopped (generally management methods to get the name etc.) handle the case where resources is null. Methods that are not expected to be called while the class loader is stopped (such as findResources) do not handle the null.\n\nThe NPE you are getting is indicative of trying to use the web application class loader after it has been stopped.\n\nI suspect you have a memory leak and something is retaining a reference the class loader that shouldn't be."}, {"count": 2, "tags": [], "creator": "jhuxhorn@googlemail.com", "text": "How about indicating that the web application is trying to use the web application class loader after it has been stopped instead of throwing a non-descriptive NPE?\n\nThe webapp in question was simply using a Java 8 forkjoin.\n\n\tat java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193)\n\tat java.util.HashMap$KeySpliterator.forEachRemaining(HashMap.java:1540)\n\tat java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:512)\n\tat java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:502)\n\tat java.util.stream.ReduceOps$ReduceTask.doLeaf(ReduceOps.java:747)\n\tat java.util.stream.ReduceOps$ReduceTask.doLeaf(ReduceOps.java:721)\n\tat java.util.stream.AbstractTask.compute(AbstractTask.java:316)\n\tat java.util.concurrent.CountedCompleter.exec(CountedCompleter.java:731)\n\tat java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)\n\tat java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:902)\n\tat java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1689)\n\tat java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1644)\n\tat java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)\n\nAre you seriously suggesting that leaving the current behavior is preferable to, say, a proper error message?\n\nBeside that: the webapp behaved like that without being stopped. This is related to undeploy magic performed by Tomcat regarding ThreadLocal and this problem shows up after RE-deploying an application without restarting Tomcat.\n\nAs I mentioned in my original report: if you search for this on the web then you'll find mentions of similar problems from 2006. I can't be sure since they just refer to generic NPE's in the findResources method spread over various Tomcat versions.\n\nIf you consider the usage of a ThreadLocal a memory leak in our app then, yes, we have a memory leak. I, on the other hand, would argue that it's the responsibility of the application server to shield web-applications from leaks like that by using separate worker threads for each webapp.\n\nI'm fully aware how this is supposed to work. But it isn't. I just observed this NPE in a live web application.\n\nAlright. Let's settle for a compromise. Just add\n\nif(resources == null) {\n    throw new IllegalStateException(\"OMG! SNAFU! This can't happen! findResources has been called on a (probably) stopped web context! /o\\\\\");\n}\n\nThis would be easier to search for than a simple NPE and would probably prove my point in the future.", "id": 178885, "attachment_id": null, "bug_id": 57172, "creation_time": "2014-11-02T00:00:16Z", "time": "2014-11-02T00:00:16Z", "is_private": false}, {"count": 3, "tags": [], "bug_id": 57172, "is_private": false, "id": 178888, "attachment_id": null, "creator": "markt@apache.org", "creation_time": "2014-11-02T01:04:40Z", "time": "2014-11-02T01:04:40Z", "text": "The INVALID response was more aimed at the suggestion that the correct way to handle this would be a check for null. Whatever the root cause, that would simply hide the symptom rather than fix the problem which is never a good idea.\n\nThe ISE is a much better idea although I'd change the wording since it is the state of the web application class loader rather than the application that is the primary concern. Better still, would be to include a check of that state as well just in case someone manages to trigger this via some other route.\n\nFirst you say this happened without the web application being stopped. Then you say it happened after a redploy (which includes a stop followed by a start). I guess you mean the problem happened after the web app was redeployed but while that redployed web application was running. That would be consistent with the reported symptoms.\n\nYes I do consider the use of a ThreadLocal that exists outside the scope of a single web application without being cleaned up when that application stops a memory leak. The Servlet spec is (currently) silent on the use of ThreadLocals and on thread pools being shared across multiple applications. Feel free to share you views with the Servlet EG in this issue:\nhttps://java.net/jira/browse/SERVLET_SPEC-82\n\nPersonally I am in favour of a single thread pool. Partly for efficiency, partly for performance (per application thread pools would still require a common thread pool to handle a request until the correct web app was identified and then hand off the request to the correct thread pool). If you really want the isolation of per application thread pools then it is probably simpler to just deploy each application to a separate instance.\n\nThere are alternative solutions to using ThreadLocals that may be appropriate depending on the circumstances. For example, the SecureRandom instances Tomcat uses to generate session IDs:\nhttp://svn.apache.org/viewvc/tomcat/trunk/java/org/apache/catalina/util/SessionIdGeneratorBase.java?view=annotate\n\nI'm re-opening this as an enhancement request for a better error message in this case."}, {"count": 4, "tags": [], "creator": "markt@apache.org", "text": "Fixed in 9.0.x and 8.0.x for 8.0.16 onwards.", "id": 179154, "time": "2014-11-17T07:49:19Z", "bug_id": 57172, "creation_time": "2014-11-17T07:49:19Z", "is_private": false, "attachment_id": null}]