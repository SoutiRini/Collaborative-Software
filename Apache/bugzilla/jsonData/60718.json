[{"id": 196872, "tags": [], "creator": "bjkail@gmail.com", "attachment_id": null, "count": 0, "text": "Sequence of events:\n1. Servlet \"synchronously\" writes an async response: ac = req.startAsync(); try { resp.getOutputStream().write(new byte[1024*1024]); } finally { ac.complete(); }\n2. Client disconnects to force broken pipe (etc.): uc = new URL(\"...\").openConnection(); uc.getInputStream().close(); uc.disconnect();\n\nIn this case, where ServletRequestListener.requestInitialized is called.  Summary of scenarios:\n- Fail: the servlet writes the response synchronously after startAsync (described above)\n- Fail: In Tomcat 8.5.11, the servlet writes the response truly asynchronously (with a new Thread)\n- Pass: in Tomcat 8.5.6, the servlet writes the response truly asynchronously (with a new Thread)\n- Pass: the servlet writes the response truly synchronously (without startAsync)\n- Pass: the client reads the stream without disconnecting early (all Tomcat versions, regardless of other scenarios presented).\n\nI think requestDestroyed should always be called.", "time": "2017-02-09T13:17:01Z", "bug_id": 60718, "creation_time": "2017-02-09T13:17:01Z", "is_private": false}, {"count": 1, "tags": [], "creator": "remm@apache.org", "is_private": false, "text": "Please try again stating more clearly what the code is (use an attachment), and the supposed failure. Please also review carefully bug 60385 it seems to apply to some of the fail scenarios described maybe (like possibly the first one).", "id": 196880, "time": "2017-02-09T17:57:58Z", "bug_id": 60718, "creation_time": "2017-02-09T17:57:58Z", "attachment_id": null}, {"count": 2, "tags": [], "bug_id": 60718, "attachment_id": 34742, "is_private": false, "id": 196883, "time": "2017-02-09T18:39:06Z", "creator": "bjkail@gmail.com", "creation_time": "2017-02-09T18:39:06Z", "text": "Created attachment 34742\ntest project\n\nI reviewed bug 60385 before opening this bug, and I do not think it is relevant.  That bug is about requestInitialized throwing an exception and therefore requestDestroyed not being called, which is reasonable.  This bug throws no exception from requestInitialized, but it forces a client error during getOutputStream().write().\n\nI am attaching a test project that demonstrates the problem for me (on Windows at least, but earlier version of the test also failed on Linux).  Install the WAR in Tomcat, then run the main method in TestServlet.  The main method connects to four endpoints, so I would expect four \"+ requestDestroyed\" messages.  On Tomcat 8.5.6, there are only three (missing async=sync).  On 8.5.11, there is only one (missing all async scenarios).  Additionally, 8.5.11 has a noisy setErrorState stack trace (seems unnecessary?) and an IllegalStateException from AsyncStateMachine.asyncError."}, {"count": 3, "tags": [], "bug_id": 60718, "attachment_id": null, "id": 196911, "time": "2017-02-10T16:53:43Z", "creator": "bjkail@gmail.com", "creation_time": "2017-02-10T16:53:43Z", "is_private": false, "text": "It's likely the same (or a related) problem, but access log entries are not written for the failing cases either (ala bug 58702)."}, {"count": 4, "tags": [], "text": "I think it's not going to \"work\" unless AsyncContextImpl.fireOnComplete calls context.fireRequestDestroyEvent(request). Or something like that.\n\nThe Tomcat code is based on the thinking that the request remains \"in scope\" while the async is started (so even when the Servlet's service method is no longer executed), which is what the spec seems to say (section 3.12).\n\nAlthough it seems to contradict section 3.12 of the spec, it could be interpreted wrong in Tomcat and requestInitialized and requestDestroyed should simply be called around the Servlet's service method call. Right now, the code is very careful to not call requestDestroyed if async is started, and then it's obvious there are cases where it's not going to be called. And doing it like that is a duplicate for what AsyncListener does so that's rather weird, but maybe it's better for some frameworks (?). I would remove !request.isAsync() in StandardHostValve, and drop fireRequestDestroyEvent from async dispatch.\n\nSo there is likely two possibilities, but Tomcat currently does neither.", "attachment_id": null, "id": 197006, "creator": "remm@apache.org", "time": "2017-02-14T17:01:38Z", "bug_id": 60718, "creation_time": "2017-02-14T17:01:38Z", "is_private": false}, {"count": 5, "tags": [], "bug_id": 60718, "attachment_id": null, "is_private": false, "id": 197009, "time": "2017-02-14T18:45:27Z", "creator": "bjkail@gmail.com", "creation_time": "2017-02-14T18:45:27Z", "text": "Tomcat doesn't appear to call AsyncListener for these scenarios either.\n\nFWIW, I agree with the \"in scope\" interpretation.  I was expecting requestDestroyed to be called only after the request is no longer \"in scope\", not just after service returns for async."}, {"count": 6, "attachment_id": null, "creator": "markt@apache.org", "is_private": false, "id": 197033, "time": "2017-02-15T10:58:38Z", "bug_id": 60718, "creation_time": "2017-02-15T10:58:38Z", "tags": [], "text": "I like the idea of moving the context.fireRequestDestroyEvent(request) call to AsyncContextImpl.fireOnComplete(). That is much better aligned with what section 3.12 of the spec says.\n\nA quick test with the current Async unit tests doesn't show any failures.\n\nNext steps are to look into the additional scenarios presented in this bug."}, {"count": 7, "tags": [], "text": "Many thanks for the test case. I've applied a fix to trunk (9.0.x) that addresses the issues raised by the test case. Before I back-port it, I want to look at whether the error handling needs some refactoring.", "attachment_id": null, "bug_id": 60718, "id": 197045, "time": "2017-02-15T20:28:29Z", "creator": "markt@apache.org", "creation_time": "2017-02-15T20:28:29Z", "is_private": false}, {"count": 8, "attachment_id": null, "creator": "markt@apache.org", "is_private": false, "id": 197047, "time": "2017-02-15T21:42:15Z", "bug_id": 60718, "creation_time": "2017-02-15T21:42:15Z", "tags": [], "text": "Fixed in:\n- trunk for 9.0.0.M18 onwards\n- 8.5.x for 8.5.12 onwards\n- 8.0.x for 8.0.42 onwards\n- 7.0.x for 7.0.76 onwards"}]