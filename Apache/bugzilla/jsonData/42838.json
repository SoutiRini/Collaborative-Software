[{"count": 0, "tags": [], "bug_id": 42838, "attachment_id": null, "text": "Please provide support for JSR 199: Java Compiler API.\n\nJava Compiler API (JSR 199) is a required part of Java SE 6 platform which\nprovides the interface to invoke Java\u2122 programming language compilers. Using\nthis interface can potentially reduce overhead of scanning the file system and\nreading jar files while sharing a file manager across compilation tasks. Please\nsee details at http://java.sun.com/javase/6/docs/api/javax/tools/JavaCompiler.html", "id": 105198, "time": "2007-07-09T01:07:55Z", "creator": "gaff78@gmail.com", "creation_time": "2007-07-09T01:07:55Z", "is_private": false}, {"count": 1, "tags": [], "creator": "stevel@apache.org", "text": "one question: why? Ant already has lots of support for the existing javac apis,\nto the extent that we're actually used behind the scenes in a lot of places.\nWhat is so compelling about the new API that we need to add a new implementation\nand the test cases to match?\n\nThe only thing would make it compelling to me would be if non-forking javac\nwould stop leaking very large (multi-megabyte) static data structures. Is there\nany discussion in that in the API? Whenever we reported that problem to sun in\nthe past, it was always dismissed as a WONTFIX \"you shouldnt be running javac\nin-process\".", "id": 105202, "time": "2007-07-09T03:32:05Z", "bug_id": 42838, "creation_time": "2007-07-09T03:32:05Z", "is_private": false, "attachment_id": null}, {"count": 2, "tags": [], "creator": "jonathan.gibbons@sun.com", "text": "(In reply to comment #1)\n> one question: why? Ant already has lots of support for the existing javac apis,\n> to the extent that we're actually used behind the scenes in a lot of places.\n> What is so compelling about the new API that we need to add a new implementation\n> and the test cases to match?\n> \n> The only thing would make it compelling to me would be if non-forking javac\n> would stop leaking very large (multi-megabyte) static data structures. Is there\n> any discussion in that in the API? Whenever we reported that problem to sun in\n> the past, it was always dismissed as a WONTFIX \"you shouldnt be running javac\n> in-process\".\n\njavac should no longer leak data as you describe. If it does, that would be regarded as a bug that would \nbe fixed. JSR199 is a specific response to the demand to be able to run javac (and related tools) in \nprocess and reflects a commitment to that mode of operation. In addition, the JSR 199 API gives better \nOO access to the diagnostics generated by the compiler. It also provides support for reading and \nwriting files from alternate storage media (e.g. memory, zip files, etc) through the use of the \nJavaFileManager.\n", "id": 105209, "time": "2007-07-09T07:16:48Z", "bug_id": 42838, "creation_time": "2007-07-09T07:16:48Z", "is_private": false, "attachment_id": null}, {"count": 3, "tags": [], "creator": "gaff78@gmail.com", "attachment_id": null, "id": 105223, "time": "2007-07-09T13:19:16Z", "bug_id": 42838, "creation_time": "2007-07-09T13:19:16Z", "is_private": false, "text": "JSR199 is the interface required by the spec for any conformant Java 6 (and\nabove) compiler. \n\nJSR199 provides \"in-process\" support for JSR269: Annotation Processing API\n(javax.annotation.processing, javax.lang.model.*)\n\nJSR199 provides support for caching resources, such as rt.jar, across\ncompilation tasks through sharing the JavaFileManager. This can improve\nperformance in cases of multiply javac invocations.\n\nJSR199 provides a standard way of plugging in alternative compilers or tools\nthrough the service provider mechanism.\n"}, {"count": 4, "tags": [], "bug_id": 42838, "attachment_id": null, "text": "Yeah yeah yeah, we get it: JSR 199 is great.\n\nIt's just too bad that it took until __Java 6__ to get all these great things.", "id": 105224, "time": "2007-07-09T13:28:48Z", "creator": "carej@us.ibm.com", "creation_time": "2007-07-09T13:28:48Z", "is_private": false}, {"count": 5, "tags": [], "creator": "alexeys@inventigo.com", "text": "(In reply to comment #4)\n> Yeah yeah yeah, we get it: JSR 199 is great.\n> \n> It's just too bad that it took until __Java 6__ to get all these great things.\n\nSo if the current JVM is __Java 6__, then using new API would be a right thing\nto do.", "id": 105230, "time": "2007-07-09T18:18:41Z", "bug_id": 42838, "creation_time": "2007-07-09T18:18:41Z", "is_private": false, "attachment_id": null}, {"count": 6, "tags": [], "bug_id": 42838, "attachment_id": null, "text": "(In reply to comment #5)\n\n> So if the current JVM is __Java 6__, then using new API would be a right thing\n> to do.\n\nI suppose that depends on your definition of \"current\". Unless I missed\nsomething, Ant is still supporting previous JVMs, so that means whomever\nimplements support for this JSR is going to have to pull out the usual bag of\ntricks to check for JDK versions, etc.\n\nI'm not suggesting that it's not worthwhile or that Ant shouldn't adopt this;\nI'm just trying to temper the rampant enthusiasm by pointing out that this JSR\nis just a __little__ bit late in coming...\n", "id": 105231, "time": "2007-07-09T18:42:35Z", "creator": "carej@us.ibm.com", "creation_time": "2007-07-09T18:42:35Z", "is_private": false}, {"count": 7, "tags": [], "bug_id": 42838, "attachment_id": null, "text": "(In reply to comment #6)\n\nBy \"current\" I meant the JVM executing ANT. The code could be something like that:\n\nif (availableClass(\"javax.tools.JavaCompiler\")) JSR199Adapter.javac(parameters);\nelse legacyAdapter.javac(parameters);", "id": 105232, "time": "2007-07-09T21:06:44Z", "creator": "alexeys@inventigo.com", "creation_time": "2007-07-09T21:06:44Z", "is_private": false}, {"count": 8, "tags": [], "creator": "stevel@apache.org", "attachment_id": null, "id": 105238, "time": "2007-07-10T03:08:51Z", "bug_id": 42838, "creation_time": "2007-07-10T03:08:51Z", "is_private": false, "text": "1. yes, I am in favour of support for this. Anything that stops javac from\nholding on to 10MB structures, alongside the 13MB structures that RMIC likes to\nhold on two, would be welcome. \n\n2. It would be implemented as a new adapter behind the javac facade, which\nalready has support for msjvc, jikes, javac classic, javac modern.\n\n3. the api implementation would have to use reflection so as to build on earlier\nJVMs, and to degrade gracefully.\n\n4. it would need tests and documentation; tests that only run on java1.6+\n\n5. I would not make this the default; we'd leave it as is, maybe add a new\nadapter \"java6\", and one alongside \"latest\" that always tries to use the most\nmodern adapter (i.e. on java7 it reserves the right to use something else)\n\nContributions of code tests and docs welcome."}, {"count": 9, "tags": [], "creator": "jglick@apache.org", "attachment_id": null, "id": 105249, "time": "2007-07-10T11:54:34Z", "bug_id": 42838, "creation_time": "2007-07-10T11:54:34Z", "is_private": false, "text": "(In reply to comment #8)\n> 3. the api implementation would have to use reflection so as to build on\n> earlier JVMs\n\nI suspect the number of calls to the JSR APIs (and callbacks for log collection)\nwould make it impractical to use reflection. Better to either require JDK 6+ to\nbuild (excluding these classes on earlier JDKs), possibly putting it in a\nseparate source tree; or create a set of stub classes for the subset of the JSR\nAPI which is needed.\n\n> and to degrade gracefully.\n\nObviously the impl would not be loaded until the existence of a token JSR 199\nclass had been confirmed.\n\n> 4. it would need tests and documentation; tests that only run on java1.6+\n\nIn fact you can run the compiler through JSR 199 on JDK 5, if you get the right\nclasses from\n\n  http://openjdk.java.net/groups/compiler/\n\nJust a possibility to keep in mind.\n\n> 5. I would not make this the default\n\nI certainly would, for people running JDK 6+. This is the official compiler API\nand there is no reason to use a deprecated and unsupported backdoor call when\nthe API is available."}, {"count": 10, "tags": [], "text": "(In reply to comment #9)\nI also agree with that.\n\nWe need to require newer Java to build ANT to have newer features supported. We\nshould only use reflection to see if the newer classes are available (and do not\ncheck for JDK version).\n\nAfter that we will just compile different directories with different\nsource/target JVM levers. \n\nAnd I would expect new JSR199 APIs to be used by default, if available.", "is_private": false, "id": 105250, "creation_time": "2007-07-10T12:16:58Z", "time": "2007-07-10T12:16:58Z", "creator": "alexeys@inventigo.com", "bug_id": 42838, "attachment_id": null}, {"count": 11, "tags": [], "creator": "stevel@apache.org", "attachment_id": null, "id": 105291, "time": "2007-07-11T06:34:00Z", "bug_id": 42838, "creation_time": "2007-07-11T06:34:00Z", "is_private": false, "text": "Well, I suppose we could cut a release on Java6, provided builds on earlier\nplatforms (a) skip that package and (b) stick with the 'modern' compiler on\njava6+...we'd still be able to load the new compiler using delegation.\n\nincidentally, does the new API let us hook in to the output better, so we can\nlog messages at different levels?"}, {"count": 12, "tags": [], "bug_id": 42838, "attachment_id": null, "text": "(In reply to comment #9)\n\n> \n> I certainly would, for people running JDK 6+. This is the official compiler API\n> and there is no reason to use a deprecated and unsupported backdoor call when\n> the API is available.\n\nFor the record, the API at com.sun.tools.javac.Main (which I assume the javac\ntask is using) is not an deprecated and unsupported backdoor call. It is a\nsupported entry point, and not deprecated.\n", "id": 105293, "time": "2007-07-11T07:27:56Z", "creator": "jonathan.gibbons@sun.com", "creation_time": "2007-07-11T07:27:56Z", "is_private": false}, {"count": 13, "tags": [], "creator": "jonathan.gibbons@sun.com", "attachment_id": null, "id": 105294, "time": "2007-07-11T07:32:17Z", "bug_id": 42838, "creation_time": "2007-07-11T07:32:17Z", "is_private": false, "text": "(In reply to comment #11)\n> incidentally, does the new API let us hook in to the output better, so we can\n> log messages at different levels?\n\nYes. Most messages are reported as \"Diagnostic\" objects to a\n\"DiagnosticListener\". The Diagnostic objects have a Kind (NOTE, WARNING, ERROR)\netc. They also provide detailed information about the location of the issue,\nwhen appropriate, giving the file in question, and the character offset within\nthe file. A few messages, such as -version and -usage info do not fall into this\ncategory and are reported to a log PrintWriter."}]