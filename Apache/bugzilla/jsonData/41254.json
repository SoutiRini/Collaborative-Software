[{"count": 0, "tags": [], "creator": "freeswitch@cartissolutions.com", "text": "I added the ability to manually block/unblock push and pop (independently of one\nanother), and provided a function to block until the queue is empty.", "id": 97427, "time": "2006-12-28T22:11:13Z", "bug_id": 41254, "creation_time": "2006-12-28T22:11:13Z", "is_private": false, "attachment_id": null}, {"count": 1, "tags": [], "creator": "freeswitch@cartissolutions.com", "text": "Created attachment 19321\nDiff for apr_queue.c", "id": 97428, "time": "2006-12-28T22:17:31Z", "bug_id": 41254, "creation_time": "2006-12-28T22:17:31Z", "is_private": false, "attachment_id": 19321}, {"count": 2, "tags": [], "creator": "freeswitch@cartissolutions.com", "text": "Created attachment 19322\nDiff for apr_queue.h", "id": 97429, "time": "2006-12-28T22:18:01Z", "bug_id": 41254, "creation_time": "2006-12-28T22:18:01Z", "is_private": false, "attachment_id": 19322}, {"count": 3, "tags": [], "bug_id": 41254, "is_private": false, "text": "There we go, fixed up the diffs for this.  Hopefully the project will deem this\na useful addition.", "id": 97430, "time": "2006-12-28T22:20:47Z", "creator": "freeswitch@cartissolutions.com", "creation_time": "2006-12-28T22:20:47Z", "attachment_id": null}, {"count": 4, "tags": [], "bug_id": 41254, "attachment_id": 19345, "text": "Created attachment 19345\n**Updated** Diff for apr_queue.c\n\nFixed the lack of initialization as pointed out by Ryan Phillips.  Performed\npatch creation in a way so as to not require -p6 to patch the original source.", "id": 97566, "time": "2007-01-03T10:03:09Z", "creator": "freeswitch@cartissolutions.com", "creation_time": "2007-01-03T10:03:09Z", "is_private": false}, {"attachment_id": 19346, "tags": [], "creator": "freeswitch@cartissolutions.com", "text": "Created attachment 19346\nPatch for apr_queue.h\n\nPerformed patch creation in a way so as to not require -p6 to patch the\noriginal source.  (Matches same -p parameter from apr_queue.c.diff)", "count": 5, "id": 97567, "time": "2007-01-03T10:04:33Z", "bug_id": 41254, "creation_time": "2007-01-03T10:04:33Z", "is_private": false}, {"count": 6, "tags": [], "creator": "nrc@cs.berkeley.edu", "text": "*** Bug 41099 has been marked as a duplicate of this bug. ***", "id": 128367, "time": "2009-06-28T23:19:22Z", "bug_id": 41254, "creation_time": "2009-06-28T23:19:22Z", "is_private": false, "attachment_id": null}, {"count": 7, "tags": [], "bug_id": 41254, "attachment_id": null, "is_private": false, "id": 128368, "time": "2009-06-28T23:22:00Z", "creator": "nrc@cs.berkeley.edu", "creation_time": "2009-06-28T23:22:00Z", "text": "Why is the ability to manually block pushs and pops useful? Seems like a fairly esoteric requirement to me."}, {"count": 8, "tags": [], "bug_id": 41254, "attachment_id": null, "text": "It suppose it can seem esoteric.  However, specific case scenario where I used this feature was this:\n\n1.  You have an apr_queue_t full of an unknown number of objects to be processed.\n2.  Processing of these objects depends on a user-provided configuration (for example credentials to connect to an RDBMS).\n3.  The user needed to make a change to the configuration, and wants the program to reload the configuration.\n4.  Without the ability to pause the apr_queue_t, we could have a scenario where the config is being reloaded at the exact second one of these objects is being processed, and cause any number of problems (object not getting recorded or program crashing).\n\nThere can be other instances where this might be handy as well, such as where you need to pause the queue to do some sort of maintenance and then unpause it.  You can see the old mod_cdr from the FreeSWITCH project to see how I had implemented it if you like.\n\nSince it doesn't add much complexity, it seemed to be something that other folks might find useful if it's available.  Feel free to merge this patch.", "id": 128395, "time": "2009-06-29T08:53:19Z", "creator": "freeswitch@cartissolutions.com", "creation_time": "2009-06-29T08:53:19Z", "is_private": false}, {"count": 9, "tags": [], "bug_id": 41254, "is_private": false, "text": "You could also achieve this functionality by inserting a \"configuration change request\" into the queue itself, and having the queue consumer pause and reload the configuration when it pops the change request from the queue. If you need to be notified when the queue consumer has applied the conf change, you can put a condition var in the change request message and wait for the consumer to signal it.\n\nThis approach also has the advantage of not blocking concurrent insertions, which reduces throughput.", "id": 128396, "time": "2009-06-29T09:04:06Z", "creator": "nrc@cs.berkeley.edu", "creation_time": "2009-06-29T09:04:06Z", "attachment_id": null}, {"count": 10, "tags": [], "creator": "freeswitch@cartissolutions.com", "text": "It's been over 2 years since I wrote this patch, and while what you said is definitely another option of how to handle the reload scenario, I thought that I wrote my code so that if you're blocking pop it shouldn't block pushes.  I thought I made it fine-grained enough that you could block either pushes or pops independently.\n\nI won't be able to re-apply this patch to be 100% certain until later on today though.  Please feel free to correct me if I'm wrong.", "id": 128397, "time": "2009-06-29T09:10:19Z", "bug_id": 41254, "creation_time": "2009-06-29T09:10:19Z", "is_private": false, "attachment_id": null}, {"count": 11, "tags": [], "bug_id": 41254, "is_private": false, "text": "Oh, right -- I was assuming the configuration change would need to be applied by the consumer thread itself. If that's not the case, you could use the \"block pop\" feature to block the consumer from doing any additional work, and then apply the configuration change from another thread while the consumer is blocked. However, AFAICS you'd still need some other mechanism to avoid a race condition: if the consumer pop()s an item just before the block_pop() arrives, it could still be processing that item while the configuration change is being applied.", "id": 128398, "time": "2009-06-29T09:19:06Z", "creator": "nrc@cs.berkeley.edu", "creation_time": "2009-06-29T09:19:06Z", "attachment_id": null}, {"attachment_id": null, "tags": [], "creator": "freeswitch@cartissolutions.com", "text": "Correct, this was designed for a situation where the consumer thread is not the one initiating any reload of configuration.  Also, it would need to be up to the application that is consuming off of the apr_queue_t to determine how to handle the potential for that specific race condition, and not the queue itself.", "count": 12, "id": 128399, "time": "2009-06-29T09:38:01Z", "bug_id": 41254, "creation_time": "2009-06-29T09:38:01Z", "is_private": false}]