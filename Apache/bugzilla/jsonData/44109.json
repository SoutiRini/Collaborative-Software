[{"count": 0, "tags": [], "creator": "daniel.armbrust.list@gmail.com", "attachment_id": null, "id": 111927, "time": "2007-12-19T14:25:00Z", "bug_id": 44109, "creation_time": "2007-12-19T14:25:00Z", "is_private": false, "text": "The Telnet Appender seems to have a poorly designed start up sequence.  \n\nHere is the activateOptions method:\n\n/** all of the options have been set, create the socket handler and\n      wait for connections. */\n  public void activateOptions() {\n    try {\n      sh = new SocketHandler(port);\n      sh.start();\n    }\n    catch(Exception e) {\n      e.printStackTrace();\n    }\n    super.activateOptions();\n  }\n\n\nIf the socket handler fails to open the socket - say for instance - the port is\nalready in use - it will nearly silently eat the error - leaving itself\nunconfigured.  If someone is trying to create a socket appender programatically,\nthey have no way of knowing if the activate step was successful or not.\n\nI'm not sure how to fix this, since the AppenderSkeleton interface does not\nallow the activateOptions method to throw exceptions.  Perhaps there should be a\nnew constructor that would take in all the options, do the work of the\nactivateOptions method, and throw the proper exceptions.  Or a getError()\nmethod, or something.   \n\nWorse - if the activateOptions() method fails, it leaves the sh variable null.\n\nLook at what happens next:\n /** Handles a log event.  For this appender, that means writing the message to\neach connected client.  */\n  protected void append(LoggingEvent event) {\n    sh.send(this.layout.format(event));\n\n\nHello, null pointer!  At log time, no less.  That code definitely needs a null\ncheck.  Having a mis-configured appender shouldn't toss null pointers into the\nlogging sequence."}, {"count": 1, "tags": [], "creator": "carnold@apache.org", "attachment_id": null, "id": 112964, "time": "2008-01-17T10:20:56Z", "bug_id": 44109, "creation_time": "2008-01-17T10:20:56Z", "is_private": false, "text": "One of the design goals of log4j 2.0 is to provide feedback of unexpected conditions.  Basically log4j 1.x's \ndesign was to hide all feedback on the health of the logging system from the application developer and \nwhat feedback was provided was sent to the console.\n\nThe null pointer in TelnetAppender.append however should have been checked, committed in rev 612911 \nand 612914."}, {"count": 2, "tags": [], "bug_id": 44109, "is_private": false, "text": "I'm not sure where you put the null check - Just to be clear - I think that the\nnull check needs to be in the class above the TelnetAppender - not in the\nTelnetAppender itself.  The append() sequence should never throw an error that\nit caused (for whatever reason) back out to the app that was just trying to log\na message.\n\nSo, no matter how poor of an Appender I create, if it messes up and takes a\nruntime exception, that shouldn't bubble back out to the caller.\n\nSecond, and I should have opened another bug on this, is the issue of creating\nthe SocketAppender and finding out about errors where the port couldn't be opened.  \n\nI fixed this by making the TelnetAppender constructor take in a port number, and\nrun the code that is currently run in activateOptions.  This way, the\nconstructor can throw the port in use exception back to the caller.  I removed\nthe setPort method, and made the activate options method do nothing.\n\nI can post the full TelnetAppender class, if you like, which fixes this startup\nissue, and bug 44108.\n\n", "id": 112965, "time": "2008-01-17T11:06:15Z", "creator": "daniel.armbrust.list@gmail.com", "creation_time": "2008-01-17T11:06:15Z", "attachment_id": null}, {"attachment_id": null, "tags": [], "bug_id": 44109, "is_private": false, "count": 3, "id": 112974, "time": "2008-01-17T13:52:08Z", "creator": "carnold@apache.org", "creation_time": "2008-01-17T13:52:08Z", "text": "I added a check for null at the head of TelnetAppender.append in rev 612911, to see just that change \nuse svn diff like:\n\nsvn diff -r 612910:612911\n\nI'd appreciate your feedback on the recently checked in code.  I did look at the code in the comments \nof 44108, but could not use it due to the JDK 1.5 stuff.  The rework to have a single collection is good, \nbut it was a lot simpler to add the sync blocks and they needed them anyway even if there was just one \ncollection.\n\nThere are two more global issues that you have mentioned:\n\nthe lack of programmatic feedback on configuration or start up issues\nthe lack of a try/catch/finally block in Categories.callAppenders or the like to catch unexpected \nexceptions during logging.\n\nThe lack of programmatic feedback is a log4j 2.0 issue.   log4j 1.2 made its design decisions 6 or so \nyears ago and we are generally stuck with them for maintenance releases.\n\nThe lack of a try/catch/finally block the Logger level was also made at that same time.  Adding it now \nwould affect the performance of every log4j user, not just those who were using TelnetAppender,  Not \nthat it would be a bad idea, but it is less likely to have serious unexpected consequences to make a \nisolated local change than a global change."}, {"count": 4, "tags": [], "creator": "daniel.armbrust.list@gmail.com", "attachment_id": null, "id": 112989, "time": "2008-01-18T07:25:45Z", "bug_id": 44109, "creation_time": "2008-01-18T07:25:45Z", "is_private": false, "text": "I can certainly see your point - I was surprised when I had the null pointer\nexception bubble out - all the time I have been using log4j, I've never had it\nhappen before - so its probably a good performance tradeoff.  But at the same\ntime, it nags me as wrong that any poorly written logger could inject runtime\nexceptions into the code simply calling a log method.\n\nCertainly no issue with making it a 2.0 issue, given the potential issues with\nthe change.\n\nIn my case, I have to have programmatic feedback if the telnet appender can't be\nstarted due to port issues, so I'll just stick with my modified constructor\nsolution for now.  \n\nIt seems to me that a correct fix for a 2.0 release would be to make the\nactivateOptions method throw a checked exception. \n\n"}]