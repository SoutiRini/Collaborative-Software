[{"count": 0, "tags": [], "creator": "fassev@gmx.de", "attachment_id": null, "id": 86616, "time": "2006-03-08T21:04:02Z", "bug_id": 38899, "creation_time": "2006-03-08T21:04:02Z", "is_private": false, "text": "Currently the method org.apache.jasper.runtime.TagHandlerPool.reuse(Tag \nhandler) - subproject jasper - has the following implementation:\n\n    public void reuse(Tag handler) {\n        synchronized( this ) {\n            if (current < (handlers.length - 1)) {\n                handlers[++current] = handler;\n                return;\n            }\n        }\n        // There is no need for other threads to wait for us to release\n        handler.release();\n    }\n\nWhere the handler.release() method of the returned TAG is called after the tag \nis returned to the pool and outside of the synchronization block. This is \nobviously wrong, because another thread can obtain the same tag from the pool \nand start use it, where at the same time the TagHandlerPool will release the \ntag (i.e. the tag will free its internal properties)! On a highly frequented \nsite, this is very likely to happen simutaniously and the state of the tag will \nbe inconsistent.\n\nThe solution is very simple: Call the handler.release() Method before the tag \nis returned to the pool, or synchronize it.\n\nRegards\nPeter"}, {"count": 1, "tags": [], "creator": "fassev@gmx.de", "attachment_id": null, "id": 86617, "time": "2006-03-08T21:12:27Z", "bug_id": 38899, "creation_time": "2006-03-08T21:12:27Z", "is_private": false, "text": "Sorry, I am blind and I jumped the gut too fast! The tag is released, ony when \nit is not added to the pool. So this bug is invalid."}]