[{"count": 0, "tags": [], "bug_id": 4138, "attachment_id": null, "text": "[Note that this is confirmed to be an issue for Tomcat 4.0b6, and is most \nlikely an issue in the 4.0 final release.]\n\nWhen an HttpProcessor thread gets created and first processes a request, its \nClassLoader does not get set until midway in the pipeline invocation.  That is, \nthe StandardHostValve changes the ClassLoader associated with the HttpProcessor \nthread to the WebappClassLoader just before it invokes the request's mapped \ncontext's pipeline.  However, it never restores the ClassLoader with the thread \nafter the invocation of the context's pipeline has completed.\n\nThis results in an inconsistent ClassLoader state for that thread after the \ncontext's pipeline is finished being invoked.  The thread will still have the \nsame WebappClassLoader for that context associated with it for all processing \nremaining for the existing request, as well as for the next request this thread \nwill be assigned to handle (up until it changes the ClassLoader for a \npotentially different context when it invokes StandardHostValve).  \nConsequently, this is a slight security issue, but more importantly, can lead \nto hard to reproduce bugs.\n\nA simple fix for this problem would be to have StandardHostValve keep a \nreference to the current thread's ClassLoader just before it changes the \nClassLoader for the mapped context to invoke it, and have it restore the \noriginal ClassLoader for the thread after it finishes invoking the context's \npipeline.", "id": 6658, "time": "2001-10-12T16:55:03Z", "creator": "ruvinsky@yahoo.com", "creation_time": "2001-10-12T16:55:03Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 4138, "text": "1) It's not a security issue, since we're inside the container. Code running \nthere have all permissions.\n2) I didn't see a case where it would be useful to map a valve below the host \nlevel. It seemed very accessory to me, so I decided to save a possibly \nrelatively expensive call. Is there a need outisde of your particular case \n(because I think you're filing the bug for a reason) ?\n\nOtherwise, your solution is fine, and it's what's been used to swap context CL \nduring the initialization (since we really have to restore the original CL at \nthat time).\n\nNote: There were probably related bugs in beta 6 with the CCL switching during \ninit. Obviously it needed some debugging to get it right.\n\nI change the version number to 4.0.1b1, since that code didn't change.", "id": 6659, "time": "2001-10-12T17:06:40Z", "creator": "remm@apache.org", "creation_time": "2001-10-12T17:06:40Z", "is_private": false, "attachment_id": null}, {"count": 2, "tags": [], "creator": "ruvinsky@yahoo.com", "attachment_id": null, "text": "Remy, thanks for such a prompt response!  This is not a pressing issue for me,\nbut I thought I would report it anyway.  The reason why I suspect that it seems\nlike a security issue is that there are moments in time that an HttpProcessor\nthread has a WebappClassLoader attached to it that belongs to the context\nassociated with the previous request.  If a new class needed to be loaded by the\nHttpProcessor, for example, the previous context's WebappClassLoader would first\ntry to load it, then pass the load request to its parent ClassLoader.  If that\nwebapp happened to have that class (yes, a remote chance), it is possible for\nthe WebappClassLoader to load it from the webapp itself.  Please let me know if\nI can further clarify.  Thanks.", "id": 6660, "time": "2001-10-12T17:14:18Z", "bug_id": 4138, "creation_time": "2001-10-12T17:14:18Z", "is_private": false}, {"count": 3, "tags": [], "bug_id": 4138, "attachment_id": null, "text": "That particular case doesn't happen at the moment with the current connectors., \nso I don't see any urgency to change it. I'll change the behavior if there's a \nneed to do so.", "id": 6666, "time": "2001-10-12T19:08:12Z", "creator": "remm@apache.org", "creation_time": "2001-10-12T19:08:12Z", "is_private": false}, {"count": 4, "tags": [], "bug_id": 4138, "attachment_id": null, "id": 8650, "time": "2001-12-05T16:22:29Z", "creator": "remm@apache.org", "creation_time": "2001-12-05T16:22:29Z", "is_private": false, "text": "Reopen before closing."}, {"count": 5, "tags": [], "bug_id": 4138, "attachment_id": null, "id": 8651, "time": "2001-12-05T16:23:30Z", "creator": "remm@apache.org", "creation_time": "2001-12-05T16:23:30Z", "is_private": false, "text": "While it's true that the thread binding won't be coherent between requests, it\nis never a problem, since the state will be adjusted at the beginning of the\nnext request."}, {"count": 6, "tags": [], "bug_id": 4138, "text": "I'd like to revisit this issue, now that it has been some time since it was \noriginally reported.  I still feel that this is technically a bug and it should \nget fixed in Tomcat's now more mature state.\n\nAlso, rethinking this, this does appear to be a security vulnerability, because \nif the classloader remains to as the webapp classloader for the processor \nthread after the servlet finishes servicing, it's particularly vulnerable \n(given that all the server code the thread runs through has all the Java2 \nsecurity permissions granted).  The thread could load classes that the *webapp \nclassloader* would try loading first (since that specific classloader type does \nnot perform parent-first classloader delegation).\n\nAside from all this, it's a code cleanliness and peace of mind issue.  :)  \nThoughts?\n\nHere is the simple fix in class \"org.apache.catalina.core.StandardHostValve\":\n\n    public void invoke(Request request, Response response,\n                       ValveContext valveContext)\n        throws IOException, ServletException {\n\n        // :\n        // :\n        // :\n\n        // remember the current classloader for this thread\n        ClassLoader origClassLoader = Thread.currentThread().\n                                             getContextClassLoader();\n\n        // set the context class loader for this thread before invoking\n        // the context\n        Thread.currentThread().setContextClassLoader(context.getLoader().\n                                                     getClassLoader());\n\n        try {\n            // have the context process this request\n            context.invoke(request, response);\n        } finally {\n            // under ANY circumstance (regardless of exception occurring during\n            // request processing), always perform the following:\n\n            // restore the original classloader for this thread\n            Thread.currentThread().setContextClassLoader(origClassLoader);\n        }\n    }", "id": 21510, "time": "2002-08-22T00:24:29Z", "creator": "ruvinsky@yahoo.com", "creation_time": "2002-08-22T00:24:29Z", "is_private": false, "attachment_id": null}, {"count": 7, "tags": [], "text": "Come to think of it, shouldn't this logic be done in StandardWrapperValve \ninstead of in StandardHostValve?  I noticed that the StandardHostValve invoke() \nimplementation terminates early if the request isn't of type \nHttpServletRequest, so the context class loader switching logic would never get \ncalled.  To ensure that it gets called before invoking the servlet's service() \nmethod, it sounds like we should do it in the StandardWrapperValve, just before \ncalling the filter chain for the request.  Just a thought.\n\nThanks,\nEddie", "attachment_id": null, "id": 21561, "creator": "ruvinsky@yahoo.com", "time": "2002-08-22T22:00:09Z", "bug_id": 4138, "creation_time": "2002-08-22T22:00:09Z", "is_private": false}, {"count": 8, "tags": [], "text": "An alternative patch was applied some time ago.\nhttp://marc.theaimsgroup.com/?l=tomcat-dev&m=106508338920002&w=2\n\nIt was for a different bug but the result is the same.", "attachment_id": null, "id": 72814, "creator": "markt@apache.org", "time": "2005-03-25T00:09:51Z", "bug_id": 4138, "creation_time": "2005-03-25T00:09:51Z", "is_private": false}, {"count": 9, "tags": [], "bug_id": 4138, "attachment_id": null, "id": 72823, "time": "2005-03-25T02:38:18Z", "creator": "ruvinsky@yahoo.com", "creation_time": "2005-03-25T02:38:18Z", "is_private": false, "text": "(In reply to comment #8)\n> An alternative patch was applied some time ago.\n> http://marc.theaimsgroup.com/?l=tomcat-dev&m=106508338920002&w=2\n> \n> It was for a different bug but the result is the same.\n\nThanks Mark, but I noticed that it's not in a finally block in case\ncontext.invoke() throws an exception.\n\nPlus, it probably doesn't address the issue I mentioned earlier where it may\nmake more sense to move this ContextClassLoader logic to StandardWrapperValve. \nThoughts?"}, {"count": 10, "tags": [], "bug_id": 4138, "attachment_id": null, "text": "(In reply to comment #9)\n> Thanks Mark, but I noticed that it's not in a finally block in case\n> context.invoke() throws an exception.\n\nAs per Remy's commit in the commit above, an exception here is a critical error.\nI view any such exception as a bug.\n \n> Plus, it probably doesn't address the issue I mentioned earlier where it may\n> make more sense to move this ContextClassLoader logic to StandardWrapperValve. \n> Thoughts?\nServeral:\n- I don't see any code paths that lead to the service() method being called\nwithout switching the ClassLoader.\n- Provide a test case that demonstrates this is a problem and I'll try and fix\nit. Otherwise, \"If it ain't broke don't fix it\" applies. Fixing theoretical bugs\nis not worth the very real risk of introducing regressions.\n\nFinally, if you do have a test case that demonstrates a problem and there is a\nchance that it may have security implications please note that security issues\nshould be directed to security@apache.org rather than discussed publically in\nbugzilla.", "id": 72898, "time": "2005-03-26T20:46:16Z", "creator": "markt@apache.org", "creation_time": "2005-03-26T20:46:16Z", "is_private": false}]