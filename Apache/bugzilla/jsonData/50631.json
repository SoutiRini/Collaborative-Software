[{"count": 0, "tags": [], "bug_id": 50631, "attachment_id": null, "is_private": false, "id": 143568, "time": "2011-01-21T13:23:52Z", "creator": "yuesong.c@gmail.com", "creation_time": "2011-01-21T13:23:52Z", "text": "InternalNioInputBuffer automatically expands its buffer while reading in request line, effectively ignoring the maxHttpHeaderSize setting."}, {"count": 1, "tags": [], "text": "For reference: this issue was created from the following thread on users@:\nhttp://tomcat.markmail.org/thread/wjuhhyfllplmyly5\n\n\nThere is the following code in InternalNioInputBuffer#fill(boolean, boolean) both in 6.0.31 and in 7.0.6:\n\n      if (parsingHeader) {\n            if (lastValid == buf.length) {\n                throw new IllegalArgumentException\n                    (sm.getString(\"iib.requestheadertoolarge.error\"));\n            }\n\nand it should take care of overflows. But there is also InternalNioInputBuffer#expand(int) which is called from #readSocket().\n\nI thought of the below patch (for trunk, not tested), but I see another problem: I do not see InternalNioInputBuffer.buf being recycled (shrunk) after its growth. I suspect that it should not be allowed to grow even when it is body of the request that we are reading now. In InternalAprInputBuffer.fill() and InternalInputBuffer.fill() the buffer can be reallocated, but the new buffer will be of the same size as the old one.\n\nThus instead of the patch below I suspect that InternalNioInputBuffer.expand() should fail unconditionally when ( newsize > buf.length ).\n\n\nIndex: java/org/apache/coyote/http11/InternalNioInputBuffer.java\n===================================================================\n--- java/org/apache/coyote/http11/InternalNioInputBuffer.java\t(revision 1064206)\n+++ java/org/apache/coyote/http11/InternalNioInputBuffer.java\t(working copy)\n@@ -370,6 +370,10 @@\n     \n     private void expand(int newsize) {\n         if ( newsize > buf.length ) {\n+            if (parsingHeader) {\n+                throw new IllegalArgumentException(\n+                        sm.getString(\"iib.requestheadertoolarge.error\"));\n+            }\n             byte[] tmp = new byte[newsize];\n             System.arraycopy(buf,0,tmp,0,buf.length);\n             buf = tmp;", "attachment_id": null, "id": 143733, "creator": "knst.kolinko@gmail.com", "time": "2011-01-27T15:26:07Z", "bug_id": 50631, "creation_time": "2011-01-27T15:26:07Z", "is_private": false}, {"count": 2, "tags": [], "creator": "knst.kolinko@gmail.com", "is_private": false, "text": "Fixed in trunk and in 6.0.\nWill be in 7.0.7, 6.0.32.", "id": 143882, "time": "2011-02-01T21:58:16Z", "bug_id": 50631, "creation_time": "2011-02-01T21:58:16Z", "attachment_id": null}]