[{"count": 0, "tags": [], "creator": "M8R-udo4lc@safetymail.info", "attachment_id": null, "id": 134400, "time": "2010-02-10T07:44:09Z", "bug_id": 48722, "creation_time": "2010-02-10T07:44:09Z", "is_private": false, "text": "apr_thread_pool_push may fail to detect that the number of idle threads is zero (because the threads did not update the counter yet). This is specially bad when you have a task that is waiting for another to complete (dead-lock).\n\nExample code:\n\n#include <stdlib.h>\n#include <apr.h>\n#include <apr_thread_mutex.h>\n#include <apr_thread_pool.h>\n#include <apr_thread_cond.h>\n\n/** structure sent to the thread-pool */\ntypedef struct st_thaux {\n\tapr_thread_mutex_t\t*mutex;\n\tapr_thread_cond_t\t*cond;\n\tint\t\t\t\t\twaiting;\n\tint\t\t\t\t\tflag;\n} thaux;\n\n/* creates an auxiliary structure and push it to the thread-pool */\n#define DO_PUSH(aux) \\\n\taux=calloc(1,sizeof(thaux));\\\n\tapr_thread_mutex_create(&aux->mutex,APR_THREAD_MUTEX_UNNESTED,mp);\\\n\tapr_thread_cond_create(&aux->cond,mp);\\\n\tapr_thread_pool_push(tp,tp_worker,(void*)aux,0,0x00);\n\n/* notifies the auxiliary structure's conditional variable */\n#define DO_NOTIFY(aux) \\\n\twhile (!aux->waiting) apr_sleep(10000);\\\n\tapr_thread_mutex_lock(aux->mutex);\\\n\taux->flag=1;\\\n\tapr_thread_cond_broadcast(aux->cond);\\\n\tapr_thread_mutex_unlock(aux->mutex);\n\n/* waits for the auxiliary structure's conditional variable to be notified */\n#define DO_WAIT(aux) \\\n\taux->waiting=1;\\\n\tapr_thread_mutex_lock(aux->mutex);\\\n\tif (!aux->flag) apr_thread_cond_timedwait(aux->cond,aux->mutex,apr_time_from_sec(1));\\\n\tif (!aux->flag) {\\\n\t\tprintf(\"DEAD-LOCK DETECTED - aborting\\n\");\\\n\t\texit(1);\\\n\t}\\\n\tapr_thread_mutex_unlock(aux->mutex);\n\n\n/** thread-pool function worker */\nvoid *APR_THREAD_FUNC tp_worker(apr_thread_t *thptr,void *arg)\n{\n\tDO_NOTIFY(((thaux*)arg));\n\treturn((void*)thptr);\n}\n\n/* main entry point */\nint main(int argc, char **argv)\n{\n\tapr_pool_t\t\t*mp\t\t= 0x00;\t/* memory pool */\n\tint\t\t\t\ti\t\t= 0;\t/* run count */\n\tconst int\t\tTHSTART\t= 1;\t/* number of threads to begin with */\n\tconst int\t\tTHMAX\t= 20;\t/* maximum number of threads allowed */\n\n\tapr_initialize();\n\tapr_pool_initialize();\n\n\tprintf(\"Starting test...\\n\");\n\tfor (i=1; i<=100; i++) {\n\t\tapr_thread_pool_t\t*tp\t\t= 0x00;\t/* thread pool */\n\t\tthaux\t\t\t\t*aux1\t= 0x00; /* task #1 */\n\t\tthaux\t\t\t\t*aux2\t= 0x00;\t/* task #2 */\n\n\t\tprintf(\"Run #%d\\n\",i);\n\t\tapr_pool_create(&mp,0x00);\n\t\tapr_thread_pool_create(&tp,THSTART,THMAX,mp);\n\t\t/* push both tasks */\n\t\tDO_PUSH(aux1);\n\t\t//apr_sleep(10000); // uncomment this line and see the results\n\t\tDO_PUSH(aux2);\n\t\t/* wait for the tasks to complete (but wait task #2 first)  */\n\t\tDO_WAIT(aux2);\n\t\tDO_WAIT(aux1);\n\t\t/* cleanup */\n\t\tfree(aux1);aux1=0;\n\t\tfree(aux2);aux2=0;\n\t\tapr_thread_pool_destroy(tp);tp=0;\n\t\tapr_pool_destroy(mp);mp=0;\n\t}\n\tprintf(\"Test finished with success!\\n\");\n\treturn 0;\n}"}, {"count": 1, "tags": [], "creator": "trawick@apache.org", "attachment_id": null, "id": 140156, "time": "2010-09-24T18:12:51Z", "bug_id": 48722, "creation_time": "2010-09-24T18:12:51Z", "is_private": false, "text": "Perhaps this and bug 49709 (which has a patch) are the same underlying issue..."}, {"count": 2, "tags": [], "bug_id": 48722, "attachment_id": null, "text": "(In reply to comment #1)\n> Perhaps this and bug 49709 (which has a patch) are the same underlying issue...\napparently not; the patch in 49709 does not make this testcase work", "id": 140201, "time": "2010-09-27T07:12:34Z", "creator": "trawick@apache.org", "creation_time": "2010-09-27T07:12:34Z", "is_private": false}, {"count": 3, "tags": [], "creator": "trawick@apache.org", "attachment_id": null, "id": 140259, "time": "2010-09-28T06:54:42Z", "bug_id": 48722, "creation_time": "2010-09-28T06:54:42Z", "is_private": false, "text": "1. the testcase\nseems to work as you expect on Mac OS X (often deadlocks before 100th iteration) but crashes for me on Linux, either with the released apr-util 1.3.9 or the current level of code\n2. expectations of apr_thread_pool\nThe original author offered this summary of expectations on the list:\n------cut here------\nThe dead-lock happens when the initial one worker thread get into idle\nfirst as no tasks are pushed yet, then two push comes in. Under this\ncircumstance, there is one thread idle, thus no new thread will be\ncreated.\n\nNow the idle thread get to pick up the first task, but is blocked,\nthus no other thread will pick up the second task, which caused the\ndead-lock.\n\nAs explained, this scenario is not supported by design as we expect\nthe task should not be blocking. Understood the cooperative approach\nis not optimal, but that is all we needed at that moment and simplify\nthings a lot.\n-------cut here------\n\nHave a look at the discussion thread starting with\n\nhttp://mail-archives.apache.org/mod_mbox/apr-dev/201009.mbox/%3CAANLkTik6=5gt287ztHzmEhY3vdEzL7E64jBr1r5EfSXn@mail.gmail.com%3E"}, {"count": 4, "tags": [], "creator": "akorobka@fxcm.com", "text": "Created attachment 27165\nExample with a fixed race condition", "id": 147214, "time": "2011-06-16T22:31:44Z", "bug_id": 48722, "creation_time": "2011-06-16T22:31:44Z", "is_private": false, "attachment_id": 27165}, {"count": 5, "tags": [], "creator": "akorobka@fxcm.com", "attachment_id": null, "id": 147216, "time": "2011-06-16T22:41:37Z", "bug_id": 48722, "creation_time": "2011-06-16T22:41:37Z", "is_private": false, "text": "Original example has a race condition between DO_PUSH() using mp pool to allocate synchronization objects in the main thread and thread pool worker function using the same mp pool to allocate internal objects. Version in the previous attachment fixes that.\n\nAlso, the deadlock can be avoided by bumping up the number of the initial threads. However this exposes another problem. If apr_thread_pool_destroy() is called quickly after creating a thread pool with a large number of initial threads it seems to leave some of them still executing inside thread_pool_func(), which causes another crash."}]