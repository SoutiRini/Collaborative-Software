[{"count": 0, "attachment_id": null, "creator": "bojan.kalan@hp.com", "text": "The inner class Dispatcher in org.apache.log4j.AsyncAppender runs as a thread \nand reads the logging event buffer which is filled by users of the \nAsyncAppender. The Dispatcher thread reads from this buffer and calls the \nappend method of all previously added Appenders (in the run() method).\n\nIf one of this appenders throws a RuntimeException, it is not catched anywhere, \nand the endless loop in the run() method is exited and the thread dies. The \nlogging event buffer is filled up until the buffer writer (in the main thread) \nblocks, which blocks the whole process. \nAs Log4J usually is used as a trace module, such an error shall not block the \nwhole productive process. It would be better if RuntimeExcpetions whould be \ncatched, proberly traced and then continued.", "id": 43881, "time": "2003-09-09T09:17:26Z", "bug_id": 23021, "creation_time": "2003-09-09T09:17:26Z", "tags": [], "is_private": false}, {"count": 1, "tags": [], "bug_id": 23021, "is_private": false, "text": "From what I can tell, this should occur at\nAppenderAttachableImpl.appendLoopOnAppenders.  Surround appender.doAppend(event)\nwith a try catch Runtime, log, and continue.  This will prevent a single faulty\nappender from preventing logging to other appenders and killing the parent loop.", "id": 50844, "time": "2004-01-20T22:17:27Z", "creator": "j.c.yip@computer.org", "creation_time": "2004-01-20T22:17:27Z", "attachment_id": null}, {"count": 2, "attachment_id": null, "creator": "j.c.yip@computer.org", "text": "As in this:\n\ntry {\n    appender.doAppend(event);\n} catch (RuntimeException e) {\n    LogLog.error(\"Error appending to \" + appender, e);\n}", "id": 51226, "time": "2004-01-27T07:09:12Z", "bug_id": 23021, "creation_time": "2004-01-27T07:09:12Z", "tags": [], "is_private": false}, {"count": 3, "attachment_id": null, "creator": "mwomack@apache.org", "is_private": false, "id": 76923, "time": "2005-07-01T23:09:55Z", "bug_id": 23021, "creation_time": "2005-07-01T23:09:55Z", "tags": [], "text": "1.2.12 candidate"}, {"count": 4, "tags": [], "text": "I'm a little troubled by the proposed resolution.  An Appender should not throw a run-time exception \nand the exception would not be caught if the appender was directly attached to the logger hierarchy.  \nI'd really prefer not to suggest that an appender that throws run-time exceptions is tolerable as long as \nyou wrap it in an async appender.  I'm not sure of the cost of the try/catch block in the async appender \nfor the run-time exception that should never come, but it could be expensive enough to be noticable.\n\nMy current preference is to check dispatcher.isAlive() at the start of AsyncAppender.doAppend and if \nthe dispatch thread has died to invoke the nested appenders synchronously.  This should result in \nsimilar behavior for both the sync and async other than your first exception is silent if wrapped in an \nasync appender.\n", "is_private": false, "id": 77527, "creator": "carnold@apache.org", "time": "2005-07-22T01:59:44Z", "bug_id": 23021, "creation_time": "2005-07-22T01:59:44Z", "attachment_id": null}, {"count": 5, "attachment_id": null, "creator": "carnold@apache.org", "text": "Fixed on both 1.2 and CVS HEAD.  If thread is dead on entry to AsyncAppender.append (possibly from a \nearlier run-time exception), then logging event will be processed synchronously.", "id": 77589, "time": "2005-07-22T21:57:19Z", "bug_id": 23021, "creation_time": "2005-07-22T21:57:19Z", "tags": [], "is_private": false}]