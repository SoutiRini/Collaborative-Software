[{"count": 0, "tags": [], "bug_id": 27883, "attachment_id": null, "id": 54512, "time": "2004-03-23T22:17:31Z", "creator": "j.peer@gmx.net", "creation_time": "2004-03-23T22:17:31Z", "is_private": false, "text": "I ran into the problem that my FTP server (runs on windows) resetted the\nconnections quite frequently , resulting in premature abort of the FTP task and\nsubsequent build failure.\n\nAnt version: 1.6.1\nCommons-net: 1.1.0 and CVS checkout on march 23, 2004\nClient System: JSDK 1.4, win XP\nServer System: Win2k, various FTP servers\n\nNote: the connection resets happened on all the FTP clients and servers i tried;\nmost likely it's some network issue, which i cannot control or fix. \n\nTherefore, i slightly adjusted the sourcecode of\norg.apache.tools.ant.taskdefs.optional.net.FTP to force it to re-connect to the\nserver in case of an error, just like many of the GUI based FTP clients do (e.g.\nSmartFTP).\n\nFurther, I have added an attribute \"maxAttempts\" to define how often the FTP\ntask should re-connect/retry before it gives up (default value is 1, to retain\nun-patched behavior).\n\ni've used it for a couple of hours now (only for file PUTing though) and it\nworks well, allowing me to continue my work despite the very fragile FTP connection.\n\n================================================================ \n\nATTACHEMENT: source code of org.apache.tools.ant.taskdefs.optional.net.FTP -  my\nchanges are marked with \"JPEER\", if you want to skim through...\n\n================================================================ \n\n\n/*\n * Copyright  2000-2004 The Apache Software Foundation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n */\npackage org.apache.tools.ant.taskdefs.optional.net;\n\nimport org.apache.commons.net.ftp.FTPClient;\nimport org.apache.commons.net.ftp.FTPFile;\nimport org.apache.commons.net.ftp.FTPReply;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.Hashtable;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\n\nimport org.apache.tools.ant.BuildException;\nimport org.apache.tools.ant.DirectoryScanner;\nimport org.apache.tools.ant.Project;\nimport org.apache.tools.ant.Task;\nimport org.apache.tools.ant.taskdefs.Delete;\nimport org.apache.tools.ant.types.EnumeratedAttribute;\nimport org.apache.tools.ant.types.FileSet;\nimport org.apache.tools.ant.types.selectors.SelectorUtils;\nimport org.apache.tools.ant.util.FileUtils;\n\n/**\n * Basic FTP client. Performs the following actions:\n * <ul>\n *   <li> <strong>send</strong> - send files to a remote server. This is the\n *   default action.</li>\n *   <li> <strong>get</strong> - retrieve files from a remote server.</li>\n *   <li> <strong>del</strong> - delete files from a remote server.</li>\n *   <li> <strong>list</strong> - create a file listing.</li>\n *   <li> <strong>chmod</strong> - change unix file permissions.</li>\n *   <li> <strong>rmdir</strong> - remove directories, if empty, from a\n *   remote server.</li>\n * </ul>\n * <strong>Note:</strong> Some FTP servers - notably the Solaris server - seem\n * to hold data ports open after a \"retr\" operation, allowing them to timeout\n * instead of shutting them down cleanly. This happens in active or passive\n * mode, and the ports will remain open even after ending the FTP session. FTP\n * \"send\" operations seem to close ports immediately. This behavior may cause\n * problems on some systems when downloading large sets of files.\n *\n * @author Roger Vaughn <a href=\"mailto:rvaughn@seaconinc.com\">\n *      rvaughn@seaconinc.com</a>\n * @author Glenn McAllister <a href=\"mailto:glennm@ca.ibm.com\">\n *      glennm@ca.ibm.com</a>\n * @author Magesh Umasankar\n * @author <a href=\"mailto:kadams@gfs.com\">Kyle Adams</a>\n * @since Ant 1.3\n */\npublic class FTP\n     extends Task {\n    protected static final int SEND_FILES = 0;\n    protected static final int GET_FILES = 1;\n    protected static final int DEL_FILES = 2;\n    protected static final int LIST_FILES = 3;\n    protected static final int MK_DIR = 4;\n    protected static final int CHMOD = 5;\n    protected static final int RM_DIR = 6;\n    /** return code of ftp - not implemented in commons-net version 1.0 */\n    private static final int CODE_521 = 521;\n    /** Default port for FTP */\n    public static final int DEFAULT_FTP_PORT = 21;\n\n    private String remotedir;\n    private String server;\n    private String userid;\n    private String password;\n    private File listing;\n    private boolean binary = true;\n    private boolean passive = false;\n    private boolean verbose = false;\n    private boolean newerOnly = false;\n    private long timeDiffMillis = 0;\n    private boolean timeDiffAuto = false;\n    private int action = SEND_FILES;\n    private Vector filesets = new Vector();\n    private Vector dirCache = new Vector();\n    private int transferred = 0;\n    private String remoteFileSep = \"/\";\n    private int port = DEFAULT_FTP_PORT;\n    private boolean skipFailedTransfers = false;\n    private int skipped = 0;\n    private boolean ignoreNoncriticalErrors = false;\n    private boolean preserveLastModified = false;\n    private String chmod = null;\n    private String umask = null;\n    private FileUtils fileUtils = FileUtils.newFileUtils();\n\t\t// JPEER\n\t\tprivate int maxAttempts = 1;\n\t\t\n    protected static final String[] ACTION_STRS = {\n        \"sending\",\n        \"getting\",\n        \"deleting\",\n        \"listing\",\n        \"making directory\",\n        \"chmod\",\n        \"removing\"\n        };\n\n    protected static final String[] COMPLETED_ACTION_STRS = {\n        \"sent\",\n        \"retrieved\",\n        \"deleted\",\n        \"listed\",\n        \"created directory\",\n        \"mode changed\",\n        \"removed\"\n        };\n\n    protected static final String[] ACTION_TARGET_STRS = {\n        \"files\",\n        \"files\",\n        \"files\",\n        \"files\",\n        \"directory\",\n        \"files\",\n        \"directories\"\n        };\n\n\n    /**\n     * internal class allowing to read the contents of a remote file system\n     * using the FTP protocol\n     * used in particular for ftp get operations\n     * differences with DirectoryScanner\n     * \"\" (the root of the fileset) is never included in the included directories\n     * followSymlinks defaults to false\n     */\n    protected class FTPDirectoryScanner extends DirectoryScanner {\n        protected FTPClient ftp = null;\n        private String rootPath = null;\n        /**\n         * since ant 1.6\n         * this flag should be set to true on UNIX and can save scanning time\n         */\n        private boolean remoteSystemCaseSensitive = false;\n        private boolean remoteSensitivityChecked = false;\n\n        /**\n         * constructor\n         * @param ftp  ftpclient object\n         */\n        public FTPDirectoryScanner(FTPClient ftp) {\n            super();\n            this.ftp = ftp;\n            this.setFollowSymlinks(false);\n        }\n\n\n        /**\n         * scans the remote directory,\n         * storing internally the included files, directories, ...\n         */\n        public void scan() {\n            if (includes == null) {\n                // No includes supplied, so set it to 'matches all'\n                includes = new String[1];\n                includes[0] = \"**\";\n            }\n            if (excludes == null) {\n                excludes = new String[0];\n            }\n\n            filesIncluded = new Vector();\n            filesNotIncluded = new Vector();\n            filesExcluded = new Vector();\n            dirsIncluded = new Vector();\n            dirsNotIncluded = new Vector();\n            dirsExcluded = new Vector();\n\n            try {\n                String cwd = ftp.printWorkingDirectory();\n                // always start from the current ftp working dir\n\n                checkIncludePatterns();\n                clearCaches();\n                ftp.changeWorkingDirectory(cwd);\n            } catch (IOException e) {\n                throw new BuildException(\"Unable to scan FTP server: \", e);\n            }\n        }\n\n\n        /**\n         * this routine is actually checking all the include patterns in\n         * order to avoid scanning everything under base dir\n         * @since ant1.6\n         */\n        private void checkIncludePatterns() {\n            Hashtable newroots = new Hashtable();\n            // put in the newroots vector the include patterns without\n            // wildcard tokens\n            for (int icounter = 0; icounter < includes.length; icounter++) {\n                String newpattern =\n                    SelectorUtils.rtrimWildcardTokens(includes[icounter]);\n                newroots.put(newpattern, includes[icounter]);\n            }\n            if (remotedir == null) {\n                try {\n                    remotedir = ftp.printWorkingDirectory();\n                } catch (IOException e) {\n                    throw new BuildException(\"could not read current ftp directory\",\n                        getLocation());\n                }\n            }\n            AntFTPFile baseFTPFile = new AntFTPRootFile(ftp, remotedir);\n            rootPath = baseFTPFile.getAbsolutePath();\n            // construct it\n            if (newroots.containsKey(\"\")) {\n                // we are going to scan everything anyway\n                scandir(rootPath, \"\", true);\n            } else {\n                // only scan directories that can include matched files or\n                // directories\n                Enumeration enum2 = newroots.keys();\n\n                while (enum2.hasMoreElements()) {\n                    String currentelement = (String) enum2.nextElement();\n                    String originalpattern = (String) newroots.get(currentelement);\n                    AntFTPFile myfile = new AntFTPFile(baseFTPFile, currentelement);\n                    boolean isOK = true;\n                    boolean traversesSymlinks = false;\n                    String path = null;\n\n                    if (myfile.exists()) {\n                        if (remoteSensitivityChecked\n                            && remoteSystemCaseSensitive && isFollowSymlinks()) {\n                            // cool case,\n                            //we do not need to scan all the subdirs in the\nrelative path\n                            path = myfile.getFastRelativePath();\n                        } else {\n                            // may be on a case insensitive file system.  We want\n                            // the results to show what's really on the disk, so\n                            // we need to double check.\n                            try {\n                                path = myfile.getRelativePath();\n                                traversesSymlinks = myfile.isTraverseSymlinks();\n                            }  catch (IOException be) {\n                                throw new BuildException(be, getLocation());\n                            } catch (BuildException be) {\n                                isOK = false;\n\n                            }\n                        }\n                    } else {\n                        isOK = false;\n                    }\n                    if (isOK) {\n                        currentelement = path.replace(remoteFileSep.charAt(0),\nFile.separatorChar);\n                        if (!isFollowSymlinks()\n                            && traversesSymlinks) {\n                            continue;\n                        }\n\n                        if (myfile.isDirectory()) {\n                            if (isIncluded(currentelement)\n                                && currentelement.length() > 0) {\n                                accountForIncludedDir(currentelement, myfile, true);\n                            }  else {\n                                if (currentelement.length() > 0) {\n                                    if (currentelement.charAt(currentelement\n                                                              .length() - 1)\n                                        != File.separatorChar) {\n                                        currentelement =\n                                            currentelement + File.separatorChar;\n                                    }\n                                }\n                                scandir(myfile.getAbsolutePath(),\ncurrentelement, true);\n                            }\n                        } else {\n                            if (isCaseSensitive\n                                && originalpattern.equals(currentelement)) {\n                                accountForIncludedFile(currentelement);\n                            } else if (!isCaseSensitive\n                                       && originalpattern\n                                       .equalsIgnoreCase(currentelement)) {\n                                accountForIncludedFile(currentelement);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /**\n         * scans a particular directory\n         * @param dir directory to scan\n         * @param vpath  relative path to the base directory of the remote fileset\n         * always ended with a File.separator\n         * @param fast seems to be always true in practice\n         */\n        protected void scandir(String dir, String vpath, boolean fast) {\n            // avoid double scanning of directories, can only happen in fast mode\n            if (fast && hasBeenScanned(vpath)) {\n                return;\n            }\n            try {\n                if (!ftp.changeWorkingDirectory(dir)) {\n                    return;\n                }\n                String completePath = null;\n                if (!vpath.equals(\"\")) {\n                    completePath = rootPath + remoteFileSep\n                        + vpath.replace(File.separatorChar,\nremoteFileSep.charAt(0));\n                } else {\n                    completePath = rootPath;\n                }\n                FTPFile[] newfiles = listFiles(completePath, false);\n\n                if (newfiles == null) {\n                    ftp.changeToParentDirectory();\n                    return;\n                }\n                for (int i = 0; i < newfiles.length; i++) {\n                    FTPFile file = newfiles[i];\n                    if (!file.getName().equals(\".\")\n                         && !file.getName().equals(\"..\")) {\n                        if (isFunctioningAsDirectory(ftp, dir, file)) {\n                            String name = vpath + file.getName();\n                            boolean slowScanAllowed = true;\n                            if (!isFollowSymlinks() && file.isSymbolicLink()) {\n                                dirsExcluded.addElement(name);\n                                slowScanAllowed = false;\n                            } else if (isIncluded(name)) {\n                                accountForIncludedDir(name,\n                                    new AntFTPFile(ftp, file, completePath) , fast);\n                            } else {\n                                dirsNotIncluded.addElement(name);\n                                if (fast && couldHoldIncluded(name)) {\n                                    scandir(file.getName(),\n                                            name + File.separator, fast);\n                                }\n                            }\n                            if (!fast && slowScanAllowed) {\n                                scandir(file.getName(),\n                                        name + File.separator, fast);\n                            }\n                        } else {\n                            String name = vpath + file.getName();\n                            if (!isFollowSymlinks() && file.isSymbolicLink()) {\n                                filesExcluded.addElement(name);\n                            } else if (isFunctioningAsFile(ftp, dir, file)) {\n                                accountForIncludedFile(name);\n                            }\n                        }\n                    }\n                }\n                ftp.changeToParentDirectory();\n            } catch (IOException e) {\n                throw new BuildException(\"Error while communicating with FTP \"\n                     + \"server: \", e);\n            }\n        }\n        /**\n         * process included file\n         * @param name  path of the file relative to the directory of the fileset\n         */\n        private void accountForIncludedFile(String name) {\n            if (!filesIncluded.contains(name)\n                && !filesExcluded.contains(name)) {\n\n                if (isIncluded(name)) {\n                    if (!isExcluded(name)) {\n                        filesIncluded.addElement(name);\n                    } else {\n                        filesExcluded.addElement(name);\n                    }\n                } else {\n                    filesNotIncluded.addElement(name);\n                }\n            }\n        }\n\n        /**\n         *\n         * @param name path of the directory relative to the directory of\n         * the fileset\n         * @param file directory as file\n         * @param fast\n         */\n        private void accountForIncludedDir(String name, AntFTPFile file, boolean\nfast) {\n            if (!dirsIncluded.contains(name)\n                && !dirsExcluded.contains(name)) {\n\n                if (!isExcluded(name)) {\n                    if (fast) {\n                        if (file.isSymbolicLink()) {\n                            try {\n                               \nfile.getClient().changeWorkingDirectory(file.curpwd);\n                            } catch (IOException ioe) {\n                                throw new BuildException(\"could not change\ndirectory to curpwd\");\n                            }\n                            scandir(file.getLink(),\n                                name + File.separator, fast);\n                        } else {\n                            try {\n                               \nfile.getClient().changeWorkingDirectory(file.curpwd);\n                            } catch (IOException ioe) {\n                                throw new BuildException(\"could not change\ndirectory to curpwd\");\n                            }\n                            scandir(file.getName(),\n                                name + File.separator, fast);\n                        }\n                    }\n                    dirsIncluded.addElement(name);\n                } else {\n                    dirsExcluded.addElement(name);\n                    if (fast && couldHoldIncluded(name)) {\n                        try {\n                            file.getClient().changeWorkingDirectory(file.curpwd);\n                        } catch (IOException ioe) {\n                            throw new BuildException(\"could not change directory\nto curpwd\");\n                        }\n                        scandir(file.getName(),\n                                name + File.separator, fast);\n                    }\n                }\n            }\n        }\n        /**\n         * temporary table to speed up the various scanning methods below\n         *\n         * @since Ant 1.6\n         */\n        private Map fileListMap = new HashMap();\n        /**\n         * List of all scanned directories.\n         *\n         * @since Ant 1.6\n         */\n        private Set scannedDirs = new HashSet();\n\n        /**\n         * Has the directory with the given path relative to the base\n         * directory already been scanned?\n         *\n         * <p>Registers the given directory as scanned as a side effect.</p>\n         *\n         * @since Ant 1.6\n         */\n        private boolean hasBeenScanned(String vpath) {\n            return !scannedDirs.add(vpath);\n        }\n\n        /**\n         * Clear internal caches.\n         *\n         * @since Ant 1.6\n         */\n        private void clearCaches() {\n            fileListMap.clear();\n            scannedDirs.clear();\n        }\n        /**\n         * list the files present in one directory.\n         * @param directory full path on the remote side\n         * @param changedir if true change to directory directory before listing\n         * @return array of FTPFile\n         */\n        public FTPFile[] listFiles(String directory, boolean changedir) {\n            //getProject().log(\"listing files in directory \" + directory,\nProject.MSG_DEBUG);\n            String currentPath = directory;\n            if (changedir) {\n                try {\n                    boolean result = ftp.changeWorkingDirectory(directory);\n                    if (!result) {\n                        return null;\n                    }\n                    currentPath = ftp.printWorkingDirectory();\n                } catch (IOException ioe) {\n                    throw new BuildException(ioe, getLocation());\n                }\n            }\n            if (fileListMap.containsKey(currentPath)) {\n                getProject().log(\"filelist map used in listing files\",\nProject.MSG_DEBUG);\n                return ((FTPFile[]) fileListMap.get(currentPath));\n            }\n            FTPFile[] result = null;\n            try {\n                result = ftp.listFiles();\n            } catch (IOException ioe) {\n                throw new BuildException(ioe, getLocation());\n            }\n            fileListMap.put(currentPath, result);\n            if (!remoteSensitivityChecked) {\n                checkRemoteSensitivity(result, directory);\n            }\n            return result;\n        }\n        /**\n         * cd into one directory and\n         * list the files present in one directory.\n         * @param directory full path on the remote side\n         * @return array of FTPFile\n         */\n        public FTPFile[] listFiles(String directory) {\n            return listFiles(directory, true);\n        }\n        private void checkRemoteSensitivity(FTPFile[] array, String directory) {\n            if (array == null) {\n                return;\n            }\n            boolean candidateFound = false;\n            String target = null;\n            for (int icounter = 0; icounter < array.length; icounter++) {\n                if (array[icounter].isDirectory()) {\n                    if (!array[icounter].getName().equals(\".\")\n                        && !array[icounter].getName().equals(\"..\")) {\n                        candidateFound = true;\n                        target = fiddleName(array[icounter].getName());\n                        getProject().log(\"will try to cd to \"\n                            + target + \" where a directory called \" +\narray[icounter].getName()\n                            + \" exists\", Project.MSG_DEBUG);\n                        for (int pcounter = 0; pcounter < array.length;\npcounter++) {\n                            if (array[pcounter].getName().equals(target) &&\npcounter != icounter) {\n                                candidateFound = false;\n                            }\n                        }\n                        if (candidateFound) {\n                            break;\n                        }\n                    }\n                }\n            }\n            if (candidateFound) {\n                try {\n                    getProject().log(\"testing case sensitivity, attempting to cd\nto \"\n                        + target, Project.MSG_DEBUG);\n                    remoteSystemCaseSensitive  =\n!ftp.changeWorkingDirectory(target);\n                } catch (IOException ioe) {\n                    remoteSystemCaseSensitive = true;\n                } finally {\n                    try {\n                        ftp.changeWorkingDirectory(directory);\n                    } catch (IOException ioe) {\n                        throw new BuildException(ioe, getLocation());\n                    }\n                }\n                getProject().log(\"remote system is case sensitive : \" +\nremoteSystemCaseSensitive,\n                    Project.MSG_VERBOSE);\n                remoteSensitivityChecked = true;\n            }\n        }\n        private String fiddleName(String origin) {\n            StringBuffer result = new StringBuffer();\n            for (int icounter = 0; icounter < origin.length(); icounter++) {\n                if (Character.isLowerCase(origin.charAt(icounter))) {\n                    result.append(Character.toUpperCase(origin.charAt(icounter)));\n                } else if (Character.isUpperCase(origin.charAt(icounter))) {\n                    result.append(Character.toLowerCase(origin.charAt(icounter)));\n                } else {\n                    result.append(origin.charAt(icounter));\n                }\n            }\n            return result.toString();\n        }\n        /**\n         * an AntFTPFile is a representation of a remote file\n         * @since Ant 1.6\n         */\n        protected class AntFTPFile {\n            /**\n             * ftp client\n             */\n            private FTPClient client;\n            /**\n             * parent directory of the file\n             */\n            private String curpwd;\n            /**\n             * the file itself\n             */\n            private FTPFile ftpFile;\n            /**\n             *\n             */\n            private AntFTPFile parent = null;\n            private boolean relativePathCalculated = false;\n            private boolean traversesSymlinks = false;\n            private String relativePath = \"\";\n            /**\n             * constructor\n             * @param client ftp client variable\n             * @param ftpFile the file\n             * @param curpwd absolute remote path where the file is found\n             */\n            public AntFTPFile(FTPClient client, FTPFile ftpFile, String curpwd) {\n                this.client = client;\n                this.ftpFile = ftpFile;\n                this.curpwd = curpwd;\n            }\n            /**\n             * other constructor\n             * @param parent the parent file\n             * @param path  a relative path to the parent file\n             */\n            public AntFTPFile(AntFTPFile parent, String path) {\n                this.parent = parent;\n                this.client = parent.client;\n                Vector pathElements = SelectorUtils.tokenizePath(path);\n                try {\n                    boolean result =\nthis.client.changeWorkingDirectory(parent.getAbsolutePath());\n                    //this should not happen, except if parent has been deleted\nby another process\n                    if (!result) {\n                        return;\n                    }\n                    this.curpwd = parent.getAbsolutePath();\n                } catch (IOException ioe) {\n                    throw new BuildException(\"could not change working dir to \"\n                    + parent.curpwd);\n                }\n                for (int fcount = 0; fcount < pathElements.size() - 1; fcount++) {\n                    String currentPathElement = (String)\npathElements.elementAt(fcount);\n                    try {\n                        boolean result =\nthis.client.changeWorkingDirectory(currentPathElement);\n                        if (!result && !isCaseSensitive()\n                            && (remoteSystemCaseSensitive ||\n!remoteSensitivityChecked)) {\n                           currentPathElement =\nfindPathElementCaseUnsensitive(this.curpwd,\n                               currentPathElement);\n                            if (currentPathElement == null) {\n                                return;\n                            }\n                        } else if (!result) {\n                            return;\n                        }\n                        this.curpwd = this.curpwd + remoteFileSep\n                            + currentPathElement;\n                    } catch (IOException ioe) {\n                        throw new BuildException(\"could not change working dir to \"\n                        + (String) pathElements.elementAt(fcount)\n                            + \" from \" + this.curpwd);\n                    }\n\n                }\n                String lastpathelement = (String)\npathElements.elementAt(pathElements.size() - 1);\n                FTPFile [] theFiles = listFiles(this.curpwd);\n                this.ftpFile = getFile(theFiles, lastpathelement);\n            }\n            /**\n             * find a file in a directory in case unsensitive way\n             * @param parentPath        where we are\n             * @param soughtPathElement what is being sought\n             * @return                  the first file found or null if not found\n             */\n            private String findPathElementCaseUnsensitive(String parentPath,\n                               String soughtPathElement) {\n                // we are already in the right path, so the second parameter\n                // is false\n                FTPFile[] theFiles = listFiles(parentPath, false);\n                if (theFiles == null) {\n                    return null;\n                }\n                for (int icounter = 0; icounter < theFiles.length; icounter++) {\n                    if\n(theFiles[icounter].getName().equalsIgnoreCase(soughtPathElement)) {\n                        return theFiles[icounter].getName();\n                    }\n                }\n                return null;\n            }\n            /**\n             * find out if the file exists\n             * @return  true if the file exists\n             */\n            public boolean exists() {\n                return (ftpFile != null);\n            }\n            /**\n             * if the file is a symbolic link, find out to what it is pointing\n             * @return the target of the symbolic link\n             */\n            public String getLink() {\n                return ftpFile.getLink();\n            }\n            /**\n             * get the name of the file\n             * @return the name of the file\n             */\n            public String getName() {\n                return ftpFile.getName();\n            }\n            /**\n             * find out the absolute path of the file\n             * @return absolute path as string\n             */\n            public String getAbsolutePath() {\n                return curpwd + remoteFileSep + ftpFile.getName();\n            }\n            /**\n             * find out the relative path assuming that the path used to construct\n             * this AntFTPFile was spelled properly with regards to case.\n             * This is OK on a case sensitive system such as UNIX\n             * @return relative path\n             */\n            public String getFastRelativePath() {\n                String absPath = getAbsolutePath();\n                if (absPath.indexOf(rootPath + remoteFileSep) == 0) {\n                    return absPath.substring(rootPath.length() +\nremoteFileSep.length());\n                }\n                return null;\n            }\n            /**\n             * find out the relative path to the rootPath of the enclosing scanner.\n             * this relative path is spelled exactly like on disk,\n             * for instance if the AntFTPFile has been instantiated as ALPHA,\n             * but the file is really called alpha, this method will return alpha.\n             * If a symbolic link is encountered, it is followed, but the name\nof the link\n             * rather than the name of the target is returned.\n             * (ie does not behave like File.getCanonicalPath())\n             * @return                relative path, separated by remoteFileSep\n             * @throws IOException    if a change directory fails, ...\n             * @throws BuildException if one of the components of the relative\npath cannot\n             * be found.\n             */\n            public String getRelativePath() throws IOException, BuildException {\n                if (!relativePathCalculated) {\n                    if (parent != null) {\n                        traversesSymlinks = parent.isTraverseSymlinks();\n                        relativePath = getRelativePath(parent.getAbsolutePath(),\n                            parent.getRelativePath());\n                    } else {\n                        relativePath = getRelativePath(rootPath, \"\");\n                        relativePathCalculated = true;\n                    }\n                }\n                return relativePath;\n            }\n            /**\n             * get thge relative path of this file\n             * @param currentPath          base path\n             * @param currentRelativePath  relative path of the base path with\nregards to remote dir\n             * @return relative path\n             */\n            private String getRelativePath(String currentPath, String\ncurrentRelativePath) {\n                Vector pathElements =\nSelectorUtils.tokenizePath(getAbsolutePath(), remoteFileSep);\n                Vector pathElements2 = SelectorUtils.tokenizePath(currentPath,\nremoteFileSep);\n                String relPath = currentRelativePath;\n                for (int pcount = pathElements2.size(); pcount <\npathElements.size(); pcount++) {\n                    String currentElement = (String) pathElements.elementAt(pcount);\n                    FTPFile[] theFiles = listFiles(currentPath);\n                    FTPFile theFile = null;\n                    if (theFiles != null) {\n                        theFile = getFile(theFiles, currentElement);\n                    }\n                    if (theFile == null) {\n                        throw new BuildException(\"could not find \" + currentElement\n                            + \" from \" + currentPath);\n                    } else {\n                        traversesSymlinks = traversesSymlinks ||\ntheFile.isSymbolicLink();\n                        if (!relPath.equals(\"\")) {\n                            relPath = relPath + remoteFileSep;\n                        }\n                        relPath = relPath + theFile.getName();\n                        currentPath = currentPath + remoteFileSep +\ntheFile.getName();\n                    }\n                }\n                return relPath;\n            }\n            /**\n             * find a file matching a string in an array of FTPFile.\n             * This method will find \"alpha\" when requested for \"ALPHA\"\n             * if and only if the caseSensitive attribute is set to false.\n             * When caseSensitive is set to true, only the exact match is returned.\n             * @param theFiles  array of files\n             * @param lastpathelement  the file name being sought\n             * @return null if the file cannot be found, otherwise return the\nmatching file.\n             */\n            public FTPFile getFile(FTPFile[] theFiles, String lastpathelement) {\n                if (theFiles == null) {\n                    return null;\n                }\n                for (int fcount = 0; fcount < theFiles.length; fcount++) {\n                     if (theFiles[fcount].getName().equals(lastpathelement)) {\n                         return theFiles[fcount];\n                     } else if (!isCaseSensitive()\n                         &&\ntheFiles[fcount].getName().equalsIgnoreCase(lastpathelement)) {\n                         return theFiles[fcount];\n                     }\n                }\n                return null;\n            }\n            /**\n             * tell if a file is a directory.\n             * note that it will return false for symbolic links pointing to\ndirectories.\n             * @return <code>true</code> for directories\n             */\n            public boolean isDirectory() {\n                return ftpFile.isDirectory();\n            }\n            /**\n             * tell if a file is a symbolic link\n             * @return <code>true</code> for symbolic links\n             */\n            public boolean isSymbolicLink() {\n                return ftpFile.isSymbolicLink();\n            }\n            /**\n             * return the attached FTP client object.\n             * Warning : this instance is really shared with the enclosing class.\n             * @return  FTP client\n             */\n            protected FTPClient getClient() {\n                return client;\n            }\n\n            /**\n             * sets the current path of an AntFTPFile\n             * @param curpwd the current path one wants to set\n             */\n            protected void setCurpwd(String curpwd) {\n                this.curpwd = curpwd;\n            }\n            /**\n             * returns the path of the directory containing the AntFTPFile.\n             * of the full path of the file itself in case of AntFTPRootFile\n             * @return parent directory of the AntFTPFile\n             */\n            public String getCurpwd() {\n                return curpwd;\n            }\n            /**\n             * find out if a symbolic link is encountered in the relative path\nof this file\n             * from rootPath.\n             * @return <code>true</code> if a symbolic link is encountered in\nthe relative path.\n             * @throws IOException if one of the change directory or directory\nlisting operations\n             * fails\n             * @throws BuildException if a path component in the relative path\ncannot be found.\n             */\n            public boolean isTraverseSymlinks() throws IOException, BuildException {\n                if (!relativePathCalculated) {\n                    // getRelativePath also finds about symlinks\n                    String relpath = getRelativePath();\n                }\n                return traversesSymlinks;\n            }\n        }\n        /**\n         * special class to represent the remote directory itself\n         * @since Ant 1.6\n         */\n        protected class AntFTPRootFile extends AntFTPFile {\n             private String remotedir;\n            /**\n             * constructor\n             * @param aclient FTP client\n             * @param remotedir remote directory\n             */\n             public AntFTPRootFile(FTPClient aclient, String remotedir) {\n                 super(aclient, null, remotedir);\n                 this.remotedir = remotedir;\n                 try {\n                     this.getClient().changeWorkingDirectory(this.remotedir);\n                     this.setCurpwd(this.getClient().printWorkingDirectory());\n                 } catch (IOException ioe) {\n                     throw new BuildException(ioe, getLocation());\n                 }\n             }\n            /**\n             * find the absolute path\n             * @return absolute path\n             */\n            public String getAbsolutePath() {\n                return this.getCurpwd();\n            }\n            /**\n             * find out the relative path to root\n             * @return empty string\n             * @throws BuildException actually never\n             * @throws IOException  actually never\n             */\n            public String getRelativePath() throws BuildException, IOException {\n                 return \"\";\n            }\n        }\n    }\n    /**\n     * check FTPFiles to check whether they function as directories too\n     * the FTPFile API seem to make directory and symbolic links incompatible\n     * we want to find out if we can cd to a symbolic link\n     * @param dir  the parent directory of the file to test\n     * @param file the file to test\n     * @return true if it is possible to cd to this directory\n     * @since ant 1.6\n     */\n    private boolean isFunctioningAsDirectory(FTPClient ftp, String dir, FTPFile\nfile) {\n        boolean result = false;\n        String currentWorkingDir = null;\n        if (file.isDirectory()) {\n            return true;\n        } else if (file.isFile()) {\n            return false;\n        }\n        try {\n            currentWorkingDir = ftp.printWorkingDirectory();\n        } catch (IOException ioe) {\n            getProject().log(\"could not find current working directory \" + dir\n                + \" while checking a symlink\",\n                Project.MSG_DEBUG);\n        }\n        if (currentWorkingDir != null) {\n            try {\n                result = ftp.changeWorkingDirectory(file.getLink());\n            } catch (IOException ioe) {\n                getProject().log(\"could not cd to \" + file.getLink() + \" while\nchecking a symlink\",\n                    Project.MSG_DEBUG);\n            }\n            if (result) {\n                boolean comeback = false;\n                try {\n                    comeback = ftp.changeWorkingDirectory(currentWorkingDir);\n                } catch (IOException ioe) {\n                    getProject().log(\"could not cd back to \" + dir + \" while\nchecking a symlink\",\n                        Project.MSG_ERR);\n                } finally {\n                    if (!comeback) {\n                        throw new BuildException(\"could not cd back to \" + dir\n                            + \" while checking a symlink\");\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * check FTPFiles to check whether they function as directories too\n     * the FTPFile API seem to make directory and symbolic links incompatible\n     * we want to find out if we can cd to a symbolic link\n     * @param dir  the parent directory of the file to test\n     * @param file the file to test\n     * @return true if it is possible to cd to this directory\n     * @since ant 1.6\n     */\n    private boolean isFunctioningAsFile(FTPClient ftp, String dir, FTPFile file) {\n        if (file.isDirectory()) {\n            return false;\n        } else if (file.isFile()) {\n            return true;\n        }\n        return !isFunctioningAsDirectory(ftp, dir, file);\n    }\n    /**\n     * Sets the remote directory where files will be placed. This may be a\n     * relative or absolute path, and must be in the path syntax expected by\n     * the remote server. No correction of path syntax will be performed.\n     *\n     * @param dir the remote directory name.\n     */\n    public void setRemotedir(String dir) {\n        this.remotedir = dir;\n    }\n\n\n    /**\n     * Sets the FTP server to send files to.\n     *\n     * @param server the remote server name.\n     */\n    public void setServer(String server) {\n        this.server = server;\n    }\n\n\n    /**\n     * Sets the FTP port used by the remote server.\n     *\n     * @param port the port on which the remote server is listening.\n     */\n    public void setPort(int port) {\n        this.port = port;\n    }\n\n\n    /**\n     * Sets the login user id to use on the specified server.\n     *\n     * @param userid remote system userid.\n     */\n    public void setUserid(String userid) {\n        this.userid = userid;\n    }\n\n\n    /**\n     * Sets the login password for the given user id.\n     *\n     * @param password the password on the remote system.\n     */\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n\n    /**\n     * If true, uses binary mode, otherwise text mode (default is binary).\n     *\n     * @param binary if true use binary mode in transfers.\n     */\n    public void setBinary(boolean binary) {\n        this.binary = binary;\n    }\n\n\n    /**\n     * Specifies whether to use passive mode. Set to true if you are behind a\n     * firewall and cannot connect without it. Passive mode is disabled by\n     * default.\n     *\n     * @param passive true is passive mode should be used.\n     */\n    public void setPassive(boolean passive) {\n        this.passive = passive;\n    }\n\n\n    /**\n     * Set to true to receive notification about each file as it is\n     * transferred.\n     *\n     * @param verbose true if verbose notifications are required.\n     */\n    public void setVerbose(boolean verbose) {\n        this.verbose = verbose;\n    }\n\n\n    /**\n     * A synonym for <tt>depends</tt>. Set to true to transmit only new\n     * or changed files.\n     *\n     * See the related attributes timediffmillis and timediffauto.\n     *\n     * @param newer if true only transfer newer files.\n     */\n    public void setNewer(boolean newer) {\n        this.newerOnly = newer;\n    }\n\n    /**\n     * number of milliseconds to add to the time on the remote machine\n     * to get the time on the local machine.\n     *\n     * use in conjunction with <code>newer</code>\n     *\n     * @param timeDiffMillis number of milliseconds\n     *\n     * @since ant 1.6\n     */\n    public void setTimeDiffMillis(long timeDiffMillis) {\n        this.timeDiffMillis = timeDiffMillis;\n    }\n\n    /**\n     * &quot;true&quot; to find out automatically the time difference\n     * between local and remote machine.\n     *\n     * This requires right to create\n     * and delete a temporary file in the remote directory.\n     *\n     * @param timeDiffAuto true = find automatically the time diff\n     *\n     * @since ant 1.6\n     */\n    public void setTimeDiffAuto(boolean timeDiffAuto) {\n        this.timeDiffAuto = timeDiffAuto;\n    }\n\n    /**\n     * Set to true to preserve modification times for \"gotten\" files.\n     *\n     * @param preserveLastModified if true preserver modification times.\n     */\n    public void setPreserveLastModified(boolean preserveLastModified) {\n        this.preserveLastModified = preserveLastModified;\n    }\n\n\n    /**\n     * Set to true to transmit only files that are new or changed from their\n     * remote counterparts. The default is to transmit all files.\n     *\n     * @param depends if true only transfer newer files.\n     */\n    public void setDepends(boolean depends) {\n        this.newerOnly = depends;\n    }\n\n\n    /**\n     * Sets the remote file separator character. This normally defaults to the\n     * Unix standard forward slash, but can be manually overridden using this\n     * call if the remote server requires some other separator. Only the first\n     * character of the string is used.\n     *\n     * @param separator the file separator on the remote system.\n     */\n    public void setSeparator(String separator) {\n        remoteFileSep = separator;\n    }\n\n\n    /**\n     * Sets the file permission mode (Unix only) for files sent to the\n     * server.\n     *\n     * @param theMode unix style file mode for the files sent to the remote\n     *        system.\n     */\n    public void setChmod(String theMode) {\n        this.chmod = theMode;\n    }\n\n\n    /**\n     * Sets the default mask for file creation on a unix server.\n     *\n     * @param theUmask unix style umask for files created on the remote server.\n     */\n    public void setUmask(String theUmask) {\n        this.umask = theUmask;\n    }\n\n\t\t\n\t\t\n    /**\n     * JPEER\n\t\t * Sets the limit of re-connects on error. Useful for instable connections.\n     * \n     * @param maxAttempts, an integer number equal or greather than 1 \n     */\n    public void setMaxAttempts(int maxAttempts) {\n        this.maxAttempts = maxAttempts;\n    }\n\t\t\n\t\t\n\n    /**\n     *  A set of files to upload or download\n     *\n     * @param set the set of files to be added to the list of files to be\n     *        transferred.\n     */\n    public void addFileset(FileSet set) {\n        filesets.addElement(set);\n    }\n\n\n    /**\n     * Sets the FTP action to be taken. Currently accepts \"put\", \"get\", \"del\",\n     * \"mkdir\" and \"list\".\n     *\n     * @deprecated setAction(String) is deprecated and is replaced with\n     *      setAction(FTP.Action) to make Ant's Introspection mechanism do the\n     *      work and also to encapsulate operations on the type in its own\n     *      class.\n     * @ant.attribute ignore=\"true\"\n     *\n     * @param action the FTP action to be performed.\n     *\n     * @throws BuildException if the action is not a valid action.\n     */\n    public void setAction(String action) throws BuildException {\n        log(\"DEPRECATED - The setAction(String) method has been deprecated.\"\n             + \" Use setAction(FTP.Action) instead.\");\n\n        Action a = new Action();\n\n        a.setValue(action);\n        this.action = a.getAction();\n    }\n\n\n    /**\n     * Sets the FTP action to be taken. Currently accepts \"put\", \"get\", \"del\",\n     * \"mkdir\", \"chmod\" and \"list\".\n     *\n     * @param action the FTP action to be performed.\n     *\n     * @throws BuildException if the action is not a valid action.\n     */\n    public void setAction(Action action) throws BuildException {\n        this.action = action.getAction();\n    }\n\n\n    /**\n     * The output file for the \"list\" action. This attribute is ignored for\n     * any other actions.\n     *\n     * @param listing file in which to store the listing.\n     */\n    public void setListing(File listing) {\n        this.listing = listing;\n    }\n\n\n    /**\n     * If true, enables unsuccessful file put, delete and get\n     * operations to be skipped with a warning and the remainder\n     * of the files still transferred.\n     *\n     * @param skipFailedTransfers true if failures in transfers are ignored.\n     */\n    public void setSkipFailedTransfers(boolean skipFailedTransfers) {\n        this.skipFailedTransfers = skipFailedTransfers;\n    }\n\n\n    /**\n     * set the flag to skip errors on directory creation.\n     * (and maybe later other server specific errors)\n     *\n     * @param ignoreNoncriticalErrors true if non-critical errors should not\n     *        cause a failure.\n     */\n    public void setIgnoreNoncriticalErrors(boolean ignoreNoncriticalErrors) {\n        this.ignoreNoncriticalErrors = ignoreNoncriticalErrors;\n    }\n\n\n    /**\n     * Checks to see that all required parameters are set.\n     *\n     * @throws BuildException if the configuration is not valid.\n     */\n    protected void checkConfiguration() throws BuildException {\n        if (server == null) {\n            throw new BuildException(\"server attribute must be set!\");\n        }\n        if (userid == null) {\n            throw new BuildException(\"userid attribute must be set!\");\n        }\n        if (password == null) {\n            throw new BuildException(\"password attribute must be set!\");\n        }\n\n        if ((action == LIST_FILES) && (listing == null)) {\n            throw new BuildException(\"listing attribute must be set for list \"\n                 + \"action!\");\n        }\n\n        if (action == MK_DIR && remotedir == null) {\n            throw new BuildException(\"remotedir attribute must be set for \"\n                 + \"mkdir action!\");\n        }\n\n        if (action == CHMOD && chmod == null) {\n            throw new BuildException(\"chmod attribute must be set for chmod \"\n                 + \"action!\");\n        }\n    }\n\n\n    /**\n     * For each file in the fileset, do the appropriate action: send, get,\n     * delete, or list.\n     *\n     * @param ftp the FTPClient instance used to perform FTP actions\n     * @param fs the fileset on which the actions are performed.\n     *\n     * @return the number of files to be transferred.\n     *\n     * @throws IOException if there is a problem reading a file\n     * @throws BuildException if there is a problem in the configuration.\n     */\n    protected int transferFiles(FTPClient ftp, FileSet fs)\n         throws IOException, BuildException {\n        DirectoryScanner ds;\n\n        if (action == SEND_FILES) {\n            ds = fs.getDirectoryScanner(getProject());\n        } else {\n            // warn that selectors are not supported\n            if (fs.getSelectors(getProject()).length != 0) {\n                getProject().log(\"selectors are not supported in remote filesets\",\n                    Project.MSG_WARN);\n            }\n            ds = new FTPDirectoryScanner(ftp);\n            fs.setupDirectoryScanner(ds, getProject());\n            ds.setFollowSymlinks(fs.isFollowSymlinks());\n            ds.scan();\n        }\n\n        String[] dsfiles = null;\n        if (action == RM_DIR) {\n            dsfiles = ds.getIncludedDirectories();\n        } else {\n            dsfiles = ds.getIncludedFiles();\n        }\n        String dir = null;\n\n        if ((ds.getBasedir() == null)\n             && ((action == SEND_FILES) || (action == GET_FILES))) {\n            throw new BuildException(\"the dir attribute must be set for send \"\n                 + \"and get actions\");\n        } else {\n            if ((action == SEND_FILES) || (action == GET_FILES)) {\n                dir = ds.getBasedir().getAbsolutePath();\n            }\n        }\n\n        // If we are doing a listing, we need the output stream created now.\n        BufferedWriter bw = null;\n\n        try {\n            if (action == LIST_FILES) {\n                File pd = fileUtils.getParentFile(listing);\n\n                if (!pd.exists()) {\n                    pd.mkdirs();\n                }\n                bw = new BufferedWriter(new FileWriter(listing));\n            }\n            if (action == RM_DIR) {\n                // to remove directories, start by the end of the list\n                // the trunk does not let itself be removed before the leaves\n                for (int i = dsfiles.length - 1; i >= 0; i--) {\n                    rmDir(ftp, dsfiles[i]);\n                }\n            }   else {\n                for (int i = 0; i < dsfiles.length; i++) {\n\t\t\t\t\t\t\t\t\t// JPEER\n\t\t\t\t\t\t\t\t\t// don't quit until transfer success or maxAttempts exceeded\n\t\t\t\t\t\t\t\t  boolean success = false;\n\t\t\t\t\t\t\t\t\tint attempts = 0;\n\t\t\t\t\t\t\t\t\twhile(!success) {\n\t\t\t\t\t\t\t\t\t\tif(attempts > 0) { log(\"attempt nr. \"+(attempts+1)+\"...\"); } \n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\t\tswitch (action) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase SEND_FILES:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsendFile(ftp, dir, dsfiles[i]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsuccess = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase GET_FILES:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgetFile(ftp, dir, dsfiles[i]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsuccess = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase DEL_FILES:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdelFile(ftp, dsfiles[i]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsuccess = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase LIST_FILES:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlistFile(ftp, bw, dsfiles[i]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsuccess = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase CHMOD:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoSiteCommand(ftp, \"chmod \" + chmod + \" \" +\nresolveFile(dsfiles[i]));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsuccess = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttransferred++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new BuildException(\"unknown ftp action \" + action);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} catch(IOException ioe) {\n\t\t\t\t\t\t\t\t\t\t\tattempts++;\n\t\t\t\t\t\t\t\t\t\t\tif(attempts >= maxAttempts) {\n\t\t\t\t\t\t\t\t\t\t\t\tlog(\"maxAttempts exceeded, aborting.\");\n\t\t\t\t\t\t\t\t\t\t\t\tthrow ioe;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t// get ready for next attempt\n\t\t\t\t\t\t\t\t\t\t\tftp = initFTPClient();\n\t\t\t\t\t\t\t\t\t\t\tprepareForTransfer(ftp);\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n                }\n            }\n        } finally {\n            if (bw != null) {\n                bw.close();\n            }\n        }\n\n        return dsfiles.length;\n    }\n\n\n    /**\n     * Sends all files specified by the configured filesets to the remote\n     * server.\n     *\n     * @param ftp the FTPClient instance used to perform FTP actions\n     *\n     * @throws IOException if there is a problem reading a file\n     * @throws BuildException if there is a problem in the configuration.\n     */\n    protected void transferFiles(FTPClient ftp)\n         throws IOException, BuildException {\n        transferred = 0;\n        skipped = 0;\n\n        if (filesets.size() == 0) {\n            throw new BuildException(\"at least one fileset must be specified.\");\n        } else {\n            // get files from filesets\n            for (int i = 0; i < filesets.size(); i++) {\n                FileSet fs = (FileSet) filesets.elementAt(i);\n\n                if (fs != null) {\n                    transferFiles(ftp, fs);\n                }\n            }\n        }\n\n        log(transferred + \" \" + ACTION_TARGET_STRS[action] + \" \"\n            + COMPLETED_ACTION_STRS[action]);\n        if (skipped != 0) {\n            log(skipped + \" \" + ACTION_TARGET_STRS[action]\n                + \" were not successfully \" + COMPLETED_ACTION_STRS[action]);\n        }\n    }\n\n\n    /**\n     * Correct a file path to correspond to the remote host requirements. This\n     * implementation currently assumes that the remote end can handle\n     * Unix-style paths with forward-slash separators. This can be overridden\n     * with the <code>separator</code> task parameter. No attempt is made to\n     * determine what syntax is appropriate for the remote host.\n     *\n     * @param file the remote file name to be resolved\n     *\n     * @return the filename as it will appear on the server.\n     */\n    protected String resolveFile(String file) {\n        return file.replace(System.getProperty(\"file.separator\").charAt(0),\n            remoteFileSep.charAt(0));\n    }\n\n\n    /**\n     * Creates all parent directories specified in a complete relative\n     * pathname. Attempts to create existing directories will not cause\n     * errors.\n     *\n     * @param ftp the FTP client instance to use to execute FTP actions on\n     *        the remote server.\n     * @param filename the name of the file whose parents should be created.\n     * @throws IOException under non documented circumstances\n     * @throws BuildException if it is impossible to cd to a remote directory\n     *\n     */\n    protected void createParents(FTPClient ftp, String filename)\n         throws IOException, BuildException {\n\n        File dir = new File(filename);\n        if (dirCache.contains(dir)) {\n            return;\n        }\n\n\n        Vector parents = new Vector();\n        String dirname;\n\n        while ((dirname = dir.getParent()) != null) {\n            File checkDir = new File(dirname);\n            if (dirCache.contains(checkDir)) {\n                break;\n            }\n            dir = checkDir;\n            parents.addElement(dir);\n        }\n\n        // find first non cached dir\n        int i = parents.size() - 1;\n\n        if (i >= 0) {\n            String cwd = ftp.printWorkingDirectory();\n            String parent = dir.getParent();\n            if (parent != null) {\n                if (!ftp.changeWorkingDirectory(resolveFile(parent))) {\n                    throw new BuildException(\"could not change to \"\n                        + \"directory: \" + ftp.getReplyString());\n                }\n            }\n\n            while (i >= 0) {\n                dir = (File) parents.elementAt(i--);\n                // check if dir exists by trying to change into it.\n                if (!ftp.changeWorkingDirectory(dir.getName())) {\n                    // could not change to it - try to create it\n                    log(\"creating remote directory \"\n                        + resolveFile(dir.getPath()), Project.MSG_VERBOSE);\n                    if (!ftp.makeDirectory(dir.getName())) {\n                        handleMkDirFailure(ftp);\n                    }\n                    if (!ftp.changeWorkingDirectory(dir.getName())) {\n                        throw new BuildException(\"could not change to \"\n                            + \"directory: \" + ftp.getReplyString());\n                    }\n                }\n                dirCache.addElement(dir);\n            }\n            ftp.changeWorkingDirectory(cwd);\n        }\n    }\n    /**\n     * auto find the time difference between local and remote\n     * @param ftp handle to ftp client\n     * @return number of millis to add to remote time to make it comparable to\nlocal time\n     * @since ant 1.6\n     */\n    private long getTimeDiff(FTPClient ftp) {\n        long returnValue = 0;\n        File tempFile = findFileName(ftp);\n        try {\n            // create a local temporary file\n            fileUtils.createNewFile(tempFile);\n            long localTimeStamp = tempFile.lastModified();\n            BufferedInputStream instream = new BufferedInputStream(new\nFileInputStream(tempFile));\n            ftp.storeFile(tempFile.getName(), instream);\n            instream.close();\n            boolean success = FTPReply.isPositiveCompletion(ftp.getReplyCode());\n            if (success) {\n                FTPFile [] ftpFiles = ftp.listFiles(tempFile.getName());\n                if (ftpFiles.length == 1) {\n                    long remoteTimeStamp =\nftpFiles[0].getTimestamp().getTime().getTime();\n                    returnValue = remoteTimeStamp - localTimeStamp;\n                }\n                ftp.deleteFile(ftpFiles[0].getName());\n            }\n            // delegate the deletion of the local temp file to the delete task\n            // because of race conditions occuring on Windows\n            Delete mydelete = (Delete) getProject().createTask(\"delete\");\n            mydelete.setFile(tempFile.getCanonicalFile());\n            mydelete.execute();\n        } catch (Exception e) {\n            throw new BuildException(e, getLocation());\n        }\n        return returnValue;\n    }\n    /**\n     *  find a suitable name for local and remote temporary file\n     */\n    private File findFileName(FTPClient ftp) {\n        FTPFile [] theFiles = null;\n        final int maxIterations = 1000;\n        for (int counter = 1; counter < maxIterations; counter++) {\n            File localFile = fileUtils.createTempFile(\"ant\" +\nInteger.toString(counter), \".tmp\",\n                null);\n            String fileName = localFile.getName();\n            boolean found = false;\n            try {\n                if (counter == 1) {\n                    theFiles = ftp.listFiles();\n                }\n                for (int counter2 = 0; counter2 < theFiles.length; counter2++) {\n                    if (theFiles[counter2].getName().equals(fileName)) {\n                        found = true;\n                        break;\n                    }\n                }\n            } catch (IOException ioe) {\n                throw new BuildException(ioe, getLocation());\n            }\n            if (!found) {\n                localFile.deleteOnExit();\n                return localFile;\n            }\n        }\n        return null;\n    }\n    /**\n     * Checks to see if the remote file is current as compared with the local\n     * file. Returns true if the target file is up to date.\n     * @param ftp ftpclient\n     * @param localFile local file\n     * @param remoteFile remote file\n     * @return true if the target file is up to date\n     * @throws IOException  in unknown circumstances\n     * @throws BuildException if the date of the remote files cannot be found\nand the action is\n     * GET_FILES\n     */\n    protected boolean isUpToDate(FTPClient ftp, File localFile,\n                                 String remoteFile)\n         throws IOException, BuildException {\n        log(\"checking date for \" + remoteFile, Project.MSG_VERBOSE);\n\n        FTPFile[] files = ftp.listFiles(remoteFile);\n\n        // For Microsoft's Ftp-Service an Array with length 0 is\n        // returned if configured to return listings in \"MS-DOS\"-Format\n        if (files == null || files.length == 0) {\n            // If we are sending files, then assume out of date.\n            // If we are getting files, then throw an error\n\n            if (action == SEND_FILES) {\n                log(\"Could not date test remote file: \" + remoteFile\n                     + \"assuming out of date.\", Project.MSG_VERBOSE);\n                return false;\n            } else {\n                throw new BuildException(\"could not date test remote file: \"\n                    + ftp.getReplyString());\n            }\n        }\n\n        long remoteTimestamp = files[0].getTimestamp().getTime().getTime();\n        long localTimestamp = localFile.lastModified();\n\n        if (this.action == SEND_FILES) {\n            return remoteTimestamp + timeDiffMillis > localTimestamp;\n        } else {\n            return localTimestamp > remoteTimestamp + timeDiffMillis;\n        }\n    }\n\n\n    /**\n    * Sends a site command to the ftp server\n    * @param ftp ftp client\n    * @param theCMD command to execute\n    * @throws IOException  in unknown circumstances\n    * @throws BuildException in unknown circumstances\n    */\n    protected void doSiteCommand(FTPClient ftp, String theCMD)\n         throws IOException, BuildException {\n        boolean rc;\n        String[] myReply = null;\n\n        log(\"Doing Site Command: \" + theCMD, Project.MSG_VERBOSE);\n\n        rc = ftp.sendSiteCommand(theCMD);\n\n        if (!rc) {\n            log(\"Failed to issue Site Command: \" + theCMD, Project.MSG_WARN);\n        } else {\n\n            myReply = ftp.getReplyStrings();\n\n            for (int x = 0; x < myReply.length; x++) {\n                if (myReply[x].indexOf(\"200\") == -1) {\n                    log(myReply[x], Project.MSG_WARN);\n                }\n            }\n        }\n    }\n\n\n    /**\n     * Sends a single file to the remote host. <code>filename</code> may\n     * contain a relative path specification. When this is the case,\n<code>sendFile</code>\n     * will attempt to create any necessary parent directories before sending\n     * the file. The file will then be sent using the entire relative path\n     * spec - no attempt is made to change directories. It is anticipated that\n     * this may eventually cause problems with some FTP servers, but it\n     * simplifies the coding.\n     * @param ftp ftp client\n     * @param dir base directory of the file to be sent (local)\n     * @param filename relative path of the file to be send\n     *        locally relative to dir\n     *        remotely relative to the remotedir attribute\n     * @throws IOException  in unknown circumstances\n     * @throws BuildException in unknown circumstances\n     */\n    protected void sendFile(FTPClient ftp, String dir, String filename)\n         throws IOException, BuildException {\n        InputStream instream = null;\n\n        try {\n            // XXX - why not simply new File(dir, filename)?\n            File file = getProject().resolveFile(new File(dir, filename).getPath());\n\n            if (newerOnly && isUpToDate(ftp, file, resolveFile(filename))) {\n                return;\n            }\n\n            if (verbose) {\n                log(\"transferring \" + file.getAbsolutePath());\n            }\n\n            instream = new BufferedInputStream(new FileInputStream(file));\n\n            createParents(ftp, filename);\n\n            ftp.storeFile(resolveFile(filename), instream);\n\n            boolean success = FTPReply.isPositiveCompletion(ftp.getReplyCode());\n\n            if (!success) {\n                String s = \"could not put file: \" + ftp.getReplyString();\n\n                if (skipFailedTransfers) {\n                    log(s, Project.MSG_WARN);\n                    skipped++;\n                } else {\n                    throw new BuildException(s);\n                }\n\n            } else {\n                // see if we should issue a chmod command\n                if (chmod != null) {\n                    doSiteCommand(ftp, \"chmod \" + chmod + \" \" +\nresolveFile(filename));\n                }\n                log(\"File \" + file.getAbsolutePath() + \" copied to \" + server,\n                    Project.MSG_VERBOSE);\n                transferred++;\n            }\n        } finally {\n            if (instream != null) {\n                try {\n                    instream.close();\n                } catch (IOException ex) {\n                    // ignore it\n                }\n            }\n        }\n    }\n\n\n    /**\n     * Delete a file from the remote host.\n     * @param ftp ftp client\n     * @param filename file to delete\n     * @throws IOException  in unknown circumstances\n     * @throws BuildException if skipFailedTransfers is set to false\n     * and the deletion could not be done\n     */\n    protected void delFile(FTPClient ftp, String filename)\n         throws IOException, BuildException {\n        if (verbose) {\n            log(\"deleting \" + filename);\n        }\n\n        if (!ftp.deleteFile(resolveFile(filename))) {\n            String s = \"could not delete file: \" + ftp.getReplyString();\n\n            if (skipFailedTransfers) {\n                log(s, Project.MSG_WARN);\n                skipped++;\n            } else {\n                throw new BuildException(s);\n            }\n        } else {\n            log(\"File \" + filename + \" deleted from \" + server,\n                Project.MSG_VERBOSE);\n            transferred++;\n        }\n    }\n\n    /**\n     * Delete a directory, if empty, from the remote host.\n     * @param ftp ftp client\n     * @param dirname directory to delete\n     * @throws IOException  in unknown circumstances\n     * @throws BuildException if skipFailedTransfers is set to false\n     * and the deletion could not be done\n     */\n    protected void rmDir(FTPClient ftp, String dirname)\n         throws IOException, BuildException {\n        if (verbose) {\n            log(\"removing \" + dirname);\n        }\n\n        if (!ftp.removeDirectory(resolveFile(dirname))) {\n            String s = \"could not remove directory: \" + ftp.getReplyString();\n\n            if (skipFailedTransfers) {\n                log(s, Project.MSG_WARN);\n                skipped++;\n            } else {\n                throw new BuildException(s);\n            }\n        } else {\n            log(\"Directory \" + dirname + \" removed from \" + server,\n                Project.MSG_VERBOSE);\n            transferred++;\n        }\n    }\n\n\n    /**\n     * Retrieve a single file from the remote host. <code>filename</code> may\n     * contain a relative path specification. <p>\n     *\n     * The file will then be retreived using the entire relative path spec -\n     * no attempt is made to change directories. It is anticipated that this\n     * may eventually cause problems with some FTP servers, but it simplifies\n     * the coding.</p>\n     * @param ftp the ftp client\n     * @param dir local base directory to which the file should go back\n     * @param filename relative path of the file based upon the ftp remote directory\n     *        and/or the local base directory (dir)\n     * @throws IOException  in unknown circumstances\n     * @throws BuildException if skipFailedTransfers is false\n     * and the file cannot be retrieved.\n     */\n    protected void getFile(FTPClient ftp, String dir, String filename)\n         throws IOException, BuildException {\n        OutputStream outstream = null;\n\n        try {\n            File file = getProject().resolveFile(new File(dir, filename).getPath());\n\n            if (newerOnly && isUpToDate(ftp, file, resolveFile(filename))) {\n                return;\n            }\n\n            if (verbose) {\n                log(\"transferring \" + filename + \" to \"\n                     + file.getAbsolutePath());\n            }\n\n            File pdir = fileUtils.getParentFile(file);\n\n            if (!pdir.exists()) {\n                pdir.mkdirs();\n            }\n            outstream = new BufferedOutputStream(new FileOutputStream(file));\n            ftp.retrieveFile(resolveFile(filename), outstream);\n\n            if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {\n                String s = \"could not get file: \" + ftp.getReplyString();\n\n                if (skipFailedTransfers) {\n                    log(s, Project.MSG_WARN);\n                    skipped++;\n                } else {\n                    throw new BuildException(s);\n                }\n\n            } else {\n                log(\"File \" + file.getAbsolutePath() + \" copied from \"\n                     + server, Project.MSG_VERBOSE);\n                transferred++;\n                if (preserveLastModified) {\n                    outstream.close();\n                    outstream = null;\n                    FTPFile[] remote = ftp.listFiles(resolveFile(filename));\n                    if (remote.length > 0) {\n                        fileUtils.setFileLastModified(file,\n                                                      remote[0].getTimestamp()\n                                                      .getTime().getTime());\n                    }\n                }\n            }\n        } finally {\n            if (outstream != null) {\n                try {\n                    outstream.close();\n                } catch (IOException ex) {\n                    // ignore it\n                }\n            }\n        }\n    }\n\n\n    /**\n     * List information about a single file from the remote host.\n<code>filename</code>\n     * may contain a relative path specification. <p>\n     *\n     * The file listing will then be retrieved using the entire relative path\n     * spec - no attempt is made to change directories. It is anticipated that\n     * this may eventually cause problems with some FTP servers, but it\n     * simplifies the coding.</p>\n     * @param ftp ftp client\n     * @param bw buffered writer\n     * @param filename the directory one wants to list\n     * @throws IOException  in unknown circumstances\n     * @throws BuildException in unknown circumstances\n     */\n    protected void listFile(FTPClient ftp, BufferedWriter bw, String filename)\n         throws IOException, BuildException {\n        if (verbose) {\n            log(\"listing \" + filename);\n        }\n\n        FTPFile ftpfile = ftp.listFiles(resolveFile(filename))[0];\n\n        bw.write(ftpfile.toString());\n        bw.newLine();\n\n        transferred++;\n    }\n\n\n    /**\n     * Create the specified directory on the remote host.\n     *\n     * @param ftp The FTP client connection\n     * @param dir The directory to create (format must be correct for host\n     *      type)\n     * @throws IOException  in unknown circumstances\n     * @throws BuildException if ignoreNoncriticalErrors has not been set to true\n     *         and a directory could not be created, for instance because it was\n     *         already existing. Precisely, the codes 521, 550 and 553 will trigger\n     *         a BuildException\n     */\n    protected void makeRemoteDir(FTPClient ftp, String dir)\n         throws IOException, BuildException {\n        String workingDirectory = ftp.printWorkingDirectory();\n        if (verbose) {\n            log(\"Creating directory: \" + dir);\n        }\n        if (dir.indexOf(\"/\") == 0) {\n            ftp.changeWorkingDirectory(\"/\");\n        }\n        String subdir = new String();\n        StringTokenizer st = new StringTokenizer(dir, \"/\");\n        while (st.hasMoreTokens()) {\n            subdir = st.nextToken();\n            log(\"Checking \" + subdir, Project.MSG_DEBUG);\n            if (!ftp.changeWorkingDirectory(subdir)) {\n                if (!ftp.makeDirectory(subdir)) {\n                    // codes 521, 550 and 553 can be produced by FTP Servers\n                    //  to indicate that an attempt to create a directory has\n                    //  failed because the directory already exists.\n                    int rc = ftp.getReplyCode();\n                    if (!(ignoreNoncriticalErrors\n                        && (rc == FTPReply.CODE_550 || rc == FTPReply.CODE_553\n                        || rc == CODE_521))) {\n                        throw new BuildException(\"could not create directory: \"\n                            + ftp.getReplyString());\n                    }\n                    if (verbose) {\n                        log(\"Directory already exists\");\n                    }\n                } else {\n                    if (verbose) {\n                        log(\"Directory created OK\");\n                    }\n                    ftp.changeWorkingDirectory(subdir);\n                }\n            }\n        }\n        if (workingDirectory != null) {\n            ftp.changeWorkingDirectory(workingDirectory);\n        }\n    }\n\n    /**\n     * look at the response for a failed mkdir action, decide whether\n     * it matters or not. If it does, we throw an exception\n     * @param ftp current ftp connection\n     * @throws BuildException if this is an error to signal\n     */\n    private void handleMkDirFailure(FTPClient ftp)\n            throws BuildException {\n        int rc = ftp.getReplyCode();\n        if (!(ignoreNoncriticalErrors\n             && (rc == FTPReply.CODE_550 || rc == FTPReply.CODE_553 || rc ==\nCODE_521))) {\n            throw new BuildException(\"could not create directory: \"\n                + ftp.getReplyString());\n        }\n    }\n\n\t// JPEER\n\t// just some refacturing to avoid redundant code in the patch\n\t// (this is method is needed both during start and during re-connect)\n\tprotected FTPClient initFTPClient() throws IOException {\n\n            log(\"Opening FTP connection to \" + server, Project.MSG_VERBOSE);\n\n            FTPClient ftp = new FTPClient();\n\n            ftp.connect(server, port);\n            if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {\n                throw new BuildException(\"FTP connection failed: \"\n                     + ftp.getReplyString());\n            }\n\n            log(\"connected\", Project.MSG_VERBOSE);\n            log(\"logging in to FTP server\", Project.MSG_VERBOSE);\n\n            if (!ftp.login(userid, password)) {\n                throw new BuildException(\"Could not login to FTP server\");\n            }\n\n            log(\"login succeeded\", Project.MSG_VERBOSE);\n\n            if (binary) {\n                ftp.setFileType(org.apache.commons.net.ftp.FTP.IMAGE_FILE_TYPE);\n                if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {\n                    throw new BuildException(\"could not set transfer type: \"\n                        + ftp.getReplyString());\n                }\n            } else {\n                ftp.setFileType(org.apache.commons.net.ftp.FTP.ASCII_FILE_TYPE);\n                if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {\n                    throw new BuildException(\"could not set transfer type: \"\n                        + ftp.getReplyString());\n                }\n            }\n\n            if (passive) {\n                log(\"entering passive mode\", Project.MSG_VERBOSE);\n                ftp.enterLocalPassiveMode();\n                if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {\n                    throw new BuildException(\"could not enter into passive \"\n                         + \"mode: \" + ftp.getReplyString());\n                }\n            }\n\n            // For a unix ftp server you can set the default mask for all files\n            // created.\n\n            if (umask != null) {\n                doSiteCommand(ftp, \"umask \" + umask);\n            }\n\n            // If the action is MK_DIR, then the specified remote\n            // directory is the directory to create.\n\n\t\t\t\t\t\t\n\t\t\treturn ftp;\n\t}\n\t\t\n\t// JPEER\n\t// just some refacturing to avoid redundant code in the patch\n\t// (this is method is needed both during start and during re-connect)\t\t\n\t\tprotected void prepareForTransfer(FTPClient ftp) throws IOException {\n\t\t\tif (remotedir != null) {\n\t\t\t\t\tlog(\"changing the remote directory\", Project.MSG_VERBOSE);\n\t\t\t\t\tftp.changeWorkingDirectory(remotedir);\n\t\t\t\t\tif (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {\n\t\t\t\t\t\t\tthrow new BuildException(\"could not change remote \"\n\t\t\t\t\t\t\t\t\t + \"directory: \" + ftp.getReplyString());\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tif (newerOnly && timeDiffAuto) {\n\t\t\t// in this case we want to find how much time span there is between local\n\t\t\t// and remote\n\t\t\t\t\ttimeDiffMillis = getTimeDiff(ftp);\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\t\n    /**\n     * Runs the task.\n     *\n     * @throws BuildException if the task fails or is not configured\n     *         correctly.\n     */\n    public void execute() throws BuildException {\n        checkConfiguration();\n\n        FTPClient ftp = null; \n\n\t\t\t\ttry {\n\t\t\t\t\t  // JPEER \n\t\t\t\t\t\tftp = initFTPClient();\n\t\t\t\t\t\n            if (action == MK_DIR) {\n                makeRemoteDir(ftp, remotedir);\n            } else {\n\t\t\t\t\t\t\t  // JPEER\n\t\t\t\t\t\t\t\tprepareForTransfer(ftp);\n                log(ACTION_STRS[action] + \" \" + ACTION_TARGET_STRS[action]);\n                transferFiles(ftp);\n            }\n\n        } catch (IOException ex) {\n            throw new BuildException(\"error during FTP transfer: \" + ex);\n        } finally {\n            if (ftp != null && ftp.isConnected()) {\n                try {\n                    log(\"disconnecting\", Project.MSG_VERBOSE);\n                    ftp.logout();\n                    ftp.disconnect();\n                } catch (IOException ex) {\n                    // ignore it\n                }\n            }\n        }\n    }\n\n\n    /**\n     * an action to perform, one of\n     * \"send\", \"put\", \"recv\", \"get\", \"del\", \"delete\", \"list\", \"mkdir\", \"chmod\",\n     * \"rmdir\"\n     */\n    public static class Action extends EnumeratedAttribute {\n\n        private static final String[] VALID_ACTIONS = {\n            \"send\", \"put\", \"recv\", \"get\", \"del\", \"delete\", \"list\", \"mkdir\",\n            \"chmod\", \"rmdir\"\n            };\n\n\n        /**\n         * Get the valid values\n         *\n         * @return an array of the valid FTP actions.\n         */\n        public String[] getValues() {\n            return VALID_ACTIONS;\n        }\n\n\n        /**\n         * Get the symbolic equivalent of the action value.\n         *\n         * @return the SYMBOL representing the given action.\n         */\n        public int getAction() {\n            String actionL = getValue().toLowerCase(Locale.US);\n\n            if (actionL.equals(\"send\") || actionL.equals(\"put\")) {\n                return SEND_FILES;\n            } else if (actionL.equals(\"recv\") || actionL.equals(\"get\")) {\n                return GET_FILES;\n            } else if (actionL.equals(\"del\") || actionL.equals(\"delete\")) {\n                return DEL_FILES;\n            } else if (actionL.equals(\"list\")) {\n                return LIST_FILES;\n            } else if (actionL.equals(\"chmod\")) {\n                return CHMOD;\n            } else if (actionL.equals(\"mkdir\")) {\n                return MK_DIR;\n            } else if (actionL.equals(\"rmdir\")) {\n                return RM_DIR;\n            }\n            return SEND_FILES;\n        }\n    }\n}"}, {"count": 1, "tags": [], "creator": "j.peer@gmx.net", "attachment_id": 10933, "text": "Created attachment 10933\nproposed patch/feature, same as in message", "id": 54513, "time": "2004-03-23T22:21:28Z", "bug_id": 27883, "creation_time": "2004-03-23T22:21:28Z", "is_private": false}, {"count": 2, "tags": [], "bug_id": 27883, "attachment_id": null, "id": 118644, "time": "2008-07-14T07:45:25Z", "creator": "bodewig@apache.org", "creation_time": "2008-07-14T07:45:25Z", "is_private": false, "text": "the retriesAllowed attribute introduced in 1.7.0 should address this"}]