[{"count": 0, "tags": [], "text": "apr should set FD_CLOEXEC if APR_FOPEN_NOCLEANUP is not set. This would in general help with security and fix some existing issues with third party httpd modules like mod_php:\n\nhttps://issues.apache.org/bugzilla/show_bug.cgi?id=43965\n\nThere was some discussion about this at\n\nhttp://mail-archives.apache.org/mod_mbox/apr-dev/200808.mbox/<1217901131.25598.58.camel%40shrek.rexursive.com>\n\nBojan Smojver has created an initial patch:\n\nhttp://mail-archives.apache.org/mod_mbox/apr-dev/200808.mbox/raw/<1217995221.25598.67.camel%40shrek.rexursive.com>", "attachment_id": null, "bug_id": 46425, "id": 123451, "time": "2008-12-20T14:59:35Z", "creator": "sf@sfritsch.de", "creation_time": "2008-12-20T14:59:35Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 46425, "text": "Created attachment 23045\nPatch for trunk to set FD_CLOEXEC\n\nHere is a patch that sets FD_CLOEXEC when a fd is not inheritable. This has the\nfollowing caveats:\n\n- I don't use any of the new APIs (O_CLOEXEC, SOCK_CLOEXEC, ...) because I\n  haven't checked what happens if apr is compiled on a system with O_CLOEXEC\n  and then is used on a system without O_CLOEXEC.\n\n- For the pollsets, I have only changed epoll so far. Changing the other\n  implementations should be straightforward, though.\n\n- I have only dealt with unix (don't know if windows and os2 have something\n  like FD_CLOEXEC).\n\n- If this patch is used with apache+mod_php, a program that is called by e.g.\n  php's passthru() won't have stderr because the error log is not opened with\n  APR_FOPEN_NOCLEANUP.  Maybe apache should set this flag on its error log.\n  Or mod_php should take care to provide stderr for its children.\n\nBefore I spend more time on this, I would like to know if this approach has\nchances of being integrated.", "id": 123460, "attachment_id": 23045, "creator": "sf@sfritsch.de", "creation_time": "2008-12-21T06:04:35Z", "time": "2008-12-21T06:04:35Z", "is_private": false}, {"count": 2, "tags": [], "bug_id": 46425, "attachment_id": null, "text": "I think it would be good to do this.\n\nNote that any place a particular object is changed to rely on FD_CLOEXEC for closure after exec, the corresponding child cleanup needs to be changed (or if appropriate, removed) since it will otherwise also try to close() the fd for a second time.\n\nLots of system call invocations:\n\n+        int fdflags = fcntl(fd, F_GETFD);\n+        fdflags |= FD_CLOEXEC;\n+        fcntl(fd, F_SETFD, fdflags);\n\nwithout any error checking seems kinda bad, but maybe that's unnecessary paranoia.", "id": 123690, "time": "2009-01-02T03:42:04Z", "creator": "jorton@redhat.com", "creation_time": "2009-01-02T03:42:04Z", "is_private": false}, {"count": 3, "tags": [], "creator": "arekm@maven.pl", "text": "http://udrepper.livejournal.com/20407.html says \"When should these interfaces be used? The answer is simple: whenever the author is not sure that no asynchronous fork()+exec can happen or a concurrently running threads executes fork()+exec (or posix_spawn(), BTW).\"\n\nCan these happen when threaded MPM is being used?\n\nps. dangling descriptors is a pain for me, too and I'm looking forward to see this patch in trunk", "id": 124889, "time": "2009-02-17T03:49:48Z", "bug_id": 46425, "creation_time": "2009-02-17T03:49:48Z", "is_private": false, "attachment_id": null}, {"count": 4, "tags": [], "bug_id": 46425, "attachment_id": null, "id": 125007, "time": "2009-02-19T19:05:27Z", "creator": "bojan@rexursive.com", "creation_time": "2009-02-19T19:05:27Z", "is_private": false, "text": "We really should be using O_CLOEXEC, dup3 and friends were available. As Ulrich explains, there can be a race condition:\n\n\"There is a (possibly brief) period of time between the return of the open() call or other function creating a file descriptor and the fcntl() call to set the flag.\"\n\nUsing FD_CLOEXEC is better than nothing, but will miss the above.\n\n> I haven't checked what happens if apr is compiled on a system with O_CLOEXEC and then is used on a system without O_CLOEXEC.\n\nDo we allow this kind of thing to be done at all? After all, we try to detect what is available during configure time, so that we can reliably use that later. All kinds of things will break if APR compiled on one system is used on another that doesn't have those features available.\n\nTake gethostbyname/getservbyname() stuff - we detect that during compile. If we move such APR to another machine that is lacking what we detected, it won't work. Same with O_CLOEXEC, dup3 etc."}, {"attachment_id": 23288, "tags": [], "bug_id": 46425, "text": "Created attachment 23288\nupdated patch that uses secure way of descriptors handling (see drepper note) where possible\n\nUpdated patch. Uses http://udrepper.livejournal.com/20407.html user level when possible and fcntl where not. Also added fcntl() error handling that was missing in original patch.\n\nPasses make test on my Linux platform.\n\nWhat else is needed to get this patch merged?", "count": 5, "id": 125046, "time": "2009-02-21T15:33:45Z", "creator": "arekm@maven.pl", "creation_time": "2009-02-21T15:33:45Z", "is_private": false}, {"count": 6, "tags": [], "bug_id": 46425, "attachment_id": 23289, "id": 125047, "time": "2009-02-21T16:10:13Z", "creator": "arekm@maven.pl", "creation_time": "2009-02-21T16:10:13Z", "is_private": false, "text": "Created attachment 23289\nupdated patch that uses secure way of descriptors handling\n\nForgot to initialize flags in one place. Fixed."}, {"attachment_id": null, "tags": [], "bug_id": 46425, "text": "(In reply to comment #2)\n> Note that any place a particular object is changed to rely on FD_CLOEXEC for\n> closure after exec, the corresponding child cleanup needs to be changed (or if\n> appropriate, removed) since it will otherwise also try to close() the fd for a\n> second time.\n\nIt is not strictly necessary to change the cleanups because they run before the exec. When a file was closed by the cleanup is no longer relevant if it had FD_CLOEXEC or not. From a performance point of view, the unnecessary cleanups should be removed, of course.\n\nIf this patch is ever backported to 1.3/1.4, I would suggest not to remove the cleanups there, to retain maximum compatibility (some apps could mess with the cleanups, after all).\n\n> Lots of system call invocations:\n> \n> +        int fdflags = fcntl(fd, F_GETFD);\n> +        fdflags |= FD_CLOEXEC;\n> +        fcntl(fd, F_SETFD, fdflags);\n> \n> without any error checking seems kinda bad, but maybe that's unnecessary\n> paranoia.\n\nThe only relevant failure modes are EBADF, if the fd is invalid, and EINVAL, if FD_CLOEXEC is unknown. I think we can ignore the latter case and only do error checking on fcntl in cases where we haven't verified that fd is valid, yet.\n\nBut I would be fine with adding error checking in all cases, of course.", "count": 7, "id": 125051, "time": "2009-02-22T04:33:58Z", "creator": "sf@sfritsch.de", "creation_time": "2009-02-22T04:33:58Z", "is_private": false}, {"count": 8, "tags": [], "bug_id": 46425, "attachment_id": null, "text": "(In reply to comment #4)\n> > I haven't checked what happens if apr is compiled on a system with O_CLOEXEC and then is used on a system without O_CLOEXEC.\n> \n> Do we allow this kind of thing to be done at all? After all, we try to detect\n> what is available during configure time, so that we can reliably use that\n> later. All kinds of things will break if APR compiled on one system is used on\n> another that doesn't have those features available.\n> \n> Take gethostbyname/getservbyname() stuff - we detect that during compile. If we\n> move such APR to another machine that is lacking what we detected, it won't\n> work. Same with O_CLOEXEC, dup3 etc.\n\nAt least apr should break in an obvious way if one does this. If new syscalls are used, this is ok because the error will be noticed.\n\nBut if the flag is silently ignored on older systems as is the case with O_CLOEXEC on linux, this may cause subtle breackage or even create security issues. In this case we should either verify that O_CLOEXEC works during run time (a PITA), or just use fcntl in addition to be on the save side.\n\nIf we can be sure that O_CLOEXEC is supported, the additional fcntl call could be ommited. For example, any linux system that supports dup3 also supports O_CLOEXEC.", "id": 125052, "time": "2009-02-22T04:41:19Z", "creator": "sf@sfritsch.de", "creation_time": "2009-02-22T04:41:19Z", "is_private": false}, {"count": 9, "tags": [], "bug_id": 46425, "text": "Created attachment 23293\nupdated patch\n\nThis updated patch\n- is more complete (dev/port, kqueue, mktemp, ...)\n- removes unnecessary cleanup functions\n- includes Arkadiusz's patch (but some possibilities to use the \n  new api is probably still missing, I don't currently have a\n  linux 2.6.28 system).\n- compiles with current trunk and passes make test but is otherwise\n  untested\n- may create problems on netware because it touches files in unix/...\n  that are also used by netware (does netware have FD_CLOEXEC?)", "id": 125055, "time": "2009-02-22T05:06:15Z", "creator": "sf@sfritsch.de", "creation_time": "2009-02-22T05:06:15Z", "is_private": false, "attachment_id": 23293}, {"count": 10, "tags": [], "bug_id": 46425, "attachment_id": 23294, "text": "Created attachment 23294\nshouldn't dup() descriptor be also marked like this?", "id": 125056, "time": "2009-02-22T05:24:01Z", "creator": "arekm@maven.pl", "creation_time": "2009-02-22T05:24:01Z", "is_private": false}, {"count": 11, "tags": [], "text": "(In reply to comment #10)\n> Created an attachment (id=23294) [details]\n> shouldn't dup() descriptor be also marked like this?\n\nI don't think so:\n\n    /* apr_file_dup() retains all old_file flags with the exceptions\n     * of APR_INHERIT and APR_FILE_NOCLEANUP.\n     * The user must call apr_file_inherit_set() on the dupped\n     * apr_file_t when desired.\n\nFD_CLOEXEC should always be unset for the which_dup == 1 case.", "is_private": false, "id": 125060, "creator": "sf@sfritsch.de", "time": "2009-02-22T06:48:22Z", "bug_id": 46425, "creation_time": "2009-02-22T06:48:22Z", "attachment_id": null}, {"count": 12, "tags": [], "text": "apr_socket_create in your patch sets CLOEXEC via fcntl even if SOCK_CLOEXEC was used. Looks like missing #ifndef SOCK_CLOEXEC, right?\n\nbtw. probably these things need configure checks since for example SOCK_CLOEXEC is supported since 2.6.27 but I already have few users that run older kernels (.25) and have newer glibc that actually defines SOCK_CLOEXEC. The bad thing with this flag is that socket() fails on older kernels and is not ignored.\n\nThe most portable way would be to test these things runtime but I don't know if that would fit into \"apr way\".", "is_private": false, "id": 125061, "creation_time": "2009-02-22T07:41:55Z", "time": "2009-02-22T07:41:55Z", "creator": "arekm@maven.pl", "bug_id": 46425, "attachment_id": null}, {"attachment_id": null, "tags": [], "bug_id": 46425, "text": "Pretty sure removing the custom inherit_unset function is a mistake. It is about buffer flushing there - not closing the file. Also, replacing cleanup functions with null functions is an error - same reason.", "count": 13, "id": 125073, "time": "2009-02-22T14:54:39Z", "creator": "bojan@rexursive.com", "creation_time": "2009-02-22T14:54:39Z", "is_private": false}, {"count": 14, "tags": [], "bug_id": 46425, "attachment_id": null, "id": 125074, "time": "2009-02-22T15:01:00Z", "creator": "bojan@rexursive.com", "creation_time": "2009-02-22T15:01:00Z", "is_private": false, "text": "In addition, there is the question of unlinking the file (if required) and removing the mutex. We can't just not have that, I think."}, {"attachment_id": null, "tags": [], "bug_id": 46425, "text": "(In reply to comment #13)\n> Pretty sure removing the custom inherit_unset function is a mistake. It is\n> about buffer flushing there - not closing the file. Also, replacing cleanup\n> functions with null functions is an error - same reason.\n\nThe problem was that the normal cleanup did flush the buffers. I only removed the child cleanup, because close by FD_CLOEXEC does the right thing in this case.\n\n(In reply to comment #14)\n> In addition, there is the question of unlinking the file (if required) and\n> removing the mutex. We can't just not have that, I think.\n\nUnlinking the file is not done in the child cleanup (is_child == 0), but you are right about the mutex. I missed that and will post an updated patch. There is also a typo in port.c.\n\nFor all other child cleanups than apr_unix_file_child_cleanup, it is ok to remove them because they only close the fd anyway.", "count": 15, "id": 125099, "time": "2009-02-23T12:12:48Z", "creator": "sf@sfritsch.de", "creation_time": "2009-02-23T12:12:48Z", "is_private": false}, {"count": 16, "tags": [], "creator": "sf@sfritsch.de", "is_private": false, "id": 125100, "attachment_id": null, "bug_id": 46425, "creation_time": "2009-02-23T12:16:15Z", "time": "2009-02-23T12:16:15Z", "text": "(In reply to comment #12)\n> apr_socket_create in your patch sets CLOEXEC via fcntl even if SOCK_CLOEXEC was\n> used. Looks like missing #ifndef SOCK_CLOEXEC, right?\n>\n> btw. probably these things need configure checks since for example SOCK_CLOEXEC\n> is supported since 2.6.27 but I already have few users that run older kernels\n> (.25) and have newer glibc that actually defines SOCK_CLOEXEC. The bad thing\n> with this flag is that socket() fails on older kernels and is not ignored.\n\nI assumed that SOCK_CLOEXEC behaved like O_CLOEXEC. But if it is not ignored then there is no reason for the additional fcntl calls. A configure check would be good in this case."}, {"count": 17, "tags": [], "text": "> The problem was that the normal cleanup did flush the buffers. I only removed\nthe child cleanup, because close by FD_CLOEXEC does the right thing in this\ncase.\n\nTrue. I misread the patch there.\n\n> Unlinking the file is not done in the child cleanup (is_child == 0)\n\nNot sure about this:\n-------------------------\napr_status_t apr_unix_child_file_cleanup(void *thefile)\n{\n    return file_cleanup(thefile);\n}\n\n\nstatic apr_status_t file_cleanup(apr_file_t *file)\n{\n    apr_status_t rv = APR_SUCCESS;\n\n    if (close(file->filedes) == 0) {\n        file->filedes = -1;\n        if (file->flags & APR_DELONCLOSE) {\n            unlink(file->fname);\n        }\n...\n-------------------------\n\nTo me, that looks like it does actually unlink the file, even in the child cleanup. No?", "is_private": false, "id": 125102, "creator": "bojan@rexursive.com", "time": "2009-02-23T13:04:38Z", "bug_id": 46425, "creation_time": "2009-02-23T13:04:38Z", "attachment_id": null}, {"count": 18, "tags": [], "creator": "sf@sfritsch.de", "text": "(In reply to comment #14)\n> > Unlinking the file is not done in the child cleanup (is_child == 0)\n> \n> Not sure about this:\n> ...\n> -------------------------\n> \n> To me, that looks like it does actually unlink the file, even in the child\n> cleanup. No?\n\nThis was changed in trunk in r712674:\n-------------------------\napr_status_t apr_unix_child_file_cleanup(void *thefile)\n{\n    return file_cleanup(thefile, 1);\n}\n\nstatic apr_status_t file_cleanup(apr_file_t *file, int is_child)\n{\n    apr_status_t rv = APR_SUCCESS;\n\n    if (close(file->filedes) == 0) {\n        file->filedes = -1;\n\n        /* Only the parent process should delete the file! */\n        if (!is_child && (file->flags & APR_DELONCLOSE)) {\n            unlink(file->fname);\n        }\n...\n-------------------------\n\nMaybe that fix should be backported?\n\nAnother question: apr_unix_file_child_cleanup destroys the file's thread mutex. But the pollsets also have a thread mutex that is not destroyed by their cleanup function. Is this the correct behaviour?", "id": 125103, "time": "2009-02-23T13:17:17Z", "bug_id": 46425, "creation_time": "2009-02-23T13:17:17Z", "is_private": false, "attachment_id": null}, {"count": 19, "tags": [], "text": "> Maybe that fix should be backported?\n\nMost likely. Not sure why it was never backported, but it does make sense.\n\n> Another question: apr_unix_file_child_cleanup destroys the file's thread mutex.\nBut the pollsets also have a thread mutex that is not destroyed by their\ncleanup function. Is this the correct behaviour?\n\nNot too familiar with that code. Will have to look. Off hand, I would say yes.", "is_private": false, "id": 125104, "creator": "bojan@rexursive.com", "time": "2009-02-23T13:31:50Z", "bug_id": 46425, "creation_time": "2009-02-23T13:31:50Z", "attachment_id": null}, {"attachment_id": 23300, "tags": [], "bug_id": 46425, "text": "Created attachment 23300\nupdated pacht which does not remove apr_unix_child_file_cleanup", "count": 20, "id": 125105, "time": "2009-02-23T13:33:11Z", "creator": "sf@sfritsch.de", "creation_time": "2009-02-23T13:33:11Z", "is_private": false}, {"count": 21, "tags": [], "creator": "arekm@maven.pl", "text": "\nSmall suggestion - be safe when fcntl fails:\n\n+        int fdflags = fcntl(fd, F_GETFD);\n+        if (fdflags != -1) {\n+            fdflags |= FD_CLOEXEC;\n+            fcntl(fd, F_SETFD, fdflags);\n+        }\n\n\nps. I'm currently using fcntl only (not complete, unix only, epoll) patch on few machines with a success (decided to not use new API because it's only suported by very fresh kernels (2.6.23+ for most of things and 2.6.27+ for SOCK_CLOEXEC)).\n\nhttp://cvs.pld-linux.org/cgi-bin/cvsweb.cgi/SOURCES/apr-bug-46425.patch", "id": 125106, "time": "2009-02-23T13:50:32Z", "bug_id": 46425, "creation_time": "2009-02-23T13:50:32Z", "is_private": false, "attachment_id": null}, {"attachment_id": null, "tags": [], "bug_id": 46425, "text": "FYI, I just backported r712674 to 1.3.x.", "count": 22, "id": 125108, "time": "2009-02-23T14:30:07Z", "creator": "bojan@rexursive.com", "creation_time": "2009-02-23T14:30:07Z", "is_private": false}, {"count": 23, "tags": [], "bug_id": 46425, "is_private": false, "id": 125110, "attachment_id": null, "creator": "bojan@rexursive.com", "creation_time": "2009-02-23T15:16:58Z", "time": "2009-02-23T15:16:58Z", "text": "Regarding comment #21, I think what Stefan used in his patch is a better alternative:\n\n+    flags = fcntl((*new)->socketdes, F_GETFD);\n+    if (flags == -1)\n+        return errno;\n\nIf we do what's suggested in comment #21, setting this flag becomes optional. I don't think that's the correct behaviour.\n\nPS. I think the above should be used consistently, which is not the case in the current patch."}, {"count": 24, "tags": [], "text": "Created attachment 23304\nupdated patch with more error checking and SOCK_CLOEXEC configure test", "attachment_id": 23304, "bug_id": 46425, "id": 125135, "time": "2009-02-24T14:54:16Z", "creator": "sf@sfritsch.de", "creation_time": "2009-02-24T14:54:16Z", "is_private": false}, {"count": 25, "tags": [], "creator": "bojan@rexursive.com", "is_private": false, "text": "Regarding comment #24, I had a read of it and it looks pretty good to me.\n\nI committed to trunk. Let's see what the review process reveals. All tests still pass for apr.", "id": 125167, "time": "2009-02-25T18:48:30Z", "bug_id": 46425, "creation_time": "2009-02-25T18:48:30Z", "attachment_id": null}, {"count": 26, "tags": [], "bug_id": 46425, "text": "This was released with apr 1.3.6", "id": 131067, "time": "2009-10-11T06:59:27Z", "creator": "sf@sfritsch.de", "creation_time": "2009-10-11T06:59:27Z", "is_private": false, "attachment_id": null}]