[{"count": 0, "tags": [], "text": "Actually a more correct description might be \"Classes NOT being reloaded from correct web app.   The following scenario results in classes loaded from one web app showing up in another web app, in place of the correct classes that should have been loaded from the latter.  The example uses Spring Security to demonstrate the problem, but after examining the Spring code I don't believe it is the problem at all and the problem can be produced in other code.\n\nScenario:\n\nTwo web apps deployed into the same Tomcat container, \"war1\" and \"war2\".  The server.xml is configured to use mutual SSL on the connector so requests must have an acceptable x509 certificate to get through.\n\nInside each war is a copy of the Spring security framework (though this can be produced with other classes, this is easy to reproduce).  The exact version probably doesn't matter, but in this case it was:\n\n..tomcat/webapps/war1/WEB-INF/lib/spring-security-core-3.1.4.RELEASE.jar\n..tomcat/webapps/war1/WEB-INF/lib/spring-security-web-3.1.4.RELEASE.jar\n\nand\n\n..tomcat/webapps/war2/WEB-INF/lib/spring-security-core-3.1.4.RELEASE.jar\n..tomcat/webapps/war2/WEB-INF/lib/spring-security-web-3.1.4.RELEASE.jar\n\n(along with associated dependencies in each case).\n\nThere are no other copies of the Spring libraries anywhere.\n\nBoth web apps declare a Spring FilterChain which, naturally, starts with the \norg.springframework.security.web.context.SecurityContextPersistenceFilter class.\n\n   <bean id=\"filterChainProxy\"\n         class=\"org.springframework.security.web.FilterChainProxy\">\n      <constructor-arg>\n         <list>\n         <security:filter-chain pattern=\"/resources/**\" filters=\"none\" />\n         <security:filter-chain pattern=\"/login**\" filters=\"none\"/>\n         <!--  All authenticated requests must go through this chain -->\n         <security:filter-chain request-matcher-ref=\"httpsRequestMatcher\"\n                   filters=      \n                          \"securityContextPersistenceFilter,  \n                           securityContextHolderAwareRequestFilter,  \n                           myAuthenticationFilter\"  \n                           />  \n \n         </list>\n      </constructor-arg>\n   </bean>\n\nThe \"securityContextPersistenceFilter\" is fairly simple, if you have not looked at their source code. All it is doing is asserting that a Spring SecurityContext object exists at the start of the request, putting it into a ThreadLocal and then, at the end of the request, clearing it from the ThreadLocal and saving the object in the session.\n\nThe \"securityContextHolderAwareRequestFilter\" is another standard Spring filter that simply wraps the request in a wrapper that knows how to get some standard security pieces out of the SecurityContext, if it exists and is setup.\n\nThe \"myAuthenticationFilter\" bean is a our own Filter that simply confirms whether the DN of the user certificate is acceptable and if so, creates an appropriate \"org.springframework.security.core.Authentication\" object that the following servlet application will understand and places it into the SecurityContextHolder.  Pretty standard stuff:\n\npublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) \nthrows IOException, ServletException{\n    //...\n    Authentication myAuth = //... create authentication.\n    SecurityContext context = SecurityContextHolder.getContext();\n    context.setAuthentication(myAuth);\n    //...\n    chain.doFilter(request,response);   \n}\n\nPretty simple.\n\nWhen either of the web apps is deployed alone, this works perfect.\n\nHowever, when both are deployed into the same tomcat, it only works perfect for the first web app you access with a request.\n\nUpon sending a request to the second war, the above code will fail because the SecurityContext object is built from classes loaded from the first war1!\n\nUpon debugging this problem, and very carefully and using the Class.getProtectionDomain().getCodeSource() API to printout the exact source of each of the relevant classes involved, the following are true:\n\n When making the first request against war1 all classes properly load from war1.\n\n When making the next request against war2:\n\n    SecurityContextHolder -> properly loaded from war2\n    Authentication -> properly loaded from war2\n    ThreadLocalSecurityContextHolderStrategy --> LOADED FROM WAR1!!!\n    SecurityContextImpl -> LOADED FROM WAR1!\n\n\nThis is bizarre and seems like an explicit violation of the specified class loader violation.\n\nIf you flip the problem around and access war2 first after startup, then the problem instead shows up when you subsequently try to access war2.\n\nThe way the Spring code is structured is pretty simple.\n\nThe SecurityContextPersistenceFilter makes use of static calls on the SecurityContextHolder class to create and 'hold' the SecurityContext object.\n\nThe SecurityContextHolder has a static field called 'strategy'.  It has a static initializer that instantiates the ThreadLocalSecurityContextHolderStrategy and assigns it to the field.  You can get to it with getContextHolderStrategy() accessor.\n\nThe strategy object itself maintains a ThreadLocal that is used to hold the SecurityContext object.  It also provides the 'createEmptyContext()' method which is used during the persistence Filter phase to create the original new SecurityContextImpl object.   The SecurityContextPersistenceFilter always makes sure to clear ThreadLocal upon request termination via a 'finally' clause.  All those steps seem to execute correctly when I step through the code.\n\nThe problem seems to be that when the second web app is being invoked and the SecurityContextHolder class is loaded from war2, it's static fields are not properly isolated.   \n\nI created an alternative 'SecurityContextHolderStrategy' implementation for the SecurityContextHolder to use that printed out debug statements (including identifying the code source) in it's constructor.  I can see that it gets properly instantiated for each web app when each is loaded.  But when I check the object that is actually attached to the SecurityContextHolder.strategy field in the second war, it points to the strategy object from the first war.\n\nI consider this to a pretty serious bug, obviously.\n\nI have a workaround for this particular occurrence of the issue.   \n\nIn \"MyAuthenticationFilter\", the very first time we get a request from an unauthenticated user, the SecurityContext object is by definition empty and the way Spring implements it, the hash code for an empty SecurityContextImpl object will always be \"-1\".   \n\nSo I can detect that it is a new, empty object without having to cast it to a SecurityContext object (which would fail because that interface class is loaded from the current web app).  I also can check the class loader against the class loader used to load the SecurityContextHolder and if they are not equal that indicates the problem (since they are _supposed_ to be loaded from the same jar).\n\nOnce I detect the problem, I can then simply instantiate a new SecurityContextImpl object (using the class from the current, correct class loader) and setting that new object into the SecurityContextHolder.   \n\nThis has to be done with reflection to avoid the class cast exceptions:\n\nClass contextHolderClass = SecurityContextHolder.class;\nMethod getContext = contextHolderClass.getMethod(\"getContext\",(Class[])null);\nObject context = getContext.invoke(null,(Object[])null);\nif(context.hashCode()==-1){\n    //this indicates it is empty.\n    if(context.getClass().getClassLoader() != contextHolderCls.getClassLoader()){\n        //it was not loaded by the correct classloader (amazingly - this can happen!)\n        //create a new one\n        String clsName = context.getClass().getName();\n        Class cls = contextHolderCls.getClassLoader().loadClass(clsName);\n        context = cls.newInstance();\n        //now, set this object back into the context holder\n        Method[] methods = contextHolderCls.getMethods();\n        Method setContext = null;\n        for(Method m : methods){\n            if(\"setContext\".equals(m.getName())){\n                setContext = m;\n                break;\n            }\n        }\n        setContext.invoke(null, context);\n    }\n}\n\nThe use of the contextHolder.getClassLoader().loadClass() method and cls.newInstance() to create the new SecurityContextImpl is probably anal-retentive caution.  It should work by simply invoking \"new SecurityContextImpl()\".\n\nThis works around this particular instance of the problem and now both web apps are able to co-exist perfectly.\n\nNotes:\n\nWe replicated this problem with the following platform variations:\n\nTomcat v7.0.55 & v7.0.42\nOS: Linux (two flavors of Centos 6.5), Windows 7 and Mac OS 10.8.5\nJava:  Java 7 v1.7.0_65 & v1.7.0_40\n\nFinally - I think it is important to emphasize that while the above workaround helps fix the occurrence relative to the Spring SecurityContext API, I do not consider this a 'fix' at all for the core problem, which must be somewhere in the web app class loader implementation.  The problem can be reproduced with any java code that follows the same pattern as these Spring classes, which are not doing anything unusual.\n\nI hope this is helpful!", "attachment_id": null, "id": 177937, "creator": "m.martinez@ll.mit.edu", "time": "2014-09-17T15:40:59Z", "bug_id": 56989, "creation_time": "2014-09-17T15:40:59Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 56989, "is_private": false, "text": "Please provide a small sample web application that would reproduce the behaviour that you are observing on a clean Tomcat installation,  so that another person could reproduce and debug the issue.\n\nRemember that Bugzilla is not a support forum. If you need help, you would better ask on the users mailing list. Its audience is wider and it is more likely to find people familiar with your configuration.\n\n\nEven if both war1 and war2 create a ThreadLocal, they are different thread locals. As far as I know, when ThreadLocals are stored in a Thread, they are keyed by Class instance.\n\nAs war1 and war2 have different class instances, those are different ThreadLocals, and cannot interfere with each other, nor can they store a class loaded from different web application (it cannot be class-casted to SecurityContext interface loaded from different web application).\n\n> the above code will fail\n\nThe word \"fail\" can mean a lot of different things. What is the actual behaviour that is observed? (The actual messages, stack traces etc.)", "id": 177938, "time": "2014-09-17T17:47:54Z", "creator": "knst.kolinko@gmail.com", "creation_time": "2014-09-17T17:47:54Z", "attachment_id": null}, {"count": 2, "tags": [], "bug_id": 56989, "attachment_id": null, "text": "Hi Konstantin,\n\nThanks for your quick response on this topic.\n\nI will try to find the time to throw together a pair of sample web apps that will reproduce the problem (I cannot provide our actual project code).  That may not happen for a day or two.\n\nI am not expecting support at all and I would hope that would be clear from the details I have provided. I have a workaround for the problem already as indicated in my report.  I am posting this bug report so that the Tomcat committers are aware that they have a very serious bug in the class loader implementation.\n\nThe use of a ThreadLocal by the Spring code is not the issue.  The ThreadLocal is being properly cleared at the termination of each request during the execution of the finally clause in the SecurityContextPersistenceFilter.  This is a class loader isolation issue.\n\nThe issue is that\n\na) the SecurityContextHolder class has a static reference to a 'strategy' object.\nb) When a request goes to war1 the SecurityContext class is loaded from war1, initialized and the strategy object is created out of the classes in war1.\nc) When a request next goes to war2, the SecurityContext class for war2 is loaded from the war2 (correctly) but it's static field STILL points to the strategy object created in (b), from war1!\nd) Because the strategy object was loaded from war1, when it's \"createEmptyContext()\" method is called, it creates a SecurityContextImpl instance using the class for that from war1.\ne) Finally, this will \"fail\" when you attempt to use this object within war2 because assigning it to a reference of type SecurityContext will throw a ClassCastException.\n\nIt will throw the ClassCastException because the object implements the SecurityContext interface from war1, not war2.\n\nThe core problem is in step \"c\" :  Why is the static field for the SecurityContextHolder class in war2 pointing to the strategy object from war1?\n\nA static field should belong to a class.  The SecurityContextHolder class in each war are, as we both agree, supposed to be separate classes.  So they are supposed to have completely separate static fields.\n\nThanks again for your attention to this.", "id": 177940, "time": "2014-09-17T19:00:33Z", "creator": "m.martinez@ll.mit.edu", "creation_time": "2014-09-17T19:00:33Z", "is_private": false}, {"count": 3, "tags": [], "bug_id": 56989, "attachment_id": null, "text": "Sigh.  Some typos.  I wish Bugzilla allowed us to edit comments.\n----- should be----\n\nThe issue is that\n\na) the SecurityContextHolder class has a static reference to a 'strategy' object.\nb) When a request goes to war1 the SecurityContextHolder class is loaded from war1, initialized and the strategy object is created out of the classes in war1.\nc) When a request next goes to war2, the SecurityContextHolder class for war2 is loaded from the war2 (correctly) but it's static field STILL points to the strategy object created in (b), from war1!\nd) Because the strategy object was loaded from war1, when it's \"createEmptyContext()\" method is called, it creates a SecurityContextImpl instance using the class for that from war1.\ne) Finally, this will \"fail\" when you attempt to use this object within war2 because assigning it to a reference of type SecurityContext will throw a ClassCastException.", "id": 177941, "time": "2014-09-17T19:04:46Z", "creator": "m.martinez@ll.mit.edu", "creation_time": "2014-09-17T19:04:46Z", "is_private": false}, {"count": 4, "tags": [], "text": "You may try running with a debugger\nhttp://wiki.apache.org/tomcat/FAQ/Developing#Debugging\n\nWith a breakpoint in static method SecurityContextHolder.initialize(). It may be interesting to know what stack trace will be at that point and what class loaders will be invoked.\n\n> c) When a request next goes to war2, the SecurityContextHolder class for\n> war2 is loaded from the war2 (correctly) but it's static field STILL\n> points to the strategy object created in (b), from war1!\n\nThat would mean that the interface (the class used to declare the static field) were also loaded from \"war1\".\n\nThere is no reflection API in use here (neither when declaring field, nor when creating strategy instance - it is created with Java \"new\" operator), so it will be loaded from the same class loader that loaded the calling class. So how can it be loaded from different war? What jars are in this classloader's class path?", "attachment_id": null, "id": 177942, "creator": "knst.kolinko@gmail.com", "time": "2014-09-17T19:39:28Z", "bug_id": 56989, "creation_time": "2014-09-17T19:39:28Z", "is_private": false}, {"count": 5, "tags": [], "creator": "markt@apache.org", "attachment_id": null, "id": 178047, "time": "2014-09-23T13:56:39Z", "bug_id": 56989, "creation_time": "2014-09-23T13:56:39Z", "is_private": false, "text": "It has been almost a week without any response to Konstantin's request for information so I am dropping the severity to normal since it clearly isn't that important to the OP or else they would have responded already.\n\nLike Konstantin, I suspect that additional copies of key classes are present elsewhere in the class loader hierarchy.\n\nWithout the requested information, this issue is going to get closed as INVALID."}, {"count": 6, "tags": [], "bug_id": 56989, "text": "A week has passed since my last comment with no response.\n\nSince no further information has been provided, this issue is being closed as invalid on the basis that the most likely cause is duplicate classes present int he class loader hierarchy.\n\nIf you are able to repeat this issue on a clean install of the latest stable Tomcat 7 (or later) release then feel free to re-open this issue and provide the steps to reproduce it.", "id": 178196, "time": "2014-09-30T09:49:49Z", "creator": "markt@apache.org", "creation_time": "2014-09-30T09:49:49Z", "is_private": false, "attachment_id": null}]