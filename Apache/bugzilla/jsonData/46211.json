[{"count": 0, "tags": [], "text": "I have an application which renders a lot of PDFs using several threads. We had an issue recently, concerning font loading. While investigating this stack trace:\n\njava.lang.NullPointerException\nat org.apache.fop.fonts.FontCache.isFailedFont(FontCache.java:294)\nat org.apache.fop.fonts.autodetect.FontInfoFinder.find(FontInfoFinder.java:179)\nat org.apache.fop.render.PrintRendererConfigurator.addFontInfoListFromFileList(PrintRendererConfigurator.java:233)\nat org.apache.fop.render.PrintRendererConfigurator.buildFontListFromConfiguration(PrintRendererConfigurator.java:140)\nat org.apache.fop.render.PrintRendererConfigurator.configure(PrintRendererConfigurator.java:95)\nat org.apache.fop.render.pdf.PDFRendererConfigurator.configure(PDFRendererConfigurator.java:71)\nat org.apache.fop.render.RendererFactory.createRenderer(RendererFactory.java:187)\nat org.apache.fop.area.RenderPagesModel.<init>(RenderPagesModel.java:68)\nat org.apache.fop.area.AreaTreeHandler.setupModel(AreaTreeHandler.java:127)\nat org.apache.fop.area.AreaTreeHandler.<init>(AreaTreeHandler.java:102)\nat org.apache.fop.render.RendererFactory.createFOEventHandler(RendererFactory.java:224)\nat org.apache.fop.fo.FOTreeBuilder.<init>(FOTreeBuilder.java:100)\nat org.apache.fop.apps.Fop.createDefaultHandler(Fop.java:100)\nat org.apache.fop.apps.Fop.<init>(Fop.java:78)\nat org.apache.fop.apps.FopFactory.newFop(FopFactory.java:247)\n\n\nI have found a possible synchronization fault in FontCache method:\n\n== Java code ==\n    public boolean isFailedFont(String embedUrl, long lastModified) {\n        if (failedFontMap.containsKey(embedUrl)) {\n            synchronized (changeLock) {\n                long failedLastModified = ((Long)failedFontMap.get(embedUrl)).longValue();\n                if (lastModified != failedLastModified) {\n                    // this font has been changed so lets remove it\n                    // from failed font map for now\n                    failedFontMap.remove(embedUrl);\n                    changed = true;\n                }                \n            }\n            return true;\n        }\n        return false;\n    }\n== end Java code ==\n\nto my opinion, it shall be like this:\n\n== Java code ==\n    public boolean isFailedFont(String embedUrl, long lastModified) {\n        synchronized (changeLock) {\n            if (failedFontMap.containsKey(embedUrl)) {\n\n                long failedLastModified = ((Long)failedFontMap.get(embedUrl)).longValue();\n                if (lastModified != failedLastModified) {\n                    // this font has been changed so lets remove it\n                    // from failed font map for now\n                    failedFontMap.remove(embedUrl);\n                    changed = true;\n                }\n                return true;\n            }\n            return false;\n        }\n    }\n== end Java code ==", "attachment_id": null, "id": 122466, "creator": "rogov@devexperts.com", "time": "2008-11-14T05:12:04Z", "bug_id": 46211, "creation_time": "2008-11-14T05:12:04Z", "is_private": false}, {"count": 1, "tags": [], "text": "\nI think the gist is correct. Have you tried changing it? Does it resolve the issue if you do?\nReason I'm asking is that there seems to be another problem: changeLock is not a 'final' variable, nor is it declared 'volatile'. \nAs a consequence:\na) since it is neither final nor volatile, it is not guaranteed to be properly initialized (some threads may see 'null' instead of the Object instance)\nb) since it is not final, it is theoretically possible to re-assign the changeLock member to a different instance, which would lead to unpredictable behavior. It is possible for two threads to enter the synchronized block, since they have each locked a separate instance.", "attachment_id": null, "id": 122497, "creator": "adelmelle@apache.org", "time": "2008-11-14T10:12:09Z", "bug_id": 46211, "creation_time": "2008-11-14T10:12:09Z", "is_private": false}, {"count": 2, "tags": [], "text": "no, i didn't tried it - but it seems quite obvious.\nand anyway - i will not be able to reproduce that easily for two reasons:\n\n1. it happens only when two threads have failed to load the font properly, which is seldom enough by itself. and this got to happen to those threads in this special order - one thread faile, tried to call isFailedFont, but got outrun by another thread which grabs the changeLock ...\n\n2. the font loading issue, which cause\u0432 this bug in my case was quickly fixed. and i really don't want to break that again :-)\n\nso, i suggest changing the \"if\" and \"synchronized\" order as in my previous comment AND making changeLock final and initializing it along with that.", "is_private": false, "id": 122498, "creator": "rogov@devexperts.com", "time": "2008-11-14T10:30:21Z", "bug_id": 46211, "creation_time": "2008-11-14T10:30:21Z", "attachment_id": null}, {"count": 3, "tags": [], "bug_id": 46211, "attachment_id": null, "is_private": false, "id": 122499, "time": "2008-11-14T10:39:15Z", "creator": "adelmelle@apache.org", "creation_time": "2008-11-14T10:39:15Z", "text": "(In reply to comment #2)\n\n> no, i didn't tried it - but it seems quite obvious.\n\nOK, thanks for the feedback.\n\n> 1. it happens only when two threads have failed to load the font properly,\n> which is seldom enough by itself. and this got to happen to those threads in\n> this special order - one thread faile, tried to call isFailedFont, but got\n> outrun by another thread which grabs the changeLock ...\n\nYep. A classic example of what is known as a 'race condition'. Unless the check is moved into the synchronized block as you suggest, this is bound to lead to trouble in some exceptional cases.\n\n> so, i suggest changing the \"if\" and \"synchronized\" order as in my previous\n> comment AND making changeLock final and initializing it along with that.\n> \n\nOK, will do. Just waiting for some feedback on fop-dev@ to see if I've overlooked anything. If not, then the changes will be committed in a few days.\n\nThanks for tracking this and reporting the bug!"}, {"count": 4, "tags": [], "creator": "adelmelle@apache.org", "attachment_id": 22875, "text": "Created attachment 22875\nPatch proposal\n\n\nAdded the proposed changes (including some other minor details, like simplification of conditionals)\n\nThe one thing I'm not sure about: we cannot combine 'final' and 'transient' as modifiers, since this would mean that the variable would always be null, apart from the very first time the cache is instantiated. When the cache is serialized once, changeLock is not written to the stream (transient), but is also never initialized again upon deserialization... (weird that this combination is actually allowed in Java)\n\nIn the patch, I've restricted it to 'final', since I don't really see why we would not serialize the lock together with the cache. Alternative would be to perform the assignment in yet another synchronized block (synchronized on the FontCache itself?)", "id": 122502, "time": "2008-11-14T12:06:44Z", "bug_id": 46211, "creation_time": "2008-11-14T12:06:44Z", "is_private": false}, {"count": 5, "tags": [], "creator": "adelmelle@apache.org", "attachment_id": null, "text": "\nNo further feedback received on fop-dev@, so changes committed to FOP Trunk in r718309.\n\nThanks for reporting!", "id": 122580, "time": "2008-11-17T10:19:44Z", "bug_id": 46211, "creation_time": "2008-11-17T10:19:44Z", "is_private": false}, {"count": 6, "tags": [], "bug_id": 46211, "text": "batch transition pre-FOP1.0 resolved+fixed bugs to closed+fixed", "id": 155822, "time": "2012-04-01T06:43:13Z", "creator": "gadams@apache.org", "creation_time": "2012-04-01T06:43:13Z", "is_private": false, "attachment_id": null}]