[{"count": 0, "tags": [], "bug_id": 46193, "attachment_id": null, "text": "Hi to all,\n\nUnder heavly load (about 500k/requests by day), I see this error about\n30 times last week on a Tomcat 6.0.16 (with libtcnative 1.1.14 on a\nSuse SLES 10 and IBM JDK 1.6-jvmxi3260-20080415_18762).\n\nWe have many HTTP sessions on our application and so frequent session cleanup done by Tomcat.\n\nWe see theses errors :\n\nWARNING: Exception processing manager\norg.apache.catalina.session.StandardManager@66196619 background\nprocess\nThrowable occurred: java.lang.ArrayIndexOutOfBoundsException\n       at java.util.AbstractCollection.toArray(Unknown Source)\n       at org.apache.catalina.session.ManagerBase.findSessions(ManagerBase.java:873)\n       at org.apache.catalina.session.ManagerBase.processExpires(ManagerBase.java:676)\n       at org.apache.catalina.session.ManagerBase.backgroundProcess(ManagerBase.java:667)\n       at org.apache.catalina.core.ContainerBase.backgroundProcess(ContainerBase.java:1316)\n       at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.processChildren(ContainerBase.java:1601)\n       at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.processChildren(ContainerBase.java:1610)\n       at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.processChildren(ContainerBase.java:1610)\n       at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.run(ContainerBase.java:1590)\n       at java.lang.Thread.run(Thread.java:735)\n7 nov. 2008 16:18:21 org.apache.catalina.core.ContainerBase backgroundProcess\n\n---\n\nWARNING: Exception processing manager\norg.apache.catalina.session.StandardManager@66196619 background\nprocess\nThrowable occurred: java.lang.IllegalMonitorStateException\n       at java.util.concurrent.locks.ReentrantLock$Sync.tryRelease(ReentrantLock.java:140)\n       at java.util.concurrent.locks.AbstractQueuedSynchronizer.release(AbstractQueuedSynchronizer.java:1188)\n       at java.util.concurrent.locks.ReentrantLock.unlock(ReentrantLock.java:444)\n       at java.util.concurrent.ConcurrentHashMap$Segment.remove(ConcurrentHashMap.java:555)\n       at java.util.concurrent.ConcurrentHashMap.remove(ConcurrentHashMap.java:936)\n       at org.apache.catalina.session.ManagerBase.remove(ManagerBase.java:885)\n       at org.apache.catalina.session.StandardSession.expire(StandardSession.java:743)\n       at org.apache.catalina.session.StandardSession.isValid(StandardSession.java:592)\n       at org.apache.catalina.session.ManagerBase.processExpires(ManagerBase.java:682)\n       at org.apache.catalina.session.ManagerBase.backgroundProcess(ManagerBase.java:667)\n       at org.apache.catalina.core.ContainerBase.backgroundProcess(ContainerBase.java:1316)\n       at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.processChildren(ContainerBase.java:1601)\n       at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.processChildren(ContainerBase.java:1610)\n       at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.processChildren(ContainerBase.java:1610)\n       at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.run(ContainerBase.java:1590)\n       at java.lang.Thread.run(Thread.java:735)\n\n\nWe take a look at ManagerBase and the sessions is using ConcurrentHashMap.\n\nWe wonder if they couldn't be some Concurrency problems when some threads are updating the sessions Map while ManagerBase try to dump the sessions into sessions array in findSessions.\n\nFrom ConcurrentHashMap comments :\n\n * Enumerations return elements reflecting the state of the hash table\n * at some point at or since the creation of the iterator/enumeration.\n * They do <em>not</em> throw\n * {@link ConcurrentModificationException}.  However, iterators are\n * designed to be used by only one thread at a time.\n\n\nRegards", "id": 122404, "time": "2008-11-12T03:56:35Z", "creator": "hgomez@apache.org", "creation_time": "2008-11-12T03:56:35Z", "is_private": false}, {"count": 1, "tags": [], "creator": "knst.kolinko@gmail.com", "attachment_id": null, "text": "It is JDK issue, not Tomcat one.\n\nAs said in the class summary ([1]) (and the JavaDoc serves as the official spec for the class), this class is designed to be a replacement for java.util.Hashtable. If the implementation does not behave, it is not Tomcat to blame.\n\n[1] http://java.sun.com/javase/6/docs/api/java/util/concurrent/ConcurrentHashMap.html\n\nThe first stacktrace of yours is a ConcurentHashMap.values().toArray(T[]) call, the second one is ConcurentHashMap.remove(Object). The both ones are valid API calls.\n\nThe second one is failing due to unpaired lock() / unlock() calls inside a segment of ConcurentHashMap. All those call pairs are internal to ConcurentHashMap implementation and do not span more that one API method call.\n\nThe first one is specifically addressed in Sun JDK implementation of AbstractCollection.toArray(), see bug 5067025 [2] for the date when it was spotted and fixed.\n\n[2] http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5067025\n\nI wonder, why you are still seeing such issues, as ConcurentHashMap class is available since JDK 5.0 and should have been well tested in practice since then. It might be there is something more subtle, specific to your CPU / libraries, or else it is a regression, and there are good chances that it is already fixed.\n\nYou may try to solve the issue with your JDK vendor.\n\n> * However, iterators are\n> * designed to be used by only one thread at a time.\n\nIt does not apply to your stack traces. There is a toArray() API call. Well, most if not all iterators are to be used by only one thread at a time.", "id": 123565, "time": "2008-12-28T08:45:09Z", "bug_id": 46193, "creation_time": "2008-12-28T08:45:09Z", "is_private": false}]