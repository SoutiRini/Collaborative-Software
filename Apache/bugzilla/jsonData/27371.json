[{"count": 0, "tags": [], "bug_id": 27371, "attachment_id": null, "id": 53333, "time": "2004-03-02T15:02:54Z", "creator": "mguillemot@yahoo.fr", "creation_time": "2004-03-02T15:02:54Z", "is_private": false, "text": "In Tomcat 5, I get a java.lang.ThreadDeath exception when I reload my\napplication.  The origin lies in the log4j library:\n\njava.lang.ThreadDeath\n        at\norg.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1270)\n        at\norg.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1230)\n        at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:315)\n        at org.apache.log4j.HTMLLayout.format(HTMLLayout.java:129)\n        at org.apache.log4j.net.SMTPAppender.sendBuffer(Unknown Source)\n        at org.apache.log4j.net.SMTPAppender.append(Unknown Source)\n        at org.apache.log4j.AppenderSkeleton.doAppend(AppenderSkeleton.java:221)\n        at\norg.apache.log4j.helpers.AppenderAttachableImpl.appendLoopOnAppenders(AppenderAttachableImpl.java:57)\n        at org.apache.log4j.Category.callAppenders(Category.java:187)\n        at org.apache.log4j.Category.forcedLog(Category.java:372)\n        at org.apache.log4j.Category.log(Category.java:864)\n        at org.apache.commons.logging.impl.Log4JLogger.error(Log4JLogger.java:192)\n        at\norg.apache.catalina.session.StandardManager.start(StandardManager.java:706)\n        at org.apache.catalina.core.StandardContext.start(StandardContext.java:4226)\n        at\norg.apache.catalina.core.StandardContext.reload(StandardContext.java:2990)\n        at\norg.apache.catalina.manager.ManagerServlet.reload(ManagerServlet.java:1019)\n        at org.apache.catalina.manager.ManagerServlet.doGet(ManagerServlet.java:377)\n        at javax.servlet.http.HttpServlet.service(HttpServlet.java:743)\n        at javax.servlet.http.HttpServlet.service(HttpServlet.java:856)\n        at\norg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:284)\n        at\norg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:204)\n        at\norg.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:257)\n        at\norg.apache.catalina.core.StandardValveContext.invokeNext(StandardValveContext.java:151)\n        at\norg.apache.catalina.core.StandardPipeline.invoke(StandardPipeline.java:567)\n        at\norg.apache.catalina.core.StandardContextValve.invokeInternal(StandardContextValve.java:245)\n        at\norg.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:199)\n        at\norg.apache.catalina.core.StandardValveContext.invokeNext(StandardValveContext.java:151)\n        at\norg.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:587)\n        at\norg.apache.catalina.core.StandardValveContext.invokeNext(StandardValveContext.java:149)\n        at\norg.apache.catalina.core.StandardPipeline.invoke(StandardPipeline.java:567)\n        at\norg.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:184)\n        at\norg.apache.catalina.core.StandardValveContext.invokeNext(StandardValveContext.java:151)\n        at\norg.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:164)\n        at\norg.apache.catalina.core.StandardValveContext.invokeNext(StandardValveContext.java:149)\n        at\norg.apache.catalina.core.StandardPipeline.invoke(StandardPipeline.java:567)\n        at\norg.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:156)\n        at\norg.apache.catalina.core.StandardValveContext.invokeNext(StandardValveContext.java:151)\n        at\norg.apache.catalina.core.StandardPipeline.invoke(StandardPipeline.java:567)\n        at org.apache.catalina.core.ContainerBase.invoke(ContainerBase.java:972)\n        at org.apache.coyote.tomcat5.CoyoteAdapter.service(CoyoteAdapter.java:206)\n        at\norg.apache.coyote.http11.Http11Processor.process(Http11Processor.java:833)\n        at\norg.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.processConnection(Http11Protocol.java:732)\n        at\norg.apache.tomcat.util.net.TcpWorkerThread.runIt(PoolTcpEndpoint.java:619)\n        at\norg.apache.tomcat.util.threads.ThreadPool$ControlRunnable.run(ThreadPool.java:688)\n        at java.lang.Thread.run(Thread.java:536)\n\nAccording to Tomcat developers, it is \"This is the old issue of log4j trying to\nuse the previous classloader\" (cf bug #26372)."}, {"count": 1, "tags": [], "text": "This is generally caused by using configureAndWatch() when configuring Log4j\nwhich starts up a thread which won't stop unless specifically shut down by\nLogManager.shutdown().  This should be done in the contextDestroyed() method of\na servlet context listener.  I have never seen this issue since I began calling\nshutdown().  BTW, if you are using configureAndWatch() in a web environment,\ndon't.  It isn't a good idea.  Better to have a configuration servlet or other\nmechanism to dynamically modify Log4j workings at runtime than to have Log4j\nspawn a thread.  It will only cause you grief.  I'm marking this as worksforme.\n Please reopen if the suggested solution does not work for you.\n\nJake", "attachment_id": null, "bug_id": 27371, "id": 53354, "time": "2004-03-03T05:17:19Z", "creator": "hoju@visi.com", "creation_time": "2004-03-03T05:17:19Z", "is_private": false}, {"count": 2, "attachment_id": null, "bug_id": 27371, "text": "I don't use (explicitely) configureAndWatch().\nIn my webapp I just place a log4j.xml in the /WEB-INF/classes directory and I\nlet log4j configures itself automagically. According to the javadoc\ndocumentation (for the log4j.properties, no mention of log4j.xml) the automatic\nconfiguration uses configure() and not configureAndWatch().\nI'll show if LogManager.shutdown() at context destruction helps.", "id": 53370, "time": "2004-03-03T09:30:38Z", "creator": "mguillemot@yahoo.fr", "creation_time": "2004-03-03T09:30:38Z", "tags": [], "is_private": false}, {"count": 3, "tags": [], "bug_id": 27371, "attachment_id": null, "id": 54260, "time": "2004-03-19T12:04:59Z", "creator": "yannc76@yahoo.de", "creation_time": "2004-03-19T12:04:59Z", "is_private": false, "text": "Jacob,\n\nthanks for your suggestion - this fixes the problem for about 80% of the time, \nbut I'm still getting sporadious ThreadDeaths when reloading via the Ant-Tasks.\n\nI'm configuring log4j via a .properties-file.\n\nAny other suggestions?"}, {"count": 4, "tags": [], "bug_id": 27371, "text": "It doesn't solve the problem for me either.\nFurthermore I think that a shutdown() of log4j can't bring the expected\nbehavior. Indeed Tomcat classes use lo4j too (through commons-logging) and would\nneed to log after a contextDestroyed() method of a context listener has been called.", "id": 54261, "attachment_id": null, "creator": "mguillemot@yahoo.fr", "creation_time": "2004-03-19T12:10:30Z", "time": "2004-03-19T12:10:30Z", "is_private": false}, {"count": 5, "tags": [], "bug_id": 27371, "attachment_id": null, "id": 54269, "time": "2004-03-19T15:41:14Z", "creator": "hoju@visi.com", "creation_time": "2004-03-19T15:41:14Z", "is_private": false, "text": "Yaan, are you saying that the ThreadDeath message still contains references to\nLog4j in the stack trace after using LogManager.shutdown()?  Or does it now look\nlike it is coming from something else?  Do you (or any other libraries in your\napp) start threads in your app that you don't clean up at application shutdown?\n\n\nMarc, same question to you.  Furthermore, LogManager.shutdown() shuts down the\nLoggerRepository connected to the current running application.  This is decided\nbased on the type of repository selector being used.  You are correct that, by\ndefault, the default logger repository is used and if LogManager.shutdown() is\nused without havin used a custom logger repository selector, it will shut down\nlogging for all applications using that logger repository.  However, there are\ntwo ways to avoid this affecting other apps....\n\n1.  Put log4j.jar in WEB-INF/lib which automatically scopes the default logger\nrepository to the current webapp, not to the rest of the server.  This is thanks\nto Tomcat's implementation of servlet spec recommended classloading behavior\nwhere the WebappClassLoader is checked first for libraries to load rather than\nusing normal Java2 classloading behavior where the parent classloader would be\nchecked first.  Do this for all of your apps and you will have complete logging\nseparation without taking any further steps.\n\n2.  Use a custom repository selector.  This will provide for a separate logger\nrepository based on, for instance, each app's JNDI context or Classloader.  Read\nmore about this here....\nhttp://nagoya.apache.org/wiki/apachewiki.cgi?Log4JProjectPages/AppContainerLogging\n\nUsing this, you can have a single instance of Log4j at the server level which is\nalso avialable to all applications and all logging will be separated for all. \nAs such, LogManager.shutdown() calls will only affect the application it was\ncalled from.\n\n\nJake"}, {"count": 6, "attachment_id": null, "creator": "mguillemot@yahoo.fr", "is_private": false, "id": 54487, "time": "2004-03-23T16:05:10Z", "bug_id": 27371, "creation_time": "2004-03-23T16:05:10Z", "tags": [], "text": "Jake,\n\nthe ThreadDeath always comes from log4j. As far as I know, I don't have threads\nthat are not cleaned up.\n\nTo 1: I use a log4j.jar per application. My logj.jar are already in WEB-INF/lib\n\nTo 2: I have to take time to look at it. It seems interesting."}, {"count": 7, "tags": [], "bug_id": 27371, "attachment_id": null, "id": 54551, "time": "2004-03-24T09:56:02Z", "creator": "yannc76@yahoo.de", "creation_time": "2004-03-24T09:56:02Z", "is_private": false, "text": "Jacob,\n\nthanks for getting back. I tried hard (about 20 times) and provoked another \nstacktrace for you ;-)\n\n*****\njava.lang.ThreadDeath\n\tat org.apache.catalina.loader.WebappClassLoader.loadClass\n(WebappClassLoader.java:1227)\n\tat org.apache.catalina.loader.WebappClassLoader.loadClass\n(WebappClassLoader.java:1187)\n\tat java.lang.ClassLoader.loadClassInternal(ClassLoader.java:302)\n\tat org.apache.log4j.spi.LoggingEvent.<init>(LoggingEvent.java:145)\n\tat org.apache.log4j.Category.forcedLog(Category.java:372)\n\tat org.apache.log4j.Category.log(Category.java:864)\n\tat org.apache.commons.logging.impl.Log4JLogger.error\n(Log4JLogger.java:192)\n\tat org.apache.catalina.session.StandardManager.start\n(StandardManager.java:659)\n\tat org.apache.catalina.core.StandardContext.start\n(StandardContext.java:4199)\n\tat org.apache.catalina.core.StandardContext.reload\n(StandardContext.java:2963)\n\tat org.apache.catalina.manager.ManagerServlet.reload\n(ManagerServlet.java:972)\n\tat org.apache.catalina.manager.ManagerServlet.doGet\n(ManagerServlet.java:330)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:697)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:810)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter\n(ApplicationFilterChain.java:237)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter\n(ApplicationFilterChain.java:157)\n\tat org.apache.catalina.core.StandardWrapperValve.invoke\n(StandardWrapperValve.java:214)\n\tat org.apache.catalina.core.StandardValveContext.invokeNext\n(StandardValveContext.java:104)\n\tat org.apache.catalina.core.StandardPipeline.invoke\n(StandardPipeline.java:520)\n\tat org.apache.catalina.core.StandardContextValve.invokeInternal\n(StandardContextValve.java:198)\n\tat org.apache.catalina.core.StandardContextValve.invoke\n(StandardContextValve.java:152)\n\tat org.apache.catalina.core.StandardValveContext.invokeNext\n(StandardValveContext.java:104)\n\tat org.apache.catalina.authenticator.AuthenticatorBase.invoke\n(AuthenticatorBase.java:540)\n\tat org.apache.catalina.core.StandardValveContext.invokeNext\n(StandardValveContext.java:102)\n\tat org.apache.catalina.core.StandardPipeline.invoke\n(StandardPipeline.java:520)\n\tat org.apache.catalina.core.StandardHostValve.invoke\n(StandardHostValve.java:137)\n\tat org.apache.catalina.core.StandardValveContext.invokeNext\n(StandardValveContext.java:104)\n\tat org.apache.catalina.valves.ErrorReportValve.invoke\n(ErrorReportValve.java:117)\n\tat org.apache.catalina.core.StandardValveContext.invokeNext\n(StandardValveContext.java:102)\n\tat org.apache.catalina.core.StandardPipeline.invoke\n(StandardPipeline.java:520)\n\tat org.apache.catalina.core.StandardEngineValve.invoke\n(StandardEngineValve.java:109)\n\tat org.apache.catalina.core.StandardValveContext.invokeNext\n(StandardValveContext.java:104)\n\tat org.apache.catalina.core.StandardPipeline.invoke\n(StandardPipeline.java:520)\n\tat org.apache.catalina.core.ContainerBase.invoke(ContainerBase.java:929)\n\tat org.apache.coyote.tomcat5.CoyoteAdapter.service\n(CoyoteAdapter.java:160)\n\tat org.apache.coyote.http11.Http11Processor.process\n(Http11Processor.java:793)\n\tat \norg.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.processConnectio\nn(Http11Protocol.java:702)\n\tat org.apache.tomcat.util.net.TcpWorkerThread.runIt\n(PoolTcpEndpoint.java:571)\n\tat org.apache.tomcat.util.threads.ThreadPool$ControlRunnable.run\n(ThreadPool.java:644)\n\tat java.lang.Thread.run(Thread.java:534)\n\n*** \n\nI don't start any threads myself nor do the libraries I use (well, I suppose - \nusing Struts and the usual commons-* stuff), my log4j-1.2.8-jar is in my WEB-\nINF/lib, I'm not using *any* shared libraries, all of them are in the \nwebapp's /lib (went through this pain often enough..).\n\nThis is a real problem when reloading applications in TC used on production \nservers since it will kill the application - only solution is to restart TC.."}, {"count": 8, "tags": [], "bug_id": 27371, "attachment_id": null, "text": "I think there is a solution for the above problem (stack trace).\nNormally you call the logger within each class like this:\n\nLogger myLogger = Logger.getLogger(MyClass.class)\n\nNow lets suppose yout classes name is not MyClass but instead MyOwnClass and \nyou call your logger\nas shown above. Then the argument does not match the correct class name\nand you will get the described stack trace.\n\nSo check each call of your logger for the appropriate class names. That should \nfix the problem.\n\n\nThorsten", "id": 57965, "time": "2004-05-24T14:07:22Z", "creator": "tvo@informatik.uni-kiel.de", "creation_time": "2004-05-24T14:07:22Z", "is_private": false}, {"count": 9, "tags": [], "bug_id": 27371, "attachment_id": null, "id": 60958, "time": "2004-07-22T12:10:03Z", "creator": "ia_rud@mail.ru", "creation_time": "2004-07-22T12:10:03Z", "is_private": false, "text": "I have the same problem with tomcat 5.0.24. It happens when jsp page has \nerrors - I reload context and tomcat gives ThreadDeath exception when I try to \ncall this jsp using browser. Tomcat works correctly for some time and then this \nexception occur after next reload."}, {"count": 10, "tags": [], "bug_id": 27371, "text": "But log4J doesnt cause a ThreadDeath when in Tomcat 4.*... so is it something \nwith tomcat 5???\n\nalso, in my stacktrace it is not even in log4J...  and my app used to work in \nTomcat4.1.28... now I am in the latest 5.* and I get this error...\n\nThanks, \nChris\n\njava.lang.ThreadDeath\n\tat org.apache.catalina.loader.WebappClassLoader.loadClass\n(WebappClassLoader.java:1229)\n\tat org.apache.catalina.loader.WebappClassLoader.loadClass\n(WebappClassLoader.java:1189)\n\tat java.beans.Introspector.instantiate(Introspector.java:1322)\n\tat java.beans.Introspector.findExplicitBeanInfo(Introspector.java:393)\n\tat java.beans.Introspector.<init>(Introspector.java:342)\n\tat java.beans.Introspector.getBeanInfo(Introspector.java:144)\n\tat org.apache.commons.beanutils.PropertyUtils.getPropertyDescriptors\n(PropertyUtils.java:949)\n\tat org.apache.commons.beanutils.PropertyUtils.getPropertyDescriptors\n(PropertyUtils.java:979)\n\tat org.apache.commons.beanutils.PropertyUtils.getPropertyDescriptor\n(PropertyUtils.java:887)\n\tat org.apache.commons.beanutils.PropertyUtils.getSimpleProperty\n(PropertyUtils.java:1172)\n\tat org.apache.commons.beanutils.PropertyUtils.getNestedProperty\n(PropertyUtils.java:772)\n\tat org.apache.commons.beanutils.PropertyUtils.getProperty\n(PropertyUtils.java:801)\n\tat org.apache.catalina.core.StandardWrapperValve.invoke\n(StandardWrapperValve.java:255)\n\tat org.apache.catalina.core.StandardValveContext.invokeNext\n(StandardValveContext.java:104)\n\tat org.apache.catalina.core.StandardPipeline.invoke\n(StandardPipeline.java:520)\n\tat org.apache.catalina.core.StandardContextValve.invokeInternal\n(StandardContextValve.java:198)\n\tat org.apache.catalina.core.StandardContextValve.invoke\n(StandardContextValve.java:152)\n\tat org.apache.catalina.core.StandardValveContext.invokeNext\n(StandardValveContext.java:104)\n\tat org.apache.catalina.core.StandardPipeline.invoke\n(StandardPipeline.java:520)\n\tat org.apache.catalina.core.StandardHostValve.invoke\n(StandardHostValve.java:137)\n\tat org.apache.catalina.core.StandardValveContext.invokeNext\n(StandardValveContext.java:104)\n\tat org.apache.catalina.valves.ErrorReportValve.invoke\n(ErrorReportValve.java:117)\n\tat org.apache.catalina.core.StandardValveContext.invokeNext\n(StandardValveContext.java:102)\n\tat org.apache.catalina.core.StandardPipeline.invoke\n(StandardPipeline.java:520)\n\tat org.apache.catalina.core.StandardEngineValve.invoke\n(StandardEngineValve.java:109)\n\tat org.apache.catalina.core.StandardValveContext.invokeNext\n(StandardValveContext.java:104)\n\tat org.apache.catalina.core.StandardPipeline.invoke\n(StandardPipeline.java:520)\n\tat org.apache.catalina.core.ContainerBase.invoke\n(ContainerBase.java:929)\n\tat org.apache.coyote.tomcat5.CoyoteAdapter.service\n(CoyoteAdapter.java:160)\n\tat org.apache.coyote.http11.Http11Processor.process\n(Http11Processor.java:793)\n\tat \norg.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.processConnecti\non(Http11Protocol.java:702)\n\tat org.apache.tomcat.util.net.TcpWorkerThread.runIt\n(PoolTcpEndpoint.java:571)\n\tat org.apache.tomcat.util.threads.ThreadPool$ControlRunnable.run\n(ThreadPool.java:644)\n\tat java.lang.Thread.run(Thread.java:534)\n", "id": 60997, "time": "2004-07-22T21:22:12Z", "creator": "mchyzer@yahoo.com", "creation_time": "2004-07-22T21:22:12Z", "is_private": false, "attachment_id": null}, {"count": 11, "tags": [], "bug_id": 27371, "attachment_id": null, "id": 61022, "time": "2004-07-23T03:34:44Z", "creator": "hoju@visi.com", "creation_time": "2004-07-23T03:34:44Z", "is_private": false, "text": "Chris,\n\nCan you describe what you were doing to get that stack trace?  Were you\nrestarting the webapp?  I don't see that in the stack trace, but you never know.\n It would be great to prove that this is more an issue with Tomcat5 than with\nLog4j.  Your stack trace helps make the case since it doesn't seem to be related\nto Log4j, although it could be that the same issue is happening, just in a\ndifferent library.\n\nJake"}, {"count": 12, "tags": [], "bug_id": 27371, "attachment_id": null, "id": 61060, "time": "2004-07-23T14:47:00Z", "creator": "mchyzer@yahoo.com", "creation_time": "2004-07-23T14:47:00Z", "is_private": false, "text": "Thanks for following up.  Upon further investigation, I only get this error \nwhen running Tomcat in debug mode with the sysdeo plugin for eclipse (Tomcat \n5, Eclipse 3.0).  I think it is a classloader problem in Sysdeo (saw a post \nonline of someone who had the same idea).  When running Tomcat in standalone \nmode with the same app I do not get a ThreadDeath, so Im fine with closing \nthis bug... Sorry for the inconvenience... Chris"}, {"count": 13, "tags": [], "bug_id": 27371, "text": "This error occurs in Tomcat 5.0.24 with context that has Axis library. Besides \nAxis library there are ordinary jsp pages. Error occurs when tomcat was \nreloaded, and jsp page with syntax error is being compiled", "id": 61061, "time": "2004-07-23T15:22:43Z", "creator": "ia_rud@mail.ru", "creation_time": "2004-07-23T15:22:43Z", "is_private": false, "attachment_id": null}, {"count": 14, "tags": [], "bug_id": 27371, "attachment_id": null, "id": 61065, "time": "2004-07-23T16:29:58Z", "creator": "mchyzer@yahoo.com", "creation_time": "2004-07-23T16:29:58Z", "is_private": false, "text": "Actually, my problem was not with Sysdeo.  I replaced Sysdeo with MyEclipse \ndebugging plugin, and got the same error.  I reverted back to Tomcat 4.1.28, \nand I do not get the error.  I started Tomcat, hit the controller of my app \nand got the Stacktrace in the other post by me...  I hope this is fixed soon \nas we need features in the newer Servlet spec...  Thanks!  ps. If you have \ntrouble reproducing this, I can zip up my open source dev env and post it for \nsomeone, and you can debug my app and see the error.  :)"}, {"count": 15, "attachment_id": null, "bug_id": 27371, "text": "Chris, can you just attach it to this bug report?\n\nJake", "id": 61070, "time": "2004-07-23T18:50:24Z", "creator": "hoju@visi.com", "creation_time": "2004-07-23T18:50:24Z", "tags": [], "is_private": false}, {"count": 16, "tags": [], "bug_id": 27371, "attachment_id": null, "text": "We are getting this error simply by compiling classes to our webapp classes \ndirectory. This happens _nearly_ on every compile we do, but never used to \nhappen. \n\nSEVERE: Exception invoking periodic operation:\njava.lang.ThreadDeath\n\tat org.apache.catalina.loader.WebappClassLoader.loadClass\n(WebappClassLoader.java:1229)\n\tat org.apache.catalina.loader.WebappClassLoader.loadClass\n(WebappClassLoader.java:1189)\n\tat java.lang.ClassLoader.loadClassInternal(Unknown Source)\n\tat org.apache.log4j.spi.LoggingEvent.<init>(LoggingEvent.java:145)\n\tat org.apache.log4j.Category.forcedLog(Category.java:372)\n\tat org.apache.log4j.Category.log(Category.java:864)\n\tat org.apache.commons.logging.impl.Log4JLogger.error\n(Log4JLogger.java:192)\n\tat org.apache.catalina.session.StandardManager.start\n(StandardManager.java:659)\n\tat org.apache.catalina.core.StandardContext.start\n(StandardContext.java:4272)\n\tat org.apache.catalina.core.StandardContext.reload\n(StandardContext.java:3021)\n\tat org.apache.catalina.core.StandardContext.backgroundProcess\n(StandardContext.java:4629)\n\tat \norg.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.processChild\nren(ContainerBase.java:1619)\n\tat \norg.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.processChild\nren(ContainerBase.java:1628)\n\tat \norg.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.processChild\nren(ContainerBase.java:1628)\n\tat \norg.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.run\n(ContainerBase.java:1608)\n\tat java.lang.Thread.run(Unknown Source)\n\nAs I say, we can reproduce this almost at will with a recompile of classes \nwhich of course makes Tomcat reload.", "id": 61457, "time": "2004-08-02T15:07:59Z", "creator": "allistair.crossley@qas.com", "creation_time": "2004-08-02T15:07:59Z", "is_private": false}, {"count": 17, "attachment_id": null, "creator": "ceki@apache.org", "is_private": false, "id": 61458, "time": "2004-08-02T15:17:44Z", "bug_id": 27371, "creation_time": "2004-08-02T15:17:44Z", "tags": [], "text": "\nFrom a cursory looks, it looks more like a Tomcat bug related to commons-\nlogging rather than log4j itself. Maybe this bug should be filed as a Tomcat\nbug rather than a log4j bug?"}, {"count": 18, "tags": [], "text": "It looks like Ceki is right. I looked at the WebClassLoader source at it is\nthrowing the ThreadDeath exception because the WebClassLoader was stopped. Did\nyou not mention that you get this exception everytime that you hot deploy your\nweb application?\n\nHere is the code within tomcat that is throwing the exception:\n\n  // Don't load classes if class loader is stopped\n  if (!started) {\n     log.info(sm.getString(\"webappClassLoader.stopped\"));\n     throw new ThreadDeath();\n  }\n\nThe sm variable is a static protected variable. It seems to me that it is not\nproperly being reset somehow.\n", "attachment_id": null, "bug_id": 27371, "id": 61462, "time": "2004-08-02T18:45:48Z", "creator": "ccorsi@progress.com", "creation_time": "2004-08-02T18:45:48Z", "is_private": false}, {"count": 19, "tags": [], "bug_id": 27371, "attachment_id": null, "id": 61464, "time": "2004-08-02T19:10:55Z", "creator": "ccorsi@progress.com", "creation_time": "2004-08-02T19:10:55Z", "is_private": false, "text": "I just realized that I incorrectly mentioned the sm variable instead of the\nstarted variable in my previous explanation. I meant to say the started variable\nwas not set correctly becaues the classes start method was not called before\ntrying to use the classload to load the class. It still is a bug within the\ntomcat code base and not the log4j code base.\n\nSorry about that :-("}, {"count": 20, "tags": [], "bug_id": 27371, "attachment_id": null, "text": "Adding tomcat-dev@jakarta.apache.org as we should keep track of this.  What's \nthe solution then?  Not log at all while restarting a webapp?", "id": 61580, "time": "2004-08-05T13:19:18Z", "creator": "yoavs@computer.org", "creation_time": "2004-08-05T13:19:18Z", "is_private": false}, {"count": 21, "tags": [], "text": "--- Begin Text by Craig McClanahan ---\nThe reason that LogFactory instances are stored in a map keyed by\ncontext class loader was to meet a functional requirement that each\nwebapp could have independently configured constellations of Log\ninstances, created by independent LogFactory instances, per webapp --\neven if commons-logging.jar itself is installed into a shared class\nloader (i.e. common/lib or shared/lib in Tomcat).  This is why you\ncan't just use a static variable, because there would only be one\nLogFactory instance across the entire Tomcat JVM.  In addition, there\nis no other reasonable key that is specific to a webapp, but *not*\nspecific to the Servlet API (tying commons-logging use to require\nservlet.jar would not be a good thing).\n\nIn order to allow cleanup of these allocated instances, the\nLogFactory.release() method may be used to ask a LogFactory to release\nall of its Log instances.  In addition, the static\nLogFactory.release(ClassLoader) method releases references to the\nLogFactory instance for that class loader.  I believe that both of\nthese APIs were just added in 1.0.4.\n\nInside Tomcat, then, a webapp using c-l can add a\nServletContextListener whose contextDestroyed() method calls the\nappropriate release methods to clean up.\n--- End text by Craig McClanahan ---\n\nSo to the people who reported this: please try adding such a \nServletContextListener and using the above methods that Craig mentioned, and \nlet us know if that makes the error go away.\n", "attachment_id": null, "bug_id": 27371, "id": 61601, "time": "2004-08-05T19:36:59Z", "creator": "yoavs@computer.org", "creation_time": "2004-08-05T19:36:59Z", "is_private": false}, {"count": 22, "tags": [], "bug_id": 27371, "attachment_id": null, "id": 61638, "time": "2004-08-06T16:25:19Z", "creator": "allistair.crossley@qas.com", "creation_time": "2004-08-06T16:25:19Z", "is_private": false, "text": "I can confirm that the following does _not_ solve the ThreadDeath exception \nwhen Tomcat reloads the context following a class compile.\n\nimport org.apache.log4j.LogManager;\nimport org.apache.commons.logging.LogFactory;\n\npublic void contextDestroyed(ServletContextEvent scE) {\t\t\n    LogManager.shutdown();\n    LogFactory.releaseAll();\n}"}, {"count": 23, "tags": [], "bug_id": 27371, "attachment_id": null, "text": "\nIt seems to me that tomcat reuses these classloaders and I have a feeling that\nwhen the classloader is being reused. The classloader start method does not get\ncalled, causing the classloader to not have been \"started\", generating the\nThreadDeath exception whenever the loadClass method is called.\n", "id": 61641, "time": "2004-08-06T17:55:38Z", "creator": "ccorsi@progress.com", "creation_time": "2004-08-06T17:55:38Z", "is_private": false}, {"count": 24, "attachment_id": null, "bug_id": 27371, "text": "What are you basing this on?  Any code references would be nice.", "id": 61642, "time": "2004-08-06T17:57:17Z", "creator": "yoavs@computer.org", "creation_time": "2004-08-06T17:57:17Z", "tags": [], "is_private": false}, {"count": 25, "tags": [], "bug_id": 27371, "text": "\nI was looking at the WebappClassLoader class and it contains a started attribute\nthat is used to determine that if the WebappClassLoader instance was started\nbefore it can be used to load classes. The started attribute is set using the\nclasses start and stop methods. The ThreadDeath exception is being thrown\nbecause when the WebappClassLoader instance is calling the loadClass method it\nchecks that the started attribute is true. If it isn't, it throws the\nThreadDeath exception.\n\nI then looked at the StandardContext class. It contains a method called reload\nthat is used whenever it wants to reload that particular web application\nassociated to that instance of StandardContext. I also noticed that the\nStandardContext method will associate a single WebappLoader to the\nStandardContext instance. This WebappLoader contain the ClassLoader used by this\nStandardContext web application. The assignment of the WebappLoader is done only\nonce and it is done within the start method only. This method initially checks\nif the WebappLoader has been associated to the StandardContext. It will then\nonly assign a WebappLoader to the StandardContext if their was none.\n\nI deduced by looking at these sections of the code that it seems like whenever a\n StandardContext web application is being reloaded. Its WebappLoader\nWebappClassLoader start method is not be called before loading any of the web\napplication classes. It does seem like its stop method is being called whenever\nthe web application is being stopped.\n\nThis is why I believe that the WebappClassLoader is not being properly setup\nbefore being used.\n\nI am basing this on looking at the code only. I have not tried to debug this\ncase. It is only a theory based on observations and nothing else.", "id": 61655, "time": "2004-08-07T00:55:49Z", "creator": "ccorsi@progress.com", "creation_time": "2004-08-07T00:55:49Z", "is_private": false, "attachment_id": null}, {"count": 26, "attachment_id": null, "bug_id": 27371, "text": "I've got the same exception, but without log4j envolvement. To reproduce try \nthis:\n\n1. In TC 5.0.27 login to admin application.\n2. Under the Host->Create New Context create the new context pointing to some \nJSP webapp outside standard webapps directory.\n3. When finished successfuly, try to invoke this application and you should get \nThreadDeath exception.\n\nBTW, it is working fine when deploying to the standard webapps directory.\n\nHere is a stack:\n\njava.lang.ThreadDeath\n\tat org.apache.catalina.loader.WebappClassLoader.loadClass\n(WebappClassLoader.java:1229)\n\tat org.apache.catalina.loader.WebappClassLoader.loadClass\n(WebappClassLoader.java:1189)\n\tat org.apache.jasper.compiler.Parser.parseCustomTag(Parser.java:1316)\n\tat org.apache.jasper.compiler.Parser.parseElements(Parser.java:1560)\n\tat org.apache.jasper.compiler.Parser.parse(Parser.java:126)\n\tat org.apache.jasper.compiler.ParserController.doParse\n(ParserController.java:220)\n\tat org.apache.jasper.compiler.ParserController.parse\n(ParserController.java:101)\n\tat org.apache.jasper.compiler.Compiler.generateJava(Compiler.java:203)\n\tat org.apache.jasper.compiler.Compiler.compile(Compiler.java:470)\n\tat org.apache.jasper.compiler.Compiler.compile(Compiler.java:451)\n\tat org.apache.jasper.compiler.Compiler.compile(Compiler.java:439)\n\tat org.apache.jasper.JspCompilationContext.compile\n(JspCompilationContext.java:511)\n\tat org.apache.jasper.servlet.JspServletWrapper.service\n(JspServletWrapper.java:295)\n\tat org.apache.jasper.servlet.JspServlet.serviceJspFile\n(JspServlet.java:292)\n\tat org.apache.jasper.servlet.JspServlet.service(JspServlet.java:236)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:802)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter\n(ApplicationFilterChain.java:237)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter\n(ApplicationFilterChain.java:157)\n\tat org.apache.catalina.core.StandardWrapperValve.invoke\n(StandardWrapperValve.java:214)\n\tat org.apache.catalina.core.StandardValveContext.invokeNext\n(StandardValveContext.java:104)\n\tat org.apache.catalina.core.StandardPipeline.invoke\n(StandardPipeline.java:520)\n\tat org.apache.catalina.core.StandardContextValve.invokeInternal\n(StandardContextValve.java:198)\n\tat org.apache.catalina.core.StandardContextValve.invoke\n(StandardContextValve.java:152)\n\tat org.apache.catalina.core.StandardValveContext.invokeNext\n(StandardValveContext.java:104)\n\tat org.apache.catalina.core.StandardPipeline.invoke\n(StandardPipeline.java:520)\n\tat org.apache.catalina.core.StandardHostValve.invoke\n(StandardHostValve.java:137)\n\tat org.apache.catalina.core.StandardValveContext.invokeNext\n(StandardValveContext.java:104)\n\tat org.apache.catalina.valves.ErrorReportValve.invoke\n(ErrorReportValve.java:117)\n\tat org.apache.catalina.core.StandardValveContext.invokeNext\n(StandardValveContext.java:102)\n\tat org.apache.catalina.core.StandardPipeline.invoke\n(StandardPipeline.java:520)\n\tat org.apache.catalina.core.StandardEngineValve.invoke\n(StandardEngineValve.java:109)\n\tat org.apache.catalina.core.StandardValveContext.invokeNext\n(StandardValveContext.java:104)\n\tat org.apache.catalina.core.StandardPipeline.invoke\n(StandardPipeline.java:520)\n\tat org.apache.catalina.core.ContainerBase.invoke(ContainerBase.java:929)\n\tat org.apache.coyote.tomcat5.CoyoteAdapter.service\n(CoyoteAdapter.java:160)\n\tat org.apache.coyote.http11.Http11Processor.process\n(Http11Processor.java:799)\n...", "id": 62863, "time": "2004-08-31T20:11:35Z", "creator": "alexsmr@sympatico.ca", "creation_time": "2004-08-31T20:11:35Z", "tags": [], "is_private": false}, {"count": 27, "tags": [], "text": "Per Jay Paulsen's findings archived at http://marc.theaimsgroup.com/?\nt=109578393000004&r=1&w=2, please try adding the Introspector.flush call to \nyour shutdown code and re-testing.  Thanks.", "is_private": false, "id": 64048, "creator": "yoavs@computer.org", "time": "2004-09-22T14:12:59Z", "bug_id": 27371, "creation_time": "2004-09-22T14:12:59Z", "attachment_id": null}, {"count": 28, "tags": [], "bug_id": 27371, "attachment_id": null, "id": 67401, "time": "2004-11-23T23:05:52Z", "creator": "st946tbf@drexel.edu", "creation_time": "2004-11-23T23:05:52Z", "is_private": false, "text": "Running the embedded Tomcat 5.5.4, after I stop and start() a web context, I got\nthe following exception (and the AxisServlet does not run).  However, with the\nexact same web application in the standalone Tomcat 5.5.4, I don't get any\nexception (and the AxisServlet runs ok)\n\n- Starting Coyote HTTP/1.1 on http-80\n- Illegal access: this web application instance has been stopped already.  Could\nnot load META-INF/services/org.apache.axis.EngineConfigurationFactory.  The\neventual following stack trace is caused by an error thrown for debugging\npurposes as well as to attempt to terminate the thread which caused the illegal\naccess, and has no functional impact.\n- Illegal access: this web application instance has been stopped already.  Could\nnot load org/apache/axis/configuration/EngineConfigurationFactoryServlet.class.\n The eventual following stack trace is caused by an error thrown for debugging\npurposes as well as to attempt to terminate the thread which caused the illegal\naccess, and has no functional impact.\n- Illegal access: this web application instance has been stopped already.  Could\nnot load org.apache.axis.configuration.EngineConfigurationFactoryServlet.  The\neventual following stack trace is caused by an error thrown for debugging\npurposes as well as to attempt to terminate the thread which caused the illegal\naccess, and has no functional impact.\n- StandardWrapper.Throwable\njava.lang.ThreadDeath\n    at\norg.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1221)\n    at\norg.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1181)\n    at org.apache.commons.discovery.ResourceClass$1.run(ResourceClass.java:77)\n    at java.security.AccessController.doPrivileged(Native Method)\n    at org.apache.commons.discovery.ResourceClass.loadClass(ResourceClass.java:73)\n    at\norg.apache.axis.configuration.EngineConfigurationFactoryFinder$1.run(EngineConfigurationFactoryFinder.java:122)\n    at java.security.AccessController.doPrivileged(Native Method)\n    at\norg.apache.axis.configuration.EngineConfigurationFactoryFinder.newFactory(EngineConfigurationFactoryFinder.java:113)\n    at\norg.apache.axis.transport.http.AxisServletBase.getEngineEnvironment(AxisServletBase.java:247)\n    at\norg.apache.axis.transport.http.AxisServletBase.getEngine(AxisServletBase.java:170)\n    at\norg.apache.axis.transport.http.AxisServletBase.getOption(AxisServletBase.java:370)\n    at org.apache.axis.transport.http.AxisServletBase.init(AxisServletBase.java:110)\n    at javax.servlet.GenericServlet.init(GenericServlet.java:211)\n    at\norg.apache.catalina.core.StandardWrapper.loadServlet(StandardWrapper.java:1053)\n    at org.apache.catalina.core.StandardWrapper.load(StandardWrapper.java:886)\n    at\norg.apache.catalina.core.StandardContext.loadOnStartup(StandardContext.java:3817)\n    at org.apache.catalina.core.StandardContext.start(StandardContext.java:4079)\n\n\n- Servlet /axis threw load() exception\njavax.servlet.ServletException: Servlet.init() for servlet AdminServlet threw\nexception\n    at\norg.apache.catalina.core.StandardWrapper.loadServlet(StandardWrapper.java:1095)\n    at org.apache.catalina.core.StandardWrapper.load(StandardWrapper.java:886)\n    at\norg.apache.catalina.core.StandardContext.loadOnStartup(StandardContext.java:3817)\n    at org.apache.catalina.core.StandardContext.start(StandardContext.java:4079)"}, {"count": 29, "tags": [], "bug_id": 27371, "attachment_id": null, "text": "I meant the AdminServlet did not run.  The AxisServlet ran fine.", "id": 67405, "time": "2004-11-23T23:35:40Z", "creator": "st946tbf@drexel.edu", "creation_time": "2004-11-23T23:35:40Z", "is_private": false}, {"count": 30, "tags": [], "bug_id": 27371, "attachment_id": null, "text": "Hi!\n\nI'm also experiencing ThreadDeath with Log4j on Tomcat 5.0.28 (bundled with\nNetBeans 4.0) when restarting applications. I understand you've already seen a\nlot of stack traces in this discussion.  So I'll just give a part of mine:\n\n==========================================\nCaused by: java.lang.ThreadDeath\n    at\norg.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1229)\n    at\norg.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1189)\n    at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:302)\n    at org.apache.log4j.NDC.get(NDC.java:201)\n    at org.apache.log4j.spi.LoggingEvent.getNDC(LoggingEvent.java:229)\netc...\n==========================================\n\nSeems like NDC is arranging its instances in a Hashtable with key being the\ncurrent thread. That might be the reason of such behaviour. Have you thought of\nswitching to ThreadLocal? I'm not sure about how it may affect the performance\nthough.\n\nThanks", "id": 70670, "time": "2005-02-09T00:42:45Z", "creator": "yegor.jbanov@spicesoft.com", "creation_time": "2005-02-09T00:42:45Z", "is_private": false}, {"count": 31, "attachment_id": null, "creator": "brett_s_r@yahoo.com.au", "text": "I'm not sure why this issue remains open, given that #26372 has been closed.\n\nWhenever there is a ThreadDeath thrown from WebappClassLoader.loadClass() during \na webapp restart, it is due to Tomcat invalidating the webapp's ClassLoader \nwhile threads are still executing a (long-running) service() method (or even \nlifecycle method).  Tomcat waits 2 seconds, then invalidates the ClassLoader and \nrestarts the app, resulting in a ThreadDeath thrown by the ClassLoader if new \nclass load requests occur.  See my comment in #26372 .\n\nGiven that #26372 has been marked invalid (read as -1 for a configurable [or \nperhaps longer] wait-time for current requests to complete, prior to \ninvalidating the ClassLoader and restarting the webapp), I think that this issue \nshould now be closed.\n\nThis is a Tomcat issue for restartable webapps, not a log4j issue.\n", "id": 70674, "time": "2005-02-09T01:08:02Z", "bug_id": 27371, "creation_time": "2005-02-09T01:08:02Z", "tags": [], "is_private": false}, {"count": 32, "tags": [], "bug_id": 27371, "attachment_id": null, "text": "Closing as consensus indicates that it is a Tomcat issue.  Wish there was a \nbetter resolution than \"INVALID\", but that seems to be the closest fit.", "id": 76925, "time": "2005-07-01T23:22:22Z", "creator": "mwomack@apache.org", "creation_time": "2005-07-01T23:22:22Z", "is_private": false}, {"count": 33, "tags": [], "text": "I found a solution. copy the log4j jar file and rename to another file name, \nsuch as log4j-1.2.6.jar. put the both log4j jar files to WEB-INF lib directory.", "is_private": false, "id": 78113, "creator": "cqhzq2002@163.com", "time": "2005-08-04T14:57:59Z", "bug_id": 27371, "creation_time": "2005-08-04T14:57:59Z", "attachment_id": null}, {"count": 34, "tags": [], "text": "Your solution seems more like black magic to me.  What do you think you've\nfixed?  And what is it about having 2 log4j jars in WEB-INF/lib changes the\nthread death behavior?  You do realize that the thread death stuff is sporadic,\nright?  You've performed an action and have found that you haven't gotten the\nerror.  You attribute the success to your action where, in reality, you can't\nknow whether it was your action or dumb luck that led to success... unless you\nactually do know the real cause/effect relationship.  If so, we're all ears! \nUntil then, this is black magic.\n\nJake", "attachment_id": null, "id": 78118, "creator": "hoju@visi.com", "time": "2005-08-04T15:45:05Z", "bug_id": 27371, "creation_time": "2005-08-04T15:45:05Z", "is_private": false}, {"count": 35, "tags": [], "text": "*** Bug 36616 has been marked as a duplicate of this bug. ***", "attachment_id": null, "id": 81614, "creator": "cowwoc@bbs.darktech.org", "time": "2005-10-24T15:07:28Z", "bug_id": 27371, "creation_time": "2005-10-24T15:07:28Z", "is_private": false}, {"count": 36, "tags": [], "bug_id": 27371, "attachment_id": null, "text": "although many comments say log4j has nothing to do with it which is \ntheoretically probably true, most of the time it appears like log4j is causing \nthe issue. my latest threaddeath which i get around 5 times per day I suppose \nafter about 5 reloads indicates\n\nINFO: Illegal access: this web application instance has been stopped already.  \nCould not load org.apache.log4j.spi.ThrowableInformation.  The eventual \nfollowing stack trace is caused by an error thrown for debugging purposes as \nwell as to attempt to terminate the thread which caused the illegal access, and \nhas no functional impact.\n\nIt does always appear to be this SPI class as long as I can remember. A naiive \nthought but perhaps if there were a way to stop this class entering loadClass \nat the wrong time the threaddeath would disappear for most common cases since \neveryone uses log4j with tomcat.\n\n", "id": 81641, "time": "2005-10-24T17:32:38Z", "creator": "allistair.crossley@qas.com", "creation_time": "2005-10-24T17:32:38Z", "is_private": false}, {"count": 37, "tags": [], "bug_id": 27371, "attachment_id": null, "text": "I second that motion. I also keep on seeing that\n\"org.apache.log4j.spi.ThrowableInformation\" error and I redeploy my application\na few hundred times a day (while developing under Netbeans) so this issue is\nvery critical to me. It would also be invaluable to have a minimal testcase for\nthis. Yoav (of Tomcat) has mentioned he'd work on a fix for this issue but we\nneed a testcase first (he can't reproduce it on his end).", "id": 81647, "time": "2005-10-24T18:01:55Z", "creator": "cowwoc@bbs.darktech.org", "creation_time": "2005-10-24T18:01:55Z", "is_private": false}, {"count": 38, "tags": [], "bug_id": 27371, "attachment_id": null, "text": "(In reply to comment #36)\n> although many comments say log4j has nothing to do with it which is \n> theoretically probably true, most of the time it appears like log4j is causing \n> the issue. my latest threaddeath which i get around 5 times per day I suppose \n> after about 5 reloads indicates\n> \n> INFO: Illegal access: this web application instance has been stopped already.  \n> Could not load org.apache.log4j.spi.ThrowableInformation.  The eventual \n> following stack trace is caused by an error thrown for debugging purposes as \n> well as to attempt to terminate the thread which caused the illegal access, and \n> has no functional impact.\n> \n> It does always appear to be this SPI class as long as I can remember. A naiive \n> thought but perhaps if there were a way to stop this class entering loadClass \n> at the wrong time the threaddeath would disappear for most common cases since \n> everyone uses log4j with tomcat.\n\nI don't see the point of blaming log4j as is. It's the same problem with any\nshared library which would keep objects related to a webapp, while at the same\ntime being disconnected from the lifecycle (at best, memory leaking will occur).\nI'd say the concept is to be blamed, but there are few solutions.\n\nProblems can also be caused by not setting the context classloader well (I did\nfix some more issues related to this in 5.5.9+, as JULI is quite sensitive to\nthat). I think the current code is now clean related to this.", "id": 81649, "time": "2005-10-24T18:08:07Z", "creator": "remm@apache.org", "creation_time": "2005-10-24T18:08:07Z", "is_private": false}, {"count": 39, "tags": [], "bug_id": 27371, "attachment_id": null, "id": 81652, "time": "2005-10-24T18:36:40Z", "creator": "allistair.crossley@qas.com", "creation_time": "2005-10-24T18:36:40Z", "is_private": false, "text": "hey,\n\ni wasn't really blaming log4j, i just noted from the many many posts for this \nbug that log4j came up a lot and taking a pragmatic view thought it may be \naddressable. however, i appreciate that if you were to do that, then where \nwould you stop if other libs caused the same issue. it wouldn't be good to \npollute tomcat's code to bypass known issues for sure. i jsut think that since \nit's mostly this log4j class causing the issue, someone somewhere could change \nthe root cause.\n\ni don't know .. just thinking out load ;)\n\n"}, {"count": 40, "tags": [], "bug_id": 27371, "attachment_id": null, "id": 81653, "time": "2005-10-24T18:45:47Z", "creator": "cowwoc@bbs.darktech.org", "creation_time": "2005-10-24T18:45:47Z", "is_private": false, "text": "Remy,\n\nI am using Tomcat 5.5.9, and log4j is only being loaded within the webapp\ncontext (not global) and I still get this problem.\n\nTo date everyone keeps on talking theory but no one had yet to offer a practical\nsolution. Both Brett and Yoav have suggested one, which is to allow a\nconfigurable timeout value before the ClassLoader is invalidated. Granted it's\nnot foolproof (who knows how big the timeout needs to be), but at least it's a\npractical solution. You mention there are some other solutions, what are some of\nyour practical solutions to this problem?"}, {"count": 41, "tags": [], "text": "Idea, would it be possible to swap class loaders like a DJ does with Records. \nLet the class loader still exist beyond the contextDestroy() call.  But only for\na limited wall clock time or until the next re-deploy for the same context\n(whichever comes first).  We don't want to hold N generations of class loaders\nduring multiple re-deploys.\n\nI'm not sure if Java allows this, but can a supperior management thread poll all\nits child threads (or all threads in the JVM) and enquire details about the\nexecution context of that thread.  This would allow a background poll of all\nthreads to occurr to identify which execution threads are still using a class\nloader that we are trying to shutdown.  If there are none we can cleanup sooner.\n\nThis seems like an obvious need from the JVM given the long running nature of\nthe JVM and the hierarchical class loader mechanism.\n\nI do understand the servlet spec does not mandate what happens, so what we get\nis a bonus to us, but I'm more for the view of lets be a leader and write an\nimplementation thats robust and useful to the general population then maybe a\nspecification will be written from it for other implementors follow.  Maybe this\nis as odds with TCs boilerplate implementation, but when an issue causes so much\npain to the community its time to bear arms.\n", "attachment_id": null, "id": 81808, "creator": "darryl@darrylmiles.org", "time": "2005-10-27T10:08:37Z", "bug_id": 27371, "creation_time": "2005-10-27T10:08:37Z", "is_private": false}, {"count": 42, "tags": [], "text": "(In reply to comment #41)\n> Idea, would it be possible to swap class loaders like a DJ does with Records. \n> Let the class loader still exist beyond the contextDestroy() call.\n\nNo.", "is_private": false, "id": 81810, "creator": "remm@apache.org", "time": "2005-10-27T10:14:04Z", "bug_id": 27371, "creation_time": "2005-10-27T10:14:04Z", "attachment_id": null}, {"count": 43, "tags": [], "bug_id": 27371, "attachment_id": null, "text": "Ok, no reply from Remy. So on the one hand this isn't a log4j issue, on the\nother hand it isn't being fixed in Tomcat... I'll ask again, does anyone have a\nminimal testcase for reproducing this issue?", "id": 81998, "time": "2005-10-31T19:31:38Z", "creator": "cowwoc@bbs.darktech.org", "creation_time": "2005-10-31T19:31:38Z", "is_private": false}, {"count": 44, "tags": [], "bug_id": 27371, "attachment_id": null, "id": 82160, "time": "2005-11-06T23:21:05Z", "creator": "brett_s_r@yahoo.com.au", "creation_time": "2005-11-06T23:21:05Z", "is_private": false, "text": "The testcase is fairly straightforward - all you need is a servlet with a\nservice() method with say a (generous) twenty second sleep in it (during which\nyou will request a reload of the context), followed by any code that will cause\na class to be loaded.  Hit the servlet with a service request, and reload the\nwebapp during the sleep.  Tomcat will have invalidated the classloader (and\nreloaded the context) by the time the sleep completes, and you should see a\nThreadDeath thrown."}, {"count": 45, "tags": [], "text": "Brett,\n\nThere seems to be a mismatch between your test-case description and what I've\nbeen experiencing on my end. What I see on my end is request #1 is run to\ntermination, I request a reload of the webapp, Tomcat's manager fails the reload\noperation and indicates a ThreadDeath has occured. I fully expect the request to\nget ThreadDeath if it continues running beyond the scope of a context reload but\nwhat I am seeing (and I consider this a bug) is Tomcat dishing out a ThreadDeath\nto a completely unrelated request. If I try sending out request #2 after the\nreload operation returns ThreadDeath, the request will fail with yet another\nexception. From this point onward Tomcat is in some sort of bad state and no\nmatter how many times I try manager stop/start/reload it'll always fail. I am\nforced to fully shutdown Tomcat and restart it. New requests to the webapp now work.\n\nYou can read more about this here:\nhttp://www.netbeans.org/issues/show_bug.cgi?id=62529\n\nDo you have any idea why this is occuring? I have been unable to narrow this\ndown to a minimal testcase. I saw it once in my minimal testcase, but too rare\nto be of any use. In my original application I see it on the first\nmanager/reload request. I will continue trying to isolate the problem.", "attachment_id": null, "id": 82167, "creator": "cowwoc@bbs.darktech.org", "time": "2005-11-07T07:11:41Z", "bug_id": 27371, "creation_time": "2005-11-07T07:11:41Z", "is_private": false}, {"count": 46, "tags": [], "creator": "brett_s_r@yahoo.com.au", "attachment_id": null, "id": 82201, "time": "2005-11-08T10:58:24Z", "bug_id": 27371, "creation_time": "2005-11-08T10:58:24Z", "is_private": false, "text": "Gili,\n\nYou asked for a minimal testcase showing ThreadDeath being thrown, so that's\nwhat I described :).  You should try it out - perhaps it will assist in\nunderstanding the specifics of the problem you are having there.\n\nYou should bear in mind that this is no longer considered a bug, as the issue is\npretty well understood now.  To re-raise as a bug you would need to be able to\ndemostrate incorrect behaviour by Tomcat's classloaders.  There are workarounds\nfor the fact that Tomcat does not allow the service() threads timeout to be\nconfigured.  Other invalid references to classloaders may be harder to track\ndown, perhaps this is what you are experiencing.\n\nI couldn't see any of your stack-traces above.  Perhaps they will highlight the\noperation that caused the ThreadDeath to be thrown.\n"}, {"count": 47, "tags": [], "bug_id": 27371, "attachment_id": null, "id": 82318, "time": "2005-11-09T21:17:22Z", "creator": "darryl@darrylmiles.org", "creation_time": "2005-11-09T21:17:22Z", "is_private": false, "text": "(In reply to comment #45)\nI request a reload of the webapp, Tomcat's manager fails the reload\n> operation and indicates a ThreadDeath has occured. I fully expect the request to\n> get ThreadDeath if it continues running beyond the scope of a context reload but\n> what I am seeing (and I consider this a bug) is Tomcat dishing out a ThreadDeath\n> to a completely unrelated request. If I try sending out request #2 after the\n> reload operation returns ThreadDeath, the request will fail with yet another\n> exception. From this point onward Tomcat is in some sort of bad state and no\n> matter how many times I try manager stop/start/reload it'll always fail. I am\n> forced to fully shutdown Tomcat and restart it. New requests to the webapp now\nwork.\n\n\nThe annoyance I get is that Tomcat states the ThreadDeath that occurs wont upset\nthe re-deployed web-app, but it does.  No further requests to tomcat on the\nweb-app are possible.  The only way out is a container restart.  I think maybe\nthis is a genuine different problem but I've no proof yet.\n\n\nMaybe as a helpful suggestion, Tomcat could emit in the ThreadDeath exception\nmessage the Thread.getId() and Thread.getName() of the thread that is dying,\nthis would be useful anyway to help fix your application and put us developers\nin the picture as to exactly what died.\n\nthrow new java.lang.ThreadDeath(\"of\nThread#\"+Thread.currentThread().getThreadId()+\" \"+Thread.currentThread().getName());\n\nWould such a trival patch be accepted ?\n\n\nUnfortunatly I've had no time this week to investigate further, I'm eyeing up\nhacking on JMP (Java Profiler) to get a class loader report from heap snapshots\nthen dumping out all references between objects that cross to a different class\nloader.  Maybe someone knows of a tool already for this ?"}]