[{"count": 0, "tags": [], "creator": "germannm@post.ch", "attachment_id": null, "text": "If the location of a PFB File is specified with an URL, it happens sometimes\nthat an IOException with the message \"Could not load the whole segment\" is thrown. \n\nI think that i found the bug in the parsePCFormat() method of the class\norg.apache.fop.fonts.type1.PCFParser (FOP 0.20.5rc2). In this class, i found\nthree occurences of the following code:\n\n> bytesRead = din.read(encryptedSegment);\n> if (bytesRead != len2) {\n>    throw new IOException(\"Could not load the whole segment\");\n> }\n\nIn my opinion, this does not work, because the read() method of InputStream does\nonly read as many bytes as are imediately available. It seams, that in a network\nconnection, not all bytes are imediately available. I think, that the read()\nmethod must be replaced by the readFully() method as follows.\n\n> din.readFully(encryptedSegment);\n\nI've replaced the calls to the read() method with the readFully() method and it\nworks for me as it should. \n\nFeel free to contact me, if you need any additional information.\n\nRegards,\n\nMatthias Germann\nSwiss Post\nInformation Technology Services (IT1-5.4)\nWebergutstrasse 12\n3030 Bern (Zollikofen)\nSwitzerland\n\nPhone\t+41 (0)31 338 07 09\nFax\t+41 (0)31 338 53 25\nE-Mail\tgermannm@post.ch\n\nHere is the version of the PFBParser which works for me. Beginn and end of the\nmodifications are marked with 'XXX'.\n\n/*\n * $Id: PFBParser.java,v 1.1.2.2 2002/12/02 14:04:16 jeremias Exp $\n * Copyright (C) 2002 The Apache Software Foundation. All rights reserved.\n * For details on use and redistribution please refer to the\n * LICENSE file included with these sources.\n */\npackage org.apache.fop.fonts.type1;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.DataInputStream;\nimport java.io.BufferedInputStream;\n\n//FOP\nimport org.apache.fop.tools.IOUtil;\n\n/**\n * This class represents a parser for Adobe Type 1 PFB files.\n *\n * @see PFBData\n */\npublic class PFBParser {\n\n    private static final byte[] CURRENTFILE_EEXEC;\n    private static final byte[] CLEARTOMARK;\n\n    static {\n        try {\n            CURRENTFILE_EEXEC = \"currentfile eexec\".getBytes(\"US-ASCII\");\n            CLEARTOMARK = \"cleartomark\".getBytes(\"US-ASCII\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            throw new RuntimeException(\"Incompatible VM. It doesn't support the\nUS-ASCII encoding\");\n        }\n    }\n\n\n    /**\n     * Parses a PFB file into a PFBData object.\n     * @param url URL to load the PFB file from\n     * @return PFBData memory representation of the font\n     * @throws IOException In case of an I/O problem\n     */\n    public PFBData parsePFB(java.net.URL url) throws IOException {\n        InputStream in = url.openStream();\n        try {\n            return parsePFB(in);\n        } finally {\n            in.close();\n        }\n    }\n\n\n    /**\n     * Parses a PFB file into a PFBData object.\n     * @param pfbFile File to load the PFB file from\n     * @return PFBData memory representation of the font\n     * @throws IOException In case of an I/O problem\n     */\n    public PFBData parsePFB(java.io.File pfbFile) throws IOException {\n        InputStream in = new java.io.FileInputStream(pfbFile);\n        try {\n            return parsePFB(in);\n        } finally {\n            in.close();\n        }\n    }\n\n\n    /**\n     * Parses a PFB file into a PFBData object.\n     * @param in InputStream to load the PFB file from\n     * @return PFBData memory representation of the font\n     * @throws IOException In case of an I/O problem\n     */\n    public PFBData parsePFB(InputStream in) throws IOException {\n        PFBData pfb = new PFBData();\n        BufferedInputStream bin = new BufferedInputStream(in);\n        DataInputStream din = new DataInputStream(bin);\n        din.mark(32);\n        int firstByte = din.readUnsignedByte();\n        din.reset();\n        if (firstByte == 128) {\n            pfb.setPFBFormat(PFBData.PFB_PC);\n            parsePCFormat(pfb, din);\n        } else {\n            pfb.setPFBFormat(PFBData.PFB_RAW);\n            parseRAWFormat(pfb, bin);\n        }\n        return pfb;\n    }\n\n\n    private static int swapInteger(final int value) {\n        return (((value >> 0) & 0xff) << 24)\n             + (((value >> 8) & 0xff) << 16)\n             + (((value >> 16) & 0xff) << 8)\n             + (((value >> 24) & 0xff) << 0);\n    }\n\n\n    private void parsePCFormat(PFBData pfb, DataInputStream din) throws\nIOException {\n        int segmentHead;\n        int segmentType;\n        int bytesRead;\n\n        //Read first segment\n        segmentHead = din.readUnsignedByte();\n        if (segmentHead != 128) {\n            throw new IOException(\"Invalid file format. Expected ASCII 80hex\");\n        }\n        segmentType = din.readUnsignedByte(); //Read\n        int len1 = swapInteger(din.readInt());\n        byte[] headerSegment = new byte[len1];\n        // XXX beginn modification\n        // bytesRead = din.read(headerSegment);\n        // if (bytesRead != len1) {\n\t\t//           throw new IOException(\"Could not load the whole segment\");\n\t\t// }\n        din.readFully(headerSegment);\n        // XXX end modification\n                pfb.setHeaderSegment(headerSegment);\n\n        //Read second segment\n        segmentHead = din.readUnsignedByte();\n        if (segmentHead != 128) {\n            throw new IOException(\"Invalid file format. Expected ASCII 80hex\");\n        }\n        segmentType = din.readUnsignedByte();\n        int len2 = swapInteger(din.readInt());\n        byte[] encryptedSegment = new byte[len2];\n        // XXX beginn modification\n        // bytesRead = din.read(encryptedSegment);\n        // if (bytesRead != len2) {\n        //     throw new IOException(\"Could not load the whole segment\");\n        // }\n        din.readFully(encryptedSegment);\n        // XXX end modification\n\n        pfb.setEncryptedSegment(encryptedSegment);\n\n        //Read third segment\n        segmentHead = din.readUnsignedByte();\n        if (segmentHead != 128) {\n            throw new IOException(\"Invalid file format. Expected ASCII 80hex\");\n        }\n        segmentType = din.readUnsignedByte();\n        int len3 = swapInteger(din.readInt());\n        byte[] trailerSegment = new byte[len3];\n        // XXX beginn modification\n\t\t// bytesRead = din.read(trailerSegment);\n        // if (bytesRead != len3) {\n        //     throw new IOException(\"Could not load the whole segment\");\n        // }\n\t\tdin.readFully(trailerSegment);\n\t\t// XXX end modification\n        pfb.setTrailerSegment(trailerSegment);\n\n        //Read EOF indicator\n        segmentHead = din.readUnsignedByte();\n        if (segmentHead != 128) {\n            throw new IOException(\"Invalid file format. Expected ASCII 80hex\");\n        }\n        segmentType = din.readUnsignedByte();\n        if (segmentType != 3) {\n            throw new IOException(\"Expected segment type 3, but found: \" +\nsegmentType);\n        }\n    }\n\n\n    private static final boolean byteCmp(byte[] src, int srcOffset, byte[] cmp) {\n        for (int i = 0; i < cmp.length; i++) {\n            // System.out.println(\"Compare: \" + src[srcOffset + i] + \" \" + cmp[i]);\n            if (src[srcOffset + i] != cmp[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private void calcLengths(PFBData pfb, byte[] originalData) {\n        // Calculate length 1 and 3\n        // System.out.println (\"Checking font, size = \"+originalData.length);\n\n        // Length1 is the size of the initial ascii portion\n        // search for \"currentfile eexec\"\n        // Get the first binary number and search backwards for \"eexec\"\n        int len1 = 30;\n\n        // System.out.println(\"Length1=\"+len1);\n        while (!byteCmp(originalData, len1 - CURRENTFILE_EEXEC.length,\nCURRENTFILE_EEXEC)) {\n            len1++;\n        }\n\n        // Skip newline\n        len1++;\n\n        // Length3 is length of the last portion of the file\n        int len3 = 0;\n        len3 -= CLEARTOMARK.length;\n        while (!byteCmp(originalData, originalData.length + len3, CLEARTOMARK)) {\n            len3--;\n            // System.out.println(\"Len3=\"+len3);\n        }\n        len3 = -len3;\n        len3++;\n        // Eat 512 zeroes\n        int numZeroes = 0;\n        byte[] ws1 = new byte[]{0x0D}; //CR\n        byte[] ws2 = new byte[]{0x0A}; //LF\n        byte[] ws3 = new byte[]{0x30}; //\"0\"\n        while ((originalData[originalData.length - len3] == ws1[0]\n                || originalData[originalData.length - len3] == ws2[0]\n                || originalData[originalData.length - len3] == ws3[0])\n                && numZeroes < 512) {\n            len3++;\n            if (originalData[originalData.length - len3] == ws3[0]) {\n                numZeroes++;\n            }\n        }\n        // System.out.println(\"Length3=\"+len3);\n\n        //Create the 3 segments\n        byte[] buffer = new byte[len1];\n        System.arraycopy(originalData, 0, buffer, 0, len1);\n        pfb.setHeaderSegment(buffer);\n\n        int len2 = originalData.length - len3 - len1;\n        buffer = new byte[len2];\n        System.arraycopy(originalData, len1, buffer, 0, len2);\n        pfb.setEncryptedSegment(buffer);\n\n        buffer = new byte[len3];\n        System.arraycopy(originalData, len1 + len2, buffer, 0, len3);\n        pfb.setTrailerSegment(buffer);\n    }\n\n    private void parseRAWFormat(PFBData pfb, BufferedInputStream bin)\n            throws IOException {\n        calcLengths(pfb, IOUtil.toByteArray(bin, 32768));\n    }\n\n}", "id": 36901, "time": "2003-05-08T12:48:44Z", "bug_id": 19764, "creation_time": "2003-05-08T12:48:44Z", "is_private": false}, {"count": 1, "tags": [], "text": "Fixed in CVS (maintenance branch and redesign). Thanks a lot!\n\nA little request: Please submit CVS patches next time as described in [1]. \nThis makes it much easier for us and reduces possible error sources.\n\n[1] http://xml.apache.org/fop/dev/index.html#patches\n\n", "is_private": false, "id": 36912, "creator": "jeremias@apache.org", "time": "2003-05-08T17:30:57Z", "bug_id": 19764, "creation_time": "2003-05-08T17:30:57Z", "attachment_id": null}, {"count": 2, "tags": [], "text": "Thank you for the advice. Next time, i will do it as adviced.", "is_private": false, "id": 36957, "creator": "germannm@post.ch", "time": "2003-05-09T05:52:48Z", "bug_id": 19764, "creation_time": "2003-05-09T05:52:48Z", "attachment_id": null}, {"count": 3, "text": "batch transition pre-FOP1.0 resolved+fixed bugs to closed+fixed", "creator": "gadams@apache.org", "attachment_id": null, "id": 155644, "time": "2012-04-01T06:33:21Z", "bug_id": 19764, "creation_time": "2012-04-01T06:33:21Z", "tags": [], "is_private": false}]