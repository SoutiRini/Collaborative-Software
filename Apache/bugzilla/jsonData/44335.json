[{"count": 0, "tags": [], "creator": "nayan@chikli.com", "is_private": false, "text": "I've run into a strange problem using xmlsec-1.4.1.\n\nI can sign a document - no problem.\n\nI can validate a VALID signature - no problem.\n\nI can detect an INVALID signature - no problem.\n\n\nHowever, once I detect an invalid signature, I validate any further signatures!\n\nI've boiled my code down to a simple case that i've posted at\nhttp://agileshrugged.com/files/soaptester.zip -- It's an eclipse project but\nrunning it outside of eclipse should work if you include all the libraries in\nthe \"lib\" directory on your classpath.\n\nThere is a JUnit test \"SoapUtilTest\" in which testSign() and testValidate()\nwork, but testInvalidThenValid() fails.\n\nI've tried this in JDK 1.4 & 1.6 with no luck.", "id": 113328, "time": "2008-01-31T17:59:04Z", "bug_id": 44335, "creation_time": "2008-01-31T17:59:04Z", "attachment_id": null}, {"count": 1, "tags": [], "bug_id": 44335, "attachment_id": null, "text": "I spent some time debugging this, as it sounded similar to bug reported for our\nproject.  I don't think the two are related, but here is what I learned.\n\nThis bug is happening when an exception is thrown in\nXMLSignature#checkSignatureValue(Key), between the time that\nSignatureAlgorithm#initVerify(Key) is called and\nSignatureAlgorithm#verify(byte[]) is called, obviously resulting in the latter\nnever being called.\n\nBecause the verify operation is not performed, the (thread local) cached\njava.security.Signature instance held in the SignatureAlgorithm instancesVerify\nMap is left in a state (in this particular case) with updated data in the\nbuffer, that is never cleared/reset by a verify operation.\n\nOrdinarily this wouldn't be a problem, because on the next verify op in the same\nthread, the java.security.Signature instance would be reinitialized ultimately\nwith java.security.Signature#initVerify(PublicKey), via a call to\nSignatureAlgorithmSpi.  However, due to the optimization that's being done in\nSignatureAlgorithm#initVerify(Key), if the key used for the next verify op for\nthat algorithm in that thread is the *same* key as the previous (failed)\noperation, it doesn't call the underlying\nSignatureAlgorithmSpi#engineInitVerify(Key).\n\nSo the bug is that this optimization implicitly assumes that the previous op\nwith that key always ran to completion, which is not true in this case.\n\nIn the subsequent verification, the data over which the signature is calculated\nis *added* to whatever data is in the buffer from the previous failed op,\nresulting in a failed verification on an otherwise valid signature.\n\nIn this particular test case, the exception is being thrown here:\n\n         //retrieve the byte[] from the stored signature\n         byte sigBytes[] = this.getSignatureValue(); \n\nbecause the way the invalidly signed test case control document is being\ninvalidated is by modifying the ds:SignatureValue data, but with what is\nsyntactically invalid Base64-encoded data - it's not a multiple of 4 bytes and\nalso has an illegal character.  I suppose it could be argued that this is pretty\nunlikely to happen in the real world, but IMHO it seems the library probably\nought to handle it more gracefully. Especially because I think you could get a\nsimilar bug case if for example the code below that writes the signed data into\nthe SignatureAlgorithm were to throw an exception after having written some data\nto the java.security.Signature buffer.\n\n\n         // Get the canonicalized (normalized) SignedInfo\n         SignerOutputStream so=new SignerOutputStream(sa);\n         OutputStream bos=new UnsyncBufferedOutputStream(so);\n         si.signInOctectStream(bos);\n         try {\n\t\t\tbos.close();\n\t\t} catch (IOException e) {\n\t\t\t//Imposible\n\t\t}\n\n\n\nI don't see a clean fix.  Perhaps ideally the SignatureAlgorithm class would\nexpose a method that could be called from the exception catch block and which\ncaused the cached algorithm -> key mapping in the keysVerify Map to be removed\nor the key reference set to null.  This would ensure that\nSignatureAlgorithmSpi#engineVerifyInit would be called in initVerify(Key) on the\nnext verification, regardless of what the most recently used key was.\n\nAn ugly workaround is to ensure that SignatureAlgorithm#verify(byte[]) is always\ncalled.  For example, this \"fixes\" the problem in this test case by verifying\nsome dummy bytes before rethrowing the exception:\n\n         //retrieve the byte[] from the stored signature\n         byte sigBytes[] = null;\n         try {\n        \t sigBytes = this.getSignatureValue();\n         } catch (XMLSignatureException e) {\n        \t sa.verify(\"dummy-data\".getBytes());\n        \t throw new XMLSignatureException(\"empty\", e);\n         }\n\n\nAlso, I haven't looked at it in detail, but I would think that the signing side\nof things might have a similar bug, since it essentially uses the same\noptimizations in SignatureAlgorithm as to caching java.security.Signature\ninstances and conditional re-initialization of those based on the most recently\nused Key.", "id": 113421, "time": "2008-02-04T16:34:13Z", "creator": "putmanb@georgetown.edu", "creation_time": "2008-02-04T16:34:13Z", "is_private": false}, {"count": 2, "attachment_id": null, "bug_id": 44335, "is_private": false, "id": 113440, "time": "2008-02-05T08:44:30Z", "creator": "nayan@chikli.com", "creation_time": "2008-02-05T08:44:30Z", "tags": [], "text": "thanks for looking into this ... I agree with your assessment that it is\nunlikely to happen in production, and also that the library should handle it\ngracefully.\n\nWould it not be as simple as putting a try/catch around:\n\n           byte sigBytes[] = this.getSignatureValue(); \n\nAnd then resetting the appropriate values if necessary?"}, {"count": 3, "tags": [], "creator": "putmanb@georgetown.edu", "text": "Well, yes, that's basically what I illustrated in my \"ugly workaround\".  But the\nonly way to currently reset the appropriate values is to call verify (on some\nbytes, it doesn't matter what).  That completes the init/update/verify cycle and\nleaves the underlying SignatureAlgorithmSpi (really the wrapped\njava.security.Signature/Mac instance) in a known good state.\n\nRe-invoking initVerify(Key) there wouldn't work because it's the source of the\nproblem in the first place.  You'd have to pass in the current verification key,\nb/c that's all you have - and that would be a noop, b/c of the optimization.\n\nThose are the only 2 methods that I can see which cause the underlying engine's\nstate to be reset.\n\nSo other than calling verify on dummy data (less than ideal...), one obvious\noption is to expose a new method on SignatureAlgorithm, which causes the\nunderlying engine Spi instance to be effectively reset (or recreated?) to a\nknown good state, either prior to or at the time of, the next verification.\n\nAnother option, which just occurred to me, is for the engine Spi instance to\nkeep track of what state it is in with respect to the init/update/verify cycle\n(or init/update/sign).  The SignatureAlgorithm could then check this state and\ndo the right thing if the engine isn't in the \"ready\" state.  This might be more\ndesirable, because it alleviates the caller (XMLSignature) from having to be\nsure to reset the engine for all cases where exceptions might encountered in the\nsign/verify cycles.  This would require augmenting the API of the\nSignatureAlgorithmSpi, however.", "id": 113451, "time": "2008-02-05T13:17:00Z", "bug_id": 44335, "creation_time": "2008-02-05T13:17:00Z", "is_private": false, "attachment_id": null}, {"count": 4, "tags": [], "bug_id": 44335, "text": "Hey,\n\nI just got this bug.\n\nI think there may be a quicker fix:\n\njust move the two lines:\n\n         //retrieve the byte[] from the stored signature\n         byte sigBytes[] = this.getSignatureValue();\n\nbefore the try/catch block:\n\n      try {\n         SignedInfo si=this.getSignedInfo();\n\n\nThis way, if the Base64 decoding fails, the SignatureAlgorithm hasn't yet been updated and does not need to be reset.\n \nThis avoids having to call #verify() just to reset the SignatureAlgorithm.\n\n\n\nThe checkSignatureValue method would look like this:\n\n    public boolean checkSignatureValue(Key pk) throws XMLSignatureException {\n\n        if (pk == null) {\n            Object exArgs[] = { \"Didn't get a key\" };\n\n            throw new XMLSignatureException(\"empty\", exArgs);\n        }\n\n        //retrieve the byte[] from the stored signature\n        // Do this before calling the SignatureAlgorithm\n        // that way if something goes bad, the sa isn't corrupted\n        byte sigBytes[] = this.getSignatureValue();\n\n        try {\n            SignedInfo si=this.getSignedInfo();\n            //create a SignatureAlgorithms from the SignatureMethod inside\n            //SignedInfo. This is used to validate the signature.\n            SignatureAlgorithm sa =si.getSignatureAlgorithm();\n            if (log.isDebugEnabled()) {\n                log.debug(\"SignatureMethodURI = \" + sa.getAlgorithmURI());\n                log.debug(\"jceSigAlgorithm    = \" + sa.getJCEAlgorithmString());\n                log.debug(\"jceSigProvider     = \" + sa.getJCEProviderName());\n                log.debug(\"PublicKey = \" + pk);\n            }\n            sa.initVerify(pk);\n\n            // Get the canonicalized (normalized) SignedInfo\n            SignerOutputStream so=new SignerOutputStream(sa);\n            OutputStream bos=new UnsyncBufferedOutputStream(so);\n            si.signInOctectStream(bos);\n            try {\n                bos.close();\n            } catch (IOException e) {\n                //Imposible\n            }\n\n            if (!sa.verify(sigBytes)) {\n                log.warn(\"Signature verification failed.\");\n                return false;\n            }\n\n            return si.verify(this._followManifestsDuringValidation);\n        } catch (XMLSecurityException ex) {\n            throw new XMLSignatureException(\"empty\", ex);\n        }\n    }", "id": 122972, "time": "2008-12-01T19:38:55Z", "creator": "lauredo@gmail.com", "creation_time": "2008-12-01T19:38:55Z", "is_private": false, "attachment_id": null}, {"count": 5, "tags": [], "bug_id": 44335, "text": "Created attachment 23779\nA patch for this issue\n\n\nSee attached for a patch for this issue.\n\nI added in two new methods to SignatureAction, one to clear the signature caches, and one to clear the verification caches.\n\nThe initializing code in XMLSignature for signing and verification is now wrapped in a try/catch that calls the corresponding cache clearing method in SignatureAction on an error, before throwing the exception. So if there's an error here, the Signature \"state\" is reset before the next attempt and there won't be a problem with a subsequent verification as per the bug.\n\nI've tested it with the submitted test-case and it works fine.\n\nColm.", "id": 127753, "time": "2009-06-09T04:57:56Z", "creator": "coheigea@apache.org", "creation_time": "2009-06-09T04:57:56Z", "is_private": false, "attachment_id": 23779}, {"count": 6, "attachment_id": null, "bug_id": 44335, "is_private": false, "id": 128639, "time": "2009-07-08T07:15:25Z", "creator": "coheigea@apache.org", "creation_time": "2009-07-08T07:15:25Z", "tags": [], "text": "\nPatch applied.\n\nColm."}]