[{"count": 0, "tags": [], "bug_id": 16830, "attachment_id": null, "text": "This may lead to using \"old\" body content, from previous tag usage.\nDetailed description and fix is at url above", "id": 30798, "time": "2003-02-06T09:39:52Z", "creator": "tivv@gtech-ua.com", "creation_time": "2003-02-06T09:39:52Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 16830, "attachment_id": null, "text": "This bug seems to be the cause of many others, like:\n\nhttp://nagoya.apache.org/bugzilla/show_bug.cgi?id=26863\nhttp://nagoya.apache.org/bugzilla/show_bug.cgi?id=26320\n\n\nIf this is not a bug (i.e., if Tomcat is doing what the specification requires),\nthen we should at least explain/confirm that here. Otherwise, it should be fixed\nsoon.", "id": 52196, "time": "2004-02-12T15:40:21Z", "creator": "nagoya@felipeal.net", "creation_time": "2004-02-12T15:40:21Z", "is_private": false}, {"count": 2, "tags": [], "text": "Tag pooling is covered in the FAQ\nhttp://jakarta.apache.org/tomcat/faq/misc.html#tagbroken", "attachment_id": null, "bug_id": 16830, "id": 52197, "time": "2004-02-12T16:00:00Z", "creator": "funkman@joedog.org", "creation_time": "2004-02-12T16:00:00Z", "is_private": false}, {"count": 3, "tags": [], "bug_id": 16830, "attachment_id": null, "text": "That is not the release case!!!.\nThis is about not calling setBodyContent(null) for second tag use.\n", "id": 52198, "time": "2004-02-12T16:03:53Z", "creator": "tivv@gtech-ua.com", "creation_time": "2004-02-12T16:03:53Z", "is_private": false}, {"count": 4, "tags": [], "bug_id": 16830, "attachment_id": null, "text": "*** Bug 24744 has been marked as a duplicate of this bug. ***", "id": 54224, "time": "2004-03-18T15:31:09Z", "creator": "issa.gorissen@axa.be", "creation_time": "2004-03-18T15:31:09Z", "is_private": false}, {"count": 5, "tags": [], "text": "Created attachment 10854\nWeb app built on version 4.1.30 of Tomcat.", "attachment_id": 10854, "bug_id": 16830, "id": 54225, "time": "2004-03-18T15:33:48Z", "creator": "issa.gorissen@axa.be", "creation_time": "2004-03-18T15:33:48Z", "is_private": false}, {"count": 6, "tags": [], "text": "Please deploy & call the JSP found in the root of the context of the posted web\napp above.\n\nThis cleary shows that the bodycontent is not properly resetted between tag's calls.", "is_private": false, "id": 54227, "creator": "issa.gorissen@axa.be", "time": "2004-03-18T15:35:42Z", "bug_id": 16830, "creation_time": "2004-03-18T15:35:42Z", "attachment_id": null}, {"count": 7, "tags": [], "bug_id": 16830, "is_private": false, "text": "If doStartTag() returns SKIP_BODY, then the tag body is not evaluated and\nsetContent() not called; the value of bodyContent is undefined when it is\naccessed at doEndTag in such a case.", "id": 54434, "time": "2004-03-22T23:22:53Z", "creator": "kin-man.chung@sun.com", "creation_time": "2004-03-22T23:22:53Z", "attachment_id": null}, {"count": 8, "tags": [], "text": "We are not talking about a tag where doStartTag() returns SKIP_BODY.  The case \nis about a tag occurring once with and once without body. See bug 24744 which \nwas marked as a duplicate of this.", "is_private": false, "id": 54454, "creator": "bob.news@gmx.net", "time": "2004-03-23T08:05:00Z", "bug_id": 16830, "creation_time": "2004-03-23T08:05:00Z", "attachment_id": null}, {"count": 9, "tags": [], "bug_id": 16830, "attachment_id": null, "text": "Are you kidding us Kin-Man?!? I don't want to start a flame thread here as it\nwould be highly unproductive - but hey, this behaviour is really dumb from\nTomcat! Others containers do handle this case \"correctly\"!\n\nPlease see in the JSP specification (1.2 of course), page 164, the init procotol\ndescribes that *all* properties of a tag must be _initialized_ after doEndTag().\nSee page 174, \"The JSP page implementation will _create_ a BodyContent if the\ndoStartTag() method returns a EVAL_BODY_BUFFERED.\" By opposition, a BodyContent\nobject must *not* be created/available if doStartTag() does not return\nEVAL_BODY_BUFFERED, right?\n\nThus if my understanding is correct, after the init protocol, for a tag that\nreturns SKIP_BODY, the variable bodyContent must be _null_ when we execute the\ndoEndTag(). Actually, this is not the case in Tomcat. And you've got to admit &\ncorrect this.", "id": 54458, "time": "2004-03-23T08:48:24Z", "creator": "issa.gorissen@axa.be", "creation_time": "2004-03-23T08:48:24Z", "is_private": false}, {"count": 10, "tags": [], "text": "Why is this invalid? Please explain.", "attachment_id": null, "bug_id": 16830, "id": 54460, "time": "2004-03-23T09:10:51Z", "creator": "issa.gorissen@axa.be", "creation_time": "2004-03-23T09:10:51Z", "is_private": false}, {"count": 11, "tags": [], "bug_id": 16830, "attachment_id": null, "is_private": false, "id": 54463, "time": "2004-03-23T10:14:57Z", "creator": "tivv@gtech-ua.com", "creation_time": "2004-03-23T10:14:57Z", "text": "OK, If you wish I am copying bug description from he url above that've started\nthat bug. It has nothing to do with SKIP_BODY:\nJasper one problem - if tag implements body tag support and sometimes body is empty\nand sometimes not, then we may have next problem:\na)Tag uses body (bodyContent set)\nb)Tag sent to pool (bodyContent set)\nb)Tag uses empty body (old bodyContent set).\nI've resolved this by setting bodyContent attribute to null before sending tag\nto pool:\nGenerator.java, line 1440:\n            if (ctxt.getOptions().isPoolingEnabled()) {\n                //We must reset body before sending to pool if it was set before\n                if (n.implementsBodyTag() && n.getBody() != null)\n                {\n                    out.printin(tagHandlerVar);\n                    out.println(\".setBodyContent(null);\");\n                }\n                out.printin(n.getTagHandlerPoolName());\n                out.print(\".reuse(\");\n                out.print(tagHandlerVar);\n                out.println(\");\");\n            }"}, {"count": 12, "tags": [], "bug_id": 16830, "is_private": false, "text": "Please try the custom tag previously attached with this JSP:\n\n<%@ taglib uri=\"/myTag\" prefix=\"tag\" %>\n\n<html>\n<head></head>\n<body>\n<tag:myBody content=\"true\">\n\t<b>this is inside myBody tag</b>\n</tag:myBody>\n<p>\n<tag:myBody content=\"true\" />\n<p>\n<tag:myBody>\n\t<b>this is inside myBody tag</b>\n</tag:myBody>\n</body>\n</html>\n\nAnd then please explain us why the 2nd *empty* tag does print the body of the\n1st tag! (as described in bug 24744)", "id": 54466, "time": "2004-03-23T11:09:37Z", "creator": "issa.gorissen@axa.be", "creation_time": "2004-03-23T11:09:37Z", "attachment_id": null}, {"count": 13, "tags": [], "bug_id": 16830, "attachment_id": null, "text": "Adding myself to the CC list.", "id": 54468, "time": "2004-03-23T12:35:45Z", "creator": "nagoya@felipeal.net", "creation_time": "2004-03-23T12:35:45Z", "is_private": false}, {"count": 14, "attachment_id": null, "creator": "remm@apache.org", "text": "Sorry, this was invalid instead.", "id": 54470, "time": "2004-03-23T13:23:53Z", "bug_id": 16830, "creation_time": "2004-03-23T13:23:53Z", "tags": [], "is_private": false}, {"count": 15, "tags": [], "text": "Hm...  From what Vit wrote I rather assume it is \"resolved fixed\" instead \nof \"resolved invalid\".  Or did I miss something?  Remy, care to explain why you \nset it to \"invalid\"?", "is_private": false, "id": 54488, "creator": "bob.news@gmx.net", "time": "2004-03-23T16:49:27Z", "bug_id": 16830, "creation_time": "2004-03-23T16:49:27Z", "attachment_id": null}, {"count": 16, "tags": [], "text": "OK, let's quote some specs first.  :-)\n\nJSP 1.2 spec, p 177 (JSP.10.2 BodyTag) Under \"Properties\":\n\n    \"The setter method (setBodyContent) will only be invoked if\n    doStartTag( ) returns EVAL_BODY_BUFFERED.\"\n\nSo it is obvious that if doStartTag returns SKIP_BODY, setBodyContent will not\nbe called.  But that was what I said before.\n\nJSP 2.0 spec further tightens the condition (JSP.13.22 p 2-67):\n\n    \"The setter method (setBodyContent) will only be invoked if\n    doStartTag() returns EVAL_BODY_BUFFERED and the corresponding\n    action element does not have an empty body.\"\n\nso setBodyContent will not be called if the body is empty also.\n\nSo technically, the patch suggested by Vit Timchishin actually violates the\nspec, because setBodyContent will be called in places where it shouldn't.  I\nwon't be surprised if the patch breaks some TCK tests.\n\nBut does it make sense, you all ask?  Personally, I think it should be allowed\nto reset the bodyContent to null in such cases, and it is an oversight in the\nspec to not consider the interaction with tag pooling in this corner case.\n\nI'll check with the JSP spec leads on this.  Unless I can find a fix that does\nnot break the spec, this bug will remain INVALID.", "attachment_id": null, "bug_id": 16830, "id": 54507, "time": "2004-03-23T20:48:36Z", "creator": "kin-man.chung@sun.com", "creation_time": "2004-03-23T20:48:36Z", "is_private": false}, {"count": 17, "tags": [], "bug_id": 16830, "attachment_id": null, "is_private": false, "id": 54541, "time": "2004-03-24T08:23:56Z", "creator": "issa.gorissen@axa.be", "creation_time": "2004-03-24T08:23:56Z", "text": "Thx Kin-Man! Your comments are greatly appreciated.\n\nAnyway, you're right that the spec does not explicitly tell what should the \ncontainer do and what the tag developer must expect from the container when tag \npooling is in place. Isn't it better to push the JSP leads to clarify this, \ninstead of making assumptions for implicit mechanism?\n\nAnd the spec is rather thin on the explanation of the INIT PROTOCOL (what are \nthose AttSet? What the container must do after doEndTag?).\n\nBTW, is there any really good explanation of the life cycle of a BodyTag with a \ntag pooling container on the Net somewhere?\n\nI guess a backdoor for tag developers is to use the TryCatchFinally \nfonctionnality to reset the bodycontent, right?"}, {"count": 18, "tags": [], "bug_id": 16830, "attachment_id": null, "is_private": false, "id": 54542, "time": "2004-03-24T08:44:39Z", "creator": "bob.news@gmx.net", "creation_time": "2004-03-24T08:44:39Z", "text": "Thanks for the lengthy explanation!\n\nUnfortunately there is some degree of freedom as to the correct interpretation \nof the spec.  If you consider the spec in absence of tag pooling then it is \nclear, that the body content of a tag that has no body remains unchanged.  \nTypically this will be 'null' since tag implementors usually won't initialize \nthis to something else (they would have to implement BodyContent for this sole \npurpose).\n\nNow, tag pooling is supposed to *not* change the semantics of a JSP.  In this \ncase not invoking setBodyContent(null) would better meet this requirement than \nnot doing it.\n\nThe only solution I can see that is both conformant to the spec and working \nwould be to request of each tag implementor that he/she resets bodyContent \nto 'null' in doEndTag().  I am just not sure whether that is possible/desired \nin all situations.  Maybe there are cases where one wants access to the body \ncontent even after doEndTag() - maybe for the doEndTag() method of an enclosing \ntag.\n\nWe'll probably need another life cycle event in interface Tag that is invoked \nwhen an instance returns to a pool. (release() is invoked when the tag is \ncompletely discarded).  That would be the best solution IMHO.\n\nThanks for listening!"}, {"count": 19, "tags": [], "text": "1) We are NOT talking about SKIP_BODY. Here are example:\n---\n<p><c:out value=\"${null}\">Default</c:out>\n<p><c:out value=\"${null}\"></c:out>\n---\nOutput:\n---\n<p>Default\n<p>Default\n---\nShould be:\n---\n<p>Default\n<p>\n---\nc:out in both cases returns EVAL_BODY_BUFFERED and according to Kin in 1.2 case\nsetBodyContent MUST be called:\n----\nJSP 1.2 spec, p 177 (JSP.10.2 BodyTag) Under \"Properties\":\n\n    \"The setter method (setBodyContent) will only be invoked if\n    doStartTag( ) returns EVAL_BODY_BUFFERED.\"\n---\nAccording to JSP 2.0 it should not be called, so we have a collision.\nEven more, according to JSP 2.0 JSP.13.2.3.3 Methods of BodyTagSupport\npublic BodyContent getBodyContent()\n Get current bodyContent.\n Returns: the body content.\nIt must work OK in all cases, while it's not and even can't because it has no\nmeans to reset it's bodyContent (we are not required to call super.doStartTag())\nif working according to JSP 2.0 specs. It does not say that return is undefined\nif tag is empty (remember, we are not talking about SKIP_BODY).\nMy proposal that I think will make everything OK is another patch that will send\ntags with equal attributes but ones using and ones not using body to two\ndifferent pools. Actually this was my first thought, but this would require more\ndeep knowledge of Jasper code I do not have (yet, with all this bugs :( ).\nI suppose this will fix the problem and won't violate any specs (but JSP 1.2\nthat still require for setBodyContent to be called if tag returned\nEVAL_BODY_BUFFERED no matter if body was empty or not). ", "attachment_id": null, "bug_id": 16830, "id": 54554, "time": "2004-03-24T10:15:37Z", "creator": "tivv@gtech-ua.com", "creation_time": "2004-03-24T10:15:37Z", "is_private": false}, {"count": 20, "tags": [], "bug_id": 16830, "attachment_id": null, "text": "Regarding <c:out>, we fixed this problem by setting bodyContent=null at\ndoStartTag() - see bug 26320\n\n", "id": 54564, "time": "2004-03-24T12:15:49Z", "creator": "nagoya@felipeal.net", "creation_time": "2004-03-24T12:15:49Z", "is_private": false}, {"count": 21, "tags": [], "bug_id": 16830, "attachment_id": null, "text": "BTW, issuing an extra setBodyContent to reset the bodyContent did break a TCK\ntest, so it violates the current JSP 2.0 spec.  Haven't run JSP 1.2 TCK tests\nyet, but I'll hate to have Tomcat 5 behaves differently from Tomcat 4.  In any\ncase, JSP 2.0 is supposed to clarify or fix problems in JSP 1.2, so if there are\ndisagreements, we should go with JSP 2.0: you don't want to have to face the\nsame problems again when porting to Tomcat 5 later!\n\nI did consult with Mark Roth, our resident JSP lead, and he suggested that\nJasper NOT reuse the tag if the first tag has a body and second does not.  I\nthink this makes lots of sense and I'll fix Jasper to to so.  Stay tuned.  :)", "id": 54585, "time": "2004-03-24T18:38:16Z", "creator": "kin-man.chung@sun.com", "creation_time": "2004-03-24T18:38:16Z", "is_private": false}, {"count": 22, "tags": [], "bug_id": 16830, "attachment_id": null, "is_private": false, "id": 54605, "time": "2004-03-24T21:49:00Z", "creator": "kin-man.chung@sun.com", "creation_time": "2004-03-24T21:49:00Z", "text": "I have fixed Jasper (both Tomcat 4 and 5) to not reuse tags in this case.  It\nshould be in the next release.\n\nSo for\n\n<tag:myBody content=\"true\">\n    this is inside myBody tag\n</tagmyBody>\n<tag:myBody content=\"true\" />\n<tag:myBody content=\"false\">\n    this is inside myBody tag\n</tag:myBody>\n\nthe second tag would now has a null bodyContent, since it is not reusing the tag\ninstance from the first, but the 3rd tag would reuse the tag instance from the\nfirst, and the bodyContent would not be reset, because doStartTag returns a\nSKIP_BODY.  I consider it an user error to try getting its bodyContent when\ndoStartTag returns a SKIP_BODY.\n\nThis is the best I can do to fix this problem and still be spec-conformant.\n"}, {"count": 23, "tags": [], "bug_id": 16830, "attachment_id": null, "text": "Great!  Sounds like the best solution.", "id": 54645, "time": "2004-03-25T08:46:10Z", "creator": "bob.news@gmx.net", "creation_time": "2004-03-25T08:46:10Z", "is_private": false}, {"count": 24, "tags": [], "text": "A mail from Mark Roth is included here for documentation.\n\n--------------\nHi Issa,\n\nThanks for your follow-up question.\n\nI'd like to take a moment to acknowledge and say that it's unfortunate \nwe ever had the reuse protocol to begin with.  It has caused nothing but \nproblems and every release of the spec we end up clarifying it one way \nor another.  Containers implement it differently, and it is the primary \nsource of incompatibilities between JSP containers.  It's very hard to \ntest because it's so complex.  In addition, we did some rough \nperformance guages and it does not seem to improve performance in any \nconsiderable way, at least with modern VMs.  This is why we went with no \nreuse mechanism for the SimpleTag API in JSP 2.0.\n\nissa.gorissen@axa.be wrote:\n> Indeed, I am in the thread on a Tomcat bug!\n> \n> Anyway, you did not fully answer my 1st question. If I can request a \n> little bit more of your time... ;)\n> \n> You can find the comment of Kin-Man below. In the example given by him, \n> the 3rd tag invocation will reuse the tag on the 1st invocation. For \n> that 3rd tag, doStartTag will return SKIP_BODY. Thus, in the doEndTag, \n> Kin-Man suggests it is an error to try using the bodycontent. My \n> question is, in this particular case, how can doEndTag know the return \n> value of doStartTag?\n\nSorry for missing this aspect of your question.  You raise a good point. \n  I read the spec in more detail and found the following relevant sections:\n\n-----\nJSP.13.2\n\nThe JSP page implementation will create a BodyContent if the \ndoStartTag() method returns a EVAL_BODY_BUFFERED. This object will be \npassed to doInitBody(); then the body of the tag will be evaluated, and \nduring that evaluation out will be bound to the BodyContent just passed \nto the BodyTag handler. Then doAfterBody() will be evaluated. If that \nmethod returns SKIP_BODY, no more evaluations of the body will be done; \nif the method returns EVAL_BODY_AGAIN, then the body will be evaluated, \nand doAfterBody() will be invoked again.\n\nThe content of a BodyContent instance remains available until after the \ninvocation of its associated doEndTag() method.\n\n...\n\nA BodyContent is made available to a BodyTag through a setBodyContent() \ncall. The tag handler can use the object until after the call to doEndTag().\n-----\n\nThe above makes it very clear that after the doEndTag() method is \ncalled, the tag handler is not to access the BodyContent.  The \nBodyContent is not available again until the next time doStartTag() \nmethod returns EVAL_BODY_BUFFERED.  A tag that tries to access the \nBodyContent at any other time will get undefined behavior.\n\nWe could have required the container to throw an exception if you access \nBodyContent at an unreasonable time, but this would degrade performance.\n\nNote that the third case is different than the second case.  The second \ncase required a change to Tomcat because even if the tag returns \nEVAL_BODY_BUFFERED, the rules in the specification specfically state \nthat setBodyContent() is not called if the tag has no body.  So to keep \nTomcat in compliance with the spec, we needed to make sure the tag \ninstance was not reused.  This is not necessary in the third case \nbecause a tag that abides by the rules in the specification will never \nencounter any problems.\n\n> Is it the responsibility of the tag programmer to keep the return value \n> of doStartTag?\n\nIt is the responsibility of the tag developer to ensure that BodyContent \nis not accessed when it is not avaialble.  For some tags, you may need \nto keep track of whether you indicated to evaluate the body buffered. \nIn this particular tag handler, you could either keep track of the \nreturn value, or look at the value of the 'content' attribute.\n\n> Should the tag programmer reset the bodycontent himself whenever \n> appropriate?\n\nNo.  setBodyContent() is never to be called by tag handlers directly - \nit is a method that the container invokes.\n\n> Is there a document available that *explicitly* explain the INIT \n> protocol and the status of the parameters (including bodycontent) of a \n> tag during its whole life time (with several reuse, several \n> required/non-required parameters)?\n\nThere are other rules scattered throughout the spec, but section \nJSP.13.2 and JSP.13.2.2, page 2-70 outline the protocol in detail, with \ndiagrams.\n\n> Several J2EE 1.3 certified JSP containers do handle custom tags \n> differently, how come they have been certified? For instance, WebLogic \n> does handle this kind of tags differently than Tomcat.\n\nIt's quite easy to write a tag that relies on behavior that is undefined \nin the spec, so even if all containers were spec compliant, there may \nstill be differences in behavior in the areas not defined by the spec.\n\nThe TCK is developed by identifying the many hundreds of assertions in \nthe specification and API javadocs.  Based on these assertions, the test \nwriters prioritize and write as many tests as they can.  We do not have \n100% coverage of all assertions due to resource constraints.  I believe \nwe have a fairly high coverage rate in this area because it's such a \npotential point of incompatibility.\n\nThe source of incompatibility in this area is not due to the lack of \ntests in the TCK but rather the unfortunate inherent complexity of the \ntag reuse protocol.  Most tag library developers (even experienced ones) \ndo not fully understand the tag reuse protocol and it's easy to make a \nnaive mistake.  In fact, I assure you even I've fallen victim to this in \ntag handlers I've written.\n\nWe used this as a justification to create a new tag handler protocol in \nJSP 2.0 called SimpleTag.  SimpleTag tag handlers are never reused by \nthe container and have a simple method doTag() instead of the complex \ndoStartTag(), doAfterBody(), doEndTag(), etc. lifecycle.\n\nI hope this helps!\n\n---\nMark Roth, Java Software\nJSP 2.0 Specification Lead\nSun Microsystems, Inc.\n\nHi Issa,\n\nThanks for your follow-up question.\n\nI'd like to take a moment to acknowledge and say that it's unfortunate \nwe ever had the reuse protocol to begin with.  It has caused nothing but \nproblems and every release of the spec we end up clarifying it one way \nor another.  Containers implement it differently, and it is the primary \nsource of incompatibilities between JSP containers.  It's very hard to \ntest because it's so complex.  In addition, we did some rough \nperformance guages and it does not seem to improve performance in any \nconsiderable way, at least with modern VMs.  This is why we went with no \nreuse mechanism for the SimpleTag API in JSP 2.0.\n\nissa.gorissen@axa.be wrote:\n> Indeed, I am in the thread on a Tomcat bug!\n> \n> Anyway, you did not fully answer my 1st question. If I can request a \n> little bit more of your time... ;)\n> \n> You can find the comment of Kin-Man below. In the example given by him, \n> the 3rd tag invocation will reuse the tag on the 1st invocation. For \n> that 3rd tag, doStartTag will return SKIP_BODY. Thus, in the doEndTag, \n> Kin-Man suggests it is an error to try using the bodycontent. My \n> question is, in this particular case, how can doEndTag know the return \n> value of doStartTag?\n\nSorry for missing this aspect of your question.  You raise a good point. \n  I read the spec in more detail and found the following relevant sections:\n\n-----\nJSP.13.2\n\nThe JSP page implementation will create a BodyContent if the \ndoStartTag() method returns a EVAL_BODY_BUFFERED. This object will be \npassed to doInitBody(); then the body of the tag will be evaluated, and \nduring that evaluation out will be bound to the BodyContent just passed \nto the BodyTag handler. Then doAfterBody() will be evaluated. If that \nmethod returns SKIP_BODY, no more evaluations of the body will be done; \nif the method returns EVAL_BODY_AGAIN, then the body will be evaluated, \nand doAfterBody() will be invoked again.\n\nThe content of a BodyContent instance remains available until after the \ninvocation of its associated doEndTag() method.\n\n...\n\nA BodyContent is made available to a BodyTag through a setBodyContent() \ncall. The tag handler can use the object until after the call to doEndTag().\n-----\n\nThe above makes it very clear that after the doEndTag() method is \ncalled, the tag handler is not to access the BodyContent.  The \nBodyContent is not available again until the next time doStartTag() \nmethod returns EVAL_BODY_BUFFERED.  A tag that tries to access the \nBodyContent at any other time will get undefined behavior.\n\nWe could have required the container to throw an exception if you access \nBodyContent at an unreasonable time, but this would degrade performance.\n\nNote that the third case is different than the second case.  The second \ncase required a change to Tomcat because even if the tag returns \nEVAL_BODY_BUFFERED, the rules in the specification specfically state \nthat setBodyContent() is not called if the tag has no body.  So to keep \nTomcat in compliance with the spec, we needed to make sure the tag \ninstance was not reused.  This is not necessary in the third case \nbecause a tag that abides by the rules in the specification will never \nencounter any problems.\n\n> Is it the responsibility of the tag programmer to keep the return value \n> of doStartTag?\n\nIt is the responsibility of the tag developer to ensure that BodyContent \nis not accessed when it is not avaialble.  For some tags, you may need \nto keep track of whether you indicated to evaluate the body buffered. \nIn this particular tag handler, you could either keep track of the \nreturn value, or look at the value of the 'content' attribute.\n\n> Should the tag programmer reset the bodycontent himself whenever \n> appropriate?\n\nNo.  setBodyContent() is never to be called by tag handlers directly - \nit is a method that the container invokes.\n\n> Is there a document available that *explicitly* explain the INIT \n> protocol and the status of the parameters (including bodycontent) of a \n> tag during its whole life time (with several reuse, several \n> required/non-required parameters)?\n\nThere are other rules scattered throughout the spec, but section \nJSP.13.2 and JSP.13.2.2, page 2-70 outline the protocol in detail, with \ndiagrams.\n\n> Several J2EE 1.3 certified JSP containers do handle custom tags \n> differently, how come they have been certified? For instance, WebLogic \n> does handle this kind of tags differently than Tomcat.\n\nIt's quite easy to write a tag that relies on behavior that is undefined \nin the spec, so even if all containers were spec compliant, there may \nstill be differences in behavior in the areas not defined by the spec.\n\nThe TCK is developed by identifying the many hundreds of assertions in \nthe specification and API javadocs.  Based on these assertions, the test \nwriters prioritize and write as many tests as they can.  We do not have \n100% coverage of all assertions due to resource constraints.  I believe \nwe have a fairly high coverage rate in this area because it's such a \npotential point of incompatibility.\n\nThe source of incompatibility in this area is not due to the lack of \ntests in the TCK but rather the unfortunate inherent complexity of the \ntag reuse protocol.  Most tag library developers (even experienced ones) \ndo not fully understand the tag reuse protocol and it's easy to make a \nnaive mistake.  In fact, I assure you even I've fallen victim to this in \ntag handlers I've written.\n\nWe used this as a justification to create a new tag handler protocol in \nJSP 2.0 called SimpleTag.  SimpleTag tag handlers are never reused by \nthe container and have a simple method doTag() instead of the complex \ndoStartTag(), doAfterBody(), doEndTag(), etc. lifecycle.\n\nI hope this helps!\n\n---\nMark Roth, Java Software\nJSP 2.0 Specification Lead\nSun Microsystems, Inc.", "attachment_id": null, "bug_id": 16830, "id": 54839, "time": "2004-03-29T21:32:49Z", "creator": "kin-man.chung@sun.com", "creation_time": "2004-03-29T21:32:49Z", "is_private": false}]