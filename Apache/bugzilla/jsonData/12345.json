[{"count": 0, "tags": [], "bug_id": 12345, "attachment_id": null, "is_private": false, "id": 22333, "time": "2002-09-05T20:46:21Z", "creator": "elvira_gurevich@ibi.com", "creation_time": "2002-09-05T20:46:21Z", "text": "using last night's build \nreading an xls file, row.getLastCellNum() returns one over.\n\nFor example, if there is only one cell, the first will be 0, and the last will \nbe 1, which makes 2 alltogether. If it is by design, it should be documented. \n\nwith this particular xls file (attached), it also reads non-existent rows.\nCode follows:\n\n\t public static final void main(String[] args)\n\t {\n\t\t  if(args==null || args.length==0)\n\t\t  {\n\t\t\t\tSystem.out.println(\"enter name of excel file\");\n\t\t\t\treturn;\n\t\t  }\n\n\t\t  String filename = args[0];\n\t\t  try\n\t\t  {\n\t\t\t\tHSSFWorkbook w = new HSSFWorkbook(new \nFileInputStream(filename));\n\t\t\t\tfor (int sheet = 0; sheet < w.getNumberOfSheets\n(); sheet++)\n\t\t\t\t{\n\t\t\t\t\t String sheetName;\n\t\t\t\t\t HSSFSheet s = w.getSheetAt(sheet); // \nget the sheet from the workbook\n\t\t\t\t\t sheetName = w.getSheetName(sheet);\t\n\t// get the name of the sheet\n\t\t\t\t\t int firstRowNumber= s.getFirstRowNum();\n\t\t\t\t\t int lastRowNumber= s.getLastRowNum();\n\t\t\t\t\t int rowCount = \ns.getPhysicalNumberOfRows();\n\t\t\t\t\t System.out.println\n(\"sheet \"+sheetName+\" first row \"+ firstRowNumber+\", last row \"+ \nlastRowNumber); \n\t\t\t\t\t System.out.println\n(\"sheet \"+sheetName+\" has \"+ rowCount+\" rows\"); \n\t\t\t\t\t if (rowCount==0)\n\t\t\t\t\t {\n\t\t\t\t\t\t  continue;\n\t\t\t\t\t }\n\n\t\t\t\t\t for (int row=firstRowNumber; \nrow<=lastRowNumber; row++)\n\t\t\t\t\t {\n\t\t\t\t\t\t  HSSFRow r = s.getRow(row);\n\t\t\t\t\t\t  if (r==null)\t  // if there \nis nothing in a row, it comes back as null\n\t\t\t\t\t\t  {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t  }\n\n\t\t\t\t\t\t  HSSFCell c = null;\n\t\t\t\t\t\t  int firstCellNumber= \nr.getFirstCellNum();\n\t\t\t\t\t\t  int lastCellNumber= \nr.getLastCellNum();\n\t\t\t\t\t\t  int colCount= lastCellNumber -\n firstCellNumber+1;\n\t\t\t\t\t\t  System.out.println\n(\"row \"+row+\": first cell number: \"+firstCellNumber+\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\", lastCellNumber: \"+lastCellNumber +\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\", column count: \"+colCount);\n\n\t\t\t\t\t\t  String namesArray[] = new \nString[colCount];\n\t\t\t\t\t\t  for (int \ncell=firstCellNumber; cell<=lastCellNumber; cell++)\n\t\t\t\t\t\t  {\n\t\t\t\t\t\t\t\n\t//System.out.println(\"row  \"+row+\", cell \"+cell); \n\t\t\t\t\t\t\t\tString \ncellValue = null;\n\t\t\t\t\t\t\t\tint nameIndex = \nlastCellNumber-cell;\n\t\t\t\t\t\t\t\tnamesArray\n[nameIndex] = makeName(cell);\n\t\t\t\t\t\t\t\tString cTitle = \nnamesArray[nameIndex];\n\t\t\t\t\t\t\t\tc = r.getCell\n((short)cell);\n\t\t\t\t\t\t\t\tif (c!=null)\n\t // if there is nothing in a cell, it comes back as null\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t //trace\n(XDState.DEBUG,\"Excel Preparser: row  \"+row+\", \ncell \"+cell+\": \"+c+\",type \"+c.getCellType()); \n\t\t\t\t\t\t\t\t\t switch \n(c.getCellType())\n\t\t\t\t\t\t\t\t\t {\n\t\t\t\t\t\t\t\t\t case\n(HSSFCell.CELL_TYPE_NUMERIC):\n\t\t\t\t\t\t\t\t\t\n\t  {\n\t\t\t\t\t\t\t\t\t\t\n\t\tdouble d = c.getNumericCellValue();\n\t\t\t\t\t\t\t\t\t\t\n\t\tDecimalFormat formatter = new DecimalFormat();  // default \nrounds to 3 decimal digits\n\t\t\t\t\t\t\t\t\t\t\n\t\tcellValue = formatter.format(d);\n\t\t\t\t\t\t\t\t\t\t\n\t\tbreak;\n\t\t\t\t\t\t\t\t\t\n\t  }\n\t\t\t\t\t\t\t\t\t case\n(HSSFCell.CELL_TYPE_BOOLEAN):\n\t\t\t\t\t\t\t\t\t\n\t  {\n\t\t\t\t\t\t\t\t\t\t\n\t\tcellValue = new Boolean(c.getBooleanCellValue()).toString();\n\t\t\t\t\t\t\t\t\t\t\n\t\tbreak;\n\t\t\t\t\t\t\t\t\t\n\t  }\n\t\t\t\t\t\t\t\t\t case\n(HSSFCell.CELL_TYPE_STRING):\n\t\t\t\t\t\t\t\t\t\n\t  {\n\t\t\t\t\t\t\t\t\t\t\n\t\tcellValue = c.getStringCellValue();\n\t\t\t\t\t\t\t\t\t\t\n\t\tbreak;\n\t\t\t\t\t\t\t\t\t\n\t  }\n\t\t\t\t\t\t\t\t\t case\n(HSSFCell.CELL_TYPE_FORMULA):\n\t\t\t\t\t\t\t\t\t\n\t  {\n\t\t\t\t\t\t\t\t\t\t\n\t\tdouble d = c.getNumericCellValue();\n\t\t\t\t\t\t\t\t\t\t\n\t\tDecimalFormat formatter = new DecimalFormat();  // default \nrounds to 3 decimal digits\n\t\t\t\t\t\t\t\t\t\t\n\t\tcellValue = formatter.format(d);\n\t\t\t\t\t\t\t\t\t\t\n\t\tbreak;\n\t\t\t\t\t\t\t\t\t\n\t  }\n\t\t\t\t\t\t\t\t\t case\n(HSSFCell.CELL_TYPE_ERROR):\n\t\t\t\t\t\t\t\t\t\n\t  {\n\t\t\t\t\t\t\t\t\t\t\n\t\tcellValue = Byte.toString(c.getErrorCellValue());\n\t\t\t\t\t\t\t\t\t\t\n\t\tbreak;\n\t\t\t\t\t\t\t\t\t\n\t  }\n\t\t\t\t\t\t\t\t\t case\n(HSSFCell.CELL_TYPE_BLANK):\n\t\t\t\t\t\t\t\t\t\n\t  {\n\t\t\t\t\t\t\t\t\t\t\n\t\tcellValue = c.getStringCellValue();\n\t\t\t\t\t\t\t\t\t\t\n\t\tbreak;\n\t\t\t\t\t\t\t\t\t\n\t  }\n\t\t\t\t\t\t\t\t\t \ndefault:\n\t\t\t\t\t\t\t\t\t\n\t  {\n\t\t\t\t\t\t\t\t\t\t\n\t\tcellValue = \"Unknown cell type:\"+c.getCellType();\n\t\t\t\t\t\t\t\t\t\n\t  }\n\t\t\t\t\t\t\t\t\t }\n\n\t\t\t\t\t\t\t\t\t \nSystem.out.println(\"cell at row \"+row+\", col \"+cell+\", value \"+cellValue);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t  }\n\t\t\t\t\t }\n\t\t\t\t}\n\t\t  }\n\t\t  catch(Exception e)\n\t\t  {\n\t\t\t\tSystem.out.println(e+\"; \"+e.getMessage());\n\t\t\t\te.printStackTrace();\n\t\t  }\n\t }\n\nThanks,"}, {"count": 1, "tags": [], "creator": "elvira_gurevich@ibi.com", "attachment_id": 2945, "is_private": false, "id": 22334, "time": "2002-09-05T20:47:36Z", "bug_id": 12345, "creation_time": "2002-09-05T20:47:36Z", "text": "Created attachment 2945\nexcel file"}, {"count": 2, "tags": [], "bug_id": 12345, "attachment_id": null, "text": "cool can you also attach the code?  ", "id": 22344, "time": "2002-09-06T01:04:37Z", "creator": "poi-support@buni.org", "creation_time": "2002-09-06T01:04:37Z", "is_private": false}, {"count": 3, "tags": [], "bug_id": 12345, "attachment_id": null, "id": 22347, "time": "2002-09-06T01:20:07Z", "creator": "poi-support@buni.org", "creation_time": "2002-09-06T01:20:07Z", "is_private": false, "text": "Wow this was a good documentation catch.  I looked through and was baffled at\nfirst.  As it turns out this is the intended behavior, but we should consider\nchanging it.  I had to look it up in my well worn copy of the \"Microsoft Excel\nDeveloper's Kit\" on page 303 with some scribbling of mine in the margins.\n\nWhy is it like this?  Well originally these values were provided from the\nDimensionsRecord which has two fields that use \"microsoft math\" (off by one like\ntheir buffer checking in the C# JIT ;-)) meaning they are one greater than what\nthey should be.\n\nAs it stands now it looks like we are calculating this field.  It would be good\nif you could raise this on the dev list (I'll provide the reference and history\nif they miss this).  \n\nBasically: should we just document this or is it worth breaking some backward\ncompatibility (in a fairly non obvious way) to make this more intuitive.  I'm\nnot sure.  I'm open to the thoughts of the developers and users.  This is a\nfairly minor issue but probably a pretty irritating usability one."}, {"count": 4, "tags": [], "bug_id": 12345, "attachment_id": 2952, "id": 22361, "time": "2002-09-06T14:05:31Z", "creator": "elvira_gurevich@ibi.com", "creation_time": "2002-09-06T14:05:31Z", "is_private": false, "text": "Created attachment 2952\ntest case for excel file previously attached. picks up cells at rows 9,10,11"}, {"count": 5, "tags": [], "bug_id": 12345, "text": "IS ANYBODY WORKING ON THIS?\nI understand that the doc has to change for row.getLastCellNum() to indicate \nthat the number returned is the index of the NEXT UNUSED cell.\n\nThe second part of this problem report, however, seems to have escaped \neverybody's attention, and that is: for the attached excel file, extra (empty, \nunused) rows are detected.\n\nThank you.\n ", "id": 23118, "time": "2002-09-19T20:00:46Z", "creator": "elvira_gurevich@ibi.com", "creation_time": "2002-09-19T20:00:46Z", "is_private": false, "attachment_id": null}, {"count": 6, "tags": [], "creator": "poi-support@buni.org", "attachment_id": null, "is_private": false, "id": 23132, "time": "2002-09-20T01:07:01Z", "bug_id": 12345, "creation_time": "2002-09-20T01:07:01Z", "text": "Patience!  This is a project of volunteers and consultants like me who give\npaying customers first crack (mortgage to pay and mouths to feed).\n\nAnyhow this part isn't a bug:\n\nrecordid = 0x203, size =14\n[NUMBER]\n    .row            = 8\n    .col            = 3\n    .xfindex        = 19\n    .value          = 0.6666666666666666\n[/NUMBER]\n\n============================================\nOffset 0xef6 (3830)\nrecordid = 0x201, size =6\n[BLANK]\nrow       = 9\ncol       = 2\nxf        = 18\n[/BLANK]\n\n============================================\nOffset 0xf00 (3840)\nrecordid = 0x201, size =6\n[BLANK]\nrow       = a\ncol       = 2\nxf        = 18\n[/BLANK]\n\n============================================\nOffset 0xf0a (3850)\nrecordid = 0x201, size =6\n[BLANK]\nrow       = b\ncol       = 2\nxf        = 18\n[/BLANK]\n\n\nSee those?  They're cells.  You perceve them to be blank in the GUI but \"BLANK\"\nis a *real* cell with a *real* row.  BLANKS sometimes have styles attached to\nthem that look different than the surrounding style (for instance a cell with a\nborder but no value).\n\nTo see what I mean do java org.apache.poi.hssf.dev.BiffViewer myfile.xls\n\nIt will dump at text representation of the binary structure to sysout.  You\nmight want to redirect the output to a file.\n\nhope that helps."}, {"count": 7, "tags": [], "bug_id": 12345, "text": "thanks,\ni understand about blank cells, i get the same results when i use hssf to read \nthese cells, however,\nwhen i open the file in excel, these cells don't look any different to me than \nother ones which are really empty(unused). i cannot detect any styles attached \nto them or anything. in fact, when the excel file was created, there was \nnothing done to those cells. could it be related to the ungodly format of the \ncorresponding cells in the preceeding row? unfortunately, i am not familiar \nwith the record format, what is xf in your dump? \nmy problem (or my qa's problem) is that as far as common knowledge, there is \nNOTHING in these cells, but when read with HSSF, they show blank data.", "id": 23167, "time": "2002-09-20T20:20:05Z", "creator": "elvira_gurevich@ibi.com", "creation_time": "2002-09-20T20:20:05Z", "is_private": false, "attachment_id": null}, {"count": 8, "tags": [], "creator": "poi-support@buni.org", "attachment_id": null, "text": "Right so you're saying the correct behavior is to ignore the ones you can't see\nvisibly in Excel?  Why excel created these?  Who knows.  However they are there\nand HSSF shows you what is really in the file NOT what you see in Excel.  My\nsuggestion is to create a utility function that ignores rows with only blank\ncells and wrap HSSF.  Regardless its not a bug in HSSF to report these rows with\nblank cells.  That is the correct behavior.    \n\nHSSF goal is to abstract you from the nasty details of the file format as much\nas possible while giving you access to all the data.  However its also intent to\nmatch the ACTUAL structure and not the perceived structure of the file. \nSometimes the two differ.", "id": 23180, "time": "2002-09-21T03:01:40Z", "bug_id": 12345, "creation_time": "2002-09-21T03:01:40Z", "is_private": false}]