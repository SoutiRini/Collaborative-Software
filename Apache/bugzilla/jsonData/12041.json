[{"count": 0, "tags": [], "bug_id": 12041, "attachment_id": null, "text": "I've got some legacy Perl CGI scripts which I wanted to run under Tomcat 4.1.x. \nAfter some debugging I discovered that the CGIServlet code would first try to\nread all the stderr input before trying to read stdout.\n\nThis doesn't work on at least Solaris 7 under JDK 1.3, because the stderr handle\ndoesn't seem to get closed, so the code hangs trying to read stderr.\n\nHowever, this approach seems like it would have problems in the case of a CGI\nscript which prints a large amount of data to stdout; while the CGIServlet was\nwaiting for the end of stderr, the CGI script would fill up the stdout buffer\nand then wait for it to be drained, causing a deadlock between the two\nprocesses.\n\nThe patch below seems to get around this problem by having a single loop which\nreads stderr if it's ready, or stdout if ready.  If neither handle has queued\ndata and the CGI script has exited, the servlet pauses a couple of times for\nhalf a second to make sure that all output has been delivered, then it exits.\n\nHere's the patch:\n\nIndex: CGIServlet.java\n===================================================================\nRCS file: /home/cvspublic/jakarta-tomcat-4.0/catalina/src/share/org/apache/catal\nina/servlets/CGIServlet.java,v\nretrieving revision 1.7\ndiff -u -3 -p -r1.7 CGIServlet.java\n--- CGIServlet.java     20 Sep 2001 23:48:13 -0000      1.7\n+++ CGIServlet.java     26 Aug 2002 14:27:27 -0000\n@@ -1663,7 +1663,6 @@ public class CGIServlet extends HttpServ\n              *                               bugParade/bugs/4223650.html\n              */\n \n-            boolean isRunning = true;\n             commandsStdOut = new BufferedReader\n                 (new InputStreamReader(proc.getInputStream()));\n             commandsStdErr = new BufferedReader\n@@ -1680,64 +1679,94 @@ public class CGIServlet extends HttpServ\n                 //NOOP: no output will be written\n             }\n \n+            boolean inHeader = true;\n+            int pauseCount = 0;\n+\n+            boolean isRunning = true;\n             while (isRunning) {\n \n-                try {\n-                    //read stderr first\n-                    cBuf = new char[1024];\n-                    while ((bufRead = commandsStdErr.read(cBuf)) != -1) {\n+                if (commandsStdErr != null && commandsStdErr.ready()) {\n+                    // about to read something; reset pause count\n+                    pauseCount = 0;\n+\n+                    bufRead = commandsStdErr.read(cBuf);\n+                    if (bufRead == -1) {\n+                        commandsStdErr.close();\n+                        commandsStdErr = null;\n+                        isRunning = (commandsStdOut != null);\n+                    } else {\n                         if (servletContainerStdout != null) {\n-                            servletContainerStdout.write(cBuf, 0, bufRead);\n+                            if (inHeader) {\n+                                servletContainerStdout.write(cBuf, 0, bufRead);\n+                            } else {\n+                                log(\"runCGI: Throwing away StdErr \\\"\" +\n+                                    new String(cBuf, 0, bufRead) + \"\\\"\");\n+                            }\n                         }\n                     }\n-\n-                    //set headers\n-                    String line = null;\n-                    while (((line = commandsStdOut.readLine()) != null)\n-                           && !(\"\".equals(line))) {\n-                        if (debug >= 2) {\n-                            log(\"runCGI: addHeader(\\\"\" + line + \"\\\")\");\n+                } else if (commandsStdOut != null && commandsStdOut.ready()) {\n+                    // about to read something; reset pause count\n+                    pauseCount = 0;\n+\n+                    if (inHeader) {\n+                        //set headers\n+                        String line = commandsStdOut.readLine();\n+                        if (line == null || \"\".equals(line)) {\n+                            inHeader = false;\n+                        } else {\n+                            if (debug >= 2) {\n+                                log(\"runCGI: addHeader(\\\"\" + line + \"\\\")\");\n+                            }\n+                            if (line.startsWith(\"HTTP\")) {\n+                                //TODO: should set status codes (NPH support)\n+                                /*\n+                                 * response.setStatus(getStatusCode(line));\n+                                 */\n+                            } else if (line.indexOf(\":\") >= 0) {\n+                                response.addHeader\n+                                    (line.substring(0, line.indexOf(\":\")).trim(\n),\n+                                     line.substring(line.indexOf(\":\") + 1).trim\n());\n+                            } else {\n+                                log(\"runCGI: bogus header line \\\"\" + line + \"\\\"\n\");\n+                            }\n                         }\n-                        if (line.startsWith(\"HTTP\")) {\n-                            //TODO: should set status codes (NPH support)\n-                            /*\n-                             * response.setStatus(getStatusCode(line));\n-                             */\n+                    } else {\n+                        //write output\n+                        bufRead = commandsStdOut.read(cBuf);\n+                        if (bufRead == -1) {\n+                            commandsStdOut.close();\n+                            commandsStdOut = null;\n+                            isRunning = (commandsStdErr != null);\n                         } else {\n-                            response.addHeader\n-                                (line.substring(0, line.indexOf(\":\")).trim(),\n-                                 line.substring(line.indexOf(\":\") + 1).trim());\n+                            if (servletContainerStdout != null) {\n+                                if (debug >= 4) {\n+                                    log(\"runCGI: write(\\\"\" + new String(cBuf, 0\n, bufRead) + \"\\\")\");\n+                                }\n+                                servletContainerStdout.write(cBuf, 0, bufRead);\n+                            }\n                         }\n                     }\n-\n-                    //write output\n-                    cBuf = new char[1024];\n-                    while ((bufRead = commandsStdOut.read(cBuf)) != -1) {\n-                        if (servletContainerStdout != null) {\n-                            if (debug >= 4) {\n-                                log(\"runCGI: write(\\\"\" + cBuf + \"\\\")\");\n+                } else {\n+                    try {\n+                        int exitVal = proc.exitValue();\n+                        pauseCount++;\n+                        if (pauseCount > 2) {\n+                            isRunning = false;\n+                        } else {\n+                            // pause for half a second\n+                            try {\n+                                Thread.sleep(500);\n+                            } catch (InterruptedException ie) {\n                             }\n-                            servletContainerStdout.write(cBuf, 0, bufRead);\n                         }\n+                    } catch (IllegalThreadStateException ex) {\n                     }\n+                }\n \n-                    if (servletContainerStdout != null) {\n-                        servletContainerStdout.flush();\n \n-                    if (servletContainerStdout != null) {\n-                        servletContainerStdout.flush();\n-                    }\n-\n-                    proc.exitValue(); // Throws exception if alive\n-\n-                    isRunning = false;\n-\n-                } catch (IllegalThreadStateException e) {\n-                    try {\n-                        Thread.currentThread().sleep(500);\n-                    } catch (InterruptedException ignored) {\n-                    }\n+                if (servletContainerStdout != null) {\n+                    servletContainerStdout.flush();\n                 }\n             } //replacement for Process.waitFor()\n-\n-\n         }\n \n \nAnd since web forms tend to hose patches, here's a gzip'd uuencoded version of\nthe same patch:\n\nbegin 644 CGIServlet.patch.gz\nM'XL(\",DZ:CT  V-S+G!A=&-H ,U846_;-A!^KG_%U0^%%-N2[+A)ZR!MUZQ;\nM @Q-D 3;P[8'6J(M=;2DD92=H,U_WU&274D6)05)@5V\".!;)X_&^CY^.? _S\nM)&\">)?S>>W!%^L>*B735]R 4DC\"6-49\\V;L(/7HW@[-?+VXH7S,JK2]D37JG\nM3[?>]=D-+ )&9V#[T8K:[EK$R9P%KOV%_$.X)\",9K5PB1U/+L?&3L\" DMN\"N\nM+7S\"J8WAV20FKD\\+K5F0PJX$/%SW.)4\\H.L@7 +'#Q%$(8RMXYX7+!8P2F!T\nM\"*,81AR?[2UW-!I5G[V8.'!#8Y@XSA@FA[/IF]D8/3AH+Y3;P6\"P/^0(?DJ6\nM:L@$QM/9Y!A_LR&]#Q]@-#XZ.AP>PR#]/ )\\E.4#7$:$*'@#>B=IZ DXES)6\nMSWI0L@-HMGFRO\"*<>-3&_X0]G4P.CUX[EB]7K.K)[D%O5!H;18R2$ )QG82A\nMRN8I2)[0D_)(-UJM\"(9X([W+1&*?D&[@8[)84$Z]:XIS\\\\I4:(;J=!'&B;R1\nMG))5UL^(>>1:2RH++89IFOH9/W%>/V.6Y3?.\\&BJTGS\\=OAV^H0\\H]GVY\\O+\nMJQF$$42)Q/A@$S &<PH;'D@<71[R@.D<U*8S/$]#W&6SU\"L()<0D$?0L2D*5\nM30<[:!PUX[+Q<<>!L>MEPM<JPLHDO\\>&O<?9BA$ #X3$:#EN8\"YD?4<7DY_#\nMX.*&_7/L3*9_G]3WS<,RYLE\"087#RG!::DY#>31->'F***K !U4WP0*,\"@^P\nM<Y@@(J]>U;F\\1R+5.<H6\"F2.H(*,(%LRJI3T,6DG^%W0'!)TBYC4NVC!;&L=\nM5GU2/U(M>#=:FY8=(F7O+HL$-72N]P= ELJ&_D7R&14)R('03?< E&$RO^YO\nML>):<WT_BT))@I!R]!T5?.LXN[7ZX9;:JC3-\\Q\"<X1:.IL1LX]ENV\\:T_Y#9\nM=_EJG99%2Z//DQ!U;0:W/H\\V\"B\"R(?>0X_I7OP\\::E9-[6:48/2P'S$,H(^N\nM6B/70ZQI>NB-=%JDMJ&?0B#JNV3! E8'=,??1@DR\\JYE^J9;\\3=L,3(!2NG6\nM2#84G)=&OV_1?Q/\"1.K5-!L9J@CE47PEP[M3F+22N80K\\;R,B48*9K;>% ^S\nM%I\"</A7!+.S3BF!N4_#_$,S.6Z],$&VW,DFTR#<I'T:4#<_3]^T;5,%OVZR%\nM&F\"!HZI%0-&Z[?Y]0CU.+!Y+JE*$[:$I=Q:>-[@4?P32-_KGM[=7_?8\\*;/M\nMV\\N?+V<@_\"AAR#1$&3W)1\"!Z'A5@?+XZ!Y'$<<2EV<'=00?Y.U LCJ-08-04\nM\"U$UG;'<_G>&\\^9 MZ0F<V9WTO==G@)U$+M<&/U9WU1P.IW2M MX!V4WF<^Q\nM2>8BTWI4^;TH3 O;L!(?=G,)%9?[JQK >.OS![W]YM$2&9+)0<;F*K&?]O9J\nME/8&NC?J_..HWNSJH+G],11O<:2A=SMPMIT61/EQ2M^OMFC>ZG5CT:SL<86S\nMLLHL[<7S_J#V CH-35-$%TXSU;-OT789;@2H1AB: 87'BD*KNV<5A&Z'@U:U\nM*+TQIYV&I\"LIBDQ6SV?\"TEXNM[])E;6\\394][^GB.6OTTG[^L5<%Y?U?N\"IH\nM5.8GGBKW2=/*?2UATDRTU^T:7F;7-GK1\"]655B!_)PS3EEZKY5^39BG[7I8/\nM!BVB6JC@WW6H.8MB]SQ%+YY\"LF/&(N+@$[8 @GO#C4*O>5Q+[K:&!VCDER48\nMI;'QVG':*Q57W:V#<1%*RGD22^I]NG-I+-4%=$#-IBN/U,'S7FDTS*-Y86_C\nM9XPN\"<O6K^H!^GT9]$Z[C!JW#W4WCLJ>N!<UJ5BP1/B&KF+1ZM;>]E#,2J]/\nM!*YW!R#2BP5KJO-2P^^:GMV2K%U\\PVVMLIRR;L(Y#67VS3!+%*Y/33-UEV'$\nMJ:<-J@;X)[RDV[\"MF;ZR%G5O'3/BTA4F(16'*T28\"F%M2\"!_B;AA*FAZ10_X\n*\\Q__WM3<+QL  +\"M\n \nend", "id": 21738, "time": "2002-08-26T14:31:38Z", "creator": "dglo@ssec.wisc.edu", "creation_time": "2002-08-26T14:31:38Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 12041, "text": "Thanks for the patch.", "id": 21765, "time": "2002-08-26T22:51:20Z", "creator": "amyroh@apache.org", "creation_time": "2002-08-26T22:51:20Z", "is_private": false, "attachment_id": null}, {"count": 2, "tags": [], "text": "I'm running existing CGI script (perl/DBI), and encountered the same problem. My\ncurrent workaround is to redirect STDERR at the beginning of the script to avoid\ngetting into deadlock.\n\nI applied the patch, and found the following additional issues:\n+ STRERR messages should always go to the log file (following Apache\nconvention). It should not matter if the message if produced before, during of\nafter the header  section (which is coming from STDOUT).\n\n+ The patch do not support long running scripts, that do not produce output\n(during database activity)\n\n+ The patch does not work well when there are a lot of message on STDERR, but\nlittle output on STDOUT. The CGI script is getting blocked on STDERR, while the\nservlet is waiting on STDOUT (#1734).\n\nI think that a good solution will be\nA. running an extra thread to deal with STDERR, OR\nB. Using Non-Blocking IO (unfortunantely, only with JDK 1.4), OR\nC. Fixing the polling loop\n\twhile ( isRunning ) {\n\t\tif (commandsStdErr != null && commandsStdErr.ready()) {\n\t\t\t/* Move STDERR data */\n\t\telse if (commandsStdOut != null && commandsStdOut.ready()) {\n\t\t\t/* Deal with STDOUT data */\n\t\telse {\n\t\t\tsleep a little (0.1 sec)\n\t\t}\n\t}\n\t/* Process  Cleanup */\n\ttry {\n\t\t... = proc.exitValue()}\n\tcatch ( ... ) {\n\t\t/* Pause, then Kill Process if needed */\n\t} ;\n", "is_private": false, "id": 21962, "creator": "yair.lenga@ssmb.com", "time": "2002-08-29T13:31:55Z", "bug_id": 12041, "creation_time": "2002-08-29T13:31:55Z", "attachment_id": null}]