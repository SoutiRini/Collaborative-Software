[{"count": 0, "tags": [], "bug_id": 49642, "attachment_id": null, "text": "A resource with a encoded question mark (%3F) will be split up, by mod_rewrite, into name and args. Expected result would be for mod_rewrite to leave the name intact.\n\n\n# From rewrite.log\n(2) init rewrite engine with requested uri /trigrewrite_filename?args\n(3) applying pattern '^/trigrewrite_(.*)' to uri '/trigrewrite_filename?args'\n(2) rewrite '/trigrewrite_filename?args' -> '/filename?args'\n(3) split uri=/filename?args -> uri=/filename, args=args\n(2) local path result: /filename\n\n\n# Vhost conf\nListen 9004\n<VirtualHost *:9004>\n    Servername rewritebug\n    DocumentRoot /home/apache/www/rewrite\n#   AllowEncodedSlashes On\n    RewriteEngine On\n    RewriteLog \"logs/rewrite.log\"\n    RewriteLogLevel 9\n\n    RewriteRule ^/trigrewrite_(.*) /$1 [L]\n\n    <Directory \"/home/apache/www/rewrite\">\n        Options None\n        Order allow,deny\n        Allow from all\n    </Directory>\n</VirtualHost>\n\n\n# From access_log\n\"GET /trigrewrite_filename%3Fargs HTTP/1.1\" 404 223\n\n\n# index.html\ntest rewrite\n<script type=\"text/javascript\">\nvar uri = '/trigrewrite_filename%3Fargs';\ndocument.write('<iframe src=\"'+uri +'\"></iframe>');\n</script>", "id": 138659, "time": "2010-07-23T09:24:56Z", "creator": "petterb@gmail.com", "creation_time": "2010-07-23T09:24:56Z", "is_private": false}, {"count": 1, "tags": [], "text": "rewrite flags doc sure thinks a literal ? in a backreference will be escaped by default, and even uses it in the example!\n\n\"NE|noescape\nBy default, special characters, such as & and ?, for example, will be converted to their hexcode equivalent. Using the [NE] flag prevents that from happening.\"", "attachment_id": null, "id": 138660, "creation_time": "2010-07-23T09:44:34Z", "time": "2010-07-23T09:44:34Z", "creator": "covener@gmail.com", "bug_id": 49642, "is_private": false}, {"text": "I think I have just stumbled upon the same problem. I have a file with a '?' in its name that I want to acccess via rewrite rules, because it used to be in /old, but is now in /new. I can work around this in this simple case by just using an equivalent Alias statement.\n\nThe RewriteRule is\n\nRewriteRule ^\\/\\/?old\\/(.*)$ /tmp/new/$1 [T=text/plain,L,NE]\n\nJust checking that the rule works with a \"normal\" file \"foo\" with contents \"foo foo\":\n\ncurl http://172.28.51.128:11003/old/foo\n172.28.51.128 - - [29/Mar/2012:15:36:14 +0200] [172.28.51.128/sid#8611b58][rid#89faec8/initial] (2) init rewrite engine with requested uri /old/foo\n172.28.51.128 - - [29/Mar/2012:15:36:14 +0200] [172.28.51.128/sid#8611b58][rid#89faec8/initial] (3) applying pattern '^\\/\\/?old\\/(.*)$' to uri '/old/foo'\n172.28.51.128 - - [29/Mar/2012:15:36:14 +0200] [172.28.51.128/sid#8611b58][rid#89faec8/initial] (2) rewrite '/old/foo' -> '/tmp/new/foo'\n172.28.51.128 - - [29/Mar/2012:15:36:14 +0200] [172.28.51.128/sid#8611b58][rid#89faec8/initial] (2) remember /tmp/new/foo to have MIME-type 'text/plain'\n172.28.51.128 - - [29/Mar/2012:15:36:14 +0200] [172.28.51.128/sid#8611b58][rid#89faec8/initial] (2) local path result: /tmp/new/foo\n172.28.51.128 - - [29/Mar/2012:15:36:14 +0200] [172.28.51.128/sid#8611b58][rid#89faec8/initial] (1) go-ahead with /tmp/new/foo [OK]\n172.28.51.128 - - [29/Mar/2012:15:36:14 +0200] [172.28.51.128/sid#8611b58][rid#89faec8/initial] (1) force filename /tmp/new/foo to have MIME-type 'text/plain'\nfoo foo\n\nThe file named \"bar?bar\" (results with or without QSA  or NE are identical):\ncurl http://172.28.51.128:11003/old/bar%3Fbar\n172.28.51.128 - - [29/Mar/2012:15:36:23 +0200] [172.28.51.128/sid#8611b58][rid#89fced0/initial] (2) init rewrite engine with requested uri /old/bar?bar\n172.28.51.128 - - [29/Mar/2012:15:36:23 +0200] [172.28.51.128/sid#8611b58][rid#89fced0/initial] (3) applying pattern '^\\/\\/?old\\/(.*)$' to uri '/old/bar?bar'\n172.28.51.128 - - [29/Mar/2012:15:36:23 +0200] [172.28.51.128/sid#8611b58][rid#89fced0/initial] (2) rewrite '/old/bar?bar' -> '/tmp/new/bar?bar'\n172.28.51.128 - - [29/Mar/2012:15:36:23 +0200] [172.28.51.128/sid#8611b58][rid#89fced0/initial] (3) split uri=/tmp/new/bar?bar -> uri=/tmp/new/bar, args=bar\n172.28.51.128 - - [29/Mar/2012:15:36:23 +0200] [172.28.51.128/sid#8611b58][rid#89fced0/initial] (2) remember /tmp/new/bar to have MIME-type 'text/plain'\n172.28.51.128 - - [29/Mar/2012:15:36:23 +0200] [172.28.51.128/sid#8611b58][rid#89fced0/initial] (2) local path result: /tmp/new/bar\n172.28.51.128 - - [29/Mar/2012:15:36:23 +0200] [172.28.51.128/sid#8611b58][rid#89fced0/initial] (1) go-ahead with /tmp/new/bar [OK]\n172.28.51.128 - - [29/Mar/2012:15:36:23 +0200] [172.28.51.128/sid#8611b58][rid#89fced0/initial] (1) force filename /tmp/new/bar to have MIME-type 'text/plain'\n<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n<html><head>\n<title>404 Not Found</title>\n</head><body>\n<h1>Not Found</h1>\n<p>The requested URL /old/bar?bar was not found on this server.</p>\n</body></html>\n\nA file named \"baz?baz\" in directory /new2 in the document root works as expected:\ncurl http://172.28.51.128:11003/new2/baz%3Fbaz\n172.28.51.128 - - [29/Mar/2012:15:37:23 +0200] [172.28.51.128/sid#8611b58][rid#8a04ef0/initial] (2) init rewrite engine with requested uri /new2/baz?baz\n172.28.51.128 - - [29/Mar/2012:15:37:23 +0200] [172.28.51.128/sid#8611b58][rid#8a04ef0/initial] (3) applying pattern '^\\/\\/?old\\/(.*)$' to uri '/new2/baz?baz'\n172.28.51.128 - - [29/Mar/2012:15:37:23 +0200] [172.28.51.128/sid#8611b58][rid#8a04ef0/initial] (3) applying pattern '.' to uri '/new2/baz?baz'\n172.28.51.128 - - [29/Mar/2012:15:37:23 +0200] [172.28.51.128/sid#8611b58][rid#8a04ef0/initial] (4) RewriteCond: input='curl/7.24.0 (i686-pc-linux-gnu) libcurl/7.24.0 OpenSSL/0.9.8u zlib/1.2.5' pattern='Apache \\(internal dummy connection\\)' => not-matched\n172.28.51.128 - - [29/Mar/2012:15:37:23 +0200] [172.28.51.128/sid#8611b58][rid#8a04ef0/initial] (1) pass through /new2/baz?baz\nbaz baz\n\nAdding [B] to the flags doesn't have the desired results either - it's actually worse, because '/' would get encoded to %2F, making directories inaccessible:\ncurl http://172.28.51.128:11003/old/bar%3Fbar\n172.28.51.128 - - [29/Mar/2012:15:39:39 +0200] [172.28.51.128/sid#847f6b0][rid#8a04eb0/initial] (2) init rewrite engine with requested uri /old/bar?bar\n172.28.51.128 - - [29/Mar/2012:15:39:39 +0200] [172.28.51.128/sid#847f6b0][rid#8a04eb0/initial] (3) applying pattern '^\\/\\/?old\\/(.*)$' to uri '/old/bar?bar'\n172.28.51.128 - - [29/Mar/2012:15:39:39 +0200] [172.28.51.128/sid#847f6b0][rid#8a04eb0/initial] (5) escaping backreference 'bar?bar' to 'bar%3fbar'\n172.28.51.128 - - [29/Mar/2012:15:39:39 +0200] [172.28.51.128/sid#847f6b0][rid#8a04eb0/initial] (2) rewrite '/old/bar?bar' -> '/tmp/new/bar%3fbar'\n172.28.51.128 - - [29/Mar/2012:15:39:39 +0200] [172.28.51.128/sid#847f6b0][rid#8a04eb0/initial] (2) remember /tmp/new/bar%3fbar to have MIME-type 'text/plain'\n172.28.51.128 - - [29/Mar/2012:15:39:39 +0200] [172.28.51.128/sid#847f6b0][rid#8a04eb0/initial] (2) local path result: /tmp/new/bar%3fbar\n172.28.51.128 - - [29/Mar/2012:15:39:39 +0200] [172.28.51.128/sid#847f6b0][rid#8a04eb0/initial] (1) go-ahead with /tmp/new/bar%3fbar [OK]\n172.28.51.128 - - [29/Mar/2012:15:39:39 +0200] [172.28.51.128/sid#847f6b0][rid#8a04eb0/initial] (1) force filename /tmp/new/bar%3fbar to have MIME-type 'text/plain'\n<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n<html><head>\n<title>404 Not Found</title>\n</head><body>\n<h1>Not Found</h1>\n<p>The requested URL /old/bar?bar was not found on this server.</p>\n</body></html>", "tags": [], "bug_id": 49642, "is_private": false, "count": 2, "id": 155369, "time": "2012-03-29T15:32:04Z", "creator": "rainer-apache@7val.com", "creation_time": "2012-03-29T15:32:04Z", "attachment_id": null}, {"count": 3, "tags": [], "creator": "andersk@mit.edu", "attachment_id": null, "id": 173714, "time": "2014-03-09T12:07:14Z", "bug_id": 49642, "creation_time": "2014-03-09T12:07:14Z", "is_private": false, "text": "Same problem on Apache 2.4.7.  And it isn\u2019t unique to encoded question marks (%3f); encoded hash (%23) has a similarly catastrophic effect."}, {"count": 4, "attachment_id": null, "creator": "covener@gmail.com", "is_private": false, "id": 173715, "time": "2014-03-09T12:20:20Z", "bug_id": 49642, "creation_time": "2014-03-09T12:20:20Z", "tags": [], "text": "(In reply to Anders Kaseorg from comment #3)\n> Same problem on Apache 2.4.7.  And it isn\u2019t unique to encoded question marks\n> (%3f); encoded hash (%23) has a similarly catastrophic effect.\n\nCan you elaborate on the problem with %23?  I was able to capture and substitute it just fine and find a file with a literal hash mark in it."}, {"count": 5, "tags": [], "bug_id": 49642, "attachment_id": null, "is_private": false, "id": 173716, "time": "2014-03-09T12:45:57Z", "creator": "andersk@mit.edu", "creation_time": "2014-03-09T12:45:57Z", "text": "With this .htaccess file:\n\nRewriteEngine on\nRewriteRule ^page/(.*)$ /cgi-bin/page.cgi/$1\n\na request for page/foo%23bar is rewritten to /cgi-bin/page.cgi/foo (the CGI script sees PATH_INFO=/foo), and a request for page/foo%3fbar is rewritten to /cgi-bin/page.cgi/foo?bar (the CGI script sees PATH_INFO=/foo and QUERY_STRING=bar)."}, {"count": 6, "tags": [], "creator": "andersk@mit.edu", "attachment_id": null, "id": 173717, "time": "2014-03-09T13:32:38Z", "bug_id": 49642, "creation_time": "2014-03-09T13:32:38Z", "is_private": false, "text": "I tried passing every unescaped and escaped character through mod_rewrite in a loop, and came up with this list of escaping problems.\n\nRewriteRule ^page/(.*)$ page.cgi/$1\n\npage.cgi/foo%0abar: PATH_INFO=\"/foo\\nbar\"\npage/foo%0abar: 404\n\npage.cgi/foo%23bar: PATH_INFO=\"/foo#bar\"\npage/foo%23bar: PATH_INFO=\"/foo\"\n\npage.cgi/foo%25bar: PATH_INFO=\"/foo%bar\"\npage/foo%25bar: PATH_INFO=\"/foo\\x{BA}r\"\n\npage.cgi/foo%3fbar: PATH_INFO=\"/foo?bar\"\npage/foo%3fbar: PATH_INFO=\"/foo\" QUERY_STRING=\"bar\"\n\n(%0a is the regex\u2019s fault in this case, since . doesn\u2019t match newline by default, but the problem doesn\u2019t go away with a more careful regex like (?s)\\Apage/(.*)\\z .)\n\nI\u2019ve seen some people recommend the [B] flag as a solution, so I tried that too.  That comes with its own set of problems:\n\nRewriteRule ^page/(.*)$ page.cgi/$1 [B]\n\npage.cgi/foo%0abar: PATH_INFO=\"/foo\\nbar\"\npage/foo%0abar: 404\n\npage.cgi/foo%20bar: PATH_INFO=\"/foo bar\"\npage/foo%20bar: PATH_INFO=\"/foo+bar\"\n\npage.cgi/foo/bar: PATH_INFO=\"/foo/bar\"\npage/foo/bar: 404\n\nI\u2019m running apache2 2.4.7-1ubuntu1 on Ubuntu trusty amd64."}, {"count": 7, "tags": [], "bug_id": 49642, "attachment_id": null, "id": 173718, "time": "2014-03-09T13:34:35Z", "creator": "covener@gmail.com", "creation_time": "2014-03-09T13:34:35Z", "is_private": false, "text": "(In reply to Anders Kaseorg from comment #5)\n> With this .htaccess file:\n> \n> RewriteEngine on\n> RewriteRule ^page/(.*)$ /cgi-bin/page.cgi/$1\n> \n> a request for page/foo%23bar is rewritten to /cgi-bin/page.cgi/foo (the CGI\n> script sees PATH_INFO=/foo), and a request for page/foo%3fbar is rewritten\n> to /cgi-bin/page.cgi/foo?bar (the CGI script sees PATH_INFO=/foo and\n> QUERY_STRING=bar).\n\nI guess the cause is the same here, capturing and substituting the decoded characters and 'B' being unsafe to use in a general purpuse substitution (and requiring per-directory rewrite to allow the re-encoded strings to be decoded again by the core).\n\nI haven't looked in detail, but I think in the case of %23 it's the core splitting the URL later as opposed to mod_rewrite splittin the URL shortly after the substitution -- so the solution might be different.\n\nFrom a workaround perspective,\n\n1)\nWhat I would normally suggest here is capturing against %{THE_REQUEST} to deal exclusively with the client-encoded form of the request.\n\n2)\nfor the #, it would seem to be feasible to use [N] and replace #->&23 and not pollute every capturing rule.  This doesn't work for ? because the split happens right away.\n\nFrom a partial fix perspective, Unfortunately I do not really see a full/acceptable or non opt-in fix at this time\n\n\n1) something like [B=#?] would allow a rule to be fine tuned a little better _after_ finding a problem.  I actually like this one as a general tool.\n\n2) an option to split the query string on the right-most question-mark (this by default would break a URL w/ a query passed in the query)\n\n3) some option to remember that the ? was captured at the time we try to split it. Even this breaks captures against %{THE_REQUEST} in a rewritecond."}, {"count": 8, "tags": [], "bug_id": 49642, "attachment_id": null, "text": "> I\u2019ve seen some people recommend the [B] flag as a solution, so I tried that\n> too.  That comes with its own set of problems:\n\nIn general [B] is very scary. It is not context aware at all.", "id": 173719, "time": "2014-03-09T13:35:46Z", "creator": "covener@gmail.com", "creation_time": "2014-03-09T13:35:46Z", "is_private": false}, {"count": 9, "tags": [], "bug_id": 49642, "is_private": false, "text": "> 2) an option to split the query string on the right-most question-mark (this\n> by default would break a URL w/ a query passed in the query)\n\nEven with this you'd of course have to manually manage the query string to avoid a ? sneaking in from a substitution as the sole question mark.", "id": 173720, "time": "2014-03-09T14:15:59Z", "creator": "covener@gmail.com", "creation_time": "2014-03-09T14:15:59Z", "attachment_id": null}]