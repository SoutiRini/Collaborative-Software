[{"count": 0, "tags": [], "bug_id": 23037, "text": "I wrote a little extension to the ContainsRegexpSelector. Like the \n<replaceregexp> Task (org.apache.tools.ant.taskdefs.optional.ReplaceRegExp) \nthe selector supports two additional parameters: \"byline\" and \"flags\". You \nwill find a short documentation inside the JavaDoc comments.\n\nI want to donate the code to the project.\n\nThorsten M\u00f6ller\n\n\nHere is the CVS patch generated against the Head-Version:\n---------------------------------------------------------\n\n\n\nIndex: ContainsRegexpSelector.java\n===================================================================\nRCS \nfile: /home/cvspublic/ant/src/main/org/apache/tools/ant/types/selectors/Contain\nsRegexpSelector.java,v\nretrieving revision 1.5\ndiff -u -r1.5 ContainsRegexpSelector.java\n--- ContainsRegexpSelector.java\t29 Jul 2003 08:37:18 -0000\t1.5\n+++ ContainsRegexpSelector.java\t9 Sep 2003 17:04:35 -0000\n@@ -54,140 +54,322 @@\n \n package org.apache.tools.ant.types.selectors;\n \n-import java.io.BufferedReader;\n import java.io.File;\n-import java.io.FileInputStream;\n+import java.io.BufferedReader;\n+import java.io.FileReader;\n import java.io.IOException;\n-import java.io.InputStreamReader;\n \n-import org.apache.tools.ant.BuildException;\n import org.apache.tools.ant.types.Parameter;\n-import org.apache.tools.ant.types.RegularExpression;\n+import org.apache.tools.ant.util.FileUtils;\n import org.apache.tools.ant.util.regexp.Regexp;\n+import org.apache.tools.ant.util.regexp.RegexpFactory;\n+import org.apache.tools.ant.BuildException;\n+import org.apache.tools.ant.Project;\n \n /**\n- * Selector that filters files based on a regular expression.\n+ * Selector that filters files based on whether they contain a\n+ * particular pattern expressed with a regular expression.\n+ * The input file(s) must be able to be properly processed by\n+ * a Reader instance. That is, it must be text only, no binary.\n+ *\n+ * The syntax of the regular expression depends on the implemtation that\n+ * you choose to use. The system property <code>ant.regexp.regexpimpl</code>\n+ * will be the classname of the implementation that will be used (the default\n+ * is <code>org.apache.tools.ant.util.regexp.JakartaOroRegexp</code> and\n+ * requires the Jakarta Oro Package).\n+ *\n+ * <pre>\n+ * For jdk  &lt;= 1.3, there are two available implementations:\n+ *   org.apache.tools.ant.util.regexp.JakartaOroRegexp (the default)\n+ *        Requires  the jakarta-oro package\n+ *\n+ *   org.apache.tools.ant.util.regexp.JakartaRegexpRegexp\n+ *        Requires the jakarta-regexp package\n  *\n- * @author <a href=\"mailto:jvandermeer2@comcast.net\">Jay van der Meer</a>\n- * @since Ant 1.6\n+ * For jdk &gt;= 1.4 an additional implementation is available:\n+ *   org.apache.tools.ant.util.regexp.Jdk14RegexpRegexp\n+ *        Requires the jdk 1.4 built in regular expression package.\n+ *\n+ *   Attributes:\n+ *\n+ *     pattern --&gt; The Regular expression to search for\n+ *     flags   --&gt; The options to give to the search. For more \ninformation, consult the Perl5 syntax.\n+ *                 i = Case insensitive match\n+ *                 m = Multiline.  Treat the string as multiple lines of \ninput, using\n+ *                     \"^\" and \"$\" as the start or end of any line, \nrespectively, rather\n+ *                     than start or end of string.\n+ *                 m = Singleline.  Treat the string as a single line of \ninput, using\n+ *                     \".\" to match any character, including a newline, which \nnormally,\n+ *                     it would not match.\n+ *\n+ *     byline  --&gt; Should files be processed a single line at a time \n(default is false)\n+ *                 \"true\" indicates to perform search on a line by line basis\n+ *                 \"false\" indicates to perform search on the whole file at \nonce.\n+ *\n+ *\n+ * @author Thorsten M\u00f6ller - Thorsten.Moeller@jexam.de\n+ * \n+ * $Revision: $; $Author: $; $Date: $\n  */\n-public class ContainsRegexpSelector extends BaseExtendSelector {\n+public class ContainsRegexpSelector extends BaseExtendSelector\n+{\n \n-    private String userProvidedExpression = null;\n-    private RegularExpression myRegExp = null;\n-    private Regexp myExpression = null;\n-    /** Key to used for parameterized custom selector */\n-    public static final String EXPRESSION_KEY = \"expression\";\n-\n-    /**\n-     * Creates a new <code>ContainsRegexpSelector</code> instance.\n-     */\n-    public ContainsRegexpSelector() {\n-    }\n-\n-    /**\n-     * @return a string describing this object\n-     */\n-    public String toString() {\n-        StringBuffer buf = new StringBuffer(\n-                \"{containsregexpselector expression: \");\n-        buf.append(userProvidedExpression);\n-        buf.append(\"}\");\n-        return buf.toString();\n-    }\n-\n-    /**\n-     * The regular expression used to search the file.\n-     *\n-     * @param theexpression this must match a line in the file to be selected.\n-     */\n-    public void setExpression(String theexpression) {\n-        this.userProvidedExpression = theexpression;\n-    }\n-\n-    /**\n-     * When using this as a custom selector, this method will be called.\n-     * It translates each parameter into the appropriate setXXX() call.\n-     *\n-     * @param parameters the complete set of parameters for this selector\n-     */\n-    public void setParameters(Parameter[] parameters) {\n-        super.setParameters(parameters);\n-        if (parameters != null) {\n-            for (int i = 0; i < parameters.length; i++) {\n-                String paramname = parameters[i].getName();\n-                if (EXPRESSION_KEY.equalsIgnoreCase(paramname)) {\n-                    setExpression(parameters[i].getValue());\n-                } else {\n-                    setError(\"Invalid parameter \" + paramname);\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Checks that an expression was specified.\n-     *\n-     */\n-    public void verifySettings() {\n-        if (userProvidedExpression == null) {\n-            setError(\"The expression attribute is required\");\n-        }\n-    }\n-\n-    /**\n-     * Tests a regular expression against each line of text in the file.\n-     *\n-     * @param basedir the base directory the scan is being done from\n-     * @param filename is the name of the file to check\n-     * @param file is a java.io.File object the selector can use\n-     * @return whether the file should be selected or not\n-     */\n-    public boolean isSelected(File basedir, String filename, File file) {\n-        String teststr = null;\n-        BufferedReader in = null;\n-\n-        // throw BuildException on error\n-\n-        validate();\n-\n-        if (file.isDirectory()) {\n-            return true;\n-        }\n-\n-        if (myRegExp == null) {\n-            myRegExp = new RegularExpression();\n-            myRegExp.setPattern(userProvidedExpression);\n-            myExpression = myRegExp.getRegexp(getProject());\n-        }\n-\n-        try {\n-            in = new BufferedReader(new InputStreamReader(\n-                    new FileInputStream(file)));\n-\n-            teststr = in.readLine();\n-\n-            while (teststr != null) {\n-\n-                if (myExpression.matches(teststr)) {\n-                    return true;\n-                }\n-                teststr = in.readLine();\n-            }\n-\n-            return false;\n-        } catch (IOException ioe) {\n-            throw new BuildException(\"Could not read file \" + filename);\n-        } finally {\n-            if (in != null) {\n-                try {\n-                    in.close();\n-                } catch (Exception e) {\n-                    throw new BuildException(\"Could not close file \"\n-                                             + filename);\n-                }\n-            }\n-        }\n-    }\n+\tprivate boolean byline;\n+\tprivate String flags;\n+\tprivate Regexp regexp = null;\n+\tprivate static final RegexpFactory factory = new RegexpFactory();\n+\n+\tpublic static final String PATTERN_KEY = \"pattern\";\n+\tpublic static final String FLAGS_KEY = \"flags\";\n+\tpublic static final String BYLINE_KEY = \"byline\";\n+\n+\tpublic ContainsRegexpSelector()\n+\t{\n+\t\tthis.regexp = factory.newRegexp();\n+\t}\n+\n+\tpublic String toString()\n+\t{\n+\t\tStringBuffer buf = new StringBuffer(\"{containsRegexpSelector \npattern: \");\n+\t\tbuf.append(regexp.getPattern());\n+\t\tbuf.append(\" byline: \");\n+\t\tbuf.append(Boolean.toString(byline));\n+\t\tbuf.append(\" flags: \");\n+\t\tbuf.append(flags);\n+\t\tbuf.append(\"}\");\n+\t\treturn buf.toString();\n+\t}\n+\n+\t/**\n+\t * Process the file(s) one line at a time.\n+\t * This is useful if you want to only search for the first occurence \nof a regular expression on\n+\t * each line, which is not easy to do when processing the file as a \nwhole.\n+\t * Defaults to <i>false</i>.</td>\n+\t */\n+\tpublic void setByLine(String byline)\n+\t{\n+\t\tBoolean res = Boolean.valueOf(byline);\n+\t\tif (res == null)\n+\t\t{\n+\t\t\tres = Boolean.FALSE;\n+\t\t}\n+\t\tthis.byline = res.booleanValue();\n+\t}\n+\n+\t/**\n+\t * The flags to use when matching the regular expression.  For more\n+\t * information, consult the Perl5 syntax.\n+\t * <ul>\n+\t *  <li>i : Case Insensitive.  Do not consider case in the match\n+\t *  <li>m : Multiline.  Treat the string as multiple lines of input, \n+\t *         using \"^\" and \"$\" as the start or end of any line, \nrespectively, rather than start or end of string.\n+\t *  <li>s : Singleline.  Treat the string as a single line of input, \nusing\n+\t *        \".\" to match any character, including a newline, which \nnormally, it would not match.\n+\t *</ul>\n+\t */\n+\tpublic void setFlags(String flags)\n+\t{\n+\t\tthis.flags = flags;\n+\t}\n+\n+\t/**\n+\t * The pattern to search for within a file.\n+\t *\n+\t * @param regexp the string that a file must contain to be selected.\n+\t */\n+\tpublic void setRegexp(String pattern)\n+\t{\n+\t\tthis.regexp.setPattern(pattern);\n+\t}\n+\n+\t/**\n+\t * When using this as a custom selector, this method will be called.\n+\t * It translates each parameter into the appropriate setXXX() call.\n+\t *\n+\t * @param parameters the complete set of parameters for this selector\n+\t */\n+\tpublic void setParameters(Parameter[] parameters)\n+\t{\n+\t\tsuper.setParameters(parameters);\n+\t\tif (parameters != null)\n+\t\t{\n+\t\t\tfor (int i = 0; i < parameters.length; i++)\n+\t\t\t{\n+\t\t\t\tString paramname = parameters[i].getName();\n+\t\t\t\tif (PATTERN_KEY.equalsIgnoreCase(paramname))\n+\t\t\t\t{\n+\t\t\t\t\tsetRegexp(parameters[i].getValue());\n+\t\t\t\t}\n+\t\t\t\telse if (BYLINE_KEY.equalsIgnoreCase\n(paramname))\n+\t\t\t\t{\n+\t\t\t\t\tsetByLine(parameters[i].getValue());\n+\t\t\t\t}\n+\t\t\t\telse if (FLAGS_KEY.equalsIgnoreCase(paramname))\n+\t\t\t\t{\n+\t\t\t\t\tsetFlags(parameters[i].getValue());\n+\t\t\t\t}\n+\t\t\t\telse\n+\t\t\t\t{\n+\t\t\t\t\tsetError(\"Invalid parameter \" + \nparamname);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Checks to make sure all settings are kosher. In this case, it\n+\t * means that the pattern attribute has been set.\n+\t *\n+\t */\n+\tpublic void verifySettings()\n+\t{\n+\t\tif (regexp == null)\n+\t\t{\n+\t\t\tsetError(\"The pattern attribute is required\");\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * The heart of the matter. This is where the selector gets to decide\n+\t * on the inclusion of a file in a particular fileset.\n+\t *\n+\t * @param basedir the base directory the scan is being done from\n+\t * @param filename is the name of the file to check\n+\t * @param file is a java.io.File object the selector can use\n+\t * @return whether the file should be selected or not\n+\t */\n+\tpublic boolean isSelected(File basedir, String filename, File file)\n+\t{\n+\n+\t\t// throw BuildException on error\n+\t\tvalidate();\n+\n+\t\tif (file.isDirectory())\n+\t\t{\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tint options = 0;\n+\t\t//\t\tif (flags.indexOf('g') != -1)\toptions |= \nRegexp.REPLACE_ALL;\n+\t\tif (flags.indexOf('i') != -1)\n+\t\t\toptions |= Regexp.MATCH_CASE_INSENSITIVE;\n+\t\tif (flags.indexOf('m') != -1)\n+\t\t\toptions |= Regexp.MATCH_MULTILINE;\n+\t\tif (flags.indexOf('s') != -1)\n+\t\t\toptions |= Regexp.MATCH_SINGLELINE;\n+\n+\t\tFileReader r = null;\n+\t\ttry\n+\t\t{\n+\t\t\tr = new FileReader(file);\n+\t\t\tBufferedReader br = new BufferedReader(r);\n+\t\t\tlog(\n+\t\t\t\t\"Searching pattern '\"\n+\t\t\t\t\t+ regexp.getPattern()\n+\t\t\t\t\t+ \"' in '\"\n+\t\t\t\t\t+ file.getPath()\n+\t\t\t\t\t+ \"'\"\n+\t\t\t\t\t+ (byline ? \" by line\" : \"\")\n+\t\t\t\t\t+ (flags.length() > 0 ? \" with \nflags: '\" + flags + \"'\" : \"\")\n+\t\t\t\t\t+ \".\",\n+\t\t\t\tProject.MSG_VERBOSE);\n+\n+\t\t\tif (byline)\n+\t\t\t{\n+\t\t\t\tStringBuffer linebuf = new StringBuffer();\n+\t\t\t\tString line = null;\n+\t\t\t\tint c;\n+\t\t\t\tboolean hasCR = false;\n+\n+\t\t\t\tdo\n+\t\t\t\t{\n+\t\t\t\t\tc = br.read();\n+\t\t\t\t\tif (c == '\\r')\n+\t\t\t\t\t{\n+\t\t\t\t\t\tif (hasCR)\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t// second CR -> EOL + \npossibly empty line\n+\t\t\t\t\t\t\tline = linebuf.toString\n();\n+\t\t\t\t\t\t\tif (regexp.matches\n(line, options))\n+\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tlinebuf.setLength(0);\n+\t\t\t\t\t\t\t// hasCR is still true \n(for the second one)\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\telse\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t// first CR in this \nline\n+\t\t\t\t\t\t\thasCR = true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\telse if (c == '\\n')\n+\t\t\t\t\t{\n+\t\t\t\t\t\t// LF -> EOL\n+\t\t\t\t\t\tline = linebuf.toString();\n+\t\t\t\t\t\tif (regexp.matches(line, \noptions))\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (hasCR)\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\thasCR = false;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tlinebuf.setLength(0);\n+\t\t\t\t\t}\n+\t\t\t\t\telse\n+\t\t\t\t\t{ // any other char\n+\t\t\t\t\t\tif ((hasCR) || (c < 0))\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t// Mac-style linebreak \nor EOF (or both)\n+\t\t\t\t\t\t\tline = linebuf.toString\n();\n+\t\t\t\t\t\t\tif (regexp.matches\n(line, options))\n+\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif (hasCR)\n+\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\thasCR = false;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tlinebuf.setLength(0);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (c >= 0)\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tlinebuf.append((char) \nc);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\twhile (c >= 0);\n+\t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\tString buf = FileUtils.readFully(br);\n+\t\t\t\tif (regexp.matches(buf, options))\n+\t\t\t\t{\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tr.close();\n+\t\t\tr = null;\n+\t\t}\n+\t\tcatch (IOException ioe)\n+\t\t{\n+\t\t\tthrow new BuildException(\"Could not read file \" + \nfilename);\n+\t\t}\n+\t\tfinally\n+\t\t{\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\tif (r != null)\n+\t\t\t\t{\n+\t\t\t\t\tr.close();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tcatch (Exception e)\n+\t\t\t{\n+\t\t\t\tthrow new BuildException(\"Could not close \nfile \" + filename);\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n }\n-", "id": 43901, "time": "2003-09-09T17:12:44Z", "creator": "ThorstenMoeller@web.de", "creation_time": "2003-09-09T17:12:44Z", "is_private": false, "attachment_id": null}, {"attachment_id": null, "tags": [], "creator": "antoine@apache.org", "is_private": false, "count": 1, "id": 43973, "time": "2003-09-10T19:12:22Z", "bug_id": 23037, "creation_time": "2003-09-10T19:12:22Z", "text": "Thorsten,\ncan you attach your patch as an attachment, rather than in the body of the bug\nreport. can you also provide a patch for the html documentation and for the\ntestcases."}, {"count": 2, "tags": [], "bug_id": 23037, "text": "Created attachment 8136\nCVS patch (rdiff) against head version", "id": 43990, "time": "2003-09-10T20:32:24Z", "creator": "ThorstenMoeller@web.de", "creation_time": "2003-09-10T20:32:24Z", "is_private": false, "attachment_id": 8136}, {"count": 3, "tags": [], "creator": "ThorstenMoeller@web.de", "attachment_id": null, "is_private": false, "id": 43993, "time": "2003-09-10T20:36:02Z", "bug_id": 23037, "creation_time": "2003-09-10T20:36:02Z", "text": "> can you also provide a patch for the html documentation and for the\n> testcases.\nSorry, I didn't have any of this."}, {"count": 4, "tags": [], "creator": "david.jackman@fastsearch.com", "attachment_id": null, "is_private": false, "id": 109406, "time": "2007-10-16T14:08:47Z", "bug_id": 23037, "creation_time": "2007-10-16T14:08:47Z", "text": "I was just about to write this same enhancement request, but I was going to\nmodify containsregexp to have the same look-and-feel as the matches condition\ninstead of the replaceregexp task.  Which would really make more sense?"}]