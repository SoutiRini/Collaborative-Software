[{"count": 0, "tags": [], "creator": "artonx@yahoo.co.jp", "attachment_id": null, "id": 36529, "time": "2003-05-02T08:50:55Z", "bug_id": 19545, "creation_time": "2003-05-02T08:50:55Z", "is_private": false, "text": "There are 3 problems on CGIServlet.\n1st: need CONTENT_LENGTH variable justification\n the situation: The client's input multibyte character may or may not be \nencoded as a pair of bytes. for example the shift_jis code 0x83-0x65 was \nencoded into \"%83e\" by the user-agent(this was produced by IE6). But re-encoded \ndata from Catalina to CGIServlet was encoded into \"%83%65\". I think it's not a \nproblem but behaviour.\nThe problme is, after changing entire size of the content (because \"%83e\" - \nlength=4, but \"%83%65\" - length = 6), the \"CONTENT_LENGTH\" variable isn't \nadjusted. So the CGI program can't read entire message body, because the \nprogram read within CONTENT_LENGTH bytes as the matter of CGI specification.\nsay \"it must not attempt to read more than CONTENT_LENGTH bytes\" by http://cgi-\nspec.golux.com/cgi-120-00a.html#7.0.\n2nd: It's too late to adjust CONTETN_LENGTH\n CGIServlet modifies CONTETN_LENGTH after the CGI program was executed. I faced \nthe problem that the CGI program start to read CONTENT_LENGTH bytes before \nCGIServlet set modified CONTETN_LENGTH. -- This modification by CGIServlet is \nfrom CGIRunner#getPostInput.\n3rd: CGIRunner#getPostInput put the content twice.\n I think it's bad behaviour because the CGI program read the data twice, and I \ndidn't figure out why the CGIServlet does this.\n\nHere is patch:\ndiff -u CGIServlet.java.org CGIServlet.java\n--- CGIServlet.java.org\tFri May 02 02:57:25 2003\n+++ CGIServlet.java\tFri May 02 17:14:05 2003\n@@ -73,6 +73,7 @@\n import java.io.OutputStream;\n import java.io.InputStreamReader;\n import java.io.OutputStreamWriter;\n+import java.io.ByteArrayOutputStream;\n import java.io.BufferedInputStream;\n import java.io.BufferedOutputStream;\n import java.io.IOException;\n@@ -1584,9 +1585,44 @@\n             cmdAndArgs = perlCommand;\n         }\n \n+      String sContentLength = (String) env.get(\"CONTENT_LENGTH\");\n+      ByteArrayOutputStream contentStream = null;\n+      if(!\"\".equals(sContentLength)) {\n+          byte[] content = new byte[Integer.parseInt(sContentLength)];\n+          int lenRead = stdin.read(content);\n+\t  contentStream = new ByteArrayOutputStream(Integer.parseInt\n(sContentLength));\n+          if (\"POST\".equals(env.get(\"REQUEST_METHOD\"))) {\n+              String paramStr = getPostInput(params);\n+              if (paramStr != null) {\n+                  byte[] paramBytes = paramStr.getBytes();\n+\t\t  contentStream.write(paramBytes);\n+\n+\t\t  int contentLength = paramBytes.length;\n+                  if (lenRead > 0) {\n+                      String lineSep = System.getProperty(\"line.separator\");\n+                      contentStream.write(lineSep.getBytes());\n+                      contentLength = lineSep.length() + lenRead;\n+                  }\n+                  env.put(\"CONTENT_LENGTH\", new Integer(contentLength));\n+              }\n+          }\n+\n+          if (lenRead > 0) {\n+\t      contentStream.write(content, 0, lenRead);\n+          }\n+\t  contentStream.close();\n+      }\n+\n             rt = Runtime.getRuntime();\n             proc = rt.exec(cmdAndArgs.toString(), hashToStringArray(env), wd);\n \n+\n+      if(contentStream != null) {\n+          commandsStdIn = new BufferedOutputStream(proc.getOutputStream());\n+          proc.getOutputStream().write(contentStream.toByteArray());\n+          commandsStdIn.flush();\n+          commandsStdIn.close();\n+      }\n             /*\n              * provide input to cgi\n              * First  -- parameters\n@@ -1649,40 +1685,6 @@\n             }\n             commandsStdIn.flush();\n             commandsStdIn.close();*/\n-      String sContentLength = (String) env.get(\"CONTENT_LENGTH\");\n-      if(!\"\".equals(sContentLength)) {\n-          commandsStdIn = new BufferedOutputStream(proc.getOutputStream());\n-          byte[] content = new byte[Integer.parseInt(sContentLength)];\n-\n-          int lenRead = stdin.read(content);\n-\n-          if (\"POST\".equals(env.get(\"REQUEST_METHOD\"))) {\n-              String paramStr = getPostInput(params);\n-              if (paramStr != null) {\n-                  byte[] paramBytes = paramStr.getBytes();\n-                  commandsStdIn.write(paramBytes);\n-\n-                  int contentLength = paramBytes.length;\n-                  if (lenRead > 0) {\n-                      String lineSep = System.getProperty(\"line.separator\");\n-\n-                      commandsStdIn.write(lineSep.getBytes());\n-\n-                      contentLength = lineSep.length() + lenRead;\n-                  }\n-\n-                  env.put(\"CONTENT_LENGTH\", new Integer(contentLength));\n-              }\n-          }\n-\n-          if (lenRead > 0) {\n-              commandsStdIn.write(content, 0, lenRead);\n-          }\n-\n-\n-          commandsStdIn.flush();\n-          commandsStdIn.close();\n-      }\n \n             /* we want to wait for the process to exit,  Process.waitFor()\n              * is useless in our situation; see\n@@ -1803,26 +1805,23 @@\n         protected String getPostInput(Hashtable params) {\n             String lineSeparator = System.getProperty(\"line.separator\");\n             Enumeration paramNames = params.keys();\n-            StringBuffer postInput = new StringBuffer(\"\");\n             StringBuffer qs = new StringBuffer(\"\");\n             if (paramNames != null && paramNames.hasMoreElements()) {\n                 while (paramNames.hasMoreElements()) {\n                     String k = (String) paramNames.nextElement();\n                     String v = params.get(k).toString();\n                     if ((k.indexOf(\"=\") < 0) && (v.indexOf(\"=\") < 0)) {\n-                        postInput.append(k);\n                         qs.append(k);\n-                        postInput.append(\"=\");\n                         qs.append(\"=\");\n-                        postInput.append(v);\n                         qs.append(v);\n-                        postInput.append(lineSeparator);\n                         qs.append(\"&\");\n                     }\n                 }\n             }\n-            qs.append(lineSeparator);\n-            return qs.append(postInput.toString()).toString();\n+\t    if (qs.charAt(qs.length() - 1) == '&') {\n+\t\tqs.setLength(qs.length() - 1);\n+\t    }\n+            return qs.toString();\n         }"}, {"count": 1, "tags": [], "creator": "markt@apache.org", "text": "This has been fixed in CVS for TC4 and TC5. Many thanks for providing the \npatch.", "id": 55963, "time": "2004-04-17T23:29:30Z", "bug_id": 19545, "creation_time": "2004-04-17T23:29:30Z", "is_private": false, "attachment_id": null}]