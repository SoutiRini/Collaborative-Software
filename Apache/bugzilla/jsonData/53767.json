[{"count": 0, "tags": [], "bug_id": 53767, "attachment_id": 29268, "text": "Created attachment 29268\nstrace output\n\nFor a resource that contains a \"Vary\" header, mod_cache creates a .header file containing the \"vary\" headers, and then creates a subdirectory (<hash>.header.vary), which in turn contains the actual .header and .data files.\n\nAssuming the cache is not above the limit specified by htcacheclean, stale content should remain in place so that it can be while revalidating content or if there's an error (ie CacheStaleOnError behaviour). For non-varying resources, this works fine.\n\nHowever, for resources that \"vary\", it appears there is a bug in htcacheclean. Once the content is stale, it deletes the top level .header file (containing the \"vary\" headers), even if the cache is within limits, meaning mod_cache is unable to serve the stale content (htcacheclean reports \"0 entries deleted\" though). It would appear that creating an empty .data file alongside the .header file prevents this from happening.\n\nI'm attaching the output of the following, for reference, which shows the unlink call at line 173:\nstrace -o ~/strace.out -s 512 htcacheclean -r -v -p /data/httpcache/httpd/ -l 1000k", "id": 161645, "time": "2012-08-23T15:28:43Z", "creator": "andy.hutson+apache@gmail.com", "creation_time": "2012-08-23T15:28:43Z", "is_private": false}, {"count": 1, "tags": [], "text": "Incidentally, this happens with or without the \"-r\" switch.", "attachment_id": null, "bug_id": 53767, "id": 161646, "time": "2012-08-23T16:00:49Z", "creator": "andy.hutson+apache@gmail.com", "creation_time": "2012-08-23T16:00:49Z", "is_private": false}, {"count": 2, "tags": [], "text": "From http://svn.apache.org/repos/asf/httpd/httpd/trunk/support/htcacheclean.c (which is later than the one we're running, but I believe has the same issue); looks like this is the section that's doing it:\n\n        /* single data and header files may be deleted either in realclean\n         * mode or if their modification timestamp is not within a\n         * specified positive or negative offset to the current time.\n         * this handling is necessary due to possible race conditions\n         * between apache and this process\n         */\n        case HEADER:\n            current = apr_time_now();\n            nextpath = apr_pstrcat(p, path, \"/\", d->basename,\n                                   CACHE_HEADER_SUFFIX, NULL);\n            if (apr_file_open(&fd, nextpath, APR_FOPEN_READ | APR_FOPEN_BINARY,\n                              APR_OS_DEFAULT, p) == APR_SUCCESS) {\n                len = sizeof(format);\n                if (apr_file_read_full(fd, &format, len,\n                                       &len) == APR_SUCCESS) {\n                    if (format == VARY_FORMAT_VERSION) {\n                        apr_time_t expires;\n\n                        len = sizeof(expires);\n\n                        if (apr_file_read_full(fd, &expires, len,\n                                               &len) == APR_SUCCESS) {\n                            apr_finfo_t finfo;\n\n                            apr_file_close(fd);\n\n                            if (apr_stat(&finfo, apr_pstrcat(p, nextpath,\n                                    CACHE_VDIR_SUFFIX, NULL), APR_FINFO_TYPE, p)\n                                    || finfo.filetype != APR_DIR) {\n                                delete_entry(path, d->basename, nodes, p);\n                            }\n                            else if (expires < current) {\n                                delete_entry(path, d->basename, nodes, p);\n                            }\n\n                            break;\n                        }\n                    }\n\n\nSpecifically, this part:\n                            else if (expires < current) {\n                                delete_entry(path, d->basename, nodes, p);\n                            }\n\nThis seems to be deleting expired vary header files by design. But this breaks CacheStaleOnError handling, as well as (but to a lesser extent) the stale-while-revalidate function that CacheLock provides, for any resources that vary.\n\nNot sure if there's any reason to be deleting these header files? They'll get deleted later on anyway, in purge(), if the cache is above limits. If there's no other need, should these three lines simply be removed?", "attachment_id": null, "bug_id": 53767, "id": 161658, "time": "2012-08-24T10:54:14Z", "creator": "andy.hutson+apache@gmail.com", "creation_time": "2012-08-24T10:54:14Z", "is_private": false}]