[{"count": 0, "tags": [], "bug_id": 16662, "attachment_id": null, "text": "Example: If you have CookieName set to \"ID\", then use of strstr() in\nspot_cookie() mod_usertrack.c will get false positives on the following sorts of\ncookies: \"MyID=binky\", \"MyCookie=IDExpired\". This bug got \"ported\" from Apache\n1.3: see bugs 16661, 11998, 8906, 8048, 5811. Here is a patch that has been\nthoroughly tested (more details at\nhttp://www.manniwood.net/mod_usertrack_patch.html):\n\n--- mod_usertrack.c\t2002-07-17 12:08:53.000000000 -0400\n+++ mod_usertrack_2.0_fixed.c\t2003-01-31 13:12:59.000000000 -0500\n@@ -125,6 +125,8 @@\n     cookie_type_e style;\n     char *cookie_name;\n     char *cookie_domain;\n+    char *regexp_string;  /* used to compile regexp; save for debugging */\n+    regex_t *regexp;  /* used to find usertrack cookie in cookie header */\n } cookie_dir_rec;\n \n /* Make Cookie: Now we have to generate something that is going to be\n@@ -197,31 +199,44 @@\n {\n     cookie_dir_rec *dcfg = ap_get_module_config(r->per_dir_config,\n \t\t\t\t\t\t&usertrack_module);\n-    const char *cookie;\n-    const char *value;\n+    const char *cookie_header;\n+\n+    /* There are only three possibilities from the regexp\n+     * ^cookie_name=([^;]+)|;[ \\t]+cookie_name=([^;]+)\n+     * because $0 is always filled with the whole match, and $1 and $2 will\n+     * be filled with either of the parenthesis matches. So, I\n+     * allocate regm[3] to cover all these cases. */\n+    regmatch_t regm[3];\n+    int i;\n \n     if (!dcfg->enabled) {\n         return DECLINED;\n     }\n \n-    if ((cookie = apr_table_get(r->headers_in,\n-                                (dcfg->style == CT_COOKIE2\n-                                 ? \"Cookie2\"\n-                                 : \"Cookie\"))))\n-        if ((value = ap_strstr_c(cookie, dcfg->cookie_name))) {\n-            char *cookiebuf, *cookieend;\n-\n-            value += strlen(dcfg->cookie_name) + 1;  /* Skip over the '=' */\n-            cookiebuf = apr_pstrdup(r->pool, value);\n-            cookieend = strchr(cookiebuf, ';');\n-            if (cookieend)\n-                *cookieend = '\\0';      /* Ignore anything after a ; */\n-\n-            /* Set the cookie in a note, for logging */\n-            apr_table_setn(r->notes, \"cookie\", cookiebuf);\n+    if ((cookie_header = apr_table_get(r->headers_in,\n+                                       (dcfg->style == CT_COOKIE2\n+                                        ? \"Cookie2\"\n+                                        : \"Cookie\")))) {\n+       if (!ap_regexec(dcfg->regexp, cookie_header, dcfg->regexp->re_nsub + 1,\nregm, 0)) {\n+           char *cookieval = NULL;\n+           /* Our regexp,\n+            * ^cookie_name=([^;]+)|;[ \\t]+cookie_name=([^;]+)\n+            * only allows for $1 or $2 to be available. ($0 is always\n+            * filled with the entire matched expression, not just\n+            * the part in parentheses.) So just check for either one\n+            * and assign to cookieval if present. */\n+           if (regm[1].rm_so != -1) {\n+               cookieval = ap_pregsub(r->pool, \"$1\", cookie_header,\ndcfg->regexp->re_nsub + 1, regm);\n+           }\n+           if (regm[2].rm_so != -1) {\n+               cookieval = ap_pregsub(r->pool, \"$2\", cookie_header,\ndcfg->regexp->re_nsub + 1, regm);\n+           }\n+           /* Set the cookie in a note, for logging */\n+           apr_table_setn(r->notes, \"cookie\", cookieval);\n \n-            return DECLINED;    /* There's already a cookie, no new one */\n-        }\n+           return DECLINED;    /* There's already a cookie, no new one */\n+       }\n+    }\n     make_cookie(r);\n     return OK;                  /* We set our cookie */\n }\n@@ -330,7 +345,20 @@\n {\n     cookie_dir_rec *dcfg = (cookie_dir_rec *) mconfig;\n \n+    /* The goal is to end up with this regexp,\n+     * ^cookie_name=([^;]+)|;[ \\t]+cookie_name=([^;]+)\n+     * with cookie_name\n+     * obviously substituted with the real cookie name set by the\n+     * user in httpd.conf. */\n+    dcfg->regexp_string = apr_pstrcat(cmd->pool, \"^\", name, \"=([^;]+)|;[ \\t]+\",\nname, \"=([^;]+)\", NULL);\n+\n     dcfg->cookie_name = apr_pstrdup(cmd->pool, name);\n+\n+    dcfg->regexp = ap_pregcomp(cmd->pool, dcfg->regexp_string, REG_EXTENDED);\n+    if (dcfg->regexp == NULL) {\n+       return \"Regular expression could not be compiled.\";\n+    }\n+\n     return NULL;\n }", "id": 30456, "time": "2003-02-01T00:26:16Z", "creator": "manniwood@planet-save.com", "creation_time": "2003-02-01T00:26:16Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 16662, "is_private": false, "id": 30457, "creation_time": "2003-02-01T00:27:27Z", "time": "2003-02-01T00:27:27Z", "creator": "manniwood@planet-save.com", "text": "Created attachment 4675\npatch for spot_cookie() bug in mod_usertrack.c", "attachment_id": 4675}, {"count": 2, "text": "\n\n*** This bug has been marked as a duplicate of 16661 ***", "bug_id": 16662, "is_private": false, "id": 44548, "time": "2003-09-23T22:38:13Z", "creator": "jwoolley@apache.org", "creation_time": "2003-09-23T22:38:13Z", "tags": [], "attachment_id": null}]