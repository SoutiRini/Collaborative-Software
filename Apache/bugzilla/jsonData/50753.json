[{"count": 0, "tags": [], "text": "Using a servlet with asynchronous support enabled and the response headers set just before AsyncContext.complete() method is called fails to send the headers over the wire. More precisely if the headers are set on the HttpServletRequest on a different thread than the request thread the headers are not sent. \n\nA simple test was devised to showcase the issue.\n\nSetting the headers on the request thread before or after the AsyncContext is acquired *succeeds* in sending the headers over the wire: \n\n    protected void doGet(HttpServletRequest request, final HttpServletResponse r) throws ServletException, IOException { \n       final AsyncContext ctx = request.startAsync(); \n        r.setHeader(\"A\", \"xyz\"); \n        r.setContentType(\"text/plain\"); \n        r.setContentLength(\"------\".getBytes().length); \n        r.getWriter().print(\"------\"); \n        ctx.start(new Runnable() { \n            public void run() { \n                try { \n                    Thread.sleep(5000); \n                    ctx.complete(); \n                } catch (Exception e) { \n                    e.printStackTrace();\n                } \n            } \n        }); \n    } \n\nSetting the headers just before the response is sent *does not succeed* in actually sending the headers over the wire: \n\n    protected void doGet(HttpServletRequest request, final HttpServletResponse r) throws ServletException, IOException { \n       final AsyncContext ctx = request.startAsync(); \n        ctx.start(new Runnable() { \n            public void run() { \n                try { \n                    Thread.sleep(5000); \n                    r.setHeader(\"A\", \"xyz\"); \n                    r.setContentType(\"text/plain\"); \n                    r.setContentLength(\"------\".getBytes().length); \n                    r.getWriter().print(\"------\"); \n                    ctx.complete(); \n                } catch (Exception e) { \n                    e.printStackTrace();\n                } \n            } \n        }); \n    }", "attachment_id": null, "bug_id": 50753, "id": 144144, "time": "2011-02-10T12:46:55Z", "creator": "mircea.toma@icesoft.com", "creation_time": "2011-02-10T12:46:55Z", "is_private": false}, {"count": 1, "tags": [], "text": "http://jira.icefaces.org/browse/PUSH-116 is the original issue.", "attachment_id": null, "bug_id": 50753, "id": 144145, "time": "2011-02-10T12:48:05Z", "creator": "mircea.toma@icesoft.com", "creation_time": "2011-02-10T12:48:05Z", "is_private": false}, {"count": 2, "tags": [], "bug_id": 50753, "attachment_id": null, "id": 144156, "time": "2011-02-10T14:43:30Z", "creator": "markt@apache.org", "creation_time": "2011-02-10T14:43:30Z", "is_private": false, "text": "This works for me with the latest Tomcat 7.0.x code and is probably (depending on exactly which change fixed this) fixed in the recently released 7.0.8 as well."}, {"count": 3, "tags": [], "bug_id": 50753, "attachment_id": null, "id": 144161, "time": "2011-02-10T16:55:46Z", "creator": "mircea.toma@icesoft.com", "creation_time": "2011-02-10T16:55:46Z", "is_private": false, "text": "Indeed, I can confirm that headers are sent properly when using Tomcat 7.0.8."}]