[{"count": 0, "tags": [], "text": "Created attachment 31660\nA file for which the problem reproduces\n\nWhen reading two copies of the same file (doesn't necessarily need to be the exact same file, but do need to contain the same styles or something along those lines),\nfrom two threads simultaneously (each thread processes its own file), the format string of cell styles get mixed up.\n\nThe following code demonstrates this, printing to System.out every time a non date cell is mistakenly recognized as date. Note that starting only one of the threads yields no System.out messages.\n\npublic class CellFormatBugExample implements Runnable {\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(new CellFormatBugExample(\"C:/temp/file_1.xls\")).start();\n\t\tnew Thread(new CellFormatBugExample(\"C:/temp/file_2.xls\")).start();\n\t}\n\n\tString filePath;\n\n\tpublic CellFormatBugExample(String filePath) {\n\t\tthis.filePath = filePath;\n\t}\n\n\t@Override\n\tpublic void run() {\n\n\t\tFile inputFile = new File(filePath);\n\t\ttry (FileInputStream stream = new FileInputStream(inputFile)) {\n\n\t\t\tWorkbook wb = WorkbookFactory.create(stream);\n\t\t\tSheet sheet = wb.getSheetAt(0);\n\n\t\t\tfor (Row row : sheet) {\n\t\t\t\tfor (Integer idxCell = 0; idxCell < row.getLastCellNum(); idxCell++) {\n\n\t\t\t\t\tCell cell = row.getCell(idxCell);\n\t\t\t\t\tcell.getCellStyle().getDataFormatString();\n\t\t\t\t\tif (cell.getCellType() == HSSFCell.CELL_TYPE_NUMERIC) {\n\t\t\t\t\t\tboolean isDate = HSSFDateUtil.isCellDateFormatted(cell);\n\t\t\t\t\t\tif (idxCell > 0 && isDate) {\n\t\t\t\t\t\t\tSystem.out.println(\"cell \" + idxCell + \" is not a date!\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n\nMake another copy of the attached file - \"file_2.xls\" and run the code to reproduce.\nDigging around a bit, seems the cause for this is a caching bug in the HSSFCellStyle.getDataFormatString() method.\nAs far as I could understand a simple resolution would be to synchronize access to that method.", "attachment_id": 31660, "bug_id": 56563, "id": 175454, "time": "2014-05-26T07:54:00Z", "creator": "urishe@gmail.com", "creation_time": "2014-05-26T07:54:00Z", "is_private": false}, {"count": 1, "tags": [], "creator": "dominik.stadler@gmx.at", "text": "This was introduced in Bug 55612, unfortunately only a lock on a static object will suffice unless we replace it with something a bit more sophisticated, e.g. a thread-local.", "id": 175474, "time": "2014-05-26T19:15:21Z", "bug_id": 56563, "creation_time": "2014-05-26T19:15:21Z", "is_private": false, "attachment_id": null}, {"attachment_id": null, "tags": [], "bug_id": 56563, "text": "Fixed via r1597637, we now use ThreadLocals to keep the cache and thus avoid multi-threading issues.\n\nThere should not be a huge overhead per Thread as we keep a string, a short and a list of (int+boolean+string), which is replaced for every cache-entry, so it cannot grow unbounded.", "count": 2, "id": 175475, "time": "2014-05-26T20:06:33Z", "creator": "dominik.stadler@gmx.at", "creation_time": "2014-05-26T20:06:33Z", "is_private": false}, {"count": 3, "tags": [], "creator": "dominik.stadler@gmx.at", "is_private": false, "text": "*** Bug 56453 has been marked as a duplicate of this bug. ***", "id": 175477, "time": "2014-05-26T20:17:27Z", "bug_id": 56563, "creation_time": "2014-05-26T20:17:27Z", "attachment_id": null}, {"attachment_id": null, "tags": [], "bug_id": 56563, "text": "A short suggestion - I saw you are trying to avoid synchronization on a static variable here.\n\nNote that every call to DateUtil.isCellDateFormatted(a-numeric-cell) ends up in a call to DateUtil.isADateFormat() which itself also maintains a static cache of the last result and synchronizes on DateUtil.class.\n\nIn my case for example, the issue with the formatString arises by a call to DateUtil.isCellDateFormatted(cell), so I still get monitor locks upon each call even though you use thread locals for the style formatString cache. \n\nSeems like it would be a good idea to use the same strategy and switch the DateUtil.isADateFormat() cache to be ThreadLocal based rather than synchronization based.", "count": 4, "id": 175489, "time": "2014-05-27T06:57:14Z", "creator": "urishe@gmail.com", "creation_time": "2014-05-27T06:57:14Z", "is_private": false}, {"count": 5, "tags": [], "creator": "dominik.stadler@gmx.at", "attachment_id": null, "id": 175686, "time": "2014-06-05T20:15:57Z", "bug_id": 56563, "creation_time": "2014-06-05T20:15:57Z", "is_private": false, "text": "Thanks for the note, I have moved this into a separate Bug 56595 as this one is resolved and the note concerns a different code-location."}]