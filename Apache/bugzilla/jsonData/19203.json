[{"count": 0, "tags": [], "bug_id": 19203, "attachment_id": null, "id": 35729, "time": "2003-04-21T21:49:58Z", "creator": "Terry.Rosenbaum@gmail.com", "creation_time": "2003-04-21T21:49:58Z", "is_private": false, "text": "I've discovered that defining a ValueIndexer with multi-byte\nnumeric types (e.g. long, int, short, etc.) does not work correctly\nwhen resolving relational comparisons other than equals (e.g.\ncan produce incorrect results for gretater than, less than, etc.).\n\nThe reason is that all data is handled as anonymous byte\narrays using the Value class and the Value class has no\ntype associated with the data. Thus, the Value.compareTo method\nis not able to properly perform comparisons for such data. It\nperforms byte-by-byte comparisons of the data.\n\nAs an example, ValueIndexer encodes the value\n1049903940000 as the bytes 0, 0, 0, -12, 115, 38, -63, -96\nand encodes the value 1050687000291 as the bytes\n0, 0, 0, -12, -95, -45, 78, -29. Thus, when comparing\na Value representing 1049903940000 to a Value\nrepresenting 1050687000291  (in pseudocode:\nValue(1049903940000).compareTo(1050687000291)),\nthe incorrect result of 5 is returned indicating that\n1049903940000 is greater than 1050687000291 (which\nis incorrect).\n\nThe problem can be encountered during XPath comparisons\nif a ValueIndexer is defined as a numeric indexer for an\nattribute or element.\n\ne.g. if you define an index to index the Time attribute as type long:\n\n<Bug Time=\"1050687000291\" />\n\n<index name=\"BugIndex\" class=\"org.apache.xindice.core.indexer.ValueIndexer\"\n   pattern=\"Bug@Time\" type=\"long\" />\n\nAnd use an XPath like /Bug[(1049903940000 < @Time) and (1050687000291 > @Time)]\nyou may see incorrect query results.\n\nPart of the problem is in the code of Value.compareTo(Value):\n\n          short s1 = (short)(b1 >>> 0);\n          short s2 = (short)(b2 >>> 0);\n          return s1 > s2 ? (i+1)\n                          : -(i+1);\n\nThis code attempts to shed the sign bits via \">>> 0\" which\nhas no effect. The result is that s1 and s2 are sign-extended\nversions of b1 and b2 and the comparison becomes a signed\ncomparison rather than the desired unsigned comparison.\nThis can be fixed by using:\n\n           int i1 = (int)b1 & 0xff;\n           int i2 = (int)b2 & 0xff;\n           return i1 > i2 ? (i+1)\n                          : -(i+1);\n\nBut, this only fixes the problem for 0 and positive values being\ncompared. It does not work for the entire domain of numeric\nvalues.\n\nOne possible way to fix this would be to add a type field\nto the Value object and perform conversion based on type\nprior to performing comparisons. A drawback of this approach\nwould be that exisiting persisted Value objects (e.g. in existing\ndatabases) would be rendered incompatible."}, {"count": 1, "tags": [], "bug_id": 19203, "attachment_id": null, "id": 38411, "time": "2003-06-05T07:39:08Z", "creator": "Terry.Rosenbaum@gmail.com", "creation_time": "2003-06-05T07:39:08Z", "is_private": false, "text": "Another possible way to fix this might\nbe through the use of a comparator\nfunction. One might alter IndexQuery\nto allow the setting of a comparator\nfor Value objects. The ValueIndexer\ncould set the comparator to the proper\ncomparator for the index type (string,\ninteger, long, boolean, etc.) in its\nqueryMatches method. This might be a\nfeasible solution allowing\nbackwards compatibility with existing\npersisted databases."}, {"count": 2, "tags": [], "bug_id": 19203, "text": "As was discussed in a recent thread on the mail list, backwards compatibility \nmeans an export and import, so we can consider your solution, or that may \nuntie your hands as far as the 'best' solution goes.", "id": 38954, "time": "2003-06-17T04:35:35Z", "creator": "Kevin.Ross@iVerticalLeap.com", "creation_time": "2003-06-17T04:35:35Z", "is_private": false, "attachment_id": null}, {"count": 3, "tags": [], "bug_id": 19203, "text": "Created attachment 19143\nPatch\n\nHere is the possible solution - to encode values depending on type of indexer\nin the way they can be compared as byte arrays. Please note that it does not\nfix existing indexers, so indexes have to be recreated.", "id": 95982, "attachment_id": 19143, "creator": "nshilenkova@gmail.com", "creation_time": "2006-11-19T11:44:52Z", "time": "2006-11-19T11:44:52Z", "is_private": false}, {"count": 4, "tags": [], "bug_id": 19203, "attachment_id": null, "id": 95983, "time": "2006-11-19T11:53:52Z", "creator": "nshilenkova@gmail.com", "creation_time": "2006-11-19T11:53:52Z", "is_private": false, "text": "One more thing, in the patch I changed the way float/double are handled, instead\nof storing only 4 digits after the dot, it will store full range of values\nallowed  for float/double.\n\nIndexer types short, integer, and long will always use 8 bytes to store the\nvalue, and both float and double use 8 bytes. Does it make a sense to change it\nso value takes exact amount of space - 2 byte for short, 4 bytes for integer and\nso on?\n"}, {"count": 5, "tags": [], "bug_id": 19203, "attachment_id": 19145, "id": 95985, "time": "2006-11-19T14:31:52Z", "creator": "nshilenkova@gmail.com", "creation_time": "2006-11-19T14:31:52Z", "is_private": false, "text": "Created attachment 19145\nTestcase"}, {"count": 6, "tags": [], "bug_id": 19203, "text": "(In reply to comment #3)\n> Here is the possible solution - to encode values depending on type of indexer\n> in the way they can be compared as byte arrays. Please note that it does not\n> fix existing indexers, so indexes have to be recreated. \n\nThis patch changes the way how Values are compared, and as a result all\ncollections using BTree filer (not only indexes) have to be re-created.\n\nCan existing import/export be a solution for an upgrade, or do we need an\nupgrade utility?", "id": 96185, "time": "2006-11-26T14:54:44Z", "creator": "vgritsenko@apache.org", "creation_time": "2006-11-26T14:54:44Z", "is_private": false, "attachment_id": null}, {"count": 7, "tags": [], "bug_id": 19203, "attachment_id": 19309, "text": "Created attachment 19309\nIndexer patch for numerical values", "id": 97387, "time": "2006-12-27T18:03:16Z", "creator": "nshilenkova@gmail.com", "creation_time": "2006-12-27T18:03:16Z", "is_private": false}, {"count": 8, "tags": [], "bug_id": 19203, "attachment_id": 19310, "text": "Created attachment 19310\nTestcase", "id": 97388, "time": "2006-12-27T18:07:41Z", "creator": "nshilenkova@gmail.com", "creation_time": "2006-12-27T18:07:41Z", "is_private": false}, {"count": 9, "tags": [], "bug_id": 19203, "text": "Created attachment 19311\nRebuild collection/index utility", "id": 97389, "time": "2006-12-27T18:10:29Z", "creator": "nshilenkova@gmail.com", "creation_time": "2006-12-27T18:10:29Z", "is_private": false, "attachment_id": 19311}, {"count": 10, "tags": [], "text": "Looks good, patch applied (with minor changes).\n\nHowever, some more work is still needed on (how it is now called)\nDatabaseRebuild utility. Need some shell script so it is more convenient to use.\nWould be nice to have single step process, with copy & re-indexing done in one\nstep. Better usage documentation.\n\nLooking forward to new patches! :)", "attachment_id": null, "bug_id": 19203, "id": 98808, "time": "2007-01-30T17:09:12Z", "creator": "vgritsenko@apache.org", "creation_time": "2007-01-30T17:09:12Z", "is_private": false}, {"count": 11, "attachment_id": null, "creator": "vgritsenko@apache.org", "text": "(closing this bug as indexing is working now. pls create new issue for any\nfollow up patches).", "id": 98809, "time": "2007-01-30T17:09:57Z", "bug_id": 19203, "creation_time": "2007-01-30T17:09:57Z", "tags": [], "is_private": false}]