[{"count": 0, "tags": [], "creator": "wpitman@hotmail.com", "attachment_id": null, "is_private": false, "id": 36723, "time": "2003-05-05T21:38:12Z", "bug_id": 19684, "creation_time": "2003-05-05T21:38:12Z", "text": "log4j 1.2.8\n\nI see that the NDC methods have a lazyRemove method to clean up context \ninformation for threads that have already died.  \n\nI don't see how this code works correctly, as the lazyRemove method will stop \nafter finding 4 threads that are alive, and does not traverse the entire set of \nNDC entries.  It is quite likely that the same 4 entries will be checked each \ntime the lazyRemove is called (depending on the hash order, etc).\n\nI run a server where threads are created and terminated on a regular basis, \nhopefully few or none of these will have failed to call NDC.remove().  My \nserver also has a large number of steady state threads which also use NDC.  In \nsuch an environment, it does not appear that the lazyRemove() method will catch \nand clean up NDC data for expired threads.\n  \n\nAm I missing something, or is lazyRemove a bit too lazy?  \n\nPS: Great job on log4j!"}, {"count": 1, "tags": [], "text": "LazyRemove gives up after 4 straigt missses, that is 4 consecutive\ninspected threads in 'ht' that turn out to be alive.\n\nThe higher the proportion on dead threads in ht, the higher the chances of \nremoval. lazyRemove might not catch all dead threads in one go but it will \ncatch them eventually.\n\n", "attachment_id": null, "bug_id": 19684, "id": 36725, "time": "2003-05-05T22:05:50Z", "creator": "ceki@apache.org", "creation_time": "2003-05-05T22:05:50Z", "is_private": false}, {"count": 2, "tags": [], "bug_id": 19684, "text": "Created attachment 6259\nTest program to illustrate resource leak in NDC class.", "id": 36850, "time": "2003-05-07T16:38:23Z", "creator": "wpitman@hotmail.com", "creation_time": "2003-05-07T16:38:23Z", "is_private": false, "attachment_id": 6259}, {"count": 3, "tags": [], "creator": "wpitman@hotmail.com", "attachment_id": null, "is_private": false, "id": 36852, "time": "2003-05-07T16:41:24Z", "bug_id": 19684, "creation_time": "2003-05-07T16:41:24Z", "text": "The attached program illustrates conditions where by lazyRemove will fail to \nremove all dead entries, regardless of how many times it tries.\n\nCompile and run the program as such:\n\njava -cp log4j.jar  NDCTester 100 5 100\n\nTo create 100 threads that set NDC data but never termainte\nTo create 5 threads that set NDC data but terminate without calling NDC.remove()\nTo create 100 threads that set NDC data and do all NDC.remove()\n\nThe debug output from NDC.lazyRemove will show how many of the dead threads \nwere reaped.  In this case, none of the 5 threads are removed by lazyRemove.\n\n\n"}, {"count": 4, "tags": [], "bug_id": 19684, "attachment_id": null, "id": 36854, "creation_time": "2003-05-07T17:16:20Z", "time": "2003-05-07T17:16:20Z", "creator": "ceki@apache.org", "text": "\nVery nice try but I remain unconvinced. :-)\n\nWhen you create 100 threads that never die and 5 that leak, catching leaking \ntheads is more difficult because they are proportionally few. However, if the \nnumber of leaking threads increases then the probability of catching them \nincreases. This is actually demonstrated by NDCTester.\n\nSo running \n\n java -cp log4j.jar  NDCTester 100 180 100\n\nwill work as expected. \n\nAs the number of leaking threads increases so does the probability of lazily \ncatching and removing them.\n\nOne could devise fiendish cases to defeat the lazy removal algoritm such that \nthreads land in specific placed in 'ht' hashmap. But these contrived cases will \nheavily depend on the Hashmap implementation and the implementation of the \nThread.hashcode method of the JDK being used. I think that for any real world \nsystem the existing lazy removal algorithm will work just fine.\n\nNice but no cigar. :-)\n", "is_private": false}]