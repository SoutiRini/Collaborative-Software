[{"attachment_id": null, "tags": [], "bug_id": 38116, "text": "I created a SuExec Modification, which chroots first to the User-Homedir and \nthen executes the cgi-script (kind of \"mpm_peruser\", but faster on machines \nwith low memory)\n\nThe Interpreter(s) are needed to be in the jail too, otherwise it can't \nexecute the script then.\n\nI created it with httpd 2.0.55, but it should work on other versions too.\n\nIt works for example if you have such a directory structure:\n\n/srv/www\n/srv/www/vhosts\n/srv/www/vhosts/user1\n/srv/www/vhosts/user1/htdocs\n/srv/www/vhosts/user2\n/srv/www/vhosts/user2/htdocs\n\nSo a request for \"user1\" will be chrooted first to /srv/www/vhosts/user1, and \nthen it will execute the specified script in that directory.\n\nSincerely\nF. D.\n\n---\n\ndiff -urN httpd-2.0.55-orig/support/suexec.c httpd-2.0.55/support/suexec.c\n--- httpd-2.0.55-orig/support/suexec.c\t2005-02-04 21:21:18.000000000 +0100\n+++ httpd-2.0.55/support/suexec.c\t2006-01-04 10:02:21.017195966 +0100\n@@ -1,34 +1,34 @@\n /* Copyright 1999-2005 The Apache Software Foundation or its licensors, as\n- * applicable.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n+* applicable.\n+*\n+* Licensed under the Apache License, Version 2.0 (the \"License\");\n+* you may not use this file except in compliance with the License.\n+* You may obtain a copy of the License at\n+*\n+*     http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n \n /*\n- * suexec.c -- \"Wrapper\" support program for suEXEC behaviour for Apache\n- *\n- ***********************************************************************\n- *\n- * NOTE! : DO NOT edit this code!!!  Unless you know what you are doing,\n- *         editing this code might open up your system in unexpected \n- *         ways to would-be crackers.  Every precaution has been taken \n- *         to make this code as safe as possible; alter it at your own\n- *         risk.\n- *\n- ***********************************************************************\n- *\n- *\n- */\n+* suexec.c -- \"Wrapper\" support program for suEXEC behaviour for Apache\n+*\n+***********************************************************************\n+*\n+* NOTE! : DO NOT edit this code!!!  Unless you know what you are doing,\n+*         editing this code might open up your system in unexpected \n+*         ways to would-be crackers.  Every precaution has been taken \n+*         to make this code as safe as possible; alter it at your own\n+*         risk.\n+*\n+***********************************************************************\n+*\n+*\n+*/\n \n #include \"apr.h\"\n #include \"ap_config.h\"\n@@ -55,21 +55,166 @@\n #include <grp.h>\n #endif\n \n+\n+/**********************/\n+/* CHROOT Data, Begin */\n+\n+#ifdef MAXPATHLEN\n+#define PATH_LEN MAXPATHLEN\n+#else\n+#define PATH_LEN PATH_MAX\n+#endif\n+\n+#define PASSWD_FILE     \"/etc/passwd\"\n+#define LINE_SZ         256\n+\n+struct passwd_data_s {\n+  char *login;\n+  char *pass;\n+  int  id;\n+  int  gid;\n+  char *gecos;\n+  char *dir;\n+  char *shell;\n+};\n+\n+typedef struct passwd_data_s passwd_data;\n+\n+/**********************/\n+\n+void free_passwd_data(passwd_data *p) {\n+\n+  if (p == NULL)\n+    return;\n+\n+  if (p->login!=NULL) free(p->login);\n+  if (p->pass!=NULL)  free(p->pass);\n+  if (p->gecos!=NULL) free(p->gecos);\n+  if (p->dir!=NULL)   free(p->dir);\n+  if (p->shell!=NULL) free(p->shell);\n+\n+  free(p);\n+}\n+\n+int fill_from_string(char *str, passwd_data *data) {\n+  char *p = str;\n+  char buff[LINE_SZ];\n+  int n = 0;\n+  int state = 0;\n+\n+  memset(buff,'\\0',LINE_SZ);\n+\n+  while (*p != '\\0') {\n+\n+    if ((*p == ':') || (*p == '\\n')) {\n+      switch (state) {\n+      case 0: \n+        data->login = (char *)malloc(strlen(buff)+1);\n+        memset(data->login,'\\0',strlen(buff)+1);\n+        strcpy(data->login,buff);\n+        break;\n+      case 1: \n+        data->pass = (char *)malloc(strlen(buff)+1);\n+        memset(data->pass,'\\0',strlen(buff)+1);\n+        strcpy(data->pass,buff);\n+        break;\n+      case 2: \n+        data->id = atoi(buff);\n+        break;\n+      case 3: \n+        data->gid = atoi(buff);\n+        break;\n+      case 4: \n+        data->gecos = (char *)malloc(strlen(buff)+1);\n+        memset(data->gecos,'\\0',strlen(buff)+1);\n+        strcpy(data->gecos,buff);\n+        break;\n+      case 5: \n+        data->dir = (char *)malloc(strlen(buff)+1);\n+        memset(data->dir,'\\0',strlen(buff)+1);\n+        strcpy(data->dir,buff);\n+        break;\n+      case 6: \n+        data->shell = (char *)malloc(strlen(buff)+1);\n+        memset(data->shell,'\\0',strlen(buff)+1);\n+        strncpy(data->shell,buff,strlen(buff));\n+        break;\n+      }\n+\n+      memset(buff,'\\0',LINE_SZ);\n+      n=0;\n+      state++;\n+    }\n+    else {\n+      buff[n] = *p;\n+      n++;\n+    }\n+\n+    p++;\n+  }\n+\n+  if (state > 6) \n+    return(1);\n+\n+  return(0);\n+}\n+\n+passwd_data *getpasswddata(int uid) {\n+  char line[LINE_SZ];\n+  passwd_data *pd = NULL;\n+  FILE *f = NULL;\n+\n+  f = fopen(PASSWD_FILE,\"r\");\n+\n+  if (!f) \n+    return(pd);\n+\n+  while (!feof(f)) {\n+\n+    memset(line,'\\0',LINE_SZ);\n+\n+    if (fgets(line,LINE_SZ,f)==NULL) {\n+      pd = NULL;\n+      break;\n+    }\n+\n+    pd = (passwd_data *)malloc(sizeof(passwd_data));\n+    memset(pd,'\\0',sizeof(passwd_data));\n+\n+    if (!fill_from_string(line,pd)) {\n+      free_passwd_data(pd);\n+      continue;\n+    }\n+\n+    if (pd->id == uid) \n+      break;\n+\n+    free_passwd_data(pd);\n+  } \n+\n+  fclose(f);\n+  return(pd);\n+\n+};\n+\n+/* CHROOT Data, End   */\n+/**********************/\n+\n /*\n- ***********************************************************************\n- * There is no initgroups() in QNX, so I believe this is safe :-)\n- * Use cc -osuexec -3 -O -mf -DQNX suexec.c to compile.\n- *\n- * May 17, 1997.\n- * Igor N. Kovalenko -- infoh@mail.wplus.net\n- ***********************************************************************\n- */\n+***********************************************************************\n+* There is no initgroups() in QNX, so I believe this is safe :-)\n+* Use cc -osuexec -3 -O -mf -DQNX suexec.c to compile.\n+*\n+* May 17, 1997.\n+* Igor N. Kovalenko -- infoh@mail.wplus.net\n+***********************************************************************\n+*/\n \n #if defined(NEED_INITGROUPS)\n int initgroups(const char *name, gid_t basegid)\n {\n-    /* QNX and MPE do not appear to support supplementary groups. */\n-    return 0;\n+  /* QNX and MPE do not appear to support supplementary groups. */\n+  return 0;\n }\n #endif\n \n@@ -93,527 +238,583 @@\n \n char *safe_env_lst[] =\n {\n-    /* variable name starts with */\n-    \"HTTP_\",\n-    \"SSL_\",\n-\n-    /* variable name is */\n-    \"AUTH_TYPE=\",\n-    \"CONTENT_LENGTH=\",\n-    \"CONTENT_TYPE=\",\n-    \"DATE_GMT=\",\n-    \"DATE_LOCAL=\",\n-    \"DOCUMENT_NAME=\",\n-    \"DOCUMENT_PATH_INFO=\",\n-    \"DOCUMENT_ROOT=\",\n-    \"DOCUMENT_URI=\",\n-    \"FILEPATH_INFO=\",\n-    \"GATEWAY_INTERFACE=\",\n-    \"HTTPS=\",\n-    \"LAST_MODIFIED=\",\n-    \"PATH_INFO=\",\n-    \"PATH_TRANSLATED=\",\n-    \"QUERY_STRING=\",\n-    \"QUERY_STRING_UNESCAPED=\",\n-    \"REMOTE_ADDR=\",\n-    \"REMOTE_HOST=\",\n-    \"REMOTE_IDENT=\",\n-    \"REMOTE_PORT=\",\n-    \"REMOTE_USER=\",\n-    \"REDIRECT_QUERY_STRING=\",\n-    \"REDIRECT_REMOTE_USER=\",\n-    \"REDIRECT_STATUS=\",\n-    \"REDIRECT_URL=\",\n-    \"REQUEST_METHOD=\",\n-    \"REQUEST_URI=\",\n-    \"SCRIPT_FILENAME=\",\n-    \"SCRIPT_NAME=\",\n-    \"SCRIPT_URI=\",\n-    \"SCRIPT_URL=\",\n-    \"SERVER_ADMIN=\",\n-    \"SERVER_NAME=\",\n-    \"SERVER_ADDR=\",\n-    \"SERVER_PORT=\",\n-    \"SERVER_PROTOCOL=\",\n-    \"SERVER_SIGNATURE=\",\n-    \"SERVER_SOFTWARE=\",\n-    \"UNIQUE_ID=\",\n-    \"USER_NAME=\",\n-    \"TZ=\",\n-    NULL\n+  /* variable name starts with */\n+  \"HTTP_\",\n+  \"SSL_\",\n+\n+  /* variable name is */\n+  \"AUTH_TYPE=\",\n+  \"CONTENT_LENGTH=\",\n+  \"CONTENT_TYPE=\",\n+  \"DATE_GMT=\",\n+  \"DATE_LOCAL=\",\n+  \"DOCUMENT_NAME=\",\n+  \"DOCUMENT_PATH_INFO=\",\n+  \"DOCUMENT_ROOT=\",\n+  \"DOCUMENT_URI=\",\n+  \"FILEPATH_INFO=\",\n+  \"GATEWAY_INTERFACE=\",\n+  \"HTTPS=\",\n+  \"LAST_MODIFIED=\",\n+  \"PATH_INFO=\",\n+  \"PATH_TRANSLATED=\",\n+  \"QUERY_STRING=\",\n+  \"QUERY_STRING_UNESCAPED=\",\n+  \"REMOTE_ADDR=\",\n+  \"REMOTE_HOST=\",\n+  \"REMOTE_IDENT=\",\n+  \"REMOTE_PORT=\",\n+  \"REMOTE_USER=\",\n+  \"REDIRECT_QUERY_STRING=\",\n+  \"REDIRECT_REMOTE_USER=\",\n+  \"REDIRECT_STATUS=\",\n+  \"REDIRECT_URL=\",\n+  \"REQUEST_METHOD=\",\n+  \"REQUEST_URI=\",\n+  \"SCRIPT_FILENAME=\",\n+  \"SCRIPT_NAME=\",\n+  \"SCRIPT_URI=\",\n+  \"SCRIPT_URL=\",\n+  \"SERVER_ADMIN=\",\n+  \"SERVER_NAME=\",\n+  \"SERVER_ADDR=\",\n+  \"SERVER_PORT=\",\n+  \"SERVER_PROTOCOL=\",\n+  \"SERVER_SIGNATURE=\",\n+  \"SERVER_SOFTWARE=\",\n+  \"UNIQUE_ID=\",\n+  \"USER_NAME=\",\n+  \"TZ=\",\n+  NULL\n };\n \n \n static void err_output(const char *fmt, va_list ap)\n {\n #ifdef AP_LOG_EXEC\n-    time_t timevar;\n-    struct tm *lt;\n+  time_t timevar;\n+  struct tm *lt;\n \n-    if (!log) {\n-        if ((log = fopen(AP_LOG_EXEC, \"a\")) == NULL) {\n-            fprintf(stderr, \"failed to open log file\\n\");\n-            perror(\"fopen\");\n-            exit(1);\n-        }\n+  if (!log) {\n+    if ((log = fopen(AP_LOG_EXEC, \"a\")) == NULL) {\n+      fprintf(stderr, \"failed to open log file %s\\n\",AP_LOG_EXEC);\n+      perror(\"fopen\");\n+      exit(1);\n     }\n+  }\n \n-    time(&timevar);\n-    lt = localtime(&timevar);\n+  time(&timevar);\n+  lt = localtime(&timevar);\n \n-    fprintf(log, \"[%d-%.2d-%.2d %.2d:%.2d:%.2d]: \",\n-            lt->tm_year + 1900, lt->tm_mon + 1, lt->tm_mday,\n-            lt->tm_hour, lt->tm_min, lt->tm_sec);\n+  fprintf(log, \"[%d-%.2d-%.2d %.2d:%.2d:%.2d]: \",\n+    lt->tm_year + 1900, lt->tm_mon + 1, lt->tm_mday,\n+    lt->tm_hour, lt->tm_min, lt->tm_sec);\n \n-    vfprintf(log, fmt, ap);\n+  vfprintf(log, fmt, ap);\n \n-    fflush(log);\n+  fflush(log);\n #endif /* AP_LOG_EXEC */\n-    return;\n+  return;\n }\n \n static void log_err(const char *fmt,...)\n {\n #ifdef AP_LOG_EXEC\n-    va_list ap;\n+  va_list ap;\n \n-    va_start(ap, fmt);\n-    err_output(fmt, ap);\n-    va_end(ap);\n+  va_start(ap, fmt);\n+  err_output(fmt, ap);\n+  va_end(ap);\n #endif /* AP_LOG_EXEC */\n-    return;\n+  return;\n }\n \n static void clean_env(void)\n {\n-    char pathbuf[512];\n-    char **cleanenv;\n-    char **ep;\n-    int cidx = 0;\n-    int idx;\n-\n-    /* While cleaning the environment, the environment should be clean.\n-     * (e.g. malloc() may get the name of a file for writing debugging info.\n-     * Bad news if MALLOC_DEBUG_FILE is set to /etc/passwd.  Sprintf() may be\n-     * susceptible to bad locale settings....)\n-     * (from PR 2790)\n-     */\n-    char **envp = environ;\n-    char *empty_ptr = NULL;\n- \n-    environ = &empty_ptr; /* VERY safe environment */\n-\n-    if ((cleanenv = (char **) calloc(AP_ENVBUF, sizeof(char *))) == NULL) {\n-        log_err(\"failed to malloc memory for environment\\n\");\n-        exit(120);\n-    }\n-\n-    sprintf(pathbuf, \"PATH=%s\", AP_SAFE_PATH);\n-    cleanenv[cidx] = strdup(pathbuf);\n-    cidx++;\n-\n-    for (ep = envp; *ep && cidx < AP_ENVBUF-1; ep++) {\n-        for (idx = 0; safe_env_lst[idx]; idx++) {\n-            if (!strncmp(*ep, safe_env_lst[idx],\n-                         strlen(safe_env_lst[idx]))) {\n-                cleanenv[cidx] = *ep;\n-                cidx++;\n-                break;\n-            }\n-        }\n+  char pathbuf[512];\n+  char **cleanenv;\n+  char **ep;\n+  int cidx = 0;\n+  int idx;\n+\n+  /* While cleaning the environment, the environment should be clean.\n+  * (e.g. malloc() may get the name of a file for writing debugging info.\n+  * Bad news if MALLOC_DEBUG_FILE is set to /etc/passwd.  Sprintf() may be\n+  * susceptible to bad locale settings....)\n+  * (from PR 2790)\n+  */\n+  char **envp = environ;\n+  char *empty_ptr = NULL;\n+\n+  environ = &empty_ptr; /* VERY safe environment */\n+\n+  if ((cleanenv = (char **) calloc(AP_ENVBUF, sizeof(char *))) == NULL) {\n+    log_err(\"failed to malloc memory for environment\\n\");\n+    exit(120);\n+  }\n+\n+  sprintf(pathbuf, \"PATH=%s\", AP_SAFE_PATH);\n+  cleanenv[cidx] = strdup(pathbuf);\n+  cidx++;\n+\n+  for (ep = envp; *ep && cidx < AP_ENVBUF-1; ep++) {\n+    for (idx = 0; safe_env_lst[idx]; idx++) {\n+      if (!strncmp(*ep, safe_env_lst[idx],\n+        strlen(safe_env_lst[idx]))) {\n+          cleanenv[cidx] = *ep;\n+          cidx++;\n+          break;\n+      }\n     }\n+  }\n \n-    cleanenv[cidx] = NULL;\n+  cleanenv[cidx] = NULL;\n \n-    environ = cleanenv;\n+  environ = cleanenv;\n }\n \n int main(int argc, char *argv[])\n {\n-    int userdir = 0;        /* ~userdir flag             */\n-    uid_t uid;              /* user information          */\n-    gid_t gid;              /* target group placeholder  */\n-    char *target_uname;     /* target user name          */\n-    char *target_gname;     /* target group name         */\n-    char *target_homedir;   /* target home directory     */\n-    char *actual_uname;     /* actual user name          */\n-    char *actual_gname;     /* actual group name         */\n-    char *prog;             /* name of this program      */\n-    char *cmd;              /* command to be executed    */\n-    char cwd[AP_MAXPATH];   /* current working directory */\n-    char dwd[AP_MAXPATH];   /* docroot working directory */\n-    struct passwd *pw;      /* password entry holder     */\n-    struct group *gr;       /* group entry holder        */\n-    struct stat dir_info;   /* directory info holder     */\n-    struct stat prg_info;   /* program info holder       */\n-\n-    /*\n-     * Start with a \"clean\" environment\n-     */\n-    clean_env();\n-\n-    prog = argv[0];\n-    /*\n-     * Check existence/validity of the UID of the user\n-     * running this program.  Error out if invalid.\n-     */\n-    uid = getuid();\n-    if ((pw = getpwuid(uid)) == NULL) {\n-        log_err(\"crit: invalid uid: (%ld)\\n\", uid);\n-        exit(102);\n-    }\n-    /*\n-     * See if this is a 'how were you compiled' request, and\n-     * comply if so.\n-     */\n-    if ((argc > 1)\n-        && (! strcmp(argv[1], \"-V\"))\n-        && ((uid == 0)\n+  /**********************/\n+  /* CHROOT Vars, Begin */\n+  int ret;\n+  passwd_data *pwdent;\n+  char *tmp_str;\n+  /* CHROOT Vars, End   */\n+  /**********************/\n+\n+\n+  int userdir = 0;        /* ~userdir flag             */\n+  uid_t uid;              /* user information          */\n+  gid_t gid;              /* target group placeholder  */\n+  char *target_uname;     /* target user name          */\n+  char *target_gname;     /* target group name         */\n+  char *target_homedir;   /* target home directory     */\n+  char *actual_uname;     /* actual user name          */\n+  char *actual_gname;     /* actual group name         */\n+  char *prog;             /* name of this program      */\n+  char *cmd;              /* command to be executed    */\n+  char cwd[AP_MAXPATH];   /* current working directory */\n+  char dwd[AP_MAXPATH];   /* docroot working directory */\n+  struct passwd *pw;      /* password entry holder     */\n+  struct group *gr;       /* group entry holder        */\n+  struct stat dir_info;   /* directory info holder     */\n+  struct stat prg_info;   /* program info holder       */\n+\n+  /*\n+  * Start with a \"clean\" environment\n+  */\n+  clean_env();\n+\n+  prog = argv[0];\n+  /*\n+  * Check existence/validity of the UID of the user\n+  * running this program.  Error out if invalid.\n+  */\n+  uid = getuid();\n+  if ((pw = getpwuid(uid)) == NULL) {\n+    log_err(\"crit: invalid uid: (%ld)\\n\", uid);\n+    exit(102);\n+  }\n+  /*\n+  * See if this is a 'how were you compiled' request, and\n+  * comply if so.\n+  */\n+  if ((argc > 1)\n+    && (! strcmp(argv[1], \"-V\"))\n+    && ((uid == 0)\n #ifdef _OSD_POSIX\n-        /* User name comparisons are case insensitive on BS2000/OSD */\n-            || (! strcasecmp(AP_HTTPD_USER, pw->pw_name)))\n+    /* User name comparisons are case insensitive on BS2000/OSD */\n+    || (! strcasecmp(AP_HTTPD_USER, pw->pw_name)))\n #else  /* _OSD_POSIX */\n-            || (! strcmp(AP_HTTPD_USER, pw->pw_name)))\n+    || (! strcmp(AP_HTTPD_USER, pw->pw_name)))\n #endif /* _OSD_POSIX */\n-        ) {\n+    ) {\n #ifdef AP_DOC_ROOT\n-        fprintf(stderr, \" -D AP_DOC_ROOT=\\\"%s\\\"\\n\", AP_DOC_ROOT);\n+      fprintf(stderr, \" -D AP_DOC_ROOT=\\\"%s\\\"\\n\", AP_DOC_ROOT);\n #endif\n #ifdef AP_GID_MIN\n-        fprintf(stderr, \" -D AP_GID_MIN=%d\\n\", AP_GID_MIN);\n+      fprintf(stderr, \" -D AP_GID_MIN=%d\\n\", AP_GID_MIN);\n #endif\n #ifdef AP_HTTPD_USER\n-        fprintf(stderr, \" -D AP_HTTPD_USER=\\\"%s\\\"\\n\", AP_HTTPD_USER);\n+      fprintf(stderr, \" -D AP_HTTPD_USER=\\\"%s\\\"\\n\", AP_HTTPD_USER);\n #endif\n #ifdef AP_LOG_EXEC\n-        fprintf(stderr, \" -D AP_LOG_EXEC=\\\"%s\\\"\\n\", AP_LOG_EXEC);\n+      fprintf(stderr, \" -D AP_LOG_EXEC=\\\"%s\\\"\\n\", AP_LOG_EXEC);\n #endif\n #ifdef AP_SAFE_PATH\n-        fprintf(stderr, \" -D AP_SAFE_PATH=\\\"%s\\\"\\n\", AP_SAFE_PATH);\n+      fprintf(stderr, \" -D AP_SAFE_PATH=\\\"%s\\\"\\n\", AP_SAFE_PATH);\n #endif\n #ifdef AP_SUEXEC_UMASK\n-        fprintf(stderr, \" -D AP_SUEXEC_UMASK=%03o\\n\", AP_SUEXEC_UMASK);\n+      fprintf(stderr, \" -D AP_SUEXEC_UMASK=%03o\\n\", AP_SUEXEC_UMASK);\n #endif\n #ifdef AP_UID_MIN\n-        fprintf(stderr, \" -D AP_UID_MIN=%d\\n\", AP_UID_MIN);\n+      fprintf(stderr, \" -D AP_UID_MIN=%d\\n\", AP_UID_MIN);\n #endif\n #ifdef AP_USERDIR_SUFFIX\n-        fprintf(stderr, \" -D AP_USERDIR_SUFFIX=\\\"%s\\\"\\n\", AP_USERDIR_SUFFIX);\n+      fprintf(stderr, \" -D AP_USERDIR_SUFFIX=\\\"%s\\\"\\n\", AP_USERDIR_SUFFIX);\n #endif\n-        exit(0);\n-    }\n-    /*\n-     * If there are a proper number of arguments, set\n-     * all of them to variables.  Otherwise, error out.\n-     */\n-    if (argc < 4) {\n-        log_err(\"too few arguments\\n\");\n-        exit(101);\n-    }\n-    target_uname = argv[1];\n-    target_gname = argv[2];\n-    cmd = argv[3];\n-\n-    /*\n-     * Check to see if the user running this program\n-     * is the user allowed to do so as defined in\n-     * suexec.h.  If not the allowed user, error out.\n-     */\n+      exit(0);\n+  }\n+  /*\n+  * If there are a proper number of arguments, set\n+  * all of them to variables.  Otherwise, error out.\n+  */\n+  if (argc < 4) {\n+    log_err(\"too few arguments\\n\");\n+    exit(101);\n+  }\n+  target_uname = argv[1];\n+  target_gname = argv[2];\n+  cmd = argv[3];\n+\n+  /*\n+  * Check to see if the user running this program\n+  * is the user allowed to do so as defined in\n+  * suexec.h.  If not the allowed user, error out.\n+  */\n #ifdef _OSD_POSIX\n-    /* User name comparisons are case insensitive on BS2000/OSD */\n-    if (strcasecmp(AP_HTTPD_USER, pw->pw_name)) {\n-        log_err(\"user mismatch (%s instead of %s)\\n\", pw->pw_name, \nAP_HTTPD_USER);\n-        exit(103);\n-    }\n+  /* User name comparisons are case insensitive on BS2000/OSD */\n+  if (strcasecmp(AP_HTTPD_USER, pw->pw_name)) {\n+    log_err(\"user mismatch (%s instead of %s)\\n\", pw->pw_name, AP_HTTPD_USER);\n+    exit(103);\n+  }\n #else  /*_OSD_POSIX*/\n-    if (strcmp(AP_HTTPD_USER, pw->pw_name)) {\n-        log_err(\"user mismatch (%s instead of %s)\\n\", pw->pw_name, \nAP_HTTPD_USER);\n-        exit(103);\n-    }\n+  if (strcmp(AP_HTTPD_USER, pw->pw_name)) {\n+    log_err(\"user mismatch (%s instead of %s)\\n\", pw->pw_name, AP_HTTPD_USER);\n+    exit(103);\n+  }\n #endif /*_OSD_POSIX*/\n \n-    /*\n-     * Check for a leading '/' (absolute path) in the command to be executed,\n-     * or attempts to back up out of the current directory,\n-     * to protect against attacks.  If any are\n-     * found, error out.  Naughty naughty crackers.\n-     */\n-    if ((cmd[0] == '/') || (!strncmp(cmd, \"../\", 3))\n-        || (strstr(cmd, \"/../\") != NULL)) {\n-        log_err(\"invalid command (%s)\\n\", cmd);\n-        exit(104);\n-    }\n-\n-    /*\n-     * Check to see if this is a ~userdir request.  If\n-     * so, set the flag, and remove the '~' from the\n-     * target username.\n-     */\n-    if (!strncmp(\"~\", target_uname, 1)) {\n-        target_uname++;\n-        userdir = 1;\n-    }\n-\n-    /*\n-     * Error out if the target username is invalid.\n-     */\n-    if (strspn(target_uname, \"1234567890\") != strlen(target_uname)) {\n-        if ((pw = getpwnam(target_uname)) == NULL) {\n-            log_err(\"invalid target user name: (%s)\\n\", target_uname);\n-            exit(105);\n-        }\n-    }\n-    else {\n-        if ((pw = getpwuid(atoi(target_uname))) == NULL) {\n-            log_err(\"invalid target user id: (%s)\\n\", target_uname);\n-            exit(121);\n-        }\n-    }\n-\n-    /*\n-     * Error out if the target group name is invalid.\n-     */\n-    if (strspn(target_gname, \"1234567890\") != strlen(target_gname)) {\n-        if ((gr = getgrnam(target_gname)) == NULL) {\n-            log_err(\"invalid target group name: (%s)\\n\", target_gname);\n-            exit(106);\n-        }\n-        gid = gr->gr_gid;\n-        actual_gname = strdup(gr->gr_name);\n-    }\n-    else {\n-        gid = atoi(target_gname);\n-        actual_gname = strdup(target_gname);\n-    }\n+  /*\n+  * Check for a leading '/' (absolute path) in the command to be executed,\n+  * or attempts to back up out of the current directory,\n+  * to protect against attacks.  If any are\n+  * found, error out.  Naughty naughty crackers.\n+  */\n+  if ((cmd[0] == '/') || (!strncmp(cmd, \"../\", 3))\n+    || (strstr(cmd, \"/../\") != NULL)) {\n+      log_err(\"invalid command (%s)\\n\", cmd);\n+      exit(104);\n+  }\n+\n+  /*\n+  * Check to see if this is a ~userdir request.  If\n+  * so, set the flag, and remove the '~' from the\n+  * target username.\n+  */\n+  if (!strncmp(\"~\", target_uname, 1)) {\n+    target_uname++;\n+    userdir = 1;\n+  }\n+\n+  /*\n+  * Error out if the target username is invalid.\n+  */\n+  if (strspn(target_uname, \"1234567890\") != strlen(target_uname)) {\n+    if ((pw = getpwnam(target_uname)) == NULL) {\n+      log_err(\"invalid target user name: (%s)\\n\", target_uname);\n+      exit(105);\n+    }\n+  }\n+  else {\n+    if ((pw = getpwuid(atoi(target_uname))) == NULL) {\n+      log_err(\"invalid target user id: (%s)\\n\", target_uname);\n+      exit(121);\n+    }\n+  }\n+\n+  /*\n+  * Error out if the target group name is invalid.\n+  */\n+  if (strspn(target_gname, \"1234567890\") != strlen(target_gname)) {\n+    if ((gr = getgrnam(target_gname)) == NULL) {\n+      log_err(\"invalid target group name: (%s)\\n\", target_gname);\n+      exit(106);\n+    }\n+    gid = gr->gr_gid;\n+    actual_gname = strdup(gr->gr_name);\n+  }\n+  else {\n+    gid = atoi(target_gname);\n+    actual_gname = strdup(target_gname);\n+  }\n \n #ifdef _OSD_POSIX\n-    /*\n-     * Initialize BS2000 user environment\n-     */\n-    {\n-        pid_t pid;\n-        int status;\n-\n-        switch (pid = ufork(target_uname)) {\n-        case -1:    /* Error */\n-            log_err(\"failed to setup bs2000 environment for user %s: %s\\n\",\n-                    target_uname, strerror(errno));\n-            exit(150);\n-        case 0:     /* Child */\n-            break;\n-        default:    /* Father */\n-            while (pid != waitpid(pid, &status, 0))\n-                ;\n-            /* @@@ FIXME: should we deal with STOP signals as well? */\n-            if (WIFSIGNALED(status)) {\n-                kill (getpid(), WTERMSIG(status));\n-            }\n-            exit(WEXITSTATUS(status));\n-        }\n+  /*\n+  * Initialize BS2000 user environment\n+  */\n+  {\n+    pid_t pid;\n+    int status;\n+\n+    switch (pid = ufork(target_uname)) {\n+  case -1:    /* Error */\n+    log_err(\"failed to setup bs2000 environment for user %s: %s\\n\",\n+      target_uname, strerror(errno));\n+    exit(150);\n+  case 0:     /* Child */\n+    break;\n+  default:    /* Father */\n+    while (pid != waitpid(pid, &status, 0))\n+      ;\n+    /* @@@ FIXME: should we deal with STOP signals as well? */\n+    if (WIFSIGNALED(status)) {\n+      kill (getpid(), WTERMSIG(status));\n     }\n-#endif /*_OSD_POSIX*/\n-    \n-    /*\n-     * Save these for later since initgroups will hose the struct\n-     */\n-    uid = pw->pw_uid;\n-    actual_uname = strdup(pw->pw_name);\n-    target_homedir = strdup(pw->pw_dir);\n-\n-    /*\n-     * Log the transaction here to be sure we have an open log \n-     * before we setuid().\n-     */\n-    log_err(\"uid: (%s/%s) gid: (%s/%s) cmd: %s\\n\",\n-            target_uname, actual_uname,\n-            target_gname, actual_gname,\n-            cmd);\n-\n-    /*\n-     * Error out if attempt is made to execute as root or as\n-     * a UID less than AP_UID_MIN.  Tsk tsk.\n-     */\n-    if ((uid == 0) || (uid < AP_UID_MIN)) {\n-        log_err(\"cannot run as forbidden uid (%d/%s)\\n\", uid, cmd);\n-        exit(107);\n-    }\n-\n-    /*\n-     * Error out if attempt is made to execute as root group\n-     * or as a GID less than AP_GID_MIN.  Tsk tsk.\n-     */\n-    if ((gid == 0) || (gid < AP_GID_MIN)) {\n-        log_err(\"cannot run as forbidden gid (%d/%s)\\n\", gid, cmd);\n-        exit(108);\n-    }\n-\n-    /*\n-     * Change UID/GID here so that the following tests work over NFS.\n-     *\n-     * Initialize the group access list for the target user,\n-     * and setgid() to the target group. If unsuccessful, error out.\n-     */\n-    if (((setgid(gid)) != 0) || (initgroups(actual_uname, gid) != 0)) {\n-        log_err(\"failed to setgid (%ld: %s)\\n\", gid, cmd);\n-        exit(109);\n-    }\n-\n-    /*\n-     * setuid() to the target user.  Error out on fail.\n-     */\n-    if ((setuid(uid)) != 0) {\n-        log_err(\"failed to setuid (%ld: %s)\\n\", uid, cmd);\n-        exit(110);\n-    }\n-\n-    /*\n-     * Get the current working directory, as well as the proper\n-     * document root (dependant upon whether or not it is a\n-     * ~userdir request).  Error out if we cannot get either one,\n-     * or if the current working directory is not in the docroot.\n-     * Use chdir()s and getcwd()s to avoid problems with symlinked\n-     * directories.  Yuck.\n-     */\n-    if (getcwd(cwd, AP_MAXPATH) == NULL) {\n-        log_err(\"cannot get current working directory\\n\");\n-        exit(111);\n-    }\n-\n-    if (userdir) {\n-        if (((chdir(target_homedir)) != 0) ||\n-            ((chdir(AP_USERDIR_SUFFIX)) != 0) ||\n-            ((getcwd(dwd, AP_MAXPATH)) == NULL) ||\n-            ((chdir(cwd)) != 0)) {\n-            log_err(\"cannot get docroot information (%s)\\n\", target_homedir);\n-            exit(112);\n-        }\n-    }\n-    else {\n-        if (((chdir(AP_DOC_ROOT)) != 0) ||\n-            ((getcwd(dwd, AP_MAXPATH)) == NULL) ||\n-            ((chdir(cwd)) != 0)) {\n-            log_err(\"cannot get docroot information (%s)\\n\", AP_DOC_ROOT);\n-            exit(113);\n-        }\n-    }\n-\n-    if ((strncmp(cwd, dwd, strlen(dwd))) != 0) {\n-        log_err(\"command not in docroot (%s/%s)\\n\", cwd, cmd);\n-        exit(114);\n-    }\n-\n-    /*\n-     * Stat the cwd and verify it is a directory, or error out.\n-     */\n-    if (((lstat(cwd, &dir_info)) != 0) || !(S_ISDIR(dir_info.st_mode))) {\n-        log_err(\"cannot stat directory: (%s)\\n\", cwd);\n-        exit(115);\n-    }\n-\n-    /*\n-     * Error out if cwd is writable by others.\n-     */\n-    if ((dir_info.st_mode & S_IWOTH) || (dir_info.st_mode & S_IWGRP)) {\n-        log_err(\"directory is writable by others: (%s)\\n\", cwd);\n-        exit(116);\n-    }\n-\n-    /*\n-     * Error out if we cannot stat the program.\n-     */\n-    if (((lstat(cmd, &prg_info)) != 0) || (S_ISLNK(prg_info.st_mode))) {\n-        log_err(\"cannot stat program: (%s)\\n\", cmd);\n-        exit(117);\n-    }\n-\n-    /*\n-     * Error out if the program is writable by others.\n-     */\n-    if ((prg_info.st_mode & S_IWOTH) || (prg_info.st_mode & S_IWGRP)) {\n-        log_err(\"file is writable by others: (%s/%s)\\n\", cwd, cmd);\n-        exit(118);\n-    }\n-\n-    /*\n-     * Error out if the file is setuid or setgid.\n-     */\n-    if ((prg_info.st_mode & S_ISUID) || (prg_info.st_mode & S_ISGID)) {\n-        log_err(\"file is either setuid or setgid: (%s/%s)\\n\", cwd, cmd);\n-        exit(119);\n-    }\n-\n-    /*\n-     * Error out if the target name/group is different from\n-     * the name/group of the cwd or the program.\n-     */\n-    if ((uid != dir_info.st_uid) ||\n-        (gid != dir_info.st_gid) ||\n-        (uid != prg_info.st_uid) ||\n-        (gid != prg_info.st_gid)) {\n-        log_err(\"target uid/gid (%ld/%ld) mismatch \"\n-                \"with directory (%ld/%ld) or program (%ld/%ld)\\n\",\n-                uid, gid,\n-                dir_info.st_uid, dir_info.st_gid,\n-                prg_info.st_uid, prg_info.st_gid);\n-        exit(120);\n-    }\n-    /*\n-     * Error out if the program is not executable for the user.\n-     * Otherwise, she won't find any error in the logs except for\n-     * \"[error] Premature end of script headers: ...\"\n-     */\n-    if (!(prg_info.st_mode & S_IXUSR)) {\n-        log_err(\"file has no execute permission: (%s/%s)\\n\", cwd, cmd);\n-        exit(121);\n+    exit(WEXITSTATUS(status));\n     }\n+  }\n+#endif /*_OSD_POSIX*/\n+\n+  /*\n+  * Save these for later since initgroups will hose the struct\n+  */\n+  uid = pw->pw_uid;\n+  actual_uname = strdup(pw->pw_name);\n+  target_homedir = strdup(pw->pw_dir);\n+\n+  /*\n+  * Log the transaction here to be sure we have an open log \n+  * before we setuid().\n+  */\n+  log_err(\"uid: (%s/%s) gid: (%s/%s) cmd: %s\\n\",\n+    target_uname, actual_uname,\n+    target_gname, actual_gname,\n+    cmd);\n+\n+  /*\n+  * Error out if attempt is made to execute as root or as\n+  * a UID less than AP_UID_MIN.  Tsk tsk.\n+  */\n+  if ((uid == 0) || (uid < AP_UID_MIN)) {\n+    log_err(\"cannot run as forbidden uid (%d/%s)\\n\", uid, cmd);\n+    exit(107);\n+  }\n+\n+  /*\n+  * Error out if attempt is made to execute as root group\n+  * or as a GID less than AP_GID_MIN.  Tsk tsk.\n+  */\n+  if ((gid == 0) || (gid < AP_GID_MIN)) {\n+    log_err(\"cannot run as forbidden gid (%d/%s)\\n\", gid, cmd);\n+    exit(108);\n+  }\n+\n+  /********************************/\n+  /* CHROOT Implementation, Begin */\n+\n+  /* First, we have to be root */\n+  if (setgid(0) || setuid(0) || getuid() != geteuid() || getgid() != getegid\n()) {\n+    log_err(\"suexec: can't setgid(0). (Is suexec owned by root and has setuid \npermissions?)\\n\");\n+    exit(126);\n+  }\n+\n+  /* Now, read the userdata of the specified user */\n+  pwdent = getpasswddata(uid);\n+  if (pwdent == NULL) {\n+    log_err(\"suexec: can't get passwd info for uid %d\\n\",uid);\n+    exit(122);\n+  }\n+\n+  /* Get Full-Path of the user-homedir */\n+  tmp_str = (char *)malloc(PATH_LEN);\n+  if (!realpath(pwdent->dir,tmp_str)) {\n+    log_err(\"suexec: can't canonize path \\\"%s\\\". Bad path?\\n\", pwdent->dir);\n+    exit(123);\n+  }\n+  free(pwdent->dir);\n+  pwdent->dir = tmp_str;\n+\n+  /* We have to read the current directory here, won't work after chroot */\n+  if (getcwd(cwd, AP_MAXPATH) == NULL) {\n+    log_err(\"cannot get current working directory\\n\");\n+    exit(111);\n+  }\n+\n+  /* Changing to Home-Dir of user */\n+  ret = chdir(pwdent->dir);\t\n+  if (ret) {\n+    log_err(\"suexec: can't chdir to path \\\"%s\\\". Bad path?\\n\", pwdent->dir);\n+    exit(124);\n+  }\n+\n+  /* Now we change the root */\n+  ret = chroot(pwdent->dir);\n+  if (ret) { \n+    log_err(\"suexec: can't chroot to path \\\"%s\\\"\\n\", pwdent->dir);\n+    exit(125);\n+  }\n+\n+  /*\n+  * Change UID/GID here so that the following tests work over NFS.\n+  *\n+  * Initialize the group access list for the target user,\n+  * and setgid() to the target group. If unsuccessful, error out.\n+  */\n+  if (((setgid(gid)) != 0) || (initgroups(actual_uname, gid) != 0)) {\n+    log_err(\"failed to setgid (%ld: %s)\\n\", gid, cmd);\n+    exit(109);\n+  }\n+\n+  /*\n+  * setuid() to the target user.  Error out on fail.\n+  */\n+  if ((setuid(uid)) != 0) {\n+    log_err(\"failed to setuid (%ld: %s)\\n\", uid, cmd);\n+    exit(110);\n+  }\n+\n+  /*\n+  * Get the current working directory, as well as the proper\n+  * document root (dependant upon whether or not it is a\n+  * ~userdir request).  Error out if we cannot get either one,\n+  * or if the current working directory is not in the docroot.\n+  * Use chdir()s and getcwd()s to avoid problems with symlinked\n+  * directories.  Yuck.\n+  */\n+\n+  if (userdir) {\n+    if (((chdir(target_homedir)) != 0) ||\n+      ((chdir(AP_USERDIR_SUFFIX)) != 0) ||\n+      ((getcwd(dwd, AP_MAXPATH)) == NULL) ||\n+      ((chdir(cwd)) != 0)) {\n+        log_err(\"cannot get docroot information (%s)\\n\", target_homedir);\n+        exit(112);\n+    }\n+  }\n+  else {\n+    if (((chdir(AP_DOC_ROOT)) != 0) ||\n+      ((getcwd(dwd, AP_MAXPATH)) == NULL) ||\n+      ((chdir(cwd)) != 0)) {\n+        log_err(\"cannot get docroot information (%s)\\n\", AP_DOC_ROOT);\n+        exit(113);\n+    }\n+  }\n+\n+  if ((strncmp(cwd, dwd, strlen(dwd))) != 0) {\n+    log_err(\"command not in docroot (%s - %s - %s)\\n\", cwd, cmd, dwd);\n+    exit(114);\n+  }\n+\n+  /* free the password-data */\n+  free_passwd_data(pwdent);\n+\n+  /* CHROOT Implementation, End   */\n+  /********************************/\n+  \n+  /*\n+  * Stat the cwd and verify it is a directory, or error out.\n+  */\n+  if (((lstat(cwd, &dir_info)) != 0) || !(S_ISDIR(dir_info.st_mode))) {\n+    log_err(\"cannot stat directory: (%s)\\n\", cwd);\n+    exit(115);\n+  }\n+\n+  /*\n+  * Error out if cwd is writable by others.\n+  */\n+  if ((dir_info.st_mode & S_IWOTH) || (dir_info.st_mode & S_IWGRP)) {\n+    log_err(\"directory is writable by others: (%s)\\n\", cwd);\n+    exit(116);\n+  }\n+\n+  /*\n+  * Error out if we cannot stat the program.\n+  */\n+  if (((lstat(cmd, &prg_info)) != 0) || (S_ISLNK(prg_info.st_mode))) {\n+    log_err(\"cannot stat program: (%s)\\n\", cmd);\n+    exit(117);\n+  }\n+\n+  /*\n+  * Error out if the program is writable by others.\n+  */\n+  if ((prg_info.st_mode & S_IWOTH) || (prg_info.st_mode & S_IWGRP)) {\n+    log_err(\"file is writable by others: (%s/%s)\\n\", cwd, cmd);\n+    exit(118);\n+  }\n+\n+  /*\n+  * Error out if the file is setuid or setgid.\n+  */\n+  if ((prg_info.st_mode & S_ISUID) || (prg_info.st_mode & S_ISGID)) {\n+    log_err(\"file is either setuid or setgid: (%s/%s)\\n\", cwd, cmd);\n+    exit(119);\n+  }\n+\n+  /*\n+  * Error out if the target name/group is different from\n+  * the name/group of the cwd or the program.\n+  */\n+  if ((uid != dir_info.st_uid) ||\n+    (gid != dir_info.st_gid) ||\n+    (uid != prg_info.st_uid) ||\n+    (gid != prg_info.st_gid)) {\n+      log_err(\"target uid/gid (%ld/%ld) mismatch \"\n+        \"with directory (%ld/%ld) or program (%ld/%ld)\\n\",\n+        uid, gid,\n+        dir_info.st_uid, dir_info.st_gid,\n+        prg_info.st_uid, prg_info.st_gid);\n+      exit(120);\n+  }\n+  /*\n+  * Error out if the program is not executable for the user.\n+  * Otherwise, she won't find any error in the logs except for\n+  * \"[error] Premature end of script headers: ...\"\n+  */\n+  if (!(prg_info.st_mode & S_IXUSR)) {\n+    log_err(\"file has no execute permission: (%s/%s)\\n\", cwd, cmd);\n+    exit(121);\n+  }\n \n #ifdef AP_SUEXEC_UMASK\n-    /*\n-     * umask() uses inverse logic; bits are CLEAR for allowed access.\n-     */\n-    if ((~AP_SUEXEC_UMASK) & 0022) {\n-        log_err(\"notice: AP_SUEXEC_UMASK of %03o allows \"\n-                \"write permission to group and/or other\\n\", AP_SUEXEC_UMASK);\n-    }\n-    umask(AP_SUEXEC_UMASK);\n+  /*\n+  * umask() uses inverse logic; bits are CLEAR for allowed access.\n+  */\n+  if ((~AP_SUEXEC_UMASK) & 0022) {\n+    log_err(\"notice: AP_SUEXEC_UMASK of %03o allows \"\n+      \"write permission to group and/or other\\n\", AP_SUEXEC_UMASK);\n+  }\n+  umask(AP_SUEXEC_UMASK);\n #endif /* AP_SUEXEC_UMASK */\n \n-    /* \n-     * Be sure to close the log file so the CGI can't\n-     * mess with it.  If the exec fails, it will be reopened \n-     * automatically when log_err is called.  Note that the log\n-     * might not actually be open if AP_LOG_EXEC isn't defined.\n-     * However, the \"log\" cell isn't ifdef'd so let's be defensive\n-     * and assume someone might have done something with it\n-     * outside an ifdef'd AP_LOG_EXEC block.\n-     */\n-    if (log != NULL) {\n-        fclose(log);\n-        log = NULL;\n-    }\n-\n-    /*\n-     * Execute the command, replacing our image with its own.\n-     */\n+  /* \n+  * Be sure to close the log file so the CGI can't\n+  * mess with it.  If the exec fails, it will be reopened \n+  * automatically when log_err is called.  Note that the log\n+  * might not actually be open if AP_LOG_EXEC isn't defined.\n+  * However, the \"log\" cell isn't ifdef'd so let's be defensive\n+  * and assume someone might have done something with it\n+  * outside an ifdef'd AP_LOG_EXEC block.\n+  */\n+  if (log != NULL) {\n+    fclose(log);\n+    log = NULL;\n+  }\n+\n+  /*\n+  * Execute the command, replacing our image with its own.\n+  */\n #ifdef NEED_HASHBANG_EMUL\n-    /* We need the #! emulation when we want to execute scripts */\n-    {\n-        extern char **environ;\n+  /* We need the #! emulation when we want to execute scripts */\n+  {\n+    extern char **environ;\n \n-        ap_execve(cmd, &argv[3], environ);\n-    }\n+    ap_execve(cmd, &argv[3], environ);\n+  }\n #else /*NEED_HASHBANG_EMUL*/\n-    execv(cmd, &argv[3]);\n+  execv(cmd, &argv[3]);\n #endif /*NEED_HASHBANG_EMUL*/\n \n-    /*\n-     * (I can't help myself...sorry.)\n-     *\n-     * Uh oh.  Still here.  Where's the kaboom?  There was supposed to be an\n-     * EARTH-shattering kaboom!\n-     *\n-     * Oh well, log the failure and error out.\n-     */\n-    log_err(\"(%d)%s: exec failed (%s)\\n\", errno, strerror(errno), cmd);\n-    exit(255);\n+  /*\n+  * (I can't help myself...sorry.)\n+  *\n+  * Uh oh.  Still here.  Where's the kaboom?  There was supposed to be an\n+  * EARTH-shattering kaboom!\n+  *\n+  * Oh well, log the failure and error out.\n+  */\n+  log_err(\"(%d)%s: exec failed (%s)\\n\", errno, strerror(errno), cmd);\n+  exit(255);\n }", "count": 0, "id": 84202, "time": "2006-01-04T10:12:08Z", "creator": "floriand70@gmx.de", "creation_time": "2006-01-04T10:12:08Z", "is_private": false}, {"attachment_id": null, "tags": [], "bug_id": 38116, "text": "Wow. What is the status of this? Googling around tells us that there\u2019s a great number of people who have manually patched chroot support into suexec, showing that there\u2019s clearly a demand for this feature in suexec. Nevertheless it has never made it into upstream suexec. Is there any reason for this? Is this ever planned to be included?\n\nSome examples of people who wrote patches apart from the guy reporting this years ago:\n\n* http://e.metaclarity.org/268/httpdsuexecchrootfastcgiphp/\n* http://www.marco-gatti.com/2012/11/06/stuff/apache-suexec-custom/\n* http://sourceforge.net/projects/chroot-suexec/\n* http://blog.ivanristic.com/2006/06/apache-suexec-chroot-patch.html\n\nDebian seems to have a patched version of suexec as a package \"custom-suexec\", but as I\u2019m not running a debian-based distro this does not really help. Any chance to have this in upstream so one can rely on this feature being maintained?\n\nValete,\nMarvin", "count": 1, "id": 170165, "time": "2013-09-19T11:22:58Z", "creator": "quintus@quintilianus.eu", "creation_time": "2013-09-19T11:22:58Z", "is_private": false}]