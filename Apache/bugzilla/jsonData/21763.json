[{"count": 0, "tags": [], "text": "Using a straight out of the box tomcat instance, when hit with heavy load, \ntomcat eventually runs out of processors. Version 4.1.18 logs an INFO entry and \nwill recover when the load reduces. Version 4.1.24 logs a SEVERE and hangs in \nan undefined state:-\n\nUnder Tomcat 4.1.24:-\n \norg.apache.tomcat.util.threads.ThreadPool logFull\nSEVERE: All threads are busy, waiting. Please increase maxThreads or check the \nservlet status75 75\n \nUnder Tomcat 4.1.18:-\n \norg.apache.tomcat.util.log.CommonLogHandler log\nINFO: All threads are busy, waiting. Please increase maxThreads or check the \nservlet status75 75", "is_private": false, "id": 41061, "creator": "ro@k00l.net", "time": "2003-07-21T12:35:20Z", "bug_id": 21763, "creation_time": "2003-07-21T12:35:20Z", "attachment_id": null}, {"count": 1, "tags": [], "bug_id": 21763, "is_private": false, "text": "This works for me. Please at least provide a dump of the threads indicating what\nthey are doing or where a possible deadlock is. I believe the fault lies with\nyour application.", "id": 41066, "time": "2003-07-21T13:45:02Z", "creator": "remm@apache.org", "creation_time": "2003-07-21T13:45:02Z", "attachment_id": null}, {"count": 2, "attachment_id": null, "creator": "rex.young@fmr.com", "text": "*** Bug 23074 has been marked as a duplicate of this bug. ***", "id": 43962, "time": "2003-09-10T17:54:32Z", "bug_id": 21763, "creation_time": "2003-09-10T17:54:32Z", "tags": [], "is_private": false}, {"count": 3, "tags": [], "creator": "remm@apache.org", "text": "Once the pool gets busy, it's normal for the threads to wait here. However, I\nhave the impression that there's a bug which may happen as soon as the pool gets\nfull.\nCan you reproduce this with 5.0.11 ?", "id": 43963, "time": "2003-09-10T18:01:00Z", "bug_id": 21763, "creation_time": "2003-09-10T18:01:00Z", "is_private": false, "attachment_id": null}, {"attachment_id": null, "tags": [], "bug_id": 21763, "is_private": false, "count": 4, "id": 43974, "time": "2003-09-10T19:21:27Z", "creator": "rex.young@fmr.com", "creation_time": "2003-09-10T19:21:27Z", "text": "This is due to a defect of design of thread pool in Tomcat 4.1.x. (I have yet \nread sources of 5.x)\n\nAn instance of ControlRunnable could wait at two locations. One is in its run() \nmethod, the another is in ThreadPool's runIt() method via TcpWorkerThread.runIt\n(). This causes deadlock.\n\nWhen a ControlRunnable is waiting at ThreadPool.runIt() via other classes such \nas TcpWorkerThread.runIt() -> endpoint.tp.runIt(this). The only chance it gets \nnotified is another ControlRunnable to end and to call \nThreadPool.returnController().\n\nAt a moment the server is under a very heavy traffic, all ControlRunnable will \nbe hung at ThreadPool.runIt() -> this.wait().\n\n\nI have a solution for this is to use a queue of ThreadPoolRunnable to hold all \nrequests. This way, a ControlRunnable no longer need to wait outside.\n\nThanks,\nRex"}, {"count": 5, "tags": [], "text": "Can you suggest a patch ?", "attachment_id": null, "bug_id": 21763, "id": 43981, "time": "2003-09-10T20:10:38Z", "creator": "remm@apache.org", "creation_time": "2003-09-10T20:10:38Z", "is_private": false}, {"count": 6, "attachment_id": null, "bug_id": 21763, "text": "Close, but not quite correct.  If it is waiting in ControlRunnable.run, then \nit is available for requests, so no deadlock is possible.  \n\nThe actual problem is with the way it waits for a free ControlRunnable.  At \nthe moment, it doesn't notice that it has a free slot if one of the threads \ndies after the pool becomes empty.  It's an easy enough fix however.  \n", "id": 43982, "time": "2003-09-10T20:14:26Z", "creator": "william.barker@wilshire.com", "creation_time": "2003-09-10T20:14:26Z", "tags": [], "is_private": false}, {"count": 7, "attachment_id": null, "bug_id": 21763, "is_private": false, "id": 43984, "time": "2003-09-10T20:21:14Z", "creator": "remm@apache.org", "creation_time": "2003-09-10T20:21:14Z", "tags": [], "text": "Isn't the problem that returnController sync on this (like the code which waits\nin findControlRunnable) ?\n\nI'm also investigating a case in parallel where no thread is waiting on accept\non the server socket, for some unknown reason (it could be that the server\nsocket died - which is likely a non recoverable error -, but the reporter was\nunable to find that in his logs, so it could be a TP bug)."}, {"count": 8, "tags": [], "bug_id": 21763, "attachment_id": null, "is_private": false, "id": 43995, "time": "2003-09-10T20:44:48Z", "creator": "william.barker@wilshire.com", "creation_time": "2003-09-10T20:44:48Z", "text": "The accept bug should be the same as this one I'm guessing.  That's what you'd \nsee soon after you got into the state in 23074.\n\nThe sync in findControlRunnable can't really interfer with returnController, \nsince it doesn't really spend any time there unless it decides to wait (at \nwhich point, it no longer owns the Monitor)."}, {"count": 9, "tags": [], "bug_id": 21763, "is_private": false, "id": 44005, "creation_time": "2003-09-10T22:43:30Z", "time": "2003-09-10T22:43:30Z", "creator": "remm@apache.org", "text": "I was considering that patch:\n\nIndex: ThreadPool.java\n===================================================================\nRCS file:\n/home/cvs/jakarta-tomcat-connectors/util/java/org/apache/tomcat/util/threads/ThreadPool.java,v\nretrieving revision 1.13\ndiff -u -r1.13 ThreadPool.java\n--- ThreadPool.java\t7 Sep 2003 13:25:26 -0000\t1.13\n+++ ThreadPool.java\t10 Sep 2003 22:38:53 -0000\n@@ -282,7 +282,17 @@\n     }\n \n     public void run(Runnable r) {\n-        ControlRunnable c = findControlRunnable();\n+        ControlRunnable c = null;\n+        while (c == null) {\n+            c = findControlRunnable();\n+            if (c == null) {\n+                try {\n+                    Thread.sleep(20);\n+                } catch (InterruptedException e) {\n+                    // Ignore\n+                }\n+            }\n+        }\n         c.runIt(r);\n     }    \n     \n@@ -301,7 +311,17 @@\n             throw new NullPointerException();\n         }\n \n-        ControlRunnable c = findControlRunnable();\n+        ControlRunnable c = null;\n+        while (c == null) {\n+            c = findControlRunnable();\n+            if (c == null) {\n+                try {\n+                    Thread.sleep(20);\n+                } catch (InterruptedException e) {\n+                    // Ignore\n+                }\n+            }\n+        }\n         c.runIt(r);\n     }\n \n@@ -324,25 +344,7 @@\n                     openThreads(toOpen);\n                 } else {\n \t\t    logFull(log, currentThreadCount, maxThreads);\n-                    // Wait for a thread to become idel.\n-                    while(currentThreadsBusy == currentThreadCount) {\n-                        try {\n-                            this.wait();\n-                        }\n-\t\t\t// was just catch Throwable -- but no other\n-\t\t\t// exceptions can be thrown by wait, right?\n-\t\t\t// So we catch and ignore this one, since\n-\t\t\t// it'll never actually happen, since nowhere\n-\t\t\t// do we say pool.interrupt().\n-\t\t\tcatch(InterruptedException e) {\n-\t\t\t    log.error(\"Unexpected exception\", e);\n-                        }\n-\n-                        // Pool was stopped. Get away of the pool.\n-                        if(0 == currentThreadCount || stopThePool) {\n-                            throw new IllegalStateException();\n-                        }\n-                    }\n+                    return null;\n                 }\n             }\n \n@@ -678,9 +680,9 @@\n                     } finally {\n                         if(shouldRun) {\n                             shouldRun = false;\n-                            /*\n-\t\t\t                * Notify the pool that the thread is now idle.\n-                            */\n+                            /**\n+                             * Notify the pool that the thread is now idle.\n+                             */\n                             p.returnController(this);\n                         }\n                     }\n\nOf course, I don't know to much about the pooling code, and I can't reproduce\nthe issue to test if that fixes anything.\nPlease go ahead and fix it if you have a working solution :)", "attachment_id": null}, {"count": 10, "tags": [], "bug_id": 21763, "attachment_id": null, "is_private": false, "id": 44014, "time": "2003-09-11T05:38:30Z", "creator": "william.barker@wilshire.com", "creation_time": "2003-09-11T05:38:30Z", "text": "After some initial test, I'm not sure that ThreadPool is really the problem.  \nHowever if Remy's patch works, then this is fixed in the CVS (with a different, \nbut fuctionally similar patch).  However, I'm inclined to think that this fixes \na largely theoretical bug.\n\nIf someone that can reliably reproduce this can produce an automated test case, \nor at the least attach the full log file for it, it would be very helpful.\n"}, {"count": 11, "attachment_id": null, "creator": "rex.young@fmr.com", "is_private": false, "id": 44055, "time": "2003-09-11T17:07:40Z", "bug_id": 21763, "creation_time": "2003-09-11T17:07:40Z", "tags": [], "text": "I have sent you guys another full dump of threads. I do not post it here \nbecause it has 1500 lines.\n\nThere are total 129 instances of ControlRunnable (Thread-2 to Thread-130). You \nwill see 125 of them are waiting for monitor entry which is at \nPoolTcpEndpoint.acceptSocket() which will soon trigger ThreadPool.runIt() -> \nthis.wait(). See it below.\n\n    \"Thread-130\" daemon prio=1 tid=0x081af570 nid=0x5c79 waiting for monitor \nentry [51c4b000..51c4b8b8]\n\tat java.net.PlainSocketImpl.accept(PlainSocketImpl.java:351)\n\t- waiting to lock <0x44e134e0> (a java.net.PlainSocketImpl)\n\tat java.net.ServerSocket.implAccept(ServerSocket.java:448)\n\tat com.sun.net.ssl.internal.ssl.SSLServerSocketImpl.accept(DashoA6275)\n\tat org.apache.tomcat.util.net.jsse.JSSESocketFactory.acceptSocket\n(JSSESocketFactory.java:240)\n\tat org.apache.tomcat.util.net.PoolTcpEndpoint.acceptSocket\n(PoolTcpEndpoint.java:341)\n\tat org.apache.tomcat.util.net.TcpWorkerThread.runIt\n(PoolTcpEndpoint.java:497)\n\tat org.apache.tomcat.util.threads.ThreadPool$ControlRunnable.run\n(ThreadPool.java:530)\n\tat java.lang.Thread.run(Thread.java:534)\n\nOnly 4 instances are idle listed below.\n\n    \"Thread-127\" daemon prio=1 tid=0x081ad0c8 nid=0x5c76 in Object.wait() \n[51ac8000..51ac88b8]\n\tat java.lang.Object.wait(Native Method)\n\t- waiting on <0x47acbe10> (a \norg.apache.tomcat.util.threads.ThreadPool$ControlRunnable)\n\tat java.lang.Object.wait(Object.java:429)\n\tat org.apache.tomcat.util.threads.ThreadPool$ControlRunnable.run\n(ThreadPool.java:509)\n\t- locked <0x47acbe10> (a \norg.apache.tomcat.util.threads.ThreadPool$ControlRunnable)\n\tat java.lang.Thread.run(Thread.java:534)\n\nObviously, there is another defect in Http Connector that causes too many \nthread requests on ThreadPool.\n\nOnce this defect meets the first defect I mentioned above in ThreadPool, which \nmeans all (the maxThreads) instances of ControlRunnable are used to wait for \nlistening on the server socket, then all threads will go to the next point at \nTcpWorkerThread.runIt() -> endpoint.tp.runIt(this) -> ThreadPool.runIt() -> \nthis.wait(), and hang there.\n\n\nI have no idea on how Http Connector works to use threads. I think you guys \nwill find clues from the dump.\n"}, {"count": 12, "attachment_id": null, "bug_id": 21763, "text": "Here is sample codes that implement queue in ThreadPool as I suggested. I do \nnot have time and access to CVS, could someone make it a pacth? Thanks.\n\n\npublic class ThreadPool\n{\n    private RunnableQueue queue = new RunnableQueue();\n    \n    public void runIt(ThreadPoolRunnable r) \n    {\n        queue.put(r);\n        ......\n    }\n    \n    static public class RunnableQueue\n    {\n        // use a resizeable array for JDK1.1\n        List queue = new ArrayList();\n        \n        synchronized public ThreadPoolRunnable get()\n        {\n            if(queue.size() == 0)\n                wait();\n            \n            ThreadPoolRunnable one = (ThreadPoolRunnable)queue.get(0);\n            queue.remove(0);\n            \n            return one;\n        }\n        \n        synchronized public ThreadPoolRunnable put(ThreadPoolRunnable one)\n        {\n            queue.add(one);\n            notify();\n        }\n    }\n    \n    public static class ControlRunnable implements Runnable \n    {\n        public void run() {\n          try {\n            while(true) {\n                try {\n                    toRun = p.queue.get();\n        ......\n    }\n}\n", "id": 44057, "time": "2003-09-11T17:27:35Z", "creator": "rex.young@fmr.com", "creation_time": "2003-09-11T17:27:35Z", "tags": [], "is_private": false}, {"count": 13, "tags": [], "text": "This should be fixed now in the CVS, and should appear in 4.1.28.\n\nIt came down to an error condition problem, that eventually causes bad threads \nto take over the connector, leaving no more room for good threads.", "is_private": false, "bug_id": 21763, "id": 44082, "time": "2003-09-12T04:02:37Z", "creator": "william.barker@wilshire.com", "creation_time": "2003-09-12T04:02:37Z", "attachment_id": null}, {"count": 14, "attachment_id": 8182, "bug_id": 21763, "is_private": false, "id": 44094, "time": "2003-09-12T08:35:01Z", "creator": "remm@apache.org", "creation_time": "2003-09-12T08:35:01Z", "tags": [], "text": "Created attachment 8182\nBinary including the fix"}, {"count": 15, "tags": [], "bug_id": 21763, "attachment_id": null, "is_private": false, "id": 45706, "time": "2003-10-15T03:02:23Z", "creator": "jswap@yahoo.com", "creation_time": "2003-10-15T03:02:23Z", "text": "I am running Tomcat v4.1.28 (which supposedly contains the fix to this bug, \naccording to the previous comment), and am still getting this hanging \nproblem.  I have tried configuring my connector two different ways, but get \nthe hanging problem using both.  When I set the connector's maxProcessors to \"-\n1\", during heavy load I see this in cataline.out:\n\"SEVERE: All threads are busy, waiting. Please increase maxThreads or check \nthe servlet status200 200\"\n\nOnce this error occurs, the server begins hanging and does not seem to recover \nuntil I restart tomcat.  A side note is that the number in the error message \nis 200.  This concerns me because I believe a value of -1 is supposed to \nmean \"unlimited\".  \nI also tried setting the maxProcessors to 1000.  Under heavy load, I saw this \nerror in catalina.out:\n\"SEVERE: All threads are busy, waiting. Please increase maxThreads or check \nthe servlet status1000 1000\"\n\nAgain, I had to restart Tomcat to recover from the hanging problem.\n\nBTW, when I say \"heavy load\", I mean about 10 pages per second.  However, \nsince we run on a dual Xeon, uptime reports a load of only about 0.5 so the \nCPU is definitely not the limiting factor."}, {"count": 16, "attachment_id": null, "creator": "remm@apache.org", "is_private": false, "id": 45719, "time": "2003-10-15T09:28:22Z", "bug_id": 21763, "creation_time": "2003-10-15T09:28:22Z", "tags": [], "text": "Seeing what you describe, I doubt this is caused by this problem (this report\nwas about much higher load factors, 10 req/s is very low). If you have\ncontention or deadlocks elsewhere, the symptoms will be the same (more\nprocessors will be created to handle the incoming requests). Get a thread dump,\nwhich could indicate where the contention is. You should discuss this in\ntomcat-user, since the cause of your problem is not likely this particular flaw\nof the thread pool.\n\nAllowing unlimited processors to get around this kind of issue could bring your\nwhole server to its knees, and is a bad idea."}, {"count": 17, "tags": [], "text": "I am having the exact same problem using Apache 2 connecting to Tomcat 4.1.24 through \nmod_jk2.\n\nIn my case, by watching jkstatus, I noticed that the number of threads in use would increase once \nevery 5 minutes (why, I don't know) until all 75 threads would be used up about 6 hours later.   \nThis is on a server with virtually NO LOAD.\n\nDeciding that it was related to connections not being dropped, we changed our connectionTimeout \nvalue for the Connector from 0 to 60000.   So far that seems like it has fixed the problem.   \nPerhaps this will give some further insight into the cause. \n\nDisclaimer: I haven't applied the attached patches from this bug report.", "attachment_id": null, "bug_id": 21763, "id": 46017, "time": "2003-10-21T23:57:12Z", "creator": "tom@squeat.com", "creation_time": "2003-10-21T23:57:12Z", "is_private": false}, {"count": 18, "tags": [], "bug_id": 21763, "is_private": false, "text": "BTW, when I said \"NO LOAD\" I lied.   I just discovered that I am indeed getting hit once every 5 \nminutes by something.", "id": 46021, "time": "2003-10-22T01:38:25Z", "creator": "tom@squeat.com", "creation_time": "2003-10-22T01:38:25Z", "attachment_id": null}, {"attachment_id": null, "tags": [], "bug_id": 21763, "text": "*** Bug 25748 has been marked as a duplicate of this bug. ***", "count": 19, "id": 49683, "time": "2003-12-25T03:04:41Z", "creator": "william.barker@wilshire.com", "creation_time": "2003-12-25T03:04:41Z", "is_private": false}, {"count": 20, "tags": [], "bug_id": 21763, "text": "Created attachment 10512\nThread dump of Tomcat after hanging with ThreadPool logFull error", "id": 52842, "time": "2004-02-24T10:34:40Z", "creator": "matthew.fitzgerald@hp.com", "creation_time": "2004-02-24T10:34:40Z", "is_private": false, "attachment_id": 10512}, {"attachment_id": null, "tags": [], "bug_id": 21763, "text": "Ok, I was having this exact same problem for 4.1.27 and 4.1.29 - I moved to \n5.0.18 and it's appearing again.  In our test environment I can't reproduce \nthe error (probably because the load isn't high enough) but as soon as it goes \ninto production, Tomcat can grind to a halt in anywhere from 1 minute to 24 \nhours after it's started.  Our web application consists of around 6 JSP files \nand some backend classes that execute simple stored procedures on a MSSQL \nWin32 box (Tomcat is running on an HP-UX 11.00 system). ", "count": 21, "id": 52843, "time": "2004-02-24T10:35:16Z", "creator": "matthew.fitzgerald@hp.com", "creation_time": "2004-02-24T10:35:16Z", "is_private": false}, {"count": 22, "attachment_id": null, "bug_id": 21763, "text": "Your thread dump looks ok, and in that situation, Tomcat is not hung. OTOH, the\nconcurrent modification error will end up causing trouble (see bug 26752).\nPlease don't reopen this bug.", "id": 52844, "time": "2004-02-24T10:48:36Z", "creator": "remm@apache.org", "creation_time": "2004-02-24T10:48:36Z", "tags": [], "is_private": false}, {"count": 23, "attachment_id": null, "creator": "vyermolenko@ukr.net", "is_private": false, "id": 58279, "time": "2004-05-28T07:08:19Z", "bug_id": 21763, "creation_time": "2004-05-28T07:08:19Z", "tags": [], "text": "We have the same problem on Tomcat 5.0.19 under Slackware 9.1.0 (2.6.5 kernel):\n\ncatalina.out-May 27, 2004 2:20:48 PM org.apache.tomcat.util.threads.ThreadPool\nlogFull\ncatalina.out:SEVERE: All threads (300) are currently busy, waiting. Increase\nmaxThreads (300) or check the servlet status\n\nOur HTTP connector configuration is:\n    <Connector port=\"8080\"\n               maxThreads=\"300\" minSpareThreads=\"30\" maxSpareThreads=\"80\"\n               enableLookups=\"false\" redirectPort=\"8443\" acceptCount=\"100\"\n               debug=\"0\" connectionTimeout=\"20000\"\n               disableUploadTimeout=\"true\" />\n\nWe use big heavy-load web application with some dozens of JSPs with XML\ntransformation and MySQL storage.\n\nWe will try to find luck in Tomcat 5.0.25..."}]