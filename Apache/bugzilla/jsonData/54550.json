[{"count": 0, "tags": [], "creator": "mi+apache@aldan.algebra.com", "attachment_id": null, "text": "A fairly common use-case involves checking, if a particular key is already present in a hash-table and inserting it, if not:\n\n   struct mystruct *value = apr_hash_get(table, key, klen);\n\n   if (value == NULL) {\n       value = create_new_value();\n       apr_hash_table_set(table, key, klen, value);\n   } else {\n       verify_value(value);\n       ...\n   }\n\nThis means, the hash-table search is performed twice -- first by the apr_hash_get, and then -- for the same key -- by the apr_hash_set. This is suboptimal... There should be a function, that would insert a new entry (with the value being NULL) under the specified key -- and allow the caller to set the value. For example something like this:\n\n   struct myststruct **pvalue;\n\n   if (apr_hash_insert(table, key, klen, &pvalue)) {\n       *pvalue = create_new_value();\n   } else {\n       verify_value(*pvalue);\n       ...\n   }\n       \nin the above apr_hash_insert the last argument will be filled with the address of the value-pointer, that was either newly-inserted by the call (if the key was a new one), or existed already (if the key was known). This would be achieved with only a single hash-table search -- something find_entry() (the static function behind both apr_hash_set and apr_hash_get) can already do.\n\nThe actual coding of this feature is not difficult. If there are no objections in principle, I could come up with a patch. Please, advise. Thanks!", "id": 165185, "time": "2013-02-11T22:25:01Z", "bug_id": 54550, "creation_time": "2013-02-11T22:25:01Z", "is_private": false}]