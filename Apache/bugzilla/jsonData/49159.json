[{"count": 0, "tags": [], "bug_id": 49159, "text": "Doing this in a thread-safe way means performing the clean-up in the thread where the ThreadLocal exists. A likely point is just before the Thread gets returned to the pool.", "id": 136276, "time": "2010-04-20T13:33:43Z", "creator": "markt@apache.org", "creation_time": "2010-04-20T13:33:43Z", "is_private": false, "attachment_id": null}, {"count": 1, "tags": [], "bug_id": 49159, "text": "I did experiment with cleaning the threadlocals from their owning thread by doing it in org.apache.tomcat.util.threads.ThreadPoolExecutor.afterExecute(Runnable, Throwable)\n\nIt does work (i.e. it improves leak protection for the http://wiki.apache.org/tomcat/MemoryLeakProtection#webappClassInstanceAsThreadLocalIndirectValue case ), but since it clear all thread locals after each request, it breaks some optimizations that are done by some frameworks, applications or even tomcat itself.\n\nI'm experimenting with the approach of recreating the thread pool, it seems cleaner and more efficient.", "id": 136422, "time": "2010-04-26T16:40:49Z", "creator": "slaurent@apache.org", "creation_time": "2010-04-26T16:40:49Z", "is_private": false, "attachment_id": null}, {"count": 2, "tags": [], "bug_id": 49159, "text": "It shouldn't clean all thread locals after each request, it should clean all thread locals loaded by a web application.\n\nIf the cleaning breaks apps or frameworks then those apps/frameworks are broken since they are leaking memory and should be fixed. One option to reduce side-effects would be only to clean the thread locals if the WebAppClassloader is stopped. The downside is that memory leaks won't be fixed immediately.\n\nThe ThreadLocals created by Tomcat will be loaded by the common class loader. Those shouldn't be causing any memory leaks, even in the embedded case since Tomcat will stop all the threads it created.", "id": 136481, "time": "2010-04-28T08:23:05Z", "creator": "markt@apache.org", "creation_time": "2010-04-28T08:23:05Z", "is_private": false, "attachment_id": null}, {"count": 3, "tags": [], "creator": "slaurent@apache.org", "attachment_id": 25411, "text": "Created attachment 25411\nPatch for tomcat 7 to renew threads\n\nHere is finally my proposition of patch for tomcat 7 to recreate the ThreadPoolExecutor of each Executor when a Context is stopped.\n\nI also removed the clearReferencesThreadLocals property on WebApp[Class]Loader since my patch makes it useless and I think this feature is too unsafe.\n\nI'm working on another patch for tomcat 6. There's a little more work to do because of the old WorkerThread stuff that has been replace by ThreadPoolExecutor in trunk.", "id": 136711, "time": "2010-05-06T17:15:35Z", "bug_id": 49159, "creation_time": "2010-05-06T17:15:35Z", "is_private": false}, {"count": 4, "tags": [], "bug_id": 49159, "attachment_id": null, "id": 138756, "time": "2010-07-30T04:02:32Z", "creator": "ArjenCornelis.Knibbe@Getronics.com", "creation_time": "2010-07-30T04:02:32Z", "is_private": false, "text": "*** Bug 49668 has been marked as a duplicate of this bug. ***"}, {"count": 5, "tags": [], "creator": "pidster@apache.org", "attachment_id": 26068, "is_private": false, "id": 140108, "time": "2010-09-23T10:49:43Z", "bug_id": 49159, "creation_time": "2010-09-23T10:49:43Z", "text": "Created attachment 26068\nAlternative approach to renewing threads\n\nInstead of completely renewing the entire thread pool, it's possible to do it incrementally, which might be less invasive, in the event of a large number of applications being updated at the same time.\n\nThis patch adds a TaskThread class and modifies the StandardContextValve. The goal is to terminate a class after it's used, when it's discovered to be older than the Context which it last serviced.\n\nThis approach wouldn't be as comprehensive as replacing the entire pool, but should cause the pool to refresh incrementally over time. Further enhancement could include self-cleaning of thread locals etc."}, {"count": 6, "tags": [], "bug_id": 49159, "text": "Pid, I applied your patch but it does not work.\nActually when the thread calls join(0) on itself it just leads to a deadlock : the Thread will remain forever in the join method unless it is interrupted.\n\nFurthermore your idea works only if a new context is started. If a context is stopped and no other context is started, Threads won't be renewed.", "id": 140124, "time": "2010-09-23T16:51:38Z", "creator": "slaurent@apache.org", "creation_time": "2010-09-23T16:51:38Z", "is_private": false, "attachment_id": null}, {"count": 7, "tags": [], "bug_id": 49159, "is_private": false, "text": "(In reply to comment #6)\n> Pid, I applied your patch but it does not work.\n> Actually when the thread calls join(0) on itself it just leads to a deadlock :\n> the Thread will remain forever in the join method unless it is interrupted.\n\nIt's experimental admittedly. I'll clean up my SVN repo & retry it, thought it was working...\nIf it won't work at all, then the idea is dead, but there must be a way to terminate an individual thread & remove it from the pool.\n\n> Furthermore your idea works only if a new context is started. \n\nOr an existing one is restarted, the point is that it's a compromise.\nThe idea was to have a lower impact than restarting the whole thread pool.\n\n> If a context is stopped and no other context is started, Threads won't be renewed.\n\nIf a context is stopped and no other context is started, how will the server work?", "id": 140127, "time": "2010-09-23T17:55:09Z", "creator": "pidster@apache.org", "creation_time": "2010-09-23T17:55:09Z", "attachment_id": null}, {"count": 8, "tags": [], "bug_id": 49159, "is_private": false, "text": "Created attachment 26074\nproposed patch to renew threads one by one with a delay\n\nI explored your idea and managed to force threads to \"kill themselves\" after a context is stopped.\nHere are the main points of my new patch :\n\n- I save the last time a context is stopped in a static variable of StandardContext (this could be improved to record it somewhere at the Service or Engine level, in a instance variable)\n- The \"suicide\" is done in ThreadPoolExecutor.afterExecute(), in case the thread was created before the last context was stopped.\n- the rate at which threads are renewed is throttled to avoid renewing all threads at the same time (otherwise it would have been the same as my initial proposal to renew the whole pool).\n- I had to make TaskQueue extend ArrayBlockingQueue instead of LinkedBlockingQueue because the latter does not propose to have a \"fair\" policy. Fairness is required so that every thread of the pool is given the opportunity to be killed.\n- Unlike LinkedBlockingQueue, ArrayBlockingQueue requires a reasonable size (not Integer.MAX_VALUE). I set it to 100 by default (configurable with the maxQueueSize property at the Connector or Executor level)\n\nI'm quite happy with this patch except the fairness requirement :\n- The javadocs of ArrayBlockingQueue say that it may decrease performance, but I don't how much\n- Since each thread of the pool is used in turn, we might lose some caching effects\n- and it also prevents the size of the pool to be decreased in case of low activity : without fairness, some Thread could timeout waiting for an element from the queue while other threads could serve new requests. Eventually the pool could decide to decrease it size.\n\nWhat do you think ? If we don't use a fair queue, we do not have a deterministic behavior and some thread might still trigger a memory leak...", "id": 140175, "time": "2010-09-25T18:42:53Z", "creator": "slaurent@apache.org", "creation_time": "2010-09-25T18:42:53Z", "attachment_id": 26074}, {"count": 9, "tags": [], "text": "> What do you think ? If we don't use a fair queue, we do not have a\n> deterministic behavior and some thread might still trigger a memory leak...\n\nUnless we have minSpareThreads=0. This way even threads that are no longer used will eventually be stopped (the timeout is 60s by default, maxIdleTime in StandardThreadExecutor and hardcoded in AbstractEndpoint.createExecutor() )", "is_private": false, "bug_id": 49159, "id": 140176, "time": "2010-09-25T18:51:53Z", "creator": "slaurent@apache.org", "creation_time": "2010-09-25T18:51:53Z", "attachment_id": null}, {"count": 10, "tags": [], "bug_id": 49159, "is_private": false, "text": "Created attachment 26097\nPatch for tomcat 7 to renew threads one by one with a delay without requiring a fair queue\n\nI worked a little more on my patch to avoid requiring a fair queue. I actually reused part of my very first patch (the Listener). Basically here is what is done :\n\n- idle threads are stopped all at once, even core pool threads. This is done by ThreadLocalLeakPreventionListener\n- like my previous patch, active threads are stopped one by one with a delay.\n\nAll in all, this avoids performance impacts under load since only idle threads will be stopped as a whole, and other threads will be renewed slowly.\n\nThis memory leak protection is not 100% deterministic since one could think of scenarios where the load decreases just after a leaking context is stopped, so that some (core pool) threads are no longer used but still present in the pool and thus triggering the memory leak...\nBut it's a compromise between performance impacts and the duration of the memory leak.\n\nI'd be glad to have some feedback on this patch!", "id": 140277, "time": "2010-09-28T17:34:48Z", "creator": "slaurent@apache.org", "creation_time": "2010-09-28T17:34:48Z", "attachment_id": 26097}, {"count": 11, "tags": [], "creator": "slaurent@apache.org", "attachment_id": 26108, "text": "Created attachment 26108\ntc7 renew threads one by one in a bounded time\n\nNew patch with further improvements : now the behavior is more deterministic, with an upper bound to the time necessary to renew all the threads of the pool. The upper bound is something like N*max(threadKeepAliveTimeout, longestRequest + threadRenewalDelay). Where N is the number of threads in the pool and longestRequest is the maximum time a request takes to be processed (of course it depends on the application).\nThis is really a worst case scenario and it should be much quicker in usual cases, something closer to max(threadKeepAliveTimeout, longestRequest).\n\nI still have to make the threadRenewalDelay configurable (hardcoded to 1s for now) and to propose some cleanups in WebAppClassLoader since this patch makes the unsafe-and-disabled-by-default ThreadLocal cleaning obsolete. (it's still interesting to introspect the ThreadLocals to detect potential leaks and warn the user, it will help to improve libraries and applications...).\n\nAny volunteer for a review before I continue finalizing this patch ?", "id": 140340, "time": "2010-09-30T18:05:48Z", "bug_id": 49159, "creation_time": "2010-09-30T18:05:48Z", "is_private": false}, {"count": 12, "tags": [], "bug_id": 49159, "attachment_id": 26150, "id": 140623, "time": "2010-10-09T17:14:35Z", "creator": "slaurent@apache.org", "creation_time": "2010-10-09T17:14:35Z", "is_private": false, "text": "Created attachment 26150\npatch tc7 renew threads RC1\n\nHere is my proposed \"RC1\" patch for tc7.\n\n- new property threadRenewalDelay on StandardThreadExecutor (default is 1000ms)\n- new property renewThreadsWhenStoppingContext on StandardContext (default is true)\n- removed property clearReferencesThreadLocals on StandardContext\n- Transformed the clearReferencesThreadLocals behavior of WebappClassLoader into a checkThreadLocalsForLeaks behavior\n- updated documentation\n- successfully performed some tests with JMeter\n\nI'll try to propose an equivalent patch for tomcat 6 in a few days..."}, {"count": 13, "tags": [], "creator": "slaurent@apache.org", "attachment_id": 26156, "is_private": false, "id": 140677, "time": "2010-10-11T16:50:39Z", "bug_id": 49159, "creation_time": "2010-10-11T16:50:39Z", "text": "Created attachment 26156\npatch tc7 renew threads RC2\n\npatch \"RC2\" for tomcat 7 : using ProtocolHandler.getExecutor() instead of testing each possible implementation (the method was not present on ProtocolHandler a couple of weeks ago)."}, {"count": 14, "tags": [], "bug_id": 49159, "is_private": false, "text": "Created attachment 26157\npatch tc6 renewThreads 2010-10-11\n\nPatch for tomcat 6.\n\nIt is essentially the same behavior as for tomcat 7, excepted that it requires that (at least) one Executor be configured and the Connectors be configured to use that(these) Executor(s).\nSo, the memory leak protection is not enabled by default, unlike for tomcat 7 which always uses an Executor.", "id": 140678, "time": "2010-10-11T16:54:31Z", "creator": "slaurent@apache.org", "creation_time": "2010-10-11T16:54:31Z", "attachment_id": 26157}, {"count": 15, "tags": [], "creator": "slaurent@apache.org", "attachment_id": null, "text": "Though my proposed patch renews threads in the pool, there are actually 2 other types of threads that can prevent an application from being garbage collected if it has ThreadLocal-related leaks : \n- the \"main\" thread (the one when starting up tomcat)\n- the ContainerBackgroundProcessor thread\n(- the shutdown hook thread too, but since the JVM is shutting down it does not really matter)\n- in an embedded scenario, the thread of the \"containing\" application\n\nCurrently when a webapp is started or stopped, the lifecycle callbacks into the webapp (context listener, filters, servlet) are executed by one of those threads.\n\nI'm working on a patch where I spawn a thread that runs just during those callbacks then shuts down, and so far it prevents such leaks.", "id": 142021, "time": "2010-11-25T16:25:32Z", "bug_id": 49159, "creation_time": "2010-11-25T16:25:32Z", "is_private": false}, {"count": 16, "tags": [], "creator": "slaurent@apache.org", "attachment_id": null, "is_private": false, "id": 142394, "time": "2010-12-05T18:00:05Z", "bug_id": 49159, "creation_time": "2010-12-05T18:00:05Z", "text": "Applied the patch to renew threads of the pool on trunk, will be available for 7.0.6."}, {"count": 17, "tags": [], "bug_id": 49159, "text": "rev 1044145 : committed some more enhancements in case a web application creates some ThreadLocals that it does not clean during its startup or shutdown phases (calls to Listeners, Filters and Servlets). A dedicated thread is used in these phases.\n\nWill be available for 7.0.6", "id": 142541, "time": "2010-12-09T17:16:44Z", "creator": "slaurent@apache.org", "creation_time": "2010-12-09T17:16:44Z", "is_private": false, "attachment_id": null}, {"count": 18, "tags": [], "text": "marking issue as resolved as of 7.0.6.", "attachment_id": null, "bug_id": 49159, "id": 145552, "time": "2011-04-04T17:37:14Z", "creator": "slaurent@apache.org", "creation_time": "2011-04-04T17:37:14Z", "is_private": false}, {"count": 19, "tags": [], "creator": "tkrah@fachschaft.imn.htwk-leipzig.de", "attachment_id": null, "text": "Does the tomcat6 patch getting applied to any 6.x version? Or is this one only there in 7.0.6+?", "id": 152718, "time": "2012-01-12T14:24:58Z", "bug_id": 49159, "creation_time": "2012-01-12T14:24:58Z", "is_private": false}, {"count": 20, "tags": [], "creator": "knst.kolinko@gmail.com", "attachment_id": null, "is_private": false, "id": 152719, "time": "2012-01-12T15:21:11Z", "bug_id": 49159, "creation_time": "2012-01-12T15:21:11Z", "text": "No. This enhancement is too intrusive to be backported."}]