[{"count": 0, "tags": [], "bug_id": 40073, "attachment_id": null, "id": 91413, "creation_time": "2006-07-19T11:30:12Z", "time": "2006-07-19T11:30:12Z", "creator": "Dubovitskiy@netcracker.com", "text": "Hi\nGentlemen,\n\nWe are using POI 2.5 (2.5.1 shows the same problem) to parse Excel files and \nhave encountered a problem with the SSTDeserializer class.\n\nWe have solved the problem but we would like to consult with you if our \ncorrections are acceptable. \nThis is also possible that this is a known problem and an official fix exists?\n\nWe\u2019ll appreciate any help much.\n\nReproduce the problem:\nJust try to open file sstTest.xls from attachment\n\nFollowing exception occurs during opening of excel file: \njava.lang.NullPointerException\n            at org.apache.poi.hssf.record.SSTRecord.getString\n(SSTRecord.java:277)\n            at org.apache.poi.hssf.model.Workbook.getSSTString\n(Workbook.java:649)\n            at org.apache.poi.hssf.usermodel.HSSFCell.<init>(HSSFCell.java:283)\n            at org.apache.poi.hssf.usermodel.HSSFRow.createCellFromRecord\n(HSSFRow.java:198)\n            at org.apache.poi.hssf.usermodel.HSSFSheet.setPropertiesFromSheet\n(HSSFSheet.java:156)\n            at org.apache.poi.hssf.usermodel.HSSFSheet.<init>\n(HSSFSheet.java:110)\n            at org.apache.poi.hssf.usermodel.HSSFWorkbook.<init>\n(HSSFWorkbook.java:177)\n            at org.apache.poi.hssf.usermodel.HSSFWorkbook.<init>\n(HSSFWorkbook.java:210)\n            at org.apache.poi.hssf.usermodel.HSSFWorkbook.<init>\n(HSSFWorkbook.java:191)\n \nProblem Description:\nThe problem reproduces when string in CONTINUE RECORD finishes at the end of \nrecord and extra CONTINUE RECORD exists. The readStringRemainder method reads \nremainder of current string but doesn\u2019t update continuationCharsRead variable \nwith new length. As a result when next CONTINUE record is called with \nprocessContinueRecord the function isStringFinished returns invalud result,and  \nstring is treated as unfinished one.\n\n\nSolutuion:\n We  suggest to correct this problem by modifying readStringRemainder code like \nthis \n\nprivate void readStringRemainder( final byte[] record )\n    {\n        int stringRemainderSizeInBytes = calculateByteCount( charCount-\ngetContinuationCharsRead() );\n        byte[] unicodeStringData = new byte[SSTRecord.STRING_MINIMAL_OVERHEAD\n                + stringRemainderSizeInBytes];\n\n        // write the string length\n        LittleEndian.putShort( unicodeStringData, 0, (short) (charCount-\ngetContinuationCharsRead()) );\n\n        // write the options flag\n        unicodeStringData[LittleEndianConsts.SHORT_SIZE] = createOptionByte( \nwideChar, richText, extendedText );\n\n        // copy the bytes/words making up the string; skipping\n        // past all the overhead of the str_data array\n        arraycopy( record, LittleEndianConsts.BYTE_SIZE, unicodeStringData,\n                SSTRecord.STRING_MINIMAL_OVERHEAD,\n                stringRemainderSizeInBytes );\n\n        // use special constructor to create the final string\n        UnicodeString string = new UnicodeString( UnicodeString.sid,\n                (short) unicodeStringData.length, unicodeStringData,\n                unfinishedString );\n        Integer integer = new Integer( strings.size() );\n\n        addToStringTable( strings, integer, string );\n\n        int newOffset = offsetForContinuedRecord( stringRemainderSizeInBytes );\n    \n\n        // ----------------------- CORRECTIONS BEGIN-------------------------\n       /* \n        * This function doesn't update the continuationCharsRead variable\n        * with new string length (unfinished string length + remaining string \nlength )\n        * Because string variable is a concatenation of unfinishedString and \nstringRemainder,\n        * it 's length is characketers can be used as new value for \ncontinuationCharsRead.\n      */\n\n        setContinuationCharsRead(string.getCharCount() );\n      \n        /*\n         * If we didn't reach end of current record we have to call \n         * manufactureStrings to process other strings in this record. \n         * Because of manufactureStrings  checks if end of record is reached \n         * it can be called unconditionally.\n         * But the problem is, manufactureStrings   \n         * will call initVars first and reset the continuationCharsRead value,\n         * which is necessary for isStringFinished to work correctly\n         * when next processContinueRecord will be called.\n         */\n        if (newOffset < record.length)\n        {\n            manufactureStrings( record, newOffset);\n        }\n\n        // ----------------------- CORRECTIONS END -------------------------\n\n    }\n\n \n \n\n Thank you.\nSergey.", "is_private": false}, {"count": 1, "tags": [], "creator": "Dubovitskiy@netcracker.com", "attachment_id": 18618, "id": 91414, "time": "2006-07-19T11:32:10Z", "bug_id": 40073, "creation_time": "2006-07-19T11:32:10Z", "is_private": false, "text": "Created attachment 18618\nsstTest.xls"}, {"text": "Works against latest SVN. SST handling was completely rewritten in the current\nSVN. Release pending.\n\nJason\n\n", "tags": [], "bug_id": 40073, "is_private": false, "count": 2, "id": 91520, "time": "2006-07-24T08:32:20Z", "creator": "jheight@apache.org", "creation_time": "2006-07-24T08:32:20Z", "attachment_id": null}]