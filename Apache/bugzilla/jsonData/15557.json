[{"count": 0, "tags": [], "bug_id": 15557, "attachment_id": null, "text": "o.a.c.loader.WebappLoader calls URL.setURLStreamHandlerFactory() with an\ninstance of o.a.n.resources.DirContextURLStreamHandlerFactory in its start()\nmethod. This factory returns URL stream handlers for the \"jndi\" protocol used\nfor web app resources. With the URL stream handler factory in place for this\nprotocol, URL instances can be created for URLs like\n\"jar:jndi:/WEB-INF/lib/foo.jar!/\" and calling openConnection on such a URL\nreturns a JarURLConnection. This feature is used in some places in Catalina and\nJasper to scan for JAR entries.\n\nHowever, registering a URL stream handler factory with\nURL.setURLStreamHandlerFactory() has nasty side effects. I'm working on a\nslimmed down Tomcat distribution package and among other things it will support\nupgrades and feature additions in a live Tomcat instance by replacing the\nclassloaders for all server classes. This fails when a URL stream handler has\nbeen registered this way, since the URL class keeps a reference to the stream\nhandler factory instance that was loaded by the original classloader. Since the\nsetURLStreamHandlerFactory() can only be called once per JVM instance, using it\nfor Tomcat internals also prevents an application that embeds Tomcat to use it.\n\nI therefore suggest a different approach. The o.a.c.c.ApplicationContext already\nreturns URL instances that are created with an instance of\nDirContextURLStreamHandler as its stream handler. This means that calling\nopenStream() on a URL returned by ServletContext.getResource() returns a stream\nto the underlying JNDI resource. Wrapping a java.util.jar.JarInputStream around\nthis stream provides access to the JAR entries. A positive side-effect of this\napproach is that it solves the problem with closing JarFile that is mentioned in\nvarious places; there's no JarFile to close with this approach and closing the\nJarInputStream works fine.\n\nIn more detail, this is what needs to be done to avoid the side effects of\nsetURLStreamHandlerFactory():\n1) In o.a.c.loader.WebappLoader#start(), remove the call to\nURL.setURLStreamHandlerFactory()\n2) Remove the o.a.n.resources.DirContextURLStreamHandlerFactory class\n3) In all places where URLs like \"jar:jndi:/WEB-INF/lib/foo.jar!/\" are created\nto access JAR entries, replace it with code that instead wraps a JarInputStream\naround the stream retrieved from the ServletContext.getResourceAsStream(). As\nfar as I can tell, there are three places in Catalina and Jasper (I have not\nlooked as non-essential code, such as the various management applications):\n  + o.a.c.startup.ContextConfig\n  + o.a.j.compiler.TagLibrayInfoImpl\n  + o.a.j.compiler.TldLocationsCache\n\nI have made these changes for my distribution, but it would be really nice to\nsee the same changes made in the Tomcat source. Here is an updated version of\nthe affected o.a.c.startup.ContextConfig code:\n\n    private void tldScanJar(String resourcePath, SAXParser saxParser,\n\t\t\t    DefaultHandler tldHandler) throws Exception {\n\n        if (debug >= 1) {\n            log(\" Scanning JAR at resource path '\" + resourcePath + \"'\");\n        }\n\n        String name = null;\n\tJarInputStream jarIS = null;\n        try {\n            URL url = context.getServletContext().getResource(resourcePath);\n            if (url == null) {\n                throw new IllegalArgumentException\n                    (sm.getString(\"contextConfig.tldResourcePath\",\n                                  resourcePath));\n            }\n\t    jarIS = new JarInputStream(url.openStream());\n\t    JarEntry entry = null;\n\t    while ((entry = jarIS.getNextJarEntry()) != null) {\n                name = entry.getName();\n\t\tif (debug >= 2) {\n\t\t    log(\" Looking at '\" + name + \"' in '\" + resourcePath + \"'\");\n\t\t}\n                if (!name.startsWith(\"META-INF/\")) {\n                    continue;\n                }\n                if (!name.endsWith(\".tld\")) {\n                    continue;\n                }\n                if (debug >= 2) {\n                    log(\"  Processing TLD at '\" + name + \"'\");\n                }\n                tldScanStream(jarIS, saxParser, tldHandler);\n            }\n        } catch (Exception e) {\n            if (name == null) {\n\t\tlog(sm.getString(\"contextConfig.tldJarException\",\n\t\t\t\t resourcePath), e);\n            } else {\n                log(sm.getString(\"contextConfig.tldEntryException\",\n\t\t\t\t name, resourcePath), e);\n            }\n        } finally {\n            if (jarIS != null) {\n                try {\n\t\t    jarIS.close();\n                } catch (Throwable t) {\n                    ;\n                }\n            }\n        }\n    }\n\n    private void tldScanStream(InputStream resourceStream, SAXParser saxParser,\n\t\t\t       DefaultHandler tldHandler)\n        throws Exception {\n\n\t/*\n\t * Create a wrapper around the stream so that it doesn't close\n\t * when the parser calls close(). Unless this is done, parsing\n\t * a JarInputStream fails when looking for the next entry.\n\t */\n\tInputStream is = new InputStreamWrapper(resourceStream);\n\tsaxParser.parse(is, tldHandler);\n    }\n\n    private static class InputStreamWrapper extends InputStream {\n\tprivate InputStream is;\n\tpublic InputStreamWrapper(InputStream is) {\n\t    this.is = is;\n\t}\n\tpublic int read() throws IOException {return is.read();}\n\tpublic int read(byte[] b) throws IOException {return is.read(b);}\n\tpublic int read(byte[] b, int off, int len) throws IOException {\n\t    return is.read(b, off, len);\n\t}\n\tpublic long skip(long n) throws IOException {return is.skip(n);}\n\tpublic int available() throws IOException {return is.available();}\n\tpublic void close() throws IOException {\n\t    // A no-op in this wrapper\n\t}\n\tpublic void mark(int readLimit) {is.mark(readLimit);}\n\tpublic void reset() throws IOException {is.reset();}\n\tpublic boolean markSupported() {return is.markSupported();}\n    }\n\nThe changes needed in o.a.j.compiler.TagLibrayInfoImpl and\no.a.j.compiler.TldLocationsCache are very similar, but if you want them, I'll\npost them as well.\n\nA possible alternative to this solution is to create a new \nDirContextJarURLStreamHandler that returns a JarURLConnection from\nopenConnection() and let o.a.c.c.ApplicationContext provide an instance of this\nclass for all URLs that represent JAR files in the JNDI context. All places\nwhere JAR files are scanned must still be changed, so I think it's pretty much\nthe same amount of work. I have not tested this alternative and I'm not sure if\nit has any advantages over the approach I describe here.", "id": 28091, "time": "2002-12-20T05:51:45Z", "creator": "hans@gefionsoftware.com", "creation_time": "2002-12-20T05:51:45Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 15557, "attachment_id": null, "text": "http://marc.theaimsgroup.com/?t=109218729100002&r=1&w=2", "id": 61845, "time": "2004-08-11T17:33:27Z", "creator": "yoavs@computer.org", "creation_time": "2004-08-11T17:33:27Z", "is_private": false}]