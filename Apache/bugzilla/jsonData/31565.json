[{"attachment_id": null, "tags": [], "bug_id": 31565, "is_private": false, "count": 0, "id": 64701, "time": "2004-10-06T15:52:17Z", "creator": "tchan@austin.rr.com", "creation_time": "2004-10-06T15:52:17Z", "text": "I have this test program which starts apache.  The result is the child processes\nall die on an accept() call with errno 88 (ENOTSOCK).\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <syslog.h>\n\nint main (int argc, char *argv[]) {\n    int i;\n    char *arg;\n\n    if (argc < 2) {\n        printf(\"Must specify the path to the executable\\n\");\n        exit(1);\n    }\n    close(0);\n    close(1);\n    close(2);\n\n    arg = malloc(strlen(argv[1]) + 1);\n    strcpy(arg, argv[1]);\n    for (i = 2; i < argc; i++) {\n        arg = realloc(arg, strlen(arg) + strlen(argv[i]) + 2);\n        strcat(arg, \" \");\n        strcat(arg, argv[i]);\n    }\n    syslog(LOG_ERR, \"Calling system(%s)\", arg);\n    system(arg);\n    exit(0);\n}\n\nIf I comment out the close()'s (or open /dev/null in their place), the child\nprocesses will have no problems.\n\nI think the problem is with the order of these events:\nFirst, apache processes the config file with a LISTEN directive, opens the\nlisten socket(s) and keeps the file descriptor(s) in its table.  With no stdin,\nstdout, etc, the first listen socket will be fd 0 and so on.\nThen later, apr_proc_detach() in srclib/apr/threadproc/unix/procsup.c does\nfreopen() on stdin, stdout and stderr which, regardless of whether fd 0, 1 and 2\nare sockets or the std files, may wipe out listen sockets created earlier.\nLater, when accept() is called on the first listen socket, it has already been\nfreopen() to a file, causing ENOTSOCK."}, {"count": 1, "tags": [], "creator": "chip@force-elite.com", "attachment_id": null, "id": 66395, "time": "2004-11-04T02:36:09Z", "bug_id": 31565, "creation_time": "2004-11-04T02:36:09Z", "is_private": false, "text": "Ouch.\n\nMoving this to a enhancement since the solution involves hacking into APR :("}]