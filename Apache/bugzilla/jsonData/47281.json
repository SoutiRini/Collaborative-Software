[{"count": 0, "tags": [], "creator": "grant-genereux@shaw.ca", "text": "I\u2019ve been using the PersistentManager with the JDBCStore.  On the surface it appears to work as designed.  However, depending on how it is used, I think it is somewhat self-defeating.\n\nIf it is being used to simply save and restore sessions across application restarts, then I think it works fine.\n\nIf you want to use it to swap out idle sessions and reduce the total amount of memory theses idle session are consuming, then it is not too effective.\n\nThe issues is with in the processExpires method of  org.apache.catalina.session.StoreBase  and called from org.apache.catalina.session.PersistentManagerBase.\n\nBasically speaking; what StoreBase.processExpires() does is\n\n1.\tGets all the keys from the store ( in this case the JDBCStore)\n2.\tLoads all the sessions from the JDBCStore\n3.\tRemoves and deletes any expired session.\n\nThe problem is that in step 2 above, we\u2019ve loaded all the fully de-serialized sessions back into memory.  This happens every few minutes with the default configuration.  \n\nSo, at the time of the call to processExpires() the total amount of memory being consumed by sessions is no less than if we had not swapped them out to the store.  \n\nIt is actually more if we are using the persistent store to back up ( not swap out) sessions.  Since, in that case, we may now have two instances of each of these sessions in memory.   \n\nI\u2019ve implemented a different method to delete expired sessions directly from the DB, without reloading them into memory.\n\nEffectively executing a SQL statement like:\n\nDELETE FROM tomcat_sessions WHERE app_name = ?  AND ( valid_session = '0' OR  ? > (last_access+max_inactive*1000)  )\n\nWhere the second parameter is set with the System.currentTimeMillis().\n\nBut, there is a downside to this approach, in that the full life cycle contract of the sessions is not observed.  No listeners are called when the session is removed from store. \n\nIn my application\u2019s case, this is not an issue.  But, it most certainly could be for others.\n\nAdditionally, it could be that for some reason an expired session swapped out to the store is still in memory.  So, we should probably first get the session keys of the expired sessions before we delete them, and ensure that they are removed from memory as well.\nI am happy to share my work-around, and work on a more robust solution if anyone is interested.", "id": 127473, "time": "2009-05-28T05:38:13Z", "bug_id": 47281, "creation_time": "2009-05-28T05:38:13Z", "is_private": false, "attachment_id": null}, {"count": 1, "tags": [], "bug_id": 47281, "text": "(In reply to comment #0)\n\n> Basically speaking; what StoreBase.processExpires() does is\n> \n> 1.    Gets all the keys from the store ( in this case the JDBCStore)\n> 2.    Loads all the sessions from the JDBCStore\n> 3.    Removes and deletes any expired session.\n> \n> The problem is that in step 2 above, we\u2019ve loaded all the fully de-serialized\n> sessions back into memory.  This happens every few minutes with the default\n> configuration.  \n> \n> So, at the time of the call to processExpires() the total amount of memory\n> being consumed by sessions is no less than if we had not swapped them out to\n> the store.  \n\nAre you sure. Looking at the code it loops through the list of sessions doing steps 2 and 3 above for one session at a time rather than all sessions at once.", "id": 127474, "time": "2009-05-28T05:59:47Z", "creator": "markt@apache.org", "creation_time": "2009-05-28T05:59:47Z", "is_private": false, "attachment_id": null}, {"count": 2, "attachment_id": null, "bug_id": 47281, "text": "(In reply to comment #1)\n> (In reply to comment #0)\n> \n> > Basically speaking; what StoreBase.processExpires() does is\n> > \n> > 1.    Gets all the keys from the store ( in this case the JDBCStore)\n> > 2.    Loads all the sessions from the JDBCStore\n> > 3.    Removes and deletes any expired session.\n> > \n> > The problem is that in step 2 above, we\u2019ve loaded all the fully de-serialized\n> > sessions back into memory.  This happens every few minutes with the default\n> > configuration.  \n> > \n> > So, at the time of the call to processExpires() the total amount of memory\n> > being consumed by sessions is no less than if we had not swapped them out to\n> > the store.  \n> \n> Are you sure. Looking at the code it loops through the list of sessions doing\n> steps 2 and 3 above for one session at a time rather than all sessions at once.\n\nThanks for the quick reply,\n\nYes, but depending upon when the GC thread kicks in.\nIf not during the: \n  for (int i = 0; i lt keys.length; i++) \nthen by the end of that statement, we'll have all the sessions back in memory.\nYes, since the reference is not kept, the GC can collect them, but it could be a bit intensive.\n\nThanks", "id": 127475, "time": "2009-05-28T06:35:44Z", "creator": "grant-genereux@shaw.ca", "creation_time": "2009-05-28T06:35:44Z", "tags": [], "is_private": false}, {"count": 3, "tags": [], "text": "After some more thought; I think a more correct approach would be to have\n\nStoreBase.processExpires()  call a method to just return the expired keys; rather than keys() (returns all keys).  It would be very similar to keys() except it includes an additional where clause such as:\n\nAND ( valid_session = '0' OR  ?\n.gt. (last_access+max_inactive*1000)  )\n\n\nWith that change, only expired sessions will be re-loaded, and we maintain the session life-cycle contract.", "is_private": false, "bug_id": 47281, "id": 127480, "time": "2009-05-28T09:13:38Z", "creator": "grant-genereux@shaw.ca", "creation_time": "2009-05-28T09:13:38Z", "attachment_id": null}, {"count": 4, "tags": [], "creator": "felix.schumacher@internetallee.de", "text": "\n\n*** This bug has been marked as a duplicate of bug 34319 ***", "id": 186469, "time": "2015-11-21T13:18:24Z", "bug_id": 47281, "creation_time": "2015-11-21T13:18:24Z", "is_private": false, "attachment_id": null}]