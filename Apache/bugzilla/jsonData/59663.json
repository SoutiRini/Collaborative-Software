[{"count": 0, "tags": [], "bug_id": 59663, "text": "Created attachment 33910\nexample\n\nPreface:\nI did read the FAQ - where it says \"Accessing the same document in multiple threads will not work.\"\nAlso I read the linked discussion (https://mail-archives.apache.org/mod_mbox/poi-user/201109.mbox/%3C1314859350817-4757295.post@n5.nabble.com%3E).\n---\n\nIn most of the discussions I read about thread safety in POI people talk about creating/writing the same document via different threads. I completely understand that making WRITING thread safe isn't trivial and probably has many many pitfalls (apart from performance implications) so that's why it isn't implemented in POI (right now).\n\nHowever, what I am wondering is if it would be possible to make POI thread safe when reading the same worksheet via multiple threads in parallel at the same time.\nWe have quite large Excel files which we have to read-only (including evaluating a lot of cell-formulars, etc.).\nBeing able to read a workbook with multiple concurrent threads at the same time would speed thing up a lot for us - and probably for other people as well.\n\nFor me - as someone who doesn't know the codebase and it's architecture - my first thought was that all that needs to be done is to make some caches thread safe (by using ConcurrentHashMaps instead of normal HashMaps) and maybe some other minor tweaks...\n\nE.g. today, I implemented a small app which tries read a worksheet via multiple threads concurrently - and of course it failed with this exception:\n----\nCaused by: java.lang.ClassCastException: java.util.HashMap$Node cannot be cast to java.util.HashMap$TreeNode\n\tat java.util.HashMap$TreeNode.moveRootToFront(HashMap.java:1819)\n\tat java.util.HashMap$TreeNode.treeify(HashMap.java:1936)\n\tat java.util.HashMap.treeifyBin(HashMap.java:771)\n\tat java.util.HashMap.putVal(HashMap.java:643)\n\tat java.util.HashMap.put(HashMap.java:611)\n\tat org.apache.poi.ss.formula.PlainCellCache.put(PlainCellCache.java:84)\n\tat org.apache.poi.ss.formula.EvaluationCache.getPlainValueEntry(EvaluationCache.java:136)\n\tat org.apache.poi.ss.formula.EvaluationTracker.acceptPlainValueDependency(EvaluationTracker.java:145)\n\tat org.apache.poi.ss.formula.WorkbookEvaluator.evaluateAny(WorkbookEvaluator.java:242)\n\tat org.apache.poi.ss.formula.WorkbookEvaluator.evaluateReference(WorkbookEvaluator.java:702)\n\tat org.apache.poi.ss.formula.SheetRefEvaluator.getEvalForCell(SheetRefEvaluator.java:48)\n\tat org.apache.poi.ss.formula.SheetRangeEvaluator.getEvalForCell(SheetRangeEvaluator.java:74)\n\tat org.apache.poi.ss.formula.LazyAreaEval.getRelativeValue(LazyAreaEval.java:51)\n\tat org.apache.poi.ss.formula.eval.AreaEvalBase.getValue(AreaEvalBase.java:131)\n\tat org.apache.poi.ss.formula.functions.MultiOperandNumericFunction.collectValues(MultiOperandNumericFunction.java:151)\n\tat org.apache.poi.ss.formula.functions.MultiOperandNumericFunction.getNumberArray(MultiOperandNumericFunction.java:128)\n\tat org.apache.poi.ss.formula.functions.MultiOperandNumericFunction.evaluate(MultiOperandNumericFunction.java:90)\n\tat org.apache.poi.ss.formula.OperationEvaluatorFactory.evaluate(OperationEvaluatorFactory.java:132)\n\tat org.apache.poi.ss.formula.WorkbookEvaluator.evaluateFormula(WorkbookEvaluator.java:503)\n\tat org.apache.poi.ss.formula.WorkbookEvaluator.evaluateAny(WorkbookEvaluator.java:263)\n\tat org.apache.poi.ss.formula.WorkbookEvaluator.evaluateReference(WorkbookEvaluator.java:702)\n\tat org.apache.poi.ss.formula.SheetRefEvaluator.getEvalForCell(SheetRefEvaluator.java:48)\n\tat org.apache.poi.ss.formula.SheetRangeEvaluator.getEvalForCell(SheetRangeEvaluator.java:74)\n\tat org.apache.poi.ss.formula.LazyRefEval.getInnerValueEval(LazyRefEval.java:43)\n\tat org.apache.poi.ss.formula.eval.OperandResolver.chooseSingleElementFromRef(OperandResolver.java:179)\n\tat org.apache.poi.ss.formula.eval.OperandResolver.getSingleValue(OperandResolver.java:62)\n\tat org.apache.poi.ss.formula.eval.TwoOperandNumericOperation.singleOperandEvaluate(TwoOperandNumericOperation.java:29)\n\tat org.apache.poi.ss.formula.eval.TwoOperandNumericOperation.evaluate(TwoOperandNumericOperation.java:36)\n\tat org.apache.poi.ss.formula.functions.Fixed2ArgFunction.evaluate(Fixed2ArgFunction.java:33)\n\tat org.apache.poi.ss.formula.OperationEvaluatorFactory.evaluate(OperationEvaluatorFactory.java:119)\n\tat org.apache.poi.ss.formula.WorkbookEvaluator.evaluateFormula(WorkbookEvaluator.java:503)\n\tat org.apache.poi.ss.formula.WorkbookEvaluator.evaluateAny(WorkbookEvaluator.java:263)\n\tat org.apache.poi.ss.formula.WorkbookEvaluator.evaluateReference(WorkbookEvaluator.java:702)\n\tat org.apache.poi.ss.formula.SheetRefEvaluator.getEvalForCell(SheetRefEvaluator.java:48)\n\tat org.apache.poi.ss.formula.SheetRangeEvaluator.getEvalForCell(SheetRangeEvaluator.java:74)\n\tat org.apache.poi.ss.formula.LazyAreaEval.getRelativeValue(LazyAreaEval.java:51)\n\tat org.apache.poi.ss.formula.LazyAreaEval.getRelativeValue(LazyAreaEval.java:45)\n\tat org.apache.poi.ss.formula.eval.AreaEvalBase.getValue(AreaEvalBase.java:128)\n\tat org.apache.poi.ss.formula.functions.LookupUtils$ColumnVector.getItem(LookupUtils.java:100)\n\tat org.apache.poi.ss.formula.functions.Vlookup.evaluate(Vlookup.java:59)\n\tat org.apache.poi.ss.formula.functions.Var3or4ArgFunction.evaluate(Var3or4ArgFunction.java:36)\n\tat org.apache.poi.ss.formula.OperationEvaluatorFactory.evaluate(OperationEvaluatorFactory.java:132)\n\tat org.apache.poi.ss.formula.WorkbookEvaluator.evaluateFormula(WorkbookEvaluator.java:503)\n\tat org.apache.poi.ss.formula.WorkbookEvaluator.evaluateAny(WorkbookEvaluator.java:263)\n\tat org.apache.poi.ss.formula.WorkbookEvaluator.evaluate(WorkbookEvaluator.java:205)\n\tat org.apache.poi.hssf.usermodel.HSSFFormulaEvaluator.evaluateFormulaCellValue(HSSFFormulaEvaluator.java:374)\n\tat org.apache.poi.hssf.usermodel.HSSFFormulaEvaluator.evaluate(HSSFFormulaEvaluator.java:202)\n----\nThis exception could be fixed be making _plainValueEntriesByLoc a ConcurrentHashMap in https://github.com/apache/poi/blob/REL_3_14_FINAL/src/java/org/apache/poi/ss/formula/PlainCellCache.java#L81\nI had a quick look in the codebase and it looks like there are some more caches which probably could just be changed to a ConcurrentHashMap...\n\n\nWhat do you think?\nIs there a chance to make this work? Or am I completly wrong?", "id": 191385, "time": "2016-06-03T20:04:05Z", "creator": "m.kurz@irregular.at", "creation_time": "2016-06-03T20:04:05Z", "is_private": false, "attachment_id": 33910}]