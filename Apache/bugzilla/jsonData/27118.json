[{"count": 0, "tags": [], "bug_id": 27118, "attachment_id": null, "text": "When you override a target in an <import>ed project, the original target is \naccessible via [importedbuildname].[targetname].  This is not true of types \nsuch as filesets, patternsets, selectors...\n\nIt would be extraordinarily helpful if you could override a type's definition \nreplacing it, but still have the opportunity to use the overriden type's \ndefinition.  For example, extend a patternset by combining the original \ndefinition with extra patterns.\n\nWithout this capability, you have to either:\na) require that overriders, reimplement the content of the imported types via \ncopy-paste (ick)\nb) explicitly code into an imported build \"framework\" types whose sole \nexistence is to be overridden and combined with the framework's default types \nin order to avoid copy-paste reuse.  For example, in the imported file\n\n   <selector id=\"someselector\">...</selector>\n   <selector id=\"someoverridableselector\"><filename name=\"**/*\"/></selector>\n   <target name=\"sometarget\">\n      <copy todir=\"...\">\n         <fileset dir=\"...\">\n            <and>\n               <selector refid=\"someselector\"/>\n               <selector refid=\"someoverridableselector\"/>\n            </and>\n         </fileset>\n      </copy>\n   </target>\n\nthen in importing file, 'someoverridableselector' can be changed from including \neverything to including a subset, thus refining the set of files copied \nin 'sometarget'.  In addition to being cumbersome to implement this pattern, \nthis approach is pretty inefficient since anding with the \ndefault 'someoverridableselector' adds cost.\n\nAn alternative might work but which is nearly as unweildy is:\n\n   <selector id=\"someselector\">...</selector>\n   <selector id=\"someoverridableselector\">\n      <and><selector refid=\"someselector\"/></and>\n   </selector>\n   <target name=\"sometarget\">\n      <copy todir=\"...\">\n         <fileset dir=\"...\">\n            <selector refid=\"someoverridableselector\"/>\n         </fileset>\n      </copy>\n   </target>\n\nand having the overrider choose to do:\n\n   <selector id=\"someoverridableselector\">\n      <and>\n         <myrefiningselector/>\n         <selector refid=\"someselector\"/>\n      </and>\n   </selector>\n\nBut having to design this extensibility into the framework is a real pain.\n\nInstead it would be great to be able to do:\n\n   <selector id=\"someselector\">ant</selector>\n   <target name=\"sometarget\">\n      <copy todir=\"...\">\n         <fileset dir=\"...\">\n            <selector refid=\"someselector\"/>\n         </fileset>\n      </copy>\n   </target>\n\nand override 'someselector' with:\n\n   <selector id=\"someselector\">\n      <and>\n         <myrefiningselector/>\n         <selector refid=\"importedproject.someselector\"/>\n      </and>\n   </selector>\n\nAlternative ways to get what I want would be great.", "id": 52674, "time": "2004-02-20T16:38:06Z", "creator": "apache@eeaston.com", "creation_time": "2004-02-20T16:38:06Z", "is_private": false}]