[{"count": 0, "tags": [], "bug_id": 48204, "attachment_id": null, "is_private": false, "id": 131994, "time": "2009-11-16T03:56:48Z", "creator": "hartmut.keil@gmx.ch", "creation_time": "2009-11-16T03:56:48Z", "text": "With the patch http://www.apache.org/dist/httpd/patches/apply_to_2.2.14/CVE-2009-3555-2.2.patch client initiated renegotiation has been disabled,\nas a consequence of CVE-2009-3555.\n\nBut in the case of a server initiated renegotiation a MITM attacker can still \nexecute an arbitrary request within the victims context:\n\no the MITM is sending a complete HTTP request, lets say with URL /cert\n  and an incomplete request with URL /cert/hacked. With incomplete\n  is meant, that the last request header, lets say 'X-Ignore' is not \n  terminated.\n\no both request will be buffered in the function 'ssl_io_input_read(..)'\n  in the cbuf of the struct bio_filter_in_ctx.\n\no the URL of the first request is triggering mod_ssl to initiate a SSL \n  renegotiation\n\no the MITM is forwarding the SSL handshakes messages and the payload from the \n  victim, in the way described in \n  http://extendedsubset.com/Renegotiating_TLS.pdf.\n\no in the end the server is executing the second request /cert/hacked of the MITM\n  with the headers of the victim request, especially the Cookie header \n  (These kind of attack has been executed by us against httpd/2.2.14 with the \n   CVE-2009-3555-2.2.patch.)\n\n\nA simple countermeasure is to reset the buffer 'cbuf' of the decrypted data \nin case of a server initiated renegotiation. See the following patch of the method 'bio_filter_in_read(..) in ssl_engine_io.c\n\n--- ssl_engine_io.c.patched     2009-11-16 10:57:23.416525000 +0100\n+++ ssl_engine_io.c     2009-11-16 11:46:51.090262000 +0100\n@@ -478,6 +478,10 @@\n         inctx->rc = APR_ECONNABORTED;\n         return -1;\n     }\n+       /* Clear buffer with decrypted data if the server has initiated a renegotiation. */\n+       if (inctx->filter_ctx->config->reneg_state == RENEG_ALLOW) {\n+        char_buffer_write(&inctx->cbuf, NULL, 0);\n+    }\n\n     /* XXX: flush here only required for SSLv2;\n      * OpenSSL calls BIO_flush() at the appropriate times for"}, {"count": 1, "tags": [], "bug_id": 48204, "attachment_id": null, "text": "> A simple countermeasure is to reset the buffer 'cbuf' of the decrypted data \n> in case of a server initiated renegotiation. See the following patch of the\n> method 'bio_filter_in_read(..) in ssl_engine_io.c\n\nHow does this not discard a legitimate clients request line?", "id": 131998, "time": "2009-11-16T04:33:39Z", "creator": "covener@gmail.com", "creation_time": "2009-11-16T04:33:39Z", "is_private": false}, {"count": 2, "tags": [], "bug_id": 48204, "attachment_id": null, "is_private": false, "id": 131999, "time": "2009-11-16T04:39:52Z", "creator": "hartmut.keil@gmx.ch", "creation_time": "2009-11-16T04:39:52Z", "text": "(In reply to comment #1)\n> > A simple countermeasure is to reset the buffer 'cbuf' of the decrypted data \n> > in case of a server initiated renegotiation. See the following patch of the\n> > method 'bio_filter_in_read(..) in ssl_engine_io.c\n> \n> How does this not discard a legitimate clients request line?\n\nNo. If mod_ssl is initiated a SSL renegotiation, the request header is already\nparsed/consumed."}, {"count": 3, "tags": [], "bug_id": 48204, "attachment_id": null, "id": 132000, "time": "2009-11-16T04:46:12Z", "creator": "covener@gmail.com", "creation_time": "2009-11-16T04:46:12Z", "is_private": false, "text": "(In reply to comment #2)\n> (In reply to comment #1)\n> > > A simple countermeasure is to reset the buffer 'cbuf' of the decrypted data \n> > > in case of a server initiated renegotiation. See the following patch of the\n> > > method 'bio_filter_in_read(..) in ssl_engine_io.c\n> > \n> > How does this not discard a legitimate clients request line?\n> \n> No. If mod_ssl is initiated a SSL renegotiation, the request header is already\n> parsed/consumed.\n\nSorry to be obtuse, but then how does this help in the attack scenario?"}, {"count": 4, "tags": [], "text": "(In reply to comment #3)\n> (In reply to comment #2)\n> > (In reply to comment #1)\n> > > > A simple countermeasure is to reset the buffer 'cbuf' of the decrypted data \n> > > > in case of a server initiated renegotiation. See the following patch of the\n> > > > method 'bio_filter_in_read(..) in ssl_engine_io.c\n> > > \n> > > How does this not discard a legitimate clients request line?\n> > \n> > No. If mod_ssl is initiated a SSL renegotiation, the request header is already\n> > parsed/consumed.\n> \n> Sorry to be obtuse, but then how does this help in the attack scenario?\n\nThe second, incomplete request in cbuff will be discarded, and request splicing\nis no longer working", "is_private": false, "bug_id": 48204, "id": 132001, "time": "2009-11-16T04:56:12Z", "creator": "hartmut.keil@gmx.ch", "creation_time": "2009-11-16T04:56:12Z", "attachment_id": null}, {"count": 5, "tags": [], "text": "(In reply to comment #4)\n> (In reply to comment #3)\n> > (In reply to comment #2)\n> > > (In reply to comment #1)\n> > > > > A simple countermeasure is to reset the buffer 'cbuf' of the decrypted data \n> > > > > in case of a server initiated renegotiation. See the following patch of the\n> > > > > method 'bio_filter_in_read(..) in ssl_engine_io.c\n> > > > \n> > > > How does this not discard a legitimate clients request line?\n> > > \n> > > No. If mod_ssl is initiated a SSL renegotiation, the request header is already\n> > > parsed/consumed.\n> > \n> > Sorry to be obtuse, but then how does this help in the attack scenario?\n> \n> The second, incomplete request in cbuff will be discarded, and request splicing\n> is no longer working\n\nSorry, I see now -- this is not a measure to allow the non-attack scenario, it's just the other half of the nuclear option for admins who haven't removed their per-dir renegotiation stuff.", "attachment_id": null, "id": 132002, "creator": "covener@gmail.com", "time": "2009-11-16T05:07:03Z", "bug_id": 48204, "creation_time": "2009-11-16T05:07:03Z", "is_private": false}, {"count": 6, "tags": [], "bug_id": 48204, "attachment_id": null, "is_private": false, "id": 132004, "time": "2009-11-16T05:49:33Z", "creator": "jorton@redhat.com", "creation_time": "2009-11-16T05:49:33Z", "text": "1) I'm surprised that patch has any effect; if it does, surely it is due to timing of the receipt of the app-data packets comprising the victim's request by the server, which is under the control of the attacker?\n\n2) I can't see how discarding data at this point is a good idea - if you presume the connection is under active attack in that code path, the only sane course of action is to log that and close the connection, right?  If you don't presume the connection is under active attack then discarding bytes is going to cause \nsome weird and wonderful failure modes.\n\nI think it'd be better to discuss this on dev@httpd to get a wider audience.  Could you start a thread there, maybe with some packet traces or similar to outline how this would work?"}]