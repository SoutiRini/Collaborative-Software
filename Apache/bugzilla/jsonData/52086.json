[{"count": 0, "tags": [], "text": "Created attachment 27844\nzip file containing patch and chart image\n\nThis bug report is an extracted abstract from the mail 'SSTRecord.serialize()\nperformance improvement patch for huge hssf output' in the 'dev@poi.apache.org'\nML.\nPlease use the 'patch' program to patch the files, such as 'patch -p 0\n< HOGE.patch'.\nI tried to use eclipse to patch them, but I found that any trial will fail.\n\n---\nThis patch contains some output performance hacks\naround the packages of org.apache.poi.hssf.record.cont and\norg.apache.poi.util.\nThe patch provides both 2~4x performance improvement and some conveniences\nin the serialization of SST.\n\nThe essential feature of patch is to extend the LittleEndianOutput (\nand the implementation classes )\nfor itself (themselves) to write out the String in the both formats of\nASCII and UTF16LE.\nThis extension internalizes the frequent polymorphism calls of\nUnknownLengthRecordOutput#writeShort() or writeByte()\nin the  ContinuableRecord#writeCharacterData().\nThe call internalization enables the jvm to avoid the polymorphism\ncost along the technique of code inlining per class .\n\nFurthermore, the template adapters of this extension are provided by\nLittleEndianOutputAdapter, LittleEndianOutputByteStreamAdatper and\nLittleEndianOutputFilterAdapter\nto ease to build up the implementation class of LittleEndianOutput.\nBy using the class tree, I implemented\nLittleEndianOutputBufferedRandomAccessFile for the performance check\nneeds,\nwhich uses the random access file coupled with buffers as the output\ndestination and\nalso supports the DelayableLittleEndianOutput interface.\n\nThe features of patch can be enabled and disabled by flipping the two\nboolean flags of\nContinuableRecordOutput.useFasterWrite and\nUnknownLengthRecordOutput.useFasterWrite.\nThe performances at changing these flags are investigated below.\n\nYou can verify the correctness of this patch\nby running the test 'testSSTRecord_DigestCheck()' contained in the\nprevious 'first-sstser-verify37.patch'\nfor each  example serialization method.\nThe example methods are Memory, DirectRandomAccessFile, StreamFile and\n LZFCompressFile in 'SerializationFunction'.\nPlease be careful to use the LZFCompressFile serialization method because\nit requires the compress-lzf-0.8.4.jar or upper which can be fetched\nfrom the maven repository.\nSee http://www.jarvana.com/jarvana/archive-details/com/ning/compress-lzf/0.8.4/compress-lzf-0.8.4.jar\nfor the more details of jar.\n\nThe performance of this patch is investigated in the table below by\ninvoking the newly created method\nTestSSTRecord.testSSTRecordPerformance()\nwith the small code change from 'int N = 1<<10' to 'int N= 1<<20'\nunder the jdk(1.6.0_26) of option '-Xmx1224m -server'.\nThe elapsed time of 2^20 SSTReocrds serialization in seconds are\nmeasured 60 times.\nThen, the statistics is calculated by excluding 40 extreme\nmeasurements for each serialization, avoiding ill measurements.\nThe value and plus minus sign represent the mean and the standard\ndeviation of serialization time.\n\n\njava: oracle jdk 1.6.0_26\noption: -Xmx1224m -server\ncpu: Intel core i5-2400\nOS: windows 7\n\nOptimization    enum_SerializeFunction  Mean Time               Standard Deviation\n---     ---     ---     --      ---\nU@T/C@T Memory  0.248   +-      0.002   secs\nU@T/C@T DirectRandomAccessFile  0.94    +-      0.024   secs\nU@T/C@T StreamFile      0.936   +-      0.072   secs\nU@T/C@T LZFCompressFile 0.362   +-      0.002   secs\n---     ---     ---     --      ---\nU@F/C@T Memory  0.213   +-      0.002   secs\nU@F/C@T DirectRandomAccessFile  0.881   +-      0.046   secs\nU@F/C@T StreamFile      0.827   +-      0.039   secs\nU@F/C@T LZFCompressFile 0.438   +-      0.004   secs\n---     ---     ---     --      ---\nU@T/C@F Memory  0.744   +-      0.001   secs\nU@T/C@F DirectRandomAccessFile  0.939   +-      0.029   secs\nU@T/C@F StreamFile      0.901   +-      0.031   secs\nU@T/C@F LZFCompressFile 0.658   +-      0.002   secs\n---     ---     ---     --      ---\nU@F/C@F Memory  1.011   +-      0.005   secs\nU@F/C@F DirectRandomAccessFile  1.29    +-      0.003   secs\nU@F/C@F StreamFile      0.837   +-      0.039   secs\nU@F/C@F LZFCompressFile 0.902   +-      0.003   secs\n---     ---     ---     --      ---\nMANUAL_HACK      Memory 0.237   +-      0.002   secs\nMANUAL_HACK      DirectRandomAccessFile 1.174   +-      0.094   secs\nMANUAL_HACK        StreamFile   0.806   +-      0.042   secs\nMANUAL_HACK      LZFCompressFile        0.384   +-      0.002   secs\n\nPlease see the 'ser_perf.png' image attached, which\ncontains a chart of the mean time for each serialize method in the\noptimizations.\nThe 'U@[TF]/C@[TF]' of 'Optimization' column indicates whether the\nflags of UnknownLengthRecordOutput.useFasterWrite and\nContinuableRecordOutput.useFasterWrite\nare TRUE or FALSE.\nIn this case, the 'U@F/C@F' is identical to the original method.\nThe values of 'MANUAL' rows mean the ones in which  the current poi\nclass trees  around the SSTSerializer are fully refactored and\noptimized as well as possible.\n#Note.. The 'MANUAL' code is not included in this patch because the\nclass tree is too much changed.\n\nFrom the table and chart,\nI concluded that  the method\n'ContinuableRecordOutput.useFasterWrite=true' and\n'UnknownLengthRecordOutput.useFasterWrite=true'\nis 2~4 times faster than the original method in the cpu dependent\ncases such as the Memory and LZFCompressedFile.\nFurthermore, from the result of full manual hack, the performance is\nreasonable and optimal for the small source code changes of patch.\n\nOn the other hand, the worse performances in the disk dependent cases,\nsuch as DirectRandomAccessFile and StreamFile,  are required to be\nfixed.\nNevertheless  the patch cannot solve the cases.\nIn my experience, the disk resource are more limited in a server\nprocessing than the cpu resource\nalthough it is required to improve the disk performance in the disk\ndependent cases.\nThese facts indicate that the compressed writer such as\nLZFCompressedFile is necessary to improve the throughput of huge\n'.xls's in a server.", "attachment_id": 27844, "id": 150899, "creator": "kuz+poi@altpaper.net", "time": "2011-10-25T14:09:57Z", "bug_id": 52086, "creation_time": "2011-10-25T14:09:57Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 52086, "attachment_id": null, "id": 151070, "time": "2011-10-31T07:27:15Z", "creator": "yegor@dinom.ru", "creation_time": "2011-10-31T07:27:15Z", "is_private": false, "text": "Thanks for the patch. I put it in my TODO list, but it will take some time to review.\n\nRegards,\nYegor"}, {"count": 2, "tags": [], "bug_id": 52086, "attachment_id": null, "text": "Finally I had time to review this patch, thanks for your patience. \n\nI made a small change to initialize the useFasterWrite from a system property:\n\nprivate static final boolean useFasterWrite = Boolean.getBoolean(\"org.apache.poi.sstFastWrite\");\n\nthis way I can test both modes without re-compiling the code. \n\nThe patch does improve performance but not that much as in your tests. In the best case I got 25% faster which is far from \"2~4x performance improvement\" observed by you. \n\nIn my tests I ran TestSSTRecord#testSSTRecordPerformance() three times in two sets, either with org.apache.poi.sstFastWrite=true or org.apache.poi.sstFastWrite=false.\n\nBelow is the console output:\n\n-Dorg.apache.poi.sstFastWrite=true\nserializer\tMemory\t time\t0.328\t+-\t0.003\tsecs\nserializer\tMemory\t time\t0.302\t+-\t0.004\tsecs\nserializer\tMemory\t time\t0.319\t+-\t0.001\tsecs\n\n-Dorg.apache.poi.sstFastWrite=false\nserializer\tMemory\t time\t0.381\t+-\t0.002\tsecs\nserializer\tMemory\t time\t0.364\t+-\t0.004\tsecs\nserializer\tMemory\t time\t0.379\t+-\t0.001\tsecs\n\n\nMy test environment:\n\njava: oracle jdk 1.6.0_29 64 bit\noption: -Xmx1224m -server\ncpu: Intel core i5-2400\nOS: windows 7 64bit, 8GB RAM\nsize of SST: 1<<20\nserializer function: Memory\n\nIf the performance gain is only 25% then I would stay with current code and not made such big changes. \nAlso, can you provide some high-level tests that show how performance improves when saving real .xls files. How much does SST serialization take from the total time spent in workbook.write() ?  \n \n\nRegards,\nYegor", "id": 152771, "time": "2012-01-14T13:18:28Z", "creator": "yegor@dinom.ru", "creation_time": "2012-01-14T13:18:28Z", "is_private": false}, {"count": 3, "tags": [], "text": "I'm changing the status to NEEDINFO until my questions are answered.\n\nYegor", "attachment_id": null, "id": 154025, "creator": "yegor@dinom.ru", "time": "2012-02-22T12:17:40Z", "bug_id": 52086, "creation_time": "2012-02-22T12:17:40Z", "is_private": false}, {"count": 4, "tags": [], "bug_id": 52086, "text": "I'll attach a comprehensive test document for this patch performance.\nAll of the tests on the document is based on the POI-3.7 release.\nAlthough the situations of mine and yours are not identical,\nthe performance seems to improve 2x~4x by my patch  independent to some jvms and cpus of 32bit or 64bit.\n\n\n(In reply to comment #2)\n> Finally I had time to review this patch, thanks for your patience. \n> \n> I made a small change to initialize the useFasterWrite from a system property:\n> \n> private static final boolean useFasterWrite =\n> Boolean.getBoolean(\"org.apache.poi.sstFastWrite\");\n> \n> this way I can test both modes without re-compiling the code. \n> \n> The patch does improve performance but not that much as in your tests. In the\n> best case I got 25% faster which is far from \"2~4x performance improvement\"\n> observed by you. \n> \n> In my tests I ran TestSSTRecord#testSSTRecordPerformance() three times in two\n> sets, either with org.apache.poi.sstFastWrite=true or\n> org.apache.poi.sstFastWrite=false.\n> \n> Below is the console output:\n> \n> -Dorg.apache.poi.sstFastWrite=true\n> serializer    Memory     time    0.328    +-    0.003    secs\n> serializer    Memory     time    0.302    +-    0.004    secs\n> serializer    Memory     time    0.319    +-    0.001    secs\n> \n> -Dorg.apache.poi.sstFastWrite=false\n> serializer    Memory     time    0.381    +-    0.002    secs\n> serializer    Memory     time    0.364    +-    0.004    secs\n> serializer    Memory     time    0.379    +-    0.001    secs\n> \n> \n> My test environment:\n> \n> java: oracle jdk 1.6.0_29 64 bit\n> option: -Xmx1224m -server\n> cpu: Intel core i5-2400\n> OS: windows 7 64bit, 8GB RAM\n> size of SST: 1<<20\n> serializer function: Memory\n> \n> If the performance gain is only 25% then I would stay with current code and not\n> made such big changes. \n> Also, can you provide some high-level tests that show how performance improves\n> when saving real .xls files. How much does SST serialization take from the\n> total time spent in workbook.write() ?  \n> \n> \n> Regards,\n> Yegor\n\n(In reply to comment #3)\n> I'm changing the status to NEEDINFO until my questions are answered.\n> \n> Yegor\n\n(In reply to comment #2)\n> Finally I had time to review this patch, thanks for your patience. \n> \n> I made a small change to initialize the useFasterWrite from a system property:\n> \n> private static final boolean useFasterWrite =\n> Boolean.getBoolean(\"org.apache.poi.sstFastWrite\");\n> \n> this way I can test both modes without re-compiling the code. \n> \n> The patch does improve performance but not that much as in your tests. In the\n> best case I got 25% faster which is far from \"2~4x performance improvement\"\n> observed by you. \n> \n> In my tests I ran TestSSTRecord#testSSTRecordPerformance() three times in two\n> sets, either with org.apache.poi.sstFastWrite=true or\n> org.apache.poi.sstFastWrite=false.\n> \n> Below is the console output:\n> \n> -Dorg.apache.poi.sstFastWrite=true\n> serializer    Memory     time    0.328    +-    0.003    secs\n> serializer    Memory     time    0.302    +-    0.004    secs\n> serializer    Memory     time    0.319    +-    0.001    secs\n> \n> -Dorg.apache.poi.sstFastWrite=false\n> serializer    Memory     time    0.381    +-    0.002    secs\n> serializer    Memory     time    0.364    +-    0.004    secs\n> serializer    Memory     time    0.379    +-    0.001    secs\n> \n> \n> My test environment:\n> \n> java: oracle jdk 1.6.0_29 64 bit\n> option: -Xmx1224m -server\n> cpu: Intel core i5-2400\n> OS: windows 7 64bit, 8GB RAM\n> size of SST: 1<<20\n> serializer function: Memory\n> \n> If the performance gain is only 25% then I would stay with current code and not\n> made such big changes. \n> Also, can you provide some high-level tests that show how performance improves\n> when saving real .xls files. How much does SST serialization take from the\n> total time spent in workbook.write() ?  \n> \n> \n> Regards,\n> Yegor", "id": 154033, "time": "2012-02-22T15:45:35Z", "creator": "kuz+poi@altpaper.net", "creation_time": "2012-02-22T15:45:35Z", "is_private": false, "attachment_id": null}, {"count": 5, "tags": [], "bug_id": 52086, "attachment_id": 28363, "id": 154035, "time": "2012-02-22T15:48:13Z", "creator": "kuz+poi@altpaper.net", "creation_time": "2012-02-22T15:48:13Z", "is_private": false, "text": "Created attachment 28363\nverification of performance"}, {"count": 6, "tags": [], "creator": "yegor@dinom.ru", "attachment_id": null, "text": "Thanks for the comprehensive report. It appears that the observed results depend on how you run the test: from IDE or from ant. I ran my tests from IDE and got only 25%, you ran from Ant and got a \"2~4x\" improvement .\n\nI still want to see how this patch affects performance when saving real excel documents. The test that was used to generate the report is too \"in vitro\" : it does not tell how much time serialization of SST takes in comparison with total time spent in workbook.write(OutputStream). \n\nYegor", "id": 154273, "time": "2012-02-27T08:36:17Z", "bug_id": 52086, "creation_time": "2012-02-27T08:36:17Z", "is_private": false}]