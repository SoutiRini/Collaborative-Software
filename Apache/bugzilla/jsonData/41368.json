[{"attachment_id": null, "tags": [], "creator": "tv_spambox@gmx.de", "text": "The setup is as follows: \nWe compile a list of java projects, logging the output of each project. The\nbasic setup for each project is as follows:\n---------------\n<target name=\"parent\">\n<record name=\"${JavaLog}\" action=\"start\" loglevel=\"info\"/>\n\n<antfetch dir=\"[...]\" target=\"child\"/>\n\n<record name=\"${JavaLog}\" action=\"stop\"/>\n</target>\n---------------\n\nNow the child target tried to write to the same logfile, basically calling \n----------------\n<target name=\"child\">\n<record name=\"${JavaLog} \" action=\"start\" append=\"true\"/>\n[...]\n<record name=\"${JavaLog} \" action=\"stop\"/>\n----------------\n\nIn Ant 1.6.5 no one noticed, because the output looked fine. Starting with ant\n1.7.0 however the output becomes strange: After the \"stop\" in the parent target\nthe logfile is empty (contains zero bytes). If I insert a fail immediately\nbefore the \"stop\" command in the parent target then everything is fine. If I do\nnot close the log file at all (in the parent target) then  the logfile is there\n- in some cases. In other cases it contains the last line of the output, or\nsometimes nothing at all, and a lot of binary zeros. Seems like the content of\nthe logfile is overwritten with zeros before it is flushed. This behavior is\nreproducable.", "count": 0, "id": 98075, "time": "2007-01-15T08:12:37Z", "bug_id": 41368, "creation_time": "2007-01-15T08:12:37Z", "is_private": false}, {"attachment_id": null, "tags": [], "bug_id": 41368, "is_private": false, "count": 1, "id": 98118, "time": "2007-01-16T03:13:21Z", "creator": "tv_spambox@gmx.de", "creation_time": "2007-01-16T03:13:21Z", "text": "(In reply to comment #0)\nUpdate:\nWhen a recorder entry is opened for the second time, the same thing happens\n(logfile becomes corrupted). Here the basic setup is\n<record action=\"start\"/>\n[calling some subtargets]\n<record action=\"stop\"/>\n<antcall target=\"mychild\"/>\nand in mychild a logfile of the same name with append=\"yes\" option is opened.\n"}, {"count": 2, "attachment_id": null, "creator": "greg.schueler+bugzilla.asf@gmail.com", "is_private": false, "id": 101833, "time": "2007-04-17T18:11:29Z", "bug_id": 41368, "creation_time": "2007-04-17T18:11:29Z", "tags": [], "text": "the problem is that taskdefs/Record.java uses a single static HashTable to hold RecordEntry objects.  Then \nit calls cleanup() in subBuildFinished(), which cleans out the static HashTable.\n\nThis is the wrong behavior, since as a static member it contains all RecordEntries across Project objects.  \n\nSeems like the correct behavior is to have a HashTable of RecorderEntry's on a per-Project-object basis. \n(single refid per-project won't work either because the refid could get copied by <ant> task's inheritRefs \nattribute.)"}, {"count": 3, "tags": [], "creator": "greg.schueler+bugzilla.asf@gmail.com", "text": "Created attachment 19992\nPatch for fix, with tests\n\npatch to Recorder.java that stores recorderEntry hashtables for each Project in\nthe static hashtable.  additional testcase in\nsrc/etc/testcases/taskdefs/recorder.xml which tests subbuild using <ant> on new\ntest buildfile src/etc/testcases/taskdefs/recorder2.xml.   Patches\nRecorderTest.java to call new testcase in recorder.xml and compare expected\noutput files.  Includes two expected result files from recorder.xml testcase.", "id": 101886, "time": "2007-04-18T10:20:41Z", "bug_id": 41368, "creation_time": "2007-04-18T10:20:41Z", "is_private": false, "attachment_id": 19992}, {"count": 4, "tags": [], "bug_id": 41368, "text": "fixed in svn revision 793792\n\nThanks for the tests as well!", "id": 128819, "time": "2009-07-13T21:52:14Z", "creator": "bodewig@apache.org", "creation_time": "2009-07-13T21:52:14Z", "is_private": false, "attachment_id": null}, {"count": 5, "tags": [], "bug_id": 41368, "text": "This fix seems to cause some side effects which does not preserve the calling hierarchical scoping for the record name while the original source code seems to be intended to preserve it.\n\nFor instance, with this script:\n    <target name=\"parent\" depends=\"prepare\">\n        <record action=\"start\" name=\"${parent.log}\"/>\n        <echo message=\"Parent target started\"/>\n\n        <antcall target=\"child\">\n            <param name=\"child.log\" value=\"${recdir}/child-01.log\"/>\n        </antcall>\n\n        <record action=\"stop\" name=\"${parent.log}\"/>\n    </target>\n    \n    <target name=\"child\">\n        <record action=\"start\" name=\"${child.log}\"/>\n        <echo message=\"Child target started - ${child.log}\"/>\n        <record action=\"stop\" name=\"${parent.log}\" append=\"yes\"/>\n\n        <echo message=\"Child target processing - ${child.log}\"/>\n    \n        <record action=\"start\" name=\"${parent.log}\"/>\n        <echo message=\"Child target ended - ${child.log}\"/>\n        <record action=\"stop\" name=\"${child.log}\"/>\n    </target>\n\nthe fix generate the following log entries for parent:\n     [echo] Parent target started\n\nchild:\n     [echo] Child target started - recorder-out/child-01.log\n     [echo] Child target processing - recorder-out/child-01.log (*)\n     [echo] Child target ended - recorder-out/child-01.log\n     [echo] Child target ended - recorder-out/child-01.log (*)\n\n(*) seems to be errors.\n\nRather than the per-Project-object approach, it might be better to check the project of RecorderEntry during the cleanup.\n\nRecoder.java (Assuming all the changes were revoked)\n  import java.util.Iterator;\n  import java.util.Map;\n\n    private void cleanup() {\n        Hashtable entries = (Hashtable)recorderEntries.clone();\n        Iterator itEntries = entries.entrySet().iterator();\n        while (itEntries.hasNext()) {\n            Map.Entry entry = (Map.Entry)itEntries.next();\n            RecorderEntry re = (RecorderEntry)entry.getValue();\n            if (re.getProject() == getProject())\n                recorderEntries.remove(entry.getKey());\n        }\n        \n        getProject().removeBuildListener(this);\n    }\n\nRecoderEntry.java\n    public Project getProject() {\n        return project;\n    }\n\nI have verified this with the ant scripts (record.xml and record2.xml) and the above script.", "id": 129503, "time": "2009-08-05T13:51:40Z", "creator": "genes_chung@hotmail.com", "creation_time": "2009-08-05T13:51:40Z", "is_private": false, "attachment_id": null}, {"count": 6, "tags": [], "creator": "genes_chung@hotmail.com", "attachment_id": 24109, "text": "Created attachment 24109\nSupport the record name scope hierarchically", "id": 129534, "time": "2009-08-06T06:58:26Z", "bug_id": 41368, "creation_time": "2009-08-06T06:58:26Z", "is_private": false}, {"count": 7, "tags": [], "bug_id": 41368, "text": "thanks, patch applied as svn revision 805382", "id": 129766, "time": "2009-08-18T05:18:31Z", "creator": "bodewig@apache.org", "creation_time": "2009-08-18T05:18:31Z", "is_private": false, "attachment_id": null}]