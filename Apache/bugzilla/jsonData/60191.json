[{"count": 0, "attachment_id": null, "bug_id": 60191, "is_private": false, "id": 194101, "time": "2016-09-30T09:35:42Z", "creator": "apyhalov@gmail.com", "creation_time": "2016-09-30T09:35:42Z", "tags": [], "text": "This is an upstream bug for https://www.illumos.org/issues/7394 . \n\nIn apr_dir_open we have the following code: \n\n    /* On some platforms (e.g., Linux+GNU libc), d_name[] in struct \n     * dirent is declared with enough storage for the name.  On other\n     * platforms (e.g., Solaris 8 for Intel), d_name is declared as a\n     * one-byte array.  Note: gcc evaluates this at compile time.\n     */\n    apr_size_t dirent_size = \n        sizeof(*(*new)->entry) +\n        (sizeof((*new)->entry->d_name) > 1 ? 0 : 255);\n\n\nWhich works incorrectly in both cases. On illumos SPARC this just allocates 0 bytes to directory names, on Intel (where d_name is char[1] - 255 bytes).\nIt should just use PATH_MAX+1 (on illumos PATH_MAX is 1024).\nSomething like this :\n\n--- file_io/unix/dir.c.1        2016-09-30 11:54:20.721126026 +0300\n+++ file_io/unix/dir.c  2016-09-30 12:01:08.345539555 +0300\n@@ -78,7 +78,7 @@\n      */\n     apr_size_t dirent_size = \n         sizeof(*(*new)->entry) +\n-        (sizeof((*new)->entry->d_name) > 1 ? 0 : 255);\n+        PATH_MAX+1;\n     DIR *dir = opendir(dirname);\n \n     if (!dir) {"}, {"count": 1, "tags": [], "bug_id": 60191, "attachment_id": null, "id": 194102, "time": "2016-09-30T10:59:26Z", "creator": "apyhalov@gmail.com", "creation_time": "2016-09-30T10:59:26Z", "is_private": false, "text": "Sorry, path solves the problem, but is incorrect.\n\nsizeof(struct dirent) includes d_name array in the result,\nit already has an extra space (minimum one byte) for terminating '\\0',\nbut the second part of this expression is incorrect if d_name array\nhas size more than one byte. On SPARC is has 3 bytes and this part\nof the expression returns 0, so, we have for names only 3 bytes\nincluding '\\0' which is incorrect."}, {"count": 2, "tags": [], "creator": "wrowe@apache.org", "attachment_id": null, "is_private": false, "id": 194104, "time": "2016-09-30T20:35:54Z", "bug_id": 60191, "creation_time": "2016-09-30T20:35:54Z", "text": "Why not\n\n-        (sizeof((*new)->entry->d_name) > 1 ? 0 : 255);\n+        PATH_MAX+1 - sizeof((*new)->entry->d_name);\n\nto allocate a sufficient d_name space while deducting any redundant bytes \nfrom the d_name elt?"}, {"count": 3, "tags": [], "text": "(In reply to William A. Rowe Jr. from comment #2)\n> Why not\n> \n> -        (sizeof((*new)->entry->d_name) > 1 ? 0 : 255);\n> +        PATH_MAX+1 - sizeof((*new)->entry->d_name);\n\nOr maybe:\n\n+    apr_size_t dname_size = sizeof((*new)->entry->d_name);\n     apr_size_t dirent_size = \n         sizeof(*(*new)->entry) +\n-        (sizeof((*new)->entry->d_name) > 1 ? 0 : 255);\n+        (d_name_size > PATH_MAX ? dname_size : PATH_MAX + 1) -\n+        dname_size;\n\nto preserve sizeof(d_name) if it's above PATH_MAX already.", "is_private": false, "id": 194105, "creator": "ylavic.dev@gmail.com", "time": "2016-09-30T21:06:07Z", "bug_id": 60191, "creation_time": "2016-09-30T21:06:07Z", "attachment_id": null}, {"count": 4, "attachment_id": null, "bug_id": 60191, "is_private": false, "id": 194136, "time": "2016-10-04T18:36:28Z", "creator": "rpluem@apache.org", "creation_time": "2016-10-04T18:36:28Z", "tags": [], "text": "(In reply to Yann Ylavic from comment #3)\n> (In reply to William A. Rowe Jr. from comment #2)\n> > Why not\n> > \n> > -        (sizeof((*new)->entry->d_name) > 1 ? 0 : 255);\n> > +        PATH_MAX+1 - sizeof((*new)->entry->d_name);\n> \n> Or maybe:\n> \n> +    apr_size_t dname_size = sizeof((*new)->entry->d_name);\n>      apr_size_t dirent_size = \n>          sizeof(*(*new)->entry) +\n> -        (sizeof((*new)->entry->d_name) > 1 ? 0 : 255);\n> +        (d_name_size > PATH_MAX ? dname_size : PATH_MAX + 1) -\n> +        dname_size;\n> \n> to preserve sizeof(d_name) if it's above PATH_MAX already.\n\nAs far as I understand the current calculation and the one Bill proposed can be done at compile time while yours need to be done at runtime. Probably using a #define dname_size could fix this."}, {"count": 5, "tags": [], "bug_id": 60191, "text": "Since dname_size is constant it can/will be optimized out at compile time too.\nThe issue is that my version (and Bill's) over allocate memory by using PATH_MAX instead NAME_MAX, so we could possibly go for something like:\n\nIndex: file_io/unix/dir.c\n===================================================================\n--- file_io/unix/dir.c\t(revision 1762122)\n+++ file_io/unix/dir.c\t(working copy)\n@@ -76,9 +76,15 @@ apr_status_t apr_dir_open(apr_dir_t **new, const c\n      * platforms (e.g., Solaris 8 for Intel), d_name is declared as a\n      * one-byte array.  Note: gcc evaluates this at compile time.\n      */\n+#if defined(NAME_MAX) && NAME_MAX > 255\n+#define DIRENT_NAME_MAX NAME_MAX\n+#else\n+#define DIRENT_NAME_MAX 255\n+#endif\n     apr_size_t dirent_size = \n         sizeof(*(*new)->entry) +\n-        (sizeof((*new)->entry->d_name) > 1 ? 0 : 255);\n+        (sizeof((*new)->entry->d_name) > DIRENT_NAME_MAX ? 0\n+         : DIRENT_NAME_MAX + 1 - sizeof((*new)->entry->d_name));\n     DIR *dir = opendir(dirname);\n \n     if (!dir) {\n_\n\n\nThe best we could do would be to use fpathconf() like proposed in the dirent_buf_size() function from https://womble.decadent.org.uk/readdir_r-advisory.html (there may be some platforms supporting file names longer than NAME_MAX, but with a lower sizeof(d_name)...).\nThis is not compile time though, but we are supposedly not in a fast path when using opendir()/readdir() :)", "id": 194140, "time": "2016-10-04T21:20:50Z", "creator": "ylavic.dev@gmail.com", "creation_time": "2016-10-04T21:20:50Z", "is_private": false, "attachment_id": null}]