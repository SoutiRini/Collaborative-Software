[{"count": 0, "tags": [], "text": "Hello\n\nI am having a problem. My application is an applet that generate a xml and sign\nit with PrivateKey from SmartCard. \n\nThe first time, it works fine! however when i try to sign again (second time), i\nget this exception: \n\njava.security.InvalidKeyException: Private keys must be instance of\nRSAPrivate(Crt)Key or have PKCS#8 encoding\n\nThe exception occurs when calling the method: DOMSignContext dsc = new\nDOMSignContext(pk, doc.getDocumentElement()); This method is part of the\nfollowing code:\n\nDoes any body know what could i do to solve this problem ?\n\n======= code that generates the xml signature\n\nString providerName = System.getProperty(\"jsr105Provider\",\n\"org.jcp.xml.dsig.internal.dom.XMLDSigRI\");\nXMLSignatureFactory fac = XMLSignatureFactory.getInstance(\n\"DOM\",\n(Provider) Class.forName(providerName).newInstance());\nReference ref = fac.newReference(\n\"\",\nfac.newDigestMethod(DigestMethod.SHA1, null),\nCollections.singletonList(fac.newTransform(\nTransform.ENVELOPED,\n(TransformParameterSpec) null)),\nnull,\nnull);\n\nSignedInfo si = fac.newSignedInfo(\nfac.newCanonicalizationMethod(\nCanonicalizationMethod.INCLUSIVE_WITH_COMMENTS,\n(C14NMethodParameterSpec) null),\nfac.newSignatureMethod(SignatureMethod.RSA_SHA1, null),\nCollections.singletonList(ref));\n\nKeyInfoFactory kif = fac.getKeyInfoFactory();\nX509Data x509 = kif.newX509Data(Collections.singletonList(cert));\nKeyInfo ki = kif.newKeyInfo(Collections.singletonList(x509));\n\nDOMSignContext dsc = new DOMSignContext(pk, doc.getDocumentElement());\n\nXMLSignature signature = fac.newXMLSignature(si, ki);\nsignature.sign(dsc);\nreturn doc; \n}\n\n======= code that get de PrivateKey and Certificate from Smart Card:\nString configuracao = \"name = SmartCard\\n\" +\n\"library = c:\\\\windows\\\\system32\\\\aetpkss1.dll\";\nbyte[] configuracaoBytes = configuracao.getBytes();\nByteArrayInputStream configuracaoStream = new\nByteArrayInputStream(configuracaoBytes);\nsun.security.pkcs11.SunPKCS11 provider = new\nsun.security.pkcs11.SunPKCS11(configuracaoStream);\nSecurity.addProvider(provider);\nthis.nomeProvider = provider.getName();\nthis.repositorio = KeyStore.getInstance(\"PKCS11\", provider);\nrepositorio.load(null, pin.toCharArray());\nthis.inicializarDados(pin);\n\nString keyEntry = null;\nboolean ok = false;\n\nEnumeration en = repositorio.aliases();\nwhile(en.hasMoreElements()) {\nkeyEntry = (String)en.nextElement();\nif(repositorio.isKeyEntry(keyEntry)){\nok = true;\nbreak;\n}\n}\nif(ok){\ncertificado = (X509Certificate) repositorio.getCertificate(keyEntry);\nchavePrivada = (PrivateKey) repositorio.getKey(keyEntry, pin.toCharArray());", "attachment_id": null, "id": 95140, "creator": "fillipelima@gmail.com", "time": "2006-10-27T04:14:56Z", "bug_id": 40826, "creation_time": "2006-10-27T04:14:56Z", "is_private": false}, {"count": 1, "tags": [], "text": "(In reply to comment #0)\n> Hello\n> \n> I am having a problem. My application is an applet that generate a xml and sign\n> it with PrivateKey from SmartCard. \n> \n> The first time, it works fine! however when i try to sign again (second time), i\n> get this exception: \n> \n> java.security.InvalidKeyException: Private keys must be instance of\n> RSAPrivate(Crt)Key or have PKCS#8 encoding\n\nThis exception indicates that you are trying to use the key that is \nstored on the smart card with a software based crypto provider. It won't work. \nSee http://java.sun.com/j2se/1.5.0/docs/guide/security/p11guide.html#DelayedSelect\nfor some more information about that.\n\nHowever, we need to figure out why you are getting that exception. \n\n> The exception occurs when calling the method: DOMSignContext dsc = new\n> DOMSignContext(pk, doc.getDocumentElement()); This method is part of the\n> following code:\n> \n> Does any body know what could i do to solve this problem ?\n\nCan you attach the full exception stack trace?", "attachment_id": null, "id": 95146, "creator": "sean.mullan@oracle.com", "time": "2006-10-27T07:46:46Z", "bug_id": 40826, "creation_time": "2006-10-27T07:46:46Z", "is_private": false}, {"count": 2, "tags": [], "bug_id": 40826, "text": "(In reply to comment #1)\n> (In reply to comment #0)\n> > Hello\n> > \n> > I am having a problem. My application is an applet that generate a xml and \nsign\n> > it with PrivateKey from SmartCard. \n> > \n> > The first time, it works fine! however when i try to sign again (second \ntime), i\n> > get this exception: \n> > \n> > java.security.InvalidKeyException: Private keys must be instance of\n> > RSAPrivate(Crt)Key or have PKCS#8 encoding\n> This exception indicates that you are trying to use the key that is \n> stored on the smart card with a software based crypto provider. It won't \nwork. \n> See \nhttp://java.sun.com/j2se/1.5.0/docs/guide/security/p11guide.html#DelayedSelect\n> for some more information about that.\n> However, we need to figure out why you are getting that exception. \n> > The exception occurs when calling the method: DOMSignContext dsc = new\n> > DOMSignContext(pk, doc.getDocumentElement()); This method is part of the\n> > following code:\n> > \n> > Does any body know what could i do to solve this problem ?\n> Can you attach the full exception stack trace?\n\nI will try to do this:\n\n\"It is recommended that applications only call getProvider() after they have \ncalled the relevant initialization method. \"\n\nIm using xml signature... \ni) Is this my initialization method \"XMLSignature signature = \nfac.newXMLSignature(si, ki)\"; ?\n\nii) Is my getProvider() this part? \"XMLSignatureFactory fac = \nXMLSignatureFactory.getInstance(\n\"DOM\",\n(Provider) Class.forName(providerName).newInstance());\nReference ref = fac.newReference(\n\"\",\nfac.newDigestMethod(DigestMethod.SHA1, null),\nCollections.singletonList(fac.newTransform(\nTransform.ENVELOPED,\n(TransformParameterSpec) null)),\nnull,\nnull);\n\" ?\n\nThe complete stack trace:\n\nAssinaturaXMLException: java.security.InvalidKeyException: Private keys must be \ninstance of RSAPrivate(Crt)Key or have PKCS#8 encoding\n\tat AssinaturaXMLEnveloped.assinar(AssinaturaXMLEnveloped.java:86)\n\tat AssinadorDigital.AssinarDados(AssinadorDigital.java:133)\n\tat AssinadorDigital.btnAssinar_actionPerformed\n(AssinadorDigital.java:189)\n\tat AssinadorDigital_btnAssinar_actionAdapter.actionPerformed\n(AssinadorDigital.java:201)\n\tat javax.swing.AbstractButton.fireActionPerformed(Unknown Source)\n\tat javax.swing.AbstractButton$Handler.actionPerformed(Unknown Source)\n\tat javax.swing.DefaultButtonModel.fireActionPerformed(Unknown Source)\n\tat javax.swing.DefaultButtonModel.setPressed(Unknown Source)\n\tat javax.swing.plaf.basic.BasicButtonListener.mouseReleased(Unknown \nSource)\n\tat java.awt.Component.processMouseEvent(Unknown Source)\n\tat javax.swing.JComponent.processMouseEvent(Unknown Source)\n\tat java.awt.Component.processEvent(Unknown Source)\n\tat java.awt.Container.processEvent(Unknown Source)\n\tat java.awt.Component.dispatchEventImpl(Unknown Source)\n\tat java.awt.Container.dispatchEventImpl(Unknown Source)\n\tat java.awt.Component.dispatchEvent(Unknown Source)\n\tat java.awt.LightweightDispatcher.retargetMouseEvent(Unknown Source)\n\tat java.awt.LightweightDispatcher.processMouseEvent(Unknown Source)\n\tat java.awt.LightweightDispatcher.dispatchEvent(Unknown Source)\n\tat java.awt.Container.dispatchEventImpl(Unknown Source)\n\tat java.awt.Component.dispatchEvent(Unknown Source)\n\tat java.awt.EventQueue.dispatchEvent(Unknown Source)\n\tat java.awt.EventDispatchThread.pumpOneEventForHierarchy(Unknown Source)\n\tat java.awt.EventDispatchThread.pumpEventsForHierarchy(Unknown Source)\n\tat java.awt.EventDispatchThread.pumpEvents(Unknown Source)\n\tat java.awt.EventDispatchThread.pumpEvents(Unknown Source)\n\tat java.awt.EventDispatchThread.run(Unknown Source)\n\n", "id": 95149, "time": "2006-10-27T09:20:54Z", "creator": "fillipelima@gmail.com", "creation_time": "2006-10-27T09:20:54Z", "is_private": false, "attachment_id": null}, {"count": 3, "tags": [], "bug_id": 40826, "attachment_id": null, "is_private": false, "id": 95151, "time": "2006-10-27T10:18:28Z", "creator": "sean.mullan@oracle.com", "creation_time": "2006-10-27T10:18:28Z", "text": "(In reply to comment #2)\n\n> The complete stack trace:\n> \n> AssinaturaXMLException: java.security.InvalidKeyException: Private keys must be \n> instance of RSAPrivate(Crt)Key or have PKCS#8 encoding\n> \tat AssinaturaXMLEnveloped.assinar(AssinaturaXMLEnveloped.java:86)\n\nThis stack trace doesn't help. The AssinaturaXMLException is swallowing the\nstack trace of the cause: InvalidKeyException. I need to have that the stack\ntrace of the InvalidKeyException to be able to help."}, {"count": 4, "tags": [], "bug_id": 40826, "attachment_id": null, "is_private": false, "id": 95164, "time": "2006-10-27T15:15:23Z", "creator": "fillipelima@gmail.com", "creation_time": "2006-10-27T15:15:23Z", "text": "(In reply to comment #3)\n> (In reply to comment #2)\n> > The complete stack trace:\n> > \n> > AssinaturaXMLException: java.security.InvalidKeyException: Private keys \nmust be \n> > instance of RSAPrivate(Crt)Key or have PKCS#8 encoding\n> > \tat AssinaturaXMLEnveloped.assinar(AssinaturaXMLEnveloped.java:86)\n> This stack trace doesn't help. The AssinaturaXMLException is swallowing the\n> stack trace of the cause: InvalidKeyException. I need to have that the stack\n> trace of the InvalidKeyException to be able to help.\n\nOk. I think this may help:\n\njavax.xml.crypto.dsig.XMLSignatureException: java.security.InvalidKeyException: \nPrivate keys must be instance of RSAPrivate(Crt)Key or have PKCS#8 encoding\n\tat org.jcp.xml.dsig.internal.dom.DOMXMLSignature.sign\n(DOMXMLSignature.java:370)\n\tat AssinaturaXMLEnveloped.assinar(AssinaturaXMLEnveloped.java:80)\n\tat AssinadorDigital.AssinarDados(AssinadorDigital.java:134)\n\tat AssinadorDigital.btnAssinar_actionPerformed\n(AssinadorDigital.java:190)\n\tat AssinadorDigital_btnAssinar_actionAdapter.actionPerformed\n(AssinadorDigital.java:202)\n\tat javax.swing.AbstractButton.fireActionPerformed(Unknown Source)\n\tat javax.swing.AbstractButton$Handler.actionPerformed(Unknown Source)\n\tat javax.swing.DefaultButtonModel.fireActionPerformed(Unknown Source)\n\tat javax.swing.DefaultButtonModel.setPressed(Unknown Source)\n\tat javax.swing.plaf.basic.BasicButtonListener.mouseReleased(Unknown \nSource)\n\tat java.awt.Component.processMouseEvent(Unknown Source)\n\tat javax.swing.JComponent.processMouseEvent(Unknown Source)\n\tat java.awt.Component.processEvent(Unknown Source)\n\tat java.awt.Container.processEvent(Unknown Source)\n\tat java.awt.Component.dispatchEventImpl(Unknown Source)\n\tat java.awt.Container.dispatchEventImpl(Unknown Source)\n\tat java.awt.Component.dispatchEvent(Unknown Source)\n\tat java.awt.LightweightDispatcher.retargetMouseEvent(Unknown Source)\n\tat java.awt.LightweightDispatcher.processMouseEvent(Unknown Source)\n\tat java.awt.LightweightDispatcher.dispatchEvent(Unknown Source)\n\tat java.awt.Container.dispatchEventImpl(Unknown Source)\n\tat java.awt.Component.dispatchEvent(Unknown Source)\n\tat java.awt.EventQueue.dispatchEvent(Unknown Source)\n\tat java.awt.EventDispatchThread.pumpOneEventForHierarchy(Unknown Source)\n\tat java.awt.EventDispatchThread.pumpEventsForHierarchy(Unknown Source)\n\tat java.awt.EventDispatchThread.pumpEvents(Unknown Source)\n\tat java.awt.EventDispatchThread.pumpEvents(Unknown Source)\n\tat java.awt.EventDispatchThread.run(Unknown Source)\nCaused by: java.security.InvalidKeyException: Private keys must be instance of \nRSAPrivate(Crt)Key or have PKCS#8 encoding\n\tat sun.security.rsa.RSAKeyFactory.translatePrivateKey(Unknown Source)\n\tat sun.security.rsa.RSAKeyFactory.engineTranslateKey(Unknown Source)\n\tat sun.security.rsa.RSAKeyFactory.toRSAKey(Unknown Source)\n\tat sun.security.rsa.RSASignature.engineInitSign(Unknown Source)\n\tat sun.security.rsa.RSASignature.engineInitSign(Unknown Source)\n\tat java.security.Signature$Delegate.init(Unknown Source)\n\tat java.security.Signature$Delegate.chooseProvider(Unknown Source)\n\tat java.security.Signature$Delegate.engineInitSign(Unknown Source)\n\tat java.security.Signature.initSign(Unknown Source)\n\tat org.jcp.xml.dsig.internal.dom.DOMRSASignatureMethod.sign\n(DOMRSASignatureMethod.java:134)\n\tat org.jcp.xml.dsig.internal.dom.DOMXMLSignature.sign\n(DOMXMLSignature.java:367)\n\t... 27 more\njava.security.InvalidKeyException: Private keys must be instance of RSAPrivate\n(Crt)Key or have PKCS#8 encoding\n\tat sun.security.rsa.RSAKeyFactory.translatePrivateKey(Unknown Source)\n\tat sun.security.rsa.RSAKeyFactory.engineTranslateKey(Unknown Source)\n\tat sun.security.rsa.RSAKeyFactory.toRSAKey(Unknown Source)\n\tat sun.security.rsa.RSASignature.engineInitSign(Unknown Source)\n\tat sun.security.rsa.RSASignature.engineInitSign(Unknown Source)\n\tat java.security.Signature$Delegate.init(Unknown Source)\n\tat java.security.Signature$Delegate.chooseProvider(Unknown Source)\n\tat java.security.Signature$Delegate.engineInitSign(Unknown Source)\n\tat java.security.Signature.initSign(Unknown Source)\n\tat org.jcp.xml.dsig.internal.dom.DOMRSASignatureMethod.sign\n(DOMRSASignatureMethod.java:134)\n\tat org.jcp.xml.dsig.internal.dom.DOMXMLSignature.sign\n(DOMXMLSignature.java:367)\n\tat AssinaturaXMLEnveloped.assinar(AssinaturaXMLEnveloped.java:80)\n\tat AssinadorDigital.AssinarDados(AssinadorDigital.java:134)\n\tat AssinadorDigital.btnAssinar_actionPerformed\n(AssinadorDigital.java:190)\n\tat AssinadorDigital_btnAssinar_actionAdapter.actionPerformed\n(AssinadorDigital.java:202)\n\tat javax.swing.AbstractButton.fireActionPerformed(Unknown Source)\n\tat javax.swing.AbstractButton$Handler.actionPerformed(Unknown Source)\n\tat javax.swing.DefaultButtonModel.fireActionPerformed(Unknown Source)\n\tat javax.swing.DefaultButtonModel.setPressed(Unknown Source)\n\tat javax.swing.plaf.basic.BasicButtonListener.mouseReleased(Unknown \nSource)\n\tat java.awt.Component.processMouseEvent(Unknown Source)\n\tat javax.swing.JComponent.processMouseEvent(Unknown Source)\n\tat java.awt.Component.processEvent(Unknown Source)\n\tat java.awt.Container.processEvent(Unknown Source)\n\tat java.awt.Component.dispatchEventImpl(Unknown Source)\n\tat java.awt.Container.dispatchEventImpl(Unknown Source)\n\tat java.awt.Component.dispatchEvent(Unknown Source)\n\tat java.awt.LightweightDispatcher.retargetMouseEvent(Unknown Source)\n\tat java.awt.LightweightDispatcher.processMouseEvent(Unknown Source)\n\tat java.awt.LightweightDispatcher.dispatchEvent(Unknown Source)\n\tat java.awt.Container.dispatchEventImpl(Unknown Source)\n\tat java.awt.Component.dispatchEvent(Unknown Source)\n\tat java.awt.EventQueue.dispatchEvent(Unknown Source)\n\tat java.awt.EventDispatchThread.pumpOneEventForHierarchy(Unknown Source)\n\tat java.awt.EventDispatchThread.pumpEventsForHierarchy(Unknown Source)\n\tat java.awt.EventDispatchThread.pumpEvents(Unknown Source)\n\tat java.awt.EventDispatchThread.pumpEvents(Unknown Source)\n\tat java.awt.EventDispatchThread.run(Unknown Source)\njava.security.InvalidKeyException: Private keys must be instance of RSAPrivate\n(Crt)Key or have PKCS#8 encoding\n\tat sun.security.rsa.RSAKeyFactory.translatePrivateKey(Unknown Source)\n\tat sun.security.rsa.RSAKeyFactory.engineTranslateKey(Unknown Source)\n\tat sun.security.rsa.RSAKeyFactory.toRSAKey(Unknown Source)\n\tat sun.security.rsa.RSASignature.engineInitSign(Unknown Source)\n\tat sun.security.rsa.RSASignature.engineInitSign(Unknown Source)\n\tat java.security.Signature$Delegate.init(Unknown Source)\n\tat java.security.Signature$Delegate.chooseProvider(Unknown Source)\n\tat java.security.Signature$Delegate.engineInitSign(Unknown Source)\n\tat java.security.Signature.initSign(Unknown Source)\n\tat org.jcp.xml.dsig.internal.dom.DOMRSASignatureMethod.sign\n(DOMRSASignatureMethod.java:134)\n\tat org.jcp.xml.dsig.internal.dom.DOMXMLSignature.sign\n(DOMXMLSignature.java:367)\n\tat AssinaturaXMLEnveloped.assinar(AssinaturaXMLEnveloped.java:80)\n\tat AssinadorDigital.AssinarDados(AssinadorDigital.java:134)\n\tat AssinadorDigital.btnAssinar_actionPerformed\n(AssinadorDigital.java:190)\n\tat AssinadorDigital_btnAssinar_actionAdapter.actionPerformed\n(AssinadorDigital.java:202)\n\tat javax.swing.AbstractButton.fireActionPerformed(Unknown Source)\n\tat javax.swing.AbstractButton$Handler.actionPerformed(Unknown Source)\n\tat javax.swing.DefaultButtonModel.fireActionPerformed(Unknown Source)\n\tat javax.swing.DefaultButtonModel.setPressed(Unknown Source)\n\tat javax.swing.plaf.basic.BasicButtonListener.mouseReleased(Unknown \nSource)\n\tat java.awt.Component.processMouseEvent(Unknown Source)\n\tat javax.swing.JComponent.processMouseEvent(Unknown Source)\n\tat java.awt.Component.processEvent(Unknown Source)\n\tat java.awt.Container.processEvent(Unknown Source)\n\tat java.awt.Component.dispatchEventImpl(Unknown Source)\n\tat java.awt.Container.dispatchEventImpl(Unknown Source)\n\tat java.awt.Component.dispatchEvent(Unknown Source)\n\tat java.awt.LightweightDispatcher.retargetMouseEvent(Unknown Source)\n\tat java.awt.LightweightDispatcher.processMouseEvent(Unknown Source)\n\tat java.awt.LightweightDispatcher.dispatchEvent(Unknown Source)\n\tat java.awt.Container.dispatchEventImpl(Unknown Source)\n\tat java.awt.Component.dispatchEvent(Unknown Source)\n\tat java.awt.EventQueue.dispatchEvent(Unknown Source)\n\tat java.awt.EventDispatchThread.pumpOneEventForHierarchy(Unknown Source)\n\tat java.awt.EventDispatchThread.pumpEventsForHierarchy(Unknown Source)\n\tat java.awt.EventDispatchThread.pumpEvents(Unknown Source)\n\tat java.awt.EventDispatchThread.pumpEvents(Unknown Source)\n\tat java.awt.EventDispatchThread.run(Unknown Source)\nAssinaturaXMLException: java.security.InvalidKeyException: Private keys must be \ninstance of RSAPrivate(Crt)Key or have PKCS#8 encoding\n\tat AssinaturaXMLEnveloped.assinar(AssinaturaXMLEnveloped.java:87)\n\tat AssinadorDigital.AssinarDados(AssinadorDigital.java:134)\n\tat AssinadorDigital.btnAssinar_actionPerformed\n(AssinadorDigital.java:190)\n\tat AssinadorDigital_btnAssinar_actionAdapter.actionPerformed\n(AssinadorDigital.java:202)\n\tat javax.swing.AbstractButton.fireActionPerformed(Unknown Source)\n\tat javax.swing.AbstractButton$Handler.actionPerformed(Unknown Source)\n\tat javax.swing.DefaultButtonModel.fireActionPerformed(Unknown Source)\n\tat javax.swing.DefaultButtonModel.setPressed(Unknown Source)\n\tat javax.swing.plaf.basic.BasicButtonListener.mouseReleased(Unknown \nSource)\n\tat java.awt.Component.processMouseEvent(Unknown Source)\n\tat javax.swing.JComponent.processMouseEvent(Unknown Source)\n\tat java.awt.Component.processEvent(Unknown Source)\n\tat java.awt.Container.processEvent(Unknown Source)\n\tat java.awt.Component.dispatchEventImpl(Unknown Source)\n\tat java.awt.Container.dispatchEventImpl(Unknown Source)\n\tat java.awt.Component.dispatchEvent(Unknown Source)\n\tat java.awt.LightweightDispatcher.retargetMouseEvent(Unknown Source)\n\tat java.awt.LightweightDispatcher.processMouseEvent(Unknown Source)\n\tat java.awt.LightweightDispatcher.dispatchEvent(Unknown Source)\n\tat java.awt.Container.dispatchEventImpl(Unknown Source)\n\tat java.awt.Component.dispatchEvent(Unknown Source)\n\tat java.awt.EventQueue.dispatchEvent(Unknown Source)\n\tat java.awt.EventDispatchThread.pumpOneEventForHierarchy(Unknown Source)\n\tat java.awt.EventDispatchThread.pumpEventsForHierarchy(Unknown Source)\n\tat java.awt.EventDispatchThread.pumpEvents(Unknown Source)\n\tat java.awt.EventDispatchThread.pumpEvents(Unknown Source)\n\tat java.awt.EventDispatchThread.run(Unknown Source)\n\n"}, {"count": 5, "tags": [], "text": "(In reply to comment #4)\n> (In reply to comment #3)\n> > (In reply to comment #2)\n> > > The complete stack trace:\n> > > \n> > > AssinaturaXMLException: java.security.InvalidKeyException: Private keys \n> must be \n> > > instance of RSAPrivate(Crt)Key or have PKCS#8 encoding\n> > > \tat AssinaturaXMLEnveloped.assinar(AssinaturaXMLEnveloped.java:86)\n> > This stack trace doesn't help. The AssinaturaXMLException is swallowing the\n> > stack trace of the cause: InvalidKeyException. I need to have that the stack\n> > trace of the InvalidKeyException to be able to help.\n> \n> Ok. I think this may help:\n> \n> javax.xml.crypto.dsig.XMLSignatureException: java.security.InvalidKeyException: \n> Private keys must be instance of RSAPrivate(Crt)Key or have PKCS#8 encoding\n\nHello\n\nI solved the problem just changing the way i get the instance of the KeyStore: \nIt was: \"this.repositorio = KeyStore.getInstance(\"PKCS11\", provider);\"\nNow is: \"this.repositorio = KeyStore.getInstance(\"PKCS11\");\"\nI singed the xml many times, without closing the application and it\u00b4s is working\nfine now.\n\nBut i still have some doubts....\n\n1) If i use KeyStore.getInstance(\"PKCS11\", provider) The Exception doesnt occurs\n at the first time and the xml document is signed normally. However, i if try to\nsign again, the exception occurs. why ? is it a Bug ?\n\n2) What\u00b4s the difference between each one? When use each one ?\n\nTks", "is_private": false, "id": 95181, "creator": "fillipelima@gmail.com", "time": "2006-10-28T14:28:43Z", "bug_id": 40826, "creation_time": "2006-10-28T14:28:43Z", "attachment_id": null}, {"count": 6, "tags": [], "bug_id": 40826, "attachment_id": null, "is_private": false, "id": 95208, "time": "2006-10-30T13:18:13Z", "creator": "sean.mullan@oracle.com", "creation_time": "2006-10-30T13:18:13Z", "text": " \n> But i still have some doubts....\n> \n> 1) If i use KeyStore.getInstance(\"PKCS11\", provider) The Exception doesnt occurs\n>  at the first time and the xml document is signed normally. However, i if try to\n> sign again, the exception occurs. why ? is it a Bug ?\n\nI don't think so. The only thing that makes sense to me is that the first key is\nsoftware based, and then the subsequent keys are hardware based and used with\na cached Signature object that is software based. Are you reusing \nthe XMLSignature objects each time you sign? Have you tried extracting the key\ncontents to see if it is hardware or software (ex: Key.getFormat should \nreturn \"RAW\" if it is hardware).\n> \n> 2) What\u00b4s the difference between each one? When use each one ?\n\nI don't think I understand the question.\n\n> \n> Tks"}, {"count": 7, "tags": [], "bug_id": 40826, "attachment_id": null, "id": 95214, "time": "2006-10-30T16:02:15Z", "creator": "fillipelima@gmail.com", "creation_time": "2006-10-30T16:02:15Z", "is_private": false, "text": "(In reply to comment #6)\n>  \n> > But i still have some doubts....\n> > \n> > 1) If i use KeyStore.getInstance(\"PKCS11\", provider) The Exception doesnt \noccurs\n> >  at the first time and the xml document is signed normally. However, i if \ntry to\n> > sign again, the exception occurs. why ? is it a Bug ?\n> I don't think so. The only thing that makes sense to me is that the first key \nis\n> software based, and then the subsequent keys are hardware based and used with\n> a cached Signature object that is software based. Are you reusing \n> the XMLSignature objects each time you sign? Have you tried extracting the key\n> contents to see if it is hardware or software (ex: Key.getFormat should \n> return \"RAW\" if it is hardware).\n> > \n> > 2) What\u00b4s the difference between each one? When use each one ?\n> I don't think I understand the question.\n> > \n> > Tks\n\nNo. I am not reusing the XMLSignature objects each time i sign. \nYes. I tried extracting the key contents: \"SunPKCS11-SmartCard RSA private key, \n1024 bits (id 1, token object, not sensitive, unextractable)\n\"\n\nthe question 2 is: what's the difference between using KeyStore.getInstance\n(\"PKCS11\", provider) and using KeyStore.getInstance(\"PKCS11\"). When use each \none ?\nI know that to use KeyStore.getInstance(\"PKCS11\") i must have to call \nSecurity.addProvider() before. but...which use ? "}, {"text": "I'm experiencing the same kind of weird behavior when I try to sign twice. The\ncode does something like:\n\nDocument document = loadDocument();\n\nsmartCard.open(...); // registers SunPKCS11 provider\nPrivateKey privateKey = smartCard.getPrivateKey(); // from the keystore\n\nxmlSign(document, privateKey, ...);\n\nsmartCard.close(); // removes SunPKCS11 provider\nsmartCard.open(...); // registers SunPKCS11 provider again\nPrivateKey privateKey = smartCard.getPrivateKey();\n\nxmlSign(document, privateKey, ...);\n\nThe second sign operation gives me:\nCaused by: org.apache.xml.security.signature.XMLSignatureException: Private key\nmust be instance of RSAPrivate(Crt)Key or have PKCS#8 encoding\nOriginal Exception was org.apache.xml.security.signature.XMLSignatureException:\nPrivate key must be instance of RSAPrivate(Crt)Key or have PKCS#8 encoding\nOriginal Exception was java.security.InvalidKeyException: Private key must be\ninstance of RSAPrivate(Crt)Key or have PKCS#8 encoding\n\tat org.apache.xml.security.signature.XMLSignature.sign(Unknown Source)\n\nIn my smart card code it doesn't matter whether to use\nKeyStore.Builder builder = KeyStore.Builder.newInstance(\"PKCS11\",\n    this.pkcs11Provider, callbackHandlerProtection);\nor\n...(\"PKCS11\", null, callbackHandlerProtection);\n\nI always get the exception. The funny thing is that I can sign twice via a\nnon-XML signature, i.e., using\nSignature.getInstance(\"SHA1withRSA\");\nbut, when using xmlsec, it's throwing the exception.\n", "tags": [], "creator": "info@frankcornelis.be", "is_private": false, "count": 8, "id": 95230, "time": "2006-10-30T23:05:21Z", "bug_id": 40826, "creation_time": "2006-10-30T23:05:21Z", "attachment_id": null}, {"count": 9, "tags": [], "bug_id": 40826, "attachment_id": null, "is_private": false, "id": 95311, "time": "2006-11-01T14:21:59Z", "creator": "sean.mullan@oracle.com", "creation_time": "2006-11-01T14:21:59Z", "text": "Ok, I looked into this a little bit more and still need more details.\n\nFirst, if you remove the SunPKCS11 provider and create a new instance, then any\nPrivateKey objects from the old SunPKCS11 instance will not be usable with the\nnew instance (and this exception will be thrown). \nIf the privateKey object is from the new provider, it should work. \n\nCan you let me know if you are doing this?"}, {"text": "(In reply to comment #9)\n> Ok, I looked into this a little bit more and still need more details.\n> \n> First, if you remove the SunPKCS11 provider and create a new instance, then any\n> PrivateKey objects from the old SunPKCS11 instance will not be usable with the\n> new instance (and this exception will be thrown). \n> If the privateKey object is from the new provider, it should work. \n> \n> Can you let me know if you are doing this?\n\nEach time i sign, i add the provider (Security.addProvider(p)) and create a new\nPrivateKey object. Im not reusing nothing.. is it correct ? or i must have to\nremove and add the provider each time? from what i know...when we use the\naddProvider, it add the provider in the available slot, but we can add in a\nspecific slot, just using addProviderAt(p, 2) for instance.", "tags": [], "creator": "fillipelima@gmail.com", "is_private": false, "count": 10, "id": 95331, "time": "2006-11-02T05:36:25Z", "bug_id": 40826, "creation_time": "2006-11-02T05:36:25Z", "attachment_id": null}, {"count": 11, "tags": [], "bug_id": 40826, "attachment_id": null, "is_private": false, "id": 95344, "time": "2006-11-02T07:42:41Z", "creator": "sean.mullan@oracle.com", "creation_time": "2006-11-02T07:42:41Z", "text": "\n> Each time i sign, i add the provider (Security.addProvider(p)) and create a new\n> PrivateKey object. Im not reusing nothing.. is it correct ? or i must have to\n> remove and add the provider each time? from what i know...when we use the\n> addProvider, it add the provider in the available slot, but we can add in a\n> specific slot, just using addProviderAt(p, 2) for instance.\n\nAhh, here's what I think is happening:\n\nThe first time you call Security.addProvider(p), your provider is added \ncorrectly, you create a new PrivateKey object using that same provider and\nthe xml signing operation works ok.\n\nThe next time you create a new provider and call Security.addProvider(p), \nI bet the provider is not added because it is already installed (from the APIs\nstandpoint, it is the same provider even though it is a new instance). Check \nthe return value of addProvider to see if it returns -1. \n\n*But* (and this is a major but), you then use the new provider instance to\ncreate a PrivateKey object. There's the problem. When you use this PrivateKey\nto sign, the xml signature cannot find the provider that you used to create it\n(since it is not installed, it only finds the old provider but that won't\nwork with the new PrivateKey) and therefore the signing operation fails because\nit cannot find a provider that the key can be used with.\n\nWorkarounds:\n\nEither, 1) explicitly remove the provider before you reinstall it each \ntime, or 2) only create and install the provider once and always use \nthis provider to create the PrivateKeys.  \n\nPlease confirm if this is the case. "}, {"count": 12, "tags": [], "text": "(In reply to comment #11)\n> > Each time i sign, i add the provider (Security.addProvider(p)) and create a new\n> > PrivateKey object. Im not reusing nothing.. is it correct ? or i must have to\n> > remove and add the provider each time? from what i know...when we use the\n> > addProvider, it add the provider in the available slot, but we can add in a\n> > specific slot, just using addProviderAt(p, 2) for instance.\n> \n> Ahh, here's what I think is happening:\n> \n> The first time you call Security.addProvider(p), your provider is added \n> correctly, you create a new PrivateKey object using that same provider and\n> the xml signing operation works ok.\n> \n> The next time you create a new provider and call Security.addProvider(p), \n> I bet the provider is not added because it is already installed (from the APIs\n> standpoint, it is the same provider even though it is a new instance). Check \n> the return value of addProvider to see if it returns -1. \n> \n> *But* (and this is a major but), you then use the new provider instance to\n> create a PrivateKey object. There's the problem. When you use this PrivateKey\n> to sign, the xml signature cannot find the provider that you used to create it\n> (since it is not installed, it only finds the old provider but that won't\n> work with the new PrivateKey) and therefore the signing operation fails because\n> it cannot find a provider that the key can be used with.\n> \n> Workarounds:\n> \n> Either, 1) explicitly remove the provider before you reinstall it each \n> time, or 2) only create and install the provider once and always use \n> this provider to create the PrivateKeys.  \n> \n> Please confirm if this is the case. \n\n\nExactly! the addProvider is returning -1 at the second time! (the first returned\na high position: 7). however i am not having problems anymore because im using\nlike this: \n\nSecurity.addProvider(p);\nKeyStore.getInstance(\"PKCS11\");\n\nIf i use KeyStore.getInstance(\"PKCS11\", p), then i get the exception the second\ntime!\n\nSean Mullan, Thank you very much for your clarifications! i am doing this as a\npart of my monograph project (Information Systems course). I will put your name\nin the gratfulness area! :))\n", "is_private": false, "id": 95360, "creator": "fillipelima@gmail.com", "time": "2006-11-02T09:44:52Z", "bug_id": 40826, "creation_time": "2006-11-02T09:44:52Z", "attachment_id": null}, {"count": 13, "tags": [], "text": "Closing this out, as it looks like my explanation is correct and the \nproblem has been resolved.", "attachment_id": null, "id": 95491, "creator": "sean.mullan@oracle.com", "time": "2006-11-06T11:55:47Z", "bug_id": 40826, "creation_time": "2006-11-06T11:55:47Z", "is_private": false}, {"count": 14, "tags": [], "bug_id": 40826, "attachment_id": null, "id": 106498, "time": "2007-08-08T13:29:14Z", "creator": "alon.barlev@gmail.com", "creation_time": "2007-08-08T13:29:14Z", "is_private": false, "text": "\nAs PKCS#11 has so great design, a separate instance must be instantiate for \neach slot of each provider.\n\nI tried to do what you requested, registered the provider to system, and passed \nnull to KeyStore.Builder as a provider and it does work.\n\nBut I don't think this is a valid solution, as there is no reason why all \nproviders should be added to the global scope.\n"}, {"count": 15, "text": "Thought about this again...\nAnd I don't think this solution is valid.\nBy convention all crypto functions throughout the SDK API accept explicit \nprovider.\nIf you can find another exception to this rule I may understand and drop \nthis...\nBut if xmlsec is the only exception, than it should sync up.\n", "creator": "alon.barlev@gmail.com", "is_private": false, "id": 106544, "time": "2007-08-09T12:28:51Z", "bug_id": 40826, "creation_time": "2007-08-09T12:28:51Z", "tags": [], "attachment_id": null}, {"count": 16, "tags": [], "bug_id": 40826, "attachment_id": null, "is_private": false, "id": 106602, "time": "2007-08-10T09:51:35Z", "creator": "sean.mullan@oracle.com", "creation_time": "2007-08-10T09:51:35Z", "text": "(In reply to comment #15)\n> Thought about this again...\n> And I don't think this solution is valid.\n> By convention all crypto functions throughout the SDK API accept explicit \n> provider.\n> If you can find another exception to this rule I may understand and drop \n> this...\n> But if xmlsec is the only exception, than it should sync up.\n\nxmlsec/jsr 105 are at a higher layer than the JCE APIs.\nI still think there should be a workaround to your problem. \nSomething is happening in your code that causes the \nPrivateKey's provider to be different than what is in the JRE's list of\nProviders.  Have you tried the solution in this bug report, that is:\n\nSecurity.addProvider(p);\nKeyStore.getInstance(\"PKCS11\");\n\n"}, {"count": 17, "tags": [], "bug_id": 40826, "attachment_id": null, "id": 119534, "time": "2008-08-07T02:17:07Z", "creator": "d.napolitano@reply.it", "creation_time": "2008-08-07T02:17:07Z", "is_private": false, "text": "I seem to be experiencing the same problem reported in this bug, but no workaround seems to be effective, apart form restarting the application altogether.\n\nThe situation I have is this: my application makes use of several different types of KeyStore. The user can use a configuration window to select which one to use, and even change some properties (e.g. the .dll module for the PKCS11 provider, or the slot number).\nThe application uses the selected provider to send SOAP requests using Axis/Rampart 1.3. I have written a replacement Crypto class for Rampart that gets the keys and certificates from the correct keystore/provider. While everything works fine with JKS keystores, the PKCS11 provider only works until it gets reconfigured. \n\nPlease note that I remove the previous Provider instance entirely, discard all previously obtained keys and keystores and recreate everything anew, but only the very first instance of the PKCS11 provider works.\n\nCode excerpt:\n----------------------------------------------------\nStringBuilder sb = new StringBuilder();\nsb.append(\"name = \");\nsb.append(providerName);\nsb.append(\"\\nlibrary = \");\nsb.append(ConfigManager.getInstance().getConf().getDllPkcs11()); // Get the selected PKCS11 DLL\nsb.append(\"\\nslot =\"); \nsb.append(ConfigManager.getInstance().getConf().getPkcs11Slot()); // Get the selected slot\nsb.append(\"\\ndisabledMechanisms = { CKM_SHA1_RSA_PKCS }\\n\");\n\t\t\nString pkcs11config = sb.toString();\n\t\t\nbyte pkcs11configBytes[] = pkcs11config.getBytes();\nByteArrayInputStream configStream = new ByteArrayInputStream(pkcs11configBytes);\nif (Security.getProvider(fullProvName)!=null) // Provider name + SunPKCS11 prefix\n\tSecurity.removeProvider(fullProvName);\nprov = new SunPKCS11(configStream);\nSecurity.insertProviderAt(prov, 1); // This is done to have Rampart select this provider for signature operations.\nks = KeyStore.getInstance(\"PKCS11\");\n-----------------------------------------------------\n\nAny key obtained after the first ever Provider instance gets replaced leads to this exception:\n\n-----------------------------------------------------\norg.apache.ws.security.WSSecurityException: Signature creation failed; nested exception is: \n\torg.apache.xml.security.signature.XMLSignatureException: Private key must be instance of RSAPrivate(Crt)Key or have PKCS#8 encoding\nOriginal Exception was org.apache.xml.security.signature.XMLSignatureException: Private key must be instance of RSAPrivate(Crt)Key or have PKCS#8 encoding\nOriginal Exception was java.security.InvalidKeyException: Private key must be instance of RSAPrivate(Crt)Key or have PKCS#8 encoding\n\tat org.apache.ws.security.message.WSSecSignature.computeSignature(WSSecSignature.java:663)\n\tat org.apache.rampart.builder.AsymmetricBindingBuilder.doSignature(AsymmetricBindingBuilder.java:611)\n\tat org.apache.rampart.builder.AsymmetricBindingBuilder.doSignBeforeEncrypt(AsymmetricBindingBuilder.java:385)\n\tat org.apache.rampart.builder.AsymmetricBindingBuilder.build(AsymmetricBindingBuilder.java:95)\n\tat org.apache.rampart.MessageBuilder.build(MessageBuilder.java:131)\n\tat org.apache.rampart.handler.RampartSender.invoke(RampartSender.java:64)\n\tat org.apache.axis2.engine.Phase.invoke(Phase.java:292)\n\tat org.apache.axis2.engine.AxisEngine.invoke(AxisEngine.java:212)\n\tat org.apache.axis2.engine.AxisEngine.send(AxisEngine.java:377)\n\tat org.apache.axis2.description.OutInAxisOperationClient.send(OutInAxisOperation.java:374)\n\tat org.apache.axis2.description.OutInAxisOperationClient.executeImpl(OutInAxisOperation.java:211)\n\tat org.apache.axis2.client.OperationClient.execute(OperationClient.java:163)\n-----------------------------------------------------\n\n\n\nIs there any way to replace the PKCS11 provider without having to restart the application? Note that since I have to change the configuration parameters at run-time I cannot leave the first provider instance alone...\n"}, {"count": 18, "tags": [], "bug_id": 40826, "text": "Have you tried the workaround implemented in bug 43056:\n\nIn order to use a specific provider, you must pass the Provider object\nas a property to the XMLSignContext or XMLValidateContext, ex:\n\nsignContext.setProperty\n    (\"org.jcp.xml.dsig.internal.dom.SignatureProvider\", new MyProvider());", "id": 119543, "time": "2008-08-07T06:09:35Z", "creator": "sean.mullan@oracle.com", "creation_time": "2008-08-07T06:09:35Z", "is_private": false, "attachment_id": null}, {"count": 19, "tags": [], "bug_id": 40826, "attachment_id": null, "text": "Unfortunately I do not have access to the signature contexts, as they are entirely handled by Rampart. In fact to 'encourage' Rampart to use the right provider I force it to the highest priority, by using Security.insertAt().\n\nHowever from my testing it seems that Rampart does select the right provider, but the provider fails to work if it's not the first time that it has been instanced. If I don't try to remove and recreate it, it works any number of times. If I have to change any parameter (for example the slot number) I have to restart the application (and the virtual machine).\n", "id": 119547, "time": "2008-08-07T07:52:07Z", "creator": "d.napolitano@reply.it", "creation_time": "2008-08-07T07:52:07Z", "is_private": false}, {"count": 20, "tags": [], "text": "Hi,\n\nI am experiencing the same problem.\nMy application uses org.apache.xml.security.signature.XMLSignature for signing with software and hardware based keys. Each time when signing with PKCS#11 hardware, the appropriate security provider is created, added and then removed after the signing.\n\nThe first time everyting works fine. However, if I try to sign again, the org.apache.xml.security.signature.XMLSignatureException with message \"Private key must be instance of RSAPrivate(Crt)Key or have PKCS#8 encoding\" is thrown:\n\norg.apache.xml.security.signature.XMLSignatureException: Private key must be instance of RSAPrivate(Crt)Key or have PKCS#8 encoding\nOriginal Exception was java.security.InvalidKeyException: Private key must be instance of RSAPrivate(Crt)Key or have PKCS#8 encoding\n\tat org.apache.xml.security.algorithms.implementations.SignatureBaseRSA.engineInitSign(SignatureBaseRSA.java:181)\n\tat org.apache.xml.security.algorithms.SignatureAlgorithm.initSign(SignatureAlgorithm.java:276)\n\tat org.apache.xml.security.signature.XMLSignature.sign(XMLSignature.java:497)\n\t...\njava.security.InvalidKeyException: Private key must be instance of RSAPrivate(Crt)Key or have PKCS#8 encoding\n\tat sun.security.pkcs11.P11RSAKeyFactory.implTranslatePrivateKey(P11RSAKeyFactory.java:84)\n\tat sun.security.pkcs11.P11KeyFactory.engineTranslateKey(P11KeyFactory.java:115)\n\tat sun.security.pkcs11.P11KeyFactory.convertKey(P11KeyFactory.java:48)\n\tat sun.security.pkcs11.P11Signature.engineInitSign(P11Signature.java:375)\n\tat java.security.Signature$Delegate.engineInitSign(Unknown Source)\n\tat java.security.Signature.initSign(Unknown Source)\n\tat org.apache.xml.security.algorithms.implementations.SignatureBaseRSA.engineInitSign(SignatureBaseRSA.java:179)\n\tat org.apache.xml.security.algorithms.SignatureAlgorithm.initSign(SignatureAlgorithm.java:276)\n\tat org.apache.xml.security.signature.XMLSignature.sign(XMLSignature.java:497)\n\t...\n\nThe interesting thing is, if I retry the signing after catching the exception, it succeeds. I found out that this \"recovery\" is caused by the \"cache cleanup\" (XMLSignature:510):\ntry {\n    // initialize SignatureAlgorithm for signing\n    sa.initSign(signingKey);\n    ...\n} catch (XMLSecurityException ex) {\n    sa.clearSignatureCache();\n    throw ex;\n}\n\nAnd the problem itself is caused by the \"cache\" (\"SignatureAlgorithm.instancesSigning\" variable). This map holds instances of SignatureAlgorithmSpi descendants. SignatureBaseRSA, which extends SignatureAlgorithmSpi, has \"private java.security.Signature _signatureAlgorithm\" variable, which, obviously, is initialised only once, and later gets associated with the first \"suitable\" security provider.\n\nDuring the second invocation, this provider (which is already removed BTW, but it doesn't matter - instance of java.security.Signature still holds a reference to it) is fed with a PrivateKey obtained from the newly added provider. This leads to futile attempts to \"convert\" the key and finally the InvalidKeyException.\n\nThere are several possible workarounds (tested and confirmed to work):\n1. try-catch and then retry, letting the \"recovery\" magic to do the work :)\n2. Manual \"cache cleanup\" before the signing, for example:\n\nnew SignatureAlgorithm(doc, signature.getSignedInfo().getSignatureMethodURI()).clearSignatureCache();\n(actually, clearSignatureCache() should be static, if it is intended for a \"public\" use - creating an instance of the SignatureAlgorithm is pointless here)\n\nOr, the \"instancesSigning\" can be cleared directly, using the reflection (this is for research only, of course):\n\nField f = SignatureAlgorithm.class.getDeclaredField(\"instancesSigning\");\nf.setAccessible(true);\nThreadLocal t = (ThreadLocal)f.get(null);\nMap instancesMap = (Map)t.get();\ninstancesMap.clear();\n\n3. Since the \"cache\" is implemented per-thread, the problem can be avoided by calling the sign() from a newly-created thread.\n\n\nThinking of the possible fixes, one solution could be implementing SignatureBaseRSA.reset() (like in IntegrityHmac), which would assing a new instance to the _signatureAlgorithm. If it's worth having such a \"cache\" at all.", "attachment_id": null, "id": 134678, "creator": "giedrius.noreikis@gmail.com", "time": "2010-02-18T23:26:32Z", "bug_id": 40826, "creation_time": "2010-02-18T23:26:32Z", "is_private": false}, {"count": 21, "tags": [], "bug_id": 40826, "attachment_id": null, "id": 138699, "time": "2010-07-27T20:09:09Z", "creator": "jdmarshall@gmail.com", "creation_time": "2010-07-27T20:09:09Z", "is_private": false, "text": "I have a coworker who is experiencing this problem.\n\nThe error doesn't happen in 1.3.0.  Something changed in the interim.  We first saw this in 1.4.1, and reproed it in 1.4.3"}, {"count": 22, "tags": [], "text": "(In reply to comment #21)\n> I have a coworker who is experiencing this problem.\n> The error doesn't happen in 1.3.0.  Something changed in the interim.  We first\n> saw this in 1.4.1, and reproed it in 1.4.3\n\nI am not sure if the cause of the problem is the same, but regarding my case (see comment #20) the optimization with the \"SignatureAlgorithm.instancesSigning\" variable was introduced in r413543 on Jun 11 2006 (as \"instances\" variable, later split into \"instancesSigning\" and \"instancesVerify\"). Version 1.3 was released in October 2005; Version 1.4 - in January 2007. So yes, that happened in the interim.", "attachment_id": null, "id": 138719, "creator": "giedrius.noreikis@gmail.com", "time": "2010-07-28T20:41:03Z", "bug_id": 40826, "creation_time": "2010-07-28T20:41:03Z", "is_private": false}]