[{"count": 0, "tags": [], "creator": "ablaszka@amazon.com", "attachment_id": 34912, "text": "Created attachment 34912\nPatch\n\nWhen piped loggers are used, errors logged during module initialization (in the post-config phase) may not always be present in the error log when the httpd master process exits. This leads to something like \"httpd exited with status 1\" being written to stdout without any corresponding error messages to explain what went wrong. This occurs because there's a race condition between apache exiting and piped loggers flushing the log entries to disk.\n  \nApache waits 10ms before exiting to account for this, but that may not always be enough. To fix this, this change makes the pre-exit pause duration configurable. The current 10ms duration is still used by default but the PRE_EXIT_PAUSE_TIME environment variable can be used to override that value. ap_timeout_parameter_parse is used to parse the environment variable contents allowing a flexible way to express the desired duration. If the value is too large (would lead to under/overflow), < 0, or otherwise invalid, it is ignored and the default value is used.\n\nGit-generated patch (created via git-format-patch attached) from the tip of trunk is attached. Including the diff here as well:\n\n\n--- httpd_current/server/main.c\t2017-04-13 19:35:01.000000000 +0000\n+++ httpd_new/server/main.c\t2017-04-13 17:11:57.000000000 +0000\n@@ -260,25 +260,49 @@\n #endif\n }\n \n-#define TASK_SWITCH_SLEEP 10000\n+#define DEFAULT_PRE_EXIT_PAUSE_TIME 10000\n+\n+/*\n+ * Pauses before exiting by sleeping for a configurable amount of time,\n+ * defaulting to DEFAULT_PRE_EXIT_PAUSE_TIME. The goal is to allow any in-flight\n+ * log entries to be flushed to disk before exiting. Failure to do so can result\n+ * in some of the entries being lost. This is of particular importance for piped\n+ * loggers, which are outside of our control and can take an arbitrarily long\n+ * time to complete. The default is intended to at least cause a context switch\n+ * to give the other process(es) time. If that isn't enough, the\n+ * PRE_EXIT_PAUSE_TIME environment variable can be used to configure a longer\n+ * pause time.\n+ */\n+static void pre_exit_pause(void)\n+{\n+    apr_interval_time_t sleep_time;\n+    const char *sleep_time_env;\n+\n+    sleep_time = DEFAULT_PRE_EXIT_PAUSE_TIME;\n+    sleep_time_env = getenv(\"PRE_EXIT_PAUSE_TIME\");\n+\n+    if (sleep_time_env) {\n+        if (ap_timeout_parameter_parse(sleep_time_env, &sleep_time, \"ms\") != APR_SUCCESS) {\n+            sleep_time = DEFAULT_PRE_EXIT_PAUSE_TIME;\n+        }\n+    }\n+\n+    if (sleep_time < 0) {\n+        sleep_time = DEFAULT_PRE_EXIT_PAUSE_TIME;\n+    }\n+\n+    apr_sleep(sleep_time);\n+}\n \n static void destroy_and_exit_process(process_rec *process,\n                                      int process_exit_value)\n {\n-    /*\n-     * Sleep for TASK_SWITCH_SLEEP micro seconds to cause a task switch on\n-     * OS layer and thus give possibly started piped loggers a chance to\n-     * process their input. Otherwise it is possible that they get killed\n-     * by us before they can do so. In this case maybe valueable log messages\n-     * might get lost.\n-     */\n-\n     /* If we are to print an error, we need the name before we destroy pool.\n      * short_name is a pointer into argv, so remains valid.\n      */\n     const char *name = process->short_name ? process->short_name : \"httpd\";\n \n-    apr_sleep(TASK_SWITCH_SLEEP);\n+    pre_exit_pause();\n     ap_main_state = AP_SQ_MS_EXITING;\n     apr_pool_destroy(process->pool); /* and destroy all descendent pools */\n     apr_terminate();", "id": 198288, "time": "2017-04-13T19:44:15Z", "bug_id": 60988, "creation_time": "2017-04-13T19:44:15Z", "is_private": false}]