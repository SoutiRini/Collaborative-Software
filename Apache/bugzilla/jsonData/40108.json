[{"count": 0, "tags": [], "bug_id": 40108, "attachment_id": null, "text": "Hi,\n\nI\u2019ve discovered a problem, that sessions are mixed, if the application makes \ncross context includes. I\u2019m using Tomcat 5.5.17.\n\nHere is the scenario:\n1)\tServlet A in context \u201cX\u201d wants to include page B from context \u201cY\u201d and \npage C from context \u201cX\u201d;\n2)\tServlet A starts two threads to include page B and C;\n3)\tServlet A pass the request and response object to these threads and \ncorresponding ServletContexts to context Y an Z (to get RequestDispatcher);\n4)\tEach thread dispatches (using RequestDispatcher) to the corresponding \npage (B or C)\n5)\tWhile in the page B and C these pages set and get attributes from the \nsession object.\n\nAccording to Servlet spec 2.4 (SRV.7.3 Session Scope) \u2013 \u201cif a servlet uses the \nRequestDispatcher to call a servlet in another Web application, any sessions \ncreated for and visible to the servlet being called must be different from \nthose visible to the calling servlet.\u201d This means that the session in the \ndifferent pages (B and C) must be different.\n\nHowever they are mixed \u2013 sometimes B sees session for C and vice versa.\n\nThe problem here is that one and the same request object is processed in two \ndifferent threads simultaneously.\n\nServlet specification does not forbid request object to be passed to multiple \nthreads and to be processed concurrently by those threads. It just says that \nthe application should wrap the request in order to synchronize the access to \nit. (Servlet spec 2.4 SRV.8.2)\n\nBut in practice this is impossible. Wrapping the request only can ensure safe \naccess but could not prevent changing of session. \n\nI\u2019ve checked the Tomcat sources. When a request has to be dispatched it is \nunwrap until container request object is reached. Then a new wrapper \n(ApplicationHttpRequest) is inserted there. This wrapper has the request \nparameters according the new context.\n\nHttpServletRequestWrapper@be49e0\nHttpServletRequestWrapper@8b8a47\nApplicationHttpRequest@e41bc3\nRequestFacade@1682598\n\nWhen the second thread dispatches the request, it is again unwrapped and a new \nwrapper is inserted:\n\nHttpServletRequestWrapper@4204\nHttpServletRequestWrapper@8b8a47\nApplicationHttpRequest@1bb9a58\nApplicationHttpRequest@e41bc3\nRequestFacade@1682598\n\nThis reflects the request in the first thread.\n\nAs a result because HttpServletRequestWrapper@8b8a47 object is common the \noutermost wrappers will use one and the same ApplicationHttpRequest@1bb9a58. \nThis is the cause for mixed session.\n\nCurrent implementation only works the first time the request is wrapped. But if \nit is wrapped several times (by some filters) this architecture will fail.\n\nI think that this has to be changed in order to allow the application to be \nable to process request in multiple threads in different contexts.\n\nSimilar scenario is valid for JSR168 Portlet applications, when the portlets \nare depoyed as separate webapps. Then the portal can trigger multiple threads \nto render the portlets from the portal page. This is equivalent to the case \nwhere a single request is processed in different context in parallel.\n\nRegards,\nDiyan", "id": 91573, "time": "2006-07-25T12:13:23Z", "creator": "diyan.yordanov@gmail.com", "creation_time": "2006-07-25T12:13:23Z", "is_private": false}, {"count": 1, "tags": [], "creator": "remm@apache.org", "is_private": false, "text": "Servlet spec 2.4 SRV.8.2 actually reads: \"The Container Provider should ensure\nthat the dispatch of the request to a target servlet occurs in the same thread\nof the same JVM as the original request.\".\n\nWhat is it you have trouble understanding ?", "id": 91607, "time": "2006-07-26T13:05:53Z", "bug_id": 40108, "creation_time": "2006-07-26T13:05:53Z", "attachment_id": null}, {"count": 2, "tags": [], "bug_id": 40108, "attachment_id": null, "text": "(In reply to comment #1)\nHi Remy,\n\nI do understand your statement. But you have to have in mind that this is not a \nmust.\n\nThe requirement in Servlet 2.4 is changed from \u201cmust\u201d to \u201cshould\u201d on contarast \nto Servlet 2.3.\n\nHere is the extract from the spec (SRV.S.17):\n\n\u2022 It is now a recommendation, instead of a requirement, that the reference to \nthe\nrequest and response object should not be given to the object in other threads -\nbased on the requirement from JSR-168. Warnings are added when the thread\ncreated by the application uses the objects managed by the container.(2.3.3.3)\n\u2022 It is now a recommendation, that the dispatch should occur in the same thread\nof the same JVM as the original request - based on the requirement from JSR-\n168(8.2)\n\nThis in practice allows the request to be dispatched to servlet in a thread \nthat is different than the thread of the original request. And in my scenario \nthe request dispatching occurs inside the new thread and not before that.\n\nSo I think that my question has its reason. Tomcat does have a bug. There is a \ntest case that can simulate it. If you need more details or examples in order \nto understand the issue, please tell and I'm ready to send it.\n\n\nRegards,\nDiyan\n\n\n\n\n", "id": 91616, "time": "2006-07-26T14:58:31Z", "creator": "diyan.yordanov@gmail.com", "creation_time": "2006-07-26T14:58:31Z", "is_private": false}]