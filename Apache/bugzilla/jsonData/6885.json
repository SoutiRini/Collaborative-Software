[{"count": 0, "tags": [], "creator": "aaron@alum.mit.edu", "text": "NodeImpl implements NodeList so it can return itself from getChildNodes().  \nParentNode implements a child node cache (I assume for performance).  This \ncombination results in problems in a multi-threaded application.  Consider the \nfollowing innocuous-looking code:\n  NodeList list = node.getChildNodes();\n  int len = list.getLength();\n  for (int i = 0; i < len; i++)\n  {\n     Node item = list.item(i);\n     // do something with item\n  }\nThis should be safe, because it should enumerate each child node exactly once.  \nIt also looks like it should be thread-safe, because it does not modify the \nstructure, and each thread appears to get its own copy of the NodeList object.  \nHowever, because ParentNode uses itself as the NodeList and has an internal \ncached child object, the two calling threads can conflict and get incorrect or \nnull results.\n\nI'm not sure if you would consider this a bug.  If the library is not \nsupposed to be thread-safe, that's a design choice, but there is no mention of \nthread-safety in the documentation and this particular thread unsafety is caused \nby an implementation choice, it's not implicit in the calling code (because \nthere is no mutation or intentional sharing of objects).\n\nI am happy to discuss this issue via e-mail.\n\n   -- Aaron Goodisman", "id": 11482, "time": "2002-03-05T20:15:12Z", "bug_id": 6885, "creation_time": "2002-03-05T20:15:12Z", "is_private": false, "attachment_id": null}, {"count": 1, "tags": [], "bug_id": 6885, "attachment_id": null, "is_private": false, "id": 11484, "time": "2002-03-05T20:39:25Z", "creator": "keshlam@us.ibm.com", "creation_time": "2002-03-05T20:39:25Z", "text": "In general, the DOM APIs do not promise threadsafety. Unless a specific \nimplementation actively promises that behavior, assume it isn't; any DOM \noperation may involve data caching or late retrieval or other reentrancy \nhazards. Remember, the DOM is only an API, not a specific set of classes; you \nhave _NO_ way of knowing what's going on under the covers, only that it \neventually returns data that represents a consistant DOM tree.\n\n(The DOM Working Group has reconsidered the threadsafety/locking issue \nperiodically, but has generally come to the conclusion that locking should be \nperformed at the application level for reasons of (a) efficiency and (b) \natomicity of multiple-operation sequences.)\n\nSo it isn't a bug unless the developers want to consider it so... but I agree \nthat it might be worth reminding users about this, if a suitable place for that \ncaveat can be found."}, {"count": 2, "tags": [], "creator": "aaron@alum.mit.edu", "text": "I agree that there's no claim of thread safety made.  The assumption I had made \nfor this code was the invariant provided by the non-synchronized java.util \nclasses (e.g., HashMap, ArrayList) that read-only access was thread safe and \nthat only modification of the structure required external synchronization.  \nObviously, that's not promised in this case, but, in general, that's a friendly \nstance.\n\nI propose a comment regarding multi-threaded access in the class documentation \nfor ParentNode, at least.  \n\nAlso, if the developers were so inclined, they could provide \nthread-safe-on-readonly as an option, set by a feature.", "id": 11492, "time": "2002-03-06T00:32:01Z", "bug_id": 6885, "creation_time": "2002-03-06T00:32:01Z", "is_private": false, "attachment_id": null}]