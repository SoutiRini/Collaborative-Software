[{"count": 0, "tags": [], "creator": "maximb@offshorecreations.com.ua", "attachment_id": null, "is_private": false, "id": 58630, "time": "2004-06-03T12:43:06Z", "bug_id": 29359, "creation_time": "2004-06-03T12:43:06Z", "text": "See fragment of public NodeRevisionDescriptors retrieveRevisionDescriptors\n(Connection connection, Uri uri) method.\n\n####################### \ntry \n{\n  statement =\n  connection.prepareStatement(\n  \"select vh.REVISION_NO, b.BRANCH_STRING from VERSION_HISTORY vh, BRANCH b, \nURI u where vh.BRANCH_ID = b.BRANCH_ID and vh.URI_ID = u.URI_ID  \n   and u.URI_STRING = ? order by vh.REVISION_NO\");\n   statement.setString(1, uri.toString());\n   res = statement.executeQuery();\n   while (res.next()) \n   {\n       NodeRevisionNumber revisionNumber = new NodeRevisionNumber(res.getString\n(1));\n       allRevisions.add(revisionNumber); // will be used to get revisions \nsuccessor\n       latestRevisionNumbers.put(res.getString(2), revisionNumber); // store \nthe lastest revision / branch\n   }\n}\nfinally \n{\n     close(statement, res);\n}\n################################\n \nBug example: \n    When file has more that 1.9 revision, this fragment will be set \ninto 'LatestRevision' revision 1.9 always."}, {"count": 1, "tags": [], "creator": "maximb@offshorecreations.com.ua", "attachment_id": null, "is_private": false, "id": 58631, "time": "2004-06-03T12:52:00Z", "bug_id": 29359, "creation_time": "2004-06-03T12:52:00Z", "text": "order by vh.REVISION_NO\nselected from table VERSION_HISTORY by order:\n1.10\n1.1\n1.2\n1.3\n1.4\n1.5\n1.6\n1.7\n1.8\n1.9\n\ntherefore latest revision is 1.9 always\nBut 1.10 > 1.9"}, {"count": 2, "tags": [], "bug_id": 29359, "attachment_id": null, "id": 58771, "time": "2004-06-04T17:28:14Z", "creator": "maximb@offshorecreations.com.ua", "creation_time": "2004-06-04T17:28:14Z", "is_private": false, "text": "You don't understand me  :)  ( I know english badly)\n\nStep by step:\n1) Put into Slide 20 files with the same name.\n   After putting, call getLatestRevision(..) method for uploaded file.\n   You will see 1.19 as latest revision.\n2) Restart application or reinit Domain\n3) Call getLatestRevision(..) method for uploaded file, again.\n   You will see 1.9 as latest revision.\n   Latest revision must be 1.19 \n\n   \n\n"}, {"count": 3, "text": ".", "creator": "maximb@offshorecreations.com.ua", "is_private": false, "id": 58772, "time": "2004-06-04T17:29:32Z", "bug_id": 29359, "creation_time": "2004-06-04T17:29:32Z", "tags": [], "attachment_id": null}, {"count": 4, "tags": [], "bug_id": 29359, "attachment_id": null, "id": 58773, "time": "2004-06-04T17:30:39Z", "creator": "maximb@offshorecreations.com.ua", "creation_time": "2004-06-04T17:30:39Z", "is_private": false, "text": "."}, {"count": 5, "tags": [], "creator": "ozeigermann@c1-fse.de", "attachment_id": null, "is_private": false, "id": 58791, "time": "2004-06-05T09:40:15Z", "bug_id": 29359, "creation_time": "2004-06-05T09:40:15Z", "text": "Why have you set this to invalid? Reopening it..."}, {"text": "OK, I see. Problem is the latest revision of a branch is not stored itself, but\nimplied by the order in which the entries are read from the db, I guess. So, we\nneed a new field to explicitely store it (as it is done in the file store).\nMaybe in the branch table?", "tags": [], "bug_id": 29359, "is_private": false, "count": 6, "id": 58792, "time": "2004-06-05T09:42:15Z", "creator": "ozeigermann@c1-fse.de", "creation_time": "2004-06-05T09:42:15Z", "attachment_id": null}, {"count": 7, "tags": [], "bug_id": 29359, "attachment_id": null, "text": "Fixed. Now the revision number gets sorted correctly", "id": 58908, "time": "2004-06-09T07:57:12Z", "creator": "ozeigermann@c1-fse.de", "creation_time": "2004-06-09T07:57:12Z", "is_private": false}]