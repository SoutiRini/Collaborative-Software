[{"count": 0, "tags": [], "bug_id": 25137, "is_private": false, "id": 48382, "attachment_id": null, "creator": "bakins@web.turner.com", "creation_time": "2003-12-02T13:37:44Z", "time": "2003-12-02T13:37:44Z", "text": "--- /home/bakins/src/httpd-2.0.48/server/mpm/worker/fdqueue.c   2003-11-06\n08:16:03.000000000 -0500\n+++ fdqueue.c   2003-09-28 23:58:41.000000000 -0400\n@@ -57,26 +57,40 @@\n  */\n  \n #include \"fdqueue.h\"\n+#include \"apr_atomic.h\"\n+\n+typedef struct recycled_pool {\n+    apr_pool_t *pool;\n+    struct recycled_pool *next;\n+} recycled_pool;\n  \n struct fd_queue_info_t {\n-    int idlers;\n+    apr_uint32_t idlers;\n     apr_thread_mutex_t *idlers_mutex;\n     apr_thread_cond_t *wait_for_idler;\n     int terminated;\n     int max_idlers;\n-    apr_pool_t        **recycled_pools;\n-    int num_recycled;\n+    recycled_pool  *recycled_pools;\n };\n  \n static apr_status_t queue_info_cleanup(void *data_)\n {\n     fd_queue_info_t *qi = data_;\n-    int i;\n     apr_thread_cond_destroy(qi->wait_for_idler);\n     apr_thread_mutex_destroy(qi->idlers_mutex);\n-    for (i = 0; i < qi->num_recycled; i++) {\n-        apr_pool_destroy(qi->recycled_pools[i]);\n+\n+    /* Clean up any pools in the recycled list */\n+    for (;;) {\n+        struct recycled_pool *first_pool = qi->recycled_pools;\n+        if (first_pool == NULL) {\n+            break;\n+        }\n+        if (apr_atomic_casptr((volatile void**)&(qi->recycled_pools),\nfirst_pool->next,\n+                              first_pool) == first_pool) {\n+            apr_pool_destroy(first_pool->pool);\n+        }\n     }\n+\n     return APR_SUCCESS;\n }\n  \n@@ -98,9 +112,7 @@\n     if (rv != APR_SUCCESS) {\n         return rv;\n     }\n-    qi->recycled_pools = (apr_pool_t **)apr_palloc(pool, max_idlers *\n-                                                   sizeof(apr_pool_t *));\n-    qi->num_recycled = 0;\n+    qi->recycled_pools = NULL;\n     qi->max_idlers = max_idlers;\n     apr_pool_cleanup_register(pool, qi, queue_info_cleanup,\n                               apr_pool_cleanup_null);\n@@ -114,24 +126,53 @@\n                                     apr_pool_t *pool_to_recycle)\n {\n     apr_status_t rv;\n-    rv = apr_thread_mutex_lock(queue_info->idlers_mutex);\n-    if (rv != APR_SUCCESS) {\n-        return rv;\n-    }\n-    AP_DEBUG_ASSERT(queue_info->idlers >= 0);\n-    AP_DEBUG_ASSERT(queue_info->num_recycled < queue_info->max_idlers);\n+    int prev_idlers;\n+\n+    /* If we have been given a pool to recycle, atomically link\n+     * it into the queue_info's list of recycled pools\n+     */\n     if (pool_to_recycle) {\n-        queue_info->recycled_pools[queue_info->num_recycled++] =\n-            pool_to_recycle;\n+        struct recycled_pool *new_recycle;\n+        new_recycle = (struct recycled_pool *)apr_palloc(pool_to_recycle,\n+                                                         sizeof(*new_recycle));\n+        new_recycle->pool = pool_to_recycle;\n+        for (;;) {\n+            new_recycle->next = queue_info->recycled_pools;\n+            if (apr_atomic_casptr((volatile void**)&(queue_info->recycled_pools),\n+                                  new_recycle, new_recycle->next) ==\n+                new_recycle->next) {\n+                break;\n+            }\n+        }\n     }\n-    if (queue_info->idlers++ == 0) {\n-        /* Only signal if we had no idlers before. */\n-        apr_thread_cond_signal(queue_info->wait_for_idler);\n+\n+    /* Atomically increment the count of idle workers */\n+    for (;;) {\n+        prev_idlers = queue_info->idlers;\n+        if (apr_atomic_cas32(&(queue_info->idlers), prev_idlers + 1,\n+                             prev_idlers) == prev_idlers) {\n+            break;\n+        }\n     }\n-    rv = apr_thread_mutex_unlock(queue_info->idlers_mutex);\n-    if (rv != APR_SUCCESS) {\n-        return rv;\n+\n+    /* If this thread just made the idle worker count nonzero,\n+     * wake up the listener. */\n+    if (prev_idlers == 0) {\n+        rv = apr_thread_mutex_lock(queue_info->idlers_mutex);\n+        if (rv != APR_SUCCESS) {\n+            return rv;\n+        }\n+        rv = apr_thread_cond_signal(queue_info->wait_for_idler);\n+        if (rv != APR_SUCCESS) {\n+            apr_thread_mutex_unlock(queue_info->idlers_mutex);\n+            return rv;\n+        }\n+        rv = apr_thread_mutex_unlock(queue_info->idlers_mutex);\n+        if (rv != APR_SUCCESS) {\n+            return rv;\n+        }\n     }\n+\n     return APR_SUCCESS;\n }\n  \n@@ -139,34 +180,66 @@\n                                           apr_pool_t **recycled_pool)\n {\n     apr_status_t rv;\n+\n     *recycled_pool = NULL;\n-    rv = apr_thread_mutex_lock(queue_info->idlers_mutex);\n-    if (rv != APR_SUCCESS) {\n-        return rv;\n-    }\n-    AP_DEBUG_ASSERT(queue_info->idlers >= 0);\n-    while ((queue_info->idlers == 0) && (!queue_info->terminated)) {\n-        rv = apr_thread_cond_wait(queue_info->wait_for_idler,\n-                                  queue_info->idlers_mutex);\n+\n+    /* Block if the count of idle workers is zero */\n+    if (queue_info->idlers == 0) {\n+        rv = apr_thread_mutex_lock(queue_info->idlers_mutex);\n         if (rv != APR_SUCCESS) {\n-            apr_status_t rv2;\n-            rv2 = apr_thread_mutex_unlock(queue_info->idlers_mutex);\n-            if (rv2 != APR_SUCCESS) {\n-                return rv2;\n+            return rv;\n+        }\n+        /* Re-check the idle worker count to guard against a\n+         * race condition.  Now that we're in the mutex-protected\n+         * region, one of two things may have happened:\n+         *   - If the idle worker count is still zero, the\n+         *     workers are all still busy, so it's safe to\n+         *     block on a condition variable.\n+         *   - If the idle worker count is nonzero, then a\n+         *     worker has become idle since the first check\n+         *     of queue_info->idlers above.  It's possible\n+         *     that the worker has also signaled the condition\n+         *     variable--and if so, the listener missed it\n+         *     because it wasn't yet blocked on the condition\n+         *     variable.  But if the idle worker count is\n+         *     now nonzero, it's safe for this function to\n+         *     return immediately.\n+         */\n+        if (queue_info->idlers == 0) {\n+            rv = apr_thread_cond_wait(queue_info->wait_for_idler,\n+                                  queue_info->idlers_mutex);\n+            if (rv != APR_SUCCESS) {\n+                apr_status_t rv2;\n+                rv2 = apr_thread_mutex_unlock(queue_info->idlers_mutex);\n+                if (rv2 != APR_SUCCESS) {\n+                    return rv2;\n+                }\n+                return rv;\n             }\n+        }\n+        rv = apr_thread_mutex_unlock(queue_info->idlers_mutex);\n+        if (rv != APR_SUCCESS) {\n             return rv;\n         }\n     }\n-    queue_info->idlers--; /* Oh, and idler? Let's take 'em! */\n-    if (queue_info->num_recycled) {\n-        *recycled_pool =\n-            queue_info->recycled_pools[--queue_info->num_recycled];\n-    }\n-    rv = apr_thread_mutex_unlock(queue_info->idlers_mutex);\n-    if (rv != APR_SUCCESS) {\n-        return rv;\n+\n+    /* Atomically decrement the idle worker count */\n+    apr_atomic_dec32(&(queue_info->idlers));\n+\n+    /* Atomically pop a pool from the recycled list */\n+    for (;;) {\n+        struct recycled_pool *first_pool = queue_info->recycled_pools;\n+        if (first_pool == NULL) {\n+            break;\n+        }\n+        if (apr_atomic_casptr((volatile void**)&(queue_info->recycled_pools),\nfirst_pool->next,\n+                              first_pool) == first_pool) {\n+            *recycled_pool = first_pool->pool;\n+            break;\n+        }\n     }\n-    else if (queue_info->terminated) {\n+\n+    if (queue_info->terminated) {\n         return APR_EOF;\n     }\n     else {\n@@ -183,11 +256,7 @@\n     }\n     queue_info->terminated = 1;\n     apr_thread_cond_broadcast(queue_info->wait_for_idler);\n-    rv = apr_thread_mutex_unlock(queue_info->idlers_mutex);\n-    if (rv != APR_SUCCESS) {\n-        return rv;\n-    }\n-    return APR_SUCCESS;\n+    return apr_thread_mutex_unlock(queue_info->idlers_mutex);\n }\n  \n /**\n@@ -334,10 +403,7 @@\n         return rv;\n     }\n     apr_thread_cond_broadcast(queue->not_empty);\n-    if ((rv = apr_thread_mutex_unlock(queue->one_big_mutex)) != APR_SUCCESS) {\n-        return rv;\n-    }\n-    return APR_SUCCESS;\n+    return apr_thread_mutex_unlock(queue->one_big_mutex);\n }\n  \n apr_status_t ap_queue_term(fd_queue_t *queue)"}, {"count": 1, "tags": [], "creator": "nick@webthing.com", "is_private": false, "text": "I think this ancient request is superseded by 2.2.", "id": 127391, "time": "2009-05-25T15:13:55Z", "bug_id": 25137, "creation_time": "2009-05-25T15:13:55Z", "attachment_id": null}, {"count": 2, "tags": [], "creator": "nick@webthing.com", "text": "I think this ancient request is superseded by 2.2.", "id": 127392, "time": "2009-05-25T15:15:00Z", "bug_id": 25137, "creation_time": "2009-05-25T15:15:00Z", "is_private": false, "attachment_id": null}]