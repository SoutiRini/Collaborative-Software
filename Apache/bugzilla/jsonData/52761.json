[{"count": 0, "attachment_id": null, "creator": "diego.rivera.cr@gmail.com", "is_private": false, "id": 154111, "time": "2012-02-24T16:22:27Z", "bug_id": 52761, "creation_time": "2012-02-24T16:22:27Z", "tags": [], "text": "This is the stack trace.\n\njava.lang.NullPointerException\n\tat org.apache.catalina.connector.Request.notifyAttributeAssigned(Request.java:1552)\n\tat org.apache.catalina.connector.Request.setAttribute(Request.java:1543)\n\tat org.apache.catalina.connector.RequestFacade.setAttribute(RequestFacade.java:541)\n\tat org.apache.catalina.core.ApplicationHttpRequest.setAttribute(ApplicationHttpRequest.java:281)\n\nBoth parameters for the invocation to setAttribute() are non-null.  It works 99% of the time, but sporadically it will cause requests to fail. Looking at the code, it seems like the request's context is the culprit (value is null).\n\nThis problem wasn't showing up with earlier versions (7.0.23, I think)."}, {"count": 1, "tags": [], "bug_id": 52761, "attachment_id": null, "id": 154114, "time": "2012-02-24T16:39:07Z", "creator": "diego.rivera.cr@gmail.com", "creation_time": "2012-02-24T16:39:07Z", "is_private": false, "text": "Correction, 7.0.23 also seems to be afflicted.  I must've not run into it before (which emphasizes how sporadic it is)."}, {"count": 2, "tags": [], "text": "It is pretty much impossible for the context to be null unless the application is doing something it shouldn't like retaining a reference to a request object in the session.\n\nThe users list is the place to seek help with this.", "is_private": false, "id": 154115, "creator": "markt@apache.org", "time": "2012-02-24T16:44:10Z", "bug_id": 52761, "creation_time": "2012-02-24T16:44:10Z", "attachment_id": null}, {"count": 3, "tags": [], "bug_id": 52761, "attachment_id": null, "id": 154116, "time": "2012-02-24T16:46:17Z", "creator": "diego.rivera.cr@gmail.com", "creation_time": "2012-02-24T16:46:17Z", "is_private": false, "text": "Well, I'm not keeping references to a request because, as you mention, doing that is not sane.  This is 100% certain.\n\nAnd I agree - this is weird, because it means that everything that happened previously that made the request get as far as it got would have exploded."}, {"count": 4, "tags": [], "text": "Are you possibly calling setAttribute() from threads other than the servlet request thread?\n\nI ask as this would be a very serious problem *if* this impacts the supported usage of this API.\n\nIt is, however, enormously tempting (and useful in cases) to start calling servlet request APIs from other threads.  This is explicitly not supported by either the servlet API or Tomcat.  Doing such calls could cause problems for any of the threads involved -- including the servlet request thread.\n\nA related possibility as Mark suggests is that you're attempting to make the call after processing of the given servlet request has been completed, which again is unsupported by both the servlet API and Tomcat.", "is_private": false, "id": 154117, "creator": "jessh@ptc.com", "time": "2012-02-24T16:48:01Z", "bug_id": 52761, "creation_time": "2012-02-24T16:48:01Z", "attachment_id": null}, {"count": 5, "tags": [], "bug_id": 52761, "attachment_id": null, "text": "Understood on both cases (separate thread, or after request has been recycled).\n\nI'm fairly sure right now that neither is happening.  I know for sure I'm not keeping references, and I'm pretty sure about the thread access b/c my background threads are doing other things not related to the request.\n\nLet me review and I'll let you guys know shortly.", "id": 154118, "time": "2012-02-24T16:50:49Z", "creator": "diego.rivera.cr@gmail.com", "creation_time": "2012-02-24T16:50:49Z", "is_private": false}, {"count": 6, "tags": [], "bug_id": 52761, "attachment_id": null, "id": 154119, "time": "2012-02-24T17:15:12Z", "creator": "diego.rivera.cr@gmail.com", "creation_time": "2012-02-24T17:15:12Z", "is_private": false, "text": "You guys were right, this defect is invalid.  There was a very subtle race condition being entered into which resulted in a Request instance being accessed from the wrong request thread (i.e. two concurrent requests A and B, it was possible for thread B to access the request object from thread A, which is evidently wrong).\n\nThanks for your time, and sorry for the confusion."}]