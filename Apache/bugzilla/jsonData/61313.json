[{"count": 0, "tags": [], "text": "Created attachment 35146\nmy hacky patch\n\nI have worked with \u200ecsutherl\u200e on #tomcat on irc.freenode.net who decided this is a bug and should be reported here rather than the ML.\n\nJDK version tested was oracle JDK 1.8.0_66.\n\nI have set connectionURL and alternateURL to try to get LDAP server failover to work.\n\nIf both servers are up, it \"works well\".\nIf only the connectionURL server is down (firewall is set to REJECT) then a newly restarted tomcat works fine, but if it goes down while tomcat is already running, the next LDAP lookup takes 15m32s.\nIf only the alternateURL server is down (firewall is set to REJECT) then a newly restarted tomcat works fine, but if it goes down while tomcat is already running, and the connectionURL server was down before but up again now (so the JNDIRealm's instance variable \"context\" is currently set using alternateURL) the next LDAP lookup takes 15m32s.\n\nSetting connectionTimeout has no effect on the time. I have verified it ends up in the Hashtable returned by getDirectoryContextEnvironment().\n\nAnd if I apply my hacky patch (attached, applies to tomcat85 git repo, tag TOMCAT_8_5_16) for the method \"JNDIRealm.open()\" so it works like a fresh tomcat startup, and never returns the old context (closes it and sets it to null, then lets the rest of the code run), it always \"works well\", taking 4-7s on a fresh tomcat, or less than 0.1s on a warmed up tomcat.\n\nserver.xml snippets:\n\n    <Realm className=\"org.apache.catalina.realm.MemoryRealm\" digest=\"MD5\" />\n    </Realm>\n    \n    <Realm className=\"org.apache.catalina.realm.JNDIRealm\"\n        connectionURL=\"ldap://auth1:389\"\n        connectionTimeout=\"1000\"\n        connectionAttempt=\"0\"\n        alternateURL=\"ldap://auth2:389\"\n        userPattern=\"uid={0},ou=People,dc=example,dc=com\"\n        userRoleAttribute=\"gidNumber\"\n        roleBase=\"ou=Group,dc=example,dc=com\"\n        roleName=\"cn\"\n        roleSearch=\"(|(gidNumber={2})(memberUid={1}))\"\n        />\n\nan example webapp that can be used for testing is attached\n\nfirewall test code (assuming otherwise blank firewall with policy ACCEPT):\n    t() { iptables -D INPUT 1 ; iptables -I INPUT 1 -p tcp -s 10.3.0.21 -j \"$1\" ; iptables -nvL; }\n    \n    # run this on machines that should work\n    t LOG\n    # run this on machines that should fail\n    t REJECT\n    \nthe test:\n    # prerequisite for the test is a server named \"auth1\" and another \"auth2\" which run on port 389. In our case it's slapd, and they have start_tls enabled but not required.\n    # on both LDAP servers:\n    t LOG\n\n    # then start tomcat, then\n    # on the first LDAP server:\n    t REJECT\n\n    # on a test machine (content of the user and password here shouldn't matter... we aren't testing authentication, only time taken)\n    time curl --user someuser:somepassword http://exampledomain:8080/dummy-service/test/ldap\n\n    (ignore response, but look at time taken)\n\nresult:\n    Almost always takes 15m32.4s plus up to 4s or so, but usually within a few ms.\n    When it \"works well\" (described in detail above), the first run takes about 4-7s, and after that it takes around 0.02s to 0.1s.\n    \nexpected:\n    It should always be quick, within some small multiple of the connection timeout, preferrably 1x. So in this case, it should take about 1s extra, or at most a few seconds, so 1.1s on a warmed up tomcat.\n\nSide comment: other LDAP clients support an arbitrary number of urls, or one line with all the urls together... I find it limiting to have only 2 that you can set here. We have 3 LDAP servers.", "attachment_id": 35146, "bug_id": 61313, "id": 199852, "time": "2017-07-17T15:42:52Z", "creator": "peter.maloney@brockmann-consult.de", "creation_time": "2017-07-17T15:42:52Z", "is_private": false}, {"count": 1, "tags": [], "creator": "peter.maloney@brockmann-consult.de", "attachment_id": 35147, "text": "Created attachment 35147\nan example webapp that can be used for testing\n\nIf it says \"The origin server did not find a current representation for the target resource or is not willing to disclose that one exists.\" that's fine... it just means the user doesn't exist or something, but it got to the LDAP server. I have verified it is fast with my patch and slow without it.\n\nIf it says \"The request has not been applied because it lacks valid authentication credentials for the target resource.\" it means it can't contact any LDAP server, which is probably fine as long as it's fast. I verified that it's fast with my patch and slow without it.", "id": 199853, "time": "2017-07-17T15:55:37Z", "bug_id": 61313, "creation_time": "2017-07-17T15:55:37Z", "is_private": false}, {"count": 2, "attachment_id": 35148, "creator": "felix.schumacher@internetallee.de", "is_private": false, "id": 199854, "time": "2017-07-17T17:17:28Z", "bug_id": 61313, "creation_time": "2017-07-17T17:17:28Z", "tags": [], "text": "Created attachment 35148\nAdd an option to set a read timeout to ldap connections used by JNDI Realm\n\nJava LDAP API seems to have an option for read timeouts. This should shorten the timeouts that you see when the firewall looses the connection state and starts dropping the packets.\n\nI haven't tested the patch yet and I think it would be even better to have an timeout on connections that aren't used for a long time, too. If the LDAP API has no such timeout, we could emulate it by keeping a timestamp up to date in close and open calls."}, {"count": 3, "tags": [], "bug_id": 61313, "attachment_id": null, "id": 199857, "time": "2017-07-17T22:45:32Z", "creator": "markt@apache.org", "creation_time": "2017-07-17T22:45:32Z", "is_private": false, "text": "Please test Felix's proposed patch and report back.\n\nNote: if it works, the documentation will need to be updated as well."}, {"count": 4, "tags": [], "creator": "peter.maloney@brockmann-consult.de", "attachment_id": null, "text": "Using Felix's patch, letting the tomcat warm up with some ok requests and both auth servers online, then taking the first down, then doing a request (to our regular app, or the dummy), it takes 6s to fail and says:\n\n<!doctype html><html lang=\"en\"><head><title>HTTP Status 401 \u2013 Unauthorized</title><style type=\"text/css\">h1 {font-family:Tahoma,Arial,sans-serif;color:white;background-color:#525D76;font-size:22px;} h2 {font-family:Tahoma,Arial,sans-serif;color:white;background-color:#525D76;font-size:16px;} h3 {font-family:Tahoma,Arial,sans-serif;color:white;background-color:#525D76;font-size:14px;} body {font-family:Tahoma,Arial,sans-serif;color:black;background-color:white;} b {font-family:Tahoma,Arial,sans-serif;color:white;background-color:#525D76;} p {font-family:Tahoma,Arial,sans-serif;background:white;color:black;font-size:12px;} a {color:black;} a.name {color:black;} .line {height:1px;background-color:#525D76;border:none;}</style></head><body><h1>HTTP Status 401 \u2013 Unauthorized</h1><hr class=\"line\" /><p><b>Type</b> Status Report</p><p><b>Description</b> The request has not been applied because it lacks valid authentication credentials for the target resource.</p><hr class=\"line\" /><h3>Apache Tomcat/8.5.16</h3></body></html>\n\nAnd then subsequent requests work fine. (but the dummy always says the above, so I guess you can't test that)\n\nDoing the failure the other way around works the same.\n\nIf I set the timeout to 500 in the server.xml, it takes 1s instead.\n\nSo the timeout works great, but it doesn't seem to fall back to the alternate/connection URL. So I think the patch is good, but incomplete.", "id": 199862, "time": "2017-07-18T14:33:11Z", "bug_id": 61313, "creation_time": "2017-07-18T14:33:11Z", "is_private": false}, {"count": 5, "tags": [], "creator": "peter.maloney@brockmann-consult.de", "attachment_id": null, "text": "The code just closes the context and returns null, and does not retry, so I guess that explains why it fails.\n\n\nline 1326 JNDIRealm.java\n        } catch (NamingException e) {\n\n            // Log the problem for posterity\n            containerLog.error(sm.getString(\"jndiRealm.exception\"), e);\n\n            // Close the connection so that it gets reopened next time\n            if (context != null)\n                close(context);\n\n            // Return \"not authenticated\" for this request\n            if (containerLog.isDebugEnabled())\n                containerLog.debug(\"Returning null principal.\");\n            return null;\n\n        }\n\n\nSEVERE: org.apache.catalina.realm.JNDIRealm: Exception performing authentication\njavax.naming.NamingException: LDAP response read timed out, timeout used:500ms.; remaining name 'uid=urban1,ou=People,dc=bc,dc=local'\n        at com.sun.jndi.ldap.Connection.readReply(Connection.java:490)\n        at com.sun.jndi.ldap.LdapClient.ldapBind(LdapClient.java:365)\n        at com.sun.jndi.ldap.LdapClient.authenticate(LdapClient.java:214)\n        at com.sun.jndi.ldap.LdapCtx.connect(LdapCtx.java:2788)\n        at com.sun.jndi.ldap.LdapCtx.ensureOpen(LdapCtx.java:2696)\n        at com.sun.jndi.ldap.LdapCtx.ensureOpen(LdapCtx.java:2670)\n        at com.sun.jndi.ldap.LdapCtx.doSearch(LdapCtx.java:1941)\n        at com.sun.jndi.ldap.LdapCtx.doSearchOnce(LdapCtx.java:1933)\n        at com.sun.jndi.ldap.LdapCtx.c_getAttributes(LdapCtx.java:1325)\n        at com.sun.jndi.toolkit.ctx.ComponentDirContext.p_getAttributes(ComponentDirContext.java:235)\n        at com.sun.jndi.toolkit.ctx.PartialCompositeDirContext.getAttributes(PartialCompositeDirContext.java:141)\n        at com.sun.jndi.toolkit.ctx.PartialCompositeDirContext.getAttributes(PartialCompositeDirContext.java:129)\n        at javax.naming.directory.InitialDirContext.getAttributes(InitialDirContext.java:142)\n        at org.apache.catalina.realm.JNDIRealm.getUserByPattern(JNDIRealm.java:1558)\n        at org.apache.catalina.realm.JNDIRealm.getUserByPattern(JNDIRealm.java:1624)\n        at org.apache.catalina.realm.JNDIRealm.getUser(JNDIRealm.java:1499)\n        at org.apache.catalina.realm.JNDIRealm.authenticate(JNDIRealm.java:1377)\n        at org.apache.catalina.realm.JNDIRealm.authenticate(JNDIRealm.java:1295)\n        at org.apache.catalina.authenticator.BasicAuthenticator.doAuthenticate(BasicAuthenticator.java:73)\n        at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:560)\n        at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140)\n        at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:80)\n        at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:624)\n        at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87)\n        at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)\n        at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:799)\n        at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66)\n        at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868)\n        at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1455)\n        at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n        at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\n        at java.lang.Thread.run(Thread.java:745)", "id": 199863, "time": "2017-07-18T15:28:39Z", "bug_id": 61313, "creation_time": "2017-07-18T15:28:39Z", "is_private": false}, {"count": 6, "attachment_id": 35151, "creator": "peter.maloney@brockmann-consult.de", "is_private": false, "id": 199864, "time": "2017-07-18T15:34:48Z", "bug_id": 61313, "creation_time": "2017-07-18T15:34:48Z", "tags": [], "text": "Created attachment 35151\nsecond possibly hacky patch, includes Felix's patch\n\nHere's another possibly hacky patch. This one looks less hacky, but it only covers the one place where the exception I observed happens. I chose that place because it is the first call of a protected method in the stack; the others before are public. And I don't know if it could loop forever, or pointlessly retry when there is another kind of exception which is also a NamingException (this one is a read timeout... I don't know what else there is).\n\nWith this patch, the problem is fixed in my testing... a failed server that was already in a previous context will cause only a delay about 0.5s plus the readTimeout. And both servers down will result in the \"HTTP Status 401 \u2013 Unauthorized\" error and delay will also be about 0.5s plus the readTimeout."}, {"count": 7, "attachment_id": null, "creator": "markt@apache.org", "is_private": false, "id": 199984, "time": "2017-07-24T15:04:22Z", "bug_id": 61313, "creation_time": "2017-07-24T15:04:22Z", "tags": [], "text": "Thanks for the work on this and especially for the patches.\n\nThere is already retry code in the public authenticate() method.\n\nFundamentally this hits up against a problem that the previous code was trying to deal with - how do you tell if a NamingException is something that requires fail over? The short answer is you can't always tell and the previous code was not failing over unless there was a clear indication (via the Exception type) that such a fail over was required.\n\nI have changed the logic so it always attempts to fail over. This won't be perfect either but I'd rather it always attempted to fail over and therefore always worked when it could and we get a few extra error messages than it didn't try to fail over and therefore failed when a fail over could have resulted in correct operation.\n\nI've also included the readTimeout improvements.\n\nFixed in:\n- trunk for 9.0.0.M25 onwards\n- 8.5.x for 8.5.19 onwards\n- 8.0.x for 8.0.46 onwards\n- 7.0.x for 7.0.80 onwards"}, {"count": 8, "tags": [], "bug_id": 61313, "attachment_id": null, "is_private": false, "id": 199988, "time": "2017-07-24T16:47:52Z", "creator": "peter.maloney@brockmann-consult.de", "creation_time": "2017-07-24T16:47:52Z", "text": "Thanks. I tested commit 30e89f9efb571a19d2d3239db7b5e0c17f86b812 (tomcat85 repo) which works like the second possibly hacky patch."}]