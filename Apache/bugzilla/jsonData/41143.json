[{"count": 0, "tags": [], "bug_id": 41143, "text": "The misplaced ap_getline may discard a valid header after a too long header, ap_getline already discards \nextra data.\nThe patch (side effect) also reduces the stack usage considerably (by 8KB).", "id": 96715, "time": "2006-12-10T15:03:32Z", "creator": "davi@apache.org", "creation_time": "2006-12-10T15:03:32Z", "is_private": false, "attachment_id": null}, {"count": 1, "attachment_id": 19239, "creator": "davi@apache.org", "is_private": false, "id": 96716, "time": "2006-12-10T15:04:36Z", "bug_id": 41143, "creation_time": "2006-12-10T15:04:36Z", "tags": [], "text": "Created attachment 19239\npatch against the 2.2.x branch"}, {"attachment_id": null, "tags": [], "creator": "jfclere@gmail.com", "text": "Fixed in 2.2.4", "count": 2, "id": 104797, "time": "2007-06-28T00:02:41Z", "bug_id": 41143, "creation_time": "2007-06-28T00:02:41Z", "is_private": false}, {"count": 3, "tags": [], "bug_id": 41143, "text": "Are you sure? which commit fixed it? I fail to see how this was solved. The code in\nquestion is still present on the 2.2.x branch and trunk.", "id": 104811, "time": "2007-06-28T04:16:45Z", "creator": "davi@apache.org", "creation_time": "2007-06-28T04:16:45Z", "is_private": false, "attachment_id": null}, {"attachment_id": null, "tags": [], "creator": "rpluem@apache.org", "text": "(In reply to comment #0)\n> The misplaced ap_getline may discard a valid header after a too long header,\nap_getline already discards \n> extra data.\n\nI am no sure if this is true in the case that the header is larger than 16KB,\nbecause in this case ap_rgetline_core will be left after the second\nap_get_brigade (in the case we only have the ap_core_input_filter in the input\nfilter chain, not checked the SSL case) which only read 16KB from the socket.\n\n> The patch (side effect) also reduces the stack usage considerably (by 8KB).\n\n", "count": 4, "id": 104874, "time": "2007-06-28T14:16:20Z", "bug_id": 41143, "creation_time": "2007-06-28T14:16:20Z", "is_private": false}, {"attachment_id": null, "tags": [], "creator": "davi@apache.org", "text": "(In reply to comment #4)\n> (In reply to comment #0)\n> > The misplaced ap_getline may discard a valid header after a too long header,\n> > ap_getline already discards extra data.\n> \n> I am no sure if this is true in the case that the header is larger than 16KB,\n> because in this case ap_rgetline_core will be left after the second\n> ap_get_brigade (in the case we only have the ap_core_input_filter in the input\n> filter chain, not checked the SSL case) which only read 16KB from the socket.\n> \n\nBear with me:\n\nap_proxy_read_headers() calls ap_getline() with a buffer of 8192 bytes. ap_getline()\ncreates a brigade and calls ap_rgetline() to get a line of protocol input (and to copy\nthe line to the buffer). ap_rgetline_core() calls ap_get_brigade(AP_MODE_GETLINE)\nwhich returns a line (brigade) of 8200 bytes (for the sake of example). If all data\nis in the first bucket, the line size could overflow the buffer, then APR_ENOSPC\nis returned. ap_getline sees the APR_ENOSPC and returns the buffer size.\n\nWe have two problems here. First, if the data of the first bucket overflows the buffer,\nthe data is not copied but ap_getline returns the size of the buffer (meaning that the\ndata was copied). Second, ap_proxy_read_headers checks if the returned len is >= than\nthe buffer size-1, if so, it calls ap_getline again, but the line was already read by\nap_get_brigade and discarded.\n\nMakes sense now?", "count": 5, "id": 104877, "time": "2007-06-28T14:50:44Z", "bug_id": 41143, "creation_time": "2007-06-28T14:50:44Z", "is_private": false}, {"count": 6, "tags": [], "bug_id": 41143, "attachment_id": null, "is_private": false, "id": 104879, "time": "2007-06-28T15:06:26Z", "creator": "rpluem@apache.org", "creation_time": "2007-06-28T15:06:26Z", "text": "(In reply to comment #5)\n\n> Bear with me:\n> \n> ap_proxy_read_headers() calls ap_getline() with a buffer of 8192 bytes.\nap_getline()\n> creates a brigade and calls ap_rgetline() to get a line of protocol input (and\nto copy\n> the line to the buffer). ap_rgetline_core() calls ap_get_brigade(AP_MODE_GETLINE)\n> which returns a line (brigade) of 8200 bytes (for the sake of example). If all\ndata\n\nBut ap_get_brigade(AP_MODE_GETLINE) returns 8192 bytes at max and it is not\nguaranteed that this data contains a LF. It is only guaranteed that\nap_get_brigade(AP_MODE_GETLINE) does not read *past* a LF. See\nap_core_input_filter and apr_brigade_split_line for why.\n\n\n> \n> Makes sense now?\n\nI agree that current code does it wrong, but I fear that there are other cases\nwhere your patch will do it wrong.\n"}, {"count": 7, "tags": [], "text": "(In reply to comment #6)\n> (In reply to comment #5)\n> \n> \n> But ap_get_brigade(AP_MODE_GETLINE) returns 8192 bytes at max and it is not\n> guaranteed that this data contains a LF.\n\nNo! ap_get_brigade(AP_MODE_GETLINE) may return much more than 8192 bytes.\nSuppose a brigade has two buckets of APR_BUCKET_BUFF_SIZE (8000) bytes each\nand the line break is on the second bucket, at position 4000. In this case, \napr_brigade_split_line() will read the first bucket, and will proceed to read the\nnext one since it's size is not >= HUGE_STRING_LEN. It will find a LF on the second\none and return a brigade of 12000 bytes.\n\n> I agree that current code does it wrong, but I fear that there are other cases\n> where your patch will do it wrong.\n\nWould you care to elaborate? Also, i'm not sure too if it's the best fix, but it can't\nget any worse (famous last words).", "attachment_id": null, "id": 104880, "creator": "davi@apache.org", "time": "2007-06-28T16:18:24Z", "bug_id": 41143, "creation_time": "2007-06-28T16:18:24Z", "is_private": false}, {"count": 8, "tags": [], "bug_id": 41143, "is_private": false, "text": "I forgot to mention, but but if my memory serves well I spotted this issue while playing with\nlarge cookies. It's not a critical real-world issue, yet :-)\n\nThanks for you comments.", "id": 104883, "time": "2007-06-28T16:30:25Z", "creator": "davi@apache.org", "creation_time": "2007-06-28T16:30:25Z", "attachment_id": null}, {"count": 9, "tags": [], "bug_id": 41143, "text": "(In reply to comment #7)\n> (In reply to comment #6)\n\n> > But ap_get_brigade(AP_MODE_GETLINE) returns 8192 bytes at max and it is not\n> > guaranteed that this data contains a LF.\n> \n> No! ap_get_brigade(AP_MODE_GETLINE) may return much more than 8192 bytes.\n\nOk. You are correct with this. Sorry, I misread the loop. \n\n> Suppose a brigade has two buckets of APR_BUCKET_BUFF_SIZE (8000) bytes each\n> and the line break is on the second bucket, at position 4000. In this case, \n> apr_brigade_split_line() will read the first bucket, and will proceed to read the\n> next one since it's size is not >= HUGE_STRING_LEN. It will find a LF on the\nsecond\n> one and return a brigade of 12000 bytes.\n\nSo apr_brigade_split_line() will not return more than maxbytes-1 + the size of\nthe following bucket. So the brigade returned by ap_get_brigade(AP_MODE_GETLINE)\nmay not contain the LF if the header is long enough (I would suppose that 16KB =\n2 * 8000 (APR_BUCKET_BUFF_SIZE) + 384 should be sufficient to get there).\nI admit that this is a constructed edge case that might not happen in real life :-).\n\n> \n> > I agree that current code does it wrong, but I fear that there are other cases\n> > where your patch will do it wrong.\n> \n> Would you care to elaborate? Also, i'm not sure too if it's the best fix, but\nit can't\n> get any worse (famous last words).\n\nIt is not getting worse, only different :-).\n\n", "id": 104904, "time": "2007-06-29T07:02:44Z", "creator": "rpluem@apache.org", "creation_time": "2007-06-29T07:02:44Z", "is_private": false, "attachment_id": null}]