[{"count": 0, "attachment_id": null, "creator": "andrei.astrouski@gmail.com", "text": "Steps:\n1. Open old.xls Excel file (see in attachment).\n2. Create new XLSX Excel file.\n2. Copy cell with colored background from old.xls to new xlsx.\n3. Process new xlsx doc with poi.\n4. Get cell background color:\ncell.getCellStyle().getFillForegroundXSSFColor().getRgb()\n\nActual: null\nExpected: rgb byte array", "id": 144310, "time": "2011-02-15T11:23:29Z", "bug_id": 50786, "creation_time": "2011-02-15T11:23:29Z", "tags": [], "is_private": false}, {"count": 1, "attachment_id": 26661, "bug_id": 50786, "is_private": false, "id": 144311, "time": "2011-02-15T11:26:26Z", "creator": "andrei.astrouski@gmail.com", "creation_time": "2011-02-15T11:26:26Z", "tags": [], "text": "Created attachment 26661\nExcel 97-2003 file"}, {"count": 2, "tags": [], "creator": "apache@gagravarr.org", "text": "Can you unzip the file (.xlsx is a zip of xml files), and track down where your colour actually gets stored?", "id": 144318, "time": "2011-02-15T11:51:48Z", "bug_id": 50786, "creation_time": "2011-02-15T11:51:48Z", "is_private": false, "attachment_id": null}, {"count": 3, "text": "styles.xml\n<fgColor indexed=\"42\"/>\nColor is stored as indexed.\n\nPossible solution:\n\nXSSFColor color = ..;\nshort colorIndex = color.getIndexed();\nHSSFColor indexedColor = HSSFColor.getIndexHash().get(colorIndex);\nbyte[] rgb = indexedColor.getTriplet();", "bug_id": 50786, "is_private": false, "id": 144340, "time": "2011-02-16T05:56:04Z", "creator": "andrei.astrouski@gmail.com", "creation_time": "2011-02-16T05:56:04Z", "tags": [], "attachment_id": null}, {"count": 4, "tags": [], "creator": "apache@gagravarr.org", "attachment_id": null, "is_private": false, "id": 144417, "time": "2011-02-18T12:42:14Z", "bug_id": 50786, "creation_time": "2011-02-18T12:42:14Z", "text": "Thanks for the investigating, sample file and proposed fix\n\nI've added the HSSFColor lookup inside the getRGB method and added a unit test for it in r1072082."}, {"count": 5, "tags": [], "creator": "andrei.astrouski@gmail.com", "attachment_id": null, "id": 144672, "time": "2011-03-02T09:31:08Z", "bug_id": 50786, "creation_time": "2011-03-02T09:31:08Z", "is_private": false, "text": "Noticed that indexed colors hashtable is not stored in HSSFColor. So getRGBOrARGB() method calls HSSFColor.getIndexHash() whitch every time (fill color, text color, border color) builds color hashtable. It's very slowly.\n\nHSSFColor.getIndexHash() method has comment:\n\"this function returns all colors in a hastable.  Its not implemented as a\n static member/staticly initialized because that would be dirty in a\n server environment as it is intended.  This means you'll eat the time\n it takes to create it once per request but you will not hold onto it\n if you have none of those requests.\""}, {"count": 6, "tags": [], "text": "(In reply to comment #5)\n> HSSFColor.getIndexHash() method has comment:\n> \"this function returns all colors in a hastable.  Its not implemented as a\n>  static member/staticly initialized because that would be dirty in a\n>  server environment as it is intended.  This means you'll eat the time\n>  it takes to create it once per request but you will not hold onto it\n>  if you have none of those requests.\"\n\nI think we should probably replace this with a lazy initialized static cache on HSSFColor. That way your first call may be a little slow while it's built, but all other calls on the server will then be fast.\n\nMy plan would be to have it return an immutable hash which is statically cached, but also offer a 2nd method that will return a writable hash for anyone currently doing anything odd\n\nI could swap that round with the new method name for the static cache version, and the old method name for the mutable one, if someone can think of a good reason why to do it that way!", "attachment_id": null, "bug_id": 50786, "id": 144673, "time": "2011-03-02T10:00:21Z", "creator": "apache@gagravarr.org", "creation_time": "2011-03-02T10:00:21Z", "is_private": false}, {"count": 7, "tags": [], "creator": "andrei.astrouski@gmail.com", "attachment_id": null, "is_private": false, "id": 144678, "time": "2011-03-02T10:41:20Z", "bug_id": 50786, "creation_time": "2011-03-02T10:41:20Z", "text": "Thanks, it's a good idea"}, {"count": 8, "tags": [], "bug_id": 50786, "attachment_id": null, "id": 144729, "time": "2011-03-04T07:54:54Z", "creator": "apache@gagravarr.org", "creation_time": "2011-03-04T07:54:54Z", "is_private": false, "text": "Change committed in r1077920.\n\nAlmost everyone seemed to just call getIndexedHash().get(..) so they will get the speedup with no need to change anything\n\nIn the very rare case that you were relying on editing the old hashtable, getModifiableIndexedHash will provide that."}, {"count": 9, "tags": [], "creator": "andrei.astrouski@gmail.com", "attachment_id": null, "is_private": false, "id": 144730, "time": "2011-03-04T08:22:49Z", "bug_id": 50786, "creation_time": "2011-03-04T08:22:49Z", "text": "Excellent!"}]