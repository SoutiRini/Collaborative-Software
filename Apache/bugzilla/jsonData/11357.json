[{"count": 0, "tags": [], "creator": "pic@uniquare.com", "attachment_id": null, "is_private": false, "id": 20515, "time": "2002-08-01T06:56:42Z", "bug_id": 11357, "creation_time": "2002-08-01T06:56:42Z", "text": "The following bug occurs only within the following test environment:\nOS Linux SuSE 7.3 (i386) Kernel version 2.4.10\nJRE 1.3.1 Standard Edition, Classic VM (build 1.3.1, J2RE 1.3.1 IBM build \ncxia32131w-20020410 ORB130)\n\nThe bug (which is located within the JVM but can be solved by changing the \nmethod ASCII85Filter.convertWord()) causes the stated method to calculate \ninvalid valus for c1 - c5, and a number of \"illegal char value \" texts are \nwritten to the screen.\nThe reason is that the IBM JVM has (sometimes!, not always) problems with long \nvalues between [0x7FFF FFFF .. 0xFFFF FFFF]. As a result the line\nbyte c1 = (byte)((word / base85_1) & 0xFF);\nreturns negative values for c1 (word and base85_1 are positive of course).\nAs mentioned, this error does not occur always, even with the same number. It \nalso depends on the position of the number within the byte array passed to \nencode().\n\nTo solve this problem I changed the ASCII85Filter.convertWord() method:\n\n  private static final double dbase85_4 = (double)85;\n  private static final double dbase85_3 = base85_4 * base85_4;\n  private static final double dbase85_2 = base85_3 * base85_4;\n  private static final double dbase85_1 = base85_2 * base85_4;\n\n  private static byte[] convertWord(long word) \n  {\n    byte[] ret = null;\n\n    word = word & 0xffffffffL;\n    if (word < 0)\n      word = -word;\n\n    if (word == 0) \n    {\n      byte[] result = {(byte)ASCII85_ZERO};\n      return result;\n    }\n \n    byte c1 = 0;\n    byte c2 = 0;\n    byte c3 = 0;\n    byte c4 = 0;\n    byte c5 = 0;\n\n// Use a different method to calculate c1-c5 if word is >= 2**31\n    if (word > 0x7fffffffL)\n    {\n      double dword = (double)word;\n      c1 = (byte)(((long)(dword / base85_1)) & 0xFF);\n      double d1 = (double)c1 * dbase85_1;\n      c2 = (byte)(((long)((dword - d1) / base85_2)) & 0xFF);\n      d1 = d1 + ((double)c2 * dbase85_2);\n      c3 = (byte)(((long)((dword - d1) / base85_3)) & 0xFF);\n      d1 = d1 + ((double)c3 * dbase85_3);\n      c4 = (byte)(((long)((dword - d1) / base85_4)) & 0xFF);\n      d1 = d1 + ((double)c4 * dbase85_4);\n      c5 = (byte)(((long)(dword - d1)) & 0xFF);\n    }\n    else\n    {\n      c1 = (byte)((word / base85_1) & 0xFF);\n      long l1 = c1 * base85_1;\n      c2 = (byte)(((word - l1) / base85_2) & 0xFF);\n      l1 = l1 + (c2 * base85_2);\n      c3 = (byte)(((word - l1) / base85_3) & 0xFF);\n      l1 = l1 + (c3 * base85_3);\n      c4 = (byte)(((word - l1) / base85_4) & 0xFF);\n      l1 = l1 + (c4 * base85_4);\n      c5 = (byte)(((word - l1)) & 0xFF);\n    }\n\n    ret = new byte[] {(byte)(c1 + ASCII85_START), (byte)(c2 + ASCII85_START),\n                      (byte)(c3 + ASCII85_START), (byte)(c4 + ASCII85_START),\n                      (byte)(c5 + ASCII85_START)};\n    for (int i = 0; i < ret.length; i++)\n    {\n      if (ret[i] < 33 || ret[i] > 117) \n      {\n        System.out.println(\"illegal char value \" + new Integer(ret[i]));\n      }\n    }\n    return ret;\n  }\n\nSome additional notes:\n* I think this bug also explains the bug report 11277\n* I wonder why this method contains\n    word = word & 0xffffffffL;\n    if (word < 0)\n      word = -word;\nwhich I did not change, however if everything would work as expected you might \nthink that this lines are senseless.\n* For critical numbers (bit 31 is 1) the calculation of c1-c5 is done using \ndouble values instead of long. For smaller numbers the original algorithm is \nused. I removed the duplicate sub-calculations by introducing the d1/l1 \nvariables, maybe this speeds up performance a bit."}, {"count": 1, "attachment_id": null, "creator": "j3322ptm@yahoo.de", "is_private": false, "id": 20570, "time": "2002-08-01T20:46:35Z", "bug_id": 11357, "creation_time": "2002-08-01T20:46:35Z", "tags": [], "text": "I committed a simplified version of the conversion code to the maintenance\nbranch, which will hopefully circumvent the JVM bug.\nAnyway, you should get the JVM bug fixed."}, {"count": 2, "attachment_id": null, "creator": "gadams@apache.org", "text": "batch transition to closed remaining pre-FOP1.0 resolved bugs", "id": 156819, "time": "2012-04-01T13:53:20Z", "bug_id": 11357, "creation_time": "2012-04-01T13:53:20Z", "tags": [], "is_private": false}]