[{"count": 0, "tags": [], "bug_id": 19355, "attachment_id": null, "id": 36181, "time": "2003-04-27T00:49:18Z", "creator": "geoff@apache.org", "creation_time": "2003-04-27T00:49:18Z", "is_private": false, "text": "this bug was first reported to dev@httpd.apache.org\n\nhttp://marc.theaimsgroup.com/?l=apache-httpd-dev&m=105120818606501&w=2\n\nmod_include has an ETag bug when activated using XBitHack Full.  in general, default_handler generates an ETag header for documents it serves.  because embedded SSI tags have the ability to alter the content of a document, mod_include strips outgoing ETag headers from responses it enters.  however, the method by which mod_include strips these headers is insufficient in cases where default_handler decides a 304 is warranted.\n\nconsider the following series of requests when XBitHack is activated for a document in DocumentRoot (uninteresting headers snipped for brevity)\n\nGET /ssi.html HTTP/1.1\n\nHTTP/1.1 200 OK\nLast-Modified: Thu, 24 Apr 2003 16:50:50 GMT\n\n-------------\n\nGET /ssi.html HTTP/1.1\nIf-Modified-Since: Thu, 24 Apr 2003 16:50:50 GMT\n\nHTTP/1.1 304 Not Modified\nLast-Modified: Thu, 24 Apr 2003 16:50:50 GMT\nETag: \"35157-5f-4861ce80\"\n\n\nwhile mod_include removes the ETag header from the first request, default_handler generates an (almost always invalid) ETag on the subsequent 304.\n\nthe below patch seems to be a better way for mod_include to handle ETag generation (or, rather, supression).\n\n\nIndex: modules/filters/mod_include.c\n===================================================================\nRCS file: /home/cvspublic/httpd-2.0/modules/filters/mod_include.c,v\nretrieving revision 1.233\ndiff -u -r1.233 mod_include.c\n--- modules/filters/mod_include.c\t3 Feb 2003 17:53:01 -0000\t1.233\n+++ modules/filters/mod_include.c\t24 Apr 2003 17:46:13 -0000\n@@ -3338,6 +3338,12 @@\n         f->r->no_local_copy = 1;\n     }\n     \n+    /* Don't allow ETag headers to be generated - see RFC2616 - 13.3.4.\n+     * We don't know if we are going to be including a file or executing\n+     * a program - in either case a strong ETag header will likely be invalid.\n+     */\n+    apr_table_setn(f->r->notes, \"no-etag\", 1);\n+\n     return OK;\n }\n \n@@ -3407,14 +3413,13 @@\n      */\n     apr_table_unset(f->r->headers_out, \"Content-Length\");\n \n-    /* Always unset the ETag/Last-Modified fields - see RFC2616 - 13.3.4.\n+    /* Always unset the Last-Modified fields - see RFC2616 - 13.3.4.\n      * We don't know if we are going to be including a file or executing\n      * a program which may change the Last-Modified header or make the \n      * content completely dynamic.  Therefore, we can't support these\n      * headers.\n      * Exception: XBitHack full means we *should* set the Last-Modified field.\n      */\n-    apr_table_unset(f->r->headers_out, \"ETag\");\n \n     /* Assure the platform supports Group protections */\n     if ((*conf->xbithack == xbithack_full)"}, {"count": 1, "tags": [], "bug_id": 19355, "attachment_id": null, "id": 46645, "time": "2003-11-02T22:14:48Z", "creator": "nd@perlig.de", "creation_time": "2003-11-02T22:14:48Z", "is_private": false, "text": "Well, fixed in 2.1 and proposed for backport.\nI've slightly modified your patch and used\n\napr_table_setn(f->r->notes, \"no-etag\", \"\");\n\nbecause the \"1\" pointer is not really portable and may cause bus errors on weird\nsystems.\n\nThanks."}]