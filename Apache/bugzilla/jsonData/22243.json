[{"count": 0, "tags": [], "bug_id": 22243, "text": "Hi,\n\nIn order to be able use the JavaCC 3.0. I have modified code of JavaCC task. I \nhave attached modified code below. \n\n/*\n * The Apache Software License, Version 1.1\n *\n * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * 3. The end-user documentation included with the redistribution, if\n *    any, must include the following acknowlegement:\n *       \"This product includes software developed by the\n *        Apache Software Foundation (http://www.apache.org/).\"\n *    Alternately, this acknowlegement may appear in the software itself,\n *    if and wherever such third-party acknowlegements normally appear.\n *\n * 4. The names \"Ant\" and \"Apache Software\n *    Foundation\" must not be used to endorse or promote products derived\n *    from this software without prior written permission. For written\n *    permission, please contact apache@apache.org.\n *\n * 5. Products derived from this software may not be called \"Apache\"\n *    nor may \"Apache\" appear in their names without prior written\n *    permission of the Apache Group.\n *\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n * ====================================================================\n *\n * This software consists of voluntary contributions made by many\n * individuals on behalf of the Apache Software Foundation.  For more\n * information on the Apache Software Foundation, please see\n * <http://www.apache.org/>.\n */\n\npackage org.apache.tools.ant.taskdefs.optional.javacc;\n\nimport org.apache.tools.ant.BuildException;\nimport org.apache.tools.ant.Project;\nimport org.apache.tools.ant.Task;\nimport org.apache.tools.ant.taskdefs.Execute;\n\nimport org.apache.tools.ant.types.Commandline;\nimport org.apache.tools.ant.types.CommandlineJava;\nimport org.apache.tools.ant.types.Path;\nimport org.apache.tools.ant.util.JavaEnvUtils;\n\nimport java.io.File;\n\nimport java.util.Hashtable;\nimport java.util.Enumeration;\n\n/**\n * JavaCC compiler compiler task.\n *\n * @author thomas.haas@softwired-inc.com\n * @author Michael Saunders <a \nhref=\"mailto:michael@amtec.com\">michael@amtec.com</a>\n * @author Dariusz Tyszka <a href=\"mailto:darek@rodan.pl\">darek@rodan.pl</a>\n */\npublic class JavaCC extends Task {\n\n    // keys to optional attributes\n    private static final String LOOKAHEAD              = \"LOOKAHEAD\";\n    private static final String CHOICE_AMBIGUITY_CHECK \n= \"CHOICE_AMBIGUITY_CHECK\";\n    private static final String OTHER_AMBIGUITY_CHECK  \n= \"OTHER_AMBIGUITY_CHECK\";\n\n    private static final String STATIC                 = \"STATIC\";\n    private static final String DEBUG_PARSER           = \"DEBUG_PARSER\";\n    private static final String DEBUG_LOOKAHEAD        = \"DEBUG_LOOKAHEAD\";\n    private static final String DEBUG_TOKEN_MANAGER    = \"DEBUG_TOKEN_MANAGER\";\n    private static final String OPTIMIZE_TOKEN_MANAGER \n= \"OPTIMIZE_TOKEN_MANAGER\";\n    private static final String ERROR_REPORTING        = \"ERROR_REPORTING\";\n    private static final String JAVA_UNICODE_ESCAPE    = \"JAVA_UNICODE_ESCAPE\";\n    private static final String UNICODE_INPUT          = \"UNICODE_INPUT\";\n    private static final String IGNORE_CASE            = \"IGNORE_CASE\";\n    private static final String COMMON_TOKEN_ACTION    = \"COMMON_TOKEN_ACTION\";\n    private static final String USER_TOKEN_MANAGER     = \"USER_TOKEN_MANAGER\";\n    private static final String USER_CHAR_STREAM       = \"USER_CHAR_STREAM\";\n    private static final String BUILD_PARSER           = \"BUILD_PARSER\";\n    private static final String BUILD_TOKEN_MANAGER    = \"BUILD_TOKEN_MANAGER\";\n    private static final String SANITY_CHECK           = \"SANITY_CHECK\";\n    private static final String FORCE_LA_CHECK         = \"FORCE_LA_CHECK\";\n    private static final String CACHE_TOKENS           = \"CACHE_TOKENS\";\n\n    private final Hashtable optionalAttrs = new Hashtable();\n\n    // required attributes\n    private File outputDirectory = null;\n    private File target          = null;\n    private File javaccHome      = null;\n\n    private CommandlineJava cmdl = new CommandlineJava();\n\n\n    /**\n     * Sets the LOOKAHEAD grammar option.\n     */\n    public void setLookahead(int lookahead) {\n        optionalAttrs.put(LOOKAHEAD, new Integer(lookahead));\n    }\n\n    /**\n     * Sets the CHOICE_AMBIGUITY_CHECK grammar option.\n     */\n    public void setChoiceambiguitycheck(int choiceAmbiguityCheck) {\n        optionalAttrs.put(CHOICE_AMBIGUITY_CHECK, new Integer\n(choiceAmbiguityCheck));\n    }\n\n    /**\n     * Sets the OTHER_AMBIGUITY_CHECK grammar option.\n     */\n    public void setOtherambiguityCheck(int otherAmbiguityCheck) {\n        optionalAttrs.put(OTHER_AMBIGUITY_CHECK, new Integer\n(otherAmbiguityCheck));\n    }\n\n    /**\n     * Sets the STATIC grammar option.\n     */\n    public void setStatic(boolean staticParser) {\n        optionalAttrs.put(STATIC, new Boolean(staticParser));\n    }\n\n    /**\n     * Sets the DEBUG_PARSER grammar option.\n     */\n    public void setDebugparser(boolean debugParser) {\n        optionalAttrs.put(DEBUG_PARSER, new Boolean(debugParser));\n    }\n\n    /**\n     * Sets the DEBUG_LOOKAHEAD grammar option.\n     */\n    public void setDebuglookahead(boolean debugLookahead) {\n        optionalAttrs.put(DEBUG_LOOKAHEAD, new Boolean(debugLookahead));\n    }\n\n    /**\n     * Sets the DEBUG_TOKEN_MANAGER grammar option.\n     */\n    public void setDebugtokenmanager(boolean debugTokenManager) {\n        optionalAttrs.put(DEBUG_TOKEN_MANAGER, new Boolean(debugTokenManager));\n    }\n\n    /**\n     * Sets the OPTIMIZE_TOKEN_MANAGER grammar option.\n     */\n    public void setOptimizetokenmanager(boolean optimizeTokenManager) {\n        optionalAttrs.put(OPTIMIZE_TOKEN_MANAGER, new Boolean\n(optimizeTokenManager));\n    }\n\n    /**\n     * Sets the ERROR_REPORTING grammar option.\n     */\n    public void setErrorreporting(boolean errorReporting) {\n        optionalAttrs.put(ERROR_REPORTING, new Boolean(errorReporting));\n    }\n\n    /**\n     * Sets the JAVA_UNICODE_ESCAPE grammar option.\n     */\n    public void setJavaunicodeescape(boolean javaUnicodeEscape) {\n        optionalAttrs.put(JAVA_UNICODE_ESCAPE, new Boolean(javaUnicodeEscape));\n    }\n\n    /**\n     * Sets the UNICODE_INPUT grammar option.\n     */\n    public void setUnicodeinput(boolean unicodeInput) {\n        optionalAttrs.put(UNICODE_INPUT, new Boolean(unicodeInput));\n    }\n\n    /**\n     * Sets the IGNORE_CASE grammar option.\n     */\n    public void setIgnorecase(boolean ignoreCase) {\n        optionalAttrs.put(IGNORE_CASE, new Boolean(ignoreCase));\n    }\n\n    /**\n     * Sets the COMMON_TOKEN_ACTION grammar option.\n     */\n    public void setCommontokenaction(boolean commonTokenAction) {\n        optionalAttrs.put(COMMON_TOKEN_ACTION, new Boolean(commonTokenAction));\n    }\n\n    /**\n     * Sets the USER_TOKEN_MANAGER grammar option.\n     */\n    public void setUsertokenmanager(boolean userTokenManager) {\n        optionalAttrs.put(USER_TOKEN_MANAGER, new Boolean(userTokenManager));\n    }\n\n    /**\n     * Sets the USER_CHAR_STREAM grammar option.\n     */\n    public void setUsercharstream(boolean userCharStream) {\n        optionalAttrs.put(USER_CHAR_STREAM, new Boolean(userCharStream));\n    }\n\n    /**\n     * Sets the BUILD_PARSER grammar option.\n     */\n    public void setBuildparser(boolean buildParser) {\n        optionalAttrs.put(BUILD_PARSER, new Boolean(buildParser));\n    }\n\n    /**\n     * Sets the BUILD_TOKEN_MANAGER grammar option.\n     */\n    public void setBuildtokenmanager(boolean buildTokenManager) {\n        optionalAttrs.put(BUILD_TOKEN_MANAGER, new Boolean(buildTokenManager));\n    }\n\n    /**\n     * Sets the SANITY_CHECK grammar option.\n     */\n    public void setSanitycheck(boolean sanityCheck) {\n        optionalAttrs.put(SANITY_CHECK, new Boolean(sanityCheck));\n    }\n\n    /**\n     * Sets the FORCE_LA_CHECK grammar option.\n     */\n    public void setForcelacheck(boolean forceLACheck) {\n        optionalAttrs.put(FORCE_LA_CHECK, new Boolean(forceLACheck));\n    }\n\n    /**\n     * Sets the CACHE_TOKENS grammar option.\n     */\n    public void setCachetokens(boolean cacheTokens) {\n        optionalAttrs.put(CACHE_TOKENS, new Boolean(cacheTokens));\n    }\n\n    /**\n     * The directory to write the generated files to.\n     * If not set, the files are written to the directory\n     * containing the grammar file.\n     */\n    public void setOutputdirectory(File outputDirectory) {\n        this.outputDirectory = outputDirectory;\n    }\n\n    /**\n     * The grammar file to process.\n     */\n    public void setTarget(File target) {\n        this.target = target;\n    }\n\n    /**\n     * The directory containing the JavaCC distribution.\n     */\n    public void setJavacchome(File javaccHome) {\n        this.javaccHome = javaccHome;\n    }\n\n    public JavaCC() {\n        cmdl.setVm(JavaEnvUtils.getJreExecutable(\"java\"));\n        \n        // Added by DT\n        try {\n            Class.forName(\"COM.sun.labs.javacc.Main\");\n            cmdl.setClassname(\"COM.sun.labs.javacc.Main\");\n        } catch (ClassNotFoundException e) {\n            cmdl.setClassname(\"org.netbeans.javacc.parser.Main\");\n        } catch (Exception e) {\n            e.printStackTrace();   \n        }   \n    }\n\n    public void execute() throws BuildException {\n\n        // load command line with optional attributes\n        Enumeration iter = optionalAttrs.keys();\n        while (iter.hasMoreElements()) {\n            String name  = (String) iter.nextElement();\n            Object value = optionalAttrs.get(name);\n            cmdl.createArgument().setValue(\"-\" + name + \":\" + value.toString());\n        }\n\n        // check the target is a file\n        if (target == null || !target.isFile()) {\n            throw new BuildException(\"Invalid target: \" + target);\n        }\n\n        // use the directory containing the target as the output directory\n        if (outputDirectory == null) {\n            outputDirectory = new File(target.getParent());\n        } else if (!outputDirectory.isDirectory()) {\n            throw new BuildException(\"Outputdir not a directory.\");\n        }\n        cmdl.createArgument().setValue(\"-OUTPUT_DIRECTORY:\"\n            + outputDirectory.getAbsolutePath());\n\n        // determine if the generated java file is up-to-date\n        final File javaFile = getOutputJavaFile(outputDirectory, target);\n        if (javaFile.exists() && target.lastModified() < javaFile.lastModified\n()) {\n            log(\"Target is already built - skipping (\" + target + \")\", \nProject.MSG_VERBOSE);\n            return;\n        }\n        cmdl.createArgument().setValue(target.getAbsolutePath());\n\n        final Path classpath = cmdl.createClasspath(project);\n        final File javaccJar = JavaCC.getArchiveFile(javaccHome);\n        classpath.createPathElement().setPath(javaccJar.getAbsolutePath());\n        classpath.addJavaRuntime();\n\n        final Commandline.Argument arg = cmdl.createVmArgument();\n        arg.setValue(\"-mx140M\");\n        arg.setValue(\"-Dinstall.root=\" + javaccHome.getAbsolutePath());\n\n        Execute.runCommand(this, cmdl.getCommandline());\n    }\n\n    /**\n     * Helper class to retrieve the path used to store the JavaCC.zip which is\n     * different from versions.\n     * @param home the javacc home path directory.\n     * @throws BuildException thrown if the home directory is invalid or if the \narchive\n     * could not be found despite attemps to do so.\n     * @return the file object pointing to the JavaCC archive.\n     */\n    protected static File getArchiveFile(File home) throws BuildException {\n        if (home == null || !home.isDirectory()) {\n            throw new BuildException(\"JavaCC home must be a valid directory.\");\n        }\n        // javacc prior to 2.0\n        File f = new File(home, \"JavaCC.zip\");\n        if (f.exists()){\n          return f;\n        }\n        // javacc install 2.0+\n        f = new File(home, \"bin/lib/JavaCC.zip\");\n        if (f.exists()){\n          return f;\n        }\n        // Added by DT\n        // javacc install 3.0+\n        f = new File(home, \"bin/lib/javacc.jar\");\n        if (f.exists()){\n          return f;\n        }\n        throw new BuildException(\"Could not find a path to JavaCC.zip or \njavacc.jar from '\" + home + \"'.\");\n    }\n\n    /**\n     * Determines the output Java file to be generated by the given grammar\n     * file.\n     * \n     */\n    private File getOutputJavaFile(File outputdir, File srcfile) {\n        String path = srcfile.getPath();\n\n        // Extract file's base-name\n        int startBasename = path.lastIndexOf(File.separator);\n        if (startBasename != -1) {\n            path = path.substring(startBasename + 1);\n        }\n\n        // Replace the file's extension with '.java'\n        int startExtn = path.lastIndexOf('.');\n        if (startExtn != -1) {\n            path = path.substring(0, startExtn) + \".java\";\n        } else {\n            path += \".java\";\n        }\n\n        // Change the directory\n        if (outputdir != null) {\n            path = outputdir + File.separator + path;\n        }\n\n        return new File(path);\n    }\n}", "id": 42387, "time": "2003-08-08T09:27:41Z", "creator": "darek@rodan.pl", "creation_time": "2003-08-08T09:27:41Z", "is_private": false, "attachment_id": null}, {"attachment_id": null, "tags": [], "creator": "bodewig@apache.org", "is_private": false, "count": 1, "id": 42745, "time": "2003-08-14T15:22:07Z", "bug_id": 22243, "creation_time": "2003-08-14T15:22:07Z", "text": "Ant's CVS even supports JavaCC 3.1 since about five weeks.\n\n*** This bug has been marked as a duplicate of 18664 ***"}]