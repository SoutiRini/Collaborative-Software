[{"count": 0, "tags": [], "creator": "oran.fry@ocf.co.nz", "is_private": false, "id": 119672, "attachment_id": 22426, "bug_id": 45612, "creation_time": "2008-08-11T02:03:17Z", "time": "2008-08-11T02:03:17Z", "text": "Created attachment 22426\nsvn diff with http://svn.apache.org/repos/asf/ant/core/trunk @ 684142\n\nSubproject Addressing and Simulation Mode are features I have added to Ant to help in my own work. They are well tested, and they don't affect ant unless they are turned on explicitly (explained below). I would love to see this patch applied to the trunk, and for these features to make it into the next release.\n\nSubproject Addressing (turned on with the -addressing flag):\nAs you know, each time <ant> or <antcall> is executed, a new Project object is created and executed as a subproject. Subproject Addressing gives each of these subprojects an address. The first subproject gets the address 1, the second gets the address 2 and so on. If subproject 1 has subprojects of its own, they are given the addresses 1.1, 1.2 and so on. These addresses are printed in front of target names as the project runs, and output is indented according to the depth of the subproject in the target tree.\n\nThese addresses can be used to select which subprojects to run in a build. Subproject Addressing adds four new options to ant: -addressing (mentioned above), -from, -to and -descend. The -from option can be used to specify a subproject to start execution from, -to to specify a subproject to execute up to and then stop, and -descend to specify a single subproject to execute (including any subprojects of its own).\n\nFor ease of use, the -from, -to and -descend options turn Subproject Addressing on automatically. The keywords \"root\" and \"infinity\" are also valid addresses, with root specifying the main project and infinity specifying a first-level subproject of the main project with an infinitly high address. So you can run things like 'ant -from 2 -to infinity'. The specified subprojects need not actually exist; in a project with four subprojects, 'ant -to 100' would just execute the four subprojects and exit.\n\nSimulation Mode (turned on with the -sim flag):\nSimulates a build. Just prints out the names of the targets that would be executed in a real build, but without actually doing anything. This was implemented by simply modifying the Task class to do nothing unless the task name is either \"import\", \"antcall\" or \"ant\" as these tasks are responsible for the flow of execution, while other tasks are responsible for doing the actual \"work\". Note: though the \"ant\" task is executed in Simulation Mode, the subproject will not actually be loaded or executed, as the specified ant file (or files it imports) may not exist yet - earlier parts of the build may be responsible for creating these files.\n\n\nThese two features go well together. You can do ant -addressing -sim to get a visual tree of projects (actually, if each subproject has just one target, you can think of it as a tree of targets). Then, you can select addresses from that visual tree to specify in the -from, -to or -descend argument.\n\nDemonstration:\n\nUsing this build.xml:\n<project name=\"TestProject\" default=\"main\">\n\n\t<target name=\"main\">\n\t\t<echo>code in main</echo>\n\t\t<antcall target=\"targetA\"/>\n\t\t<antcall target=\"targetB\"/>\n\t\t<antcall target=\"targetC\"/>\n\t\t<antcall target=\"targetD\"/>\n\t\t<echo>code in main</echo>\n\t</target>\n\n\t<target name=\"targetA\">\n\t\t<echo>code in a</echo>\n\t</target>\n\n\t<target name=\"targetB\">\n\t\t<echo>code in b</echo>\n\t\t<antcall target=\"targetBsub\"/>\n\t\t<antcall target=\"targetBsub2\"/>\n\t\t<echo>code in b</echo>\n\t</target>\n\n\t<target name=\"targetC\">\n\t\t<echo>code in c</echo>\n\t\t<ant antfile=\"build2.xml\" target=\"externalTarget1\"/>\n\t\t<ant antfile=\"build2.xml\" target=\"externalTarget2\"/>\n\t\t<ant antfile=\"build2.xml\">\n\t\t\t<target name=\"externalTarget1\"/>\n\t\t\t<target name=\"externalTarget2\"/>\n\t\t</ant>\n\t</target>\n\n\t<target name=\"targetD\" depends=\"targetDdepend\">\n\t\t<echo>code in d</echo>\n\t</target>\n\n\t<target name=\"targetBsub\">\n\t\t<echo>code in b sub</echo>\n\t\t<antcall target=\"targetBsubsub\"/>\n\t\t<echo>code in b sub</echo>\n\t</target>\n\n\t<target name=\"targetBsub2\">\n\t\t<echo>code in b sub2</echo>\n\t</target>\n\n\t<target name=\"targetBsubsub\">\n\t\t<echo>code in b sub sub</echo>\n\t</target>\n\n\t<target name=\"targetDdepend\">\n\t\t<echo>code in d depend</echo>\n\t</target>\n\n</project>\n\n\n(blank lines omitted from output)\n\nRun the build with no options (everything runs as normal):\n$ ant\n\nmain:\n\t [echo] code in main\ntargetA:\n\t [echo] code in a\ntargetB:\n\t [echo] code in b\ntargetBsub:\n\t [echo] code in b sub\ntargetBsubsub:\n\t [echo] code in b sub sub\n\t [echo] code in b sub\ntargetBsub2:\n\t [echo] code in b sub2\n\t [echo] code in b\ntargetC:\n\t [echo] code in c\nexternalTarget1:\n\t [echo] code in an external target 1\nexternalTarget2:\n\t [echo] code in an external target 2\nexternalTarget1:\n\t [echo] code in an external target 1\nexternalTarget2:\n\t [echo] code in an external target 2\ntargetDdepend:\n\t [echo] code in d depend\ntargetD:\n\t [echo] code in d\n\t [echo] code in main\n\nSimulate build:\n$ ant -sim\nmain:\ntargetA:\ntargetB:\ntargetBsub:\ntargetBsubsub:\ntargetBsub2:\ntargetC:\nexternalTarget1 in build2.xml\nexternalTarget2 in build2.xml\nexternalTarget1,externalTarget2 in build2.xml\ntargetDdepend:\ntargetD:\n\n\nSimulate build, with addressing:\n$ ant -sim -addressing\nmain:\n|   \n|   1 targetA:\n|   \n|   2 targetB:\n|   |   \n|   |   2.1 targetBsub:\n|   |   |   \n|   |   |   2.1.1 targetBsubsub:\n|   |   \n|   |   2.2 targetBsub2:\n|   \n|   3 targetC:\n|   |   \n|   |   3.1 -> externalTarget1 in build2.xml\n|   |   \n|   |   3.2 -> externalTarget2 in build2.xml\n|   |   \n|   |   3.3 -> externalTarget1,externalTarget2 in build2.xml\n|   \n|   4 targetDdepend:\n|   \n|   4 targetD:\n\nNote that targetDdepend and targetD get the same address. This is because they are part of the same subproject. This is how it should be, because we always need to be sure that dependencies have been run before the targets that depend on them; addressing does not allow the user to get out of running target dependencies.\n\n\nRun the build with addressing\n$ ant -addressing\nmain:\n|\t[echo] code in main\n|   \n|   1 targetA:\n|   |\t\t[echo] code in a\n|   \n|   2 targetB:\n|   |\t\t[echo] code in b\n|   |   \n|   |   2.1 targetBsub:\n|   |   |\t\t[echo] code in b sub\n|   |   |   \n|   |   |   2.1.1 targetBsubsub:\n|   |   |   |\t\t[echo] code in b sub sub\n|   |   |\t[echo] code in b sub\n|   |   \n|   |   2.2 targetBsub2:\n|   |   |\t\t[echo] code in b sub2\n|   |\t\t[echo] code in b\n|   \n|   3 targetC:\n|   |\t\t[echo] code in c\n|   |   \n|   |   3.1 externalTarget1:\n|   |   |\t\t[echo] code in an external target 1\n|   |   \n|   |   3.2 externalTarget2:\n|   |   |\t\t[echo] code in an external target 2\n|   |   \n|   |   3.3 externalTarget1:\n|   |   |\t\t[echo] code in an external target 1\n|   |   \n|   |   3.3 externalTarget2:\n|   |   |\t\t[echo] code in an external target 2\n|   \n|   4 targetDdepend:\n|   |\t\t[echo] code in d depend\n|   \n|   4 targetD:\n|   |\t\t[echo] code in d\n|\t\t[echo] code in main\n\nNote that when an ant task has multiple nested target elements (in the case of 3.3) they are loaded into the same subproject so they get the same address. \n\n\nSimulate, starting from subproject 3 (note inclusive nature of -from):\n$ ant -from 3 -sim\nmain:\n|   \n|   3 targetC:\n|   |   \n|   |   3.1 -> externalTarget1 in build2.xml\n|   |   \n|   |   3.2 -> externalTarget2 in build2.xml\n|   |   \n|   |   3.3 -> externalTarget1,externalTarget2 in build2.xml\n|   \n|   4 targetDdepend:\n|   \n|   4 targetD:\n\nSimulate, executing up to subproject 3 (note exclusive nature of -to):\n$ ant -to 3 -sim\nmain:\n|   \n|   1 targetA:\n|   \n|   2 targetB:\n|   |   \n|   |   2.1 targetBsub:\n|   |   |   \n|   |   |   2.1.1 targetBsubsub:\n|   |   \n|   |   2.2 targetBsub2\n\nSimulate descending target 2:\n$ ant -descend 2 -sim\nmain:\n|   \n|   2 targetB:\n|   |   \n|   |   2.1 targetBsub:\n|   |   |   \n|   |   |   2.1.1 targetBsubsub:\n|   |   \n|   |   2.2 targetBsub2:\n\nNote that when starting from a subproject deep in the tree using -from or -descend, ancestors projects [and their code] are also executed - be careful:\n\n$ ant -descend 2.1\nmain:\n|\t\t[echo] code in main\n|   \n|   2 targetB:\n|   |\t\t[echo] code in b\n|   |   \n|   |   2.1 targetBsub:\n|   |   |\t\t[echo] code in b sub\n|   |   |   \n|   |   |   2.1.1 targetBsubsub:\n|   |   |   |\t\t[echo] code in b sub sub\n|   |   |\t\t[echo] code in b sub\n|   |\t\t[echo] code in b\n|\t\t[echo] code in main\n\nSpecifying more than one target on the command line:\n(for demonstration, I just specify main twice)\n\n$ ant -sim -addressing main main\nBuildfile: /media/disk/oran/sandbox/test-project/build.xml\nmain:\n|   \n|   1 targetA:\n|   \n|   2 targetB:\n|   |   \n|   |   2.1 targetBsub:\n|   |   |   \n|   |   |   2.1.1 targetBsubsub:\n|   |   \n|   |   2.2 targetBsub2:\n|   \n|   3 targetC:\n|   |   \n|   |   3.1 -> externalTarget1 in build2.xml\n|   |   \n|   |   3.2 -> externalTarget2 in build2.xml\n|   |   \n|   |   3.3 -> externalTarget1,externalTarget2 in build2.xml\n|   \n|   4 targetDdepend:\n|   \n|   4 targetD:\nmain:\n|   \n|   5 targetA:\n|   \n|   6 targetB:\n|   |   \n|   |   6.1 targetBsub:\n|   |   |   \n|   |   |   6.1.1 targetBsubsub:\n|   |   \n|   |   6.2 targetBsub2:\n|   \n|   7 targetC:\n|   |   \n|   |   7.1 -> externalTarget1 in build2.xml\n|   |   \n|   |   7.2 -> externalTarget2 in build2.xml\n|   |   \n|   |   7.3 -> externalTarget1,externalTarget2 in build2.xml\n|   \n|   8 targetDdepend:\n|   \n|   8 targetD:\n\n\nKeyword addresses are good for being explicit, but are rarely needed:\n'ant -addressing' is the same as 'ant -descend root -from 0 -to infinity'\n'ant -from 2' is the same as 'ant -from 2 -descend root -to infinity'\n'ant -to root' does nothing\n'ant -from infinity' does nothing\n'ant -descend infinity' does nothing\n\nMy first patch! Any questions, please mail me. Thank you to apache and everyone working on ant for a great tool."}, {"count": 1, "tags": [], "bug_id": 45612, "text": "just stumbled over this report - if you assign a bug to yourself the other developers won't see the notifications and thus potentially never notice the report.  don't do this ;-)\n\nI've seen you mail to the dev list and started reading it but repeatedly gave up because I failed to understand the rationale immediately (and ran out of time for deeper thoughts).  It's on my TODO list, though.", "id": 119888, "time": "2008-08-18T08:03:55Z", "creator": "bodewig@apache.org", "creation_time": "2008-08-18T08:03:55Z", "is_private": false, "attachment_id": null}, {"count": 2, "tags": [], "creator": "mbenson@apache.org", "is_private": false, "id": 119891, "attachment_id": null, "bug_id": 45612, "creation_time": "2008-08-18T08:30:00Z", "time": "2008-08-18T08:30:00Z", "text": "For my own POV, I looked at this when it first came through but forgot to comment.  I'm not sure I feel this feature is compatible at a theoretical level with Ant's target concept.  I would think it would be possible to implement this behavior independently with a custom target Executor, and would be in favor of any changes needed to permit the functioning of such a third-party implementation."}, {"count": 3, "tags": [], "creator": "oran.fry@ocf.co.nz", "is_private": false, "id": 119902, "attachment_id": null, "bug_id": 45612, "creation_time": "2008-08-18T19:05:58Z", "time": "2008-08-18T19:05:58Z", "text": "(In reply to comment #1)\n>I've seen you mail to the dev list\n(In reply to comment #2)\n>I'm not sure this feature is compatible ... with Ant's target concept\n\nPlease do not go by the email I sent to the dev list - I have cleaned up a lot of the details since then. In the email I referred to the feature as \"target addressing\", but I have since I realized that \"project addressing\" is more appropriate, and more compatible with Ant concepts (and code).\n\n(In reply to comment #1)\n>I failed to understand the rationale immediately (and ran out of\n>time for deeper thoughts)\n\nFair enough! It started as a way to resume a failed build. The first time I saw a chance to extend Ant was when I started working with Greenstone3. The build is done with Ant, with lots of use of antcall and it's a very long process. If the build failed partway through (say, because some environment variable was set incorrectly), you could fix the problem and rerun the target where the build failed, which was great. But the problem was, it would not then carry on with the rest of the build - all you could do was to start the build from the beginning again. There was inevitably some bandwidth, cpu, and time wastage rerunning the same targets again, despite Ant's ability to avoid repeat operations. The solution was to implement a system where you always specify the same high level target on the command line (an \"entry point\" target, something like \"build-greenstone3\"), but with the option of telling Ant to resume the build from the given subproject (i.e., antcall). Addressing was a natural way to tell Ant which subproject to resume from (the -from option), and once that was implemented it was worth it to add the complimentary -to and -descend options.\n"}, {"count": 4, "tags": [], "bug_id": 45612, "text": "Well first, maybe it's the heavy use of <antcall> that's the performance problem! (had to put that one in ;-)\n\nOK, the use case you describe makes sense, although I'm not sure your approach is a pragmatic one. From my experience with large, multi-sub-project builds, restarting the build does indeed take a little time, but a well design build that does nothing when nothing needs doing quickly gets up to the end. My largest build ever with close to 100 different sub-builds of native C/C++/Fortran code took 30sec to recurse in every lib and exe and jar when everything was up-to-date. So the complex feature you are suggesting wouldn't buy you much, since once the build is designed, it rarely fails in the middle for nothing.\n\nAdd validation targets to your subbuilds, and recurse on those in a first pass to find all potential issue quickly, then do the build per se on a second pass.\n\nTo come back to your idea, you describe a \"resumable\" mode for Ant. The way I see it, the user would explicitly request Ant be in the \"resumable\" mode, and if something fails, you'd do \"ant -resume\" to restart it from the failure point. But that would imply tracking which targets ran so far, which one failed, both in which nested builds, etc... Plus what the properties where, and worse, what the reference datatypes were, which implies serializing the latter. So it's very difficult to code up. Specifying from which target to resume explicitly would be very brittle for the same property/reference issue.\n\nThere's simply not enough bang for the buck here IMHO. --DD", "id": 119914, "time": "2008-08-19T06:51:51Z", "creator": "ddevienne@gmail.com", "creation_time": "2008-08-19T06:51:51Z", "is_private": false, "attachment_id": null}, {"count": 5, "tags": [], "bug_id": 45612, "text": "The basic idea of the Addressing feature is that it allows a user to see the project tree, and make use of its structure. It is an general tool which could have many uses, and users may find new ways to use it that even I haven't thought of. It's not just about resuming a build; that is only one way it can help.\n\nHere are some of the uses I have put addressing to:\n* Viewing the structure of an unfamiliar project (e.g., one downloaded from the internet)\n* Resuming a failed build that is not well designed to avoid repeat operations\n* Resuming even well designed builds which inevitably take time to skip over operations which are already done (especially when the checks involve checking files on the internet)\n* Stepping through a build, to examine the state of files etc. as the build progresses\n* Executing the first part of a build in preparation to execute the second part later (E.g., If I'm waiting for the files needed for the second part)\n* Skipping over an unstable or problematic part of a build without having to modify the build file. (e.g., If an build is failing at a particular target but you are able to perform that operation manually.)\n* Expressing the relationship between targets. Addressing lets the user see which targets are being called as dependencies and which are being called as subprojects. If \"do-b\" and \"do-c\" are subprojects of \"do-a\", this expresses that \"b\" and \"c\" they are *part of* the process \"a\". If \"do-b\" and \"do-c\" are dependencies of \"do-a\", this expresses that \"b\" and \"c\" are things which must be done *before* process \"a\". For a user, seeing these relationships makes a build easier to understand.\n* Avoiding repeat execution of \"init\" targets. Rather than making every target depend on \"init\", I just make the entry point target(s) depend on \"init\". Since the build is always entered from the entry point target, the init target will always be executed when the build is invoked. And it will only ever be executed once, unlike in some projects where it is executed multiple times as a result of the absence of backwards propagation in ant. It also saves you putting 'depends=\"init\"' on every target.\n* Checking for links in an antfile to other antfiles (i.e., use of the <ant> task. Done by using ant -sim -addressing.)\n* Addressing works for any ant file, whether the developers are aware of addressing or not. But if the developers are aware of addressing, they can design their builds to make special use of it and so get the most out of it.\n\nI have found the addressing option (in conjunction with the sim option) a pleasure to use as I have developed and used the nightly release snapshot system for Greenstone. It is actually very simple as far as the code changes are concerned - I have added just two if blocks to check whether a call to a task should proceed in light of the addressing and sim options specified on the command line, and the rest is just the code to pass those options around, some display stuff, and a class to represent an address. It has many uses, and I have had good feedback about it. So I think there is a lot of bang for your buck!", "id": 120426, "time": "2008-09-07T17:05:58Z", "creator": "oran.fry@ocf.co.nz", "creation_time": "2008-09-07T17:05:58Z", "is_private": false, "attachment_id": null}]