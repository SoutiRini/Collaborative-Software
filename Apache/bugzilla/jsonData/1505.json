[{"count": 0, "tags": [], "bug_id": 1505, "attachment_id": null, "id": 2086, "time": "2001-04-25T08:46:34Z", "creator": "aarong@cs.cmu.edu", "creation_time": "2001-04-25T08:46:34Z", "is_private": false, "text": "The call to wait in AsyncAppender.append() is surrounded by an if-statement to\ncheck the guard condition (bf.isFull()).  The wait() should be enclosed inside\nof while(bf.isFull) { ... }.  This is because interrupting the waiting will\ncause append to continue executing as if the condition were satisfied.  In the\ncase that the BufferedFIFO is still full, then the append will silently fail\nbecause the implementaiton of BufferedFIFO.put silently drops the event when\nthe FIFO is full.\n\nAt the end of this description is a program that forces this to happen.  I\nhave been able to consistently cause it to happen on my computer, a dual\nprocessor Pentium II 400Mhz running Windows NT 4.0, using both Log4j 1.0.4 and\n1.1b5.  This problem ought to be platform-independent, though.  \n\nThe following program causes the event lossage to occur for version 1.1b5 (for \n1.0.4 replace event.getMessage() with event.message).  Admittedly, it is\nonly in pathological situations where it can occur, but the fix is simple.\n\n\n\nimport java.lang.*;\nimport java.util.*;\n\nimport org.apache.log4j.*;\nimport org.apache.log4j.performance.*;\nimport org.apache.log4j.spi.*;\n\n/**\n * Program that attempts to cause AsyncAppender to have an event\n * lossed by it being silently dropped BufferedFIFO.put().  This can\n * occur when the FIFO is full and the AsyncAppender.append()\n * operation is interrupted while waiting.  The ultimate cause of \n * the error is the failure to use a while-loop when waiting\n * in AsyncAppender.append().\n *\n * <p>The main program repeated sends messages encoding increasing\n * long integer values.  A second thread repeatedly invokes \n * interrupt on the main thread.  A special Appender implementation\n * is used to check for missed events.  If a received event is not \n * exactly 1 greater than the previous event then an event has been\n * dropped on the floor due to AysncAppender.append being interrupted.\n *\n * @author Aaron Greenhouse\n */\npublic class SkipEvent {\n  /** Set to true when the error is detected. */\n  private static volatile boolean errorFound = false;\n\n  /**\n   * Flag used for busy-waiting so that we don't exit before\n   * the error info is printing.\n   */\n  private static volatile boolean donePrinting = false;\n  \n  public static void main( String[] args )\n  {\n    final Category cat = Category.getInstance( \"test_cat\" );\n    final AsyncAppender aa = new AsyncAppender();\n    final CheckerAppender checker = new CheckerAppender();\n\n    aa.addAppender( checker );\n    cat.addAppender( aa );\n\n    final Thread interrupter =\n      new Thread( new Interrupter( Thread.currentThread() ) );\n    interrupter.start();\n\n    // Repeated send ever increasing events.\n    long message = 1L;\n    while( !errorFound ) {\n      cat.info( Long.toString( message ) );\n      message += 1;\n    }\n\n    // Shutdown\n    try {\n      interrupter.join();\n    } catch( InterruptedException e ) {\n    }\n\n    // Busy wait for the error info to print\n    while( !donePrinting ) {\n      Thread.yield();\n    }\n\n    // Call exit because the thread in AysncAppender is not a\n    // daemon thread.\n    System.exit( 0 );\n  }\n\n\n  /**\n   * Repeatedly interrupt the given thread until the \n   * error has been detected.\n   */\n  private static class Interrupter implements Runnable\n  {\n    private final Thread victim;\n\n    public Interrupter( final Thread v )\n    {\n      victim = v;\n    }\n\n    public void run()\n    {\n      while( !errorFound ) {\n\tvictim.interrupt();\n      }\n    }\n  }\n\n\n\n  /**\n   * Appender that tracks the events it receives, looking for a skipped\n   * event.\n   */\n  private static class CheckerAppender extends AppenderSkeleton {\n    /** The next message we expect to receive. */\n    private long nextMessage = 1L;\n\n    /** Store all the received messages in this list. */\n    private final List messages = new ArrayList();\n\n    public void close()\n    {\n    }\n    \n    public void append( final LoggingEvent event )\n    {\n      // Do nothing if the error has already been found.\n      // This prevents the output from being too yucky.\n      if( errorFound ) return;\n\n      try {\n\t// Save the new event\n\tmessages.add( event.getMessage() );\n\n\t// Extract the long from the event\n\tfinal long newMessage = Long.parseLong( (String)event.getMessage() );\n\n\t// Look for a skipped event\n\tif( newMessage != nextMessage ) {\n\t  // Error found, set the flag to shut things down\n\t  errorFound = true;\n\n\t  // Make a stink about it...\n\t  System.out.println( \"Message Skipped: got \" + newMessage + \n\t\t\t      \", but expecting \" + nextMessage );\n\n\t  for( int i = 0; i < messages.size(); i++ ) {\n\t    System.out.println( \"messages(\" + i + \") = \" + messages.get( i ) );\n\t  }\n\t  System.out.println( \"--- done ---\" );\n\n\t  // Okay, we can exit now\n\t  donePrinting = true;\n\t}\n\t\n\t// Update the next expected message\n\tnextMessage += 1;\n      } catch( final NumberFormatException e ) {\n\tSystem.err.println( \"Couldn't parse message\" );\n\tSystem.exit( 1 );\n      }\n    }\n    \n    public boolean requiresLayout()\n    {\n      return false;\n    }  \n  }\n}"}, {"count": 1, "tags": [], "bug_id": 1505, "text": "Created attachment 127\nProgram that creates the described error (skipped events)", "id": 2095, "time": "2001-04-25T10:46:21Z", "creator": "aarong@cs.cmu.edu", "creation_time": "2001-04-25T10:46:21Z", "is_private": false, "attachment_id": 127}, {"count": 2, "tags": [], "bug_id": 1505, "text": "Aaron,\n\nThe AsyncAppender is not supposed to be interrupted, so why are you trying to \ninterrupt it? With you test program I get plenty of lines of the form:\n\nlog4j:ERROR AsyncAppender cannot be interrupted.\njava.lang.InterruptedException\n        at java.lang.Object.wait(Native Method)\n        at java.lang.Object.wait(Object.java:420)\n        at org.apache.log4j.AsyncAppender.append(AsyncAppender.java:110)\n        at org.apache.log4j.AppenderSkeleton.doAppend(AppenderSkeleton.java:251)\n        at org.apache.log4j.helpers.AppenderAttachableImpl.appendLoopOnAppenders\n(AppenderAttachableImpl.java:57)\n        at org.apache.log4j.Category.callAppenders(Category.java:253)\n        at org.apache.log4j.Category.forcedLog(Category.java:443)\n        at org.apache.log4j.Category.info(Category.java:691)\n        at SkipEvent.main(SkipEvent.java:51)\n\nThe AsyncAppender does not support thread interruption. What's wrong with that?\nWhat am I missing? Thanks, Ceki", "id": 2109, "time": "2001-04-26T01:38:10Z", "creator": "bugzilla@apache.org", "creation_time": "2001-04-26T01:38:10Z", "is_private": false, "attachment_id": null}, {"count": 3, "tags": [], "bug_id": 1505, "text": "\nMy mistake. You are interrupting your own thread. That is your prerogative and \nlog4j should support it. Ceki", "id": 2110, "time": "2001-04-26T01:45:39Z", "creator": "bugzilla@apache.org", "creation_time": "2001-04-26T01:45:39Z", "is_private": false, "attachment_id": null}]