[{"count": 0, "tags": [], "bug_id": 42701, "text": "When loading pages via Http11NioProtocol about 50% of images and other resources\nare randomly replaced with other images/resources from the same page or fail.\nThe problem usually is noticeable only when communicating with non-localhost\nservers.\n\nUpon investigating I found out that NIO protocol reads from request input stream\nuntil it drains the available data, then puts the partially parsed request and\nthe partially read socket into event queues and waits until more data comes.\n\nHowever then it mismatches the request/socket pair and the resulting request is\na mix of headers from several different requests. In fact it doesn't even try to\n keep the mapping - it just grabs any request and any socket and starts parsing.\n\nThis bug is not noticeable on localhost, since there the entire request is\ntypically read at once.\n\nThis bug does not happen for Comet requests that keep their socket-request\nmapping in Http11NioProtocol.Http11ConnectionHandler.connections map.\n\nChanging Http11NioProtocol.Http11ConnectionHandler.process() to the following\nseems to fix the problem (I am keeping the socket-request mapping for regular\nrequests in the same map where Comet requests keep theirs)\n===============================================================\n        public SocketState process(MyNioChannel socket) {\n            MyHttp11NioProcessor processor = connections.get(socket);\n            try {\n                if (processor == null) {\n                    processor = recycledProcessors.poll();\n                }\n                if (processor == null) {\n                    processor = createProcessor();\n                }\n\n                if (processor instanceof ActionHook) {\n                    ((ActionHook) processor).action(ActionCode.ACTION_START, null);\n                }\n\n\n                processor.setSslSupport(null);\n\n\n                SocketState state = processor.process(socket);\n                if (state != SocketState.CLOSED) {\n                    // Associate the connection with the processor. The next request\n                    // processed by this thread will use either a new or a recycled\n                    // processor.\n                    if (log.isDebugEnabled()) log.debug(\"Not recycling\n[\"+processor+\"]\nComet=\"+((NioEndpoint.KeyAttachment)socket.getAttachment(false)).getComet());\n                    connections.put(socket, processor);\n                    socket.getPoller().add(socket);\n                } else {\n                    connections.remove(socket);\n                    recycledProcessors.offer(processor);\n                }\n                return state;\n\n            } catch (java.net.SocketException e) {\n                // SocketExceptions are normal\n               \nlog.debug(sm.getString(\"http11protocol.proto.socketexception.debug\"), e);\n            } catch (java.io.IOException e) {\n                // IOExceptions are normal\n               \nlog.debug(sm.getString(\"http11protocol.proto.ioexception.debug\"), e);\n            }\n            // Future developers: if you discover any other\n            // rare-but-nonfatal exceptions, catch them here, and log as\n            // above.\n            catch (Throwable e) {\n                // any other exception or error is odd. Here we log it\n                // with \"ERROR\" level, so it will show up even on\n                // less-than-verbose logs.\n                log.error(sm.getString(\"http11protocol.proto.error\"), e);\n            }\n            connections.remove(socket);\n            recycledProcessors.offer(processor);\n            return SocketState.CLOSED;\n        }", "id": 104543, "time": "2007-06-20T05:24:19Z", "creator": "andreysubbotin@mail.ru", "creation_time": "2007-06-20T05:24:19Z", "is_private": false, "attachment_id": null}, {"count": 1, "tags": [], "creator": "fhanik@apache.org", "attachment_id": null, "text": "I believe a different fix has been applied to trunk of 6.0.x and 6.x, are you\nable to test that version before we consider this fix.", "id": 104546, "time": "2007-06-20T06:07:32Z", "bug_id": 42701, "creation_time": "2007-06-20T06:07:32Z", "is_private": false}, {"attachment_id": null, "tags": [], "creator": "fhanik@apache.org", "is_private": false, "count": 2, "id": 104548, "time": "2007-06-20T06:11:30Z", "bug_id": 42701, "creation_time": "2007-06-20T06:11:30Z", "text": "here is the 6.0 fix\nhttp://svn.apache.org/viewvc?view=rev&revision=542645\n\nand here is the 6.x fix\nhttp://svn.apache.org/viewvc?view=rev&rev=542666\n\n"}, {"count": 3, "tags": [], "bug_id": 42701, "text": "Yes, I checked and the bug was fixed in the trunk. My apologies for not checking\nthe latest version.", "id": 104562, "time": "2007-06-20T06:57:04Z", "creator": "andreysubbotin@mail.ru", "creation_time": "2007-06-20T06:57:04Z", "is_private": false, "attachment_id": null}, {"count": 4, "tags": [], "text": "no worries, thanks for reporting it.\nThe two fixes are little different:\n6.0.x is blocking read of the request\n6.x is non blocking read of request line and headers\n\nwould you be able to test both?\n\nFilip", "is_private": false, "bug_id": 42701, "id": 104564, "time": "2007-06-20T07:24:28Z", "creator": "fhanik@apache.org", "creation_time": "2007-06-20T07:24:28Z", "attachment_id": null}]