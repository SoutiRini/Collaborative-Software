[{"count": 0, "tags": [], "text": "I've seen a rather odd issue with a spreadsheet that results in the size of the section length being miscalculated.  The following:\n\n/*\n * Read the section length.\n */\nsize = (int) LittleEndian.getUInt(src, o1);\n\nreturns a negative number that causes an OutOfMemory error.  It appears to be a valid Excel document (it opens fine in OpenOffice).  My fix for the timebeing is to throw the following immediately after\n\nif (size < 0) {\n    throw new UnsupportedEncodingException(\"Tried to allocate a section of size \" + size);\n}\n\nThe document appears to parse fine after that.  Please let me know if you need any more info, I might well be able to clean up the data in the original document, but saving in OpenOffice might actually correct the issue.", "is_private": false, "bug_id": 47270, "id": 127419, "time": "2009-05-26T09:51:26Z", "creator": "jonathan.holloway@gmail.com", "creation_time": "2009-05-26T09:51:26Z", "attachment_id": null}, {"count": 1, "attachment_id": null, "creator": "apache@gagravarr.org", "is_private": false, "id": 127420, "time": "2009-05-26T09:55:15Z", "bug_id": 47270, "creation_time": "2009-05-26T09:55:15Z", "tags": [], "text": "I don't think getUInt should ever return a negative number - the U in the method name means unsigned\n\nAny chance you could post the problem document / do some sniffing about?"}, {"count": 2, "tags": [], "bug_id": 47270, "attachment_id": null, "text": "I'm sure this is bad data in the spreadsheet, in org.apache.poi.util.LittleEndian  byte[] data (4096 bytes) is passed in:\n\noffset = 316\nb0 = 0\nb1 = 0\nb2 = 0\nb3 = 228\n\nso (b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0) returns -469762048\n\nSaving in OpenOffice \"fixes\" the document - so I can't cleanse the doc to send it to you, and unfortunately I can't send it for client confidentiality reasons.", "id": 127423, "time": "2009-05-26T10:34:57Z", "creator": "jonathan.holloway@gmail.com", "creation_time": "2009-05-26T10:34:57Z", "is_private": false}, {"count": 3, "tags": [], "text": "I think the negative value results from interpreting an unsigned int as signed int, i.e. the unsigned int has a larger positive range than what int can hold, so very large unsigned ints will lead to negative signed int values when a cast is used. to correctly handle large unsigned ints, you need to use a long datatype.\n\nHowever I assume something with the document is not quite right here as I don't think the section size really holds such large values in your document, or?\n\nHowever for now without a sample document we are not able to investigate here, therefore I am setting this to LATER for now, please reopen this with a sample document and the steps to reproduce the problem, ideally as self-sufficient unit test.", "is_private": false, "id": 183024, "creator": "dominik.stadler@gmx.at", "time": "2015-05-18T21:20:59Z", "bug_id": 47270, "creation_time": "2015-05-18T21:20:59Z", "attachment_id": null}]