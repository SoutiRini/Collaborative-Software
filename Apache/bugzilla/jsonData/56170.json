[{"count": 0, "tags": [], "creator": "dirk.dittert@googlemail.com", "text": "Created attachment 31338\nTemplate file to reproduce the issue\n\nI'm trying to add rows to an Excel 2010 table that has no visible header rows. However, POI-3.10 throws an exception on safe (see below).\n\nGiven:\n======\nan Excel 2010 file that contains a table with no visible header rows\n\nDescription:\n============\nNew rows are added to the table and the table is expanded before safe. POI tries to update the table headers in org.apache.poi.xssf.usermodel.XSSFTable#updateHeaders but fails to take into account that there are no visible table headers. \n\nIf I use the debugger to set the value of row in XSSFTable line 295 to null, the exception can be avoided and POI produces a file that opens in Excel without errors. I guess adding a condition that checks for number of visible header rows should help. \n\nPlease note:\nThis exception does not occur if the table has headers. It also does not occur if there is no other content in the file (thus the x in column C).\n\nDemo program to reproduce (please adjust paths before running):\n===============================================================\npublic class Demo\n{\n\tpublic static void main(String[] args) throws IOException, InvalidFormatException\n\t{\n\t\tfinal Workbook workbook = WorkbookFactory.create(new File(\"Tabelle.xlsx\"));\n\t\tfinal XSSFSheet sheet = (XSSFSheet) workbook.getSheetAt(0);\n\n\t\t// add some contents to table so that the table will need expansion\n\t\tRow row = sheet.getRow(0);\n\t\tCell cell = row.createCell(0);\n\t\tcell.setCellValue(\"demo1\");\n\t\tcell = row.createCell(1);\n\t\tcell.setCellValue(\"demo2\");\n\t\tcell = row.createCell(2);\n\t\tcell.setCellValue(\"demo3\");\n\n\t\trow = sheet.getRow(1);\n\t\tcell = row.createCell(0);\n\t\tcell.setCellValue(\"demo1\");\n\t\tcell = row.createCell(1);\n\t\tcell.setCellValue(\"demo2\");\n\t\tcell = row.createCell(2);\n\t\tcell.setCellValue(\"demo3\");\n\n\t\t// expand table\n\t\tXSSFTable table = sheet.getTables().get(0);\n\t\tfinal CellReference startRef = table.getStartCellReference();\n\t\tfinal CellReference endRef = table.getEndCellReference();\n\t\ttable.getCTTable().setRef(new CellRangeAddress(startRef.getRow(), 1, startRef.getCol(), endRef.getCol()).formatAsString());\n\n\n\t\tFileOutputStream stream = new FileOutputStream(\"e:\\\\output.xlsx\");\n\t\tworkbook.write(stream);\n\t\tstream.close();\n\t}\n\n}\n\nExcpetion:\n==========\nException in thread \"main\" org.apache.xmlbeans.impl.values.XmlValueDisconnectedException\n\tat org.apache.xmlbeans.impl.values.XmlObjectBase.check_orphaned(XmlObjectBase.java:1213)\n\tat org.openxmlformats.schemas.spreadsheetml.x2006.main.impl.CTCellImpl.getF(Unknown Source)\n\tat org.apache.poi.xssf.usermodel.XSSFCell.getCellType(XSSFCell.java:529)\n\tat org.apache.poi.xssf.usermodel.XSSFCell.getRichStringCellValue(XSSFCell.java:264)\n\tat org.apache.poi.xssf.usermodel.XSSFCell.getStringCellValue(XSSFCell.java:251)\n\tat org.apache.poi.xssf.usermodel.XSSFTable.updateHeaders(XSSFTable.java:301)\n\tat org.apache.poi.xssf.usermodel.XSSFTable.writeTo(XSSFTable.java:84)\n\tat org.apache.poi.xssf.usermodel.XSSFTable.commit(XSSFTable.java:95)\n\tat org.apache.poi.POIXMLDocumentPart.onSave(POIXMLDocumentPart.java:322)\n\tat org.apache.poi.POIXMLDocumentPart.onSave(POIXMLDocumentPart.java:326)\n\tat org.apache.poi.POIXMLDocumentPart.onSave(POIXMLDocumentPart.java:326)\n\tat org.apache.poi.POIXMLDocument.write(POIXMLDocument.java:173)\n\tat Demo.main(PoiBug.java:49)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:601)\n\tat com.intellij.rt.execution.application.AppMain.main(AppMain.java:120)", "id": 173394, "time": "2014-02-20T10:39:52Z", "bug_id": 56170, "creation_time": "2014-02-20T10:39:52Z", "is_private": false, "attachment_id": 31338}, {"count": 1, "tags": [], "creator": "yaniv@kundas.net", "text": "I've found the problem in XSSFTable.updateHeaders() while fixing bug #56274, and found that adding row validation solves it, i.e. changing\nif (row != null)\nto\nif (row != null && row.getCTRow().validate())\n\nI've not included a patch, since I'm not sure it's ok to count on validate() to check this - can invalid rows still be appropriate for being a table header row?\nIn addition, validate() might be too heavy - but I didn't find any other way of identifying what's wrong.", "id": 173927, "time": "2014-03-19T09:31:07Z", "bug_id": 56170, "creation_time": "2014-03-19T09:31:07Z", "is_private": false, "attachment_id": null}, {"count": 2, "tags": [], "creator": "dominik.stadler@gmx.at", "text": "The actual point where the Cell contents becomes invalid is here:\n\nCTRowImpl(XmlComplexContentImpl).arraySetterHelper(XmlObject[], QName) line: 1149\t\nCTRowImpl.setCArray(CTCell[]) line: not available\t\nXSSFRow.onDocumentWrite() line: 466\t\nXSSFSheet.write(OutputStream) line: 2761\t\nXSSFSheet.commit() line: 2725\t\nXSSFSheet(POIXMLDocumentPart).onSave(Set<PackagePart>) line: 322\t\nXSSFWorkbook(POIXMLDocumentPart).onSave(Set<PackagePart>) line: 326\t\nXSSFWorkbook(POIXMLDocument).write(OutputStream) line: 173\t\nXSSFTestDataSamples.writeOutAndReadBack(R) line: 68\t\nTestXSSFCell.test56170() line: 299\t\n\nUnfortunatly the XMLBeans framework is very picky about objects being used in more than one place, sometimes setting objects to \"invalid\" if they are removed from some collection, while we are still using it in other places. \n\nYour change basically just checks if the row or any cell inside it became invalid by some prior action, so it is not a full fix, but just does not do anything any more with the cell as soon as it becomes invalid.", "id": 175266, "time": "2014-05-16T09:03:41Z", "bug_id": 56170, "creation_time": "2014-05-16T09:03:41Z", "is_private": false, "attachment_id": null}, {"count": 3, "tags": [], "bug_id": 56170, "is_private": false, "text": "I did some more investigation, this is likely caused at XSSFRow.onDocumentWrite() when we call\n\n   _row.setCArray(cArray);\n\nWe mostly pass in objects which were in this array before, but XMLBeans does not handle this case when the old array is larger than the new one.\n\nThe call gets to XmlComplexContentImpl.arraySetterHelper() where XMLBeans will release any objects that it removes from the previous array and thus objects will be disconnected if they are still referenced there afterwards, despite them still being in the new array that we set!\n\nSo it is mostly caused by how XMLBeans is handling setting these arrays, my first approach in fixing locally in POI is to keep the array of CTCells in XSSFRow._row in sync with _cells, so these cases do not appear at all.", "id": 175271, "time": "2014-05-16T12:02:27Z", "creator": "dominik.stadler@gmx.at", "creation_time": "2014-05-16T12:02:27Z", "attachment_id": null}, {"count": 4, "tags": [], "creator": "dominik.stadler@gmx.at", "text": "I tried to fix this in r1595659, I could not find any other way than to copy the CTCell in this case, which is not nice and may cause a slight increase in save-time.", "id": 175303, "time": "2014-05-18T19:21:27Z", "bug_id": 56170, "creation_time": "2014-05-18T19:21:27Z", "is_private": false, "attachment_id": null}]