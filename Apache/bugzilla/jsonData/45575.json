[{"count": 0, "tags": [], "creator": "domenico.napoletano@exprivia.it", "attachment_id": 22394, "is_private": false, "id": 119476, "time": "2008-08-06T01:32:22Z", "bug_id": 45575, "creation_time": "2008-08-06T01:32:22Z", "text": "Created attachment 22394\nSimple test doc with body, header/footer, annotations, footnotes and endnotes\n\nUsing a small trick (based on text length) it's possibile to get the location of a Range (body? header/footer? footnote? etc.). For example, let's suppose to have 3 character runs:\n1) coded in ASCII, ending at 2000 \n2) coded in Unicode, ending at 4050\n3) coded in ASCII, ending 2100\n4) coded in Unicode, ending at 4200\n5) coded in Unicode, ending at 4500\nand that ccpText field of the document they belong is 2100.\nIf every chacater run was in ASCII (we can know if a character run is Unicode or ASCII, comparing length in characters from text and length in bytes from end-start), the end values would be\n1) 2000\n2) 2025\n3) 2100\n4) 2100\n5) 2250\nand then, comparing *these* end values with ccpText, we can conclude that the character runs are\n1) in body\n2) in body\n3) at end of body\n4) at end of body\n5) out of body, maybe in footnote\nThis same algorithm can be applied to all Range types (paragraph, section, and so on) and to all locations (body, header/footer, footnote, etc.)\n\nTo make it possible, it's necessary to;\n\n1) add to FileInformationBlock class the new lines\n\n    public int getCcpFtn() {\n    \treturn _longHandler.getLong(FIBLongHandler.CCPFTN);\n    }\n    \n    public int getCcpHdd() {\n    \treturn _longHandler.getLong(FIBLongHandler.CCPHDD);\n    }\n    \n    public int getCcpAtn() {\n    \treturn _longHandler.getLong(FIBLongHandler.CCPATN);\n    }\n    \n    public int getCcpEdn() {\n    \treturn _longHandler.getLong(FIBLongHandler.CCPEDN);\n    }\n\nto know limits in characters of footnotes, header/footer, annotations and endnotes respectively\n\n2) create a new enum in \"usermodel\" package to represent locations\npublic enum Location {\n\tBODY,\n\tFOOTNOTE,\n\tHEADER_FOOTER,\n\tANNOTATION,\n\tENDNOTE,\n\tUNKNOWN;\n}\n\nInstead of an enum, also a series of int constants defined in Range may be used.\n\n3) add to Range class the new member variable\n\nprotected Location _location = null;\n\nand the new method\n\npublic Location getLocationType() {\n\t\tif(_location == null)\n\t\t{\n                        //it stores the end in characters\n\t\t\tint x = 0;\n\t\t\t\n\t\t\tint charLen = this.text().length();\n\t\t\tint byteLen = _end - _start;\n\t\t\tif(byteLen == charLen)\n\t\t\t\tx = _end;   //ASCII\n\t\t\telse\n\t\t\t\tx = _end / 2;  //Unicode\n\t\t\t\n\t\t\tFileInformationBlock fib = _doc.getFileInformationBlock();\n\t\t\tif(x <= fib.getCcpText())\n\t\t\t\t_location = Location.BODY;\n\t\t\telse if(x <= fib.getCcpText() + fib.getCcpFtn())\n\t\t\t\t_location = Location.FOOTNOTE;\n\t\t\telse if(x <= fib.getCcpText() + fib.getCcpFtn() + fib.getCcpHdd())\n\t\t\t\t_location = Location.HEADER_FOOTER;\n\t\t\telse if(x <= fib.getCcpText() + fib.getCcpFtn() + fib.getCcpHdd() + fib.getCcpAtn())\n\t\t\t\t_location = Location.ANNOTATION;\n\t\t\telse if(x <= fib.getCcpText() + fib.getCcpFtn() + fib.getCcpHdd() + fib.getCcpAtn() + fib.getCcpEdn())\n\t\t\t\t_location = Location.ENDNOTE;\n\t\t\telse\n\t\t\t\t_location = Location.UNKNOWN;\n\t\t}\n\n\t\treturn _location;\n\t}\n\nThis is a simple test class (perhaps it can be transformed in a JUnit testcase?) to test my code:\n\npublic class QuickTest\n{\n  public QuickTest()\n  {\n  }\n\n  public static void main(String[] args)\n  {\n          try\n          {\n\n        \t  JFileChooser jfc = new JFileChooser();\n\n                int esito = jfc.showOpenDialog(null);\n\n                if(esito != JFileChooser.APPROVE_OPTION)\n                {\n                        JOptionPane.showMessageDialog(null, \"No file selected\");\n                }\n                else\n                {\n                        String percorso = jfc.getSelectedFile().getAbsolutePath();\n\n                        HWPFDocument doc = new HWPFDocument(new FileInputStream(percorso));\n                        Range r = doc.getRange();\n                        for(int i = 0; i < r.numParagraphs(); i++)\n                        {\n                                //Paragraph, CharacterRun, Section... it's equivalent\n                        \tParagraph cr = r.getParagraph(i);\n                        \tSystem.out.println(\"<\" + cr.text().trim() + \"> \" + cr.getLocationType());\n                        }\n                }\n          }\n          catch(Exception er)\n          {\n                  er.printStackTrace();\n          }\n  }\n\n}\n\nwhich, applied to test doc I have attached, produces the output\n\n<BODY\u0002 TEXT FRAGMENT\u0005 1> BODY\n<BODY\u0002 TEXT\u0002 FRAGMENT\u0005 2> BODY\n<> BODY\n<FOOTNOTE TEXT 1> FOOTNOTE\n<FOOTNOTE TEXT 2> FOOTNOTE\n<> FOOTNOTE\n<> HEADER_FOOTER\n<> HEADER_FOOTER\n<> HEADER_FOOTER\n<> HEADER_FOOTER\n<> HEADER_FOOTER\n<> HEADER_FOOTER\n<> HEADER_FOOTER\n<> HEADER_FOOTER\n<HEADER TEXT FRAGMENT 1> HEADER_FOOTER\n<HEADER TEXT FRAGMENT 2> HEADER_FOOTER\n<> HEADER_FOOTER\n<FOOTER TEXT FRAGMENT 1> HEADER_FOOTER\n<FOOTER TEXT FRAGMENT 2> HEADER_FOOTER\n<> HEADER_FOOTER\n<> HEADER_FOOTER\n<ANNOTATION 1> ANNOTATION\n<ANNOTATION 2> ANNOTATION\n<> ANNOTATION\n<ENDNOTE TEXT> ENDNOTE\n<> ENDNOTE\n<> UNKNOWN"}, {"count": 1, "attachment_id": null, "creator": "apache@gagravarr.org", "is_private": false, "id": 119678, "time": "2008-08-11T04:41:11Z", "bug_id": 45575, "creation_time": "2008-08-11T04:41:11Z", "tags": [], "text": "Something similar to this is now in svn\n\ngetRange() now only returns the main body, but getOverallRange() gives you the lot. There are also a few other Range getters, for the other things like header+footer\n\nThe unicode stuff has also been made a bit nicer, so the range detection stuff is much simpler now too :)"}, {"count": 2, "tags": [], "text": "(In reply to comment #1)\n> Something similar to this is now in svn\n> \n> getRange() now only returns the main body, but getOverallRange() gives you the\n> lot. There are also a few other Range getters, for the other things like\n> header+footer\n> \n> The unicode stuff has also been made a bit nicer, so the range detection stuff\n> is much simpler now too :)\n> \n\nI have poi-3.1-final but I dont see any getOverallRange nor any Range getters. ", "attachment_id": null, "bug_id": 45575, "id": 121113, "time": "2008-10-01T03:49:48Z", "creator": "wnadela@hotmail.com", "creation_time": "2008-10-01T03:49:48Z", "is_private": false}]