[{"count": 0, "tags": [], "bug_id": 8882, "text": "The stock mod_rewrite interface with an external rewrite engine via stdin/stdout\nrequires a lockfile to prevent multiple child processes screwing up each other's\nrewriting.  This essentially means that all rewrite processes are serialised,\nand can result in a serious queuing of requests if the rewrite program\nencounters any delay.\n\nThe following patch will enable mod_rewrite to communicate with the external\nrewrite engine over TCP/IP sockets, meaning that a multi-threaded (or\nmulti-process, you choose) rewrite engine can deal with several rewrite requests\nat once, without the need to serialise the requests.  I'm not suggesting for one\nminute that it's perfect, or even close, but it's a means to an end and it\nactually works.\n\nThere's a slight change to the RewriteMap directive:\n\nRewriteMap name \"prg:/path/to/prog args\" port\n\nWhere port is the port to send rewrite requests to.  I'm sure this could be done\nmore elegantly by having an extra RewriteMap type, but tying it into the prg:\ntype does have the advantage of ensuring that the process is up and running at\nthe same time Apache is.\n\n--- src/modules/standard/mod_rewrite.c  Tue May  7 16:34:43 2002\n+++ /home/jtait/src/apache_1.3.24/src/modules/standard/mod_rewrite.c    Tue May\n 7 16:14:34 2002\n@@ -168,7 +168,7 @@\n       \"an input string and a to be applied regexp-pattern\" },\n     { \"RewriteRule\",     cmd_rewriterule,     NULL, OR_FILEINFO, RAW_ARGS,\n       \"an URL-applied regexp-pattern and a substitution URL\" },\n-    { \"RewriteMap\",      cmd_rewritemap,      NULL, RSRC_CONF,   TAKE2,\n+    { \"RewriteMap\",      cmd_rewritemap,      NULL, RSRC_CONF,   TAKE23,\n       \"a mapname and a filename\" },\n     { \"RewriteLock\",     cmd_rewritelock,     NULL, RSRC_CONF,   TAKE1,\n       \"the filename of a lockfile used for inter-process synchronization\"},\n@@ -448,7 +448,7 @@\n }\n\n static const char *cmd_rewritemap(cmd_parms *cmd, void *dconf, char *a1,\n-                                  char *a2)\n+                                  char *a2, char *a3)\n {\n     rewrite_server_conf *sconf;\n     rewritemap_entry *new;\n@@ -485,6 +485,12 @@\n         new->type = MAPTYPE_PRG;\n         new->datafile = a2+4;\n         new->checkfile = a2+4;\n+        if (a3 == NULL) {\n+            new->port = 0;\n+        }\n+       else {\n+            new->port = atoi(a3);\n+        }\n     }\n     else if (strncmp(a2, \"int:\", 4) == 0) {\n         new->type      = MAPTYPE_INT;\n@@ -2753,7 +2759,7 @@\n             }\n             else if (s->type == MAPTYPE_PRG) {\n                 if ((value =\n-                     lookup_map_program(r, s->fpin, s->fpout, key)) != NULL) {\n+                     lookup_map_program(r, s->fpin, s->fpout, key, s->port)) !=\nNULL) {\n                     rewritelog(r, 5, \"map lookup OK: map=%s key=%s -> val=%s\",\n                                s->name, key, value);\n                     return value;\n@@ -2891,11 +2897,12 @@\n }\n #endif\n\n-static char *lookup_map_program(request_rec *r, int fpin, int fpout, char *key)\n+static char *lookup_map_program(request_rec *r, int fpin, int fpout, char *key,\nunsigned short port)\n {\n     char buf[LONG_STRING_LEN];\n     char c;\n     int i;\n+    int sock;\n #ifndef NO_WRITEV\n     struct iovec iov[2];\n #endif\n@@ -2909,33 +2916,71 @@\n         return NULL;\n     }\n\n-    /* take the lock */\n-    rewritelock_alloc(r);\n+    if (port != 0) {\n+        /* create a socket connection to the external program */\n+        sock = make_socket_connection(r, port);\n+        if (sock == -1) {\n+            return NULL;\n+        }\n+\n+        ap_hard_timeout(\"Send external rewrite request\", r);\n+        /* write out the request key */\n+        i = send(sock, key, strlen(key), 0);\n+        if (i != strlen(key)) {\n+            ap_kill_timeout(r);\n+            return NULL;\n+        }\n+        ap_reset_timeout(r);\n+\n+        i = send(sock, \"\\n\", 1, 0);\n+        if (i != 1) {\n+            ap_kill_timeout(r);\n+            return NULL;\n+        }\n+        ap_kill_timeout(r);\n+\n+        /* read in the response value */\n+        ap_hard_timeout(\"Receive external rewrite response\", r);\n+        i = 0;\n+        while (recv(sock, &c, 1, 0) == 1 && (i < LONG_STRING_LEN -1)) {\n+            if (c == '\\n') {\n+                break;\n+            }\n+            buf[i++] = c;\n+        }\n+        buf[i] = '\\0';\n+        ap_pclosesocket(r->pool, sock);\n+        ap_kill_timeout(r);\n+    }\n+    else {\n+        /* take the lock */\n+        rewritelock_alloc(r);\n\n-    /* write out the request key */\n+        /* write out the request key */\n #ifdef NO_WRITEV\n-    write(fpin, key, strlen(key));\n-    write(fpin, \"\\n\", 1);\n+        write(fpin, key, strlen(key));\n+        write(fpin, \"\\n\", 1);\n #else\n-    iov[0].iov_base = key;\n-    iov[0].iov_len = strlen(key);\n-    iov[1].iov_base = \"\\n\";\n-    iov[1].iov_len = 1;\n-    writev(fpin, iov, 2);\n+        iov[0].iov_base = key;\n+        iov[0].iov_len = strlen(key);\n+        iov[1].iov_base = \"\\n\";\n+        iov[1].iov_len = 1;\n+        writev(fpin, iov, 2);\n #endif\n\n-    /* read in the response value */\n-    i = 0;\n-    while (read(fpout, &c, 1) == 1 && (i < LONG_STRING_LEN-1)) {\n-        if (c == '\\n') {\n-            break;\n+        /* read in the response value */\n+        i=0;\n+        while (read(fpout, &c, 1) == 1 && (i < LONG_STRING_LEN-1)) {\n+            if (c == '\\n') {\n+                break;\n+            }\n+            buf[i++] = c;\n         }\n-        buf[i++] = c;\n-    }\n-    buf[i] = '\\0';\n+        buf[i] = '\\0';\n\n-    /* give the lock back */\n-    rewritelock_free(r);\n+        /* give the lock back */\n+        rewritelock_free(r);\n+    }\n\n     if (strcasecmp(buf, \"NULL\") == 0) {\n         return NULL;\n@@ -2945,6 +2990,45 @@\n     }\n }\n\n+static int make_socket_connection(request_rec *r, unsigned short port)\n+{\n+    struct hostent *server_hp;\n+    struct sockaddr_in addr;\n+    int sock;\n+    int i;\n+\n+    memset(&addr, '\\0', sizeof(addr));\n+    addr.sin_family = AF_INET;\n+    addr.sin_port   = htons(port);\n+\n+    server_hp = gethostbyname(\"localhost\");\n+    addr.sin_addr.s_addr =  ((struct in_addr *)server_hp->h_addr_list[0])->s_addr;\n+\n+    sock = ap_psocket(r->pool, PF_INET, SOCK_STREAM, IPPROTO_TCP);\n+    if (sock == -1) {\n+        ap_log_rerror(APLOG_MARK, APLOG_ERR, r, \"Unable to create socket\");\n+        return -1;\n+    }\n+\n+    ap_hard_timeout(\"External rewriter connect\", r);\n+    do {\n+        i = connect(sock, (struct sockaddr *) &addr, sizeof(struct sockaddr_in));\n+#if defined(WIN32) || defined(NETWARE)\n+        if (i == SOCKET_ERROR) {\n+            errno = WSAGetLastError();\n+        }\n+#endif /* WIN32 */\n+    } while (i == -1 && errno == EINTR);\n+    if (i == -1) {\n+        ap_log_rerror(APLOG_MARK, APLOG_ERR, r,\n+                      \"Unable to connect to external rewriter on %s:%d\",\n+                      inet_ntoa(addr.sin_addr), ntohs(addr.sin_port));\n+        sock = -1;\n+    }\n+    ap_kill_timeout(r);\n+    return sock;\n+}\n+\n static char *lookup_map_internal(request_rec *r,\n                                  char *(*func)(request_rec *, char *),\n                                  char *key)\n--- src/modules/standard/mod_rewrite.h  Tue May  7 16:34:43 2002\n+++ /home/jtait/src/apache_1.3.24/src/modules/standard/mod_rewrite.h    Fri May\n 3 17:18:39 2002\n@@ -274,6 +274,7 @@\n     int   fperr;                   /* err file pointer for program maps */\n     char *(*func)(request_rec *,   /* function pointer for internal maps */\n                   char *);\n+    unsigned short port;           /* port number for program maps */\n } rewritemap_entry;\n\n typedef struct {\n@@ -383,7 +384,7 @@\n static const char *cmd_rewritelog     (cmd_parms *cmd, void *dconf, char *a1);\n static const char *cmd_rewriteloglevel(cmd_parms *cmd, void *dconf, char *a1);\n static const char *cmd_rewritemap     (cmd_parms *cmd, void *dconf, char *a1,\n-                                       char *a2);\n+                                       char *a2, char *a3);\n static const char *cmd_rewritelock(cmd_parms *cmd, void *dconf, char *a1);\n static const char *cmd_rewritebase(cmd_parms *cmd, rewrite_perdir_conf *dconf,\n                                    char *a1);\n@@ -440,7 +441,8 @@\n static char *lookup_map_dbmfile(request_rec *r, char *file, char *key);\n #endif\n static char *lookup_map_program(request_rec *r, int fpin,\n-                                int fpout, char *key);\n+                                int fpout, char *key, unsigned short port);\n+static int make_socket_connection(request_rec *r, unsigned short port);\n static char *lookup_map_internal(request_rec *r,\n                                  char *(*func)(request_rec *r, char *key),\n                                  char *key);", "id": 15644, "time": "2002-05-07T16:26:40Z", "creator": "JTait@wyrddreams.demon.co.uk", "creation_time": "2002-05-07T16:26:40Z", "is_private": false, "attachment_id": null}, {"count": 1, "tags": [], "creator": "JTait@wyrddreams.demon.co.uk", "attachment_id": null, "text": "OK, I've spent some time coming up with a better solution.  The following patch\nis much more elegant, and allows Apache to talk to another server altogether\n(what TCP/IP was designed for, right?).  It doesn't ensure that the external\nrewrite engine is started, but it's a small price to pay for a potentially large\nincrease in performance.\n\nThe new format is:\n\nRewriteMap tcp:ipaddr.or.dnsname.of.host:port\n\nThe port does not have a default value, so it must be specified.\n\n--- src/modules/standard/mod_rewrite.c  Sat Mar 16 23:44:20 2002\n+++ /home/jtait/src/apache_1.3.24/src/modules/standard/mod_rewrite.c    Wed May\n 8 15:18:36 2002\n@@ -507,6 +507,11 @@\n                               a2+4, NULL);\n         }\n     }\n+    else if (strncmp(a2, \"tcp:\", 4) == 0) {\n+        new->type      = MAPTYPE_TCP;\n+        new->datafile  = a2+4;\n+        new->checkfile = NULL;\n+    }\n     else {\n         new->type      = MAPTYPE_TXT;\n         new->datafile  = a2;\n@@ -2751,6 +2756,17 @@\n                 return NULL;\n #endif\n             }\n+            else if (s->type == MAPTYPE_TCP) {\n+                if ((value = lookup_map_tcp(r, s->datafile, key)) != NULL) {\n+                    rewritelog(r, 5, \"map lookup OK: map=%s(%s) key=%s -> val=%s\",\n+                               s->name, s->datafile, key, value);\n+                    return value;\n+                }\n+                else {\n+                    rewritelog(r, 5, \"map lookup FAILED: map=%s(%s), key=%s\",\n+                               s->name, s->datafile, key);\n+                }\n+            }\n             else if (s->type == MAPTYPE_PRG) {\n                 if ((value =\n                      lookup_map_program(r, s->fpin, s->fpout, key)) != NULL) {\n@@ -2945,6 +2961,126 @@\n     }\n }\n\n+static char *lookup_map_tcp(request_rec *r, const char *hoststr, char *key)\n+{\n+    char buf[LONG_STRING_LEN];\n+    char c;\n+    int i, sock;\n+\n+    /* create a socket connection to the external program */\n+    sock = make_socket_connection(r, hoststr);\n+    if (sock == -1) {\n+        return NULL;\n+    }\n+\n+    ap_hard_timeout(\"Send external rewrite request\", r);\n+    /* write out the request key */\n+    i = send(sock, key, strlen(key), 0);\n+    if (i != strlen(key)) {\n+        ap_kill_timeout(r);\n+        return NULL;\n+    }\n+    ap_reset_timeout(r);\n+\n+    i = send(sock, \"\\n\", 1, 0);\n+    if (i != 1) {\n+        ap_kill_timeout(r);\n+        return NULL;\n+    }\n+    ap_kill_timeout(r);\n+\n+    /* read in the response value */\n+    ap_hard_timeout(\"Receive external rewrite response\", r);\n+    i = 0;\n+    while (recv(sock, &c, 1, 0) == 1 && (i < LONG_STRING_LEN - 1)) {\n+        if (c == '\\n') {\n+            break;\n+        }\n+        buf[i++] = c;\n+    }\n+    buf[i] = '\\0';\n+    ap_pclosesocket(r->pool, sock);\n+    ap_kill_timeout(r);\n+\n+    if (strcasecmp(buf, \"NULL\") == 0) {\n+        return NULL;\n+    }\n+    else {\n+        return ap_pstrdup(r->pool, buf);\n+    }\n+}\n+\n+static int make_socket_connection(request_rec *r, const char *hoststr)\n+{\n+    struct hostent *server_hp;\n+    struct sockaddr_in addr;\n+    int i, sock, port;\n+    char *host;\n+    char *portstr;\n+\n+    memset(&addr, '\\0', sizeof(addr));\n+    addr.sin_family = AF_INET;\n+\n+    host = ap_pstrdup(r->pool, hoststr);\n+    rewritelog(r, 5, \"Extracting port from string: [%s]\", host);\n+\n+    port = 0;\n+    portstr = strchr(host, ':');\n+    if (portstr != NULL) {\n+        *(portstr++) = '\\0';\n+        rewritelog(r, 5, \"Port found: [%s]\", portstr);\n+        if (ap_isdigit(*portstr)) {\n+            port = atoi(portstr);\n+        }\n+    }\n+\n+    addr.sin_port = htons(port);\n+\n+    for (i = 0; host[i] != '\\0'; i++) {\n+        if(!ap_isdigit(host[i]) && host[i] != '.') {\n+            break;\n+        }\n+    }\n+    if (host[i] == '\\0') {\n+        rewritelog(r, 3, \"External rewrite host IP: %s:%d\", host, port);\n+        addr.sin_addr.s_addr = inet_addr(host);\n+    }\n+    else {\n+        rewritelog(r, 3, \"External rewrite hostname: %s:%d\", host, port);\n+        server_hp = gethostbyname(host);\n+        if (host == NULL) {\n+            addr.sin_addr.s_addr = 0;\n+        }\n+        else {\n+            addr.sin_addr.s_addr = ((struct in_addr\n*)server_hp->h_addr_list[0])->s_addr;\n+        }\n+    }\n+\n+    sock = ap_psocket(r->pool, PF_INET, SOCK_STREAM, IPPROTO_TCP);\n+    if (sock == -1) {\n+        ap_log_rerror(APLOG_MARK, APLOG_ERR, r, \"Unable to create socket\");\n+        return -1;\n+    }\n+\n+    ap_hard_timeout(\"External rewriter connect\", r);\n+    do {\n+        i = connect(sock, (struct sockaddr *) &addr, sizeof(struct sockaddr_in));\n+#if defined(WIN32) || defined(NETWARE)\n+        if (i == SOCKET_ERROR) {\n+            errno = WSAGetLastError();\n+        }\n+#endif /* WIN32 */\n+    } while (i == -1 && errno == EINTR);\n+    if (i == -1) {\n+        ap_log_rerror(APLOG_MARK, APLOG_ERR, r,\n+                      \"Unable to connect to external rewriter on %s:%d\",\n+                      inet_ntoa(addr.sin_addr), ntohs(addr.sin_port));\n+        sock = -1;\n+    }\n+    ap_kill_timeout(r);\n+    return sock;\n+}\n+\n static char *lookup_map_internal(request_rec *r,\n                                  char *(*func)(request_rec *, char *),\n                                  char *key)\n--- src/modules/standard/mod_rewrite.h  Wed Mar 13 21:05:34 2002\n+++ /home/jtait/src/apache_1.3.24/src/modules/standard/mod_rewrite.h    Wed May\n 8 15:00:22 2002\n@@ -220,6 +220,7 @@\n #define MAPTYPE_PRG                 1<<2\n #define MAPTYPE_INT                 1<<3\n #define MAPTYPE_RND                 1<<4\n+#define MAPTYPE_TCP                 1<<5\n\n #define ENGINE_DISABLED             1<<0\n #define ENGINE_ENABLED              1<<1\n@@ -441,6 +442,8 @@\n #endif\n static char *lookup_map_program(request_rec *r, int fpin,\n                                 int fpout, char *key);\n+static char *lookup_map_tcp(request_rec *r, const char *hoststr, char *key);\n+static int make_socket_connection(request_rec *r, const char *hoststr);\n static char *lookup_map_internal(request_rec *r,\n                                  char *(*func)(request_rec *r, char *key),\n                                  char *key);\n", "id": 15717, "time": "2002-05-08T14:28:49Z", "bug_id": 8882, "creation_time": "2002-05-08T14:28:49Z", "is_private": false}, {"count": 2, "attachment_id": 1812, "creator": "JTait@wyrddreams.demon.co.uk", "text": "Created attachment 1812\nPatch to allow mod_rewrite to talk to an external rewrite engine over TCP/IP", "id": 15718, "time": "2002-05-08T14:35:28Z", "bug_id": 8882, "creation_time": "2002-05-08T14:35:28Z", "tags": [], "is_private": false}, {"count": 3, "tags": [], "bug_id": 8882, "attachment_id": null, "text": "I'm going through the bug db to make sure patches are findable.  Please see \nhttp://httpd.apache.org/dev/patches.html\n", "id": 47826, "time": "2003-11-21T18:05:51Z", "creator": "trawick@apache.org", "creation_time": "2003-11-21T18:05:51Z", "is_private": false}]