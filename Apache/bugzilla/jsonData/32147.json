[{"count": 0, "tags": [], "bug_id": 32147, "is_private": false, "text": "This is undoubtably a corner-case, however I've experienced some flexibility\nissues configuring mod_cache to work well with a combination of mod_proxy\nand mod_rewrite.  Specifically, the issue related to the inability\n(without resorting to cumbersome URI rewriting kludges) of mod_cache to be\nenabled/disabled on more than simply the basis of the leading portion of\na URI path.\n\nAdditionally, due to the fact that mod_cache uses the quick_handler hook, it\ninterrupts (if deciding to return cached content) most down-stream modules so\nthat they cannot make decisions about caching or non-caching content.\npost_read_handler is the obvious exception, however due to the nearly\nunconditional way in which mod_cache intercepts requests, it's rather\nnon-elegant to resort to intercept and avoidance trickery via post_read_handler\nalgorithms.  I do understand that using quick_handler, in the majority\nof minimal configuration caching needs, is a performance win.\n\nCertainly, this could be worked around with subrequests, however I would\nprefer not to have to deal with the overhead of a subreq on every transaction\n(which is what would be necessary in _my_ particular case, others may have\nbetter solutions).\n\nWith that being stated, the attached patch to 2.1-HEAD was my solution to\nthis issue.  The following are a list of changes, some of which may be beyond\nthe scope of what was necessary and violate various development API\nintegrity rules.  If this is the case, I would be happy to remove/alter\ncertain portions (and I'll mention some discomforts I have below as well).\n\nChanges:\n\n1. Added two optional hooks, cache_check_enabled and cache_check_disabled:\n\n   A. cache_check_enabled is run from ap_cache_get_providers in order to\n   determine if a particular uri (or other condition) is cause to\n   enable caching.  The default handler for this hook implements the\n   original functionality by iterating the cacheenable list and\n   adding each entry whose left-most portion of the uri path matches.\n\n   B. cache_check_disabled is run from ap_cache_get_provider in order\n   to dermine if caching should be disabled.  The first hook to return\n   DECLINED causes mod_cache to discontinue trying to find a provider.\n   Again, the default handler performs the original functionality by\n   iterating the cachedisable list.  In addition, a check_disable hook may\n   return CACHE_DEFER, which results in mod_cache refusing to return cached\n   content if in the quick_handler hook.  Instead it tries again from a\n   regular content hook (see below).\n\n2. New optional function: ap_cache_request_enable_provider.  Intended\n   to be used by those who hook check_enabled to add a provider name\n   (\"type\" seems to be the parlance in mod_cache at that level)\n   and optional version number to the list of providers that\n   ap_cache_get_providers() will try to lookup.\n\n   Using ap_cache_request_enable_provider is a module's way of telling\n   mod_cache to attempt caching.  The func name is tad cumbersome,\n   the \"request\" is only in there to give some indication that it is\n   a per-request call, not a general-use function for enabling providers.\n\n   Perhaps this should be an optional, because it's functionally identical\n   to a normal API call.  If that is the case, then check_enabled and\n   check_disabled shouldn't be optional hooks either.\n\n3. Added a content handler to mod_cache so that it (or others) can choose,\n   selectively, to handle a request _after_ other modules have taken\n   their turn.  Particularly useful for mod_rewrite.  Additionally, the\n   request handler  must be set to \"cache-server\", which is done\n   automatically if a check_disabled handler returns CACHE_DEFER inside\n   the context of cache_url_handler.  mod_rewrite can also enable caching\n   this way by setting the content handler during a rewrite rule.\n   In my case, this is useful for enabling both reverse proxy and\n   caching for requests that meet certain header constraints.\n\n4. Added a new directive \"CacheDefer\", which when toggled on forces\n   the above behavior (handling from the content_handler) to be the\n   default.  This was completely arbitrary, however it provided the\n   functionality I needed and was useful for testing.  Obviously,\n   with the above changes this could be done from anywhere.  Not crazy\n   about the name either, it is .. non-intuitive for those unfamiliar\n   with the code.\n\n5. The majority of mod_cache.h internals were moved to cache_private.h, due\n   to the fact that there now exist some intentionally public exports.\n   The now highly minimalized mod_cache.h added to $top_srcdir/Makefile.in\n   for the install-include target.  All mod_cache related sources that\n   previously referenced mod_cache.h changed to cache_private.h.\n   Might need some dependancy fixups, I didn't go that far.\n\nThank you for your time.  I hope this will be of some use.  If there are\nany questions or requested changes, please feel free to let me know\n(or just have bugzilla do it =P)\n\nJesse Sipprell", "id": 66656, "time": "2004-11-10T07:47:59Z", "creator": "jesses@sportsline.com", "creation_time": "2004-11-10T07:47:59Z", "attachment_id": null}, {"count": 1, "text": "Created attachment 13375\nfine-grained enable/disable enhancements to mod_cache", "bug_id": 32147, "is_private": false, "id": 66657, "time": "2004-11-10T07:49:07Z", "creator": "jesses@sportsline.com", "creation_time": "2004-11-10T07:49:07Z", "tags": [], "attachment_id": 13375}, {"count": 2, "text": "httpd-trunk supports the CacheQuickHandler directive, which allows you to run the cache as a normal handler, which means most of the cases described below should now work.\n\nAssuming this problem still exists, can you verify that CacheQuickHandler helps the issues below?\n\nThe attached patch seems to attempt to do a number of things at the same time, which is difficult to review.", "bug_id": 32147, "is_private": false, "id": 130842, "time": "2009-10-03T08:31:47Z", "creator": "minfrin@sharp.fm", "creation_time": "2009-10-03T08:31:47Z", "tags": [], "attachment_id": null}, {"count": 3, "tags": [], "bug_id": 32147, "attachment_id": null, "is_private": false, "id": 134137, "time": "2010-02-02T06:20:57Z", "creator": "hurikhan77@googlemail.com", "creation_time": "2010-02-02T06:20:57Z", "text": "Is this going to be backported or available as a single patch I could try to apply to 2.2.14 sources?\n\nWe have a problem where using mod_cache and mod_rewrite together and enabling Expires header in a php application, mod_cache always returns the same content on subsequent requests no matter which URL was requested from apache. mod_cache seems to only see the index.php in it's cache while rewrite rules route all URLs through this file. Example setup:\n\nRewriteEngine on\nRewriteRule ^(favicon\\.ico|robots\\.txt) - [L]\nRewriteCond %{REQUEST_FILENAME} !-f\nRewriteCond %{REQUEST_FILENAME} !-d\nRewriteCond %{REQUEST_FILENAME} !-l\nRewriteRule .* index.php\n\nOn the first request (cold cache) when we request /real/url.html from the server it returns the right content. On the next request it serves the content from cache as intended. Next we request /another/url.html and the cache simply servers the content of the first url without going through the index.php (which uses PATH_INFO to extract the URL data).\n\nI think this is because mod_cache only hashed \"index.php\" as the URL which had in both cases no query string and it thus handles both different requests as equal. As far as I understood this should be solvable by using \"CacheQuickHandler off\"."}, {"count": 4, "tags": [], "bug_id": 32147, "is_private": false, "text": "(In reply to comment #3)\n> Is this going to be backported or available as a single patch I could try to\n> apply to 2.2.14 sources?\n> \n> We have a problem where using mod_cache and mod_rewrite together and enabling\n> Expires header in a php application, mod_cache always returns the same content\n> on subsequent requests no matter which URL was requested from apache. mod_cache\n> seems to only see the index.php in it's cache while rewrite rules route all\n> URLs through this file. Example setup:\n> \n> RewriteEngine on\n> RewriteRule ^(favicon\\.ico|robots\\.txt) - [L]\n> RewriteCond %{REQUEST_FILENAME} !-f\n> RewriteCond %{REQUEST_FILENAME} !-d\n> RewriteCond %{REQUEST_FILENAME} !-l\n> RewriteRule .* index.php\n> \n> On the first request (cold cache) when we request /real/url.html from the\n> server it returns the right content. On the next request it serves the content\n> from cache as intended. Next we request /another/url.html and the cache simply\n> servers the content of the first url without going through the index.php (which\n> uses PATH_INFO to extract the URL data).\n> \n> I think this is because mod_cache only hashed \"index.php\" as the URL which had\n> in both cases no query string and it thus handles both different requests as\n> equal. As far as I understood this should be solvable by using\n> \"CacheQuickHandler off\".\n\nThis sounds strange and IMHO should not happen with 2.2.14. Please set your loglevel to debug and provide the error log output for\n\n1. Startup with a cold cache\n2. Request /real/url.html\n3. Request /real/url.html (from cache)\n4. Request /another/url.html", "id": 134145, "time": "2010-02-02T08:40:55Z", "creator": "rpluem@apache.org", "creation_time": "2010-02-02T08:40:55Z", "attachment_id": null}, {"count": 5, "tags": [], "bug_id": 32147, "attachment_id": null, "is_private": false, "id": 151572, "time": "2011-11-16T22:32:49Z", "creator": "wrowe@apache.org", "creation_time": "2011-11-16T22:32:49Z", "text": "No reply to info request; closing."}]