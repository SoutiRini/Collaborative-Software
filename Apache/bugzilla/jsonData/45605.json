[{"count": 0, "attachment_id": null, "bug_id": 45605, "text": "I have a mod_jk server, and the log shows this warning before the server dies:\n [Mon Aug 04 16:30:39 2008] [crit] [Mon Aug 04 16:30:39 2008] file fdqueue.c, line 293, assertion \"!((queue)->nelts == (queue)->bounds)\" failed\n\nI think when some (not all) of the backend servers are down (and the rest are therefore slower) it happens.", "id": 119635, "time": "2008-08-09T00:40:34Z", "creator": "rmattison190@gmail.com", "creation_time": "2008-08-09T00:40:34Z", "tags": [], "is_private": false}, {"count": 1, "attachment_id": null, "bug_id": 45605, "text": "I was able to reproduce this bug under heavy load on Linux CentOS 4. Without the maintainer-mode configured ap_queue_push() would simply write past the end of the worker_queue->data[] array, and into the work_queue_info structure that happened to be allocated directly past it in memory. The end result was that the condition variable pointer at worker_queue_info->wait_for_idler would be overwritten (as well as the other parts of worker_queue_info before that) and the child process would hang when it attempted to shutdown (queue_info_cleanup(), apr_thread_cond_destroy(), apr_pool_cleanup_run(), thread_cond_cleanup(), pthread_cond_destroy() hung in here attempting to lock the mutex embedded in the condition variable.\n\nI also observer other problems (seg faults in two other places) which ins't surprising since we are looking at a buffer overrun into who knows what memory.\n\nDuplicated with 2.2.9. When maintainer mode was enable I got the same assert as reported in this bug.\n\nI would be willing to work on a fix for this, but haven't had time to dig deep enough to know if there already is a mechanism to prevent this buffer array overflow that simply is broken, or if one needs to be built. Any pointers would be appreciated.", "id": 120760, "time": "2008-09-18T13:11:09Z", "creator": "jlawson@omniture.com", "creation_time": "2008-09-18T13:11:09Z", "tags": [], "is_private": false}, {"count": 2, "tags": [], "creator": "cluby@omniture.com", "text": "Created attachment 22614\nworker_queue wait for not full patch for 2.2.6\n\nThis is the patch I'm currently testing for this against 2.2.6.  I just finished it about an hour ago and I would love any feedback.  What I've done is added a second condition to the queue structure that the listener thread waits on when the queue is full until one of the worker threads signals it after popping a socket off of the queue.  It's kind of the opposite of the not_empty condition", "id": 120813, "time": "2008-09-19T16:14:17Z", "bug_id": 45605, "creation_time": "2008-09-19T16:14:17Z", "is_private": false, "attachment_id": 22614}, {"count": 3, "tags": [], "creator": "cluby@omniture.com", "text": "Created attachment 22615\nworker_queue wait for not full patch for 2.2.6 - version 2 (added warning)\n\nSlight update to the patch that I'm testing to include an error log warning to help out validation", "id": 120814, "time": "2008-09-19T16:53:46Z", "bug_id": 45605, "creation_time": "2008-09-19T16:53:46Z", "is_private": false, "attachment_id": 22615}, {"count": 4, "tags": [], "bug_id": 45605, "attachment_id": null, "text": "The same was reproduced several times under a heavy load with the 1 process / 2 thread configuration. Due to the data corruption by the worker_queue overflow the core is dumped. Inspecting the core files, the underflow of worker_queue_info.idlers is found.\n\nFinally, that looks like the race between the condition signal and the atomic update of the idlers variable.\n\nThe following scheduling scenario leads to the idlers underflow:\n\n0. one listener + worker thread\n\n1. listener got a connection, decreases idlers to 0, then context switch\n2. worker does his job set the idlers from 0 to 1,\n   then context switch before the condition signal\n3. listener got a connection, sees that idlers is 1,\n   so decreases is to 0, gets another connection,\n   waits on the condition variable\n4. worker remembering that the idlers was 0,\n   does the cond_signal, then context switch\n5. listener wakes up and set idlers to -1\n\nThe 2.2.9 patch is the following. The similar patch for 2.2.3 is currently under the test.\n\n--- server/mpm/worker/fdqueue.c.fdqueue-overflow    2006-07-12 07:38:44.000000000 +0400\n+++ server/mpm/worker/fdqueue.c     2008-10-07 13:53:28.000000000 +0400\n@@ -166,7 +166,7 @@\n          *     now nonzero, it's safe for this function to\n          *     return immediately.\n          */\n-        if (queue_info->idlers == 0) {\n+        while (queue_info->idlers == 0) {\n             rv = apr_thread_cond_wait(queue_info->wait_for_idler,\n                                   queue_info->idlers_mutex);\n             if (rv != APR_SUCCESS) {\n", "id": 121273, "time": "2008-10-07T07:08:42Z", "creator": "denusk@gmail.com", "creation_time": "2008-10-07T07:08:42Z", "is_private": false}, {"count": 5, "tags": [], "bug_id": 45605, "attachment_id": null, "text": "(In reply to comment #4)\n> The same was reproduced several times under a heavy load with the 1 process / 2\n> thread configuration. Due to the data corruption by the worker_queue overflow\n> the core is dumped. Inspecting the core files, the underflow of\n> worker_queue_info.idlers is found.\n> \n> Finally, that looks like the race between the condition signal and the atomic\n> update of the idlers variable.\n> \n> The following scheduling scenario leads to the idlers underflow:\n> \n> 0. one listener + worker thread\n> \n> 1. listener got a connection, decreases idlers to 0, then context switch\n> 2. worker does his job set the idlers from 0 to 1,\n>    then context switch before the condition signal\n> 3. listener got a connection, sees that idlers is 1,\n>    so decreases is to 0, gets another connection,\n>    waits on the condition variable\n> 4. worker remembering that the idlers was 0,\n>    does the cond_signal, then context switch\n> 5. listener wakes up and set idlers to -1\n> \n> The 2.2.9 patch is the following. The similar patch for 2.2.3 is currently\n> under the test.\n\nVery nice analysis. Just one question for clarification: After applying the patch you submitted the issue was gone and no longer reproducable?\n\n", "id": 121277, "time": "2008-10-07T08:52:54Z", "creator": "rpluem@apache.org", "creation_time": "2008-10-07T08:52:54Z", "is_private": false}, {"count": 6, "tags": [], "bug_id": 45605, "attachment_id": null, "text": "(In reply to comment #5)\n> (In reply to comment #4)\n> > \n> > The 2.2.9 patch is the following. The similar patch for 2.2.3 is currently\n> > under the test.\n> \n> Very nice analysis. Just one question for clarification: After applying the\n> patch you submitted the issue was gone and no longer reproducable?\n \nRight! No segfault anymore.", "id": 121300, "time": "2008-10-08T01:39:39Z", "creator": "denusk@gmail.com", "creation_time": "2008-10-08T01:39:39Z", "is_private": false}, {"count": 7, "attachment_id": null, "bug_id": 45605, "text": "Committed to trunk as r702867 (http://svn.apache.org/viewvc?rev=702867&view=rev).", "id": 121307, "time": "2008-10-08T06:33:05Z", "creator": "rpluem@apache.org", "creation_time": "2008-10-08T06:33:05Z", "tags": [], "is_private": false}, {"count": 8, "tags": [], "creator": "jlawson@omniture.com", "attachment_id": null, "id": 121313, "time": "2008-10-08T08:41:36Z", "bug_id": 45605, "creation_time": "2008-10-08T08:41:36Z", "is_private": false, "text": "This latest report is a legitimate bug, as can be seen by following events through the given scenario. However it is not the exactly the same bug as originally reported. As can be seen by reviewing the assert condition that the original bug reporter was having, the original condition was an overflow not an underflow. Here is the scenario where the overflow can happen.\n\n1. Listener thread is waiting for workers.\n1. Worker threads are all busy but one that just finished.\n2. That worker thread atomically increments idlers from 0 to 1 and awakens the listener.\n3. That worker thread context switches (before getting into ap_queue_pop())\n4. Listener awakens and finds that there is an idle worker and begins to fill the queue (ap_queue_push()), repeatedly until queue is overfilled.\n\nUnfortunately the fix provided by Denis does not address this problem. \n\nThe root of the problem is that there is no way for the listener to indicate that it is idle, then execute code outside of a critical section, and then pick up the work to be done without this timing window being present. \n\nThe possible solutions are:\n- Have the idler not indicate it is ready to process a request before it is actually in the critical section where it will pick up the work to be processed. This is not trivial using the current architecture of having the queue and queueinfo structures being separate structures.\n- Have the listener wait if the queue is full as Chris' patch does. This introduces and an extra condition variable, and an extra mutex lock for each \nrequest. (Might be able to mitigate the mutex lock cost to almost zero by only locking when the queue is full)\n- To minimize code changes we could simply gracefully exit the child when the queue is full allowing those requests to finish but no more requests to be processed by this child. I don't like this solution because it makes more work (child startup/shutdown) right when the system is already overloaded.\n\nComments? Other possibilities?"}, {"count": 9, "tags": [], "creator": "jlawson@omniture.com", "attachment_id": null, "id": 121314, "time": "2008-10-08T09:07:29Z", "bug_id": 45605, "creation_time": "2008-10-08T09:07:29Z", "is_private": false, "text": "there is a mistake in the last comment. The paragraph:\nThe root of the problem is that there is no way for the listener to indicate\nthat it is idle, then execute code outside of a critical section, and then pick\nup the work to be done without this timing window being present. \n\nshould read:\nThe root of the problem is that there is no way for the worker (not listener) to indicate that it is idle, then execute code outside of a critical section, and then pick up the work to be done without this timing window being present. \n"}, {"count": 10, "tags": [], "creator": "rpluem@apache.org", "attachment_id": null, "id": 121315, "time": "2008-10-08T09:29:17Z", "bug_id": 45605, "creation_time": "2008-10-08T09:29:17Z", "is_private": false, "text": "(In reply to comment #8)\n> This latest report is a legitimate bug, as can be seen by following events\n> through the given scenario. However it is not the exactly the same bug as\n> originally reported. As can be seen by reviewing the assert condition that the\n> original bug reporter was having, the original condition was an overflow not an\n> underflow. Here is the scenario where the overflow can happen.\n> \n> 1. Listener thread is waiting for workers.\n> 1. Worker threads are all busy but one that just finished.\n> 2. That worker thread atomically increments idlers from 0 to 1 and awakens the\n> listener.\n> 3. That worker thread context switches (before getting into ap_queue_pop())\n> 4. Listener awakens and finds that there is an idle worker and begins to fill\n> the queue (ap_queue_push()), repeatedly until queue is overfilled.\n\nI cannot follow this last point. Once the listerner awakes again from \napr_thread_cond_wait in ap_queue_info_wait_for_idler it knows for sure that there is at least one idle thread (after the patch from Denis is applied). But if there is only one idle thread queue_info->idlers is decreased to zero again by apr_atomic_dec32(&(queue_info->idlers)); in ap_queue_info_wait_for_idler. After returning from ap_queue_info_wait_for_idler the listener thread tries to accept *one* connection and pushes it to the queue. Afterwards it has to wait again for an idle thread in ap_queue_info_wait_for_idler (exactly in the call apr_thread_cond_wait). So the queue is not filled repeatedly by the listener thread until overfilled.\nHave you applied the patch and checked whether you still experience the same kind of SegFaults as without?\nDo you still see the assertion error message found by the original reporter?"}, {"count": 11, "tags": [], "bug_id": 45605, "attachment_id": null, "text": "Yes I see that, thanks for the explanation.\n\nI will test with the new patch. \n\nI see how the underflow of queue_info->idlers can cause on overflow of queue->data[]:\n1. Underflow explained by Denis happens.\n2. Listener fills the queue, decrementing queue_info->idlers each insert making it more and more negative until queue->data[] overflows and bad things happen.\n", "id": 121322, "time": "2008-10-08T14:36:12Z", "creator": "jlawson@omniture.com", "creation_time": "2008-10-08T14:36:12Z", "is_private": false}, {"count": 12, "tags": [], "creator": "jlawson@omniture.com", "attachment_id": null, "id": 121425, "time": "2008-10-10T12:48:08Z", "bug_id": 45605, "creation_time": "2008-10-10T12:48:08Z", "is_private": false, "text": "This patch also fixes ny scenario. No more assert.\n"}, {"count": 13, "tags": [], "bug_id": 45605, "attachment_id": null, "text": "Proposed for backport as r703707 (http://svn.apache.org/viewvc?rev=703707&view=rev).", "id": 121436, "time": "2008-10-11T11:43:46Z", "creator": "rpluem@apache.org", "creation_time": "2008-10-11T11:43:46Z", "is_private": false}, {"count": 14, "tags": [], "creator": "rpluem@apache.org", "attachment_id": null, "id": 121674, "time": "2008-10-18T03:20:19Z", "bug_id": 45605, "creation_time": "2008-10-18T03:20:19Z", "is_private": false, "text": "Backported to 2.2.x as r705872 (http://svn.apache.org/viewvc?rev=705872&view=rev)."}]