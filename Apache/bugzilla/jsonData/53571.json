[{"attachment_id": null, "tags": [], "bug_id": 53571, "text": "So I've run into a problem with my custom ant task that extends JUnitTask. Because my subclass is loaded out of my custom jar and my custom jar also requires the junit.jar on the tasked classpath I've run into an inconsistency in how the JUnitTask determines if it needs to use a split classloader.\n\nHere is the exception I run into:\n\n/examples/build.xml:38: The <classpath> for <junit> must include junit.jar if not in Ant's own classpath\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.createMirror(JUnitTask.java:695)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.setupJUnitDelegate(JUnitTask.java:745)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:755)\n\nThe <junit> classpath _does_ have the junit.jar, but it's not on Ant's own classpath. This error is caused my an inconsistency between which classloader is being used to check the junit classes.\n\nHere is the code in question from JUnitTask - in setupJUnitDelegate it uses the JUnitTask.class.getClassloader (which will be loaded in the default ant classloader which does not have junit.jar on it's classpath). It then uses splitJunit to determine if it needs to use the split classpath, but in my case splitJunit is false when it should be true. Since it's false it uses the JUnitTask.class.getClassLoader() to try and load the junit classes which fails.\n\n    protected void setupJUnitDelegate() {\n        ClassLoader myLoader = JUnitTask.class.getClassLoader();\n        if (splitJunit) {\n\n\nThe reason splitJunit is false is because it's using a different classloader to do it's initial check. Here it's set to the result of !addClasspathResource():\n\n    public void init() {\n        antRuntimeClasses = new Path(getProject());\n        splitJunit = !addClasspathResource(\"/junit/framework/TestCase.class\");\n\u2026\n        } else {\n            mirrorLoader = myLoader;\n        }\n\n\nAnd addClasspathResource uses getClass().getClassLoader() which in my case is my subclass whose <taskdef> classpath _does_ have the junit.jar classes on it's classpath (my subclass requires it to load).\n\n    private boolean addClasspathResource(String resource) {\n\u2026\n        File f = LoaderUtils.getResourceSource(getClass().getClassLoader(),\n                                               resource);\n\n\nChanging addClasspathResource to use JUnitTask.class.getClassLoader() seems to solve the problem, but the fact that it's not consistent is probably all that's required.", "count": 0, "id": 160733, "time": "2012-07-19T19:40:38Z", "creator": "brian.mcdonald@ca.com", "creation_time": "2012-07-19T19:40:38Z", "is_private": false}, {"count": 1, "tags": [], "creator": "jglick@apache.org", "text": "Committed revision 1363748. Using JUnitTask.class in both places now, rather than getClass() - while your subclass may happen to link against junit.jar, the mirror classes are designed to let the task instance use whatever copy of JUnit is in the project classpath.", "id": 160757, "time": "2012-07-20T12:27:51Z", "bug_id": 53571, "creation_time": "2012-07-20T12:27:51Z", "is_private": false, "attachment_id": null}]