[{"count": 0, "tags": [], "bug_id": 7016, "attachment_id": null, "id": 11636, "time": "2002-03-10T22:31:57Z", "creator": "ccalvert@yahoo.com", "creation_time": "2002-03-10T22:31:57Z", "is_private": false, "text": "In Execute.java You are checking for 2000 and NT, but not for xp. Here is hte \nfixed code for GetProcEnvCommand:\n\n            if ( osname.indexOf(\"nt\") >= 0 || osname.indexOf(\"2000\") >= 0 || \nosname.indexOf(\"xp\") >= 0 ) \n\t\t\t{\n                // Windows 2000/NT/XP\n\t\t\t\tSystem.out.println(\"running under xp\");\n                String[] cmd = {\"cmd\", \"/c\", \"set\" };\n                return cmd;\n            }\n            else {\n                // Windows 98/95 - need to use an auxiliary script\n\t\t\t\tSystem.out.println(\"running under Windows \n95/98\");\n                String[] cmd = {\"command.com\", \"/c\", \"set\" };\n                return cmd;\n            }\n\nNotice that I check for xp.\n\nHere is the whole class. Notice that I have left in some debug statements:\n\n/*\n * The Apache Software License, Version 1.1\n *\n * Copyright (c) 2000 The Apache Software Foundation.  All rights\n * reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * 3. The end-user documentation included with the redistribution, if\n *    any, must include the following acknowlegement:\n *       \"This product includes software developed by the\n *        Apache Software Foundation (http://www.apache.org/).\"\n *    Alternately, this acknowlegement may appear in the software itself,\n *    if and wherever such third-party acknowlegements normally appear.\n *\n * 4. The names \"The Jakarta Project\", \"Ant\", and \"Apache Software\n *    Foundation\" must not be used to endorse or promote products derived\n *    from this software without prior written permission. For written\n *    permission, please contact apache@apache.org.\n *\n * 5. Products derived from this software may not be called \"Apache\"\n *    nor may \"Apache\" appear in their names without prior written\n *    permission of the Apache Group.\n *\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n * ====================================================================\n *\n * This software consists of voluntary contributions made by many\n * individuals on behalf of the Apache Software Foundation.  For more\n * information on the Apache Software Foundation, please see\n * <http://www.apache.org/>.\n */\n\npackage org.apache.tools.ant.taskdefs;\n\nimport org.apache.tools.ant.BuildException;\nimport org.apache.tools.ant.Project;\nimport org.apache.tools.ant.Task;\nimport org.apache.tools.ant.types.Commandline;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.BufferedReader;\nimport java.io.StringReader;\nimport java.io.ByteArrayOutputStream;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Vector;\n\n/**\n * Runs an external program.\n *\n * @author thomas.haas@softwired-inc.com\n */\npublic class Execute {\n\n    /** Invalid exit code. **/\n    public final static int INVALID = Integer.MAX_VALUE;\n\n    private String[] cmdl = null;\n    private String[] env = null;\n    private int exitValue = INVALID;\n    private ExecuteStreamHandler streamHandler;\n    private ExecuteWatchdog watchdog;\n    private File workingDirectory = null;\n    private Project project = null;\n    private boolean newEnvironment = false;\n\n    /** Controls whether the VM is used to launch commands, where possible */\n    private boolean useVMLauncher = true;    \n    \n    private static String antWorkingDirectory = System.getProperty(\"user.dir\");\n    private static CommandLauncher vmLauncher = null;\n    private static CommandLauncher shellLauncher = null;\n    private static Vector procEnvironment = null;\n\n    /** \n     * Builds a command launcher for the OS and JVM we are running under\n     */\n    static {\n        // Try using a JDK 1.3 launcher\n        try {\n            vmLauncher = new Java13CommandLauncher();\n        }\n        catch ( NoSuchMethodException exc ) {\n            // Ignore and keep try\n        }\n\n        String osname = System.getProperty(\"os.name\").toLowerCase();\n        if ( osname.indexOf(\"mac os\") >= 0 ) {\n            // Mac\n            shellLauncher = new MacCommandLauncher(new CommandLauncher());\n        }\n        else if ( osname.indexOf(\"os/2\") >= 0 ) {\n            // OS/2 - use same mechanism as Windows 2000\n            shellLauncher = new WinNTCommandLauncher(new CommandLauncher());\n        }\n        else if ( osname.indexOf(\"windows\") >= 0 ) {\n            // Windows.  Need to determine which JDK we're running in\n            CommandLauncher baseLauncher;\n            if ( System.getProperty(\"java.version\").startsWith(\"1.1\") ) {\n                // JDK 1.1\n                baseLauncher = new Java11CommandLauncher();\n            }\n            else {\n                // JDK 1.2\n                baseLauncher = new CommandLauncher();\n            }\n\n            // Determine if we're running under 2000/NT or 98/95\n            if ( osname.indexOf(\"nt\") >= 0 || osname.indexOf(\"2000\") >= 0 || \nosname.indexOf(\"xp\") >= 0 ) \n\t\t\t{\n                // Windows 2000/NT\n                System.out.println(\"running under xp\");\n                shellLauncher = new WinNTCommandLauncher(baseLauncher);\n            }\n            else {\n                // Windows 98/95 - need to use an auxiliary script\n                shellLauncher = new ScriptCommandLauncher(\"bin/antRun.bat\", \nbaseLauncher);\n            }\n        }\n        else {\n            // Generic\n            shellLauncher = new ScriptCommandLauncher(\"bin/antRun\", new \nCommandLauncher());\n        }\n    }\n\n    /**\n     * Find the list of environment variables for this process.\n     */\n    public static synchronized Vector getProcEnvironment() {\n        if (procEnvironment != null) return procEnvironment;\n\n        procEnvironment = new Vector();\n        try {\n            ByteArrayOutputStream out = new ByteArrayOutputStream();\n            Execute exe = new Execute(new PumpStreamHandler(out));\n            exe.setCommandline(getProcEnvCommand());\n            // Make sure we do not recurse forever\n            exe.setNewenvironment(true);\n            int retval = exe.execute();\n            if ( retval != 0 ) {\n                // Just try to use what we got\n            }\n\n            BufferedReader in = \n                new BufferedReader(new StringReader(out.toString()));\n            String var = null;\n            String line, lineSep = System.getProperty(\"line.separator\");\n            while ((line = in.readLine()) != null) {\n                if (line.indexOf('=') == -1) {\n                    // Chunk part of previous env var (UNIX env vars can\n                    // contain embedded new lines).\n                    if (var == null) {\n                        var = lineSep + line;\n                    }\n                    else {\n                        var += lineSep + line;\n                    }\n                }\n                else {\n                    // New env var...append the previous one if we have it.\n                    if (var != null) {\n                        procEnvironment.addElement(var);\n                    }\n                    var = line;\n                }\n            }\n            // Since we \"look ahead\" before adding, there's one last env var.\n            procEnvironment.addElement(var);\n        } \n        catch (java.io.IOException exc) {\n            exc.printStackTrace();\n            // Just try to see how much we got\n        }\n        return procEnvironment;\n    }\n\n    private static String[] getProcEnvCommand() {\n        String osname = System.getProperty(\"os.name\").toLowerCase();\n        if ( osname.indexOf(\"mac os\") >= 0 ) {\n            // Mac\n            // Determine if we are running under OS X\n            try {\n                String version = System.getProperty(\"os.version\");\n                int majorVersion = \n                    Integer.parseInt(version.substring(0, version.indexOf\n('.')));\n\n                if (majorVersion >= 10) {\n                    // OS X - just line UNIX\n                    String[] cmd = {\"/usr/bin/env\"};\n                    return cmd;\n                }\n            } catch (NumberFormatException e) {\n                // fall through to OS 9\n            }\n            // OS 9 and previous\n            // TODO: I have no idea how to get it, someone must fix it\n            String[] cmd = null;\n            return cmd;\n        }\n        else if ( osname.indexOf(\"os/2\") >= 0 ) {\n            // OS/2 - use same mechanism as Windows 2000\n            // Not sure\n            String[] cmd = {\"cmd\", \"/c\", \"set\" };\n            return cmd;\n        }\n        else if ( osname.indexOf(\"indows\") >= 0 ) {\n            // Determine if we're running under 2000/NT or 98/95\n\t\t\tSystem.out.println(\"osname: \" + osname);\n            if ( osname.indexOf(\"nt\") >= 0 || osname.indexOf(\"2000\") >= 0 || \nosname.indexOf(\"xp\") >= 0 ) \n\t\t\t{\n                // Windows 2000/NT/XP\n\t\t\t\tSystem.out.println(\"running under xp\");\n                String[] cmd = {\"cmd\", \"/c\", \"set\" };\n                return cmd;\n            }\n            else {\n                // Windows 98/95 - need to use an auxiliary script\n\t\t\t\tSystem.out.println(\"running under Windows \n95/98\");\n                String[] cmd = {\"command.com\", \"/c\", \"set\" };\n                return cmd;\n            }\n        }\n        else {\n            // Generic UNIX\n            // Alternatively one could use: /bin/sh -c env\n            String[] cmd = {\"/usr/bin/env\"};\n            return cmd;\n        }\n    }\n\n    /**\n     * Creates a new execute object using <code>PumpStreamHandler</code> for\n     * stream handling.\n     */\n    public Execute() {\n        this(new PumpStreamHandler(), null);\n    }\n\n\n    /**\n     * Creates a new execute object.\n     *\n     * @param streamHandler the stream handler used to handle the input and\n     *        output streams of the subprocess.\n     */\n    public Execute(ExecuteStreamHandler streamHandler) {\n        this(streamHandler, null);\n    }\n\n    /**\n     * Creates a new execute object.\n     *\n     * @param streamHandler the stream handler used to handle the input and\n     *        output streams of the subprocess.\n     * @param watchdog a watchdog for the subprocess or <code>null</code> to\n     *        to disable a timeout for the subprocess.\n     */\n    public Execute(ExecuteStreamHandler streamHandler, ExecuteWatchdog \nwatchdog) {\n        this.streamHandler = streamHandler;\n        this.watchdog = watchdog;\n    }\n\n\n    /**\n     * Returns the commandline used to create a subprocess.\n     *\n     * @return the commandline used to create a subprocess\n     */\n    public String[] getCommandline() {\n        return cmdl;\n    }\n\n\n    /**\n     * Sets the commandline of the subprocess to launch.\n     *\n     * @param commandline the commandline of the subprocess to launch\n     */\n    public void setCommandline(String[] commandline) {\n        cmdl = commandline;\n    }\n\n    /**\n     * Set whether to propagate the default environment or not.\n     *\n     * @param newenv whether to propagate the process environment.\n     */\n    public void setNewenvironment(boolean newenv) {\n        newEnvironment = newenv;\n    }\n\n    /**\n     * Returns the environment used to create a subprocess.\n     *\n     * @return the environment used to create a subprocess\n     */\n    public String[] getEnvironment() {\n        if (env == null || newEnvironment) return env;\n        return patchEnvironment();\n    }\n\n\n    /**\n     * Sets the environment variables for the subprocess to launch.\n     *\n     * @param commandline array of Strings, each element of which has\n     * an environment variable settings in format <em>key=value</em> \n     */\n    public void setEnvironment(String[] env) {\n        this.env = env;\n    }\n\n    /**\n     * Sets the working directory of the process to execute.\n     *\n     * <p>This is emulated using the antRun scripts unless the OS is\n     * Windows NT in which case a cmd.exe is spawned,\n     * or MRJ and setting user.dir works, or JDK 1.3 and there is\n     * official support in java.lang.Runtime.\n     *\n     * @param wd the working directory of the process.\n     */\n    public void setWorkingDirectory(File wd) {\n        if (wd == null || wd.getAbsolutePath().equals(antWorkingDirectory))\n            workingDirectory = null;\n        else\n            workingDirectory = wd;\n    }\n\n    /**\n     * Set the name of the antRun script using the project's value.\n     *\n     * @param project the current project.\n     */\n    public void setAntRun(Project project) throws BuildException {\n        this.project = project;\n    }\n\n    /**\n     * Launch this execution through the VM, where possible, rather than \nthrough\n     * the OS's shell. In some cases and operating systems using the shell \nwill \n     * allow the shell to perform additional processing such as associating an \n     * executable with a script, etc\n     *\n     * @param vmLauncher true if exec should launch through thge VM, \n     *                   false if the shell should be used to launch the \ncommand.\n     */\n    public void setVMLauncher(boolean useVMLauncher) {\n        this.useVMLauncher = useVMLauncher;\n    }\n    \n    /**\n     * Runs a process defined by the command line and returns its exit status.\n     *\n     * @return the exit status of the subprocess or <code>INVALID</code>\n     * @exception java.io.IOExcpetion The exception is thrown, if launching\n     *            of the subprocess failed\n     */\n    public int execute() throws IOException {\n        CommandLauncher launcher = vmLauncher != null ? vmLauncher : \nshellLauncher;\n        if (!useVMLauncher) {\n            launcher = shellLauncher;\n        }\n        \n        final Process process = launcher.exec(project, getCommandline(), \ngetEnvironment(), workingDirectory);\n        try {\n            streamHandler.setProcessInputStream(process.getOutputStream());\n            streamHandler.setProcessOutputStream(process.getInputStream());\n            streamHandler.setProcessErrorStream(process.getErrorStream());\n        } catch (IOException e) {\n            process.destroy();\n            throw e;\n        }\n        streamHandler.start();\n        if (watchdog != null) watchdog.start(process);\n        waitFor(process);\n        if (watchdog != null) watchdog.stop();\n        streamHandler.stop();\n        if (watchdog != null) watchdog.checkException();\n        return getExitValue();\n    }\n\n    protected void waitFor(Process process) {\n        try {\n            process.waitFor();\n            setExitValue(process.exitValue());\n        } catch (InterruptedException e) {}\n    }\n\n    protected void setExitValue(int value) {\n        exitValue = value;\n    }\n\n    public int getExitValue() {\n        return exitValue;\n    }\n\n    /**\n     * Patch the current environment with the new values from the user.\n     * @return the patched environment\n     */\n    private String[] patchEnvironment() {\n        Vector osEnv = (Vector) getProcEnvironment().clone();\n        for (int i = 0; i < env.length; i++) {\n            int pos = env[i].indexOf('=');\n            // Get key including \"=\"\n            String key = env[i].substring(0, pos+1);\n            int size = osEnv.size();\n            for (int j = 0; j < size; j++) {\n                if (((String)osEnv.elementAt(j)).startsWith(key)) {\n                    osEnv.removeElementAt(j);\n                    break;\n                }\n            }\n            osEnv.addElement(env[i]);\n        }\n        String[] result = new String[osEnv.size()];\n        osEnv.copyInto(result);\n        return result;\n    }\n\n    /**\n     * A utility method that runs an external command.  Writes the output and\n     * error streams of the command to the project log.\n     *\n     * @param task      The task that the command is part of.  Used for logging\n     * @param cmdline   The command to execute.\n     *\n     * @throws BuildException if the command does not return 0.\n     */\n    public static void runCommand(Task task, String[] cmdline) throws \nBuildException\n    {\n        try {\n            task.log(Commandline.toString(cmdline), Project.MSG_VERBOSE);\n            Execute exe = new Execute(new LogStreamHandler(task, \n                                                           Project.MSG_INFO,\n                                                           Project.MSG_ERR));\n            exe.setAntRun(task.getProject());\n            exe.setCommandline(cmdline);\n            int retval = exe.execute();\n            if ( retval != 0 ) {\n                throw new BuildException(cmdline[0] + \" failed with return \ncode \" + retval, task.getLocation());\n            }\n        } \n        catch (java.io.IOException exc) {\n            throw new BuildException(\"Could not launch \" + cmdline[0] + \": \" + \nexc, task.getLocation());\n        }\n    }\n\n    /**\n     * A command launcher for a particular JVM/OS platform.  This class is\n     * a general purpose command launcher which can only launch commands in\n     * the current working directory.\n     */\n    private static class CommandLauncher\n    {\n        /** \n         * Launches the given command in a new process.\n         *\n         * @param project       The project that the command is part of\n         * @param cmd           The command to execute\n         * @param env           The environment for the new process.  If null,\n         *                      the environment of the current proccess is \nused.\n         */\n        public Process exec(Project project, String[] cmd, String[] env) \nthrows IOException\n        {\n            if (project != null) {\n                project.log(\"Execute:CommandLauncher: \" +\n                            Commandline.toString(cmd), Project.MSG_DEBUG);\n            }                            \n            return Runtime.getRuntime().exec(cmd, env);\n        }\n\n        /** \n         * Launches the given command in a new process, in the given working\n         * directory.\n         *\n         * @param project       The project that the command is part of\n         * @param cmd           The command to execute\n         * @param env           The environment for the new process.  If null,\n         *                      the environment of the current proccess is \nused.\n         * @param workingDir    The directory to start the command in.  If \nnull,\n         *                      the current directory is used\n         */\n        public Process exec(Project project, String[] cmd, String[] env, File \nworkingDir) throws IOException\n        {\n            if ( workingDir == null ) {\n                return exec(project, cmd, env);\n            }\n            throw new IOException(\"Cannot execute a process in different \ndirectory under this JVM\");\n        }\n    }\n\n    /**\n     * A command launcher for JDK/JRE 1.1 under Windows.  Fixes quoting \nproblems\n     * in Runtime.exec().  Can only launch commands in the current working\n     * directory\n     */\n    private static class Java11CommandLauncher extends CommandLauncher\n    {\n        /**\n         * Launches the given command in a new process.  Needs to quote\n         * arguments\n         */\n        public Process exec(Project project, String[] cmd, String[] env) \nthrows IOException \n        {\n            // Need to quote arguments with spaces, and to escape quote \ncharacters\n            String[] newcmd = new String[cmd.length];\n            for ( int i = 0; i < cmd.length; i++ ) {\n                newcmd[i] = Commandline.quoteArgument(cmd[i]);\n            }\n            if (project != null) {\n                project.log(\"Execute:Java11CommandLauncher: \" +\n                            Commandline.toString(newcmd), Project.MSG_DEBUG);\n            }                            \n            return Runtime.getRuntime().exec(newcmd, env);\n        }\n    }\n\n    /**\n     * A command launcher for JDK/JRE 1.3 (and higher).  Uses the built-in\n     * Runtime.exec() command\n     */\n    private static class Java13CommandLauncher extends CommandLauncher\n    {\n        public Java13CommandLauncher() throws NoSuchMethodException\n        {\n            // Locate method Runtime.exec(String[] cmdarray, String[] envp, \nFile dir)\n            _execWithCWD = Runtime.class.getMethod(\"exec\", new Class[] {String\n[].class, String[].class, File.class});\n        }\n\n        /** \n         * Launches the given command in a new process, in the given working\n         * directory\n         */\n        public Process exec(Project project, String[] cmd, String[] env, File \nworkingDir) \n            throws IOException\n        {\n            try {\n                if (project != null) {\n                    project.log(\"Execute:Java13CommandLauncher: \" +\n                                Commandline.toString(cmd), Project.MSG_DEBUG);\n                }                                \n                Object[] arguments = { cmd, env, workingDir };\n                return (Process)_execWithCWD.invoke(Runtime.getRuntime(), \narguments);\n            } \n            catch (InvocationTargetException exc) {\n                Throwable realexc = exc.getTargetException();\n                if ( realexc instanceof ThreadDeath ) {\n                    throw (ThreadDeath)realexc;\n                } \n                else if ( realexc instanceof IOException ) {\n                    throw (IOException)realexc;\n                } \n                else {\n                    throw new BuildException(\"Unable to execute command\", \nrealexc);\n                }\n            } \n            catch (Exception exc) {\n                // IllegalAccess, IllegalArgument, ClassCast\n                throw new BuildException(\"Unable to execute command\", exc);\n            }\n        }\n        \n        private Method _execWithCWD;\n    }\n    \n    /**\n     * A command launcher that proxies another command launcher.  \n     *\n     * Sub-classes override exec(args, env, workdir)\n     */\n    private static class CommandLauncherProxy extends CommandLauncher\n    {\n        CommandLauncherProxy(CommandLauncher launcher)\n        {\n            _launcher = launcher;\n        }\n\n        /** \n         * Launches the given command in a new process.  Delegates this\n         * method to the proxied launcher\n         */\n        public Process exec(Project project, String[] cmd, String[] env) \nthrows IOException\n        {\n            return _launcher.exec(project, cmd, env);\n        }\n\n        private CommandLauncher _launcher;\n    }\n\n    /**\n     * A command launcher for Windows 2000/NT/XP that uses 'cmd.exe' when\n     * launching commands in directories other than the current working\n     * directory.\n     */\n    private static class WinNTCommandLauncher extends CommandLauncherProxy\n    {\n        WinNTCommandLauncher(CommandLauncher launcher)\n        {\n            super(launcher);\n        }\n\n        /** \n         * Launches the given command in a new process, in the given working\n         * directory.\n         */\n        public Process exec(Project project, String[] cmd, String[] env, File \nworkingDir) throws IOException\n        {\n            File commandDir = workingDir;\n            if ( workingDir == null ) {\n                if ( project != null ) {\n                    commandDir = project.getBaseDir();\n                } else {\n                    return exec(project, cmd, env);\n                }\n            }\n\n            // Use cmd.exe to change to the specified directory before running\n            // the command\n            final int preCmdLength = 6;\n            String[] newcmd = new String[cmd.length + preCmdLength];\n            newcmd[0] = \"cmd\";\n            newcmd[1] = \"/c\";\n            newcmd[2] = \"cd\";\n            newcmd[3] = \"/d\";\n            newcmd[4] = commandDir.getAbsolutePath();\n            newcmd[5] = \"&&\";\n            System.arraycopy(cmd, 0, newcmd, preCmdLength, cmd.length);\n\n            return exec(project, newcmd, env);\n        }\n    }\n\n    /**\n     * A command launcher for Mac that uses a dodgy mechanism to change\n     * working directory before launching commands.\n     */\n    private static class MacCommandLauncher extends CommandLauncherProxy\n    {\n        MacCommandLauncher(CommandLauncher launcher)\n        {\n            super(launcher);\n        }\n\n        /** \n         * Launches the given command in a new process, in the given working\n         * directory\n         */\n        public Process exec(Project project, String[] cmd, String[] env, File \nworkingDir) throws IOException\n        {\n            if ( workingDir == null ) {\n                return exec(project, cmd, env);\n            }\n\n            System.getProperties().put(\"user.dir\", workingDir.getAbsolutePath\n());\n            try {\n                return exec(project, cmd, env);\n            } \n            finally {\n                System.getProperties().put(\"user.dir\", antWorkingDirectory);\n            }\n        }\n    }\n\n    /**\n     * A command launcher that uses an auxiliary script to launch commands\n     * in directories other than the current working directory.\n     */\n    private static class ScriptCommandLauncher extends CommandLauncherProxy\n    {\n        ScriptCommandLauncher(String script, CommandLauncher launcher)\n        {\n            super(launcher);\n            _script = script;\n        }\n\n        /** \n         * Launches the given command in a new process, in the given working\n         * directory\n         */\n        public Process exec(Project project, String[] cmd, String[] env, File \nworkingDir) throws IOException\n        {\n            if ( project == null ) {\n                if ( workingDir == null ) {\n                    return exec(project, cmd, env);\n                }\n                throw new IOException(\"Cannot locate antRun script: No project \nprovided\");\n            }\n            \n            // Locate the auxiliary script\n            String antHome = project.getProperty(\"ant.home\");\n            if ( antHome == null ) {\n                throw new IOException(\"Cannot locate antRun script: \nProperty 'ant.home' not found\");\n            }\n            String antRun = project.resolveFile(antHome + File.separator + \n_script).toString();\n\n            // Build the command\n            File commandDir = workingDir;\n            if ( workingDir == null && project != null ) {\n                commandDir = project.getBaseDir();\n            }\n\n            String[] newcmd = new String[cmd.length + 2];\n            newcmd[0] = antRun;\n            newcmd[1] = commandDir.getAbsolutePath();\n            System.arraycopy(cmd, 0, newcmd, 2, cmd.length);\n            \n            return exec(project, newcmd, env);\n        }\n\n        private String _script;\n    }\n}"}, {"count": 1, "tags": [], "bug_id": 7016, "is_private": false, "text": "Charlie.\nthanks for the patch, but I am afraid to have to tell you that a patch for \nthis has been in ant1.5alpha for some time, it is only since java1.4 came out \nthat people using java1.4.1 have noticed, and we are starting to see these \nreports trickle in.\n\nWhich is why we have an item about the subject on our news page\nhttp://jakarta.apache.org/ant/antnews.html\n\nAnyway, we appreciate your contribution, even if it is a duplicate. There are \nmany other outstanding bugs and feature requests for which we do need code...\n\n*** This bug has been marked as a duplicate of 6456 ***", "id": 11643, "time": "2002-03-11T05:43:04Z", "creator": "steve_l@iseran.com", "creation_time": "2002-03-11T05:43:04Z", "attachment_id": null}]