[{"count": 0, "attachment_id": null, "bug_id": 9488, "text": "If a software send the command 'GET' to the server, Apache makes a fatal error.\nI have the message :\n\"The instruction to '0x6fed2bd0' uses the memory adress '0x00000000x. The \nmemory adress can't be 'read'.\"\nWhen I choose 'OK', Apache is restarted.", "id": 16865, "time": "2002-05-29T10:37:19Z", "creator": "lolo32@altavista.fr", "creation_time": "2002-05-29T10:37:19Z", "tags": [], "is_private": false}, {"count": 1, "tags": [], "bug_id": 9488, "text": "I think you'll need to provide a little more info.\n\n1. What do you mean \"send the command GET\"?  Please be specific.\n\n2. What changes have you made from the default configuration?\n\n3. Are you using any firewall software?", "id": 16882, "time": "2002-05-29T17:44:43Z", "creator": "slive@apache.org", "creation_time": "2002-05-29T17:44:43Z", "is_private": false, "attachment_id": null}, {"count": 2, "tags": [], "creator": "lolo32@altavista.fr", "attachment_id": null, "text": "The send command is when a program send the string 'GET' to get a page instead \nof the string 'GET /Adresse_Of_Document'.\n\nThe problem is enabled even if I use the default configuration file of Apache \nand I don't use a firewall software.", "id": 16896, "time": "2002-05-29T20:47:15Z", "bug_id": 9488, "creation_time": "2002-05-29T20:47:15Z", "is_private": false}, {"count": 3, "tags": [], "bug_id": 9488, "text": "I've tried the strings \"GET\", \"GET \", \"GET  \", \"GET HTTP/1.0\", \"GET HTTP/1.1\",\n\"GET  HTTP/1.0\" and \"GET  HTTP/1.1\" to try replicating every way this could have\nbeen mangled.  None produce a segfault.\n\nWhat modules do you have loaded?  Try disabling them one-by-one \nand let's see if it goes away, and we can track down the offensive \nmodule by process of elimination.\n\n", "id": 16905, "time": "2002-05-29T22:23:10Z", "creator": "wrowe@apache.org", "creation_time": "2002-05-29T22:23:10Z", "is_private": false, "attachment_id": null}, {"count": 4, "tags": [], "bug_id": 9488, "text": "Thank you for your help.\n\nThe problem is the OpenSSL module.", "id": 16909, "time": "2002-05-29T23:34:49Z", "creator": "lolo32@altavista.fr", "creation_time": "2002-05-29T23:34:49Z", "is_private": false, "attachment_id": null}, {"count": 5, "attachment_id": null, "bug_id": 9488, "text": "\n  Need to confirm interaction with mod_ssl", "id": 16911, "time": "2002-05-30T00:37:55Z", "creator": "wrowe@apache.org", "creation_time": "2002-05-30T00:37:55Z", "tags": [], "is_private": false}, {"count": 6, "tags": [], "bug_id": 9488, "text": "I'm 99.9% sure this works at least on Unix, as it's tested by the test \nharness.  A stack trace would be nice...", "id": 16912, "time": "2002-05-30T00:46:51Z", "creator": "jwoolley@apache.org", "creation_time": "2002-05-30T00:46:51Z", "is_private": false, "attachment_id": null}, {"count": 7, "tags": [], "creator": "wrowe@apache.org", "attachment_id": null, "text": "\n  Verified that these are misbehaving, although not the same way.  Perhaps\n  the offending code that was segfaulting is corrected in the current tree.\n\n  However, the initial assbackwards request (single line GET with no HTTP\n  version tag) responds (correctly) immediately.  Subsequent requests from\n  the same workstation are blocking for more input after the initial \"GET /\"\n  when they should expect no additional input.  Looks like our HTTP input \n  filter chain is busted after a single request.\n\n  Cliff, do you see similar on Unix?\n", "id": 17103, "time": "2002-06-03T19:52:14Z", "bug_id": 9488, "creation_time": "2002-06-03T19:52:14Z", "is_private": false}, {"count": 8, "tags": [], "bug_id": 9488, "text": "\n  One last note, \"GET /\" to the https port (typically 443) should fail, I don't\n  expect https can be negotiated on pre-HTTP/1.0 connections.  At the least\n  it should never segfault, but return a \"protocol error, HTTP over HTTPS?\"\n  message instead.\n\n  Have we seriously ever supported assbackwards HTTP 0.9 SSL connections?\n  Did mod_ssl for Apache 1.3?\n", "id": 17104, "time": "2002-06-03T19:54:29Z", "creator": "wrowe@apache.org", "creation_time": "2002-06-03T19:54:29Z", "is_private": false, "attachment_id": null}, {"count": 9, "tags": [], "creator": "jwoolley@apache.org", "attachment_id": null, "text": "Yep, 0.9 is broken.  Not sure if we ever really supported this or not.  What \nI'm seeing: \n---------------------------------------------------- \nroot@deepthought:/root# telnet localhost 8530 \nTrying 127.0.0.1... \nConnected to localhost. \nEscape character is '^]'. \nGET / \n \n \n \n \nHTTP/1.1 400 Bad Request \nDate: Mon, 03 Jun 2002 20:22:05 GMT \nServer: Apache/2.0.37-dev (Unix) mod_ssl/2.0.37-dev OpenSSL/0.9.6c DAV/2 \nPHP/4.3.0-dev \nContent-Length: 460 \nConnection: close \nContent-Type: text/html; charset=iso-8859-1 \n \n<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\"> \n<html><head> \n<title>400 Bad Request</title> \n</head><body> \n<h1>Bad Request</h1> \n<p>Your browser sent a request that this server could not understand.<br /> \nReason: You're speaking plain HTTP to an SSL-enabled server port.<br /> \nInstead use the HTTPS scheme to access this URL, please.<br /> \n<blockquote>Hint: <a \nhref=\"https://localhost:8530/\"><b>https://localhost:8530/</b></a></blockquote></p> \n</body></html> \nConnection closed by foreign host. \n---------------------------------------------------- \n ", "id": 17106, "time": "2002-06-03T20:27:08Z", "bug_id": 9488, "creation_time": "2002-06-03T20:27:08Z", "is_private": false}, {"count": 10, "tags": [], "bug_id": 9488, "text": "Okay, so basically what's happening is that we depend upon OpenSSL to tell us \nwhen the data it got from the client resembles an HTTP request rather than an \nSSL handshake.  The test looks like this: \n        if ((n = SSL_accept(filter->pssl)) <= 0) { \n            ... \n            if (ERR_GET_REASON(ERR_peek_error()) == SSL_R_HTTP_REQUEST) { \n                return HTTP_BAD_REQUEST; \n            } \n            ... \n        } \nThere's no distinction in there of whether it detected an 0.9 or an 1.x \nrequest, just that it wasn't SSL and it kinda looked like HTTP.  The above \ncondition triggers a hardcoded magic request \n \nGET /mod_ssl:error:HTTP-request HTTP/1.0 \n \nto be sent back up the input filter chain, which is obviously broken if the \noriginal request was in fact 0.9.  So somehow we either need to get OpenSSL to \ngive us back more information (like perhaps a copy of the data it errored out \non) or we need to stash a copy of that data before OpenSSL processes it.  \nEither way could be potentially messy... I'm not sure of the implementation \ndetails yet. \n \n--Cliff \n ", "id": 17107, "time": "2002-06-03T21:03:46Z", "creator": "jwoolley@apache.org", "creation_time": "2002-06-03T21:03:46Z", "is_private": false, "attachment_id": null}, {"count": 11, "tags": [], "bug_id": 9488, "attachment_id": null, "id": 17138, "time": "2002-06-04T07:17:20Z", "creator": "rbb@apache.org", "creation_time": "2002-06-04T07:17:20Z", "is_private": false, "text": "Looked through the Apache 1.3 code, and it also used a 1.0 request to fake the request.  The problem with the code right now, is that the bucket code is calling socket_bucket_read a second time, which means that theserver ends up sitting in select, waiting for more input.  I am still lookinginto that, but my gut feeling is that we shouldn't try to support 0.9 requestover SSL."}, {"count": 12, "tags": [], "creator": "jorton@redhat.com", "attachment_id": null, "text": "In fact this issue was reversed in recent releases: mod_ssl will never send\nanything other than an \"HTTP/0.9\" response to any plain HTTP request (regardless\nof version) on the SSL port: modern browers accept that as a valid HTTP request,\nso it's not such a big issue.  Marking this fixed, anyway.", "id": 51179, "time": "2004-01-26T09:45:12Z", "bug_id": 9488, "creation_time": "2004-01-26T09:45:12Z", "is_private": false}]