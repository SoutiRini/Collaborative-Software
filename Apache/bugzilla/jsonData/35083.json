[{"count": 0, "tags": [], "creator": "marc.stern@approach.be", "attachment_id": null, "text": "In case a SSL connection fails because a certificate is expired, or a CRL is\nunavailable, etc., the browser receives a SSL error that results in a cryptic\ntechnical error displayed to the user - sometimes only an error number like in\nFirefox. In such a situation, the SSL connection could be established, and an\nadditional module could trap the exact SSL error and redirect to a page with the\nspecific error message (\"Your certificate is expired\", \"We cannot check the\nvalidity of the certificate - retry later\", etc.).\n\nI developed such a module, that I'll submit today: mod_ssl_error\n\nIn order to let the module trap the code, we need, when the module is loaded, to\naccept to establish the connection in case of a certificate validation error:\n\nIn ssl_io_filter_connect( ) - ssl_engine_io.c - we have 2 cases (at line 1147\nand 1173) where the connection may break because of certificates\nverification/validation problem:  ' return ssl_filter_io_shutdown(filter_ctx, c,\n1); '\n\nI would return only if the error trapping module (mod_ssl_error) is not loaded.\nIf it is loaded, I would accept the certificate (continue the treatment and\nreturn DECLINED), as the error will be trapped later.\nSo, replace\n    return ssl_filter_io_shutdown(filter_ctx, c, 1); \nby\n     if ( ! is_ssl_error_loaded ) return ssl_filter_io_shutdown(filter_ctx, c, 1); \n\nIn order to check if the module is loaded, I need a few lines at the beginning\nof the function - unless a function exists to check if a module is loaded ?\nCurrently I coded it in the function:\n    BOOL is_ssl_error_loaded = FALSE;\n    { /* Check if mod_ssl_error is loaded */\n        extern AP_DECLARE_DATA module *ap_top_module;\n        module *modp;\n        for ( modp = ap_top_module; modp; modp = modp->next )\n            if ( strcmp(modp->name, \"mod_ssl_error.c\") == 0 ) {\n                is_ssl_error_loaded = TRUE;\n                break;\n            }\n    }", "id": 75408, "time": "2005-05-26T10:09:52Z", "bug_id": 35083, "creation_time": "2005-05-26T10:09:52Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 35083, "is_private": false, "text": "I don't believe we should write something specific for your module (eg checking\nfor the exact name of your module).\n\nIf we want to provide this, I think we should look at integrating that module\nwith the core mod_ssl.  The other alternative is to just provide a configuration\ndirective to not return.  This might be the best way to go.\n\nSomething like:\n\nSSLFatalErrors Off\n\nThoughts?", "id": 75533, "time": "2005-05-27T21:05:47Z", "creator": "chip@force-elite.com", "creation_time": "2005-05-27T21:05:47Z", "attachment_id": null}, {"count": 2, "tags": [], "creator": "marc.stern@approach.be", "attachment_id": null, "text": "The best would obviously to integrate it with the core mod_ssl.\n\nThe main goal was to avoid a misconfiguration that would accept wrong\ncertificates; this could be the case with the directive.\n\nIf we want to keep the compatibility with the curretn version (SSL error not\nremapped), maybe the best would be to put my module in the standard distribution\nand check if it is loaded, no ? This ensures that non fatal errors are only\npassing when a module is loaded to trap them later.\n\nMaybe I'm too paranoiac ... or experienced ;-)", "id": 75584, "time": "2005-05-30T07:36:38Z", "bug_id": 35083, "creation_time": "2005-05-30T07:36:38Z", "is_private": false}, {"count": 3, "attachment_id": null, "creator": "marc.stern@approach.be", "text": "Addition to trap when no certif is sent (user hits Esc in browser):\n\n+ orig_verify_mode = filter_ctx->pssl->verify_mode;\n+ if ( sslErrorRedirected )\n+    filter_ctx->pssl->verify_mode &= ~SSL_VERIFY_FAIL_IF_NO_PEER_CERT;\n if ((n = SSL_accept(filter_ctx->pssl)) <= 0) {\n\n...\n\n verify_result = SSL_get_verify_result(filter_ctx->pssl);\n\n+ if ( orig_verify_mode != filter_ctx->pssl->verify_mode ) {\n+    verify_result = X509_V_ERR_CERT_REJECTED;\n+    sslconn->verify_error = X509_verify_cert_error_string(verify_result);\n+ }\n\n if ((verify_result != X509_V_OK) ||\n\n\nThe choice of X509_V_ERR_CERT_REJECTED as error is purely arbitrary, any better\none ?", "id": 75707, "time": "2005-06-01T10:21:39Z", "bug_id": 35083, "creation_time": "2005-06-01T10:21:39Z", "tags": [], "is_private": false}, {"count": 4, "tags": [], "bug_id": 35083, "is_private": false, "text": "Sorry, I forgot something.\nHere is the correct version:\n\n+ orig_verify_mode = filter_ctx->pssl->verify_mode;\n+ if ( sslErrorRedirected )\n+    filter_ctx->pssl->verify_mode &= ~SSL_VERIFY_FAIL_IF_NO_PEER_CERT;\n if ((n = SSL_accept(filter_ctx->pssl)) <= 0) {\n\n...\n\n verify_result = SSL_get_verify_result(filter_ctx->pssl);\n\n+ if ( (orig_verify_mode != filter_ctx->pssl->verify_mode) &&\n+      !filter_ctx->pssl->session->peer ) {\n+    verify_result = X509_V_ERR_CERT_REJECTED;\n+    sslconn->verify_error = X509_verify_cert_error_string(verify_result);\n+ }\n\n if ((verify_result != X509_V_OK) ||", "id": 75708, "time": "2005-06-01T11:15:22Z", "creator": "marc.stern@approach.be", "creation_time": "2005-06-01T11:15:22Z", "attachment_id": null}, {"count": 5, "tags": [], "bug_id": 35083, "attachment_id": null, "id": 78560, "time": "2005-08-17T04:20:52Z", "creator": "magnus@alum.mit.edu", "creation_time": "2005-08-17T04:20:52Z", "is_private": false, "text": "(In reply to comment #2)\n> The best would obviously to integrate it with the core mod_ssl.\n> \n\nI agree strongly.  The current behavior of mod_ssl is significantly broken for\nclient certificates.  "}, {"count": 6, "attachment_id": null, "creator": "jorton@redhat.com", "is_private": false, "id": 78568, "time": "2005-08-17T12:29:16Z", "bug_id": 35083, "creation_time": "2005-08-17T12:29:16Z", "tags": [], "text": "I'm not convinced this is necessary.  mod_ssl should be reporting errors at\nTLS-level for TLS-level problems like bad certs.  If browsers handle that badly\nthen fix the browsers.\n\nIf you do want custom HTML responses for cert validation problems, it should be\npossible already using \"SSLVerifyClient optional\" with SSLRequire and a custom\n403 errordoc.  What about the current code prevents that?  Possibly more\ninformation needs to be exported to get to the \"certificate has expired\" stuff.\n 2.1's SSL_CLIENT_V_REMAIN might be sufficient for that."}, {"text": "Joe,\n\n1. I do not think we could blame the browsers (at least not totally), because\nthey do not receive enough information to display a error complete mesage.\n\n2. Although Apache strictly follows the standards, its main goal is to be used\nby B2B-like clients, AND BROWSERS, no ?\nThere is no one browser that implements SSL error trapping in another way that\ngiving a technical error message or number\n\n3. In a lot of environments, the Web admin would like to give more information\nto the user about how to solve the connection problem. This is especially true\nin governmental sites: most of European countries (and several other ones) are\ndeploying identity smart card with national certificates that are intended to\nbare citizens that do not understand anything about certificates. The error\nmessage to be given is highly specific in this case.\n\n4. Although not stressed in the module description, the module also allows some\nreporting of errors in a way governmental applications like a lot: their\napplication can receive (and so handle/log) any connection failure with the\nexact reason. Again, for governmental certificates, this is highly important\nbecause of the OCSP SLA, etc.\nThis could be achieved in a separate application/script by analysing the logs,\nalthough the needed log level would probably generate to much data for a\nproduction environment.\n\n> If you do want custom HTML responses for cert validation problems, it should\n> be possible already using \"SSLVerifyClient optional\" with SSLRequire and\n> a custom 403 errordoc.\n> What about the current code prevents that?\n> Possibly more information needs to be exported to get to the\n> \"certificate has expired\" stuff.\n> 2.1's SSL_CLIENT_V_REMAIN might be sufficient for that.\nI tried, but couldn't do that (at least in 2.0.54). Revoked certificates are\naccepted and ther's no way to trap it.\nIf we could trap the errors without modifying med_ssl core, then it's obviously\nperfect. My module could thus be reimplemented to use that new\nSSL_CLIENT_V_REMAIN, is that correct ?\n", "tags": [], "bug_id": 35083, "attachment_id": null, "count": 7, "id": 79212, "time": "2005-08-31T09:31:46Z", "creator": "marc.stern@approach.be", "creation_time": "2005-08-31T09:31:46Z", "is_private": false}, {"count": 8, "attachment_id": null, "creator": "jorton@redhat.com", "text": "The specific configuration I'm talking about would be:\n\n  SSLVerifyClient optional_no_ca\n  SSLRequire %{SSL_VERIFY_CLIENT} eq \"SUCCESS\"\n  ErrorDocument 403 /bzzt.html\n\nbut, I guess for the case where the cert has been revoked by a CRL, or the cert\nhas expired, this is not sufficient, since the handshake will fail in those cases.\n\nSo the minimal enhancement that I think is acceptable is to have more\nfine-grained failure modes for SSLVerifyClient.  e.g.\n\n  SSLVerifyCLient optional_revoked\n  SSLVerifyClient optional_expired\n\nor something like that.  Maybe ideally it would be possible to combine such\noptions perhaps, allowing\n\n  SSLVerifyClient optional no_ca revoked expired\n\nor using a separate directive:\n\n  SSLVerifyClient optional\n  SSLVerifyIgnoreFailures no_ca revoked expired\n  \nI'm not sure about the best UI here.\n\nSo I think a patch for something like this would be acceptable and is the best\nway to implement this feature.  This is critical code and has a bad security\nhistory though so it needs to be done carefully.\n", "id": 79227, "time": "2005-08-31T12:33:22Z", "bug_id": 35083, "creation_time": "2005-08-31T12:33:22Z", "tags": [], "is_private": false}, {"count": 9, "tags": [], "text": ">   SSLVerifyClient optional_no_ca\n>   SSLRequire %{SSL_VERIFY_CLIENT} eq \"SUCCESS\"\n>   ErrorDocument 403 /bzzt.html\nHow would the application know about the exact status, in order to display a\nrelevant error message ?\nWhat is the reason for error 403: authorisation failure, certificate revocation,\ncertificate expiration ?\nCan the relevant info systematically be added to an environment variable ?\n\nIf you look the mod_ssl_error, it adds all information to GET data.\nMaybe a stupid question, but does the \"SSLVerifyClient optional\" directive add\nany added value to mod_ssl_error ? If not, couldn't we imagine to completely\nreplace this directive by mod_ssl_error which is more general ?", "is_private": false, "bug_id": 35083, "id": 79229, "time": "2005-08-31T12:56:43Z", "creator": "marc.stern@approach.be", "creation_time": "2005-08-31T12:56:43Z", "attachment_id": null}, {"count": 10, "tags": [], "bug_id": 35083, "attachment_id": null, "id": 79233, "time": "2005-08-31T15:08:15Z", "creator": "jorton@redhat.com", "creation_time": "2005-08-31T15:08:15Z", "is_private": false, "text": "Yes, put any required info into env vars so that an SSI page or whatever can\nretrieve that stuff directly.  The redirect-to-custom-URI-with-QUERY_URI thing\nused by mod_ssl_error is just a nasty hack; do it with env vars."}, {"count": 11, "tags": [], "text": "I would like to be sure to not introduce a security risk because of a bad\nconfiguration: suppose we use something like \"SSLVerifyClient optional_no_ca\"\nand trap the error by activating another directive; if the administrator removes\nthe error trapping, the certificate would be accepted.\nThis is obviously the administrator's fault, but you know about the security\nfailure principle.\nShouldn't we replace the check for \"SSLVerifyClient optional_no_ca ...\" by a\ncheck \"is error trapping activated\" ? Currently, the check controls if the\nmodule is loaded (thus activated), but we could imagine a general directive\n\"SSLTrapCertifErrors\".\n\nBtw, what was the original intend of the \"SSLVerifyClient  optional_no_ca\"\ndirective ? Is it really used ? Because, if we use it as a flag to trap the\nerror, we cannot use the \"old way\" anymore, so we break the compatibility.\n\nTo recap, does the following seem better:\n - we include the whole handling in mod_ssl (no external module)\n - we add a general directive \"SSLTrapCertifErrors\"\n - we put all extra info (error, DN, serial, ...) in environment variables\n\nIf you prefer a separate module, how to activate it in without either explicitly\npatching mod_ssl, or accepting all certrificates error in mod_ssl - which I find\ndangerous as explained above ?", "attachment_id": null, "bug_id": 35083, "id": 79425, "time": "2005-09-06T10:25:45Z", "creator": "marc.stern@approach.be", "creation_time": "2005-09-06T10:25:45Z", "is_private": false}, {"count": 12, "tags": [], "creator": "jorton@redhat.com", "attachment_id": null, "text": " - we include the whole handling in mod_ssl (no external module)\n\nI'm not sure what you mean by that.\n\n - we add a general directive \"SSLTrapCertifErrors\"\n\nI am OK with a new directive which allows the admin to relax certain SSL\ncertificate verification errors such as recovation status, expiry status, etc.\n\n - we put all extra info (error, DN, serial, ...) in environment variables\n\nYes.  DN and serial are already available in env vars of course.", "id": 79432, "time": "2005-09-06T13:45:36Z", "bug_id": 35083, "creation_time": "2005-09-06T13:45:36Z", "is_private": false}, {"count": 13, "attachment_id": null, "creator": "marc.stern@approach.be", "text": ">  - we include the whole handling in mod_ssl (no external module)\n> I'm not sure what you mean by that.\nI mean it becomes part of mod_ssl, it is not a separate module.\nTo be honest, I designed it as a module to have minimal impact on mod_ssl, in\norder to speed up acceptance - bad guess.\n\n>  - we add a general directive \"SSLTrapCertifErrors\"\n> I am OK with a new directive which allows the admin to relax certain SSL\n> certificate verification errors such as recovation status, expiry status, etc.\nThis does not relax anything, it just replaces a SSL error by a HTTP error (or a\ncustom page).\nIf needed, \"SSLVerifyClient optional_no_ca ...\" can still be used.\nIf it has any utility (?)", "id": 79441, "time": "2005-09-06T14:48:49Z", "bug_id": 35083, "creation_time": "2005-09-06T14:48:49Z", "tags": [], "is_private": false}, {"count": 14, "tags": [], "creator": "marc.stern@approach.be", "attachment_id": null, "is_private": false, "id": 82799, "time": "2005-11-24T11:13:44Z", "bug_id": 35083, "creation_time": "2005-11-24T11:13:44Z", "text": "While waiting for the best integration as requested, here is how to integrate it\ncorrectly with 2.0.54 (and probably above) - I added some other traps during\nrenegociation.\n\nmod_ssl.h: add\nextern int sslErrorRedirected;\n\nssl_engine_init.c: add\nint sslErrorRedirected = -1;\n\nin ssl_engine_io.c:\nat the beginning of ssl_io_filter_connect(): add\nif ( sslErrorRedirected == -1 ) { /* Check if mod_ssl_error is loaded */\n   extern AP_DECLARE_DATA module *ap_top_module;\n   module *modp;\n   sslErrorRedirected = FALSE;\n   for ( modp = ap_top_module; modp; modp = modp->next )\n      if ( strcmp(modp->name, \"mod_ssl_error.c\") == 0 ) {\n         sslErrorRedirected = TRUE;\n         break;\n      }\n}\n\nin ssl_engine_io.c:\nin ssl_io_filter_connect(), after\n   orig_verify_mode = filter_ctx->pssl->verify_mode;\n/* Accept if no certs are sent (user hits Esc) */\nif ( sslErrorRedirected ) filter_ctx->pssl->verify_mode &=\n~SSL_VERIFY_FAIL_IF_NO_PEER_CERT;\n\nin ssl_engine_io.c:\nin ssl_io_filter_connect(), replace\nif (ssl_verify_error_is_optional(verify_result) && ...) {\n   ...\n}\nelse {\n   return ssl_filter_io_shutdown(filter_ctx, c, 1);\n}\nby\nif (ssl_verify_error_is_optional(verify_result) && ...) {\n   ...\n}\nelse {\n   if ( sslErrorRedirected ) return APR_SUCCESS;\n   return ssl_filter_io_shutdown(filter_ctx, c, 1);\n}\n\n\nin ssl_engine_io.c:\nin ssl_io_filter_connect(), replace\nif ((sc->server->auth.verify_mode == SSL_CVERIFY_REQUIRE) && ... ){\n   return ssl_filter_io_shutdown(filter_ctx, c, 1);\n}\nby if ((sc->server->auth.verify_mode == SSL_CVERIFY_REQUIRE) && ... ){\n   if ( sslErrorRedirected ) return APR_SUCCESS;\n   return ssl_filter_io_shutdown(filter_ctx, c, 1);\n}\n\nin ssl_engine_kernel.c: replace\nSSL_do_handshake(ssl);\nif (SSL_get_state(ssl) != SSL_ST_OK) {\nby\nSSL_do_handshake(ssl);\nif (!sslErrorRedirected && SSL_get_state(ssl) != SSL_ST_OK) {\n\nin ssl_engine_kernel.c in ssl_hook_Access(): replace\nif (do_verify && (SSL_get_verify_result(ssl) != X509_V_OK)) {\n   ...\n   return HTTP_FORBIDDEN;\nby\nif (do_verify && (SSL_get_verify_result(ssl) != X509_V_OK)) {\n   ...\n   if (!sslErrorRedirected) return HTTP_FORBIDDEN;\n\nin ssl_engine_kernel.c in ssl_callback_SSLVerify():\nbefore\nif (!ok) {\n...\n}\n/*\n * And finally signal OpenSSL the (perhaps changed) state\n */\nreturn ok;\nadd\nif (sslErrorRedirected) ok = TRUE; /* MSTERN: SSL errors are trapped later */\n"}, {"count": 15, "attachment_id": null, "creator": "jorton@redhat.com", "is_private": false, "id": 82802, "time": "2005-11-24T11:36:17Z", "bug_id": 35083, "creation_time": "2005-11-24T11:36:17Z", "tags": [], "text": "I'm not sure what you're waiting for from anyone else, I thought we were agreed\non how to proceed here:\n\n1. add a new directive which allows the admin to selectively ignore SSL cert\nverification failures (per comment 8)\n\n2. add new env vars which describe the verification error and allow a custom 403\nerror page to explain the issue"}, {"count": 16, "tags": [], "bug_id": 35083, "text": "Creating env variables also solves point 4 from comment 7 as it can be covered\nby LogFormat's and conditional CustomLogs and if the application wants it /\nneeds it, it can fetch these too (at least inside httpd). So Joe's approach also\nsaves a lot of wheel reinvention here. ", "id": 82850, "time": "2005-11-24T22:57:31Z", "creator": "rpluem@apache.org", "creation_time": "2005-11-24T22:57:31Z", "is_private": false, "attachment_id": null}, {"count": 17, "tags": [], "creator": "marc.stern@approach.be", "attachment_id": 19457, "text": "Created attachment 19457\nPatch based on SSL_CVERIFY_OPTIONAL_NO_CA\n\nI extended SSL_CVERIFY_OPTIONAL_NO_CA usage to let the session establish,\nwhatever validation problems happen. This seems to me consistent with comments\nin teh code stating that this option should be used for testing purpose, so\neveryt certificate should be accepted. If I correctly understood,\n\"OPTIONAL_NO_CA\" should so be replaced everywhere by something like\n\"IGNORE_ERRORS\"; if not, we should add another option.", "id": 98501, "time": "2007-01-25T04:26:41Z", "bug_id": 35083, "creation_time": "2007-01-25T04:26:41Z", "is_private": false}, {"count": 18, "tags": [], "bug_id": 35083, "text": "What is the status of this request for enhancement ?\nI have use for this behaviour of optional_no_ca ?\n", "id": 120401, "time": "2008-09-05T08:31:13Z", "creator": "bdauvergne@entrouvert.com", "creation_time": "2008-09-05T08:31:13Z", "is_private": false, "attachment_id": null}, {"count": 19, "tags": [], "bug_id": 35083, "is_private": false, "text": "The patch is waiting for approval.\nGlad to see other people manifesting their interest ;-)\n\nI think the only real question before actually implementing it is to see if the \"legacy\" directive SSL_CVERIFY_OPTIONAL_NO_CA is still meaningful, or if we should replace it with something like SSL_IGNORE_ERRORS.\n\nOtherwise, I never got any problem report.\nIt runs in production for 3 years (18 months for latest patch) on dozens of Web sites, in a version published and supported by Belgian government for all agencies and private sector.\n\nNote that this is key differentiator compared to IIS and other servers.\nWouldn't it worth to integrate it ?", "id": 120489, "time": "2008-09-09T01:22:18Z", "creator": "marc.stern@approach.be", "creation_time": "2008-09-09T01:22:18Z", "attachment_id": null}, {"count": 20, "tags": [], "text": "Hello, is this being incorporated into mod_ssl and, if yes, what is the release schedule? Thanks, Paul", "attachment_id": null, "bug_id": 35083, "id": 136873, "time": "2010-05-14T16:20:27Z", "creator": "paul.rabinovich@exostar.com", "creation_time": "2010-05-14T16:20:27Z", "is_private": false}, {"count": 21, "tags": [], "text": "Any update to this? -- it's been 4 years since Stern added it (\"pending approval\") and 6 years since mod_ssl_error was offered up. \n\nAny pointers to alternate solutions?\n\nThanx", "attachment_id": null, "bug_id": 35083, "id": 148343, "time": "2011-08-02T21:47:32Z", "creator": "jazing@gmail.com", "creation_time": "2011-08-02T21:47:32Z", "is_private": false}, {"count": 22, "attachment_id": null, "creator": "eprost@orpheus.fr", "text": "I have the very same problem with revoked certificates as explained by comment 7: not being able to \"trap\" SSL errors in order to redirect to some sort of custom processing is very annoying.\n\nI have a business case where customer's security policy prescribes to log any failed login attempt and this includes revoked certificates. This can not be done.\n\nTested with 2.2.14 on Linux (+ checked 2.2.21 source code of modules/ssl/ssl_engine_kernel.c: as far as I remember C language, the problem is still there).\n\nTried with rewrite rules: doesn't work, connection attempt with revoked certificate is shutdown by mod_ssl and rules are not evaluated.\n\nRewriteEngine\ton\nRewriteCond\t%{SSL:SSL_CLIENT_VERIFY} !=SUCCESS\nRewriteRule\t.? /unsecure/bad-ssl.cgi [R,L]\n\nOne alternative would be to run a frontend before Apache, if that frontend is capable of better handling of SSL errors. Quite a heavy solution (+ more admin burden)... Another alternative would be to run SSL controls at the application layer, \"after\" Apache handles the request to Tomcat or whatever else. This would be ill-architected.\n\nIt would be great to be able to detect SSL errors (not only revoked certificates, one can think of out-dated CRLs also) in order to redirect those cases to some custom processing, with rewrite rules for example or whatever else that is under our responsability, not Apache's code.\n\nWilling to help in order to give \"additional information before it can be dealt\", Erik.\n\n\n\nPS: \"out-dated CRLs\" => see 2.2.21 ssl_engine_kernel.c line 2106: from what I understand (newbie to Apache source code...), if current date is greater than next update date stored in current CRL then all client certificates are rejected. This is kind of \"brute force\" if the admin forgets to update CRL before the \"next update\" date stored in the current CRL, or if a cron job fails, or whatever like this happens...", "id": 151326, "time": "2011-11-09T14:46:32Z", "bug_id": 35083, "creation_time": "2011-11-09T14:46:32Z", "tags": [], "is_private": false}, {"count": 23, "tags": [], "creator": "marc.stern@approach.be", "attachment_id": null, "is_private": false, "id": 151329, "time": "2011-11-09T15:28:17Z", "bug_id": 35083, "creation_time": "2011-11-09T15:28:17Z", "text": "The patch traps all validation errors, thus also expired CRL.\nWhat about the status NEEDINFO? This should be changed. Should I put back to NEW?"}, {"count": 24, "tags": [], "bug_id": 35083, "text": "(In reply to comment #23)\n> The patch traps all validation errors, thus also expired CRL.\n> What about the status NEEDINFO? This should be changed. Should I put back to\n> NEW?\n\nSorry, looks like I was not clear enough in my post: the described patch is ok and I wish it is already shipped to a stable version of Apache!\n\nErik", "id": 151331, "time": "2011-11-09T15:40:47Z", "creator": "eprost@orpheus.fr", "creation_time": "2011-11-09T15:40:47Z", "is_private": false, "attachment_id": null}, {"count": 25, "attachment_id": null, "creator": "bdauvergne@entrouvert.com", "text": "How does this patch compare to the one attached to #45922 ? This one does not change optional_no_ca behaviour and create a new option_no_verify which gives the permissive behaviour we are all looking for.", "id": 151361, "time": "2011-11-10T11:25:09Z", "bug_id": 35083, "creation_time": "2011-11-10T11:25:09Z", "tags": [], "is_private": false}, {"count": 26, "attachment_id": null, "creator": "marc.stern@approach.be", "text": "After a very quick browse, I think it totally supersedes mine.", "id": 151366, "time": "2011-11-10T12:58:59Z", "bug_id": 35083, "creation_time": "2011-11-10T12:58:59Z", "tags": [], "is_private": false}, {"count": 27, "tags": [], "text": "Obsolete with TLS1.2 that handles this in the TLS protocol", "is_private": false, "bug_id": 35083, "id": 192207, "time": "2016-07-07T12:01:41Z", "creator": "marc.stern@approach.be", "creation_time": "2016-07-07T12:01:41Z", "attachment_id": null}]