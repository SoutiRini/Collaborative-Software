[{"count": 0, "tags": [], "bug_id": 56190, "is_private": false, "id": 173489, "attachment_id": 31346, "creator": "fx@apache.org", "creation_time": "2014-02-26T13:52:07Z", "time": "2014-02-26T13:52:07Z", "text": "Created attachment 31346\nAsyncHelloServlet.java\n\nI am trying to use asynchronous servlets. It looks like whenever you call request.startAsync() keep-alive is disabled and the response is sent in chunked transfer encoding.\n\nI attached the code of a simple servlet. I get these headers in the response:\nHTTP/1.1 200 OK\nServer: Apache-Coyote/1.1\nTransfer-Encoding: chunked\nDate: Wed, 26 Feb 2014 13:25:29 GMT\n\nWith a regular blocking servlet I get:\nHTTP/1.1 200 OK\nServer: Apache-Coyote/1.1\nContent-Length: 11\nDate: Wed, 26 Feb 2014 13:49:17 GMT"}, {"count": 1, "tags": [], "bug_id": 56190, "attachment_id": null, "id": 173490, "time": "2014-02-26T13:53:01Z", "creator": "fx@apache.org", "creation_time": "2014-02-26T13:53:01Z", "is_private": false, "text": "I have the same issue with Tomcat 7.0.52"}, {"count": 2, "tags": [], "creator": "knst.kolinko@gmail.com", "attachment_id": null, "text": "> I get these headers in the response\n\nWith those headers you have keep-alive enabled (as that is default if nothing else is specified in an HTTP/1.1 response, per HTTP/1.1 specification).\n\nSo, what is your problem?\n\n>  response is sent in chunked transfer encoding\n\n\"Chunked encoding\" just means that response length was not know at the moment when response had to be sent to client. E.g. if output stream was flushed before closing the connection. Both are valid responses.", "id": 173510, "time": "2014-02-27T11:33:01Z", "bug_id": 56190, "creation_time": "2014-02-27T11:33:01Z", "is_private": false}, {"text": "This is as per the Servlet specification. The response has to committed when the async context is completed. At this point the response body may not be fully written so chunked encoding has to be used.", "tags": [], "creator": "markt@apache.org", "is_private": false, "count": 3, "id": 173512, "time": "2014-02-27T12:10:28Z", "bug_id": 56190, "creation_time": "2014-02-27T12:10:28Z", "attachment_id": null}, {"count": 4, "tags": [], "bug_id": 56190, "attachment_id": null, "id": 173535, "time": "2014-02-28T11:54:45Z", "creator": "fx@apache.org", "creation_time": "2014-02-28T11:54:45Z", "is_private": false, "text": "Thanks for your answers. I had a closer look at the specifications and there is no problem about the keep-alive header.\n\nAbout the \"Transfer-Encoding: chunked\" header, in my test I am just writing \"Hello world\" in the response (should be small enough for the buffer), there is no flush so when I call AsyncContext.complete() method  the content size is perfectly known and I would expect the server to set the content-length header and not to use chunked content encoding.\nAccording to servlet 3.0 specification \"The content length is automatically set if the entire response fits inside the response buffer.\"\nhttp://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServlet.html#doGet(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)\n\nJust to explain how I found this issue: I was doing some tests with Apache Benchmark. I was surprised to see that the performance of Tomcat were not good compared to other servlet containers, then I noticed that keep-alive was not working with tomcat while it was with other servlet containers like Jetty. It looks like ab disables keep-alive when the response is chunked."}, {"count": 5, "tags": [], "bug_id": 56190, "attachment_id": null, "id": 173536, "time": "2014-02-28T11:58:09Z", "creator": "markt@apache.org", "creation_time": "2014-02-28T11:58:09Z", "is_private": false, "text": "Please re-read comment#3"}, {"count": 6, "tags": [], "bug_id": 56190, "is_private": false, "id": 173537, "attachment_id": null, "creator": "fx@apache.org", "creation_time": "2014-02-28T12:07:58Z", "time": "2014-02-28T12:07:58Z", "text": "I did.\nI know the response is committed when you call AsyncContext.complete() but at this point the response body is fully written.\nThe specification is clear about that: \"Completes the asynchronous operation that was started on the request that was used to initialze this AsyncContext, closing the response that was used to initialize this AsyncContext.\"\n\nhttp://docs.oracle.com/javaee/6/api/javax/servlet/AsyncContext.html#complete()"}, {"count": 7, "tags": [], "text": "1. I agree that \"closing the response that was used to initialize this AsyncContext.\" seems to be missing from AsyncContextImpl.complete()\n\n[[[\n request.getCoyoteRequest().action(ActionCode.COMMIT, null);\n request.getCoyoteRequest().action(ActionCode.ASYNC_COMPLETE, null);\n clearServletRequestResponse();\n]]]\n\n\n2. It is unclear whether this \"commit\" and \"closing the response\" have to occur before firing onComplete() event or after it.\n\nIt it has to be committed before firing and closed after firing, you would get the chunked response.\n\nTo get a non-chunked response, one has to close the response without an explicit commit. Either (close before firing) or (non commit before firing + close after firing).\n\nI am reading that onComplete() is designed to allow cleanup of some resources, so I think that response can be closed before firing. (Though it will break applications that expect otherwise. Are there are any?)\n\n\n3. There is a workaround for your example:\nClose the response explicitly,\n[[[\n  response.getWriter().close()\n]]]\n\nYou should get a non-chunked response this way.", "is_private": false, "id": 173577, "creation_time": "2014-03-03T11:34:45Z", "time": "2014-03-03T11:34:45Z", "creator": "knst.kolinko@gmail.com", "bug_id": 56190, "attachment_id": null}, {"count": 8, "tags": [], "creator": "markt@apache.org", "attachment_id": null, "text": "I've been back and re-read both the Servlet 3.0 and Servlet 3.1 specifications. I don't know where I got the idea from that the response always had to be writable after the call to complete() but that is clearly wrong.\n\nThere is the requirement that when called before the container-initiated dispatch that called startAsync() has returned to the container then the complete() call doesn't take effect until after that thread returns but when it does take effect it still needs to close the response.\n\nI'll take a look at getting this fixed.\n\nThis might break some applications (it might even break some of our test cases) but the spec is clear on the required behavior so I think any such breakage is acceptable.", "id": 173645, "time": "2014-03-05T21:38:10Z", "bug_id": 56190, "creation_time": "2014-03-05T21:38:10Z", "is_private": false}, {"count": 9, "tags": [], "bug_id": 56190, "is_private": false, "id": 173656, "attachment_id": null, "creator": "markt@apache.org", "creation_time": "2014-03-06T09:31:06Z", "time": "2014-03-06T09:31:06Z", "text": "I have the first pass at a fix for this ready. The required changes are minimal but it breaks a lot of unit tests. The unit tests depend on being able to write to the response after the async complete. I need to implement an alternative solution for these tests."}, {"count": 10, "tags": [], "bug_id": 56190, "attachment_id": null, "is_private": false, "id": 173669, "time": "2014-03-06T15:59:36Z", "creator": "markt@apache.org", "creation_time": "2014-03-06T15:59:36Z", "text": "This has been fixed in 7.0.x for 7.0.53 onwards and in 8.0.x for 8.0.4 onwards."}, {"count": 11, "tags": [], "bug_id": 56190, "attachment_id": null, "id": 173821, "time": "2014-03-14T16:51:29Z", "creator": "fx@apache.org", "creation_time": "2014-03-14T16:51:29Z", "is_private": false, "text": "Thanks. I just tested. Everything works as expected now."}]