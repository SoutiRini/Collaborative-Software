[{"count": 0, "tags": [], "creator": "tforbis@dynalivery.com", "attachment_id": null, "is_private": false, "id": 61849, "time": "2004-08-11T18:05:23Z", "bug_id": 30603, "creation_time": "2004-08-11T18:05:23Z", "text": "Someone on the POI-user-list suggested this is the best way to submit code for \napproval.  I have included a description of the Ole format so others may modify \nmy code if necesary.\n\nDescription:\nAs I was reading MSWord files, I discovered that there no current POI APIs for \ndealing with the headers and footers in my document.  So I resolved to find out \na way to access them.  I looked that the files in a hex editor as well as read \nand outputted them to text through POI.  And to my surprise, the header and \nfooter are dealt with the same as tables: just like ordinary text.  After the \nend of the entire document there are eight paragraph, if you have a header or a \nfooter, they contain the text as follows ([ETX],,[EOT],,[ETX],,[EOT],).  For \nclarification, those are the unicode character 0003 (End of Text) and 0004 (End \nof Transmission) alternating with empty strings.  Then follows the text of the \nheader and the footers separated by a blank paragraph.  My first question after \nI found that out was this:  what if the header and footer is just a blank \nparagraph, how can you tell the difference?  The separator paragraphs contain \nno tabs, while the text contains two tab stops (which is beyond me, I just use \nit to my advantage).  The layout of the header and footers is as follows: \nHeaderOdd, HeaderEven, FooterOdd, FooterEven, HeaderFirst, FooterFirst; for \neach section.  If the section either does not have diffrent even/odd pages or \nfirst page, then these are skipped.  For example, a document with three normal \nsections would have the same number of \"feet\" (as I called them because they \ncame at the end of the document) as a document with one section with different \nfirst and odd/even pages.  By using the other data in the section properties, \nyou can establish which \"feet\" go where in your document.\nThe class that i created just makes an array of feet based on the structure I \nexplained above.  It doesn't know the section properties, so it treats them all \nthe same.  It then also includes an iterator and functions for moving forward \nand backwards, as well as direct access if that is the preferred method.  I \nalso modified the Range.java file to accept this type of \"Range.\"  I based the \nfunction off the one for the table in which you pass it the first paragraph \nthat is part of the Footer (which I classified as the one that contains [ETX]).\nI will admit that this code is nowhere perfect, but I think that it is a good \nstart towards making POI more Word-complete.  If you have any questions or \ncomments, feel free to reply.\n\nCODE:\npackage org.apache.poi.hwpf.usermodel;\n\npublic class Footer\n  extends Range\n{\n  /**\n   * is the footer of the word document\n   * this contains all the header / footer information for a word document\n   * it will go through and make an array of ranges that contains the text of \nthese\n   * usig the iterator, one can cycle through the sections of the document and\n   * put i the appropiate headers where they belong.\n   * The storing format is in order of sections and then by:\n   *   Header for section\n   *   Footer for section\n   *   Header for First page\n   *   Footer for First Page\n   * This class currently does not have settings for odd and even page \nheaders/footers\n   *\n   * @author Tim Forbis\n   */\n    \n  /**\n   *\n   * number of \"feet\" in this footer.\n   * it is the number total number of headers and footers in the document\n   */\n  private int numFeet;\n  \n  /**\n   * used to cycle through theheaders and footers.\n   * 0: represents the first one in list\n   * numFeet-1: represents last one in array\n   */\n  private int iterator;\n  \n  /**\n   * array of these feet.\n   * each one is a full range that contains the paragraphs of the header/footer.\n   * this \"foot\" can be treated the same as any pother range as far as \nformatting and\n   * treatment in a client.\n   */\n  private Range[] Foot;\n  \n   \n  Footer(int startIdx, int endIdx, Range parent, int levelNum)\n  {\n    super(startIdx, endIdx, Range.TYPE_PARAGRAPH, parent);\n    int Start, End, i=0;\n    int[] FootStart = new int[parent.numSections()*6];\n    int[] FootEnd = new int[parent.numSections()*6];\n    for (int j=0; j<parent.numSections()*6; j++)\n    {\n        FootStart[j]=0;\n        FootEnd[j]=0;\n    }\n    int numParagraphs = numParagraphs();\n    if (this.getParagraph(0).getCharacterRun(0).text().startsWith(\"\\u0003\"))\n    {\n      Start=8;\n      this.initAll();\n      End=Start+1;\n      int limit = _paragraphs.size();\n      if (this.getParagraph(Start).getTabList().length==0)\n      {\n        //there is a footer, but it has no data\n        numFeet=-1;\n      }\n      else\n      {\n        do\n        {\n            for (; End < limit; End++)\n            {\n                // one paragraph without any tabs is a delimitor between the \nseparate feet\n                //the word document records two tabs in each header / footer; \nno purpose that i can see\n            //if ((this.getParagraph(End+1).text()).length()<=1)\n            if (this.getParagraph(End+1).getTabList().length==0)\n            {\n                break;\n            }\n            }\n            FootStart[i]=Start;\n            FootEnd[i]=End;\n            Start=End;\n            End=Start+1;\n            i++;\n            //three \"empty\" (without tab stops listed) is the delimintator for \nthe end of the document\n        //} while (!((this.getParagraph(End-2).getTabList().length==0)&&\n(this.getParagraph(End).getTabList().length==0)&&(this.getParagraph(End-\n1).getTabList().length==0)));\n        } while (!(this.getParagraph(End-2).text().length()<2 && \nthis.getParagraph(End-1).text().length()<2 && this.getParagraph(End).text\n().length()<2));\n        numFeet=i;\n        Foot=new Range[numFeet];\n        for (int k=0; k<numFeet; k++)\n        {\n            Foot[k]=new Range(FootStart[k], FootEnd[k], TYPE_PARAGRAPH, this);\n        }\n        iterator=0;\n      }\n    }   \n  }\n  \n  /**\n   * @return number of header/footers in the document foot\n   * to be used in <code>for</code> loop\n   */\n  public int numFeet()\n  {\n    return numFeet;\n  }\n  \n  public int curFoot()\n  {\n    return iterator+1;\n  }\n  \n  /**\n   * get a specific foot in the document given an index\n   * used in <code>for</code> loop\n   *\n   * @param int index = location of foot\n   * @return Range Foot\n   */\n  public Range getFoot(int index)\n  {\n    if ((index>=numFeet)||(index<=0))\n    {\n       throw new ArrayIndexOutOfBoundsException(\"Index outside of bounds of \nFooter\");\n    }\n    else\n    {\n        return Foot[index];\n    }\n  }\n  \n  \n  \n  /**\n   * get the foot that the iterator is curently pointed at\n   * to be used in a <code>do-while</code> loop\n   *\n   * @return Range Foot\n   */\n  public Range getFoot()\n  {\n    if (iterator>=numFeet)\n    {\n       throw new ArrayIndexOutOfBoundsException(\"Index outside of bounds of \nFooter\");\n    }\n    else\n    {\n        return Foot[iterator];\n    }\n  }\n  \n  /**\n   * start the count over at zero, and guarantee that you are at the first \nheader\n   */\n  public void MoveFirst()\n  {\n    iterator=0;\n  }\n  \n  /**\n   * increment the iterator, so that it is point at the next one in line\n   * to be used in a <code>do-while</code> loop\n   */\n  public void MoveNext()\n  {\n    iterator++;\n  }\n  \n  /**\n   * decrement the iterator, so that it is point at the previous one in line\n   * to be used in a <code>do-while</code> loop\n   */\n  public void MovePrevious()\n  {\n    iterator--;\n  }\n  \n  /**\n   * point at the last header in the list\n   */\n  public void MoveLast()\n  {\n    iterator=numFeet-1;\n  }\n\n  /**\n   * @return is End of Foot\n   */\n  public boolean EOF()\n  {\n    return (iterator==numFeet);\n  }\n  \n}"}, {"count": 1, "tags": [], "text": "Created attachment 12396\ncode", "is_private": false, "bug_id": 30603, "id": 61850, "time": "2004-08-11T18:06:08Z", "creator": "tforbis@dynalivery.com", "creation_time": "2004-08-11T18:06:08Z", "attachment_id": 12396}, {"count": 2, "tags": [], "text": "Thanks for that, Tim.\n\nIt is usual when posting code into bugzilla to prefix the subject line with \n[PATCH] so that people can see there is code in your submission rather than \njust a bug report.\n\nI'll look at the existing code and see how this fits into the overall scheme of \nthings.\n\nRegards,\n         Piers", "is_private": false, "bug_id": 30603, "id": 61912, "time": "2004-08-12T18:48:38Z", "creator": "apachedev@2vu.com", "creation_time": "2004-08-12T18:48:38Z", "attachment_id": null}, {"count": 3, "tags": [], "creator": "apachedev@2vu.com", "attachment_id": null, "id": 62090, "time": "2004-08-17T21:19:21Z", "bug_id": 30603, "creation_time": "2004-08-17T21:19:21Z", "is_private": false, "text": "Hi Tim,\n\nI've checked out the Word 97 file format and Headers and Footers are stored in \ntheir own structure. I know Range is returning them, but it looks like it \nshouldn't. HWPF obviously needs to have the Header Footer structure added to \nits user model and Range needs to be changed to prevent it returning Headers \nand Footers as part of the normal Text ranges.\n\nWould you be interested in looking into writing the class that handles word's \ninternal Header Footer structure (the plcfhdd)? You can find copied of the word \n97 file format spec at http://www.wotsit.org/search.asp?s=text\n\nIf you are interested, please let me know. (Apache will need you to sign a CLA).\n\nBest regards,\n                Piers"}, {"count": 4, "tags": [], "creator": "robert-francois.pastor@cegetel.net", "attachment_id": null, "id": 108231, "time": "2007-09-15T11:56:22Z", "bug_id": 30603, "creation_time": "2007-09-15T11:56:22Z", "is_private": false, "text": "(In reply to comment #1)\n> Created an attachment (id=12396) [edit]\n> code\n\nDear Tim,\nI have imported your code for the Footer but it raises an error: in\nif (this.getParagraph(Start).getTabList().length==0)\nMethod getTabList undefined for the type Paragraph.\nI am using POI 3.0\nCheers\nRobert"}, {"count": 5, "tags": [], "creator": "domenico.napoletano@exprivia.it", "attachment_id": null, "is_private": false, "id": 118864, "time": "2008-07-21T03:29:37Z", "bug_id": 30603, "creation_time": "2008-07-21T03:29:37Z", "text": "(In reply to comment #4)\n> (In reply to comment #1)\n> > Created an attachment (id=12396) [edit] [details]\n> > code\n> \n> Dear Tim,\n> I have imported your code for the Footer but it raises an error: in\n> if (this.getParagraph(Start).getTabList().length==0)\n> Method getTabList undefined for the type Paragraph.\n> I am using POI 3.0\n> Cheers\n> Robert\n\nTo compile this code, if getTabsList().length refers (maybe?) to list of tabs in paragraph, could it be replaced with\n\ncloneProperties().getRgdxatab().length\n\nwhich contains the length of tab positions (and then of tabs)?\n\n"}, {"count": 6, "tags": [], "bug_id": 30603, "is_private": false, "id": 119676, "attachment_id": null, "creator": "apache@gagravarr.org", "creation_time": "2008-08-11T04:36:00Z", "time": "2008-08-11T04:36:00Z", "text": "There's now code in svn to handle headers and footers in hwpf. It parses the PlcfHdd to figure out which parts of the HeaderStories range contain what"}]