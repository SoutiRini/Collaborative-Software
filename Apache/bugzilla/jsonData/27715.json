[{"count": 0, "tags": [], "bug_id": 27715, "is_private": false, "text": "Some clients (for ex.: wap browser in motorola phone) insert spaces around \"=\"\nin \"Range:\" header, and send something like \"Range: bytes = 0-100\", but apache\nunderstands that header only if it's written without this spaces.\nApache 2.0 has the same bug.", "id": 54085, "time": "2004-03-16T16:32:59Z", "creator": "ulanov@rt.mipt.ru", "creation_time": "2004-03-16T16:32:59Z", "attachment_id": null}, {"count": 1, "tags": [], "bug_id": 27715, "attachment_id": null, "text": "That is a possible patch:\n--- apache_1.3.29/src/main/http_protocol.c.old  2004-03-16 18:59:27.000000000 +0300\n+++ apache_1.3.29/src/main/http_protocol.c      2004-03-16 19:01:08.000000000 +0300\n@@ -303,10 +303,12 @@\n     if (!(range = ap_table_get(r->headers_in, \"Range\")))\n         range = ap_table_get(r->headers_in, \"Request-Range\");\n\n-    if (!range || strncasecmp(range, \"bytes=\", 6)) {\n+    if (range && strncasecmp(range, \"bytes=\", 6)==0)\n+        range += 6;\n+    if (range && strncasecmp(range, \"bytes = \", 8)==0)\n+        range += 8;\n+    else\n         return 0;\n-    }\n-    range += 6;\n\n     /* Check the If-Range header for Etag or Date.\n      * Note that this check will return false (as required) if either\n", "id": 54086, "time": "2004-03-16T16:34:50Z", "creator": "ulanov@rt.mipt.ru", "creation_time": "2004-03-16T16:34:50Z", "is_private": false}, {"count": 2, "tags": [], "bug_id": 27715, "is_private": false, "text": "  In 14.35.1 of RFC2616 I'm not seeing it...\n\n       ranges-specifier = byte-ranges-specifier\n       byte-ranges-specifier = bytes-unit \"=\" byte-range-set\n       byte-range-set  = 1#( byte-range-spec | suffix-byte-range-spec )\n       byte-range-spec = first-byte-pos \"-\" [last-byte-pos]\n       first-byte-pos  = 1*DIGIT\n       last-byte-pos   = 1*DIGIT\n\n  But in the be liberal in what you parse, strict in what you send, I'd\n  accept LWS parsing within Range tags.  Other comments?\n\n  I've reclassed as a 2.0 bug to draw attention and interest :)", "id": 54091, "time": "2004-03-16T18:02:54Z", "creator": "wrowe@apache.org", "creation_time": "2004-03-16T18:02:54Z", "attachment_id": null}, {"count": 3, "tags": [], "bug_id": 27715, "is_private": false, "text": "+1 to change it in 2.1.", "id": 63004, "time": "2004-09-03T03:10:46Z", "creator": "chip@force-elite.com", "creation_time": "2004-09-03T03:10:46Z", "attachment_id": null}, {"count": 4, "tags": [], "bug_id": 27715, "attachment_id": null, "id": 81476, "time": "2005-10-20T19:14:27Z", "creator": "rcritten@redhat.com", "creation_time": "2005-10-20T19:14:27Z", "is_private": false, "text": "The space parsing problem also affects how the range is determined. If one\nspecifies a negative range like -10, to fetch the last 10 bytes, and it is\npreceeded by a space, the current code treats the space as a 0 so instead of the\nlast 10 bytes, you get the first 10. \n\nSo this request:\n\nGET /small.html HTTP/1.1\nHost: localhost\nRange: bytes= -10\nConnection: close\n\nreturns bytes 0-9 instead of the the last 10.\n\nA patch to fix both issues is:\n\n--- http_protocol.c.orig        2005-10-20 11:54:44.000000000 -0400\n+++ http_protocol.c     2005-10-20 11:55:57.000000000 -0400\n@@ -3033,7 +3033,8 @@\n \n static int ap_set_byterange(request_rec *r)\n {\n-    const char *range;\n+    const char *tmphdr;\n+    char *range;\n     const char *if_range;\n     const char *match;\n     const char *ct;\n@@ -3053,8 +3054,14 @@\n      * Navigator 2-3 and MSIE 3.\n      */\n \n-    if (!(range = apr_table_get(r->headers_in, \"Range\"))) {\n-        range = apr_table_get(r->headers_in, \"Request-Range\");\n+    if (!(tmphdr = apr_table_get(r->headers_in, \"Range\"))) {\n+        tmphdr = apr_table_get(r->headers_in, \"Request-Range\");\n+    }\n+\n+    range = NULL;\n+    if (tmphdr) {\n+        range = apr_palloc(r->pool, strlen(tmphdr));\n+        apr_collapse_spaces(range, tmphdr);\n     }\n \n     if (!range || strncasecmp(range, \"bytes=\", 6) || r->status != HTTP_OK) {"}, {"count": 5, "tags": [], "bug_id": 27715, "attachment_id": null, "text": "Reconsidering 14.35.1 Byte Ranges in RFC2616, and looking at the recent issues\nwith request/response splitting/spoofing;\n\n-1 on any patch to permit this grammer, however in comment 4 we have a clear\nissue, we can't be treating empty space as a zero-value.\n\nTherefore, we should treat the invalid characters (any of them, including\nunpermited lws) as a flaw.  Now, back to the original report, how to handle.\n\nI suggest we treat any flawed bytes= sequence as a noop, unset the corresponding\ninput Range/IfRange header, and provide the complete response.  The broken\nclient will need to be fixed (it sucks down more data than it intended) but it\nshould be aware of servers which don't support [it's broken] range syntax, and\ntherefore even the broken client shouldn't fail.\n\nSorry if I led in the opposite direction nearly 2 years ago, but in hindsite,\nallowing invalid grammer proved to be the fatal flaw in the entire class of\nproxy splitting vulnerabilities, since each server was 'differently permissive'\nand their permissive and strict interpretations of the headers clashed.", "id": 81479, "time": "2005-10-20T20:28:04Z", "creator": "wrowe@apache.org", "creation_time": "2005-10-20T20:28:04Z", "is_private": false}, {"count": 6, "tags": [], "bug_id": 27715, "attachment_id": null, "text": "The current code is not compliant with 2616 since it doesn't allow the implied\nLWS.  I cannot imagine why you'd say that *fixing* a 2616 compliance issue could\ncreate a security issue.  (nor how any particular interpretation of the Range\nheader would create a security issue in the first place)\n\nPatch looks fine to me.", "id": 81498, "time": "2005-10-21T09:35:35Z", "creator": "jorton@redhat.com", "creation_time": "2005-10-21T09:35:35Z", "is_private": false}, {"count": 7, "tags": [], "text": "Note on Joe's comment, '-' is -NOT- defined as a seperator, so I agree that\nimplied *LWS permits 'bytes = 500-600,601-999' ... or 'bytes=500-600 , 601-999'\n\nBut implied *LWS apparenty does not permit 'bytes=500 - 600,601 - 999' as the\nminus symbol/dash is not in the list of 'seperators' defined by RFC 2616.", "is_private": false, "id": 81535, "creator": "wrowe@apache.org", "time": "2005-10-21T20:06:35Z", "bug_id": 27715, "creation_time": "2005-10-21T20:06:35Z", "attachment_id": null}, {"count": 8, "tags": [], "bug_id": 27715, "attachment_id": null, "text": "So what problem is created in following the usual \"be liberal in what you\naccepte\" rule and stripping all whitespace?  What security issues are you\ntalking about above?", "id": 81695, "time": "2005-10-25T12:27:46Z", "creator": "jorton@redhat.com", "creation_time": "2005-10-25T12:27:46Z", "is_private": false}, {"count": 9, "tags": [], "bug_id": 27715, "is_private": false, "text": "The grammar is already liberal, as you and I agreed.  I'm noting only the one\nspecific exclusion.\n\nAfter the Watchfire paper, forgive me for being a bit more paranoid about\nbeing excessively liberal with input.  Unless we care to canonicalize the\ninput, if it can be passed through the proxy, we should stick to RFC2616.\n\n+1 on fixing the implied LWS where permitted, which is everywhere except between\ndigits, or between the digits and the hyphen.\n", "id": 81719, "time": "2005-10-25T17:42:51Z", "creator": "wrowe@apache.org", "creation_time": "2005-10-25T17:42:51Z", "attachment_id": null}]