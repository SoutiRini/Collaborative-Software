[{"count": 0, "tags": [], "bug_id": 55912, "text": "apr_file_pipe_create_ex creates a pipe with a unique name:\n\nfile_io/win32/pipe.c :\n\nstatic unsigned long id = 0;\n[...]\nsprintf(name, \"\\\\\\\\.\\\\pipe\\\\apr-pipe-%u.%lu\", getpid(), id++);\n\n(*in)->filehand = CreateNamedPipe(name,\n\tdwOpenMode,\n\tdwPipeMode,\n[...]\n\nThis code is not reliable in multilthread (id++ is not an atomic operation): two threads can increment id at the same time.\nAs a result, the second creation fails: CreateNamedPipe returns INVALID_HANDLE_VALUE and sets the error to ERROR_PIPE_BUSY (the first pipe was already created and it still exists in most cases).\n\nThe testcase is complicated: the request server must be under heavy load (the error was triggered around the 988000th request to a CGI script (which was checking its stdin validity)).\n\nI think that replacing \"id++\" by a call to \"InterlockedIncrement\" fixes the issue.\nInterlockedIncrement is available for all the Windows versions from Windows 95 (at least).\nInterlockedIncrement is not strictly equivalent to \"id++\": InterlockedIncrement is equivalent to \"++id\", but it actually means that no pipe is created with the id 0.", "id": 171831, "time": "2013-12-19T14:34:59Z", "creator": "gzahm@wanadoo.fr", "creation_time": "2013-12-19T14:34:59Z", "is_private": false, "attachment_id": null}]