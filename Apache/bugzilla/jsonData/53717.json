[{"count": 0, "tags": [], "bug_id": 53717, "attachment_id": 29226, "id": 161368, "time": "2012-08-14T14:25:09Z", "creator": "jodeen@gmail.com", "creation_time": "2012-08-14T14:25:09Z", "is_private": false, "text": "Created attachment 29226\nSample client showing buffering\n\nIt appears that tomcat 7.0.29 under Java 1.6.0_33 is operating a bit strangely in how it is buffering SSL responses (and differently from 1.6.0_25). \n\nI have a web app that just has a single servlet that outputs a few thousand characters of data (in valid html). Tomcat is set up to use the Http11NioProtocol connector and a self-signed certificate. \n\nIf I try using a SSLSocket to read the data from the page every other chunk of the data will have only a single byte, followed by a normal sized chunk.  The client just uses the normal OutputStream.read function passing in a large buffer (source attached).\n\nSample Output-------------\nCount of Bytes Read: 16384\nData:HTTP/1.1 200 OK\nSer--SNIP--defabcdefabcdefabcde\n\nCount of Bytes Read: 1\nData: f\n\nCount of Bytes Read: 275\nData:abcdefabcdefabcdefab--SNIP--cdefabcdefabcdefabcd\n\nCount of Bytes Read: 1\nData: e\n\nCount of Bytes Read: 1666\nData:fabcdefabcdefabcdefa--SNIP--y>\n</html>\n\nThis behavior only happens with the secure connector.  If use a non-secure connector, the chunks are all sized similarly. \n\nThis is different from the behavior when tomcat is running using 1.6.0_25.  Under that version, the chunks appear to be normally-sized (no 1-byte chunks).\n\nI've attached a sample client that uses a SSLSocket to connect directly to tomcat and show how the buffering is working. I've confirmed that the version of the client doesn't matter, the same issue happens regardless of whether I'm using 1.6.0_25 or 1.6.0_33"}, {"count": 1, "tags": [], "bug_id": 53717, "attachment_id": null, "text": "I can reproduce this. Debugging the NIO code shows that the splitting into a single byte and remaining bytes happens in JRE code. I am likely to resolve this as INVALID but I want to double check the JRE code first.", "id": 161534, "time": "2012-08-20T11:46:00Z", "creator": "markt@apache.org", "creation_time": "2012-08-20T11:46:00Z", "is_private": false}, {"count": 2, "tags": [], "creator": "markt@apache.org", "text": "I have traced this behaviour to the following:\nhttp://hg.openjdk.java.net/jdk7u/jdk7u6-gate/jdk/diff/14d8cc19f227/src/share/classes/sun/security/ssl/AppOutputStream.java\n\nSwitching to TLSv1.1 or later reduces the problem but even switching to TLSv1.2 (available in Java 7) doesn't eliminate the problem entirely. There are still a handful of small reads.\n\nI haven't dug into this too much but this is definitely a JRE feature. It may also be a side-effect of something the JRE has to do as part of the SSL/TLS implementation. Generally, it appears the is.read() on a secure connection will only ever read a single SSL data record even if multiple records are available to read. I'd expect records to be read until the internal buffer was full.\n\nAnyway, this is not a Tomcat problem.", "id": 161688, "time": "2012-08-24T21:28:43Z", "bug_id": 53717, "creation_time": "2012-08-24T21:28:43Z", "is_private": false, "attachment_id": null}]