[{"count": 0, "tags": [], "text": "I just saw this when compiling with clang on Mac OS X (partially because clang shows all warnings and errors in BIG BOLD SUPER HIGHLIGHTED TEXT!):\n\nsrc/jnilib.c:130:11: warning: comparison of unsigned expression < 0 is always\n      false [-Wtautological-compare]\n    if (l < 0)\n        ~ ^ ~\n1 warning generated.\n\nI checked, and the function [jstring tcn_new_stringn(JNIEnv *env, const char *str, size_t l)] accepts an argument of size_t and then checks to see if it is less than 0. Since it's unsigned, it will never be negative.\n\nI checked, and this function is not even used in the tcnative library itself.\n\nLooking at similar functions, I can see that tcn_new_stringn actually checks the Java runtime to see if new references can be created in the local scope and fails if it can't. The other similar functions do not do such checking, and are therefore fragile.\n\nI think it makes sense to review these functions to decide what functions to eliminate (e.g. tcn_new_stringn) and to what extent will the code in tcnative do diligent sanity checking rather than letting the runtime fail in various ways.", "is_private": false, "id": 177297, "creator": "chris@christopherschultz.net", "time": "2014-08-21T19:04:18Z", "bug_id": 56878, "creation_time": "2014-08-21T19:04:18Z", "attachment_id": null}, {"count": 1, "tags": [], "creator": "knst.kolinko@gmail.com", "is_private": false, "id": 177298, "creation_time": "2014-08-21T20:15:22Z", "time": "2014-08-21T20:15:22Z", "bug_id": 56878, "text": "(In reply to Christopher Schultz from comment #0)\n> I just saw this when compiling with clang on Mac OS X (partially because\n> clang shows all warnings and errors in BIG BOLD SUPER HIGHLIGHTED TEXT!):\n> \n> src/jnilib.c:130:11: warning: comparison of unsigned expression < 0 is always\n>       false [-Wtautological-compare]\n>     if (l < 0)\n>         ~ ^ ~\n> 1 warning generated.\n> \n> I checked, and the function [jstring tcn_new_stringn(JNIEnv *env, const char\n> *str, size_t l)] accepts an argument of size_t and then checks to see if it\n> is less than 0. Since it's unsigned, it will never be negative.\n\nWhat header defines size_t ? Is it platform-dependent?\n\nPassing \"-1\" as a size might be a valid use case (in theory).\n\nBTW, the \"len\" local variable is cast to (jsize) on one line and to (jint) on another.\n\n> Looking at similar functions, I can see that tcn_new_stringn actually checks\n> the Java runtime to see if new references can be created in the local scope\n> and fails if it can't. The other similar functions do not do such checking,\n> and are therefore fragile.\n\nThe only other function that calls DeleteLocalRef there (tcn_get_string) has such check. I do not think anything is fragile there.\n\nDocumentation for \"EnsureLocalCapacity\" [1] says that JVM does not enforce the limit, but allocates references beyond the ensured capacity.\n\nI think the EnsureLocalCapacity call here just makes it to produce a nice explicit OutOfMemoryError instead of a NULL return value. I think that it wouldn't become fragile if EnsureLocalCapacity call is omitted, because on the following lines all function that allocate objects are checked for returning a NULL value.\n\nBTW, comparing \"tcn_new_stringn\" and \"tcn_new_string\" implementations,\nthere is subtle difference between them:\n- the \"tcn_new_string\" method calls \"NewStringUTF\" (so it uses \"modified\" UTF-8 used by Java),\n- the \"tcn_new_stringn\" method copies C chars into a byte array and uses platform encoding to convert them into Java characters.\n\nWhat approach is the correct one depends on where the char* data came from.\n\n[1] http://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/functions.html#global_local\n[2] http://stackoverflow.com/questions/7081853/jni-ensurelocalcapacity-why", "attachment_id": null}, {"count": 2, "tags": [], "creator": "chuck.caldarale@unisys.com", "attachment_id": null, "id": 177299, "creation_time": "2014-08-21T20:40:01Z", "time": "2014-08-21T20:40:01Z", "bug_id": 56878, "text": "(In reply to Konstantin Kolinko from comment #1)\n> What header defines size_t ? Is it platform-dependent?\n> \n> Passing \"-1\" as a size might be a valid use case (in theory).\n\nNo, size_t is defined to be unsigned by the C and C++ standards.  The range of values supported is platform-dependent, but they are always zero or positive.", "is_private": false}, {"count": 3, "tags": [], "bug_id": 56878, "attachment_id": null, "is_private": false, "id": 186180, "time": "2015-11-02T11:16:11Z", "creator": "markt@apache.org", "creation_time": "2015-11-02T11:16:11Z", "text": "Fixed ~9 months ago in r1650304."}]