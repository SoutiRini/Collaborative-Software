[{"count": 0, "tags": [], "bug_id": 45060, "attachment_id": null, "id": 116895, "time": "2008-05-22T04:17:02Z", "creator": "cpuidle@gmx.de", "creation_time": "2008-05-22T04:17:02Z", "is_private": false, "text": "This is a follow-on issue to bug 45041. \n\nThe following example creates a sheet with\ntwo rows as input data for the final formula in row 3. The formula produces a #VALUE error\nin excel (tested on poi 3.1beta).\nVisually the formula in Excel appears ok. Just pressing\n\"Enter\" in the formula field again fixes the problem and field displays a value. It seems\nExcel is correcting the formula in the background- visually it does not change by this\nprocess.\n\nimport java.io.*;\nimport java.util.*;\n\nimport org.apache.poi.hssf.usermodel.*;\n\npublic\nclass Test\n{\n\tstatic int row = 0;\n\n\tstatic HSSFSheet sheet;\n\n\tstatic HSSFCellStyle\nxlsDateStyle, xlsNumericStyle, xlsPercentStyle;\n\n\t/**\n\t * @param args\n\t * @throws\nException \n\t */\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tFileOutputStream\nout = new FileOutputStream(\"d:\\\\test.xls\");\n\t\tHSSFWorkbook wb = new HSSFWorkbook();\n\n\t\tsheet\n= wb.createSheet(\"test\");\n\n\t\t// Excel-formatted date object\n\t\txlsDateStyle = wb.createCellStyle();\n\t\txlsDateStyle.setDataFormat(wb.createDataFormat().getFormat(\"dd.mm.yyyy\"));\n\t\t\n\t\t//\nExcel-formatted number\n\t\txlsNumericStyle = wb.createCellStyle();\n\t\txlsNumericStyle.setDataFormat(wb.createDataFormat().getFormat(\"0.00\"));\n\t\t\n\t\t//\nExcel-formatted percent object\n\t\txlsPercentStyle = wb.createCellStyle();\n\t\txlsPercentStyle.setDataFormat(wb.createDataFormat().getFormat(\"0.00%\"));\n\n\t\taddRow(new\nDate(0, 0, 1), 100.0);\n\t\taddRow(new Date(1, 0, 1), -110.0);\n\n\t\tHSSFRow r = sheet.createRow(row++);\n\n\t\t//\ncreate the IRR formula\n\t\tshort col = 2;\n\t\tHSSFCell c = r.createCell(col++);\n\t\tc.setCellStyle(xlsPercentStyle);\n\t\tc.setCellType(HSSFCell.CELL_TYPE_FORMULA);\n\t\tc.setCellFormula(\"(1+IRR(SUMIF(A:A,ROW(INDIRECT(MIN(A:A)&\\\":\\\"&MAX(A:A))),B:B),0))^365-1\");\n\n\t\twb.write(out);\n\t\tout.close();\n\t}\n\n\tprivate\nstatic void addRow(Date date, double d)\n\t{\n\t\tHSSFRow r = sheet.createRow(row++);\n\n\t\tshort\ncol = 0;\n\t\tHSSFCell c = r.createCell(col++);\n\t\tc.setCellValue(date);\n\t\tc.setCellStyle(xlsDateStyle);\n\n\t\tc\n= r.createCell(col++);\n\t\tc.setCellValue(d);\n\t\tc.setCellStyle(xlsNumericStyle);\n\t}\n}"}, {"count": 1, "tags": [], "creator": "cpuidle@gmx.de", "attachment_id": 21987, "text": "Created attachment 21987\ntest case", "id": 116896, "time": "2008-05-22T04:17:33Z", "bug_id": 45060, "creation_time": "2008-05-22T04:17:33Z", "is_private": false}, {"count": 2, "tags": [], "bug_id": 45060, "text": "Initial investigation shows that Excel encodes (when it re-parses) the formula different to POI.  At first I thought the problem might have been the missing tAttrVolatile token, but that seems to make no difference.  The critical problem is the difference in the operand class of two of the function tokens.  \nExcel augments to them to 'array'.  I am speculating that the rule being followed here is that when the function parameter is 'reference' and the actual argument is 'value' that it should get changed to 'array'.  However, I can't see that explicity mentioned in the ooo document.  \n\n// The formula parse tokens \nAttrPtg [volatile ]  (POI does not encode this token)\nIntPtg [1]\nAreaPtg [A:A]\nAreaPtg [A:A]\nFuncVarPtg [MIN nArgs=1]\nStringPtg [:]\nConcatPtg\nAreaPtg [A:A]\nFuncVarPtg [MAX nArgs=1]\nConcatPtg\nFuncVarPtg [INDIRECT nArgs=1]\nFuncVarPtg [ROW nArgs=1]   >>> ptgClass = V should be A\nAreaPtg [B:B]\nFuncVarPtg [SUMIF nArgs=3] >>> ptgClass = V should be A\nIntPtg [0]\nFuncVarPtg [IRR nArgs=2]  \nclass AddPtg\n\n// Function metadata\n#Columns: (index, name, minParams, maxParams, returnClass, paramClasses)\n148\tINDIRECT\t1\t2\tR\tV V\n8\tROW\t0\t1\tV\tR\n345\tSUMIF\t2\t3\tV\tR V R\n62\tIRR\t1\t2\tV\tR \n\n\nIn this current example  SUMIF()'s return class is 'value' but IRR() expects 'reference' for the first parameter.  I guess this somehow necessitates the transformation of the SUMIF() token to 'array'.  From there, perhaps 'forced array' state causes SUMIF()'s second arg to be transformed to 'array' too.\n\nA simpler example \"COLUMNS(PI())\" also gets encoded by Excel with transformation to 'array' operand class.  Excel tolerates POI's incorrect encoding in this case, so the mistake is not as clearly visible.\n\nThe fix for this is going to be in FormulaParser.setParameterRVA().\n\n", "id": 116905, "time": "2008-05-22T10:25:02Z", "creator": "josh@apache.org", "creation_time": "2008-05-22T10:25:02Z", "is_private": false, "attachment_id": null}, {"count": 3, "tags": [], "creator": "josh@apache.org", "attachment_id": null, "text": "Fix applied in svn r660828.\n\nIt seems that POI's operand class transformation differed from a lot Excel's.  A new test case (TestRVA.java) shows many of those differences.\n\nIt seems that in the function metadata for IRR, the first parameter should be operand class 'array' (not 'reference').  However, this was not nearly enough to get all the test cases working.\n\nSome changes were made to the Ptg class hierarchy (to make the distinction between classified and base tokens clearer).  Amongst other changes FormulaParser was fixed to produce a parse tree on the fly while parsing (as opposed to storing tokens in a flat list.\n\nAs of this fix, POI still has some differences with Excel with regard to operand class transformation, but no significant examples have been found (i.e. in the cases where POI gets it wrong, Excel still seems to read/evaluate the formula OK).\n", "id": 117072, "time": "2008-05-27T23:30:09Z", "bug_id": 45060, "creation_time": "2008-05-27T23:30:09Z", "is_private": false}, {"count": 4, "tags": [], "bug_id": 45060, "attachment_id": null, "text": "*** Bug 45206 has been marked as a duplicate of this bug. ***", "id": 117709, "time": "2008-06-15T15:28:36Z", "creator": "josh@apache.org", "creation_time": "2008-06-15T15:28:36Z", "is_private": false}]