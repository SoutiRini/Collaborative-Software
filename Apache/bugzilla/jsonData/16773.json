[{"count": 0, "tags": [], "creator": "hchiavettone@ariba.com", "attachment_id": null, "id": 30676, "time": "2003-02-04T19:00:31Z", "bug_id": 16773, "creation_time": "2003-02-04T19:00:31Z", "is_private": false, "text": "In looking through the JSTL source, I noticed 40 occurances (listed below) \nwhere the code was creating new Boolean objects.  In a system where \nperformance is critical, this creation of garbage Boolean objects can increase \nthe overall memory load of a system.  It is much preferable to use the \nBoolean.TRUE and Boolean.FALSE static values in situations where the use of a \nBoolean is required.  It is fairly easy to write a simple public static final \nhelper method (getBoolean(boolean flag)) that does a {if (flag) return \nBoolean.TRUE; return Boolean.FALSE;}\n\nThanks for you help in improving JSTL's performance.\n\nHeath Chiavettone\n\n \\jakarta-\ntaglibs\\standard\\src\\javax\\servlet\\jsp\\jstl\\core\\ConditionalTagSupport.java\n(185,43):            pageContext.setAttribute(var, new Boolean(result), scope);\n\\jakarta-\ntaglibs\\standard\\src\\org\\apache\\taglibs\\standard\\extra\\spath\\SPathParser.java\n(460,27):    boolean[] la1tokens = new boolean[20];\n\\jakarta-\ntaglibs\\standard\\src\\org\\apache\\taglibs\\standard\\lang\\jpath\\adapter\\Convert.jav\na(129,25):            converted = new Boolean(false);\n\\jakarta-\ntaglibs\\standard\\src\\org\\apache\\taglibs\\standard\\lang\\jpath\\adapter\\Convert.jav\na(155,25):            converted = new Boolean(false);\n\\jakarta-\ntaglibs\\standard\\src\\org\\apache\\taglibs\\standard\\lang\\jpath\\adapter\\Convert.jav\na(157,25):            converted = new Boolean(true);\n\\jakarta-\ntaglibs\\standard\\src\\org\\apache\\taglibs\\standard\\lang\\jpath\\adapter\\Convert.jav\na(159,25):            converted = new Boolean(false);\n\\jakarta-\ntaglibs\\standard\\src\\org\\apache\\taglibs\\standard\\lang\\jpath\\adapter\\Convert.jav\na(167,25):            converted = new Boolean(false);\n\\jakarta-\ntaglibs\\standard\\src\\org\\apache\\taglibs\\standard\\lang\\jpath\\adapter\\Convert.jav\na(169,25):            converted = new Boolean(true);\n\\jakarta-\ntaglibs\\standard\\src\\org\\apache\\taglibs\\standard\\lang\\jpath\\adapter\\Convert.jav\na(171,25):            converted = new Boolean(false);\n\\jakarta-\ntaglibs\\standard\\src\\org\\apache\\taglibs\\standard\\lang\\jpath\\adapter\\Convert.jav\na(185,25):            converted = new Boolean(false);\n\\jakarta-\ntaglibs\\standard\\src\\org\\apache\\taglibs\\standard\\lang\\jpath\\adapter\\Convert.jav\na(192,25):            converted = new Boolean(true);\n\\jakarta-\ntaglibs\\standard\\src\\org\\apache\\taglibs\\standard\\lang\\jpath\\expression\\AndOpera\ntor.java(201,22):            result = new Boolean(leftSide && rightSide);\n\\jakarta-\ntaglibs\\standard\\src\\org\\apache\\taglibs\\standard\\lang\\jpath\\expression\\BooleanL\niteral.java(185,16):        return new Boolean(val);\n\\jakarta-\ntaglibs\\standard\\src\\org\\apache\\taglibs\\standard\\lang\\jpath\\expression\\Contains\nFunction.java(218,22):            result = new Boolean(arg1.indexOf(arg2) != -\n1);\n\\jakarta-\ntaglibs\\standard\\src\\org\\apache\\taglibs\\standard\\lang\\jpath\\expression\\EqualsOp\nerator.java(237,16):        return new Boolean(result);\n\\jakarta-\ntaglibs\\standard\\src\\org\\apache\\taglibs\\standard\\lang\\jpath\\expression\\GreaterT\nhanEqualOperator.java(238,16):        return new Boolean(result);\n\\jakarta-\ntaglibs\\standard\\src\\org\\apache\\taglibs\\standard\\lang\\jpath\\expression\\GreaterT\nhanOperator.java(238,16):        return new Boolean(result);\n\\jakarta-\ntaglibs\\standard\\src\\org\\apache\\taglibs\\standard\\lang\\jpath\\expression\\LessThan\nEqualOperator.java(238,16):        return new Boolean(result);\n\\jakarta-\ntaglibs\\standard\\src\\org\\apache\\taglibs\\standard\\lang\\jpath\\expression\\LessThan\nOperator.java(238,16):        return new Boolean(result);\n\\jakarta-\ntaglibs\\standard\\src\\org\\apache\\taglibs\\standard\\lang\\jpath\\expression\\NotEqual\nsOperator.java(237,16):        return new Boolean(result);\n\\jakarta-\ntaglibs\\standard\\src\\org\\apache\\taglibs\\standard\\lang\\jpath\\expression\\NotFunct\nion.java(198,16):        return new Boolean(result.booleanValue() == false);\n\\jakarta-\ntaglibs\\standard\\src\\org\\apache\\taglibs\\standard\\lang\\jpath\\expression\\OrOperat\nor.java(201,22):            result = new Boolean(leftSide || rightSide);\n\\jakarta-\ntaglibs\\standard\\src\\org\\apache\\taglibs\\standard\\lang\\jpath\\expression\\Parser.j\nava(885,54):                           BooleanFunction jjtn001 = new \nBooleanFunction(JJTBOOLEANFUNCTION);\n\\jakarta-\ntaglibs\\standard\\src\\org\\apache\\taglibs\\standard\\lang\\jpath\\expression\\Parser.j\nava(1808,29):   BooleanLiteral jjtn001 = new BooleanLiteral(JJTBOOLEANLITERAL);\n\\jakarta-\ntaglibs\\standard\\src\\org\\apache\\taglibs\\standard\\lang\\jpath\\expression\\Parser.j\nava(2679,27):    boolean[] la1tokens = new boolean[65];\n\\jakarta-\ntaglibs\\standard\\src\\org\\apache\\taglibs\\standard\\lang\\jpath\\expression\\StartsWi\nthFunction.java(218,22):            result = new Boolean(arg1.startsWith\n(arg2));\n\\jakarta-\ntaglibs\\standard\\src\\org\\apache\\taglibs\\standard\\lang\\jstl\\BooleanLiteral.java\n(73,45):  public static final BooleanLiteral TRUE = new BooleanLiteral \n(\"true\");\n\\jakarta-\ntaglibs\\standard\\src\\org\\apache\\taglibs\\standard\\lang\\jstl\\BooleanLiteral.java\n(74,46):  public static final BooleanLiteral FALSE = new BooleanLiteral \n(\"false\");\n\\jakarta-\ntaglibs\\standard\\src\\org\\apache\\taglibs\\standard\\lang\\jstl\\parser\\ELParser.java\n(1093,27):    boolean[] la1tokens = new boolean[54];\n\\jakarta-\ntaglibs\\standard\\src\\org\\apache\\taglibs\\standard\\lang\\jstl\\parser\\jsp20\n\\ELParser.java(1090,27):    boolean[] la1tokens = new boolean[54];\n\\jakarta-\ntaglibs\\standard\\src\\org\\apache\\taglibs\\standard\\tag\\common\\core\\ForEachSupport\n.java(296,29):        Boolean[] wrapped = new Boolean[a.length];\n\\jakarta-\ntaglibs\\standard\\src\\org\\apache\\taglibs\\standard\\tag\\common\\core\\ForEachSupport\n.java(298,26):            wrapped[i] = new Boolean(a[i]);\n\\jakarta-taglibs\\standard\\src\\org\\apache\\taglibs\\standard\\tlv\\JstlCoreTLV.java\n(206,26):\t\t    chooseHasWhen.push(new Boolean(true));\n\\jakarta-taglibs\\standard\\src\\org\\apache\\taglibs\\standard\\tlv\\JstlCoreTLV.java\n(222,31):\t\t    chooseHasOtherwise.push(new Boolean(true));\n\\jakarta-taglibs\\standard\\src\\org\\apache\\taglibs\\standard\\tlv\\JstlCoreTLV.java\n(251,22):\t\tchooseHasWhen.push(new Boolean(false));\n\\jakarta-taglibs\\standard\\src\\org\\apache\\taglibs\\standard\\tlv\\JstlCoreTLV.java\n(252,27):\t\tchooseHasOtherwise.push(new Boolean(false));\n\\jakarta-taglibs\\standard\\src\\org\\apache\\taglibs\\standard\\tlv\\JstlXmlTLV.java\n(201,40):                    chooseHasWhen.push(new Boolean(true));\n\\jakarta-taglibs\\standard\\src\\org\\apache\\taglibs\\standard\\tlv\\JstlXmlTLV.java\n(217,31):\t\t    chooseHasOtherwise.push(new Boolean(true));\n\\jakarta-taglibs\\standard\\src\\org\\apache\\taglibs\\standard\\tlv\\JstlXmlTLV.java\n(239,36):                chooseHasWhen.push(new Boolean(false));\n\\jakarta-taglibs\\standard\\src\\org\\apache\\taglibs\\standard\\tlv\\JstlXmlTLV.java\n(240,27):\t\tchooseHasOtherwise.push(new Boolean(false));"}, {"count": 1, "tags": [], "creator": "bayern@essentially.net", "attachment_id": null, "is_private": false, "id": 30677, "time": "2003-02-04T19:11:19Z", "bug_id": 16773, "creation_time": "2003-02-04T19:11:19Z", "text": "Do you have some evidence that this leads, in practice, to a performance-\nproblem on any real-world system.  The change you're suggesting is minor, so I \ncan just make it as soon as I get a chance, but I'm not inclined to go out of \nmy way to intuit things about system performance without hard evidence.  My \nimpression is that any legitimate JIT knows how to optimize this kind of code; \nobject creation is emphatically *not* expensive on nearly all real-world JITs, \nand code is often made complex out of a mistaken desire to avoid it!"}, {"count": 2, "tags": [], "text": "I agree with Shawn the JITs should take care of these kinds of optimization. In\nfact, if they do, then your approach would penalize the performance, as it would\nrequire an extra method call.\n\nOn the other hand, such static function already exists in JDK 1.4.2: \n\nhttp://java.sun.com/j2se/1.4.2/docs/api/java/lang/Boolean.html#valueOf(boolean)\n\nThe fact that this function exists suggests that creating new Booleans in fact a\ndecreases performance. If JSTL depended on JDK 1.4.2, we could easily fix this\nby using replacing the occurrences of \"new Boolean(x)\" to \"Boolean.valueOf(x)\",\nbut unfortunately that's not the case. Another option would be\nBoolean.valueOf(\"\"+x), as JDK 1.3.x has a valueOf(String) method.\n\nJust my 2 cents,\n\nFelipe\n\n\n\n", "is_private": false, "bug_id": 16773, "id": 42956, "time": "2003-08-19T00:39:54Z", "creator": "t5jtjj502@sneakemail.com", "creation_time": "2003-08-19T00:39:54Z", "attachment_id": null}, {"count": 3, "tags": [], "bug_id": 16773, "attachment_id": null, "text": "Did a general audit and substituted static values where Boolean objects were created where \nappropriate. Changes were made to standard HEAD and available in the nightly build and will be \navailable in the upcoming Standard 1.1.1 release.\n\nI agree with Shawn and Felipe's assessment that the JIT should take care of this type of optimization so \ntherefore the static helper method won't be implemented. I believe that the added method call may \npenalize performance.", "id": 57239, "time": "2004-05-11T23:23:54Z", "creator": "justyna.horwat@sun.com", "creation_time": "2004-05-11T23:23:54Z", "is_private": false}]