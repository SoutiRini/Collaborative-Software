[{"count": 0, "tags": [], "text": "Assumptions:  You are using an AsyncAppender subclass, and assume it's internal \nFIFO is full (because you hammered it with events faster than it's dispatcher \ncan pull them off).\n\nWith FIFO full, dispatcher thread comes along and pulls next item from FIFO, so \nFIFO now has 1 slot available.  Just after that, another thread puts an event \ninto the FIFO, so now FIFO is full again.  Meanwhile, the dispatcher thread is \ntrying to dispatch the event.  If that code attempts to log anything, it will \nbe blocked, because the FIFO is full, and the FIFO will never be drained \nbecause now the dispatcher thread is blocked.\n\nEven if there's no other thread filling up the FIFO, the lockup can happen if \nthe dispatcher thread is trying to log 2 events:  The first log will succeed in \nputting it into the FIFO (filling it up), the 2nd will hang it.\n\nIt will ALWAYS lock up if the dispatcher is trying to log more events than the \nsize of the FIFO, so if you simply have the dispached code log 129 events, \nyou're toast.\n\nMy temporary workaround was to update our category subclass and not log \nanything when Thread.currentThread().getName().startsWith(\"Dispatcher-\nThread\").  This prevents those log events from being logged that are logged \nfrom the dispatcher thread, somewhat undesirable.\n\nI'm quite unfamiliar with log4j, so I cannot suggest a permanent solution, but \nI guess it would require a FIFO replacement, maybe use SimpleQueue with 'soft' \nenforcement of it's max size (allowing the dispatcher thread to ALWAYS add \nevents to the queue, even if it's 'full').", "attachment_id": null, "id": 60606, "creator": "johannes.eggers@scgo.com", "time": "2004-07-14T17:14:44Z", "bug_id": 30106, "creation_time": "2004-07-14T17:14:44Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 30106, "is_private": false, "id": 86925, "creation_time": "2006-03-16T17:44:12Z", "time": "2006-03-16T17:44:12Z", "creator": "carnold@apache.org", "text": "AsyncAppender was reworked for bug 38982 to add non-blocking option for\nAsyncAppender and address deadlock issues.  In rev 386400, if event is appended\non the dispatcher thread, then it behaves as if blocking=false was set.  A\ncorresponding unit test was added that would lock up on earlier implementations.", "attachment_id": null}]