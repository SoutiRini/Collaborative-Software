[{"count": 0, "tags": [], "bug_id": 16205, "attachment_id": null, "id": 29604, "time": "2003-01-17T14:47:02Z", "creator": "richard.hansen@westgroup.com", "creation_time": "2003-01-17T14:47:02Z", "is_private": false, "text": "1) The howto examples used the newer <resource-env-ref> inplace of <resource-\nref>. Problem is that BeanFactory does not work with <resource-env-ref>. It \njust returns null.\n\n2) BeanFactory checks for instances of a ResourceRef object, if the object \npassed isn't one BeanFactory just returns null. No error is logged or exception \nthrown. This made debugging more difficult than it should have been. It later \ncasts the object to a Reference not a ResourceRef.\n\n3) BeanFactory tries to put the value from <description> element into the \nobject as a parameter. If it can't find a setDescription method it throws a \nNamingException.\n\n\nFixed BeanFactory.getObjectInstance() below\n=====================================================================\n\n    public Object getObjectInstance(Object obj, Name name, Context nameCtx,\n                                    Hashtable environment)\n        throws NamingException {\n\n        if (!(obj instanceof Reference)) \n\t    throw new NamingException(\"Object must be instanceof \njavax.naming.Reference\");\n\n        try {\n                \n            Reference ref = (Reference) obj;\n            String beanClassName = ref.getClassName();\n            Class beanClass = null;\n            ClassLoader tcl = \n                 Thread.currentThread().getContextClassLoader();\n            if (tcl != null) {\n                try {\n                    beanClass = tcl.loadClass(beanClassName);\n                } catch(ClassNotFoundException e) {\n                }\n            } else {\n                try {\n                    beanClass = Class.forName(beanClassName);\n                } catch(ClassNotFoundException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (beanClass == null) {\n                throw new NamingException\n                    (\"Class not found: \" + beanClassName);\n            }\n                \n            BeanInfo bi = Introspector.getBeanInfo(beanClass);\n            PropertyDescriptor[] pda = bi.getPropertyDescriptors();\n                \n            Object bean = beanClass.newInstance();\n                \n            Enumeration e = ref.getAll();\n            while (e.hasMoreElements()) {\n                    \n                RefAddr ra = (RefAddr) e.nextElement();\n                String propName = ra.getType();\n                \n                if (propName.equals(Constants.FACTORY) ||\n                    propName.equals(\"scope\") || \n\t\t    propName.equals(\"auth\") || \n\t\t    propName.equals(\"description\")) {\n                    continue;\n                }\n                    \n                String value = (String)ra.getContent();\n                    \n                Object[] valueArray = new Object[1];\n                    \n                int i = 0;\n                for (i = 0; i<pda.length; i++) {\n\n                    if (pda[i].getName().equals(propName)) {\n\n                        Class propType = pda[i].getPropertyType();\n\n                        if (propType.equals(String.class)) {\n                            valueArray[0] = value;\n                        } else if (propType.equals(Character.class) \n                                   || propType.equals(char.class)) {\n                            valueArray[0] = new Character(value.charAt(0));\n                        } else if (propType.equals(Byte.class) \n                                   || propType.equals(byte.class)) {\n                            valueArray[0] = new Byte(value);\n                        } else if (propType.equals(Short.class) \n                                   || propType.equals(short.class)) {\n                            valueArray[0] = new Short(value);\n                        } else if (propType.equals(Integer.class) \n                                   || propType.equals(int.class)) {\n                            valueArray[0] = new Integer(value);\n                        } else if (propType.equals(Long.class) \n                                   || propType.equals(long.class)) {\n                            valueArray[0] = new Long(value);\n                        } else if (propType.equals(Float.class) \n                                   || propType.equals(float.class)) {\n                            valueArray[0] = new Float(value);\n                        } else if (propType.equals(Double.class) \n                                   || propType.equals(double.class)) {\n                            valueArray[0] = new Double(value);\n                        } else {\n                            throw new NamingException\n                                (\"String conversion for property type '\"\n                                 + propType.getName() + \"' not available\");\n                        }\n                            \n                        Method setProp = pda[i].getWriteMethod();\n                        if (setProp != null) {\n                            setProp.invoke(bean, valueArray);\n                        } else {\n                            throw new NamingException\n                                (\"Write not allowed for property: \" \n                                 + propName);\n                        }\n\n                        break;\n\n                    }\n\n                }\n\n                if (i == pda.length) {\n                    throw new NamingException\n                        (\"No set method found for property: \" + propName);\n                }\n\n            }\n\n            return bean;\n\n        } catch (java.beans.IntrospectionException ie) {\n            throw new NamingException(ie.getMessage());\n        } catch (java.lang.IllegalAccessException iae) {\n            throw new NamingException(iae.getMessage());\n        } catch (java.lang.InstantiationException ie2) {\n            throw new NamingException(ie2.getMessage());\n        } catch (java.lang.reflect.InvocationTargetException ite) {\n            throw new NamingException(ite.getMessage());\n        }\n\n    }\n}"}, {"count": 1, "tags": [], "bug_id": 16205, "text": "Created attachment 4475\nBeanFactory.java with fixed getObjectInstance method", "id": 29605, "time": "2003-01-17T14:48:45Z", "creator": "richard.hansen@westgroup.com", "creation_time": "2003-01-17T14:48:45Z", "is_private": false, "attachment_id": 4475}, {"count": 2, "tags": [], "text": "I have followed the how to using the latest TC4.1.x code from SVN with respect\nto the issues you raise:\n\n1. resource-env-ref works for me.\n\n2. I think I need an example here. I don't see how the wrong class can end up\nhere based just on user configuration.\n\n3. There is no description element, it is an attribute of the Resource element\nand is ignored.\n\nI have searched the commit history but cannot find any changes that might fix\nany of the above. However, since I might have missed them I am going to resolve\nthis as fixed. If you think otherwise, please re-open this report with a simple\nas possible test case that demonstrates the problem with Tomcat 4.1.31 or later.", "attachment_id": null, "id": 80292, "creator": "markt@apache.org", "time": "2005-09-22T00:54:13Z", "bug_id": 16205, "creation_time": "2005-09-22T00:54:13Z", "is_private": false}]