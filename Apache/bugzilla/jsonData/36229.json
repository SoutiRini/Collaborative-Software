[{"count": 0, "attachment_id": null, "creator": "craiglaurent@yahoo.com", "is_private": false, "id": 78587, "time": "2005-08-17T16:23:39Z", "bug_id": 36229, "creation_time": "2005-08-17T16:23:39Z", "tags": [], "text": "Using the Regular Expression Extractor against and HTML page it makes an\nincorrect pattern match if there are multiple matches on the same line.\n\nIt appears that for a given line, it is getting the firstIndex of the first\npart; and the lastIndex of the last part....when it should be getting the\nfirstIndex of the last part; starting at the firstIndex + length of first part.\n\nsimply, if it is looking for a(.+)c; and the data contains xabcyabcz, it returns\none entry \"bcyab\" rather than two entries \"b\" and \"b\".\nA workaround would be to search for xa(.+)cy or ya(.+)cz, which would result in\na unique match.\n \nE.g.  A more practical example follows.\nIf the regex is setup as:\n  documentID='(.+)'\nand a line looks like this:\n  To view the document, <a href=\"url?documentID='123'\">click here&nbsp;</a><a\nhref=\"url?documentID='123'\"><img ...></a>\nthe resulting pattern match stored in the variable is a single entry of:\n  123'\">click here&nbsp;</a><a href=\"url?documentID='123\nwhen it should return two entries:\n  123 and 123.\n\nWe found that we could workaround, and specify everything, so that it would find\na unique match...but that is just a hack to workaround the bug.  This is\nsimplified html...obviously this html could be changed to use a single anchor tag."}, {"count": 1, "tags": [], "text": "The .+ in documentID='(.+)' means find any characters (including '), and is \ngreedy - it will try for the longest match.\n\nTry \n\ndocumentID='(.+?)'\n\nor\n\ndocumentID='(\\d+)'\n\ninstead", "is_private": false, "id": 78588, "creation_time": "2005-08-17T16:27:55Z", "time": "2005-08-17T16:27:55Z", "creator": "sebb@apache.org", "bug_id": 36229, "attachment_id": null}]