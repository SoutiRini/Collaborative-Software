[{"count": 0, "tags": [], "bug_id": 33031, "attachment_id": null, "text": "There is only one property websphere.home when we use ejbjar task to build ejb \nfor Websphere 5.1. AS a matter of fact, there is another very important \ncommand line option for ejbdeploy that is ws.ext.dirs. We can not build ejb \nfor Websphere 5.1 without this option. I actually have modified \nWebsphereDeploymentTool.java source code available. I hope that you can make \nmy code available in the next release.\n\n\n\n\n\n\n\n\n\n\n\n\nThanks,\n\nGeorge", "id": 69506, "time": "2005-01-10T20:31:20Z", "creator": "gwang@ph.com", "creation_time": "2005-01-10T20:31:20Z", "is_private": false}, {"count": 1, "tags": [], "text": "/*\n * Copyright  2001-2004 The Apache Software Foundation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n */\npackage org.apache.tools.ant.taskdefs.optional.ejb;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarFile;\nimport java.util.jar.JarOutputStream;\nimport org.apache.tools.ant.BuildException;\nimport org.apache.tools.ant.Project;\nimport org.apache.tools.ant.taskdefs.Java;\nimport org.apache.tools.ant.types.EnumeratedAttribute;\nimport org.apache.tools.ant.types.Environment;\nimport org.apache.tools.ant.types.Path;\nimport org.apache.tools.ant.util.FileUtils;\n\n/**\n * Websphere deployment tool that augments the ejbjar task.\n * Searches for the websphere specific deployment descriptors and\n * adds them to the final ejb jar file. Websphere has two specific descriptors \nfor session\n * beans:\n * <ul>\n *    <li>ibm-ejb-jar-bnd.xmi</li>\n *    <li>ibm-ejb-jar-ext.xmi</li>\n * </ul>\n * and another two for container managed entity beans:\n * <ul>\n *    <li>Map.mapxmi</li>\n *    <li>Schema.dbxmi</li>\n * </ul>\n * In terms of WebSphere, the generation of container code and stubs is\n * called <code>deployment</code>. This step can be performed by the websphere\n * element as part of the jar generation process. If the switch\n * <code>ejbdeploy</code> is on, the ejbdeploy tool from the websphere toolset\n * is called for every ejb-jar. Unfortunately, this step only works, if you\n * use the ibm jdk. Otherwise, the rmic (called by ejbdeploy) throws a\n * ClassFormatError. Be sure to switch ejbdeploy off, if run ant with\n * sun jdk.\n *\n */\npublic class WebsphereDeploymentTool extends GenericDeploymentTool {\n    /**\n     * Enumerated attribute with the values for the database vendor types\n     *\n     */\n    public static class DBVendor extends EnumeratedAttribute {\n        public String[] getValues() {\n            return new String[]{\n                \"SQL92\", \"SQL99\", \"DB2UDBWIN_V71\", \"DB2UDBOS390_V6\", \"DB2UDBAS4\n00_V4R5\",\n                \"ORACLE_V8\", \"INFORMIX_V92\", \"SYBASE_V1192\", \"MSSQLSERVER_V7\", \n\"MYSQL_V323\"\n                };\n        }\n    }\n\n\n    public static final String PUBLICID_EJB11\n         = \"-//Sun Microsystems, Inc.//DTD Enterprise JavaBeans 1.1//EN\";\n    public static final String PUBLICID_EJB20\n         = \"-//Sun Microsystems, Inc.//DTD Enterprise JavaBeans 2.0//EN\";\n    protected static final String SCHEMA_DIR = \"Schema/\";\n\n    protected static final String WAS_EXT = \"ibm-ejb-jar-ext.xmi\";\n    protected static final String WAS_BND = \"ibm-ejb-jar-bnd.xmi\";\n    protected static final String WAS_CMP_MAP = \"Map.mapxmi\";\n    protected static final String WAS_CMP_SCHEMA = \"Schema.dbxmi\";\n\n    /** Instance variable that stores the suffix for the websphere jarfile. */\n    private String jarSuffix = \".jar\";\n\n    /** Instance variable that stores the location of the ejb 1.1 DTD file. */\n    private String ejb11DTD;\n\n    /** Instance variable that determines whether generic ejb jars are kept. */\n\n    private boolean keepGeneric = false;\n\n    private boolean alwaysRebuild = true;\n\n    private boolean ejbdeploy = true;\n\n    /** Indicates if the old CMP location convention is to be used. */\n    private boolean newCMP = false;\n\n    /** The classpath to the websphere classes. */\n    private Path wasClasspath = null;\n\n    /** The DB Vendor name, the EJB is persisted against */\n    private String dbVendor;\n\n    /** The name of the database to create. (For top-down mapping only) */\n    private String dbName;\n\n    /** The name of the schema to create. (For top-down mappings only) */\n    private String dbSchema;\n\n    /** true - Only generate the deployment code, do not run RMIC or Javac */\n    private boolean codegen;\n\n    /** true - Only output error messages, suppress informational messages */\n    private boolean quiet = true;\n\n    /** true - Disable the validation steps */\n    private boolean novalidate;\n\n    /** true - Disable warning and informational messages */\n    private boolean nowarn;\n\n    /** true - Disable informational messages */\n    private boolean noinform;\n\n    /** true - Enable internal tracing */\n    private boolean trace;\n\n    /** Additional options for RMIC */\n    private String rmicOptions;\n\n    /** true- Use the WebSphere 3.5 compatible mapping rules */\n    private boolean use35MappingRules;\n\n    /** the scratchdir for the ejbdeploy operation */\n    private String tempdir = \"_ejbdeploy_temp\";\n\n    /** the home directory for websphere */\n    private File websphereHome;\n\n     private String websphereExtDirs;\n    /** Get the classpath to the websphere classpaths */\n    public Path createWASClasspath() {\n        if (wasClasspath == null) {\n            wasClasspath = new Path(getTask().getProject());\n        }\n        return wasClasspath.createPath();\n    }\n\n\n    public void setWASClasspath(Path wasClasspath) {\n        this.wasClasspath = wasClasspath;\n    }\n\n\n    /** Sets the DB Vendor for the Entity Bean mapping ; optional.\n     * Valid options are for example:\n     * <ul>\n     * <li>SQL92</li> <li>SQL99</li> <li>DB2UDBWIN_V71</li>\n     * <li>DB2UDBOS390_V6</li> <li>DB2UDBAS400_V4R5</li> <li>ORACLE_V8</li>\n     * <li>INFORMIX_V92</li> <li>SYBASE_V1192</li> <li>MYSQL_V323</li>\n     * </ul>\n     * This is also used to determine the name of the Map.mapxmi and\n     * Schema.dbxmi files, for example Account-DB2UDBWIN_V71-Map.mapxmi\n     * and Account-DB2UDBWIN_V71-Schema.dbxmi.\n     */\n    public void setDbvendor(DBVendor dbvendor) {\n        this.dbVendor = dbvendor.getValue();\n    }\n\n\n    /**\n     * Sets the name of the Database to create; optional.\n     *\n     * @param dbName name of the database\n     */\n    public void setDbname(String dbName) {\n        this.dbName = dbName;\n    }\n\n\n    /**\n     * Sets the name of the schema to create; optional.\n     *\n     * @param dbSchema name of the schema\n     */\n    public void setDbschema(String dbSchema) {\n        this.dbSchema = dbSchema;\n    }\n\n\n    /**\n     * Flag, default false, to only generate the deployment\n     * code, do not run RMIC or Javac\n     *\n     * @param codegen option\n     */\n    public void setCodegen(boolean codegen) {\n        this.codegen = codegen;\n    }\n\n\n    /**\n     * Flag, default true, to only output error messages.\n     *\n     * @param quiet option\n     */\n    public void setQuiet(boolean quiet) {\n        this.quiet = quiet;\n    }\n\n\n    /**\n     * Flag to disable the validation steps; optional, default false.\n     *\n     * @param novalidate option\n     */\n    public void setNovalidate(boolean novalidate) {\n        this.novalidate = novalidate;\n    }\n\n\n    /**\n     * Flag to disable warning and informational messages; optional, default \nfalse.\n     *\n     * @param nowarn option\n     */\n    public void setNowarn(boolean nowarn) {\n        this.nowarn = nowarn;\n    }\n\n\n    /**\n     * Flag to disable informational messages; optional, default false.\n     *\n     * @param noinform if true disables informational messages\n     */\n    public void setNoinform(boolean noinform) {\n        this.noinform = noinform;\n    }\n\n\n    /**\n     * Flag to enable internal tracing when set, optional, default false.\n     *\n     * @param trace\n     */\n    public void setTrace(boolean trace) {\n        this.trace = trace;\n    }\n\n    /**\n     * Set the rmic options.\n     *\n     * @param options\n     */\n    public void setRmicoptions(String options) {\n        this.rmicOptions = options;\n    }\n\n    /**\n     * Flag to use the WebSphere 3.5 compatible mapping rules ; optional, \ndefault false.\n     *\n     * @param attr\n     */\n    public void setUse35(boolean attr) {\n        use35MappingRules = attr;\n    }\n\n\n    /**\n     * Set the rebuild flag to false to only update changes in the jar rather\n     * than rerunning ejbdeploy; optional, default true.\n     */\n    public void setRebuild(boolean rebuild) {\n        this.alwaysRebuild = rebuild;\n    }\n\n\n    /**\n     * String value appended to the basename of the deployment\n     * descriptor to create the filename of the WebLogic EJB\n     * jar file. Optional, default '.jar'.\n     * @param inString the string to use as the suffix.\n     */\n    public void setSuffix(String inString) {\n        this.jarSuffix = inString;\n    }\n\n\n    /**\n     * This controls whether the generic file used as input to\n     * ejbdeploy is retained; optional, default false.\n     * @param inValue either 'true' or 'false'.\n     */\n    public void setKeepgeneric(boolean inValue) {\n        this.keepGeneric = inValue;\n    }\n\n\n    /**\n     * Decide, wether ejbdeploy should be called or not;\n     * optional, default true.\n     *\n     * @param ejbdeploy\n     */\n    public void setEjbdeploy(boolean ejbdeploy) {\n        this.ejbdeploy = ejbdeploy;\n    }\n\n\n    /**\n     * Setter used to store the location of the Sun's Generic EJB DTD. This\n     * can be a file on the system or a resource on the classpath.\n     *\n     * @param inString the string to use as the DTD location.\n     */\n    public void setEJBdtd(String inString) {\n        this.ejb11DTD = inString;\n    }\n\n\n    /**\n     * Set the value of the oldCMP scheme. This is an antonym for newCMP\n     * @ant.attribute ignore=\"true\"\n     */\n    public void setOldCMP(boolean oldCMP) {\n        this.newCMP = !oldCMP;\n    }\n\n\n    /**\n     * Set the value of the newCMP scheme. The old CMP scheme locates the\n     * websphere CMP descriptor based on the naming convention where the\n     * websphere CMP file is expected to be named with the bean name as the\n     * prefix. Under this scheme the name of the CMP descriptor does not match\n     * the name actually used in the main websphere EJB descriptor. Also,\n     * descriptors which contain multiple CMP references could not be used.\n     */\n    public void setNewCMP(boolean newCMP) {\n        this.newCMP = newCMP;\n    }\n\n\n    /**\n     * The directory, where ejbdeploy will write temporary files;\n     * optional, defaults to '_ejbdeploy_temp'.\n     */\n\n    public void setTempdir(String tempdir) {\n        this.tempdir = tempdir;\n    }\n\n\n    protected DescriptorHandler getDescriptorHandler(File srcDir) {\n        DescriptorHandler handler = new DescriptorHandler(getTask(), srcDir);\n        // register all the DTDs, both the ones that are known and\n        // any supplied by the user\n        handler.registerDTD(PUBLICID_EJB11, ejb11DTD);\n\n        for (Iterator i = getConfig().dtdLocations.iterator(); i.hasNext();) {\n            EjbJar.DTDLocation dtdLocation = (EjbJar.DTDLocation) i.next();\n\n            handler.registerDTD(dtdLocation.getPublicId(), \ndtdLocation.getLocation());\n        }\n\n        return handler;\n    }\n\n\n    protected DescriptorHandler getWebsphereDescriptorHandler(final File \nsrcDir) {\n        DescriptorHandler handler =\n            new DescriptorHandler(getTask(), srcDir) {\n                protected void processElement() {\n                }\n            };\n\n        for (Iterator i = getConfig().dtdLocations.iterator(); i.hasNext();) {\n            EjbJar.DTDLocation dtdLocation = (EjbJar.DTDLocation) i.next();\n\n            handler.registerDTD(dtdLocation.getPublicId(), \ndtdLocation.getLocation());\n        }\n        return handler;\n    }\n\n\n    /**\n     * Add any vendor specific files which should be included in the EJB Jar.\n     */\n    protected void addVendorFiles(Hashtable ejbFiles, String baseName) {\n\n        String ddPrefix = (usingBaseJarName() ? \"\" : baseName);\n        String dbPrefix = (dbVendor == null) ? \"\" : dbVendor + \"-\";\n\n        // Get the Extensions document\n        File websphereEXT = new File(getConfig().descriptorDir, ddPrefix + \nWAS_EXT);\n\n        if (websphereEXT.exists()) {\n            ejbFiles.put(META_DIR + WAS_EXT,\n                websphereEXT);\n        } else {\n            log(\"Unable to locate websphere extensions. \"\n                + \"It was expected to be in \"\n                + websphereEXT.getPath(), Project.MSG_VERBOSE);\n        }\n\n        File websphereBND = new File(getConfig().descriptorDir, ddPrefix + \nWAS_BND);\n\n        if (websphereBND.exists()) {\n            ejbFiles.put(META_DIR + WAS_BND,\n                websphereBND);\n        } else {\n            log(\"Unable to locate websphere bindings. \"\n                + \"It was expected to be in \"\n                + websphereBND.getPath(), Project.MSG_VERBOSE);\n        }\n\n        if (!newCMP) {\n            log(\"The old method for locating CMP files has been DEPRECATED.\",\n                Project.MSG_VERBOSE);\n            log(\"Please adjust your websphere descriptor and set \"\n                + \"newCMP=\\\"true\\\" to use the new CMP descriptor \"\n                + \"inclusion mechanism. \", Project.MSG_VERBOSE);\n        } else {\n            // We attempt to put in the MAP and Schema files of CMP beans\n            try {\n                // Add the Map file\n                File websphereMAP = new File(getConfig().descriptorDir,\n                    ddPrefix + dbPrefix + WAS_CMP_MAP);\n\n                if (websphereMAP.exists()) {\n                    ejbFiles.put(META_DIR + WAS_CMP_MAP,\n                        websphereMAP);\n                } else {\n                    log(\"Unable to locate the websphere Map: \"\n                        + websphereMAP.getPath(), Project.MSG_VERBOSE);\n                }\n\n                File websphereSchema = new File(getConfig().descriptorDir,\n                    ddPrefix + dbPrefix + WAS_CMP_SCHEMA);\n\n                if (websphereSchema.exists()) {\n                    ejbFiles.put(META_DIR + SCHEMA_DIR + WAS_CMP_SCHEMA,\n                        websphereSchema);\n                } else {\n                    log(\"Unable to locate the websphere Schema: \"\n                        + websphereSchema.getPath(), Project.MSG_VERBOSE);\n                }\n                // Theres nothing else to see here...keep moving sonny\n            } catch (Exception e) {\n                String msg = \"Exception while adding Vendor specific files: \"\n                    + e.toString();\n\n                throw new BuildException(msg, e);\n            }\n        }\n    }\n\n\n    /**\n     * Get the vendor specific name of the Jar that will be output. The\n     * modification date of this jar will be checked against the dependent\n     * bean classes.\n     */\n    File getVendorOutputJarFile(String baseName) {\n        return new File(getDestDir(), baseName + jarSuffix);\n    }\n\n\n    /**\n     * Gets the options for the EJB Deploy operation\n     *\n     * @return String\n     */\n    protected String getOptions() {\n        // Set the options\n        StringBuffer options = new StringBuffer();\n\n        if (dbVendor != null) {\n            options.append(\" -dbvendor \").append(dbVendor);\n        }\n        if (dbName != null) {\n            options.append(\" -dbname \\\"\").append(dbName).append(\"\\\"\");\n        }\n\n        if (dbSchema != null) {\n            options.append(\" -dbschema \\\"\").append(dbSchema).append(\"\\\"\");\n        }\n\n        if (codegen) {\n            options.append(\" -codegen\");\n        }\n\n        if (quiet) {\n            options.append(\" -quiet\");\n        }\n\n        if (novalidate) {\n            options.append(\" -novalidate\");\n        }\n\n        if (nowarn) {\n            options.append(\" -nowarn\");\n        }\n\n        if (noinform) {\n            options.append(\" -noinform\");\n        }\n\n        if (trace) {\n            options.append(\" -trace\");\n        }\n\n        if (use35MappingRules) {\n            options.append(\" -35\");\n        }\n\n        if (rmicOptions != null) {\n            options.append(\" -rmic \\\"\").append(rmicOptions).append(\"\\\"\");\n        }\n\n        return options.toString();\n    }\n\n\n    /**\n     * Helper method invoked by execute() for each websphere jar to be built.\n     * Encapsulates the logic of constructing a java task for calling\n     * websphere.ejbdeploy and executing it.\n     *\n     * @param sourceJar java.io.File representing the source (EJB1.1) jarfile.\n     * @param destJar java.io.File representing the destination, websphere\n     *      jarfile.\n     */\n    private void buildWebsphereJar(File sourceJar, File destJar) {\n        try {\n            if (ejbdeploy) {\n                Java javaTask = (Java) getTask().getProject().createTask\n(\"java\");\n                // Set the JvmArgs\n                javaTask.createJvmarg().setValue(\"-Xms64m\");\n                javaTask.createJvmarg().setValue(\"-Xmx128m\");\n\n                // Set the Environment variable\n                Environment.Variable var = new Environment.Variable();\n\n                var.setKey(\"websphere.lib.dir\");\n                File libdir = new File(websphereHome, \"lib\");\n                var.setValue(libdir.getAbsolutePath());\n                javaTask.addSysproperty(var);\n\n// this is my new code adding ws.ext.dirs command option for ejbdeploy tool\n                 var = new Environment.Variable();\n                    var.setKey(\"ws.ext.dirs\");\n                    var.setValue(websphereExtDirs);\n                    javaTask.addSysproperty(var);\n\n                // Set the working directory\n                javaTask.setDir(websphereHome);\n\n                // Set the Java class name\n                javaTask.setTaskName(\"ejbdeploy\");\n                javaTask.setClassname(\"com.ibm.etools.ejbdeploy.EJBDeploy\");\n\n                javaTask.createArg().setValue(sourceJar.getPath());\n                javaTask.createArg().setValue(tempdir);\n                javaTask.createArg().setValue(destJar.getPath());\n                javaTask.createArg().setLine(getOptions());\n                if (getCombinedClasspath() != null\n                    && getCombinedClasspath().toString().length() > 0) {\n                    javaTask.createArg().setValue(\"-cp\");\n                    javaTask.createArg().setValue(getCombinedClasspath\n().toString());\n                }\n\n                Path classpath = wasClasspath;\n\n                if (classpath == null) {\n                    classpath = getCombinedClasspath();\n                }\n\n                if (classpath != null) {\n                    javaTask.setClasspath(classpath);\n                    javaTask.setFork(true);\n                } else {\n                    javaTask.setFork(true);\n                }\n\n                log(\"Calling websphere.ejbdeploy for \" + sourceJar.toString(),\n                    Project.MSG_VERBOSE);\n\n                javaTask.execute();\n            }\n        } catch (Exception e) {\n            // Have to catch this because of the semantics of calling main()\n            String msg = \"Exception while calling ejbdeploy. Details: \" + \ne.toString();\n\n            throw new BuildException(msg, e);\n        }\n    }\n\n\n    /**\n     * Method used to encapsulate the writing of the JAR file. Iterates over\n     * the filenames/java.io.Files in the Hashtable stored on the instance\n     * variable ejbFiles.\n     */\n    protected void writeJar(String baseName, File jarFile, Hashtable files, \nString publicId)\n         throws BuildException {\n        if (ejbdeploy) {\n            // create the -generic.jar, if required\n            File genericJarFile = super.getVendorOutputJarFile(baseName);\n\n            super.writeJar(baseName, genericJarFile, files, publicId);\n\n            // create the output .jar, if required\n            if (alwaysRebuild || isRebuildRequired(genericJarFile, jarFile)) {\n                buildWebsphereJar(genericJarFile, jarFile);\n            }\n            if (!keepGeneric) {\n                log(\"deleting generic jar \" + genericJarFile.toString(),\n                    Project.MSG_VERBOSE);\n                genericJarFile.delete();\n            }\n        } else {\n            // create the \"undeployed\" output .jar, if required\n            super.writeJar(baseName, jarFile, files, publicId);\n        }\n    }\n\n\n    /**\n     * Called to validate that the tool parameters have been configured.\n     */\n    public void validateConfigured() throws BuildException {\n        super.validateConfigured();\n        if (ejbdeploy) {\n\n            String home = getTask().getProject().getProperty(\"websphere.home\");\n            if (home == null) {\n                throw new BuildException(\"The 'websphere.home' property must \"\n                    + \"be set when 'ejbdeploy=true'\");\n            }\n            websphereHome = getTask().getProject().resolveFile(home);\n\n            // this is my new code\n            /* websphereExtDirs needs to be passed to the ejbDeploy in order \nto get\n             * websphere 5.x deploy tool to work ...\n             */\n            websphereExtDirs = getTask().getProject().getProperty\n(\"websphere.extdirs\");\n            if (websphereExtDirs == null) {\n                throw new BuildException(\"The 'websphere.home' property must \"\n                    + \"be set when 'ejbdeploy=true'\");\n            }\n\n        }\n    }\n\n\n    /**\n     * Helper method to check to see if a websphere EBJ1.1 jar needs to be\n     * rebuilt using ejbdeploy. Called from writeJar it sees if the \"Bean\"\n     * classes are the only thing that needs to be updated and either updates\n     * the Jar with the Bean classfile or returns true, saying that the whole\n     * websphere jar needs to be regened with ejbdeploy. This allows faster\n     * build times for working developers. <p>\n     *\n     * The way websphere ejbdeploy works is it creates wrappers for the\n     * publicly defined methods as they are exposed in the remote interface.\n     * If the actual bean changes without changing the the method signatures\n     * then only the bean classfile needs to be updated and the rest of the\n     * websphere jar file can remain the same. If the Interfaces, ie. the\n     * method signatures change or if the xml deployment descriptors changed,\n     * the whole jar needs to be rebuilt with ejbdeploy. This is not strictly\n     * true for the xml files. If the JNDI name changes then the jar doesnt\n     * have to be rebuild, but if the resources references change then it\n     * does. At this point the websphere jar gets rebuilt if the xml files\n     * change at all.\n     *\n     * @param genericJarFile java.io.File The generic jar file.\n     * @param websphereJarFile java.io.File The websphere jar file to check to\n     *      see if it needs to be rebuilt.\n     */\n    protected boolean isRebuildRequired(File genericJarFile, File \nwebsphereJarFile) {\n        boolean rebuild = false;\n\n        JarFile genericJar = null;\n        JarFile wasJar = null;\n        File newwasJarFile = null;\n        JarOutputStream newJarStream = null;\n\n        try {\n            log(\"Checking if websphere Jar needs to be rebuilt for jar \"\n                + websphereJarFile.getName(), Project.MSG_VERBOSE);\n            // Only go forward if the generic and the websphere file both exist\n            if (genericJarFile.exists() && genericJarFile.isFile()\n                 && websphereJarFile.exists() && websphereJarFile.isFile()) {\n                //open jar files\n                genericJar = new JarFile(genericJarFile);\n                wasJar = new JarFile(websphereJarFile);\n\n                Hashtable genericEntries = new Hashtable();\n                Hashtable wasEntries = new Hashtable();\n                Hashtable replaceEntries = new Hashtable();\n\n                //get the list of generic jar entries\n                for (Enumeration e = genericJar.entries(); e.hasMoreElements\n();) {\n                    JarEntry je = (JarEntry) e.nextElement();\n\n                    genericEntries.put(je.getName().replace('\\\\', '/'), je);\n                }\n                //get the list of websphere jar entries\n                for (Enumeration e = wasJar.entries(); e.hasMoreElements();) {\n                    JarEntry je = (JarEntry) e.nextElement();\n\n                    wasEntries.put(je.getName(), je);\n                }\n\n                //Cycle Through generic and make sure its in websphere\n                ClassLoader genericLoader = getClassLoaderFromJar\n(genericJarFile);\n\n                for (Enumeration e = genericEntries.keys(); e.hasMoreElements\n();) {\n                    String filepath = (String) e.nextElement();\n\n                    if (wasEntries.containsKey(filepath)) {\n                        // File name/path match\n                        // Check files see if same\n                        JarEntry genericEntry = (JarEntry) genericEntries.get\n(filepath);\n                        JarEntry wasEntry = (JarEntry) wasEntries.get\n(filepath);\n\n                        if ((genericEntry.getCrc() != wasEntry.getCrc())\n                            || (genericEntry.getSize() != wasEntry.getSize())) \n{\n\n                            if (genericEntry.getName().endsWith(\".class\")) {\n                                //File are different see if its an object or \nan interface\n                                String classname\n                                    = genericEntry.getName().replace\n(File.separatorChar, '.');\n\n                                classname = classname.substring(0, \nclassname.lastIndexOf(\".class\"));\n\n                                Class genclass = genericLoader.loadClass\n(classname);\n\n                                if (genclass.isInterface()) {\n                                    //Interface changed   rebuild jar.\n                                    log(\"Interface \" + genclass.getName()\n                                        + \" has changed\", Project.MSG_VERBOSE);\n                                    rebuild = true;\n                                    break;\n                                } else {\n                                    //Object class Changed   update it.\n                                    replaceEntries.put(filepath, genericEntry);\n                                }\n                            } else {\n                                // is it the manifest. If so ignore it\n                                if (!genericEntry.getName().equals(\"META-\nINF/MANIFEST.MF\")) {\n                                    //File other then class changed   rebuild\n                                    log(\"Non class file \" + \ngenericEntry.getName()\n                                        + \" has changed\", Project.MSG_VERBOSE);\n                                    rebuild = true;\n                                }\n                                break;\n                            }\n                        }\n                    } else {\n                        // a file doesn't exist rebuild\n\n                        log(\"File \" + filepath + \" not present in websphere \njar\",\n                            Project.MSG_VERBOSE);\n                        rebuild = true;\n                        break;\n                    }\n                }\n\n                if (!rebuild) {\n                    log(\"No rebuild needed - updating jar\", \nProject.MSG_VERBOSE);\n                    newwasJarFile = new File(websphereJarFile.getAbsolutePath\n() + \".temp\");\n                    if (newwasJarFile.exists()) {\n                        newwasJarFile.delete();\n                    }\n\n                    newJarStream = new JarOutputStream(new FileOutputStream\n(newwasJarFile));\n                    newJarStream.setLevel(0);\n\n                    //Copy files from old websphere jar\n                    for (Enumeration e = wasEntries.elements(); \ne.hasMoreElements();) {\n                        byte[] buffer = new byte[1024];\n                        int bytesRead;\n                        InputStream is;\n                        JarEntry je = (JarEntry) e.nextElement();\n\n                        if (je.getCompressedSize() == -1\n                            || je.getCompressedSize() == je.getSize()) {\n                            newJarStream.setLevel(0);\n                        } else {\n                            newJarStream.setLevel(9);\n                        }\n\n                        // Update with changed Bean class\n                        if (replaceEntries.containsKey(je.getName())) {\n                            log(\"Updating Bean class from generic Jar \" + \nje.getName(),\n                                Project.MSG_VERBOSE);\n                            // Use the entry from the generic jar\n                            je = (JarEntry) replaceEntries.get(je.getName());\n                            is = genericJar.getInputStream(je);\n                        } else {\n                            //use fle from original websphere jar\n\n                            is = wasJar.getInputStream(je);\n                        }\n                        newJarStream.putNextEntry(new JarEntry(je.getName()));\n\n                        while ((bytesRead = is.read(buffer)) != -1) {\n                            newJarStream.write(buffer, 0, bytesRead);\n                        }\n                        is.close();\n                    }\n                } else {\n                    log(\"websphere Jar rebuild needed due to changed \"\n                        + \"interface or XML\", Project.MSG_VERBOSE);\n                }\n            } else {\n                rebuild = true;\n            }\n        } catch (ClassNotFoundException cnfe) {\n            String cnfmsg = \"ClassNotFoundException while processing ejb-jar \nfile\"\n                 + \". Details: \"\n                 + cnfe.getMessage();\n\n            throw new BuildException(cnfmsg, cnfe);\n        } catch (IOException ioe) {\n            String msg = \"IOException while processing ejb-jar file \"\n                 + \". Details: \"\n                 + ioe.getMessage();\n\n            throw new BuildException(msg, ioe);\n        } finally {\n            // need to close files and perhaps rename output\n            if (genericJar != null) {\n                try {\n                    genericJar.close();\n                } catch (IOException closeException) {\n                }\n            }\n\n            if (wasJar != null) {\n                try {\n                    wasJar.close();\n                } catch (IOException closeException) {\n                }\n            }\n\n            if (newJarStream != null) {\n                try {\n                    newJarStream.close();\n                } catch (IOException closeException) {\n                }\n\n                try {\n                    FileUtils.newFileUtils().rename(newwasJarFile,\n                                                    websphereJarFile);\n                } catch (IOException renameException) {\n                    log(renameException.getMessage(), Project.MSG_WARN);\n                    rebuild = true;\n                }\n            }\n        }\n\n        return rebuild;\n    }\n\n\n    /**\n     * Helper method invoked by isRebuildRequired to get a ClassLoader for a\n     * Jar File passed to it.\n     *\n     * @param classjar java.io.File representing jar file to get classes from.\n     */\n    protected ClassLoader getClassLoaderFromJar(File classjar) throws \nIOException {\n        Path lookupPath = new Path(getTask().getProject());\n\n        lookupPath.setLocation(classjar);\n\n        Path classpath = getCombinedClasspath();\n\n        if (classpath != null) {\n            lookupPath.append(classpath);\n        }\n\n        return getTask().getProject().createClassLoader(lookupPath);\n    }\n}\n\n", "attachment_id": null, "id": 69507, "creator": "gwang@ph.com", "time": "2005-01-10T20:34:01Z", "bug_id": 33031, "creation_time": "2005-01-10T20:34:01Z", "is_private": false}]