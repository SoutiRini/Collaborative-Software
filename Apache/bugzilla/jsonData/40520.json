[{"count": 0, "attachment_id": null, "bug_id": 40520, "text": "I'm using poi-bin-3.0-alpha2-20060616 because I need support for (RichText) \nformatting within a cell. The resulting sheet is read by Excel 2003 SP2.\n\nI found a number of cases where I think, HSSFFont.applyFont() formats wrong \nparts of HSSFRichTextString. (see testcase below)\n\nThis seems to happen in (at least) the following cases:\n    // overlapped range => will format whole String\n    str.applyFont(0,7,font);\n    str.applyFont(5,9,font);\n    \n    \n    // formated twice => will format whole String\n    str2.applyFont(0,2,font);\n    str2.applyFont(0,2,font);\n\n    // wrong order and formated twice => will format 0-6\n    str3.applyFont(0,2,font);\n    str3.applyFont(5,7,font);\n    str3.applyFont(0,2,font);\n\nMy \"font\" just uses a foreground color \"font.setColor((short) 2);\".\n\nHere is my complete testcase. (I will try to attach it also, but haven't seen \nan option until now to attach a file)\n\n------------------ snip, snip ----\npackage poi_hssf;\n\nimport java.io.*;\n\nimport org.apache.poi.hssf.usermodel.*;\n\n\npublic class HSSFRichText\n{\n  private void newRow()\n  {\n    this.actRow = this.sheet.createRow(this.nextLineNr);\n    this.nextLineNr++;\n    this.actCol = 0;\n  }\n\n\n  private HSSFCell appendCell()\n  {\n    this.actCell = this.actRow.createCell(this.actCol++);\n    return (this.actCell);\n  }\n\n  \n  private void test()\n  {\n    File file = new File(\"RichPOI.xls\");\n    FileOutputStream outStream = null;\n    try\n    {\n      outStream = new FileOutputStream(file);\n    }\n    catch (FileNotFoundException e)\n    {\n      System.err.println(e.getStackTrace());\n    }\n    \n    this.wb = new HSSFWorkbook();\n    this.sheet = wb.createSheet();\n\n    HSSFFont font;\n    font = this.wb.createFont();\n    font.setColor((short) 2); // Rot\n\n    HSSFCell cell;\n    \n    this.newRow();\n    HSSFRichTextString str = new HSSFRichTextString\n(\"f0_123456789012345678901234567890123456789012345678901234567890\");    \n    \n    // overlapped range => will format whole String\n    str.applyFont(0,7,font);\n    str.applyFont(5,9,font);\n    cell = this.appendCell();\n    cell.setCellValue(str);\n    \n    \n    this.newRow();\n    HSSFRichTextString str2 = new HSSFRichTextString\n(\"f1_123456789012345678901234567890123456789012345678901234567890\");    \n    // formated twice => will format whole String\n    str2.applyFont(0,2,font);\n    str2.applyFont(0,2,font);\n    cell = this.appendCell();\n    cell.setCellValue(str2);\n    \n\n    this.newRow();\n    HSSFRichTextString str3 = new HSSFRichTextString\n(\"f2_123456789012345678901234567890123456789012345678901234567890\");    \n    // wrong order => will format 0-6\n    str3.applyFont(0,2,font);\n    str3.applyFont(5,7,font);\n    str3.applyFont(0,2,font);\n    cell = this.appendCell();\n    cell.setCellValue(str3);\n\n    try\n    {\n      this.wb.write(outStream);\n      outStream.close();\n    }\n    catch (IOException e)\n    {\n       System.err.println(e.getStackTrace());\n    }    \n  }\n  \n  \n  public static void main(String[] args)\n  {\n      HSSFRichText testit = new HSSFRichText();\n      testit.test();\n  }\n  \n  \n  private int nextLineNr;\n  private short actCol;\n  private HSSFWorkbook wb;\n  private HSSFSheet sheet;\n  private HSSFRow actRow;\n  private HSSFCell actCell;\n}", "id": 93625, "time": "2006-09-15T13:22:42Z", "creator": "Martin.Jost@siemens.com", "creation_time": "2006-09-15T13:22:42Z", "tags": [], "is_private": false}, {"count": 1, "attachment_id": 18869, "bug_id": 40520, "text": "Created attachment 18869\nTestcase for the problerm", "id": 93626, "time": "2006-09-15T13:24:05Z", "creator": "Martin.Jost@siemens.com", "creation_time": "2006-09-15T13:24:05Z", "tags": [], "is_private": false}, {"count": 2, "text": "fixed  in r738908.\n\nYegor", "bug_id": 40520, "attachment_id": null, "id": 124477, "time": "2009-01-29T08:06:31Z", "creator": "yegor@dinom.ru", "creation_time": "2009-01-29T08:06:31Z", "tags": [], "is_private": false}]