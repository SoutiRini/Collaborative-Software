[{"count": 0, "tags": [], "bug_id": 42198, "attachment_id": null, "is_private": false, "id": 102115, "time": "2007-04-23T08:31:37Z", "creator": "matthias.reich@siemens-enterprise.com", "creation_time": "2007-04-23T08:31:37Z", "text": "I am currently porting our eventing framework for web based clients to Tomcat 6,\nas we would like to make use of the new CometProcessor interface.\n\nI detected that the concurrent access of event processor thread and response\nprovider thread seems to be unsufficiently synchronized.\n\nI built a small test webapp which tries to simulate the communication behaviour\nof our framework and did some tests.\n(see attachment comettest.war)\nYou can easily use the test webapp by simply deploying it to the webapps folder\nof Tomcat,\nthen start one more more browsers (IE and FireFox shown a little different\nbehaviour),\nand request the index page of the webapp.\n\nI did my tests first with tomcat 6.0.10,\nthen with http://svn.apache.org/repos/asf/tomcat/tc6.0.x/tags/TOMCAT_6_0_11,\nrevision 530531, and finally with the trunk, revision 531159.\nFor the APR connector I used tcnative-1.dll in version 1.1.8.\n\nWithout enhanced synchronization, the XMLHttpRequests are often hanging after\nreaching readyState 3 (often with Firefox, sometimes with IE).\nFurthermore, CometEventImpl.close sometimes fails, and with the NIO connector I\nsaw e.g. this Exception:\n\njava.lang.NullPointerException\n\tat\norg.apache.coyote.http11.InternalNioOutputBuffer.writeToSocket(InternalNioOutputBuffer.java:436)\n\tat\norg.apache.coyote.http11.InternalNioOutputBuffer.flushBuffer(InternalNioOutputBuffer.java:761)\n\tat\norg.apache.coyote.http11.InternalNioOutputBuffer.endRequest(InternalNioOutputBuffer.java:398)\n\tat org.apache.coyote.http11.Http11NioProcessor.action(Http11NioProcessor.java:1087)\n\tat org.apache.coyote.Response.action(Response.java:183)\n\tat org.apache.coyote.Response.finish(Response.java:305)\n\tat org.apache.catalina.connector.OutputBuffer.close(OutputBuffer.java:276)\n\tat org.apache.catalina.connector.Response.finishResponse(Response.java:486)\n\tat org.apache.catalina.connector.CometEventImpl.close(CometEventImpl.java:85)\n\tat comettest.CometServlet.closeEvent(CometServlet.java:331)\n\tat comettest.CometServlet.access$2(CometServlet.java:317)\n\tat comettest.CometServlet$EventProvider.sendResponse(CometServlet.java:146)\n\tat comettest.CometServlet$EventProvider.run(CometServlet.java:95)\n\tat java.lang.Thread.run(Thread.java:595)\n\n\nWith the APR connector sometimes even the VM crashed. (see attached dump)\n\n\nThis is probably related to my observation that, if the concurrent close is\nexecuted immediately after the CoyoteAdapter.service call, there is not END\nevent signalled.\nAlso with the NIO connector I saw that I did not get END events for all BEGIN\nevents.\n\nThus, my guess was that response objects might have been recycled too early, and\nI modified the classes org.apache.catalina.connector.CometEventImpl,\norg.apache.catalina.connector.CoyoteAdapter, and\norg.apache.catalina.connector.Request to add a synchronization between event\nprocessor thread and response provider thread via the CometEventImpl object.\n(see attachment patches-reich.jar)\n\nThis synchronization prevents a recycling of request and response before the\nclose operation is completely finished and ensures that the close operation is\nexecuted at most once.\n- If one Thread enters the close method, the state of the object changes from\nOPEN to CLOSING. When the close has finished, state goes to CLOSED.\n- One sync point is in the CoyoteAdapter.service method when decides whether the\nrequest shall be closed or put into the CometPoller.\n  If the CometEventImpl.close method has not been called until then (state is\nstill OPEN), any later invocation of close is allowed to perform recycling of\nrequest and response object by its own, until a new event is dispatched for the\nrequest.\n- The second sync point is at event dispatching to the CoyoteAdapter.event method.\n  If the CometEventImpl state is still OPEN, the CoyoteAdapter takes over\nresponsibilty for recycling again, until the end of event dispatching.\n  If CometEventImpl state is CLOSED, it does not make sense to send an END event\ninto the valve, because CometEventImpl.close has already recycled request and\nresponse object.\n\nI found out that the asynchronous response providers must not call the close\nmethod of the OutputStream directly.\nThey must only use the CometEvent.close method, as otherwise there are still\nproblems due to unsynchronized access (I did not retest this with the trunk yet).\n\n\nAn alternative solution would be to leave the job of recycling completely to\nCoyoteAdapter.event, but then we must be 100% sure that we get an appropriate\nevent from the underlying connector.\n\nIn my mind, the far better alternative would be to leave all recycling\ncompletely to the garbage collector, i.e. do not reuse any objects at all, to\navoid the problems that arise automatically when we leave the world of\nsynchronous request processing, but surely this cannot be done in a day.\n\nWith my adaptation, my test application runs without problems for quite a while\nwith both connectors if there are only short resonse times for the poll requests.\nI still sometimes (but not that often) got VM crashes with the APR connector at\nthe same point of execution of my response provider thread.\nI am not sure if my synchronization is still not good enough, or if these\ncrashes happened when I pressed the reload button to reload the test page into\nthe browser.\n(I saw in the repository created by 'ant download' that you are already working\non tcnative 1.1.10, so that problem might already be solved.)\n\nAs I ran my tests (server and browsers) on a WinXP/SP2 machine with a single\nprocessor, I cannot tell whether my adaptation also works well on other\noperating systems or on multi processor machines. Furthermore, I don't know if\nit really fits with your concepts of the CometEvent lifecycle model. Therefore,\nI cannot claim that my adaptations are a patch."}, {"count": 1, "tags": [], "creator": "matthias.reich@siemens-enterprise.com", "attachment_id": 20017, "id": 102116, "time": "2007-04-23T08:33:40Z", "bug_id": 42198, "creation_time": "2007-04-23T08:33:40Z", "is_private": false, "text": "Created attachment 20017\ncomettest.war"}, {"count": 2, "tags": [], "bug_id": 42198, "attachment_id": 20018, "is_private": false, "id": 102117, "time": "2007-04-23T08:36:14Z", "creator": "matthias.reich@siemens-enterprise.com", "creation_time": "2007-04-23T08:36:14Z", "text": "Created attachment 20018\nMy modifications of Tomcat6\n\nperhaps this will be considered to be a patch, but I am not sure ..."}, {"count": 3, "tags": [], "bug_id": 42198, "attachment_id": 20019, "text": "Created attachment 20019\nVM dump after APR segmentation fault", "id": 102118, "time": "2007-04-23T08:38:36Z", "creator": "matthias.reich@siemens-enterprise.com", "creation_time": "2007-04-23T08:38:36Z", "is_private": false}, {"count": 4, "tags": [], "creator": "remm@apache.org", "attachment_id": null, "id": 102122, "time": "2007-04-23T08:51:36Z", "bug_id": 42198, "creation_time": "2007-04-23T08:51:36Z", "is_private": false, "text": "I think you should first be testing with the current svn code. To make things\nshort, I am not going to agree to some sync (it is up to you to sync most write\noperations), and I don't know yet if your usage is legitimate or not."}, {"count": 5, "tags": [], "bug_id": 42198, "is_private": false, "text": "Ok, I have read (it was a bit hidden) that you have tested with the current svn\ncode. I had forgotten that close was immediately closing the response. As the\nthing is designed, this is a bit wrong, I think, so I will make an update.\n\nI don't understand how your problem can happen at this time (it would imply that\nthe internal objects have been recycled, however), since I don't see anything\noccuring on your connections. Maybe you could use the system property\norg.apache.catalina.connector.RECYCLE_FACADES set to true (you can put it in\ncatalina.properties). It protects from crashes from funky async accesses (like\nJava2D, or here, bad Comet access).\n\nYou appear to be storing connections in a queue for some async processing. In\nthe design, it is up to you to synchronize accesses as needed (as with the rest\nof the Servlet API, nothing is thread safe): in the example ChatServlet - not\nfunctional, but is meant to be an IO test - all async writes are done inside a\nsync on an object which is also used to manipulate the list of connections. This\nway, you cannot have a close occurring at the same time as another write (or\nclose). The more I think about it, the less I think there's a bug to fix.", "id": 102143, "time": "2007-04-23T12:26:17Z", "creator": "remm@apache.org", "creation_time": "2007-04-23T12:26:17Z", "attachment_id": null}, {"count": 6, "tags": [], "creator": "matthias.reich@siemens-enterprise.com", "attachment_id": 20017, "id": 102144, "time": "2007-04-23T12:36:21Z", "bug_id": 42198, "creation_time": "2007-04-23T12:36:21Z", "is_private": false, "text": "Comment on attachment 20017\ncomettest.war\n\nTest Web application to reproduce bug"}, {"count": 7, "tags": [], "bug_id": 42198, "attachment_id": 20025, "is_private": false, "id": 102167, "time": "2007-04-23T14:52:04Z", "creator": "matthias.reich@siemens-enterprise.com", "creation_time": "2007-04-23T14:52:04Z", "text": "Created attachment 20025\nCorrected version of comettest.war\n\nYou are right - it is not a bug! I synchronized access to the output stream by\nsynchronizing on the event object, and the synchronization problem is solved -\nThank you for your quick comment.\n\nSynchronization on the CometEvent object works fine with the current\nimplementation which reuses the same CometEventImpl instance throughout the\nlifetime of a request, but is this part of the contract between container and\nthe Servlet?\n\nI would not like the idea of synchronizing write operations on lots of\nconnections with the help of a single synchronizer object like the example\nChatServlet does. An alternative would be to synchronize on the\nHttpServletResponse object. What do you recommend?\n\nAs I understood your comment, event.close and outputStream.close are not\nintended to be coupled as close as they are in the current implementation.\n\nThus, would it be the recommended use of the Comet interface if the response\nprovider thread closes only the stream but not the event, so that the Servlet's\nevent method will be triggered with an END event, and the event method can\nclose the event?\nWill a close of the event be required in case of an END event (e.g. to enable\nrecycling of request and response) or is it optional?"}, {"count": 8, "tags": [], "bug_id": 42198, "attachment_id": null, "is_private": false, "id": 102182, "time": "2007-04-23T17:36:18Z", "creator": "remm@apache.org", "creation_time": "2007-04-23T17:36:18Z", "text": "I think there are a few sync strategies which can work.\n\n- I think there is no reason to stop using a single event instance\n- the ChatServlet only has one main thread writing (the others are there to add\nstuff to do), so there is no unnecessary contention\n- event.close indeed does a close, but it may not make a real difference\n(because the stream close also ends the response)\n- in svn head, you will get an END event in certain cases (like if the event or\nstream is closed asynchronously), but it is not required to close the event\nagain since it's been done already; if the request is closed synchronously\nduring processing of the event method, for example when processing a timeout,\nyou will not get another END event; there's a valve which provides additional\nEND events (on session expiration, etc)"}, {"count": 9, "text": "Hi, I know that this is no discussion forum but I wanted to comment on\n\n(In reply to comment #8)\n> - in svn head, you will get an END event in certain cases (like if the event or\n> stream is closed asynchronously), but it is not required to close the event\n> again since it's been done already; if the request is closed synchronously ...\n\nIf and when you get an END event depends very much on the connection type you\nare using.\n\nWhen you are using a Keep-Alive connection you dont get an END event when\ncalling event.close() synchronously. You will get it at some point later when\nthe browser decides to release the connection.\n\nOtherwise (Connection: close) the connection will be released instantly and an\nEND event will be triggered. In that case the comet event object will become\nkind of invalid, because if you call event.close() a NullPointerException will\nby thrown. Unfortunately there is no way to query the event if it is already\nclosed. \n\nPersonally I find that the event.close() method should never fail in that way\nbut rather return silently when being called on a closed event.\n\nI wonder if there is a way to close the connection from the server side (other\nthan using Connection: close).\n\nIt's also a bit strange that you can keep on writing into a response output\nstream of a closed event without getting an error when using Keep-Alive\nconnections. It seems to me that an exception should be thrown when trying to\nwrite. \n\nJust my 5C\n", "bug_id": 42198, "is_private": false, "id": 102266, "time": "2007-04-24T14:04:57Z", "creator": "daniel.doubleday@gmx.net", "creation_time": "2007-04-24T14:04:57Z", "tags": [], "attachment_id": null}, {"count": 10, "tags": [], "bug_id": 42198, "attachment_id": null, "is_private": false, "id": 102269, "time": "2007-04-24T16:05:37Z", "creator": "remm@apache.org", "creation_time": "2007-04-24T16:05:37Z", "text": "This should be posted on the user list.\n\nI doubt what you described corresponds to what actually happens (with the\nexception of write being a noop after closing the stream - it is the same in a\nregular servlet).\n\nIf you are playing with the Connection header, the client could assume things\nand abruptly close the connection. You should not be playing with the connection\nstate (it's also true in a regular servlet), but it should not make any\ndifference as long as the client does not get confused.\n\nAfter the END event, it is clearly mentioned that the request is done, and\nobjects will be recycled, so it's up to you to stop doing things with that\nrequest (if you want to code more freely, you should use\norg.apache.catalina.connector.RECYCLE_FACADES set to true, which will avoid all\ninvalid accesses)."}]