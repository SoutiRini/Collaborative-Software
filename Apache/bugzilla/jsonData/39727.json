[{"count": 0, "tags": [], "bug_id": 39727, "attachment_id": null, "text": "Entities gzip:ed by mod_deflate still carries the same ETag as the plain entiy,\ncausing inconsistency in ETag aware proxy caches.\n\nIt is very important each unique entity carries unique ETag:s as these identify\nthe specific entity variant of the URL. Each negotiated variant (where\nAccept-Encoding is just one negotioantio parameter) needs to have unique ETag:s.\nFor mod_deflate it's as simple as adding the encoding to the already computed ETag.\n\nThis has implications on at least the following HTTP directives:\n\n   If-None-Match  used in Vary negotiation from ETag aware caches\n   If-Range       ranges in gzip:ed entity obviously not the same as ranges in\nthe plain entity\n   If-Match       mainly conditional PUT requests\n\n\nExample HTTP responses from an Apache-2.2.2 mod_deflate enabled server\n(irrelevant headers pruned):\n\nPlain request\n\n   Server: Apache/2.2.2 (Fedora)\n   ETag: \"76e23-1835-4156af5e53ac0\"\n   Content-Length: 6197\n   Vary: Accept-Encoding,User-Agent\n   \n\nSame request with \"Accept-Encoding: gzip\":\n\n   Server: Apache/2.2.2 (Fedora)\n   ETag: \"76e23-1835-4156af5e53ac0\"\n   Vary: Accept-Encoding,User-Agent\n   Content-Encoding: gzip\n   Content-Length: 1829\n\n\n\nImplications of this:\n\n  * Clients may be given the incorrect response. In effect the first cached\nresponse is given to all clients as If-None-Match indicates the entitiy is OK\nfor all clients..  (same ETag used in both responses -> Same If-None-Match\nrequest so mod_deflate can not tell if the If-None-Match condition is on a\ncompressed or plain entity..)\n\n  * Clients doing range requests with If-Range may end up with corrupted objects\ncontaining part compressed part plain content.\n\n\nSquid-2.6 and later is ETag aware and will make this problem quite visible.\nRelease date for Squid-2.6 is 1/7 (i.e. in less than a month).", "id": 89798, "time": "2006-06-05T23:43:49Z", "creator": "hno@squid-cache.org", "creation_time": "2006-06-05T23:43:49Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 39727, "attachment_id": 18407, "id": 89799, "time": "2006-06-06T00:43:33Z", "creator": "nick@webthing.com", "creation_time": "2006-06-06T00:43:33Z", "is_private": false, "text": "Created attachment 18407\npatch that'll cause mod_filter to unset the etag - see util_filter.h\n\nThis needs more discussion before committing this or any other patch."}, {"count": 2, "tags": [], "text": "Some references\n\nMy ETag notes:  http://devel.squid-cache.org/\n\nOld dev discussions:\nhttp://mail-archives.apache.org/mod_mbox/httpd-dev/200311.mbox/%3C3FB2E075.5010705@modperlcookbook.org%3E\nhttp://mail-archives.apache.org/mod_mbox/httpd-dev/200311.mbox/%3C3FB2C0CB.30401@sun.com%3E\nhttp://mail-archives.apache.org/mod_mbox/httpd-dev/200206.mbox/%3C00b801c20daf$736dd190$c000000a@KOJ%3E", "is_private": false, "bug_id": 39727, "id": 89812, "time": "2006-06-06T08:51:22Z", "creator": "hno@squid-cache.org", "creation_time": "2006-06-06T08:51:22Z", "attachment_id": null}, {"count": 3, "tags": [], "text": "(In reply to comment #1)\n> Created an attachment (id=18407) [edit]\n> patch that'll cause mod_filter to unset the etag - see util_filter.h\n> \n> This needs more discussion before committing this or any other patch.\n\nSorry for my confusion, but this will only work if mod_deflate is used via\nmod_filter, right?\nIt will not work if mod_deflate is used without mod_filter. I guess for this\ncase it is needed to unset the ETag header inside mod_deflate. So something like\nthe following:\n\nIndex: mod_deflate.c\n===================================================================\n--- mod_deflate.c       (Revision 411469)\n+++ mod_deflate.c       (Arbeitskopie)\n@@ -389,6 +389,7 @@\n             apr_table_mergen(r->headers_out, \"Content-Encoding\", \"gzip\");\n         }\n         apr_table_unset(r->headers_out, \"Content-Length\");\n+        apr_table_unset(r->headers_out, \"ETag\");\n\n         /* initialize deflate output buffer */\n         ctx->stream.next_out = ctx->buffer;", "is_private": false, "bug_id": 39727, "id": 89833, "time": "2006-06-06T20:49:19Z", "creator": "rpluem@apache.org", "creation_time": "2006-06-06T20:49:19Z", "attachment_id": null}, {"count": 4, "tags": [], "text": "(In reply to comment #3)\n\n> Sorry for my confusion, but this will only work if mod_deflate is used via\n> mod_filter, right?\n\nYes.  I mentioned that to the reporter in IRC, but not here,\n\n>          apr_table_unset(r->headers_out, \"Content-Length\");\n> +        apr_table_unset(r->headers_out, \"ETag\");\n\nUgh.  That way every filter has to reinvent protocol handling.  A fertile \nbreeding ground for bugs (and we have a history to prove it).  mod_filter is \ndesigned to centralise that, so we only need to get the protocol right once.", "is_private": false, "id": 89836, "creator": "nick@webthing.com", "time": "2006-06-06T21:40:29Z", "bug_id": 39727, "creation_time": "2006-06-06T21:40:29Z", "attachment_id": null}, {"count": 5, "tags": [], "bug_id": 39727, "is_private": false, "id": 89838, "attachment_id": null, "creator": "rpluem@apache.org", "creation_time": "2006-06-06T22:02:11Z", "time": "2006-06-06T22:02:11Z", "text": "(In reply to comment #4)\n> >          apr_table_unset(r->headers_out, \"Content-Length\");\n> > +        apr_table_unset(r->headers_out, \"ETag\");\n> \n> Ugh.  That way every filter has to reinvent protocol handling.  A fertile \n> breeding ground for bugs (and we have a history to prove it).  mod_filter is\n\nYes, and I am pretty sure we have this history :-), BUT mod_filter is not\nmandatory to use.\n \n> designed to centralise that, so we only need to get the protocol right once.\n\nAgreed, but then we must make the use of mod_filter (or at least the usage of\nthese parts) mandatory or must incorporate them into the core filter routines."}, {"count": 6, "tags": [], "text": "From a protocol perspective removing the ETag is sufficient to make you\ncompliant. If conditionals (If-xxx) anyway doesn't work right on transformed\nresponses there is not much benefit of sending an ETag out.\n\nBut if you can it's better if you send an ETag. As I said initially you don't\nneed  to compute a new etag, just adding some extra detail to the tag is fine.\n\nI.e. \"638f3e-6-1b6d6340-gzip\" or similar for a gzip:ed entity where the base\nentity had the etag \"638f3e-6-1b6d6340\".  To HTTP the etag is just a string with\nthe only requirement that it must be unique for each entity variants of the same\nURL.\n\nActually I think adding details to the ETag may simplify many things for you as\nthe core routines then can make quick asssssments of conditionals if it's\npossible to infer information about how the object had been processed from\nlooking at the entity tag.", "is_private": false, "bug_id": 39727, "id": 89851, "time": "2006-06-07T03:57:53Z", "creator": "hno@squid-cache.org", "creation_time": "2006-06-07T03:57:53Z", "attachment_id": null}, {"count": 7, "tags": [], "bug_id": 39727, "attachment_id": null, "id": 95998, "time": "2006-11-20T01:11:19Z", "creator": "hno@squid-cache.org", "creation_time": "2006-11-20T01:11:19Z", "is_private": false, "text": "Any progress on getting this patch (or another reasonable alternative) into the\nmod_deflate tree?"}, {"count": 8, "tags": [], "bug_id": 39727, "attachment_id": null, "id": 95999, "time": "2006-11-20T01:23:19Z", "creator": "nick@webthing.com", "creation_time": "2006-11-20T01:23:19Z", "is_private": false, "text": "(In reply to comment #7)\n> Any progress on getting this patch (or another reasonable alternative) into the\n> mod_deflate tree?\n\nIt needs raising on dev@ so we can reach a consensus solution.  Bugzilla has only proved that we have \nmore than one competing solution."}, {"count": 9, "tags": [], "bug_id": 39727, "attachment_id": null, "text": "This needs to be fixed by mod_deflate producing a new etag.  How we do that\nis going to take some investigation, since it doesn't do any good to produce\nthe etag unless we can also check it on conditional requests.\n", "id": 96584, "time": "2006-12-06T16:30:13Z", "creator": "fielding@apache.org", "creation_time": "2006-12-06T16:30:13Z", "is_private": false}, {"count": 10, "tags": [], "bug_id": 39727, "text": "My suggestion is to simply extend the existing etag with a gzip marker, for\nexample adding ;gzip at the end or something like that.\n\nI.e. if the original reply had\n\nETag: \"6bf1f7-6-1b6d6340\"\n\nThen make mod-gzip translate this to\n\nETag: \"6bf1f7-6-1b6d6340;gzip\"\n\nThis should allows for easy bidirectional mapping, simplifying most conditionals\nas no transformation of the entity body is needed to find the etag, and the\nsimple format makes it easier to trace should any misunderstandings occur.", "id": 96634, "attachment_id": null, "creator": "hno@squid-cache.org", "creation_time": "2006-12-07T14:19:16Z", "time": "2006-12-07T14:19:16Z", "is_private": false}, {"count": 11, "tags": [], "text": "Pinging dev@ one more time..", "is_private": false, "id": 107283, "creator": "hno@squid-cache.org", "time": "2007-08-27T05:25:52Z", "bug_id": 39727, "creation_time": "2007-08-27T05:25:52Z", "attachment_id": null}, {"count": 12, "tags": [], "bug_id": 39727, "is_private": false, "text": "Just committed a fix to make any ETag weak if we transform the entity. \nHopefully this should fix protocol compliance (and our users) without being\ncontroversial.\n", "id": 108888, "time": "2007-10-02T04:52:22Z", "creator": "nick@webthing.com", "creation_time": "2007-10-02T04:52:22Z", "attachment_id": null}, {"count": 13, "tags": [], "bug_id": 39727, "attachment_id": null, "id": 108910, "time": "2007-10-02T11:30:50Z", "creator": "hno@squid-cache.org", "creation_time": "2007-10-02T11:30:50Z", "is_private": false, "text": "Not sufficient. The two versions is not semantically equivalen as one can not be\nexchanged for the other without breaking the protocol. In the context of\nIf-None-Match the weak comparator is used in HTTP and there a strong ETag is\nequal to a weak ETag."}, {"count": 14, "tags": [], "text": "Can you elaborate in more detail why you think that the two versions are not\nsemantically equivalent? I read 13.3.3 in a way that they are.", "is_private": false, "id": 108911, "creator": "rpluem@apache.org", "time": "2007-10-02T11:51:52Z", "bug_id": 39727, "creation_time": "2007-10-02T11:51:52Z", "attachment_id": null}, {"count": 15, "tags": [], "text": "Because you can not exchange the gzip:ed variant with the identity encoded\nvariant wihout causing breakage. The two do not mean the same thing to a\nrecipient who do not know how to handle gzip.\n\nThe two is only semantically equivalent for a recipient capable of handling\ngzip, but not to HTTP in general as HTTP do not guarantee clients can handle gzip.\n\nIf they were semantically equivalent then there would be no need for conditional\nmod_gzip compression, or the use of Vary, at least not other than to reduce the\nload on the server under peak load...", "is_private": false, "bug_id": 39727, "id": 108912, "time": "2007-10-02T12:22:16Z", "creator": "hno@squid-cache.org", "creation_time": "2007-10-02T12:22:16Z", "attachment_id": null}, {"count": 16, "tags": [], "bug_id": 39727, "text": "What you can do is to either\n\na) Drop the ETag completely. This is not opimal but works..\n\nb) Or modify the ETag value in some manner. For example adding a constant string\ninfront or after the original ETag.\n\nIn 'b', if the compression is not deterministic and always resulting in the same\nencoding then the ETag should additionally be made weak, to make sure no one\nattemtps merging partial responses down the line..\n\n\n\nThe main downside of 'a' is that ETag aware caches will then cache multiple\ncopies of the same object, one per each slight varance of Vary indicated\nheaders. For Apache itself it's not so big difference until conditional requests\nworks proper in precense of filters like mod_deflate (i.e. If-None-Match).", "id": 108913, "attachment_id": null, "creator": "hno@squid-cache.org", "creation_time": "2007-10-02T12:30:37Z", "time": "2007-10-02T12:30:37Z", "is_private": false}, {"attachment_id": null, "tags": [], "bug_id": 39727, "is_private": false, "count": 17, "id": 108916, "time": "2007-10-02T12:54:58Z", "creator": "nick@webthing.com", "creation_time": "2007-10-02T12:54:58Z", "text": "(In reply to comment #15)\n> Because you can not exchange the gzip:ed variant with the identity encoded\n> variant wihout causing breakage. The two do not mean the same thing to a\n> recipient who do not know how to handle gzip.\n\nBugzilla is the wrong place for this discussion.  Should be on dev@httpd.\n\nOnly a recipient that can handle gzip will be served the gzipped version.\n\n> The two is only semantically equivalent for a recipient capable of handling\n> gzip, but not to HTTP in general as HTTP do not guarantee clients can handle gzip.\n\nHTTP provides a separate mechanism for negotiating that.\n\n> \n> If they were semantically equivalent then there would be no need for conditional\n> mod_gzip compression, or the use of Vary, at least not other than to reduce the\n> load on the server under peak load...\n\nHuh?  Those exist precisely because we need to cater for different clients."}, {"count": 18, "tags": [], "bug_id": 39727, "attachment_id": null, "text": "(In reply to comment #17)\n\n> Only a recipient that can handle gzip will be served the gzipped version.\n\nWhich isn't true due to this bug. If there is a ETag aware cache between the\nclient and Apache the client will be given whatever the previous client could\nhandle.\n\n> Huh?  Those exist precisely because we need to cater for different clients.\n\nExactly.", "id": 108922, "time": "2007-10-02T15:10:37Z", "creator": "hno@squid-cache.org", "creation_time": "2007-10-02T15:10:37Z", "is_private": false}, {"count": 19, "tags": [], "bug_id": 39727, "attachment_id": null, "text": "(In reply to comment #18)\n> (In reply to comment #17)\n> \n> > Only a recipient that can handle gzip will be served the gzipped version.\n> \n> Which isn't true due to this bug. If there is a ETag aware cache between the\n> client and Apache the client will be given whatever the previous client could\n> handle.\n\nThe intermediate got a weak ETag.  So the intermediate has been told that the\nentity is equivalent but not byte-by-byte identical, and may be subject to\nnegotiated transformation.  Therefore the intermediate is responsible for\ndealing with content-negotiated properties.\n\nDo you have a particular intermediate in mind, when you propose something that\ntreats a weak ETag as strong?", "id": 108943, "time": "2007-10-03T05:18:50Z", "creator": "nick@webthing.com", "creation_time": "2007-10-03T05:18:50Z", "is_private": false}, {"count": 20, "tags": [], "bug_id": 39727, "attachment_id": null, "id": 113010, "time": "2008-01-19T09:29:19Z", "creator": "takashi.asfbugzilla@tks.st", "creation_time": "2008-01-19T09:29:19Z", "is_private": false, "text": "2.2 r608849\nhttp://svn.apache.org/viewvc?view=rev&revision=608849"}, {"count": 21, "tags": [], "bug_id": 39727, "attachment_id": null, "text": "http://svn.apache.org/viewvc?view=rev&revision=581198\nhttp://svn.apache.org/viewvc?view=rev&revision=607219", "id": 114046, "time": "2008-02-27T04:49:12Z", "creator": "takashi.asfbugzilla@tks.st", "creation_time": "2008-02-27T04:49:12Z", "is_private": false}, {"attachment_id": null, "tags": [], "bug_id": 39727, "text": "This fix needs improvements. Etag needs to be quoted ;  this fix adds -gzip outside the quotes, so I get things like \"\"638f3e-6-1b6d6340\"-gzip which is ugly and not very RFC compliant.\n\nNow, another problem I got. I have 2 servers with mod_deflate and mod_cache. with mod_cache, I get validation \n\n-> If behind the same squid proxy I have servers with DeflateCompressionLevel set to 1, and other ones with DeflateCompressionLevel 7, and mod_cache enabled on get validation on different contents.\n(yes, I know that's a change strange setup).", "count": 22, "id": 120535, "time": "2008-09-11T06:00:58Z", "creator": "airmax@trolleur.net", "creation_time": "2008-09-11T06:00:58Z", "is_private": false}, {"attachment_id": 23050, "tags": [], "bug_id": 39727, "text": "Created attachment 23050\npatch that fixes the etags transformed by mod_deflate to be quoted strings\n\nAddresses the issue raised by Maxime Ritter - currently the Etags that are transformed by mod_deflate are not properly quoted and are not RFC compliant.", "count": 23, "id": 123512, "time": "2008-12-24T14:59:45Z", "creator": "shah.paritosh@gmail.com", "creation_time": "2008-12-24T14:59:45Z", "is_private": false}, {"count": 24, "tags": [], "bug_id": 39727, "attachment_id": 23051, "text": "Created attachment 23051\nfix etag checking in content handlers by stripping \"-gzip\" from etags in if headers\n\nA problem with adding \"-gzip\" to etags is that it breaks etag checking in If-* headers for content handlers ( e.g. mod_dav ) which will not recognize the \"-gzip\" etag as a valid etag for any entity of the resource. One way to fix this is to strip the \"-gzip\" suffix from the etags in If-None-Match and If-Match request headers. Attaching a patch to achieve this. It implements a fixup hook in mod_deflate and fixes etags in the respective headers. The patch has been tested with mod_dav_fs for If-Match and If-None-Match headers, with and without gzip encoding.\n\nNote: this patch depends on the previous patch (https://issues.apache.org/bugzilla/attachment.cgi?id=23050) having already been applied.", "id": 123542, "time": "2008-12-26T13:32:50Z", "creator": "shah.paritosh@gmail.com", "creation_time": "2008-12-26T13:32:50Z", "is_private": false}, {"count": 25, "tags": [], "text": "Committed patch to trunk fixing the creation of invalid Etag headers\nsuch as \n\n  Etag: \"2106e9-2c-3e9564c23b60\"-gzip\n\ninstead of \n\n  Etag: \"2106e9-2c-3e9564c23b60-gzip\"\n\nmod_deflate ignores invalid Etag headers not starting with a double quote,\nand weak Etag headers starting with \"W/\". \n\nhttp://svn.apache.org/viewvc?view=rev&revision=740149\n", "is_private": false, "id": 124610, "creator": "lars@apache.org", "time": "2009-02-02T15:27:04Z", "bug_id": 39727, "creation_time": "2009-02-02T15:27:04Z", "attachment_id": null}, {"count": 26, "tags": [], "bug_id": 39727, "attachment_id": null, "id": 124618, "time": "2009-02-03T00:24:45Z", "creator": "hno@squid-cache.org", "creation_time": "2009-02-03T00:24:45Z", "is_private": false, "text": "What do you mean by ignore weak etags?\n\nIf there is a weak ETag then it needs to be transformed as well, or removed. If not you'll still crash caches out there as object variants is identified by their ETag."}, {"count": 27, "tags": [], "text": "(In reply to comment #26)\n> What do you mean by ignore weak etags?\n> \n> If there is a weak ETag then it needs to be transformed as well, or removed. If\n> not you'll still crash caches out there as object variants is identified by\n> their ETag.\n> \n\nThis is discussible. A weak ETAG IMHO doesn't mean that both entities with the same weak ETAG are the same on binary level. But the weak ETAG only changes when the meaning of the entity changes (13.3.3, 3rd paragraph).\n", "is_private": false, "id": 124624, "creator": "rpluem@apache.org", "time": "2009-02-03T03:13:08Z", "bug_id": 39727, "creation_time": "2009-02-03T03:13:08Z", "attachment_id": null}, {"count": 28, "tags": [], "text": "(In reply to comment #26)\n> What do you mean by ignore weak etags?\n\nWell, the original code was only adding the gzip marker when the\nEtag was not starting with \"W/\", and I didn't changed this behavior.\n", "is_private": false, "bug_id": 39727, "id": 124625, "time": "2009-02-03T04:34:33Z", "creator": "lars@apache.org", "creation_time": "2009-02-03T04:34:33Z", "attachment_id": null}, {"count": 29, "tags": [], "bug_id": 39727, "attachment_id": null, "id": 124628, "time": "2009-02-03T06:17:14Z", "creator": "hno@squid-cache.org", "creation_time": "2009-02-03T06:17:14Z", "is_private": false, "text": "A weak ETag means the two are interchangeable for the same request (semantically equivalent) but may differ significantly at the octet level.\n\nA gzip and identity encoded entity is not interchangeable without serious breakage."}, {"count": 30, "tags": [], "text": "Just to clarify the breakage:\n\nGET /some-object\n\nHTTP/1.1 200 OK\nVary: Accept-Encoding\nETag: W/\"a\"\n\nGET /some-object\nAccept-Encoding: gzip\nIf-None-Match: W/\"a\"\n\nHTTP/1.1 304 Not Modified\nETag: W/\"a\"\n\n\nIf you are unsure what this is about, see 13.6  Caching Negotiated Responses.\n\n\nTo explain it in other words: Two resource versions MAY share the same weak ETag (but MUST NOT when using a strong ETag), but two incompatible resource representations MUST NOT.", "is_private": false, "id": 124629, "creator": "hno@squid-cache.org", "time": "2009-02-03T06:23:55Z", "bug_id": 39727, "creation_time": "2009-02-03T06:23:55Z", "attachment_id": null}, {"attachment_id": null, "tags": [], "bug_id": 39727, "text": "The HTTP syntax error has been fixed in trunk, but the problem\nmotivating this report is a no-win situation no matter how it is\n\"fixed\".  The only good answer is \"don't use mod_deflate\" because\nchanging content-encoding on the fly in an inconsistent manner\n(neither \"never\" nor \"always) makes it impossible for later\nrequests regarding that content (e.g., PUT or conditional GET)\nto be handled correctly.  This is, of course, why performing\non-the-fly content-encoding is a stupid idea, and why I added\nTransfer-Encoding to HTTP as the proper way to do on-the-fly\nencoding without changing the resource.\n\nmod_deflate is written as a content filter that can be arbitrarily\nadded to the output chain after the request is processed, just\nbefore the body goes out on the wire.  If mod_deflate modifies\nETag on the way out, then its corresponding later requests must\nbe reverse-modified (etags and request content) on the way back.\n\nThe problem here is that the DEFLATE filter is usually\nadded after the request is processed, based on the media type\nof the response, so there is no clear way of selectively inflating\na corresponding PUT or conditional request before the request\nprocessing is begun, especially if the request has been\nproxied to another server.  We would have to add a corresponding\ninput filter whenever the output filter is configured and ensure\nthat it would activate under the same conditions, based on the\nrequest header fields, as DEFLATE/INFLATE does for responses.\nI am still looking at this option.\n\nPreprocessing all incoming conditional headers to remove\na -gzip suffix before the request is processed won't work.\nIn a chain of Apache servers, we won't know which server\nset the suffix and how many caches have stored the modified\nETag versus the unmodified ETag.  We can't add some random\nunique id to the suffix, either, since we need the tag to\npersist across restarts.  In any case, that solution becomes\nso complex that we are better off deleting the module.\n\nFinally, we can't just remove the ETag because then the\nunfiltered content has an ETag but the filtered content\ndoes not, which puts us back to the point of messing up\na cache that is checking the 304 response for consistency.\nLikewise, removing etags for the entire configured scope\nallows clients to use the last-modified timestamp for range\nrequests, which would be just as bad as not changing ETag.\n\nThe best solution is to implement transfer-encoding as an\nhttp protocol filter module.\n", "count": 31, "id": 124828, "time": "2009-02-12T17:08:56Z", "creator": "fielding@apache.org", "creation_time": "2009-02-12T17:08:56Z", "is_private": false}, {"count": 32, "tags": [], "bug_id": 39727, "attachment_id": null, "id": 124829, "time": "2009-02-12T18:42:13Z", "creator": "hno@squid-cache.org", "creation_time": "2009-02-12T18:42:13Z", "is_private": false, "text": "Deleting the ETag+Content-Location is safe with respect to caches even if very suboptimal in terms of HTTP performance and cache validation robustness. It's highly undesireable, but still better than sending out the same ETag or Content-Location on incompatible respones.\n\nSending responses with an ETag and/or Content-Location which MAY be shared by an incompatible response for the same URL makes a true mess for caches. This applies to both 200 and 304 responses. The mess gets injected by the processing of 304 responses which may make incompatible but identified equal content migrate between different requeests.\n\nAnd yes, Roy is absolutely right. HTTP is not well suited for on-the-fly content recoding. You can't both eat the cake and keep it unless you do a lot of effort, far beyond the recoding itself. To anyone external from the server it SHOULD look like the recoding is in fact done statically with different representations stored on the server (i.e. page.html and page.html.gz) as negotiated by mod_negotiate, That means unique ETags and unique Content-Location, plus the If-* conditions working properly for all combinations.\n\nNot impossible, but not easy either."}, {"count": 33, "tags": [], "text": "Hi,\n\n\nI refer to https://issues.apache.org/bugzilla/show_bug.cgi?id=47253 . In\nthis situation imho fixing it this way is retrograde step. There is a\nquestion I would like to ask here:\n\nWhy you do not determined a policy?\n\n   - Etag will formed as usual.\n   - Configuration tree, that handle a resource, add fourth digest part\n     into Etag-values.\n   - Each filter transforming contents (on-the-fly) have to add a suffix.\n\nI imagine, each handler have a unique key (let's say mod_deflate \"DE\" and\nmod_include \"IN\" etc.). Configuration tree means a string consisting of\nall keys [ simple: next = etag_uint64_to_hex(next, \"IN:CH:DE\"); ]. So a\nchange of configurations will be unique in Etag as well. But sensible configuration information should encodet twice (first time nonreversible\nby including a static unique-ID of environment) to withhold clients from\nit. Already configuration tree is being parsed. It means there is a small\noverhead in prucedures like that.\n\nhttps://svn.apache.org/viewcvs.cgi?view=rev&rev=761835 it works fine befor\nchange. Only you should remove all added suffixes, then check condition\nrequests. Befor Etag-value are comprised that way:\n\"%{resource_digest}\"-suffix\nOnly check %{resource_digest}. (modules/http/http_protocol.c; function\nap_meets_conditions(); line 270)\n\nThe worse is yet to come:\nI see now way to determine mod_ext_filter. Handler module should remove\nall symbols form responce header line Cache-Control how make it cache\nable, and maybe statically add symbols to force inability.\n\nI'm sorry. English is not my nativ language. ;-\\\n\n\nWith best regards from Berlin\neddi", "is_private": false, "bug_id": 39727, "id": 127327, "time": "2009-05-23T05:22:29Z", "creator": "e.ehritt@web.de", "creation_time": "2009-05-23T05:22:29Z", "attachment_id": null}, {"count": 34, "tags": [], "bug_id": 39727, "attachment_id": null, "id": 136945, "time": "2010-05-18T17:42:42Z", "creator": "robert.collins@canonical.com", "creation_time": "2010-05-18T17:42:42Z", "is_private": false, "text": "We're encountering this problem using Apache as a front end SSL / compressing accelerator. Is there any chance of getting a patch in to permit stripping incoming ETag's of their -gzip suffix based on a configuration option ? In our topology we know precisely where -gzip is added, and thus how to strip it safely; we'd rather strip it in the stage matching where it was added outbound, rather than at a different step.\n\nI realise that this isn't theoretically complete, but crucially for us, it would do the job reliably."}, {"attachment_id": null, "tags": [], "bug_id": 39727, "text": "*** Bug 49358 has been marked as a duplicate of this bug. ***", "count": 35, "id": 137203, "time": "2010-05-29T08:25:05Z", "creator": "rainer.jung@kippdata.de", "creation_time": "2010-05-29T08:25:05Z", "is_private": false}, {"count": 36, "tags": [], "bug_id": 39727, "is_private": false, "text": "Any news about this more than five years old bug?", "id": 149212, "time": "2011-09-14T11:51:55Z", "creator": "oliver@siegmar.de", "creation_time": "2011-09-14T11:51:55Z", "attachment_id": null}, {"count": 37, "tags": [], "bug_id": 39727, "attachment_id": null, "is_private": false, "id": 161215, "time": "2012-08-09T22:42:23Z", "creator": "ache@vniz.net", "creation_time": "2012-08-09T22:42:23Z", "text": "Since different gzip compression levels are semantically equal, you can _always_ send weak tag when using gzip with any compression level, with -gzip suffix like that:\n\nETag: W/\"76e23-1835-4156af5e53ac0-gzip\""}, {"count": 38, "tags": [], "bug_id": 39727, "attachment_id": null, "id": 168649, "time": "2013-07-17T16:45:45Z", "creator": "anshulagrawal@gmail.com", "creation_time": "2013-07-17T16:45:45Z", "is_private": false, "text": "The server response contains proper Vary header clearly indicating the response varies depending whether client is able to accept gzip content or not.\n\nIn that case, the responsibility lies with the intermediate proxy to make sure all conditional headers check are met before sending a cached response for an ETag.\n\nFor the implications mentioned in the description:\n* The repeat request from same client will have same value for \"Accept-Encoding\" header as well as User Agent string meaning Apache has sufficient information to decide whether to send plain text or gzipped response. If-None-Match can have same ETag value in both case and still server should have no problem deciding which response to send.\n\n* The above logic covers range queries as well."}, {"count": 39, "tags": [], "text": "This has already been discussed to death and still comes back...\n\nThere is no escape from the rule that each variant of a given URL MUST have a unique ETag value, or none at all. How the ETag value is formed is entirely up ot the server implementation and may carry any amount of unstructured and structured data as needed by the server to uniquely identify a variant.\n\nWeak ETags have slightly different rules but is irrelevant to this discussion. Applies i.e. to when using dynamic adjustment of gzip encoding levels based on CPU load, but not for identity vs gzip encoded variant which are semantically different.\n\n(In reply to Anshul from comment #38)\n> The server response contains proper Vary header clearly indicating the\n> response varies depending whether client is able to accept gzip content or\n> not.\n\nNo. The server has sent a Vary header indicating that the servers variant selection depends on the content of the Accept-Encoding header in the request, and quite often User-Agent as well.\n\n> In that case, the responsibility lies with the intermediate proxy to make\n> sure all conditional headers check are met before sending a cached response\n> for an ETag.\n\nNo. It's the origin servers responsibility to perform variant selection. Caches uses If-None-Match to ask the server which variant among a set of known cached variants of the requested URL should be used in response to unknown request combinations. The response to such requests ONLY says \"Use the variant with ETag XXXX\".\n\nSemantically transparent proxies are not allowed to guess what variant selection preferences the server has. I.e. which browsers it had blacklisted content of type X for etc, or which browsers the server knows handles gzip content encoding when there is not Accept-encoding header present.\n\ngzip compression is onlhy a tiny tiny little bit of server side variant selection. The same mechanism for selecting the correct variant amont a set of cached variants of a URL is used for a vide variety of response variance (selection of content-encoding, content-language, content-type, browser based, custom headers, etc etc)\n\nNote: Apache mod_negotiation does the right thing in all cases known. Issues only arise with dynamic content encoding with mod_deflate (and a numbe of other similar modules performing dynamic content transformation) often forgetting about the meaning of ETag and it's relation to If-None-Match.", "attachment_id": null, "bug_id": 39727, "id": 168653, "time": "2013-07-18T06:23:24Z", "creator": "hno@squid-cache.org", "creation_time": "2013-07-18T06:23:24Z", "is_private": false}, {"count": 40, "tags": [], "text": "Just so folks know, the authoritative text on this topic will soon be:\n  http://tools.ietf.org/html/draft-ietf-httpbis-p4-conditional-26", "attachment_id": null, "bug_id": 39727, "id": 174938, "time": "2014-04-30T10:01:26Z", "creator": "mnot@mnot.net", "creation_time": "2014-04-30T10:01:26Z", "is_private": false}, {"count": 41, "tags": [], "bug_id": 39727, "attachment_id": null, "text": "I've been going through the comments and some of the links mentioned and I'm unsure if this issue will be resolved or I should implement a work-around on my side.\n\nThis ticket is open for 9 years now and it is still relevant with apache 2.4.\nIs it a WONT FIX ? What's the recent status here for apache users?\n\nThanks", "id": 182757, "time": "2015-04-30T11:11:21Z", "creator": "shmulikk@gmail.com", "creation_time": "2015-04-30T11:11:21Z", "is_private": false}]