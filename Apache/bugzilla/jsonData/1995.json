[{"count": 0, "tags": [], "text": "howdy\n\nconsider a model 2 architecture web-app that consists of:\n  a servlet that makes up a page by including:\n    a header JSP\n    a controller servlet that provides content by including:\n       a content JSP\n    a footer JSP\n\n(these are included below: S1.java S2.java header.jsp content.jsp & footer.jsp)\n\non the first invocation of the webapp, only the 'content' is present on the \npage despite the header and footer JSPs being called (as evidenced by a trace \non stdout).  on subsequent invocations the output from all the JSPs is present.\n\nmy guess is that the output buffer is being reset at some point: i came across \nthis bug (or very similar) while developing a real app that always threw \nan \"IllegalStateException: Cannot forward after response has been committed\" \nat \"org.apache.catalina.core.ApplicationDispatcher.doForward \n(ApplicationDispatcher.java:301)\" whenever a page was accessed the first time \nbut not on subsequent accesses.  note that \"doForward\" is called despite the \nfact that \"requestDispatcher.include\" was originally called. my test app was \nunable to reproduce this but does suffer similar problems as described.\n\nboth real and test apps work as expected on TC3.2.1\n\nlater\nmark\n\n--8<-- S1.java\n\nimport java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic final class S1\nextends HttpServlet\n{\n\tpublic void service(HttpServletRequest req, HttpServletResponse res)\n\tthrows ServletException, IOException\n\t{\n\t\tres.setContentType(\"text/html; charset=UTF-8\");\n\t\tgetServletContext().getRequestDispatcher(res.encodeURL\n(\"/header.jsp\")).include(req, res);\n\t\tgetServletContext().getRequestDispatcher(res.encodeURL\n(\"/servlet/S2\")).include(req, res);\n\t\tgetServletContext().getRequestDispatcher(res.encodeURL\n(\"/footer.jsp\")).include(req, res);\n\n\t} \t\n}\n\n--8<-- S2.java\n\nimport java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic final class S2\nextends HttpServlet\n{\n\tpublic void service(HttpServletRequest req, HttpServletResponse res)\n\tthrows ServletException, IOException\n\t{\n\t\tgetServletContext().getRequestDispatcher(res.encodeURL\n(\"/content.jsp\")).include(req, res);\n\t} \t\n}\n\n--8<-- header.jsp\n\n<%@ page session=\"false\" %>\n<% System.out.println(\"header\"); %>\n<h1>header</h1>\n\n--8<-- content.jsp\n\n<%@ page session=\"false\" %>\n<% System.out.println(\"content\"); %>\n<h3>content</h3>\n\n--8<-- footer.jsp\n\n<%@ page session=\"false\" %>\n<% System.out.println(\"footer\"); %>\n<h6>footer</h6>", "attachment_id": null, "id": 2739, "creator": "mrobinson@baltimore.com", "time": "2001-06-04T19:08:13Z", "bug_id": 1995, "creation_time": "2001-06-04T19:08:13Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 1995, "attachment_id": null, "is_private": false, "id": 3599, "time": "2001-07-10T17:09:40Z", "creator": "craig.mcclanahan@sun.com", "creation_time": "2001-07-10T17:09:40Z", "text": "NOTE - it is not valid (or required) to call response.encodeURL() on the\nargument to ServletContext.getRequestDispatcher().  This is only required in the\nresponse that is ultimately sent back to the client.\n"}, {"count": 2, "attachment_id": null, "bug_id": 1995, "is_private": false, "id": 3746, "time": "2001-07-16T17:20:07Z", "creator": "craig.mcclanahan@sun.com", "creation_time": "2001-07-16T17:20:07Z", "tags": [], "text": "The change I just checked in for InvokerServlet *should* fix this problem.  \nCould you try it with the 20010717 nightly build?\n\nThe underlying problem was the way that the InvokerServlet (/servlet/*) was \nworking.  On the first request to a particular servlet, the invoker would set up \na new Wrapper and associated <servlet-mapping> dynamically, which would be used \non all subsequent requests.  However, it would then try to use a \nRequestDispatcher.forward() to actually process that first request.  This caused \ntwo things to happen:\n- Any content written before the invoked servlet would be erased\n- Any content written after the invoked servlet returns would be ignored\n(which matches your symptoms).\n\nNow, InvokerServlet executes the newly allocated servlet directly, instead of \nusing a request dispatcher, so these things no longer happen.\n\nNote -- this problem did not exist before for servlets that were actually mapped \nin the web.xml file (such as the way that Struts maps \"*.do\" to the controller \nservlet).  It only affected cases where the included servlet was accessed \nthrough the invoker servlet, AND this was the first request to that servlet.\n\n"}]