[{"text": "It seems to me that under some circumstances Tomcat don't release file \nhandlers. I have the problem that after a while I got a lot of IOexceptions, \nbecause there are no more file handlers. Increasing the number of handlers with \nulimit only shifts the problem in time, but is not a solution. I'm not really \nsure where it happens. I can see it in the log file:\n\nWebappClassLoader: Failed to open JAR\njava.util.zip.ZipException: Too many open files\n\tat java.util.zip.ZipFile.open(Native Method)\n\tat java.util.zip.ZipFile.<init>(ZipFile.java:112)\n\tat java.util.jar.JarFile.<init>(JarFile.java:127)\n\tat java.util.jar.JarFile.<init>(JarFile.java:92)\n\tat org.apache.catalina.loader.WebappClassLoader.openJARs\n(WebappClassLoader.java:1549)\n\tat org.apache.catalina.loader.WebappClassLoader.findResourceInternal\n(WebappClassLoader.java:1771)\n\tat org.apache.catalina.loader.WebappClassLoader.findClassInternal\n(WebappClassLoader.java:1575)\n\tat org.apache.catalina.loader.WebappClassLoader.findClass\n(WebappClassLoader.java:860)\n\tat org.apache.catalina.loader.WebappClassLoader.loadClass\n(WebappClassLoader.java:1307)\n\tat org.apache.catalina.loader.WebappClassLoader.loadClass\n(WebappClassLoader.java:1189)\n\tat java.lang.ClassLoader.loadClassInternal(ClassLoader.java:302)\n[...]\n\nwhen I take a look at the WebappClassLoader.java everything seems to be okay, \nas far as I can see from the logic all file handles should be closed before new \nfiles are assigned. Anyway I could at some places imagine situations where an \nIOException won't close all file handlers. In such cases the openJAR method \nwill overwrite existing jarFiles[] entries without closing them (try-catch \noutside loop). A simple solution would be to ensure integrity of jarFiles[] \nbefore changes (i.e. check whether the array entry is really closed and null), \nof course unreferenced file objects should be closed automatically somehow, but \nthis seems not to happen (I got almost 1 GB log-file with this error during 2 \ndays, so there is definetyl a leak). For installations with more deployments a \nglobal LRU-Cache with a fixed size upper limit of open filed would be probably \nmore appropriate.", "tags": [], "creator": "sd@mediaclockwork.de", "is_private": false, "count": 0, "id": 61225, "time": "2004-07-28T12:36:34Z", "bug_id": 30362, "creation_time": "2004-07-28T12:36:34Z", "attachment_id": null}, {"count": 1, "attachment_id": null, "bug_id": 30362, "text": "I didn't see anyone else reporting that. On Windows, I think this would cause\nfile locking, and the CL doesn't do that.\nSo can you submit a patch to release whatever files you think are leaked,\nbecause I can't understand where it would happen ? Thanks.", "id": 61227, "time": "2004-07-28T13:18:05Z", "creator": "remm@apache.org", "creation_time": "2004-07-28T13:18:05Z", "tags": [], "is_private": false}, {"count": 2, "tags": [], "bug_id": 30362, "attachment_id": null, "is_private": false, "id": 61231, "time": "2004-07-28T14:36:46Z", "creator": "sd@mediaclockwork.de", "creation_time": "2004-07-28T14:36:46Z", "text": "okay, first of all the tomcat is on a linux box - no windows !\n\nSo here are my concerns in WebappClassloader:\n    public void closeJARs(boolean force) {\n        if (jarFiles.length > 0) {\n            try {\n                synchronized (jarFiles) {\n                    if (force || (System.currentTimeMillis()\n                                  > (lastJarAccessed + 90000))) {\n                        for (int i = 0; i < jarFiles.length; i++) {\n                            if (jarFiles[i] != null) {\n                                jarFiles[i].close();\n                                jarFiles[i] = null;\n                            }\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                log.warn(\"Failed to close JAR\", e);\n            }\n        }\n    }\n\nIf you get an IOException the for-loop will break, and not run through the rest \nof possible still open files. If you take then a look at \n    protected void openJARs() {\n        if (started && (jarFiles.length > 0)) {\n            lastJarAccessed = System.currentTimeMillis();\n            if (jarFiles[0] == null) {\n                try {\n                    for (int i = 0; i < jarFiles.length; i++) {\n                        jarFiles[i] = new JarFile(jarRealFiles[i]);\n                    }\n                } catch (IOException e) {\n                    log.warn(\"Failed to open JAR\", e);\n                }\n            }\n        }\n    }\nOnly the first array entry is checked for \"null\", so if there are other not \nclosed entries, they will simply overwritten without closing them first. I'm \nnot sure, whether this is really the point of failure, but this was my first \nguess looking at the code. So a solution would be e.g.:\n\n    protected void openJARs() {\n        if (started && (jarFiles.length > 0)) {\n            lastJarAccessed = System.currentTimeMillis();\n            if (jarFiles[0] == null) {\n                try {\n                    for (int i = 0; i < jarFiles.length; i++) {\n                        if (jarFiles[i]!=null){// would prefer a isClosed() \ncheck too, but seems not be available\n                            jarFiles[i].close(); \n                            jarFiles[i]=null;\n                        }\n                        jarFiles[i] = new JarFile(jarRealFiles[i]);\n                    }\n                } catch (IOException e) {\n                    log.warn(\"Failed to open JAR\", e);\n                }\n            }\n        }\n    }\n\nor in closeJARs just move the try-catch inside the for-loop (it's expensive, I \nknow), but may be a simple\nfinally{\n continue;\n}\nwould do too, because the IOException will break the loop and the finally will \ncontinue it, I'm not sure whether this works with an inner synchronized block - \nnever thought about this, I gues from JVM spec it should work ?\n\nStill not sure, that this is really the point, but I can assure you, I got tons \nof this exception. "}, {"count": 3, "tags": [], "creator": "remm@apache.org", "text": "Ok, indeed it would be a good idea moving try catch inside the loop, but you\nshould't get any IOE here. You have a serious problem somewhere causing this, IMO.", "id": 61235, "time": "2004-07-28T15:00:58Z", "bug_id": 30362, "creation_time": "2004-07-28T15:00:58Z", "is_private": false, "attachment_id": null}, {"count": 4, "tags": [], "creator": "sd@mediaclockwork.de", "text": "First, I think you can get an IOE here if you delete a jar-file which is \nreferenced in the application, so the native close operation on the file \nhandler may fail with an IOE.\nBut this is probably not our case, so still I'm not sure that the code of \nWebappClassloader is causing the problem of the file handler leak since this is \nan OS resource and shared by all classes using files, so it could also happen \nsomewhere else.\nIn addition I still don't think it's a good idea to hold open references to all \njar's here, because if you have a lot of applications with lots of jars to \nload, you might get to the OS limits. \nIn \"normal\" cases this won't be a problem, but you might run against \nthe \"ulimit -n\" limit, a more dynamic approach would be more failsafe (i.e. NOT \nset ulimit -n to maximum of your OS :-) ). \nYou still have another array with filenames and pathes, so you can create file \nobjects on demand. If you look at the constructor of ZipFile (and Jarfile \ninherits from there) there is an implicit native open(...) call, which might \nuse one OS file handle (I don't know the implementation of this native method, \nso ???)\nOk, creating handles on demand might be more expensive, so to avoid this a \nstatic LRU Cache with a fixed (or even decreasable) size might solve problems \nhere. \nIf I'm totally wrong here (i.e. this could not happen, because some logic will \nprevent from problem), please tell me. \n\nSince then I'm still searching the leak...", "id": 61266, "time": "2004-07-28T17:50:57Z", "bug_id": 30362, "creation_time": "2004-07-28T17:50:57Z", "is_private": false, "attachment_id": null}, {"count": 5, "tags": [], "bug_id": 30362, "attachment_id": null, "is_private": false, "id": 61268, "time": "2004-07-28T19:40:37Z", "creator": "mdang@interwoven.com", "creation_time": "2004-07-28T19:40:37Z", "text": "So I am curious to know if you fix the suspected section on your local build, \ndo you see the problem go away?\n\nI am also seeing handle leak on my app, handle count grows from 1000 to 1500 \nand then crash, but I am not sure if that is Tomcat\u2019s issue yet.  There are \nmany things I need to check, but I just wonder if this jar fix is worth a try.\n\nThanks."}, {"count": 6, "tags": [], "bug_id": 30362, "attachment_id": null, "is_private": false, "id": 61280, "time": "2004-07-28T22:03:27Z", "creator": "yoavs@computer.org", "creation_time": "2004-07-28T22:03:27Z", "text": "That's a good idea -- rather than writing up pages and pages of discussion, \nplease test your patch.  If it works for you, please create an attachment for \nthis issue with the patch in diff format as usual, not the whole file.\n\nIn the future, you may wish to discuss any issues you're seeing on the tomcat-\nuser list before opening bugzilla items for them, especially if you're not \nsure how they could be occurring."}, {"count": 7, "tags": [], "bug_id": 30362, "attachment_id": null, "is_private": false, "id": 61291, "time": "2004-07-29T07:49:46Z", "creator": "rainer.jung@kippdata.de", "creation_time": "2004-07-29T07:49:46Z", "text": "You could use lsof on the live system to find out, which files or sockets are\nbeing held open."}, {"count": 8, "attachment_id": null, "bug_id": 30362, "text": "Thanks for the lsof hint. \nI analyzed the situation on a different machine and first thing was really the \nhuge amount of open files from Tomcat uses. This must have been an issue \nalready in the past, cause I found the comment:\n        // Close all JARs right away to avoid always opening a peak number \n        // of files on startup\n        if (getLoader() instanceof WebappLoader) {\n            ((WebappLoader) getLoader()).closeJARs(true);\n        }\n(StandardContext.java). Nevertheless this seems to be the only point where open \njar-files are closed, later on they might reopened and onle be closed if a \nwebapp will stop() (btw: there the try-catch is inside the for-loop). On the \nmachine we have normally 7 Webapps and 1763 open handles reported by lsof to \njar files. The same jar files are opened up to 40 times according to lsof, \nsorry to say so, but I don't think this is necessary and is messing up with \nsystem resources. On the test machine we often deploy new versions and then we \ncome to the ulimit limits sometimes (also sometimes we see a \"Failed to close \nJAR\" error, which leads to additional unclosed and forgotten jars).\nI would like to make a patch which will do two things:\n-> reduce the amount of open handles to same file, by using a global jar-file \ncache such that jar-fiels with same path are opened only once.\n-> restrict the number of parallel open handles by using an LRU-Cache for the \nglobal cache (e.g. hard limit to 500).\nSince this might affect design issues, I would like to get a comment about \nthis, before start programming it.", "id": 61365, "time": "2004-07-30T08:55:51Z", "creator": "sd@mediaclockwork.de", "creation_time": "2004-07-30T08:55:51Z", "tags": [], "is_private": false}, {"count": 9, "tags": [], "creator": "remm@apache.org", "text": "This makes little sense to me so far, sorry.\nAbout the comment, your conslusion is wrong. About never closing JARs: look closer.\nDon't implement waht wou propose, I would refuse it. There's no need for a\n\"global\" structure, because one JAR belongs to a classloader, which is unique\nfor a given webapp. When the classloader is stopped, the JARs are closed. Where\nis that \"resource leak\" that nobody else is seeing ?", "id": 61366, "time": "2004-07-30T09:12:07Z", "bug_id": 30362, "creation_time": "2004-07-30T09:12:07Z", "is_private": false, "attachment_id": null}, {"count": 10, "tags": [], "bug_id": 30362, "attachment_id": null, "is_private": false, "id": 61369, "time": "2004-07-30T10:48:59Z", "creator": "sd@mediaclockwork.de", "creation_time": "2004-07-30T10:48:59Z", "text": "As far as I can see each classloader also loads the \"global\" jars from \nCatalina, which would be the same for all web applications, so they are opened \nmore than once and are not unique to the classloader. These could be shared \neasily with a global structure. Also leaving all jar's open all the time a web-\napp is running is still messy for servers with lot of webapps. And why did \nsomeone bother to close the jars after starting, if it wasn't necessary at some \npoint ? You're right about closing all jars when stopping, I saw this, but \nstill habe concerns about unreferenced jarfiles, because of the ioe catch \noutside the loop, may be this could be at least patched.\nAnyway we're testing now with a subclass of the classloader changing the \nopenJARs method to avoid system limitations and it looks promising, so we'll \nfollow that path instead of providing a patch (I wasn't really glad about this \nidea). We'll use an LRU with in-/decreasing upper limit, such that any IOE will \nincrease the maximum amount of open jars with some lower notification limit. At \nleast we don't have so many open file handles as before, and we will probably \nno longer see the original exception at this point."}, {"count": 11, "tags": [], "bug_id": 30362, "attachment_id": null, "is_private": false, "id": 61370, "time": "2004-07-30T11:13:44Z", "creator": "remm@apache.org", "creation_time": "2004-07-30T11:13:44Z", "text": "Yes, the JARs in common/lib are global. However, they are not opened by the\nwebapps classloaders, but rather by a shared classloader to which the webapps\nCLs delegate.\nI did move the try/catch inside the loop, as I don't see any reason not to. I\ndon't really see why it would fix too many things, but it definitely doesn't hurt.\n\nNote: I did add the code which closes the JARs during startup. Since we load all\nwebapps, I thought there would be good to avoid keeping too much stuff open\nuntil the webapp needs more classes. I think you didn't see the periodic operation."}]