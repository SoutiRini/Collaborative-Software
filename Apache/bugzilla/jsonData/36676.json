[{"count": 0, "tags": [], "bug_id": 36676, "text": "I am currently developing a socket server for winblows and wanted to emulate \nSIGCHLDs in the parent process ... unix fork() feel.  To do this, I have to \nkeep an array of win32 process HANDLE objects returned by CreateProcess() that \nI pass to WSAWaitForMultipleEvents(), along with some WSAEVENTs.  The problem \nis that once again winblows has an annoying limit: MAXIMUM_WAIT_OBJECTS.  I \nsearch the interent for ideas and came across apaches wait_for_many_objects \nfunction in the http-2.0 project.  It's in os/win32/util_win32.c.  I found bug \nin there and thought I would submit the solution I used in my code. \n\nBUG:\nThe function uses time() to mark the wait_stop_time.  It also uses time() to \nverify when to expire the wait attempt.  The problem here is if someone plays \nwith the windows clock (a person, ntp, etc).  If you set the clock back a few \nhours, the wait period goes way beyond what it is supposed to.  The solution is \nto use the win32 QueryPerformanceCounter() function (shown below).\n\nHere are the modifications I made.\n\nstatic LONGLONG freq_per_msec=0;\nstatic void (*wait_clock)(void);\n\nstatic LONGLONG freq_clock(void)\n{\n  LARGE_INTEGER li;\n  QueryPerformanceCounter(&li);\n  return li.QuadPart / freq_per_msec;\n}\n\n/* in case machine doesn't support performace counter, not based on OSVer. */\nstatic LONGLONG time_clock(void)\n{\n  FILETIME ft;\n  LARGE_INTEGER li;\n  GetSystemTimeAsFileTime(&ft);\n  li.LowPart = ft.dwLowDateTime;\n  li.HighPart = ft.dwHighDateTime;\n  return li.QuadPart / 10000;\n}\n\n/* \n * cache the frequency, in ms, and the correct wait func.  winblows states some\n * hardware may not support the performace counter.  In those cases, I used \n * GetSystemTimeAsFileTime() which suffers from the same issues as calling time\n(),\n * although it a faster call.\n */\nvoid util_win32_init(void)\n{\n  LARGE_INTEGER li;\n  \n  /* winblows states some . */\n  li.QuadPart = 0;\n  if(QueryPerformanceFrequency(&li) && li.QuadPart)\n  {\n    freq_per_msec = li.QuadPart / 1000;\n    wait_clock = s_PerformanceClock;\n  }\n  else\n  {\n    wait_clock = time_clock;\n  }\n}\n\n/*\n * The Win32 call WaitForMultipleObjects will only allow you to wait for\n * a maximum of MAXIMUM_WAIT_OBJECTS (current 64).  Since the threading\n * model in the multithreaded version of apache wants to use this call,\n * we are restricted to a maximum of 64 threads.  This is a simplistic\n * routine that will increase this size.\n */\nDWORD wait_for_many_objects(DWORD nCount, CONST HANDLE *lpHandles, \n                            DWORD /*dwSeconds*/dwMilliseconds)\n{\n  //time_t tStopTime;\n  LONGLONG tStopTime;\n  DWORD dwRet = WAIT_TIMEOUT;\n  DWORD dwIndex=0;\n  BOOL bFirst = TRUE;\n  \n  \n  //tStopTime = time(NULL) + dwSeconds;\n  tStopTime = wait_clock() + dwMilliseconds;\n  \n  do {\n    if (!bFirst)\n      Sleep(1000 /*100*/); // Why 1 second?\n    else\n      bFirst = FALSE;\n\n    for (dwIndex = 0; dwIndex * MAXIMUM_WAIT_OBJECTS < nCount; dwIndex++) {\n      dwRet = WaitForMultipleObjects( \n        min(MAXIMUM_WAIT_OBJECTS, nCount - (dwIndex * MAXIMUM_WAIT_OBJECTS)),\n        lpHandles + (dwIndex * MAXIMUM_WAIT_OBJECTS), \n        0, 0);\n\n      if (dwRet != WAIT_TIMEOUT) {                                          \n        break;\n      }\n    }\n    // personally, I would check dwRet before making the func call\n  } while((dwRet == WAIT_TIMEOUT) && (wait_clock() < tStopTime));\n  //while((time(NULL) < tStopTime) && (dwRet == WAIT_TIMEOUT));\n\n  return dwRet;\n}", "id": 80002, "time": "2005-09-15T21:07:49Z", "creator": "achernow@yahoo.com", "creation_time": "2005-09-15T21:07:49Z", "is_private": false, "attachment_id": null}, {"count": 1, "tags": [], "bug_id": 36676, "attachment_id": null, "id": 80003, "time": "2005-09-15T21:17:51Z", "creator": "achernow@yahoo.com", "creation_time": "2005-09-15T21:17:51Z", "is_private": false, "text": "Sorry, I have a typo in util_win32_init(). s_PerformanceClock should be freq_clock."}]