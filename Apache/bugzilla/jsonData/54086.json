[{"count": 0, "tags": [], "text": "Solaris 10 x86, jdk 1.7.\n\nWe use tomcat clustering for session replication with 4 nodes and sometimes 8 nodes.  We get a ConcurrentModificationException occasionally on shutdown.  I have been unable to reliably reproduce the exception. In the log, I see \"Unable to close cluster receiver selector.\" with the exception below:\n\njava.util.ConcurrentModificationException \n    java.util.HashMap$HashIterator.nextEntry(HashMap.java:894) \n    java.util.HashMap$KeyIterator.next(HashMap.java:928) \n    java.util.Collections$UnmodifiableCollection$1.next(Collections.java:1067) \n    org.\u200bapache.\u200bcatalina.\u200btribes.\u200btransport.\u200bnio.\u200bNioReceiver.\u200bcloseSelector(\u200bNioReceiver.\u200bjava:382) \n    org.\u200bapache.\u200bcatalina.\u200btribes.\u200btransport.\u200bnio.\u200bNioReceiver.\u200bstopListening(\u200bNioReceiver.\u200bjava:365) \n    org.apache.catalina.tribes.transport.nio.NioReceiver.stop(NioReceiver.java:86) \n    org.\u200bapache.\u200bcatalina.\u200btribes.\u200bgroup.\u200bChannelCoordinator.\u200binternalStop(\u200bChannelCoordinator.java:203) \n    org.\u200bapache.\u200bcatalina.\u200btribes.\u200bgroup.\u200bChannelCoordinator.\u200bstop(\u200bChannelCoordinator.\u200bjava:115) \n    org.\u200bapache.\u200bcatalina.\u200btribes.\u200bgroup.\u200bChannelInterceptorBase.\u200bstop(\u200bChannelInterceptorBase.java:178) \n    org.\u200bapache.\u200bcatalina.\u200btribes.\u200bgroup.\u200bChannelInterceptorBase.\u200bstop(\u200bChannelInterceptorBase.java:178) \n    org.\u200bapache.\u200bcatalina.\u200btribes.\u200bgroup.\u200bChannelInterceptorBase.\u200bstop(\u200bChannelInterceptorBase.java:178) \n    org.\u200bapache.\u200bcatalina.\u200btribes.\u200bgroup.\u200binterceptors.\u200bMessageDispatchInterceptor.\u200bstop(\u200bMessageDispatchInterceptor.java:172)\n    org.\u200bapache.\u200bcatalina.\u200btribes.\u200bgroup.\u200bChannelInterceptorBase.\u200bstop(\u200bChannelInterceptorBase.java:178) \n    org.\u200bapache.\u200bcatalina.\u200btribes.\u200bgroup.\u200bChannelInterceptorBase.\u200bstop(\u200bChannelInterceptorBase.java:178) \n    org.apache.catalina.tribes.group.GroupChannel.stop(GroupChannel.java:438) \n    org.\u200bapache.\u200bcatalina.\u200bha.\u200btcp.\u200bSimpleTcpCluster.\u200bstopInternal(\u200bSimpleTcpCluster.\u200bjava:\u200b744) \n    org.apache.catalina.util.LifecycleBase.stop(LifecycleBase.java:232) \n    org.apache.catalina.core.ContainerBase.stopInternal(ContainerBase.java:1199) \n    org.apache.catalina.util.LifecycleBase.stop(LifecycleBase.java:232) \n    org.apache.catalina.core.StandardService.stopInternal(StandardService.java:502) \n    org.apache.catalina.util.LifecycleBase.stop(LifecycleBase.java:232) \n    org.apache.catalina.core.StandardServer.stopInternal(StandardServer.java:753) \n    org.apache.catalina.util.LifecycleBase.stop(LifecycleBase.java:232) \n    org.apache.catalina.startup.Catalina.stop(Catalina.java:751) \n    org.apache.catalina.startup.Catalina.start(Catalina.java:713) \n    sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) \n    sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) \n    sun.\u200breflect.\u200bDelegatingMethodAccessorImpl.\u200binvoke(\u200bDelegatingMethodAccessorImpl.\u200bjava:43) \n    java.lang.reflect.Method.invoke(Method.java:601) \n    org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:322) \n    org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:451)\n\nI looked at the code briefly and noticed the use of a SelectionKey Iterator.  I have not dug deep enough to find any issue in the NioReceiver code, but I did find this potentially relevant text in the Selector javadocs (http://docs.oracle.com/javase/7/docs/api/java/nio/channels/Selector.html):\n\n\"A selector's key and selected-key sets are not, in general, safe for use by multiple concurrent threads. If such a thread might modify one of these sets directly then access should be controlled by synchronizing on the set itself. The iterators returned by these sets' iterator methods are fail-fast: If the set is modified after the iterator is created, in any way except by invoking the iterator's own remove method, then a ConcurrentModificationException will be thrown.\"", "is_private": false, "bug_id": 54086, "id": 163112, "time": "2012-11-01T13:32:28Z", "creator": "clucas@e-miles.com", "creation_time": "2012-11-01T13:32:28Z", "attachment_id": null}, {"count": 1, "tags": [], "text": "Thanks for the report. I did see a code path that would result in two threads both trying to close the Selector. This, and some other threading issues, have been fixed in trunk and 7.0.x and will be included in 7.0.33 onwards.\n\nI can't be 100% certain that the problem I found is the one you were seeing but it looks very much like it.", "is_private": false, "bug_id": 54086, "id": 163165, "time": "2012-11-05T00:25:32Z", "creator": "markt@apache.org", "creation_time": "2012-11-05T00:25:32Z", "attachment_id": null}, {"count": 2, "tags": [], "text": "I verified that this problem still exists in 7.0.41.  I tracked down and fixed the problem.\n\nProblem:\nDuring shutdown, NioReceiver.close() is called which ultimately calls NioReceiver.closeSelector(). selector.keys() is called and an iteration is performed - closing the existing channels and canceling the keys.  Per the Selector javadocs, the set cannot be modified during iteration by another thread or else a ConcurrentModificationException will be thrown.  The set is in fact being modified by another thread (NioReceiver thread) when existing connections are closed (see listen() and canceledKey(SelectionKey) methods).\n\nThe problem is difficult to reproduce because of timing. I was able to reliably reproduce the problem but I had to add a sleep in the closeSelector() method and or set breakpoints during testing.  Ultimately, I couldn't come up with a test case that didn't need a sleep in closeSelector() so I don't have a test case for the attached patch.\n\nThe attached patch loops (up to 3 times) catching ConcurrentModificationException during close and sleeps for a brief period (100ms * attempt number) allowing the NioReceiver thread to finish it's loop. After the sleep, it attempts to close channels again.", "attachment_id": null, "bug_id": 54086, "id": 168078, "time": "2013-06-26T20:03:09Z", "creator": "clucas@e-miles.com", "creation_time": "2013-06-26T20:03:09Z", "is_private": false}, {"count": 3, "tags": [], "creator": "clucas@e-miles.com", "attachment_id": 30489, "id": 168079, "time": "2013-06-26T20:07:37Z", "bug_id": 54086, "creation_time": "2013-06-26T20:07:37Z", "is_private": false, "text": "Created attachment 30489\nfix for bug"}, {"count": 4, "tags": [], "text": "Created attachment 30490\nfix for bug\n\ni inadvertently left in a printStackTrace on the original patch. use this one instead.", "is_private": false, "bug_id": 54086, "id": 168081, "time": "2013-06-26T20:17:54Z", "creator": "clucas@e-miles.com", "creation_time": "2013-06-26T20:17:54Z", "attachment_id": 30490}, {"count": 5, "tags": [], "bug_id": 54086, "is_private": false, "text": "(In reply to Casey Lucas from comment #2)\n> Problem:\n> During shutdown, NioReceiver.close()\n\nThere is no such method. I'm going to assume you mean stop().", "id": 168169, "time": "2013-07-01T10:36:35Z", "creator": "markt@apache.org", "creation_time": "2013-07-01T10:36:35Z", "attachment_id": null}, {"text": "Thanks for the analysis and patch.\n\nI went with a different approach as I generally prefer to tackle the root cause rather than handle the symptoms of a problem.\n\nProviding that the receiver thread stops in a timely manner, the patch prevents multiple threads accessing the key set.", "tags": [], "bug_id": 54086, "attachment_id": null, "count": 6, "id": 168173, "time": "2013-07-01T11:11:18Z", "creator": "markt@apache.org", "creation_time": "2013-07-01T11:11:18Z", "is_private": false}, {"count": 7, "tags": [], "creator": "clucas@e-miles.com", "attachment_id": null, "id": 168186, "time": "2013-07-01T13:09:45Z", "bug_id": 54086, "creation_time": "2013-07-01T13:09:45Z", "is_private": false, "text": "(In reply to Mark Thomas from comment #5)\n> (In reply to Casey Lucas from comment #2)\n> > Problem:\n> > During shutdown, NioReceiver.close()\n> \n> There is no such method. I'm going to assume you mean stop().\n\nYes, stop.  Thanks for the fix."}]