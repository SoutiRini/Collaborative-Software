[{"count": 0, "tags": [], "bug_id": 57448, "attachment_id": null, "text": "In Apache 2.2, one could set an SSI variable based on backreferences from a regex match in the previous <!--#if -->:\n\n<!--#if expr='$REQUEST_URI = /(.*)/' -->\n<!--#set var=\"foo\" value=\"$1\" -->\nFound <!--#echo var=\"foo\" -->\n<!--#endif -->\n\nHowever, in Apache 2.4, the equivalent code doesn\u2019t work:\n\n<!--#if expr='v(\"REQUEST_URI\") =~ /(.*)/' -->\n<!--#set var=\"foo\" value=\"$1\" -->\nFound <!--#echo var=\"foo\" -->\n<!--#endif -->\n\nIt sets the variable to the empty string and yields this error:\n\n[Thu Jan 15 19:23:20.763133 2015] [include:warn] [pid 6768:tid 140695587436288] [client 127.0.0.1:59575] AH01330: regex capture $1 is out of range (last regex was: '(null)') in /var/www/html/test.shtml\n\nI can still use the Apache 2.2 code if I set SSILegacyExprParser on, but obviously there should be a non-deprecated way to do this.", "id": 180312, "time": "2015-01-16T00:27:33Z", "creator": "andersk@mit.edu", "creation_time": "2015-01-16T00:27:33Z", "is_private": false}, {"count": 1, "attachment_id": null, "bug_id": 57448, "is_private": false, "id": 182292, "time": "2015-04-09T14:20:28Z", "creator": "aa@rcpt.at", "creation_time": "2015-04-09T14:20:28Z", "tags": [], "text": "I can reproduce this bug. <!--#set var=\"foo\" value=\"$0\" -->  does work, it contains the whole string, but $1 does fail exactly as described earlier."}, {"count": 2, "tags": [], "bug_id": 57448, "text": "This bug is still present in 2.4.16 where I have encountered it today.", "id": 185549, "time": "2015-09-29T22:13:46Z", "creator": "man_utd_are_rubbish@yahoo.co.uk", "creation_time": "2015-09-29T22:13:46Z", "is_private": false, "attachment_id": null}, {"count": 3, "attachment_id": null, "bug_id": 57448, "is_private": false, "id": 185569, "time": "2015-09-30T13:39:18Z", "creator": "hk@b61.de", "creation_time": "2015-09-30T13:39:18Z", "tags": [], "text": "Example: Show 198. from 198.19.81.98\n<!--#if expr=\"v('REMOTE_ADDR') =~ /(\\d+\\.)\\d+/ && $1 =~ /(\\d\\.)/\" -->\n<!--#set var=\"foo\" value=\"$0\" -->\nFound <!--#echo var=\"foo\" -->\n<!--#endif -->\nYou *must* use Backreferences in same Expression!"}, {"count": 4, "tags": [], "bug_id": 57448, "attachment_id": null, "is_private": false, "id": 188828, "time": "2016-02-26T08:39:54Z", "creator": "eveslage@gmail.com", "creation_time": "2016-02-26T08:39:54Z", "text": "(In reply to Helge from comment #3)\n> Example: Show 198. from 198.19.81.98\n> <!--#if expr=\"v('REMOTE_ADDR') =~ /(\\d+\\.)\\d+/ && $1 =~ /(\\d\\.)/\" -->\n> <!--#set var=\"foo\" value=\"$0\" -->\n> Found <!--#echo var=\"foo\" -->\n> <!--#endif -->\n> You *must* use Backreferences in same Expression!\n\nThat's correct, in the same expression you can use $1 and backreference matches. BUT $0 references always the whole string and not the last matched string. in Helges example \nfoo == \"198.19.81.98\"\nand not as expected \"198.\"\n\nif you try use a nested if, you can backreference\n\n<!--#if expr=\"v('REMOTE_ADDR') =~ /(\\d+\\.)\\d+/ && $1 =~ /(\\d\\.)/\" -->\n  <!--# if expr='$1 == \"198.\"' --> \n    Found 198.\n  <--#endif -->\n<!--#endif -->\n\nit matches. this means backreferences are available in nested ap_expr, but not for any \"<!--#set\" var or \"<!--#echo\" operation."}, {"count": 5, "tags": [], "creator": "hk@b61.de", "attachment_id": null, "id": 188829, "time": "2016-02-26T10:17:15Z", "bug_id": 57448, "creation_time": "2016-02-26T10:17:15Z", "is_private": false, "text": "(In reply to Ingmar Eveslage from comment #4)\n> (In reply to Helge from comment #3)\n> That's correct, in the same expression you can use $1 and backreference\n> matches. BUT $0 references always the whole string and not the last matched\n> string. in Helges example \n> foo == \"198.19.81.98\"\n> and not as expected \"198.\"\n\nI have tested my Example many times on Apache 2.4.12 an it works as expected: foo returns \"198.\".\n$1 from expression /^(\\d\\.)/ is $0 for 'set var=foo'."}, {"count": 6, "tags": [], "text": "i boiled it down a litte:\n\nat first: there has to be an indirection with \"<!--#set var\". echoing directly \"$0\" doesn't work.\n\nmy example shows a work around: \n\n<!--#set var=\"test_var\" value=\"1_2_3_4\" --> \n<!--#if expr='v(\"test_var\") =~ /(1_)(.*)/ && $1 =~ /(.*)/' --><!--#endif -->\n<!--#set var=\"first\" value=\"$0\" -->\n<!--#echo encoding='none' var='first' -->\n\nOUTPUT: 1_\n\nchanging the second regex in the if statement to $2\n\n<!--#set var=\"test_var\" value=\"1_2_3_4\" --> \n<!--#if expr='v(\"test_var\") =~ /(1_)(.*)/ && $2 =~ /(.*)/' --><!--#endif -->\n<!--#set var=\"first\" value=\"$0\" -->\n<!--#echo encoding='none' var='first' -->\n\nOUTPUT: 2_3_4\n\nso the simple \"$n =~ /(.*)/\" acts like an exporter for matched parts.\nBUT BE AWARE: don't simplify it \"$n =~ /.*/\" doesn't work.\n\ni think the bug report stands. somethings doesn't add up.", "is_private": false, "id": 188830, "creator": "eveslage@gmail.com", "time": "2016-02-26T10:27:34Z", "bug_id": 57448, "creation_time": "2016-02-26T10:27:34Z", "attachment_id": null}, {"attachment_id": null, "tags": [], "creator": "hk@b61.de", "is_private": false, "count": 7, "id": 188831, "time": "2016-02-26T11:04:31Z", "bug_id": 57448, "creation_time": "2016-02-26T11:04:31Z", "text": "And why does my RegExample correctly working on my server?\n(Last Test on Apache/2.4.12: Fri 2016-02-26 10:50 GMT)\n\n-----------------------\nSSILegacyExprParser Off\n-----------------------\n\nYou CAN use for echoing\n\n#1: #set var=\"FooBar\" value=\"$0\"\n    + #echo var=\"FooBar\"\n\n    -OR-\n\n#2: #echo var=\"0\" (var=\"$0\" doesn't work!)\n\n\nCORRECTED (full) EXAMPLE: Show first ^(\\d+\\.) from IPv4 Address\n\n<!--#if expr=\"v('REMOTE_ADDR') =~ /^(\\d+\\.)/ && $1 =~ /^(\\d+\\.)/\"-->\n<!--#set var=\"FooBar\" value=\"$0\" -->\nFooBar #1: <!--#echo var=\"FooBar\" --><br>\nFooBar #2: <!--#echo var=\"0\" -->\n<!--#endif -->\n\nIt works!"}, {"count": 8, "tags": [], "bug_id": 57448, "attachment_id": null, "is_private": false, "id": 188832, "time": "2016-02-26T11:16:32Z", "creator": "eveslage@gmail.com", "creation_time": "2016-02-26T11:16:32Z", "text": "Thanks for the explanation of the echo part. <!--#echo var=\"0\" --> works.\n\nyour example works for me, too. And it does the same as my example. Match a group and match it again in the same expression. so it gets exported as $0.\n\ni think we can agree on that. but i think its still a workaround. $1...$n should be exported directly as gets exported using the legacy parser. Don't you think.\n\nand if the developer do not agree on that, then at least the fact that: \n\n<!--#if expr='v(\"test_var\") =~ /(1_)(.*)/ && $1 =~ /(.*)/' --><!--#endif -->\n<!--#echo var=\"0\" -->\nworks and \n\n<!--#if expr='v(\"test_var\") =~ /(1_)(.*)/ && $1 =~ /.*/' --><!--#endif -->\n<!--#echo var=\"0\" -->\ndoesn't, is still a bug. right?"}, {"count": 9, "tags": [], "bug_id": 57448, "attachment_id": null, "is_private": false, "id": 188835, "time": "2016-02-26T11:34:20Z", "creator": "hk@b61.de", "creation_time": "2016-02-26T11:34:20Z", "text": "(In reply to Ingmar Eveslage from comment #8)\n> Thanks for the explanation of the echo part. <!--#echo var=\"0\" --> works.\n\nI tell you a secret:\nI'm personally using 'SSILegacyExprParser On'.\nFor me and until now It always works. ;-)\n\nGreetings from Helge"}, {"count": 10, "tags": [], "bug_id": 57448, "attachment_id": null, "text": "good to know. but what are the plans for \"SSILegacyExprParser\". will it be removed in future versions?", "id": 188837, "time": "2016-02-26T11:36:18Z", "creator": "eveslage@gmail.com", "creation_time": "2016-02-26T11:36:18Z", "is_private": false}, {"count": 11, "tags": [], "bug_id": 57448, "text": "(In reply to Ingmar Eveslage from comment #10)\n> good to know. but what are the plans for \"SSILegacyExprParser\". will it be\n> removed in future versions?\n\nI think, it could be removed in Apache/2.5 (?)", "id": 188838, "time": "2016-02-26T11:44:03Z", "creator": "hk@b61.de", "creation_time": "2016-02-26T11:44:03Z", "is_private": false, "attachment_id": null}, {"count": 12, "attachment_id": null, "creator": "apache@jamesahart.us", "text": " The code shows that $1 is available in the #if, but not #set, whereas $0 is available in the #set.\n\n <!--#set var=\"a\" value=\"abc\" --> \n<!--#if expr='v(\"a\") =~ /a(b)c/' -->\n <!--#if expr='$1 == \"b\"' -->\n Got a match.\n <!--#set var=\"match\" value=\"a$1\" --> \n<!--#echo var=\"match\" -->\n <!--#set var=\"match\" value=\"a$0\" --> \n<!--#echo var=\"match\" -->\n\n =============== \nGot a match.\n a \naabc", "id": 193560, "time": "2016-09-08T02:04:43Z", "bug_id": 57448, "creation_time": "2016-09-08T02:04:43Z", "tags": [], "is_private": false}, {"count": 13, "tags": [], "text": "I finally got round to migrating my SSI expressions to the \"new\" ap_expr syntax, and hit this bug.  And it is clearly a bug.\n\nBecause $0 is sometimes (though not always) exported from the \"if\" to a subsequent \"set\", you can hack it with extra matchers.  Congratulations to the folks who discovered that, as it's a viable workaround!  But it's clearly a hack, and doesn't work if you want to capture more than one substring.\n\nThe documentation for ap_expr suggests that modules can, if they want to, allow the  backref variables to survive between expressions.  It's *partially* happening with SSI (but only with $0, and only if there are capturing parentheses, which in themselves shouldn't affect whether $0 is set), so please can it be fixed to work properly?\n\nI've taken a look at util_expr_eval.c and mod_include.c, and my guess is it's somewhere in the code in parse_ap_expr that decides whether to (re)allocate a backref_t struct within the persistent include_ctx_t.  Hopefully somebody more familiar with this area of code will spot it!", "attachment_id": null, "id": 201822, "creator": "richard-apache@musicbox.net", "time": "2017-10-31T14:01:18Z", "bug_id": 57448, "creation_time": "2017-10-31T14:01:18Z", "is_private": false}]