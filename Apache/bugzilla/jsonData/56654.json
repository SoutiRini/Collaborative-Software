[{"count": 0, "tags": [], "text": "apr_skiplist sometimes corrupts.\n\napr_skiplist_insert uses apr_skiplist_alloc to allocate memory for apr_skiplistnode_t, but apr_skiplist_alloc sometimes returns uninitialized (un-memset-zeroed) one.\napr_skiplist have a memory recycle system, so apr_skiplist_alloc first tries to get memory from it, but apr_skiplist_alloc doesn't clear memory.\napr_skiplist_insert presume apr_skiplist_alloc returns zero cleared memory.\n\nHow to reproduce:\n\n1. insert objects to skiplist many times (about 10?)\n2. remove all objects from the skiplist\n3. insert objects to skiplist many times again\n\nthen skiplist_print_struct shows like this:\nSkiplist Structure (height: 3)\n_(nil) 0xb3805e78 0xb3805f18 \n_0xb3806080 \n_0xb3806088 0xb3806088 \n_0xb38060c0 \n\nFirst line should contains NULL only, but it doesn't.", "attachment_id": null, "bug_id": 56654, "id": 175946, "time": "2014-06-21T06:14:53Z", "creator": "takashi.asfbugzilla@tks.st", "creation_time": "2014-06-21T06:14:53Z", "is_private": false}, {"count": 1, "tags": [], "text": "Created attachment 31737\nEnable skiplist_print_struct for debug\n\napr_skiplist.c has skiplist_print_struct but disabled.\nThis patch enables it.", "attachment_id": 31737, "bug_id": 56654, "id": 175947, "time": "2014-06-21T06:17:14Z", "creator": "takashi.asfbugzilla@tks.st", "creation_time": "2014-06-21T06:17:14Z", "is_private": false}, {"count": 2, "tags": [], "bug_id": 56654, "attachment_id": 31738, "text": "Created attachment 31738\ncode to reproduce\n\nThis code needs earlier patch (31737)", "id": 175948, "time": "2014-06-21T06:22:28Z", "creator": "takashi.asfbugzilla@tks.st", "creation_time": "2014-06-21T06:22:28Z", "is_private": false}, {"count": 3, "tags": [], "text": "Created attachment 31739\noutput from the code (31738)", "is_private": false, "id": 175949, "creator": "takashi.asfbugzilla@tks.st", "time": "2014-06-21T06:23:43Z", "bug_id": 56654, "creation_time": "2014-06-21T06:23:43Z", "attachment_id": 31739}, {"count": 4, "tags": [], "bug_id": 56654, "attachment_id": 31740, "id": 175951, "time": "2014-06-21T06:35:36Z", "creator": "takashi.asfbugzilla@tks.st", "creation_time": "2014-06-21T06:35:36Z", "is_private": false, "text": "Created attachment 31740\npatch for fix\n\nfix for apr_skiplist_alloc"}, {"count": 5, "tags": [], "creator": "covener@gmail.com", "attachment_id": null, "id": 175954, "time": "2014-06-21T11:54:05Z", "bug_id": 56654, "creation_time": "2014-06-21T11:54:05Z", "is_private": false, "text": "Just out of context in the diff it's clear we pcalloc/calloc new memory so +1.\n\nI did just now look at the original (non-apr) skiplist, which always does malloc inline and either does memset or memcpy right after. We don't seem to have that memcpy equivalent path (I can't tell why) so it seems like we're never doing a throwaway memset+memcpy.  \n\nWill commit shortly"}, {"count": 6, "tags": [], "bug_id": 56654, "attachment_id": null, "text": "(In reply to Eric Covener from comment #5)\n> Just out of context in the diff it's clear we pcalloc/calloc new memory so\n> +1.\n> \n> I did just now look at the original (non-apr) skiplist, which always does\n> malloc inline and either does memset or memcpy right after. We don't seem to\n> have that memcpy equivalent path (I can't tell why) so it seems like we're\n> never doing a throwaway memset+memcpy.  \n> \n> Will commit shortly\n\nDid you try your testcase w/ this #if 0 un-ifdeffed out?\n\nstatic apr_skiplistnode *insert_compare(apr_skiplist *sl, void *data,\n                                        apr_skiplist_compare comp, int replace)\n{\n    apr_skiplistnode *m, *p, *tmp, *ret = NULL, **stack;\n    int nh = 1, ch, stacki;\n    if (!sl->top) {\n        sl->height = 1;\n        sl->topend = sl->bottomend = sl->top = sl->bottom =\n            (apr_skiplistnode *)apr_skiplist_alloc(sl, sizeof(apr_skiplistnode));\n#if 0\n        sl->top->next = (apr_skiplistnode *)NULL;\n        sl->top->data = (apr_skiplistnode *)NULL;\n        sl->top->prev = (apr_skiplistnode *)NULL;\n        sl->top->up = (apr_skiplistnode *)NULL;\n        sl->top->down = (apr_skiplistnode *)NULL;\n        sl->top->nextindex = (apr_skiplistnode *)NULL;\n        sl->top->previndex = (apr_skiplistnode *)NULL;\n#endif\n        sl->top->sl = sl;\n    }\n\nI wonder if there is even any point in skipping a memset call though.", "id": 175955, "time": "2014-06-21T11:58:17Z", "creator": "covener@gmail.com", "creation_time": "2014-06-21T11:58:17Z", "is_private": false}, {"count": 7, "tags": [], "bug_id": 56654, "attachment_id": null, "id": 175959, "time": "2014-06-21T14:34:33Z", "creator": "takashi.asfbugzilla@tks.st", "creation_time": "2014-06-21T14:34:33Z", "is_private": false, "text": "(In reply to Eric Covener from comment #6)\n[cut]\n> \n> Did you try your testcase w/ this #if 0 un-ifdeffed out?\n> \n> static apr_skiplistnode *insert_compare(apr_skiplist *sl, void *data,\n>                                         apr_skiplist_compare comp, int\n> replace)\n> {\n>     apr_skiplistnode *m, *p, *tmp, *ret = NULL, **stack;\n>     int nh = 1, ch, stacki;\n>     if (!sl->top) {\n>         sl->height = 1;\n>         sl->topend = sl->bottomend = sl->top = sl->bottom =\n>             (apr_skiplistnode *)apr_skiplist_alloc(sl,\n> sizeof(apr_skiplistnode));\n> #if 0\n>         sl->top->next = (apr_skiplistnode *)NULL;\n>         sl->top->data = (apr_skiplistnode *)NULL;\n>         sl->top->prev = (apr_skiplistnode *)NULL;\n>         sl->top->up = (apr_skiplistnode *)NULL;\n>         sl->top->down = (apr_skiplistnode *)NULL;\n>         sl->top->nextindex = (apr_skiplistnode *)NULL;\n>         sl->top->previndex = (apr_skiplistnode *)NULL;\n> #endif\n>         sl->top->sl = sl;\n>     }\n> \n> I wonder if there is even any point in skipping a memset call though.\n\nI just tried this, but doesn't remove the issue.\nThen, I found another #if 0 block.\n \n    for (; sl->height < nh; sl->height++) {\n        sl->top->up =\n            (apr_skiplistnode *)apr_skiplist_alloc(sl, sizeof(apr_skiplistnode));\n        sl->top->up->down = sl->top;\n        sl->top = sl->topend = sl->top->up;\n#if 0\n        sl->top->prev = sl->top->next = sl->top->nextindex =\n            sl->top->previndex = sl->top->up = NULL;\n        sl->top->data = NULL;\n#endif\n        sl->top->sl = sl;\n    }\n\nI removed this and ran my testcode, and seemed like things went well."}, {"count": 8, "tags": [], "bug_id": 56654, "attachment_id": null, "text": "It turns out a very minor change to your testcase crashes w/o the patch, I got\nlucky in adding just a few extra calls.\n\nCommitted APR test based on your sample program and the #if 0 fix (1604598) to\ntrunk.  Will backport later today.  Please check out trunk for feedback before\nI backport", "id": 175973, "time": "2014-06-22T15:13:10Z", "creator": "covener@gmail.com", "creation_time": "2014-06-22T15:13:10Z", "is_private": false}, {"count": 9, "attachment_id": null, "creator": "takashi.asfbugzilla@tks.st", "is_private": false, "id": 175979, "time": "2014-06-23T05:37:28Z", "bug_id": 56654, "creation_time": "2014-06-23T05:37:28Z", "tags": [], "text": "(In reply to Eric Covener from comment #8)\n[cut]\n> Committed APR test based on your sample program and the #if 0 fix (1604598)\n> to\n> trunk.  Will backport later today.  Please check out trunk for feedback\n> before\n> I backport\n\nI tried. I verified the issue was resolved.\nThe httpd event MPM + wstunnel Async with idle timeout works well too."}]