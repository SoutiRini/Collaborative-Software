[{"count": 0, "attachment_id": null, "bug_id": 56966, "is_private": false, "id": 177759, "time": "2014-09-11T15:36:42Z", "creator": "tom@tom-fitzhenry.me.uk", "creation_time": "2014-09-11T15:36:42Z", "tags": [], "text": "The problem:\nAccessLogValve's elapsed time variables (%D and %T) calculate elapsed time using System.currentTimeMillis()[0]. System.currentTimeMillis() only has a precision of ~15ms on Windows.[1]\n\nA potential fix:\nCalculate elapsed time using a precision timer, such as System.nanoTime(), which has a higher precision (dependent on OS).\n\n\nReferences:\n0. See https://github.com/apache/tomcat/blob/3986c5dc894fda541aa1855503debe1a8c01fc9f/java/org/apache/catalina/connector/CoyoteAdapter.java#L266 , which gets fed into the 'time' parameter of https://github.com/apache/tomcat/blob/99029882cb020f8d354ad4e2ef46e8edacb0c73d/java/org/apache/catalina/valves/AbstractAccessLogValve.java#L1183\n1. http://stackoverflow.com/questions/7859019/system-currenttimemillis-is-not-accurate-on-windows-xp"}, {"count": 1, "tags": [], "text": "I see 1ms precision when running on Windows 7. I see 1ms running on Linux.\nThe last time when I observed 10ms was Windows XP, but Windows XP is now End-of-life.\n\n\nNote that System.nanoTime() has caveats. It makes sense only when measuring time intervals. It cannot be used to measure current time.\n\nreq.getStartTime() is used as wall clock time value. It means that there has to be another field in addition to req.getStartTime(). It also means that there needs to be a change to the Log interface to pass a nano time value in addition to milli time one.\n\nIs there much interest in measuring times shorter than 1ms? Usually there is an interest in requests that take a long time.", "is_private": false, "id": 179414, "creator": "knst.kolinko@gmail.com", "time": "2014-12-01T18:14:30Z", "bug_id": 56966, "creation_time": "2014-12-01T18:14:30Z", "attachment_id": null}, {"count": 2, "tags": [], "bug_id": 56966, "attachment_id": null, "is_private": false, "id": 179415, "time": "2014-12-01T18:26:22Z", "creator": "tom@tom-fitzhenry.me.uk", "creation_time": "2014-12-01T18:26:22Z", "text": "I observed the 15ms precision on Windows Server 2012 R2, the latest MS server edition.\n\nSorry, I should have mentioned that in the description."}, {"count": 3, "tags": [], "bug_id": 56966, "attachment_id": null, "id": 179421, "time": "2014-12-01T22:20:57Z", "creator": "chris@christopherschultz.net", "creation_time": "2014-12-01T22:20:57Z", "is_private": false, "text": "Any other environmental notes? For instance, are you running on bare metal or in a virtualized environment?"}, {"count": 4, "tags": [], "bug_id": 56966, "attachment_id": null, "id": 179441, "time": "2014-12-02T12:51:12Z", "creator": "tom@tom-fitzhenry.me.uk", "creation_time": "2014-12-02T12:51:12Z", "is_private": false, "text": "The machine is a virtual machine running on the Windows Azure hypervisor (similar to Hyper-V, supposedly).\n\nThe guest OS runs Windows Server 2012 R2, and reports its hardware as:\n\n    Processor: Intel(R) Xeon(R) CPU E5-2660 0 @ 2.260GHz 2.20GHz\n    Installed memory (RAM): 14.0 GB\n    System type: 60-bit Operation System, x64-based processor\n\nThe program on http://stackoverflow.com/questions/7859019/system-currenttimemillis-is-not-accurate-on-windows-xp , when executed against Oracle JRE 7, prints 15ms."}, {"count": 5, "tags": [], "bug_id": 56966, "attachment_id": null, "id": 179496, "time": "2014-12-04T03:31:06Z", "creator": "chris@christopherschultz.net", "creation_time": "2014-12-04T03:31:06Z", "is_private": false, "text": "(In reply to Konstantin Kolinko from comment #1)\n> I see 1ms precision when running on Windows 7. I see 1ms running on Linux.\n> The last time when I observed 10ms was Windows XP, but Windows XP is now\n> End-of-life.\n\n+1\n\nI don't have any non-virtual Windows instances available for testing, unfortunately. I don't trust real-time clocks on VMs.\n\n> Note that System.nanoTime() has caveats. It makes sense only when measuring\n> time intervals. It cannot be used to measure current time.\n> \n> req.getStartTime() is used as wall clock time value. It means that there has\n> to be another field in addition to req.getStartTime(). It also means that\n> there needs to be a change to the Log interface to pass a nano time value in\n> addition to milli time one.\n\nAccessLogValve could take its own timestamps in nanos, though the start time would be \"after\" req.getStartTime(). Or we could use (nanos / 1000) to get \"better\" resolution for the time-interval for a request. It seems like extra work for little benefit. (Though those experiencing 15ms-minimums would certainly argue that the benefit is great.)\n\n> Is there much interest in measuring times shorter than 1ms? Usually there is\n> an interest in requests that take a long time.\n\n+1\n\nFor resources that run reasonably faster than 15ms, one can use a Filter around them to collect metrics and aggregate total time over many requests to get a mean-request-time if that's what you ultimately want."}, {"count": 6, "tags": [], "bug_id": 56966, "attachment_id": null, "id": 189062, "time": "2016-03-03T17:14:07Z", "creator": "markt@apache.org", "creation_time": "2016-03-03T17:14:07Z", "is_private": false, "text": "System.nanoTime() is approximately 40x slower than System.currentTimeMillis(). On my machine the equates to the difference between ~600ns and ~15ns per call.\n\nDuration requires a start and an end time. So that is ~1.2\u03bcs. On the same machine a basic request with access logging takes ~30\u03bcs so switching to ns precision adds approximately 4% of overhead. That is a fair amount overhead.\n\nIt is worth checking the timings on a more modern machine (I'll do that shortly) before making any decisions on this."}, {"count": 7, "tags": [], "text": "Hmm. Both methods around 40\u03bcs on may newer laptop which would make this change pretty much zero perofromnace impact.\n\nThere are a few too many variables here. H/W, OS, JVM etc. I'm going to do some wider testing to get a better sense of the relative performance of these methods.", "is_private": false, "id": 189063, "creator": "markt@apache.org", "time": "2016-03-03T17:36:10Z", "bug_id": 56966, "creation_time": "2016-03-03T17:36:10Z", "attachment_id": null}, {"count": 8, "tags": [], "bug_id": 56966, "attachment_id": null, "id": 189089, "time": "2016-03-04T12:09:14Z", "creator": "markt@apache.org", "creation_time": "2016-03-04T12:09:14Z", "is_private": false, "text": "The times were consistent on my fairly old (2008) server running Win 2008 R2 at 15/600 regardless with Java 7 Java 8 and Java 9.\n\nOn my 2012 OSX laptop the times were consistently ~40\u03bcs for Java 7 and 8.\n\nAnd on a year old Windows laptop the times are ~7\u03bcs for System.currentTimeMillis() and ~14\u03bcs for System.nanoTime() for Java 8 and 9.\n\nIt looks like times are largely independent of Java version.\n\nOn remotely modern hardware (would anyone really worried about a few \u03bcs of performance be running 4+ year old hardware?) it looks like this is a non-issue performance wise.\n\nI'm going to go ahead and implement this for 9.0.x."}]