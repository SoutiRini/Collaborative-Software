[{"count": 0, "tags": [], "creator": "amd1212@vier-ringe.at", "text": "A little background: I am using the redirect feature for mod_proxy_balancer as feature to pair two servers together while all servers are still used within an cluster. \nThats how the configuration looks like:\n\n<Proxy balancer://fe_cluster>\n    BalancerMember http://fe01:8080 min=0 smax=30 retry=30 max=100 loadfactor=50 route=fe01 redirect=fe02\n    BalancerMember http://fe02:8080 min=0 smax=30 retry=30 max=100 loadfactor=50 route=fe02 redirect=fe01\n    BalancerMember http://fe03:8080 min=0 smax=30 retry=30 max=100 loadfactor=50 route=fe03 redirect=fe04\n    BalancerMember http://fe04:8080 min=0 smax=30 retry=30 max=100 loadfactor=50 route=fe04 redirect=fe03\n    BalancerMember http://fe05:8080 min=0 smax=30 retry=30 max=100 loadfactor=50 route=fe05 redirect=fe06\n    BalancerMember http://fe06:8080 min=0 smax=30 retry=30 max=100 loadfactor=50 route=fe06 redirect=fe05\n</proxy>\n\nThe goal of that configuration is that the app-servers in the back do not need to replicate their sessions to all servers but only to their redirect partner (and sessions can become big, so this saves lot of memory).\nIt might by unusual to use the redirect feature in this way, but a segfault is a bug regardless how a feature is used.\n\nThis setup works really fine if at least one server of each pair is active (not disabled or in error mode). If both servers of a pair are not available then the module is hanging in a deadloop doing the redirect which ends in an segfault.\nThe problem seems to be that the redirection has no limit/does not check if it already tried to redirect to a specific memeber already.\n\nThe relevant code is located in the file: modules/proxy/mod_proxy_balancer.c:\n  For httpd-2.4.23 between line 214 to 277.\n  For httpd-2.2.31 between line 190 to 252.\n  It looks for me that the problem still exists in 2.5-trunk.\n\n\n\n\nGDB output:\n[Thread 0x7fffeff86700 (LWP 52185) exited]\n\nProgram received signal SIGSEGV, Segmentation fault.\n[Switching to Thread 0x7fffcefcd700 (LWP 52245)]\n0x00007ffff3288356 in find_route_worker (balancer=balancer@entry=0x320ad1c8, route=0x7ffff0bc9ce0 \"fe01\", r=r@entry=0x7fff94002970)\n    at /opt/httpd-2.2.31/modules/proxy/mod_proxy_balancer.c:192\n\n\n\nWhat should happen:\nIf there is a redirect mod_proxy_balancer should keep track of the members it already tried to redirect to or at least have a limit how often to try to redirect -> and then return the same error code like it does when all members of a cluster a down: 503 \"Service Temporarily Unavailable\".", "id": 192397, "time": "2016-07-15T10:52:15Z", "bug_id": 59864, "creation_time": "2016-07-15T10:52:15Z", "is_private": false, "attachment_id": null}, {"count": 1, "tags": [], "creator": "rpluem@apache.org", "text": "Does the below patch fix your issue?\n\nIndex: modules/proxy/mod_proxy_balancer.c                    \n===================================================================\n--- modules/proxy/mod_proxy_balancer.c  (revision 1752793)         \n+++ modules/proxy/mod_proxy_balancer.c  (working copy)             \n@@ -212,7 +212,8 @@                                                \n /* Find the worker that has the 'route' defined                   \n  */                                                               \n static proxy_worker *find_route_worker(proxy_balancer *balancer,  \n-                                       const char *route, request_rec *r)\n+                                       const char *route, request_rec *r,\n+                                       int recursion)                    \n {                                                                        \n     int i;                                                               \n     int checking_standby;                                                \n@@ -249,10 +250,15 @@                                                     \n                          * This enables to safely remove the member from the\n                          * balancer. Of course you will need some kind of   \n                          * session replication between those two remote.    \n+                         * Also check that we haven't gone thru all the     \n+                         * balancer members by means of redirects.          \n+                         * This should avoid redirect cycles.                                                                                                                                                                    \n                          */                                                                                                                                                                                                      \n-                        if (*worker->s->redirect) {                                                                                                                                                                              \n+                        if ((*worker->s->redirect)                                                                                                                                                                               \n+                            && (recursion < balancer->workers->nelts)) {                                                                                                                                                         \n                             proxy_worker *rworker = NULL;                                                                                                                                                                        \n-                            rworker = find_route_worker(balancer, worker->s->redirect, r);                                                                                                                                       \n+                            rworker = find_route_worker(balancer, worker->s->redirect,                                                                                                                                           \n+                                                        r, recursion + 1);                                                                                                                                                       \n                             /* Check if the redirect worker is usable */                                                                                                                                                         \n                             if (rworker && !PROXY_WORKER_IS_USABLE(rworker)) {                                                                                                                                                   \n                                 /*                                                                                                                                                                                               \n@@ -315,7 +321,7 @@                                                                                                                                                                                                               \n         /* We have a route in path or in cookie                                                                                                                                                                                  \n          * Find the worker that has this route defined.                                                                                                                                                                          \n          */                                                                                                                                                                                                                      \n-        worker = find_route_worker(balancer, *route, r);                                                                                                                                                                         \n+        worker = find_route_worker(balancer, *route, r, 1);                                                                                                                                                                      \n         if (worker && strcmp(*route, worker->s->route)) {                                                                                                                                                                        \n             /*                                                                                                                                                                                                                   \n              * Notice that the route of the worker chosen is different from", "id": 192409, "time": "2016-07-15T18:38:05Z", "bug_id": 59864, "creation_time": "2016-07-15T18:38:05Z", "is_private": false, "attachment_id": null}, {"count": 2, "tags": [], "text": "Created attachment 34043\nPatch against trunk", "is_private": false, "id": 192410, "creator": "rpluem@apache.org", "time": "2016-07-15T18:39:14Z", "bug_id": 59864, "creation_time": "2016-07-15T18:39:14Z", "attachment_id": 34043}, {"count": 3, "tags": [], "creator": "rpluem@apache.org", "is_private": false, "text": "Created attachment 34044\nPatch against trunk", "id": 192411, "time": "2016-07-15T18:42:54Z", "bug_id": 59864, "creation_time": "2016-07-15T18:42:54Z", "attachment_id": 34044}, {"count": 4, "tags": [], "text": "Sorry white space issue with the first post of the patch:\n\nIndex: modules/proxy/mod_proxy_balancer.c\n===================================================================\n--- modules/proxy/mod_proxy_balancer.c  (revision 1752793)\n+++ modules/proxy/mod_proxy_balancer.c  (working copy)\n@@ -212,7 +212,8 @@\n /* Find the worker that has the 'route' defined\n  */\n static proxy_worker *find_route_worker(proxy_balancer *balancer,\n-                                       const char *route, request_rec *r)\n+                                       const char *route, request_rec *r,\n+                                       int recursion)\n {\n     int i;\n     int checking_standby;\n@@ -249,10 +250,15 @@\n                          * This enables to safely remove the member from the\n                          * balancer. Of course you will need some kind of\n                          * session replication between those two remote.\n+                         * Also check that we haven't gone thru all the\n+                         * balancer members by means of redirects.\n+                         * This should avoid redirect cycles.\n                          */\n-                        if (*worker->s->redirect) {\n+                        if ((*worker->s->redirect)\n+                            && (recursion < balancer->workers->nelts)) {\n                             proxy_worker *rworker = NULL;\n-                            rworker = find_route_worker(balancer, worker->s->redirect, r);\n+                            rworker = find_route_worker(balancer, worker->s->redirect,\n+                                                        r, recursion + 1);\n                             /* Check if the redirect worker is usable */\n                             if (rworker && !PROXY_WORKER_IS_USABLE(rworker)) {\n                                 /*\n@@ -315,7 +321,7 @@\n         /* We have a route in path or in cookie\n          * Find the worker that has this route defined.\n          */\n-        worker = find_route_worker(balancer, *route, r);\n+        worker = find_route_worker(balancer, *route, r, 1);\n         if (worker && strcmp(*route, worker->s->route)) {\n             /*\n              * Notice that the route of the worker chosen is different from", "is_private": false, "id": 192413, "creator": "rpluem@apache.org", "time": "2016-07-15T18:44:28Z", "bug_id": 59864, "creation_time": "2016-07-15T18:44:28Z", "attachment_id": null}, {"count": 5, "attachment_id": null, "bug_id": 59864, "is_private": false, "id": 192419, "time": "2016-07-15T21:22:31Z", "creator": "amd1212@vier-ringe.at", "creation_time": "2016-07-15T21:22:31Z", "tags": [], "text": "Yes, i've tested the patch successfully on version 2.2.31.\nIt works like a charm, I can't reproduce the segfaults anymore and if a pair is down the request gets sent to other members of the same cluster.\n\nI will test it in detail on monday, but it looks very promising so far.\n\nThanks a lot.\nbest regards\nStefan"}, {"count": 6, "tags": [], "creator": "rpluem@apache.org", "text": "Committed to trunk as r1753594.", "id": 192554, "time": "2016-07-20T18:33:00Z", "bug_id": 59864, "creation_time": "2016-07-20T18:33:00Z", "is_private": false, "attachment_id": null}, {"count": 7, "attachment_id": null, "bug_id": 59864, "text": "Proposed for backport to 2.4.x as r1754075.", "id": 192647, "time": "2016-07-26T10:00:00Z", "creator": "rpluem@apache.org", "creation_time": "2016-07-26T10:00:00Z", "tags": [], "is_private": false}, {"count": 8, "attachment_id": null, "bug_id": 59864, "is_private": false, "id": 194968, "time": "2016-11-14T12:19:46Z", "creator": "ylavic.dev@gmail.com", "creation_time": "2016-11-14T12:19:46Z", "tags": [], "text": "Backported to 2.4.24 in r1756563."}]