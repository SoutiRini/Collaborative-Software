[{"count": 0, "tags": [], "creator": "csdillard@gmail.com", "is_private": false, "id": 169466, "creation_time": "2013-08-15T16:08:46Z", "time": "2013-08-15T16:08:46Z", "bug_id": 55422, "text": "When clients access an Apache reverse proxy with differing host names (and thus different \"Host\" headers), Apache's HTTPS client can generate improper requests to the origin server that have Host != SSL_TLS_SNI.\n\nHere's the simplest setup where I could reproduce the problem:\n\nServer A:  Let's call it \"dmz.example.com\", and suppose its IP address is 192.168.1.100.  Its Apache has one HTTPS VirtualHost.  ProxyPreserveHost is on, and there is one ProxyPass to the origin server, i.e.:\n\nProxyPreserveHost on\nProxyPass /foo https://192.168.1.200/foo\n\nServer B:  Call this one \"origin.example.com\", and suppose its IP address is 192.168.1.200. Its Apache has one HTTPS VirtualHost and it's just serving up HTML files.\n\nFire up both Apache servers, then repeatedly do this from a bash shell:\n\ncurl https://dmz.example.com/foo https://192.168.4.100/foo\n\n... i.e. access Machine A by name and by IP.\n\nEvery once in a while, you'll get a \"400 Bad Request\" response with the text \"Your browser sent a request that this server could not understand.\"  Examining the logs shows that the error occurred at the origin server, and that it rejected a request whose \"Host\" was \"192.168.4.100\" and whose SNI was \"dmz.example.com\".  So the \"browser\" is really the Apache server on Machine A.\n\nI poked around in the source, and I have a hunch that this is what's happening (though this is mostly just speculation):\n\nApache makes mod_proxy workers by URL.  In my example there's exactly one worker.  Each worker has a pool of connections that gets reused (via HTTP Keep-Alive).  But SNI only happens before the very first \"kept alive\" request.  So if Apache serves a request for https://192.168.4.100/foo by reusing a worker's connection whose SNI was \"dmz.example.com\", then that's bad.", "attachment_id": null}, {"count": 1, "attachment_id": null, "bug_id": 55422, "is_private": false, "id": 169467, "time": "2013-08-15T16:34:30Z", "creator": "csdillard@gmail.com", "creation_time": "2013-08-15T16:34:30Z", "tags": [], "text": "I should have also mentioned that this appears to be related to the functionality (added in 2.4.3, IIRC) that causes \"ProxyPreserveHost on\" to use the value of the \"Host\" request header in the SNI sent to the origin server."}, {"count": 2, "attachment_id": null, "bug_id": 55422, "is_private": false, "id": 169493, "time": "2013-08-16T08:12:17Z", "creator": "rpluem@apache.org", "creation_time": "2013-08-16T08:12:17Z", "tags": [], "text": "In your case you cannot use persistent backend connections. Disable them by setting the environment variables proxy-initial-not-pooled or proxy-nokeepalive\n(http://httpd.apache.org/docs/2.4/env.html).\nBe aware that this can have performance penalties especially for proxy-nokeepalive as full SSL handshakes need to be performed for each request to the backend."}, {"count": 3, "tags": [], "bug_id": 55422, "attachment_id": null, "text": "It seems more appropriate to mark this as \"RESOLVED WONTFIX\", no?  After all, httpd is in fact generating bad requests to the origin server.  (Where \"bad requests\" means \"requests that httpd itself will reject as invalid\".)", "id": 169506, "time": "2013-08-16T15:07:48Z", "creator": "csdillard@gmail.com", "creation_time": "2013-08-16T15:07:48Z", "is_private": false}, {"count": 4, "tags": [], "creator": "csdillard@gmail.com", "text": "Here's an inelegant workaround that still allows for persistent connections to the back-end:\n\nMake multiple named load balancers, each with exactly one BalancerMember, but all of which point to the same origin server, e.g.:\n\n  <Proxy balancer://origin1>\n    BalancerMember https://192.168.1.200\n  </Proxy>\n  <Proxy balancer://origin2>\n    BalancerMember https://192.168.1.200\n  </Proxy>\n\nThen make multiple (nearly identical) VirtualHosts with different ServerNames, each using a different balancer:\n\n  <VirtualHost *:443>\n    ...\n    ServerName dmz.example.com\n    ...\n    ProxyPass /foo balancer://origin1/foo\n  </VirtualHost>\n  <VirtualHost *:443>\n    ...\n    ServerName 192.168.1.100\n    ...\n    ProxyPass /foo balancer://origin2/foo\n  </VirtualHost>\n\nThis works around this bug because the way balancers are coded, each gets its own worker connection pool, and the VirtualHosts route to different balancers.  So there won't be any connection sharing with requests to a different host name.\n\nThe down side is that this requires a longer, more error-prone config file.  And it requires loading up all the balancer machinery.", "id": 169575, "time": "2013-08-19T18:16:04Z", "bug_id": 55422, "creation_time": "2013-08-19T18:16:04Z", "is_private": false, "attachment_id": null}]