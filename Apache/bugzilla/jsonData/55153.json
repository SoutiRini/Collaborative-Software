[{"count": 0, "tags": [], "text": "No fileevents fire for me.\n\nTest script:\n--test_socket_async.tcl--\nset q I\nset h [open /usr/tmp/test.txt w]\nfileevent $h writable \"set q W\"\nafter 1000 \"set q T\"\nvwait q\nclose $h\nputs $q\nfile delete /usr/tmp/test.txt\n--eof--\n\nThis script will output \"T\" when started in Apache Rivet normal mode and Output \"W\" when:\n-started by tclsh8.6\n-started by apache single process mode (/usr/sbin/httpd -X)\n\nPlatform:\n- Centos 64 bit\n- TCL 8.6.0\n- Rivet 2.1.2rc2", "attachment_id": null, "bug_id": 55153, "id": 168109, "time": "2013-06-28T09:03:22Z", "creator": "harald.oehlmann@elmicron.de", "creation_time": "2013-06-28T09:03:22Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 55153, "text": "I asked on clt for help:\nhttps://groups.google.com/forum/#!topic/comp.lang.tcl/Ja01kv75tVk\nThread name: \"Async sockets hang under Rivet but work in tclsh 8.6\"\nStart Date: 27.6.2013\n\nHere is the essence:\n- CentOS 6.2 64 bit\n- /usr/sbin/httpd -V\nServer version: Apache/2.2.15 (Unix)\nServer built:   May 13 2013 22:11:16\nServer's Module Magic Number: 20051115:25\nServer loaded:  APR 1.3.9, APR-Util 1.3.9\nCompiled using: APR 1.3.9, APR-Util 1.3.9\nArchitecture:   64-bit\nServer MPM:     Prefork\n  threaded:     no\n    forked:     yes (variable process count)\n- Apache was configured to only have one thread (/etc/httpd/conf/httpd.conf:\n<IfModule prefork.c>\nStartServers       1\nMinSpareServers    1\nMaxSpareServers   20\nServerLimit      256\nMaxClients       256\nMaxRequestsPerChild  4000\n</IfModule>\n)\n\n- Test file \"test_file_async.tcl\" in \"/var/www/html\". File contents as in the original bug.\n\n- Start http: service httpd start\n- start strace:\n  ps awux | grep sbin/httpd | awk '{print\"-p \" $2}' | xargs strace -tt -f -o straceall.txt \n- the resulting trace file is attached to the bug.\n\nHere are the comments by Alexandre Ferieux to the strace log from clt:\n\nOK here is what I can see:\n\n(1) open the file, and wake up the notifier (by writing a single byte to the pipe) thread so that it takes the new fd into account for its select() mask:\n\n> 29969 12:04:52.368364 open(\"/usr/tmp/test.txt\", O_WRONLY|O_CREAT|O_TRUNC, 0666) = 21\n> ...\n> 29969 12:04:52.368806 write(17, \"\\0\", 1) = 1\n\n(2) In the notifier: detect that activity on the control pipe...\n\n> 29965 12:04:52.368843 <... select resumed> ) = 1 (in [16])\n> 29965 12:04:52.368889 read(16,  <unfinished ...>\n> 29965 12:04:52.368922 <... read resumed> \"\\0\", 1) = 1\n\n(3) ... and normally restart a select with the new fd (21) in the write mask, but here, FAIL TO DO SO:\n\n> 29965 12:04:52.368963 select(17, [16], [], [], NULL <unfinished ...>\n\n(4) So, sleep stupidly (only monitoring the control pipe) until the timeout expires:\n\n> 29962 12:04:53.218193 <... select resumed> ) = 0 (Timeout)\n\n\nI ran your script in vanilla Tcl (which works, as we already know), and verified that the difference is exactly this (ignore the difference in fds):\n\n2297  17:31:15.800767 open(\"/tmp/test.txt\", O_WRONLY|O_CREAT|O_TRUNC|O_LARGEFILE, 0666) = 5\n2298  17:31:15.803090 <... read resumed> \"\\0\", 1) = 1\n2298  17:31:15.803165 select(6, [3], [5], [], NULL) = 1 (out [5])\n\nSo here, somehow the communication with the notifier is incomplete: we do get the control signal through (\"hey, new mask to recompute\"), but the recomputation miserably fails.\n\nNext step, I guess, is to look in detail at the data structures that are shared between the caller and notifier. Perhaps the maintainer knows how the Rivet environment is different in that respect ?\n\n--- Comment 2 ---\n\n> 29965 12:04:52.368963 select(17, [16], [], [], NULL <unfinished ...>\n> ...\n> 29962 12:04:53.218193 <... select resumed> ) = 0 (Timeout)\n\nHmmm, just noticed the different thread IDs: here we have a dance of 3 threads !\n\n - 29969 is your main thread\n - 29965 is the notifier\n - 29962 is a mysterious other thread that does a 1-second periodic task\n\nApart from the (remote) similarity between this 1-second period and your [after 1000], this does not really match what we see in the script. Definitely something to be explained by a Rivet-savvy person...\n\n-Alex", "id": 168219, "time": "2013-07-02T08:37:51Z", "creator": "harald.oehlmann@elmicron.de", "creation_time": "2013-07-02T08:37:51Z", "is_private": false, "attachment_id": null}, {"count": 2, "tags": [], "text": "Created attachment 30522\nstrace log of test file\n\nAlexandre Ferrieux based its analysis on this log.", "attachment_id": 30522, "bug_id": 55153, "id": 168221, "time": "2013-07-02T08:44:05Z", "creator": "harald.oehlmann@elmicron.de", "creation_time": "2013-07-02T08:44:05Z", "is_private": false}, {"count": 3, "tags": [], "creator": "harald.oehlmann@elmicron.de", "attachment_id": null, "id": 168564, "time": "2013-07-12T14:23:39Z", "bug_id": 55153, "creation_time": "2013-07-12T14:23:39Z", "is_private": false, "text": "Am Donnerstag, 4. Juli 2013 14:30:27 UTC+2 schrieb Harald Oehlmann:\n> Am Mittwoch, 3. Juli 2013 13:06:31 UTC+2 schrieb Alexandre Ferrieux:\n> \n> > I'd bet the next thing to do is to recompile Tcl with debug symbols, break in gdb in Tcl_CreateFileHandler, and single-step there to see what doesn't pass through. \n\nI suppose I have found something.\nWhen Apache starts, there are (at least) 2 processes, one owned by root and one owned by user apache:\n\nps -L aux\nUSER       PID   LWP %CPU NLWP %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\nroot      1997  1997  0.0    2  1.4 393536 14704 ?        Tsl  15:21   0:00 /usr/sbin/httpd\nroot      1997  2000  0.0    2  1.4 393536 14704 ?        Tsl  15:21   0:00 /usr/sbin/httpd\napache    1999  1999  0.0    1  0.7 391472  7292 ?        S    15:21   0:00 /usr/sbin/httpd\napache    2001  2001  0.0    1  0.9 394648  9724 ?        S    15:21   0:00 /usr/sbin/httpd\n\nThe process 1997 is the controler process, the others are final handler processes.\n\nI run two gdb, one attached to 1997, one attached to 2001.\n\nThe first has 2 threads:\n\n(gdb) info thread\n* 2 Thread 0x7fb15f77b700 (LWP 2000)  NotifierThreadProc (clientData=0x0) at /home/admin/test/tcl8.6.0/unix/tclUnixNotfy.c:1186\n  1 Thread 0x7fb16db9c7e0 (LWP 1997)  0x00007fb16c1d24f3 in select () at ../sysdeps/unix/syscall-template.S:82\n\nThe Thread 2 (LWP 2000) runs the TCL notifier function \"NotifierThreadProc\".\n\nThe second (ID 2001) has only one thread and runs the tcl interpreter:\n(gdb) info threads\n* 1 Thread 0x7fb16db9c7e0 (LWP 2001)  0x00007fb16c1d9f03 in epoll_wait () at ../sysdeps/unix/syscall-template.S:82\n\nIn thread 1 of process 2001, the procedure Tcl_CreateFileHandler is called, the file handle to monitor is written in a thread specific data memory area and \"\" is written to the communication pipe.\n\nIn thread 2 of process 1997 (LWP2000), in NotifierThreadProc the write to the pipe is recognized by the select and the shared memory is checked. As it is another process, the data does not pass.\n\nSo, the pipe connection works, but there is no shared memory and thus passing the file descriptor to select on does not work. In addition, the file description of process 2001 would propably not by valid in process 1997, LWP 2000.\n\nMore in detail, there is a shared variable \"waitingListPtr\".\nThis is set to a value in one process and remains zero on the other side.\n\nHere are some details:\n\n*** tsdPtr in procedure Tcl_CreateFileHandler, Process 2001:\n\n 523         ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);\n(gdb) print tsdPtr\n$1 = (ThreadSpecificData *) 0x7fb16eb9f6a0\n\n*** and the memory configuration just before writing to the pipe:\nProcedure Tcl_WaitForEvent in Process 2001:\n\n 907             tsdPtr->prevPtr = 0;\n 908             waitingListPtr = tsdPtr;\n(gdb) print &waitingListPtr\n$5 = (ThreadSpecificData **) 0x7fb16260ee88\n(gdb) print waitingListPtr\n$3 = (ThreadSpecificData *) 0x7fb16eb9f6a0\n(gdb) print *waitingListPtr\n$4 = {firstFileHandlerPtr = 0x7fb16ec8d7b0, checkMasks = {readable = {__fds_bits = {0 <repeats 16 times>}}, writable = {__fds_bits = {1048576, 0 <repeats 15 times>}}, exception = {__fds_bits = {0 <repeats 16 times>}}}, readyMasks = {readable = {__fds_bits = {0 <repeats 16 times>}}, writable = {__fds_bits = {0 <repeats 16 times>}}, exception = {__fds_bits = {0 <repeats 16 times>}}}, numFdBits = 21, onList = 1, pollState = 0, nextPtr = 0x0, prevPtr = 0x0, waitCV = 0x7fb16ec83850, eventReady = 0}\n 909             tsdPtr->onList = 1;\n(gdb) print tsdPtr\n$2 = (ThreadSpecificData *) 0x7fb16eb9f6a0\n 910 \n 911             if ((write(triggerPipe, \"\", 1) == -1) && (errno != EAGAIN)) {\n\n*** and now the notifier thread in Process 1997, thread 2 (LWP 2000):\nprocedure NotifierThreadProc\n\n1186         Tcl_MutexLock(&notifierMutex);\n1187         for (tsdPtr = waitingListPtr; tsdPtr; tsdPtr = tsdPtr->nextPtr) {\n(gdb) print &waitingListPtr\n$3 = (ThreadSpecificData **) 0x7fb16260ee88\n(gdb) print waitingListPtr\n$2 = (ThreadSpecificData *) 0x0\n\n---\n\nThe address of waitingListPtr is identical in the two threads but not the data.\nI suppose, this is due to the fork of the parent thread...\n\n---\n\nWell, I suppose, this thread configuration is not as intended.\nEach tcl worker process should have its notifier thread...\n\nThanks anybody to look into this.\n\nThank you,\nHarald"}, {"count": 4, "tags": [], "creator": "mxmanghi@apache.org", "text": "great job Harald\n\nafter your findings the question should be put on TCLCORE. \n\nCan you test a modified mod_rivet where Rivet_ChildInit creates an interpreter anew? I think that disregarding initialization scripts issues the test should be preatty easy, just replacing the interpreter inherited from the parent process with a new one just coined by Tcl_CreateInterpreter\n\n -- M", "id": 168565, "time": "2013-07-12T14:46:25Z", "bug_id": 55153, "creation_time": "2013-07-12T14:46:25Z", "is_private": false, "attachment_id": null}, {"count": 5, "attachment_id": 30592, "creator": "mxmanghi@apache.org", "text": "Created attachment 30592\nreintroducing child specific intepreter to see if the bug with fileevent can in case be cured\n\nHarald, please try apply this patch to see if the expected behavior for fileevent is restored. The patch makes void any initialization to the interpreter you may have done in a RivetServerInit directive script, but at least restores in the child process a pristine interpreter which is not a copy obtained by forking the parent process", "id": 168596, "time": "2013-07-15T00:00:18Z", "bug_id": 55153, "creation_time": "2013-07-15T00:00:18Z", "tags": [], "is_private": false}, {"count": 6, "tags": [], "bug_id": 55153, "text": "I am sorry, Moassimo, but the patch does not change anything for me:\n\na) the issue is not cured\nb) if I look via \"ps -L aux\" to the thread configuration, this did not change:\n\nps -L aux\nUSER       PID   LWP %CPU NLWP %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\nroot     19610 19610  0.1    2  1.4 393540 14692 ?        Ssl  13:13   0:00 /usr/sbin/httpd\nroot     19610 19613  0.0    2  1.4 393540 14692 ?        Ssl  13:13   0:00 /usr/sbin/httpd\napache   19612 19612  0.0    1  0.7 391476  7292 ?        S    13:13   0:00 /usr/sbin/httpd\napache   19614 19614  0.0    1  1.0 393960 10432 ?        S    13:13   0:00 /usr/sbin/httpd\n\nThus, the notifier thread still runs one in the root process and not in the worker threads.\n\nI have looked a bit, where the thread creation function \"Tcl_InitNotifier\" is called.\n\nIt eaven has a stub entry:\ntclStubInit.c: Tcl_InitNotifier, /* 307 */\n\nHere is the general call:\ngeneric\\tclNotify.c: procedure: TclInitNotifier()\nwhich is called by the procedure in the same file : TclInitSubsystems()\n\nThis is called by by all of those:\ntclBasic.c: Tcl_CreateInterp()\ntclEncoding: Tcl_FindExecutable()\n\nThe patch proposed to call: Rivet_CreateTclInterp\nwhich itself calls:\nTcl_FindExecutable()\nand\nTcl_CreateInterp()\n\nThus the thread creation routine should be executed twice.\n\nSo I tried to first end the notifier for the case, that the count variable \"notifierCount\" within Tcl_CreateNotifier() is already 1 which would cause that no notifier is created:\n\nRivet_InitTclStuff(server_rec *s, apr_pool_t *p)\n{\n    rivet_server_conf *rsc = RIVET_SERVER_CONF( s->module_config );\n    Tcl_FinalizeNotifier(NULL);\n    Tcl_Interp *interp = Rivet_CreateTclInterp(s);\n...\n\nThis removed also the one nothifier thread owned by root but does not create one owned by apache used:\nIn the upper ps -L aux, it removes LWP 19613\n\nI also tried to add an explicite \"Tcl_CreateNotifier():\n\nRivet_InitTclStuff(server_rec *s, apr_pool_t *p)\n{\n    rivet_server_conf *rsc = RIVET_SERVER_CONF( s->module_config );\n    Tcl_FinalizeNotifier(NULL);\n    Tcl_Interp *interp = Rivet_CreateTclInterp(s);\n    Tcl_InitNotifier();\n\nbut this does not help...\n\nSorry,\nHarald", "id": 168607, "attachment_id": null, "creator": "harald.oehlmann@elmicron.de", "creation_time": "2013-07-15T14:25:59Z", "time": "2013-07-15T14:25:59Z", "is_private": false}, {"count": 7, "attachment_id": null, "creator": "mxmanghi@apache.org", "text": "I don't know how far we can get doing these tests, but let's try anyway. I don't understand what's wrong with the interpreter created within the child process, I can only surmise there are shared resources not handled consistently with our picture and in order to understand we need at least a way to create a sound interpreter in our child process.\n\nSo what would be the correct way to release those supposedly conflicting resources? Rivet_InitHandler is the callback where the server master interpreter is created. Perhaps you could try releasing all the resource explicitly before returning OK by adding\n\nTcl_Finalize();\n\n \"Tcl_Finalize is similar to Tcl_Exit except that it does not exit from the current process.  It is useful for cleaning up when a process is finished using Tcl\" (man 3tcl Tcl_Finalize)\n\nI suppose it's not essential to delete the interpreter", "id": 168622, "time": "2013-07-16T16:55:57Z", "bug_id": 55153, "creation_time": "2013-07-16T16:55:57Z", "tags": [], "is_private": false}, {"count": 8, "tags": [], "creator": "harald.oehlmann@elmicron.de", "text": "Massimo,\n\nthank you for the comment.\n\nYes this might work.\n\nI had another idea:\nzclUnixNotify.c: Tcl_InitNotifier\n\nModify this function, that it checks, if the Process has changed, e.g. we are in a fork.\nIf so:\n- close the communication pipe (as we have copies of the file handlers)\n- restart the notifier thread\n\nThis would preserve the capability of Rivet to:\n- first load\n- then fork\nwhich is currently the case and helped to spped-up the boot time of FlightAware around 40 Minuites...\n\nDo you think this is feasable?\n\nHarald", "id": 168634, "time": "2013-07-17T06:33:30Z", "bug_id": 55153, "creation_time": "2013-07-17T06:33:30Z", "is_private": false, "attachment_id": null}, {"count": 9, "tags": [], "bug_id": 55153, "attachment_id": null, "text": "TCL was modified, that Tcl_InitNotifier also starts the thread if we are forked.\nUsing that, fileevents do fire.\n\nAn alternate solution I see would to create the Tcl interpreter after the fork, which would vanish advantages by the general init script...\n\nRequired modifications in Rivet are:\nmod_rivet.c :\n\nPut \n    Tcl_InitNotifier();\nsomewhere at the beginning of function:\n    Rivet_InitTclStuff\n\nAlternate test script is:\n--test_file_async.tcl--\nset q I\nset h [open /usr/tmp/test.txt w]\nset idafter [after 100000 \"set q T\"]\nfileevent $h writable \"set q W;after cancel [after 1000 \"set q T\"]\"\nvwait q\nclose $h\nputs $q\nfile delete /usr/tmp/test.txt\n-EOF \n\nHere is the tcl RFE:\nhttp://core.tcl.tk/tcl/info/a0bc856dcd\n\nHave fun ;-)\nHarald", "id": 168648, "time": "2013-07-17T16:15:33Z", "creator": "harald.oehlmann@elmicron.de", "creation_time": "2013-07-17T16:15:33Z", "is_private": false}, {"count": 10, "tags": [], "creator": "mxmanghi@apache.org", "attachment_id": null, "id": 168650, "time": "2013-07-17T16:47:23Z", "bug_id": 55153, "creation_time": "2013-07-17T16:47:23Z", "is_private": false, "text": "Brilliant Harald\n\nMy patch with Rivet_CreateTclInterp(s) was meant to create the Tcl interpreter anew hoping for the best about all the subsystems involved. It seems it didn't work. I tried it myself also Finalizing Rivet's master interpreter before Rivet_InitHandler exits, but I got a segmentation fault when the first request is served\n\nPlease, would you share your patch to Tcl? Have you considered about a TIP?"}, {"count": 11, "tags": [], "text": "There are some related mails on the rivet dev mailing list:\n\n---\n\nDamon Courtney: issue does only show in threadded tcl\n\n---\n\nJeff Lawson: master interpreter preinitialisation is a big time saver:\n\nIt is definitely important for us at FlightAware to be able to do Tcl interpreter initialization before forking.  Our webserver environment uses multiple physical servers each with 300 Apache children processes.  During the Tcl global init and before forking, we pre-load several gigabytes of infrequently changed data from our database for performance.\n\nThe inability to do this pre-loading would cause each child to have to load this data from the database (which causes a massive database overhead for 300 connections to simultaneously request that much data), which indeed adds many minutes of startup time to our daily release cycle.  Since our release cycle requires us to fully restart one physical server at a time so that we can continue to serve production traffic on the remaining physical servers, any increase in restart time cascades linearly with the number of physical servers we have.\n\nThe added database overhead of these 300 Apache children requesting gigabytes of data would also compromise our ability to handle normal database traffic from our other servers while we are restarting one.  \n\nAdditionally, the RAM usage on the webservers is significantly impacted since this static data is now actually allocated and duplicated in each child, rather than being loaded in the parent and cloned via copy-on-write pages to each child.  Several gigabyte per child multiplied by 300 processes is a significant memory footprint change for our webservers.\n\n---\n\nMassimo about some tests:\n\nI got fileevent working again by inserting Tcl_FinalizeNotifier in\nRivet_InitHandler and Tcl_InitNotifier in Rivet_InitTclStuff (at the\ncost of breaking the inheritance of an interpreter from the parent to\nthe child process)", "attachment_id": null, "bug_id": 55153, "id": 168661, "time": "2013-07-19T09:52:59Z", "creator": "harald.oehlmann@elmicron.de", "creation_time": "2013-07-19T09:52:59Z", "is_private": false}, {"count": 12, "tags": [], "bug_id": 55153, "text": "E-Mail by Jan Nijtmans on clt:\n\n2013/7/17 Harald Oehlmann <harald.oehlmann@elmicron.de>:\n> Q1) Is this use-case reasonable to cover by the tcl core?\n\nYes\n\n> Q2) May a wizard please review the code\n\nCompare your solution with the solution already present\nin the OSX-version of the notifier:\n    <http://core.tcl.tk/tcl/artifact/8c82932603?ln=512-521>\nIt's very similar. Looks OK to me, even though I'm\nnot a wizard regarding the UNIX notifier.\n\n> Q3) Is this a bug fix or is a TIP required ?\n\nGive that the bug only manifests itself on UNIX\nwith --enable-threads, I would say it's a bug. OSX\nalready has a similar solution to what you propose\nand Windows doesn't have fork at all. Any Tcl\napplication which doesn't use threads should\nbehave the same whether threads are enabled or\nnot. Failing that it's a bug, and the best way\nto demonstrate that is with a test-case.\n\n> Q4) If reasonable, we should also back-port it to tcl8.5\n\nBugs are normally fixed in core-8-5-branch first, then\nmerged to trunk. I rebased \"rfe-notifier-fork\" to\ncore-8-5-branch now and added a \"testfork\" test\ncommand. Adding a test-case is all that's left to\nbe approved for the core.\n\nThe OSX solution using pthread_atfork() disables\nthe OSX notifier during the fork. I don't think that's\nnecessary for the UNIX notifier, but maybe someone\nelse can comment on that.", "id": 168708, "time": "2013-07-22T08:39:23Z", "creator": "harald.oehlmann@elmicron.de", "creation_time": "2013-07-22T08:39:23Z", "is_private": false, "attachment_id": null}, {"count": 13, "tags": [], "bug_id": 55153, "attachment_id": null, "text": "Fixed in *TCL* core \"trunk\" and \"core-8-5-branch\":\n\nhttp://core.tcl.tk/tcl/info/4e3f024bd7\n\nhttp://core.tcl.tk/tcl/info/0107005970c\n\nThis fix should be included in upcoming TCL 8.6.1 and 8.5.15\n\n---\n\nIf pthread_atfork works (TCL configure reports YES), there is no need to modify Rivet. Otherwise, an additional Tcl_InitNotifier call is required.\n\nIf an older TCL version is used, one may choose of the following options:\n\n- do not use threaded tcl (default for tcl 8.5.x)\n- do not use fileevents with rivet\n\nThe init script feature should be well documented not to leave any file handles open.\n\nThank you all,\nHarald", "id": 169167, "time": "2013-08-06T06:56:38Z", "creator": "harald.oehlmann@elmicron.de", "creation_time": "2013-08-06T06:56:38Z", "is_private": false}, {"count": 14, "tags": [], "creator": "harald.oehlmann@elmicron.de", "attachment_id": null, "id": 169170, "time": "2013-08-06T07:22:10Z", "bug_id": 55153, "creation_time": "2013-08-06T07:22:10Z", "is_private": false, "text": "What could be done in addition:\n\n- include the pthread_atfork test from tcl in the configure script\n- include a Tcl_InitNotifier() if pthread_atfork is not available\n\n#if !defined(HAVE_PTHREAD_ATFORK)\n    Tcl_InitNotifier();\n#endif\n\nThis would do it the same way as the tcl core test case which is IMHO a good thing.\n\nThank you,\nHarald"}, {"count": 15, "attachment_id": null, "creator": "mxmanghi@apache.org", "text": "OK Harald, I guess Rivet_InitTclStuff is place where Tcl_InitNotifier should be called", "id": 169176, "time": "2013-08-06T09:50:24Z", "bug_id": 55153, "creation_time": "2013-08-06T09:50:24Z", "tags": [], "is_private": false}]