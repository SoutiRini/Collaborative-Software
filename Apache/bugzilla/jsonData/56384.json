[{"count": 0, "attachment_id": 31508, "bug_id": 56384, "is_private": false, "id": 174453, "time": "2014-04-10T16:07:21Z", "creator": "josh.holthaus@gmail.com", "creation_time": "2014-04-10T16:07:21Z", "tags": [], "text": "Created attachment 31508\npatch\n\nWhen a document contains nested field codes only the inner most field code is processed. This causes unwanted text to appear when converting a document to html.\n\nExample filed code:\n{ SYMBOL { =32+ { SEQ IPItem \\n } \\f \"TDPUNDNO\" \\h \\s 10 }{ADVANCE \\l 11 }\nThis example has 1 field code SYMBOL which contains 2 more field codes within."}, {"count": 1, "tags": [], "bug_id": 56384, "attachment_id": 31509, "text": "Created attachment 31509\nSample Document\n\nThis is a sample document that contains nested field codes. The patch runs junit against this file.", "id": 174454, "time": "2014-04-10T16:09:05Z", "creator": "josh.holthaus@gmail.com", "creation_time": "2014-04-10T16:09:05Z", "is_private": false}, {"count": 2, "attachment_id": null, "bug_id": 56384, "text": "Hm, the patch seems to remove quite a bit of code, I don't know this area well, so am not sure why it was necessary before and how it becomes be obsolete after your changes, can you please explain in a few sentences how you managed the same behaviour+fix with your changes?", "id": 181687, "time": "2015-03-11T20:38:55Z", "creator": "dominik.stadler@gmx.at", "creation_time": "2015-03-11T20:38:55Z", "tags": [], "is_private": false}, {"count": 3, "tags": [], "text": "I am basically redoing the iteration in the parseFieldStructureImpl method. The current switch statement will ignore a field code if a second FIELD_BEGIN_MARK is encountered before a FIELD_END_MARK. Example: { OUTER_FIELD { INNER_FIELD }}. In this case the OUTER_FIELD would be ignored because the start of the INNER_FIELD occurs before the OUTER_FIELD is closed. I changed the method to store all the begin marks in a list to retain their order when fields are nested. When a FIELD_END_MARK is encountered I take the last FIELD_BEGIN_MARK and corresponding FIELD_SEPARATOR_MARK and add them to the results. I no longer needed the binarySearch method to determine the next start since I changed it to iterate through all fields between startOffsetInclusive and endOffsetExclusive.", "attachment_id": null, "id": 181716, "creator": "josh.holthaus@gmail.com", "time": "2015-03-12T21:11:54Z", "bug_id": 56384, "creation_time": "2015-03-12T21:11:54Z", "is_private": false}]