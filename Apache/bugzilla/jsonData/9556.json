[{"count": 0, "tags": [], "bug_id": 9556, "text": "The following case behaves as I would expect:\n   Perl5 Expression: (.)(?=(.))(.)\n   Search Input: XYZ\n   Match 1: XY\n      Subgroups:\n         1: X\n         2: Y\n         3: Y\n\nBut the slightly simpler case, below, doesn't seem to match the 2nd subgroup\ncorrectly:\n   Perl5 Expression: (.)(?=(.))\n   Search Input: XY\n   Match 1: X\n      Subgroups:\n         1: X\n         2:\n\nShouldn't the second subgroup in the second case be \"Y\" instead of blank?\nI'm trying this in the \"Demonstration Applet\" from version 2.0.6.", "id": 17022, "time": "2002-06-01T00:06:59Z", "creator": "adrianboyko@hotmail.com", "creation_time": "2002-06-01T00:06:59Z", "is_private": false, "attachment_id": null}, {"count": 1, "tags": [], "creator": "dfs@apache.org", "attachment_id": null, "text": "Perl does fill $2 with Y.  And so does Perl5Matcher.  If you look at\nthe group offsets, you'll find the matching is performed correctly.  In\nother words, two groups are found and the begin and end offsets of the\nsecond group are 1 and 2.  However, because the matched group was a\nzero-width lookahead assertion, the Y character is not consumed and not\nconsidered part of the full match.  So the full match is just 'X'.  Since\nthe full match stored in the MatchResult is 'X', offsets that exceed the\nlength of the match result in empty strings.  To show that the full\nmatch is just 'X' in Perl, look at group 0 here:\n\n~> perl -e '\"xy\" =~ /(.)(?=(.))/; print \"0: $& 1: $1 2: $2 3: $3\\n\";'\n0: x 1: x 2: y 3: \n\nNow, the problem we're faced with is one that I'm not sure how to deal\nwith.  Is the capturing of the lookahead assertion an undefined\nside-effect, much as some situations involving the capturing of\nrepetitions used to be before Perl 5.6?  Or is it intended for a\ngroups that match outside of the full match to be saved?  It's\nactually quite tricky to implement this without either maintaining\na reference to a copy of the entire original input (undesirable) or\nscrewing up a lot of other cases.  I'd like to mull this one over\nfor a while.  In the meantime, the workaround is to use the group\noffset information to extract the appropriate substring from the\ninput.", "id": 17024, "time": "2002-06-01T00:39:15Z", "bug_id": 9556, "creation_time": "2002-06-01T00:39:15Z", "is_private": false}, {"count": 2, "tags": [], "text": "Here's a patch that fixes the case you reported.  I don't think it\nbreaks anything else, but I can't be sure.  Any volunteers for those\nunit tests we keep talking about?  At any rate, I don't want to apply\nthe patch until it has been well-tested.\n\nIndex: src/java/org/apache/oro/text/regex/Perl5MatchResult.java\n===================================================================\nRCS file:\n/home/cvs/jakarta-oro/src/java/org/apache/oro/text/regex/Perl5MatchResult.java,v\nretrieving revision 1.4\ndiff -u -r1.4 Perl5MatchResult.java\n--- src/java/org/apache/oro/text/regex/Perl5MatchResult.java\t17 May 2001 21:59:33 -0000\t1.4\n+++ src/java/org/apache/oro/text/regex/Perl5MatchResult.java\t31 May 2002 16:21:15 -0000\n@@ -125,7 +125,11 @@\n    * @return The length of the match.\n    */\n   public int length(){\n-    return _match.length();\n+    int length;\n+\n+    length = (_endGroupOffset[0] - _beginGroupOffset[0]);\n+\n+    return (length > 0 ? length : 0);\n   }\n \n \nIndex: src/java/org/apache/oro/text/regex/Perl5Matcher.java\n===================================================================\nRCS file:\n/home/cvs/jakarta-oro/src/java/org/apache/oro/text/regex/Perl5Matcher.java,v\nretrieving revision 1.18\ndiff -u -r1.18 Perl5Matcher.java\n--- src/java/org/apache/oro/text/regex/Perl5Matcher.java\t25 Jan 2002 09:32:28 -0000\t1.18\n+++ src/java/org/apache/oro/text/regex/Perl5Matcher.java\t31 May 2002 16:21:16 -0000\n@@ -241,7 +241,7 @@\n   // Set the match result information.  Only call this if we successfully\n   // matched.\n   private void __setLastMatchResult() {\n-    int offs;\n+    int offs, maxEndOffs = 0;\n \n     //endOffset+=dontTry;\n \n@@ -251,10 +251,6 @@\n     if(__endMatchOffsets[0] > __originalInput.length)\n       throw new ArrayIndexOutOfBoundsException();\n \n-    __lastMatchResult._match =\n-      new String(__originalInput, __beginMatchOffsets[0],\n-\n\t __endMatchOffsets[0] - __beginMatchOffsets[0]);\n-\n     __lastMatchResult._matchBeginOffset = __beginMatchOffsets[0];\n \n     while(__numParentheses >= 0) {\n@@ -269,15 +265,21 @@\n \n       offs = __endMatchOffsets[__numParentheses];\n \n-      if(offs >= 0)\n+      if(offs >= 0) {\n \t__lastMatchResult._endGroupOffset[__numParentheses] =\n \t  offs - __lastMatchResult._matchBeginOffset;\n-      else\n+\nif(offs > maxEndOffs && offs <= __originalInput.length)\n+\n  maxEndOffs = offs;\n+      } else\n \t__lastMatchResult._endGroupOffset[__numParentheses] =\n \t  OpCode._NULL_OFFSET;\n \n       --__numParentheses;\n     }\n+\n+    __lastMatchResult._match =\n+      new String(__originalInput, __beginMatchOffsets[0],\n+\n\t maxEndOffs - __beginMatchOffsets[0]);\n \n     // Free up for garbage collection\n     __originalInput = null;\n", "attachment_id": null, "id": 17025, "creator": "dfs@apache.org", "time": "2002-06-01T00:40:36Z", "bug_id": 9556, "creation_time": "2002-06-01T00:40:36Z", "is_private": false}, {"count": 3, "tags": [], "text": "Went ahead and applied fix so that it can be tested by users in a 2.0.7-dev-1\nrelease.", "is_private": false, "id": 18686, "creator": "dfs@apache.org", "time": "2002-06-27T23:03:01Z", "bug_id": 9556, "creation_time": "2002-06-27T23:03:01Z", "attachment_id": null}, {"count": 4, "tags": [], "bug_id": 9556, "text": "Closing as it's been fixed for a good many months now.", "id": 32525, "time": "2003-03-06T03:43:45Z", "creator": "dfs@apache.org", "creation_time": "2003-03-06T03:43:45Z", "is_private": false, "attachment_id": null}]