[{"count": 0, "tags": [], "bug_id": 5040, "is_private": false, "id": 8205, "creation_time": "2001-11-23T00:03:25Z", "time": "2001-11-23T00:03:25Z", "creator": "heiner.amthauer@t-systems.de", "text": "Hi there!\n\nI'm using Tomcat 4.0.1/Apache 1.3.22/mod_webapp1.0. I'm running an applet, \nwhich directly talks to a bunch of servlets. It does this, by opening an \nObjectXxxStream, sending objects and receiving objects. This code has been used \non different webservers, successfully. However, when using the above mentioned \ncombination, I get an EOFException on some specific objects. Ulrich Knecht has \npointed out the same problem on Thu, Oct. 4th, 2001 at tomcat userlist. \nAttached, you'll find lots of lines, containing the stack trace and one class \n(with superclass), which cannot be send via mod_webapp/warp, using a \nObjectXxxStream.\n\nHeiner\n\n\n--------------------------------- stack -------------------------------------\n2001-11-23 08:24:29 \norg.apache.catalina.INVOKER.com.dsh.egb.aks.betrieb.servlets.BlattIdServlet:  \n[BlattIdServlet] java.io.EOFException\n\tat java.io.DataInputStream.readFully(Unknown Source)\n\tat java.io.ObjectInputStream.readFully(Unknown Source)\n\tat java.io.ObjectInputStream.inputClassFields(Unknown Source)\n\tat java.io.ObjectInputStream.defaultReadObject(Unknown Source)\n\tat java.io.ObjectInputStream.inputObject(Unknown Source)\n\tat java.io.ObjectInputStream.readObject(Unknown Source)\n\tat java.io.ObjectInputStream.inputArray(Unknown Source)\n\tat java.io.ObjectInputStream.readObject(Unknown Source)\n\tat java.io.ObjectInputStream.inputClassFields(Unknown Source)\n\tat java.io.ObjectInputStream.defaultReadObject(Unknown Source)\n\tat java.io.ObjectInputStream.inputObject(Unknown Source)\n\tat java.io.ObjectInputStream.readObject(Unknown Source)\n\tat java.io.ObjectInputStream.inputClassFields(Unknown Source)\n\tat java.io.ObjectInputStream.defaultReadObject(Unknown Source)\n\tat java.io.ObjectInputStream.inputObject(Unknown Source)\n\tat java.io.ObjectInputStream.readObject(Unknown Source)\n\tat java.io.ObjectInputStream.readObject(Unknown Source)\n\tat com.dsh.egb.aks.betrieb.servlets.MetaServlet.readFromApplet\n(MetaServlet.java:91)\n\tat com.dsh.egb.aks.betrieb.servlets.BlattIdServlet.doPost\n(BlattIdServlet.java:39)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:760)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:853)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter\n(ApplicationFilterChain.java:247)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter\n(ApplicationFilterChain.java:193)\n\tat org.apache.catalina.core.StandardWrapperValve.invoke\n(StandardWrapperValve.java:243)\n\tat org.apache.catalina.core.StandardPipeline.invokeNext\n(StandardPipeline.java:566)\n\tat org.apache.catalina.core.StandardPipeline.invoke\n(StandardPipeline.java:472)\n\tat org.apache.catalina.core.ContainerBase.invoke(ContainerBase.java:943)\n\tat org.apache.catalina.core.StandardContextValve.invoke\n(StandardContextValve.java:201)\n\tat org.apache.catalina.core.StandardPipeline.invokeNext\n(StandardPipeline.java:566)\n\tat org.apache.catalina.core.StandardPipeline.invoke\n(StandardPipeline.java:472)\n\tat org.apache.catalina.core.ContainerBase.invoke(ContainerBase.java:943)\n\tat org.apache.catalina.core.StandardContext.invoke\n(StandardContext.java:2344)\n\tat org.apache.catalina.core.StandardHostValve.invoke\n(StandardHostValve.java:164)\n\tat org.apache.catalina.core.StandardPipeline.invokeNext\n(StandardPipeline.java:566)\n\tat org.apache.catalina.valves.ErrorDispatcherValve.invoke\n(ErrorDispatcherValve.java:170)\n\tat org.apache.catalina.core.StandardPipeline.invokeNext\n(StandardPipeline.java:564)\n\tat org.apache.catalina.valves.ErrorReportValve.invoke\n(ErrorReportValve.java:170)\n\tat org.apache.catalina.core.StandardPipeline.invokeNext\n(StandardPipeline.java:564)\n\tat org.apache.catalina.core.StandardPipeline.invoke\n(StandardPipeline.java:472)\n\tat org.apache.catalina.core.ContainerBase.invoke(ContainerBase.java:943)\n\tat org.apache.catalina.core.StandardEngineValve.invoke\n(StandardEngineValve.java:163)\n\tat org.apache.catalina.core.StandardPipeline.invokeNext\n(StandardPipeline.java:566)\n\tat org.apache.catalina.core.StandardPipeline.invoke\n(StandardPipeline.java:472)\n\tat org.apache.catalina.core.ContainerBase.invoke(ContainerBase.java:943)\n\tat org.apache.catalina.connector.warp.WarpRequestHandler.handle\n(WarpRequestHandler.java:215)\n\tat org.apache.catalina.connector.warp.WarpConnection.run\n(WarpConnection.java:194)\n\tat java.lang.Thread.run(Unknown Source)\n\n--------------------------- class GbAuswahlDaten.java ------------------------\n\npackage common;\n\nimport java.util.Vector;\nimport java.util.Enumeration;\n\n/**\n * Gruppiert die anzufordernden Grundbuchbl\u00e4tter mit den gew\u00fcnschten Zielen \n(Ansich, Datenexport, Ausdruck, amtlicher Ausdruck, Vorgangs- bzw. \nAntragsliste). * @author\n *\n * Serialisierbar\n */\npublic class GbAuswahlDaten extends DatenObjekt implements java.io.Serializable \n{\n\n    /**\n     * Vector, welcher die GB-Bl\u00e4tter enth\u00e4lt.    * @author\n     */\n    public Vector gbBlaetter;\n\n    /**\n     * true, wenn eine Grundbuchansicht gew\u00fcnscht ist.    * @author\n     */\n    public boolean ansicht;\n\n    /**\n     * true, wenn die GB-Blattdaten in eine andere Anwendung exportiert werden \nsollen.    * @author\n     */\n    public boolean datenExport;\n\n    /**\n     * true, wenn die GB-Ansicht den Vermerk \"Ausdruck\" tragen soll.    * \n@author\n     */\n    public boolean ausdruck;\n\n    /**\n     * true, wenn ein amtlicher Ausdruck auf Papier angefordert werden soll.    \n* @author\n     */\n    public boolean amtlAusdruck;\n\n    /**\n     * true, wenn die laufenden Antr\u00e4ge f\u00fcr das GB-Blatt angezeigt werden \nsollen.    * @author\n     */\n    public boolean vorgangsListe;\n\n    /**\n     * true, wenn die GB-ID der Bl\u00e4tter bereits bekannt ist.    * @author\n     */\n    public boolean gbBlattIdBekannt = false;\n\n    /**\n     * Extradaten\n     */\n    public Object extraDaten;\n    \n    /**\n     * Erzeugt eine Kopie der Daten, ohne den Vector gbBlaetter\n     */\n    public GbAuswahlDaten(GbAuswahlDaten auswahlDaten) {\n        ansicht = auswahlDaten.ansicht;\n        datenExport = auswahlDaten.datenExport;\n        ausdruck = auswahlDaten.ausdruck;\n        amtlAusdruck = auswahlDaten.amtlAusdruck;\n        vorgangsListe = auswahlDaten.vorgangsListe;\n        gbBlattIdBekannt = false;\n        extraDaten = auswahlDaten.extraDaten;\n        gbBlaetter = new Vector();\n    }\n    \n    /**\n     * Erzeugt ein leeres Objekt\n     */\n    public GbAuswahlDaten() {\n    }\n    \n    /** Erzeugt ein Objekt mit einer Kopie der GbBlattInfo */\n    public GbAuswahlDaten(GbBlattInfo gbBlattInfo) {\n        gbBlaetter = new Vector();\n        gbBlaetter.addElement(new GbBlattInfo(gbBlattInfo));\n        gbBlattIdBekannt = true;\n    }\n    \n    public GbAuswahlDaten(GbAuswahlDaten gbAuswahlDaten, GbBlattInfo \ngbBlattInfo) {\n        this(gbAuswahlDaten);\n        gbBlaetter.addElement(gbBlattInfo);\n        if (AksKonstanten.KEINE_GBBLATTID != gbBlattInfo.gbBlattId) \ngbBlattIdBekannt = true;\n    }\n    \n    /**\n     * Erzeugt ein neues Objekt, welches wahlweise die Bl\u00e4tter des alten Objekt \nmit oder\n     * ohne papiergef\u00fchrte Bl\u00e4tter enth\u00e4lt.\n     * @param auswahlDaten zu kopierende Auswahldaten\n     * @param papierGefuehrtUebernehmen true, wenn die papiergef\u00fchrten Bl\u00e4tter \n\u00fcbernommen werden sollen\n     */\n    public GbAuswahlDaten(GbAuswahlDaten gbAuswahlDaten, boolean \npapierGefuehrtUebernehmen) {\n        this(gbAuswahlDaten);\n        gbBlattIdBekannt = gbAuswahlDaten.gbBlattIdBekannt;\n        Enumeration e = gbAuswahlDaten.gbBlaetter.elements();\n        while(e.hasMoreElements()) {\n            GbBlattInfo info = (GbBlattInfo)e.nextElement();\n            if (papierGefuehrtUebernehmen || (AksKonstanten.GBBLATT_PAPIER != \ninfo.typ)) {\n                gbBlaetter.addElement(info);\n            }\n        }\n    }\n}\n\n----------------------------- class DatenObjekt.java ------------------------\n\n/*\n * DatenObjekt.java\n *\n * Created on 2. November 2000, 10:14\n */\n\npackage common;\n\nimport java.lang.reflect.*;\n/**\n * Oberklasse aller Objekte, die nur Daten enthalten. Wird verwendet, um die \nDaten leichter ausgeben zu k\u00f6nnen.\n */\npublic class DatenObjekt extends Object implements java.io.Serializable, AksLog \n{\n\n    /**\n     * Diese Methode f\u00fcgt \u00fcber Reflection die Namen und Typen aller\n     * Felder der \u00fcbergebenen Klasse zu einem String zusammen und\n     * gibt diesen zur\u00fcck. Au\u00dferdem wird noch der Klassenname selbst\n     * mit aufgef\u00fchrt.\n     * @return Eine Stringrepr\u00e4sentation aller Felder der Klasse.\n     */\n    public String toComplexString() {\n        StringBuffer sb = new StringBuffer();\n        Class c = this.getClass();\n        String className = c.getName();\n        sb.append(\"***\" + className + \"***:\\n\");\n        Field[] publicFields = c.getFields();\n        for (int i = 0; i < publicFields.length; i++) {\n            String fieldName = publicFields[i].getName();\n            Class typeClass = publicFields[i].getType();\n            String fieldType = typeClass.getName();\n            Object fieldValue = null;\n            try{\n                fieldValue =publicFields[i].get(this);\n            } catch (SecurityException e) {\n                System.out.println(e);\n            } catch (IllegalAccessException e) {\n                System.out.println(e);\n            }\n            sb.append(fieldName);\n            sb.append(\" | \");\n            sb.append(fieldType);\n            sb.append(\" | \");\n            sb.append(fieldValue);\n\n            sb.append(\"\\n\");\n        }\n        return sb.toString();\n    }\n\n    public String toString() {\n        StringBuffer sb = new StringBuffer();\n        Class c = this.getClass();\n        Field[] publicFields = c.getFields();\n        for (int i = 0; i < publicFields.length; i++) {\n            String fieldName = publicFields[i].getName();\n            Class typeClass = publicFields[i].getType();\n            String fieldType = typeClass.getName();\n            Object fieldValue = null;\n            try{\n                fieldValue =publicFields[i].get(this);\n            } catch (SecurityException e) {\n                System.out.println(e);\n            } catch (IllegalAccessException e) {\n                System.out.println(e);\n            }\n            // null, Leerstrings und false m\u00fcssen nicht gespeichert werden, da \ndiese eh Iinitiale Werte sind!\n            if (((fieldValue != null) && !fieldValue.toString().equals(\"\")) && !\nfieldValue.toString().equals(\"false\")){\n            \n                sb.append(fieldName);\n                sb.append(\"=\");\n                sb.append(fieldValue);\n                sb.append(\",\");\n            }\n        }\n        return sb.substring(0,sb.length()-1);\n    }\n\n        \n    public void log(final java.lang.Object p1,long p2) {\n        log(this, p1, p2);\n    }\n    \n    public void log(Object p1, Object p2, long p3) {\n        AksKonstanten.getLogger().log(p1, p2, p3);\n    }\n}\n\n\n-------------------------- interface AksLog.java --------------------------\n\n/*\n * AksLog.java\n *\n * Created on 22. Februar 2001, 15:28\n */\n\npackage common;\n\n/**\n * sorgt f\u00fcr einen einheitlichen Mechanismus zum Beschreiben von \"Log-Dateien\"\n * @author  Dr. Josef Siegel\n * @version 1.0\n */\npublic interface AksLog {\n    \n    /**\n     * gibt <code>nachricht</code> aus, \n     * falls das <code>Debuglevel&level</code> von 0 verschieden ist.\n     * Diese Methode dient nur zur Bequehmlichkeit und muss bei der \nImplementierung\n     * die Methode <code>log(caller, nachricht, level)</log> aufrufen.\n     * @param nachricht auszugebender Text\n     * @param level Bit, das gesetzt sein muss, damit der Text ausgegeben wird\n     */\n    public void log(java.lang.Object nachricht, long level);\n    \n    /**\n     * gibt <code>nachricht</code> aus, \n     * falls das <code>Debuglevel&level</code> von 0 verschieden ist.\n     * Bei der Ausgabe wird der Klassenname von <code>caller</code> mit \nausgegeben.\n     * @param nachricht auszugebender Text\n     * @param caller Referenz auf das Aufrufende Objekt\n     * @param level Bit, das gesetzt sein muss, damit der Text ausgegeben wird\n     */\n    public void log(Object caller, java.lang.Object nachricht, long level);\n    \n}", "attachment_id": null}, {"count": 1, "attachment_id": null, "bug_id": 5040, "is_private": false, "id": 14994, "time": "2002-04-29T12:23:38Z", "creator": "pier@betaversion.org", "creation_time": "2002-04-29T12:23:38Z", "tags": [], "text": "\n\n*** This bug has been marked as a duplicate of 4930 ***"}]