[{"count": 0, "attachment_id": 28526, "bug_id": 53022, "text": "Created attachment 28526\nEffect described Tomcat 7.0.26\n\nHi\n\nI was running some performance tests across multiple frameworks with Tomcat and I just found a issue with the session management. \n\nThe test try to run tomcat with low memory (-Xms32m -Xmx32m -server) and put it to stress, to see how the garbage collector (GC) handles the load.\n\nI tried the same tests with 7.0.23 without problem, but when I changed to 7.0.26, I notice the server in one moment cannnot found the session and makes my test load fail. I use jmeter for the load and I can see for some time how the test start to fail. But new request continues hitting the server creating new session, but in that case those sessions does not fail, so again it continues for other time. \n\nI run tests with different frameworks, and in each framework the response is different but the problem is the same: a request try to get a session that should exists, then the session is not found and the code fails.\n\nCould you guys review the changes done between 7.0.23 and 7.0.26 to see if there is some problem?", "id": 157040, "time": "2012-04-02T02:46:57Z", "creator": "lu4242@apache.org", "creation_time": "2012-04-02T02:46:57Z", "tags": [], "is_private": false}, {"count": 1, "tags": [], "creator": "lu4242@apache.org", "attachment_id": 28527, "id": 157041, "time": "2012-04-02T02:47:34Z", "bug_id": 53022, "creation_time": "2012-04-02T02:47:34Z", "is_private": false, "text": "Created attachment 28527\nNormal behavior Tomcat 7.0.23"}, {"count": 2, "tags": [], "bug_id": 53022, "attachment_id": null, "is_private": false, "id": 157042, "time": "2012-04-02T02:51:58Z", "creator": "lu4242@apache.org", "creation_time": "2012-04-02T02:51:58Z", "text": "I have attached two graphs that shows how it should work normally, and what is happening in 7.0.26. When the blank spots happen, the effect over the session is seen.\n\nI think this one is blocker priority, but I set it as critical, so you can evaluate it first. Thanks for your attention"}, {"count": 3, "tags": [], "creator": "markt@apache.org", "attachment_id": null, "text": "There is no evidence here of a bug with Tomcat.\n\nExpecting the committers to review every change since 7.0.23 on the basis of this bug report is - frankly - ridiculous.\n\nPlease follow up this issue on the users mailing list. There are two things I strongly recommend that you do before posting there:\n1. Check the logs for errors.\n2. Add the requested session ID to the access log and review the access logs.", "id": 157050, "time": "2012-04-02T08:18:22Z", "bug_id": 53022, "creation_time": "2012-04-02T08:18:22Z", "is_private": false}, {"count": 4, "tags": [], "creator": "lu4242@apache.org", "attachment_id": null, "text": "Ok, I'll explain it in deep. Look this code in org.apache.catalina.session.ManagerBase\n\n    protected String generateSessionId() {\n\n        String result = null;\n\n        do {\n            if (result != null) {\n                // Not thread-safe but if one of multiple increments is lost\n                // that is not a big deal since the fact that there was any\n                // duplicate is a much bigger issue.\n                duplicates++;\n            }\n\n            result = sessionIdGenerator.generateSessionId();\n            \n        } while (sessions.containsKey(result));\n        \n        return result;\n    }\n\nBut the in tomcat 7.0.23 was\n\n    protected synchronized String generateSessionId() {\n......\n\nThe code was changed in 7.0.26 from use just one SecureRandom to:\n\nprivate Queue<SecureRandom> randoms = new ConcurrentLinkedQueue<SecureRandom>();\n\nThere is one good reason for use a synchronized method in that part. Before Java 7, there is no mention anywere on java spec that SecureRandom is thread safe. To ensure thread safety, SecureRandom and the algorithm should ensure thread safety (look than in 7.0.26, the algorihm can be configured, are you 100% sure the algorithm selected will be thread safe?). Being strict with java spec, you should use a synchronized block in that part. \n\nBut the worst part is the use of a queue of SecureRandom instances and the way the algorithm check for duplicates. Since the containsKey() operation and the further put() operation occur in different places (see ManagerBase.add()), there is no warrant a duplicate sessionid cannot be included in the time between containsKey() and put() and since you have multiple SecureRandom instances this risk is even more evident.\n\nEven if the probability that those events could happen is very, very, very small, it is clear that ManagerBase.add() operation should do the check for duplicates too and if that so, try to generate and alternate identifier.\n\nNote how tricky is all this. Reproduce this failure is something almost impossible, one in a million. There is no unit test that could catch it, but the bug exists, it is theorically feasible.\n\nAfter investigating my particular problem, I found that my problem was more related with JMeter. In my load test I used the default Java for HTTP protocol implementation (because is a little bit faster) but since there is no control over connection reuse, Tomcat throw SocketException after some time without log it in the default logger. Switching to HttpClient4 solves the problem.\n\nIt is curious how many users has been caught over the time into the same problem (JMeter-Tomcat). After all, the solution is not trivial. \n\nPlease be more kind in the future. By experience I know that sometimes gather evidence about these kind of bugs is very difficult, so don't throw away such reports, without consider them first.", "id": 157078, "time": "2012-04-02T20:41:44Z", "bug_id": 53022, "creation_time": "2012-04-02T20:41:44Z", "is_private": false}, {"count": 5, "tags": [], "bug_id": 53022, "attachment_id": null, "id": 157081, "time": "2012-04-02T21:25:31Z", "creator": "markt@apache.org", "creation_time": "2012-04-02T21:25:31Z", "is_private": false, "text": "(In reply to comment #4)\n> Ok, I'll explain it in deep. Look this code in\n> org.apache.catalina.session.ManagerBase\n> \n>     protected String generateSessionId() {\n> \n>         String result = null;\n> \n>         do {\n>             if (result != null) {\n>                 // Not thread-safe but if one of multiple increments is lost\n>                 // that is not a big deal since the fact that there was any\n>                 // duplicate is a much bigger issue.\n>                 duplicates++;\n>             }\n> \n>             result = sessionIdGenerator.generateSessionId();\n> \n>         } while (sessions.containsKey(result));\n> \n>         return result;\n>     }\n> \n> But the in tomcat 7.0.23 was\n> \n>     protected synchronized String generateSessionId() {\n> ......\n\nNo it wasn't. The code quoted for 7.0.23 is incorrect. The only code changes to ManagerBase since 7.0.23 are to add some comments and to make some fields final.\n\n\n> The code was changed in 7.0.26 from use just one SecureRandom to:\n> \n> private Queue<SecureRandom> randoms = new\n> ConcurrentLinkedQueue<SecureRandom>();\n\nWrong again. That change was introduced in 7.0.5.\n\n\n> There is one good reason for use a synchronized method in that part. Before\n> Java 7, there is no mention anywere on java spec that SecureRandom is thread\n> safe. To ensure thread safety, SecureRandom and the algorithm should ensure\n> thread safety (look than in 7.0.26, the algorihm can be configured, are you\n> 100% sure the algorithm selected will be thread safe?). Being strict with java\n> spec, you should use a synchronized block in that part.\n\nWrong again. There is no concurrent access to SecureRandom instances.\n\n\n> But the worst part is the use of a queue of SecureRandom instances and the way\n> the algorithm check for duplicates. Since the containsKey() operation and the\n> further put() operation occur in different places (see ManagerBase.add()),\n> there is no warrant a duplicate sessionid cannot be included in the time\n> between containsKey() and put() and since you have multiple SecureRandom\n> instances this risk is even more evident.\n\nI agree the duplicate check is incomplete but I believe it to be completely unnecessary. The odds of getting a duplicate are so astronomically small that I do not believe we should even bother checking. That code is a left over from very early days of Tomcat when insecure random number generators were used that did have a realistic chance of generating a duplicate.\n\n\n> Even if the probability that those events could happen is very, very, very\n> small, it is clear that ManagerBase.add() operation should do the check for\n> duplicates too and if that so, try to generate and alternate identifier.\n\nAs I stated above, I disagree. The check is pointless.\n\n\n> Note how tricky is all this. Reproduce this failure is something almost\n> impossible, one in a million. There is no unit test that could catch it, but\n> the bug exists, it is theorically feasible.\n\nThe odds are an awful lot longer than that.\n\n\n> After investigating my particular problem, I found that my problem was more\n> related with JMeter. In my load test I used the default Java for HTTP protocol\n> implementation (because is a little bit faster) but since there is no control\n> over connection reuse, Tomcat throw SocketException after some time without log\n> it in the default logger. Switching to HttpClient4 solves the problem.\n\nWhich just confirms my point that this was not a Tomcat bug at all. Depending on what triggered the exception, it may well be logged below INFO level and therefore not be logged by default.\n\n\n> It is curious how many users has been caught over the time into the same\n> problem (JMeter-Tomcat). After all, the solution is not trivial. \n> \n> Please be more kind in the future. By experience I know that sometimes gather\n> evidence about these kind of bugs is very difficult, so don't throw away such\n> reports, without consider them first.\n\nThe 'kindness' of a response is largely proportional to the quality of the bug report. Lets take a look at your initial report:\n- Tomcat version provided? Yes.\n- Test case to reproduce provided? No.\n- Description of how to reproduce? No.\n- Configuration details for Tomcat (Connector, changes to defaults, etc.) provided? No.\n- Configuration for JMeter provided? No.\n- Chances of anyone being able to recreate the problem you were seeing? Zero.\n- Chances of anyone being able to make an educated guess as to the cause of the problem you were seeing? Zero.\n- Evidence of further research on your part to reduce search space (e.g. testing with 7.0.25) ? None.\n\nOverall, a fairly useless bug report. Given the quality of the bug report, my response was pretty mild.\n\nMoving on to comment #4 ...\n\nYour comments on the correctness of the duplicate check are valid but the rest is way off the mark. There are multiple incorrect statements about when changes were introduced followed by some incorrect concurrency analysis. Overall I'd rate it as marginally useful since it has reminded me to look at removing the pointless duplicate check.\n\nIf you choose to respond to this, then I strongly recommend that you read this first:\nhttp://www.catb.org/~esr/faqs/smart-questions.html\n\nand respond on the users list. Bugzilla is not a discussion forum."}, {"count": 6, "tags": [], "bug_id": 53022, "text": "I would thought and algorithm so critical like session id generation would be bullet proof .... anyway ..... not very professional .... maybe too lazy to do it right ... whatever ....\n\nI checked the comparison and it seems my IDE confused tomcat sources with other ones taken from a optional dependency, so I was looking an old version. Thanks for notice it.\n\nFinally, it is clear this issue should be solved as Won't Fix, instead Invalid. After all, the path taken here is ignore a possible failure because its probability is very small. I appreciate your help and your fast response with this issue ;-) calm down! be cool!.", "id": 157086, "time": "2012-04-02T22:06:05Z", "creator": "lu4242@apache.org", "creation_time": "2012-04-02T22:06:05Z", "is_private": false, "attachment_id": null}, {"count": 7, "tags": [], "text": "After evaluating the probabilities, it seems to be the size of the key is critical. Since by default sessionIdLength is 16, there are 2^128 = 3.4e38 possible combinations. So, the possible number of sessions in a single tomcat instance and the ammount of request a tomcat instance is capable to handle in a reasonable frame of time is much more less. The duplicate check is useless, because it will not affect significantly the probability, but a single lookup over a ConcurrentHashMap is cheap enough to let it (because the duplicate should happen in a even shorter frame of time). Anyway, a simple check taking the value returned by put() operation, could easily detect the occurrence, and it is not necessary to do anything more than restore the old session in the map, and throw an exception for the new one. It will be enough to prevent the duplicate session effect at 100% and they are just some few lines of code.\n\nOther different history will happen if the user reduce sessionIdLength, but there is nothing to do in that case, maybe a check for a minimal sessionIdLength is reasonable, but it is questionable because usually you want that key be large enough to make computationally infeasible to find it by brute force.", "attachment_id": null, "id": 157089, "creator": "lu4242@apache.org", "time": "2012-04-03T02:20:59Z", "bug_id": 53022, "creation_time": "2012-04-03T02:20:59Z", "is_private": false}]