[{"count": 0, "tags": [], "bug_id": 4129, "attachment_id": null, "is_private": false, "id": 6647, "time": "2001-10-12T13:17:35Z", "creator": "gmarcy@us.ibm.com", "creation_time": "2001-10-12T13:17:35Z", "text": "AttributesImpl.java includes a \"fix\" that changed the original:\n\n    public void removeAttribute (int index)\n    {\n        if (index >= 0 && index < length) {\n              if (index < length - 1) {\n                System.arraycopy(data, (index+1)*5, data, index*5,\n                                 (length-index)*5);\n            }\n            length--;\n        } else {\n            badIndex(index);\n        }\n    }\n\nto:\n\n    public void removeAttribute (int index)\n    {\n        if (index >= 0 && index < length) {\n            data[index*5] = null;\n            data[index*5+1] = null;\n            data[index*5+2] = null;\n            data[index*5+3] = null;\n            data[index*5+4] = null;\n            if (index < length - 1) {\n                System.arraycopy(data, (index+1)*5, data, index*5,\n                                 (length-index-1)*5);\n            }\n            length--;\n        } else {\n            badIndex(index);\n        }\n    }\n\nThe original code was clearing the entry at the new end of the list by copying \nthe presumably empty entry \"one past the end\" over the last entry.  The change \ncorrectly changed the length of the copy to no longer reference past the end of \nthe data array, which would sometimes raise an ArrayIndexOutOfBoundsException.\n\nHowever, the code to clear the element being removed just before it is copied \nover can only be useful in the single case where the copy doesn't happen, i.e. \nthe attr removed is the last one in the list.  The correct code would always \nclear the entry that actually needs to be cleared, which is the one that was \npreviously in the last position before one was removed.  The following code does \nso:\n\n    public void removeAttribute (int index)\n    {\n        if (index >= 0 && index < length) {\n            if (index < length - 1) {\n                System.arraycopy(data, (index+1)*5, data, index*5,\n                                 (length-index-1)*5);\n            }\n            length--;\n            data[length*5] = null;\n            data[length*5+1] = null;\n            data[length*5+2] = null;\n            data[length*5+3] = null;\n            data[length*5+4] = null;\n        } else {\n            badIndex(index);\n        }\n    }"}, {"count": 1, "tags": [], "bug_id": 4129, "attachment_id": null, "text": "Do we have a test program that shows the effects of this bug on another Apache \nproduct yet?", "id": 6730, "time": "2001-10-15T16:27:10Z", "creator": "curcuru@apache.org", "creation_time": "2001-10-15T16:27:10Z", "is_private": false}, {"count": 2, "tags": [], "creator": "gmarcy@us.ibm.com", "text": "I am not sure how to create one exactly.  The reason for the initial report is \nnot know to me, except that from inspection I can see that the original code did \nnot clear the \"slots\" following the new last entry after a call to remove an \nattribute.  This would simply leave references to String objects that would not \nbe collectable during gc(), but would otherwise seem to be benign (they are \nimmutable after all...)  My changes were to simply take the \"spirit\" of the \noriginal fix and change the code to clear the String references so that the \nentries in the array were always null beyond the last in-use entry.  Perhaps we \nshould ask garyp or dims if they have more information to offer.\n", "id": 6752, "time": "2001-10-16T05:09:53Z", "bug_id": 4129, "creation_time": "2001-10-16T05:09:53Z", "is_private": false, "attachment_id": null}]