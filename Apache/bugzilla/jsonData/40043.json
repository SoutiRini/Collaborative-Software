[{"count": 0, "tags": [], "creator": "haiping@plaxo.com", "attachment_id": null, "id": 91302, "time": "2006-07-14T06:44:57Z", "bug_id": 40043, "creation_time": "2006-07-14T06:44:57Z", "is_private": false, "text": "I logged this bug against httpd 2.0.58, the version I have, but reading source \ncode of 2.2.0 and 2.2.2, the bug is still there for sure. I didn't check 2.3.\n\nWhen ap_get_client_block() is called with a buffer size say 48k, and it is \ncalled again, even if whole brigade has more data (than 48k), the 2nd call \nwill return 0 regardless. This is because internally, both ap_get_client_block \nand apr_brigade_flatten, a function called by ap_get_client_block, will simply \ndiscard the whole brigade after filling up specified buffer in the 1st call. \nThis buggy behavior is even pointed out by comments in a .c file, not in the \nheader or anywhere in documentation. Several people on the web have \nencountered this same bug one way or another, and there may already be some \nhack or workaround somewhere that I couldn't find, and I'm pretty sure this is \na known bug, probably not logged though. I'm just copying my own workaround by \nreplacing and not calling the original ap_get_client_block(). So one can call \nmine like this sample,\n\napr_bucket_brigade *m_bb = NULL;\napr_bucket *m_b = NULL;\napr_size_t m_pos = 0;\n\n// this block can be repeated until len_read is 0 or -1\nint nBufSize = *piSize;\nint len_read;\nlen_read = ap_get_client_block_ex(m_bb, m_b, m_pos,\n                                 (request_rec*) m_pContext, pBuffer, *piSize);\n\n// in case there's an error somewhere, clean up m_bb\nif (m_bb) {\n  apr_brigade_destroy(m_bb);\n}\n\n\n-- file: http_protocol_ex.h\n\n#include \"apr.h\"\n#include \"apr_lib.h\"\n#include \"apr_strings.h\"\n#include \"apr_pools.h\"\n#include \"apr_tables.h\"\n#include \"apr_buckets.h\"\n#include \"apr_errno.h\"\n#define APR_WANT_MEMFUNC\n#define APR_WANT_STRFUNC\n#include \"apr_want.h\"\n\n#include \"httpd.h\"\n#include \"http_config.h\"\n#include \"http_core.h\"\n#include \"http_protocol.h\"\n\nAP_DECLARE(long) ap_get_client_block_ex(apr_bucket_brigade *&bb,\n                                        apr_bucket *&b,\n                                        apr_size_t &pos,\n                                        request_rec *r, char *buffer,\n                                        apr_size_t bufsiz);\n\nAPU_DECLARE(apr_status_t) apr_brigade_flatten_ex(apr_bucket_brigade *bb,\n                                                 apr_bucket *&b,\n                                                 apr_size_t &pos,\n                                                 char *c, apr_size_t *len);\n\n\n\n-- file http_protocol_ex.c\n\n// where i can fix apache 2.0 bugs\n#include \"http_protocol_ex.h\"\n\nAP_DECLARE(long) ap_get_client_block_ex(apr_bucket_brigade *&bb,\n                                        apr_bucket *&b,\n                                        apr_size_t &pos,\n                                        request_rec *r, char *buffer,\n                                        apr_size_t bufsiz)\n{\n  apr_status_t rv;\n\n  if (r->remaining < 0 || (!r->read_chunked && r->remaining == 0)) {\n    return 0;\n  }\n\n  if (bb == NULL) {\n\n    bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);\n    if (bb == NULL) {\n      r->connection->keepalive = AP_CONN_CLOSE;\n      return -1;\n    }\n\n    rv = ap_get_brigade(r->input_filters, bb, AP_MODE_READBYTES,\n                        APR_BLOCK_READ, bufsiz);\n\n    /* We lose the failure code here.  This is why ap_get_client_block should\n     * not be used.\n     */\n    if (rv != APR_SUCCESS) {\n      /* if we actually fail here, we want to just return and\n       * stop trying to read data from the client.\n       */\n      r->connection->keepalive = AP_CONN_CLOSE;\n      apr_brigade_destroy(bb);\n      bb = NULL;\n      return -1;\n    }\n\n    /* If this fails, it means that a filter is written incorrectly and that\n     * it needs to learn how to properly handle APR_BLOCK_READ requests by\n     * returning data when requested.\n     */\n    AP_DEBUG_ASSERT(!APR_BRIGADE_EMPTY(bb));\n\n    b = NULL;\n  }\n\n  rv = apr_brigade_flatten_ex(bb, b, pos, buffer, &bufsiz);\n  if (rv != APR_SUCCESS) {\n    apr_brigade_destroy(bb);\n    bb = NULL;\n    return -1;\n  }\n\n  if (b == APR_BRIGADE_SENTINEL(bb)) {\n    /* Check to see if EOS in the brigade.\n     *\n     * If so, we have to leave a nugget for the *next* ap_get_client_block\n     * call to return 0.\n     */\n    if (APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(bb))) {\n      if (r->read_chunked) {\n        r->remaining = -1;\n      }\n      else {\n        r->remaining = 0;\n      }\n    }\n\n    apr_brigade_destroy(bb);\n    bb = NULL;\n  }\n\n  /* XXX yank me? */\n  r->read_length += bufsiz;\n\n  return bufsiz;\n}\n\nAPU_DECLARE(apr_status_t) apr_brigade_flatten_ex(apr_bucket_brigade *bb,\n                                                 apr_bucket *&b,\n                                                 apr_size_t &pos,\n                                                 char *c, apr_size_t *len)\n{\n  apr_size_t actual = 0;\n\n  for (b = b ? b : APR_BRIGADE_FIRST(bb); b != APR_BRIGADE_SENTINEL(bb); b = \nAPR_BUCKET_NEXT(b)) {\n    const char *str;\n    apr_size_t str_len;\n    apr_status_t status;\n\n    status = apr_bucket_read(b, &str, &str_len, APR_BLOCK_READ);\n    if (status != APR_SUCCESS) {\n      return status;\n    }\n\n    if (pos >= str_len) {\n      pos = 0;\n      continue;\n    }\n\n    // determine the block in bucket to copy to c\n    apr_size_t pos0 = pos;\n    str += pos; str_len -= pos;    // shift window by \"pos\" to right\n    if (str_len + actual > *len) {\n      str_len = *len - actual;     // shorten window by \"*len - actual\" to left\n    }\n\n    // copy the block/window\n    memcpy(c, str, str_len);\n\n    c += str_len;\n    actual += str_len;\n\n    /* This could probably be actual == *len, but be safe from stray\n     * photons. */\n    if (actual >= *len) {\n      pos = pos0 + str_len; // pos always points to the byte to read next time\n      break;\n    }\n    pos = 0; // get ready to read next bucket\n  }\n\n  *len = actual;\n  return APR_SUCCESS;\n}"}, {"count": 1, "tags": [], "text": "It seems to me this can only manifest as a bug if ap_get_brigade returns too much data, which would imply the real bug is in the filter doing that.  Hence, no doubt, why it's been ignored for so long.\n\nAnd since this is an API issue, you are always in a position to work around that.\nA trivial fix would be to insert a filter that buffers any remaining data if it gets too much (I daresay that's pretty-much equivalent to your posted fix).\n\nMarking WONTFIX because:\n1. Hasn't been fixed, indicating lack of interest\n2. Not really a bug, just a failure to compensate for bugs elsewhere\n3. If it affects you, a workaround is always in your power\n\nHowever, if you have real-life usage cases where this affects you, please tell us!\nIt means there's a buggy input filter that needs fixing!", "is_private": false, "id": 130047, "creator": "nick@webthing.com", "time": "2009-08-29T20:47:33Z", "bug_id": 40043, "creation_time": "2009-08-29T20:47:33Z", "attachment_id": null}]