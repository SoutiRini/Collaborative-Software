[{"count": 0, "tags": [], "bug_id": 16229, "attachment_id": null, "text": "In my application (ArgoUML) there are a lot of places where log4j is called \nwith the debug level. Some of them are like this (actual examples):\n    cat.debug(\"applying critic: \" + _headline);\n...\n    cat.debug(d + \" \" + d.getPriority());\n...\n          Configuration.cat.debug(\"key '\" + key\n                                  + \"' returns '\" + result + \"'\");\n\nThis all seems very harmless, and most of my developers don't (and shouldn't) \nhesitate in adding such lines to the code. Now let me tell you that my \nprofilation of the application lead to the fact that the first line was doing \n18% of all memory allocation as innocent as it may seem (with debug turned off).\n\nThe log4j faq suggests that we should replace\n          cat.debug(\"we now have \" + value)\nwith\n          if (cat.isDebugEnabled()) {\n              cat.debug(\"we now have \" + value);\n          }\nbut this code really makes the log4j-calls stand out and clutter the \napplication code.\n\nLet me suggest that the following convenience methods (with friends) are added \nto the Logger class to fix this problem (I am not sure this exact \nimplementation work but I hope you get the general idea):\n\n    void debug(Object mess1, Object mess2) {\n        if (isDebugEnabled()) {\n            debug(\"\" + mess1 + mess2);\n        }\n    }\n    void debug(Object mess1, Object mess2, Object mess3) {\n        if (isDebugEnabled()) {\n            debug(\"\" + mess1 + mess2 + mess3);\n        }\n    }\n    void debug(Object mess1, Object mess2, Object mess3, Object mess4) {\n        if (isDebugEnabled()) {\n            debug(\"\" + mess1 + mess2 + mess3 + mess4);\n        }\n    }\n    void debug(Object mess1, Object mess2, Object mess3, Object mess4, Object \nmess5) {\n        if (isDebugEnabled()) {\n            debug(\"\" + mess1 + mess2 + mess3 + mess4 + mess5);\n        }\n    }\n\nThese would allow me to write the code like this:\n    cat.debug(\"applying critic: \", _headline);\n...\n    cat.debug(d, \" \", d.getPriority());\n...\n          Configuration.cat.debug(\"key '\", key, \"' returns '\", result, \"'\");\n\na beautiful and efficient implementation.", "id": 29635, "time": "2003-01-17T22:50:11Z", "creator": "linus@tigris.org", "creation_time": "2003-01-17T22:50:11Z", "is_private": false}, {"attachment_id": null, "tags": [], "bug_id": 16229, "text": "Maybe I'm showing my Naivete here, but if you have:\n\nlogger.debug(\"some string\" + somevar + \"another string\" + anothervar);\n\nMultiple StringBuffers would be created via the String concatenation *before*\never callling the debug method.  Therefore, the only place to make this check is\n*before* you call the debug method.  So, logger.isDebugEnabled() is entirely\nnecessary to be in your own code, even though it seems like a burden.  This\nmakes this a bug report against Java itself rather than Log4j.\n\nAm I wrong?\n\nJake", "count": 1, "id": 29637, "time": "2003-01-18T00:15:30Z", "creator": "hoju@visi.com", "creation_time": "2003-01-18T00:15:30Z", "is_private": false}, {"count": 2, "tags": [], "bug_id": 16229, "text": "Hello Jake! You are completely right. If I have\n\nlogger.debug(\"some string\" + somevar + \"another string\" + anothervar);\n\nthe StringBuffer is created before ever calling the debug method and the test \nmust be in my code. I don't like this and that is why I have suggested these \nimprovements.\n\nThis is not a bug in Java, it is a design decision.", "id": 29669, "time": "2003-01-18T20:43:48Z", "creator": "linus@tigris.org", "creation_time": "2003-01-18T20:43:48Z", "is_private": false, "attachment_id": null}, {"count": 3, "tags": [], "text": "I've refactored your code, to provide a better solution, perhaps...\n\nCreate a single new method to log4j, or a wrapper class, as follows.\n\npublic void checkedDebug(Object message)\n{\n  if (isDebugEnabled()) {\n            debug(message);\n        }\n}\n\nThen create the following class\n\npublic class Concatenator\n{\n  Vector fItems = new Vector(5);\n\n  public void addItem(Object newItem)\n  {\n    fItems.add(newItem);\n  }\n\n  public String toString()\n  {\n    String result = \"\";\n    // iterate over fItems here\n    // ...\n    // for each Object in fItems\n    result += curItem.toString();\n    return result;\n  }\n}\n\nI think this is the best solution to your problem.  If more details on this \nsolution are required, please let me know.  (BTW, if you like this solution, \nperhaps it should be added to the FAQ).\n\n  - Matt Munz\n    mmunz@apelon.com\n\n", "attachment_id": null, "id": 29671, "creation_time": "2003-01-18T21:01:59Z", "time": "2003-01-18T21:01:59Z", "creator": "mmunz@apelon.com", "bug_id": 16229, "is_private": false}, {"count": 4, "tags": [], "bug_id": 16229, "text": "Hello Matt!\n\nI don't see the point of your checkedDebug() method. It does exactly the same \nthing as the debug()-method except that same tests are run twice (if enabled).\n\nYour suggestion is that I create a concatenation object instead of creating the \nStringBuffer. If I take some liberty with your suggestion this will look like \nthis in my application (example from Jake):\n\nlogger.debug(new Concatenator(\"some string\", somevar,\n                              \"another string\", anothervar));\n\nI considered this solution but I have two things against it. Firstly, this \nmeans that somewhere in my code I will have this utility class or more likely \nit will be implemented differently in several different parts of my code by \ndifferent developers and some will forget about it. Secondly, this suggestion \nresults in the creation of the Concatenator object wether debugging is on or \noff. It is better than the creation of StringBuffer+String but not good enough.", "id": 29672, "time": "2003-01-18T21:33:57Z", "creator": "linus@tigris.org", "creation_time": "2003-01-18T21:33:57Z", "is_private": false, "attachment_id": null}, {"count": 5, "tags": [], "bug_id": 16229, "attachment_id": null, "id": 29674, "time": "2003-01-18T21:57:07Z", "creator": "mmunz@apelon.com", "creation_time": "2003-01-18T21:57:07Z", "is_private": false, "text": "Linus,\n\nJust an idea -- use it as you'd like.  \n\n> I don't see the point of your checkedDebug() method. It does exactly the same \n> thing as the debug()-method except that same tests are run twice (if enabled).\n\nI'm not aware of the implementation of debug().  If it performs the check, then \nyou are correct, checkedDebug() is unnecessary.\n\n> logger.debug(new Concatenator(\"some string\", somevar,\n>                              \"another string\", anothervar));\n\n>I considered this solution but I have two things against it. Firstly, this \n>means that somewhere in my code I will have this utility class or more likely \n>it will be implemented differently in several different parts of my code by \n>different developers and some will forget about it. Secondly, this suggestion \n\nNo, it just has to be on your classpath.  You could say the same thing about \nevery class you use.  Vector or ArrayList?  Enumeration or Iterator?  Class \nduplication is a fact of life.  The only way to avoid it is to make sure that \nthe developers on your team are on the same page as far as code conventions are \nconcerned.  How do you enforce the use of Logger over System.out?  Use the same \nmechanism to enforce the use of your preferred Concatenation class.\n\n>results in the creation of the Concatenator object wether debugging is on or \n>off. It is better than the creation of StringBuffer+String but not good enough.\n\nOK.  This is Java.  (Almost) Everything is an object.  I too am a member of the \nsociety against the proliferation of objects.  But how much overhead is added \nto the memory footprint by the concatenation class?  \"some string\", \nsomevar, \"another string\", and anothervar are going to get allocated either \nway, AFAIK.  That only leaves the pointers required to constitute the Vector in \nConcatenator.  Given that these can/will be garbage collected after use, this \nis not much of a performance loss, IMO.\n\nLooking at your initial code (line 1), it appears that _headline.toString() is \nthe expensive operation.  The Concatenation object saves you this method call.  \n\nI will admit that I'm not a memory optimization expert, so perhaps I've missed \nsomething here.  If so, please let me know.\n\nAlso, as you might have guessed, I think the pattern\n\nmethodA(arg)\nmethodA(arg, arg)\nmethodA(arg, arg, arg)\nmethodA(arg, arg, arg, ..., arg)\n\nis rather awkward from a design perspective.  I've got to think that there is a \nbetter way.\n\n  - Matt Munz\n    mmunz@apelon.com\n\n"}, {"count": 6, "tags": [], "creator": "linus@tigris.org", "text": "What design perspective? What are the considerations?", "id": 29918, "time": "2003-01-23T08:41:28Z", "bug_id": 16229, "creation_time": "2003-01-23T08:41:28Z", "is_private": false, "attachment_id": null}, {"count": 7, "tags": [], "bug_id": 16229, "attachment_id": null, "text": "Hi,\n\nJust a short remark about this discussion: although I completely agree with the \ncomments of Jacob Kjome on 2003-01-18 00:15 and Linus Tolke on 2003-01-18 20:43 \nabout multiple buffer and concatenation when writing something like\n\n   logger.debug(\"some string\" + somevar + \"another string\" + anothervar);\n\nI think the whole point of the proposition of Linus is to replace this call by \n\n   logger.debug(\"some string\" , somevar , \"another string\" , anothervar);\n\n(i.e. using comas instead of '+'). Otherwise, the proposed extension is NOT \nused!\n\nI think this kind of call is clean and easy to write (easier than \nthe 'concatenator' one). And the implementation is short and straigthforward \ntoo.\n\nThe only drawback I see (and this is also true with the concatenator option) is \nthat all the parameters must be Object, so no int, boolean,...\n\ncheers...\n\n\n", "id": 29919, "time": "2003-01-23T09:13:59Z", "creator": "olivier.vierlinck@advalvas.be", "creation_time": "2003-01-23T09:13:59Z", "is_private": false}, {"count": 8, "tags": [], "text": "Created attachment 11812\nIllustrating example.", "attachment_id": 11812, "id": 58986, "creator": "linus@tigris.org", "time": "2004-06-10T06:27:13Z", "bug_id": 16229, "creation_time": "2004-06-10T06:27:13Z", "is_private": false}, {"count": 9, "tags": [], "bug_id": 16229, "text": "Here is a test case for you. Notice that theGood runs several times faster \nthan theBad while producing the same output.\n\nOn my computer:\n1000 laps 48 times faster.\n3000 laps 387 times faster.\n10000 laps 8025 times faster.\n\nIn theUgly, the code that actually does something is almost completely hidden \nby the log statements.", "id": 58987, "attachment_id": null, "creator": "linus@tigris.org", "creation_time": "2004-06-10T06:27:44Z", "time": "2004-06-10T06:27:44Z", "is_private": false}, {"count": 10, "tags": [], "bug_id": 16229, "attachment_id": null, "text": "Well, JDK 1.5 is going to help us here, but I would think that what should \nnormally be done, and only if performance is an issue, is that StringBuffers are \nused...\n\nI would also think that if you are actually Logging that much in an intensive \nloop, AND in a production environment, you have to ask yourself if you need that \nmuch logging?\n\nI would think that adding a 2nd argument version is just asking for method \nexplosion, and lets just wait until JDK1.5 comes along to save us all.", "id": 58989, "time": "2004-06-10T06:41:13Z", "creator": "psmith@apache.org", "creation_time": "2004-06-10T06:41:13Z", "is_private": false}, {"count": 11, "tags": [], "bug_id": 16229, "attachment_id": null, "text": "Hello Paul!\n\nThen, let me suggest that you update the FAQ at: \nhttp://logging.apache.org/log4j/docs/FAQ.html#fastLogging\nto state that the fastest way of not logging is to remove the log statements \nfrom the source.\n\n(. I had always thought that one of the purposes of having a logger tool like \nlog4j was that it would be possible to leave the debug log statements in the \nproduction code but have debug logging turned off. .)", "id": 58993, "time": "2004-06-10T07:17:52Z", "creator": "linus@tigris.org", "creation_time": "2004-06-10T07:17:52Z", "is_private": false}, {"count": 12, "tags": [], "bug_id": 16229, "attachment_id": null, "id": 58994, "time": "2004-06-10T07:31:23Z", "creator": "psmith@apache.org", "creation_time": "2004-06-10T07:31:23Z", "is_private": false, "text": "Yes, but to minimes heavy logging, you would have the pattern:\n\nif(LOGGER.isDebugEnabled()){\n LOGGER.debug(\"Oh\" + \"Wow\" + \"What\" + \"A\" + \"LOT\" + \"OF object allocation\");\n}\n\nThen that object allocation is never done, as it never gets into the IF block \nunless you have DEBUG on for that logger, and I assume you would not do that \nunless you REALLY need the information."}, {"count": 13, "tags": [], "text": "Yes, and I would prefer to have this handled in log4j than to clutter up my \ncode with if statements. I thought my example was very clear on this.\n\nIf the consequences is a method explosion in log4j that can be reduced again \nwith jdk1.5, so be it! It will be isolated to the logging tool.", "attachment_id": null, "id": 58996, "creation_time": "2004-06-10T07:49:42Z", "time": "2004-06-10T07:49:42Z", "creator": "linus@tigris.org", "bug_id": 16229, "is_private": false}, {"attachment_id": null, "tags": [], "bug_id": 16229, "text": "\nHello Linus,\n\nHow about this:\n  logger.debug(\"Happy birthday {}. Your age of {} is respectable.\", name, age);\n\nThis involves some parsing of the message. The parsed version could be cached \nwithin log4j itself.", "count": 14, "id": 59012, "time": "2004-06-10T13:37:29Z", "creator": "ceki@apache.org", "creation_time": "2004-06-10T13:37:29Z", "is_private": false}, {"count": 15, "tags": [], "bug_id": 16229, "attachment_id": null, "id": 59019, "time": "2004-06-10T14:16:23Z", "creator": "linus@tigris.org", "creation_time": "2004-06-10T14:16:23Z", "is_private": false, "text": "It looks great! The parsing and caching is only needed if debugging is indeed \non."}, {"count": 16, "tags": [], "bug_id": 16229, "text": "\nParsing will only occur if the message needs to be logged. If the log stament \nis disabled, log4j will not parse it for pleasure. :-) ", "id": 59020, "attachment_id": null, "creator": "ceki@apache.org", "creation_time": "2004-06-10T14:21:57Z", "time": "2004-06-10T14:21:57Z", "is_private": false}, {"count": 17, "tags": [], "bug_id": 16229, "text": "Linus/Ceki, \n\nI would suggest using the java.text.MessageFormat class (I think this is JDK1.\n2+, it's been around a while any way).  Then you could do something like this:\n\n\nlogger.debug(\"Happy birthday {1}. Your age of {0} is respectable.\", new Object[]\nage, name});\n\nThis has a number of advantages:\n\n1. It would require no change to the Logger class, nice to minimise this \nsignature change because of downstream compatibility issues \n\n2. This format allows the parameter order to be independanty of the order in \nwhich they are used in the string pattern (note that item 0 is placed last in my \nexample).\n\n3. It allows for an open-ended # arguments without having to \"wait\" for JDK1.5.\n\nSince an array is an Object, the above would just require a change in the \nappending method to check if the Object is an array, and if so, use the \nMessageFormat class.  An Arrays .toString() method is pretty useless, so we \ncould just perform this message parsing.  \n\nIf we were to do this, perhaps it is a good chance to do another convenience \nclass check of the Object and check if it's a Throwable, and get the Stacktrace \nof the Throwable rather than just the .toString().  e.g:\n\n}catch(Exception e){\n  LOG.error(e);\n}\n\nThis is SUCH a common mistake by a developer (even experienced log4j'ers), and \nprobably an 'assumed' function, that we should consider it. (sorry for adding \nthis feature into this bug, but I wanted to raise it while I thought of it).\n\ncheers,\n\nPaul Smith", "id": 59069, "attachment_id": null, "creator": "psmith@apache.org", "creation_time": "2004-06-10T22:05:00Z", "time": "2004-06-10T22:05:00Z", "is_private": false}, {"count": 18, "tags": [], "bug_id": 16229, "attachment_id": null, "id": 59090, "time": "2004-06-11T10:36:11Z", "creator": "ceki@apache.org", "creation_time": "2004-06-11T10:36:11Z", "is_private": false, "text": "\n> Linus/Ceki, \n> \n> I would suggest using the java.text.MessageFormat class (I think this is JDK1.\n> 2+, it's been around a while any way).  Then you could do something like this:\n> \n> \n> logger.debug(\"Happy birthday {1}. Your age of {0} is respectable.\", new Object\n[]\n> age, name});\n> \n> This has a number of advantages:\n> \n> 1. It would require no change to the Logger class, nice to minimise this \n> signature change because of downstream compatibility issues \n\n? I am consused here. There is no method with signature \n  \n  Logger.debug(Object, Object) \n\nwhich existing Logger method are you referring to?\n\n> 2. This format allows the parameter order to be independanty of the order in \n> which they are used in the string pattern (note that item 0 is placed last in \nmy \n> example).\n\nI don't think allowing free parameter ordering as\njava.text.MessageFormat does makes the API easier to use, on the\ncontrary.\n\nWe can expect the user to provide the arguments in the correct\norder. That is really not too much to ask for. Moreover, if the\ndeveloper is as inattentive as to mix the order of arguments, the same\ndeveloper will also fail to correctly label/number the various anchor\nstrings, e.g. {4}.\n\nThe only advantage in labeled anchors is the ability to repeat the\nsame argument multiple times.\n\nYou can write\n\n  l.debug(\"Hello {0}. The time is {1}. BTW, {0} is a nice name.\", name, time);\n\nbut how often does that happen? \n\n> 3. It allows for an open-ended # arguments without having to \"wait\" for \nJDK1.5.\n> \n> Since an array is an Object, the above would just require a change in the \n> appending method to check if the Object is an array, and if so, use the \n> MessageFormat class.  An Arrays .toString() method is pretty useless, so we \n> could just perform this message parsing.  \n\nInteresting observation. We must also consider the fact that calling\nnew Object[] creates an object array (which as you observed is still\nan object). For a *disabled* log statement,\n\n l.debug(new Object{\"Hello {}.\", \"Paul\"});\n\nwill be significantly slower than:\n\n l.debug(\"Hello {}.\", \"Paul\");\n\nTaking an object array as a parameter would allow us to handle an\nunlimited number of parameters. How often do you need to print mopre\nthan two variable values in a message?\n\nIf you need 3 or more variables, you can always write:\n\n  if(l.isDebugEnabled()) {\n   l.debug(\"The lucky numbers are \"+n1+\", \"+n2+\", and \"+n3+\".\");\n  }\n\nDespite all the above I am still interested on your comments on the\nmatter. Could we continue this discussion on log4j-dev@ please?\n\n\n> If we were to do this, perhaps it is a good chance to do another convenience \n> class check of the Object and check if it's a Throwable, and get the \nStacktrace \n> of the Throwable rather than just the .toString().  e.g:\n> \n> }catch(Exception e){\n>   LOG.error(e);\n> }\n> \n> This is SUCH a common mistake by a developer (even experienced log4j'ers), \nand \n> probably an 'assumed' function, that we should consider it. (sorry for adding \n> this feature into this bug, but I wanted to raise it while I thought of it).\n\nThis is a different matter. \n \n"}, {"count": 19, "tags": [], "bug_id": 16229, "attachment_id": null, "id": 68346, "time": "2004-12-13T15:51:27Z", "creator": "yoavs@computer.org", "creation_time": "2004-12-13T15:51:27Z", "is_private": false, "text": "There are a lot of alternatives here.  Using isDebugEnabled is indeed more \nclutter, but that's a price to pay for higher performance.  Log4j 1.3 also \nprovides parameterized logging with a couple of Objects, i.e. debug(message), \ndebug(message, obj1), debug(message, obj1, obj2), but not more than that: more \nthan that would be bloat.  When log4j 1.5 moves to J2SE 5.0, maybe varargs can \nbe used.  Until then, you can use varargs on your end if you want."}, {"count": 20, "tags": [], "bug_id": 16229, "attachment_id": null, "id": 69864, "time": "2005-01-20T14:40:43Z", "creator": "ceki@apache.org", "creation_time": "2005-01-20T14:40:43Z", "is_private": false, "text": "\nLog4j 1.3alpha implements parametrized messages.\n\nPlease see http://logging.apache.org/log4j/docs/faq.html#2.3 and in particular the \nsub-section entitled \"Better alternative based on message patterns\".\n\nUGLI also supports parametrized messages. Please see http://logging.apache.org/\nlog4j/docs/ugli.html "}]