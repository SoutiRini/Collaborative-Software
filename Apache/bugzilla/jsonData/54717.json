[{"count": 0, "tags": [], "bug_id": 54717, "attachment_id": null, "is_private": false, "id": 165954, "time": "2013-03-18T10:59:01Z", "creator": "dlade@web.de", "creation_time": "2013-03-18T10:59:01Z", "text": "Because the BatchSampleSender/StatisticalSampleSender synchronizes the whole sampleOccurred() method it blocks the threads of each thread group. \n\nThe differences of the generate load can be seen using the DiskStoreSampleSender. In our case it was a factor of 3 faster. But this one could not be used striped therefore the request body is stored and will be send at the end (in our case several GB of data).\n\nAlthough the AsynchSampleSender blocks several times on queue.offer() if the traffic could not be send fast enough to the client - which might also be a problem of sending the big request body too.\n\nI suggest to decouple all sample senders from working threads, using a rather simple idea:\nStore the (stripped) sample in a ConcurrentHashMap grouped by the current thread name and send it by one (ore more) worker thread(s) to the client.\n\nThere is no need to block the load generating threads doing their job."}, {"count": 1, "tags": [], "creator": "dlade@web.de", "text": "Created attachment 30065\nexample code for a totally decoupled statistical sample sender", "id": 165955, "time": "2013-03-18T11:14:24Z", "bug_id": 54717, "creation_time": "2013-03-18T11:14:24Z", "is_private": false, "attachment_id": 30065}, {"count": 2, "tags": [], "creator": "p.mouawad@ubik-ingenierie.com", "attachment_id": 30724, "id": 169378, "time": "2013-08-12T21:17:59Z", "bug_id": 54717, "creation_time": "2013-08-12T21:17:59Z", "is_private": false, "text": "Created attachment 30724\nPatch to send SampleEvents outside of synchronized block"}, {"count": 3, "tags": [], "bug_id": 54717, "text": "Hello,\nCould you give the attached patch a try ?\nIt does not yet do what you propose but it should improve the blocking time.\n\nThanks", "id": 169379, "attachment_id": null, "creator": "p.mouawad@ubik-ingenierie.com", "creation_time": "2013-08-12T21:18:51Z", "time": "2013-08-12T21:18:51Z", "is_private": false}, {"count": 4, "tags": [], "creator": "p.mouawad@ubik-ingenierie.com", "text": "we could also create a StrippedAsyncBatchMode\n\nFinally I think the Disruptor Framework would be a good answer for the async sample sender.", "id": 169380, "time": "2013-08-12T21:30:26Z", "bug_id": 54717, "creation_time": "2013-08-12T21:30:26Z", "is_private": false, "attachment_id": null}, {"count": 5, "tags": [], "text": "(In reply to Philippe Mouawad from comment #3)\n> It does not yet do what you propose but it should improve the blocking time.\n\nThe sampleStore needs to be synchronised for both the clone() and clear() methods otherwise a sample can be added between the clone() and the clear(). Or possibly the store can be updated during the clone(). In either case, samples can be lost if the code is not synchronised.\n\nThat's partly why the existing code is synchronised - to make sure samples are not lost.", "attachment_id": null, "id": 169383, "creator": "sebb@apache.org", "time": "2013-08-12T22:53:26Z", "bug_id": 54717, "creation_time": "2013-08-12T22:53:26Z", "is_private": false}, {"count": 6, "tags": [], "bug_id": 54717, "attachment_id": null, "is_private": false, "id": 169384, "time": "2013-08-12T22:56:20Z", "creator": "sebb@apache.org", "creation_time": "2013-08-12T22:56:20Z", "text": "(In reply to Sebb from comment #5)\n> (In reply to Philippe Mouawad from comment #3)\n> > It does not yet do what you propose but it should improve the blocking time.\n> \n> The sampleStore needs to be synchronised for both the clone() and clear()\n> methods otherwise a sample can be added between the clone() and the clear().\n> Or possibly the store can be updated during the clone(). In either case,\n> samples can be lost if the code is not synchronised.\n> \n> That's partly why the existing code is synchronised - to make sure samples\n> are not lost.\n\nSorry, I see now that the code is still synchronised - the idea of the clone() is presumably to decouple the sending from the extracting of the samples."}, {"count": 7, "tags": [], "bug_id": 54717, "attachment_id": 30729, "is_private": false, "id": 169422, "time": "2013-08-14T06:33:33Z", "creator": "dlade@web.de", "creation_time": "2013-08-14T06:33:33Z", "text": "Created attachment 30729\nexample code for a totally decoupled statistical sample sender"}, {"count": 8, "tags": [], "creator": "dlade@web.de", "is_private": false, "id": 169423, "creation_time": "2013-08-14T06:41:13Z", "time": "2013-08-14T06:41:13Z", "bug_id": 54717, "text": "I've uploaded a new version of our implementation, because we've made several bugfixes. Now it works fine and completely without synchronization at all.\n\nIn my opinion it will be much harder to find a solution for batched samplers, but for hold samplers this solution seems to be the best.\n\nnote: \nIgnore the \"marker\"-stuff in the code. We're using it to measure different phases of the load test.", "attachment_id": null}, {"count": 9, "tags": [], "bug_id": 54717, "is_private": false, "id": 169424, "attachment_id": null, "creator": "dlade@web.de", "creation_time": "2013-08-14T07:05:52Z", "time": "2013-08-14T07:05:52Z", "text": "About your patch:\nIt still synchronizes the sample store and this is the most time consuming operation. \n\nIMHO this is not necessary to synchronize the sample store if you're using an own  store for each thread (see my attachment). \nThe only catch is, that testEnded() runs in the main thread. This is why I use the queue of maps to store all maps of the threads on one central point. But the queue is only accessed two times 1) at the initializing for each thread (see statisticalMapSelector) and 2) at the testEnded() method.\n\nThis is why I don't need to synchronize or lock at all."}, {"count": 10, "tags": [], "bug_id": 54717, "is_private": false, "id": 169426, "attachment_id": null, "creator": "sebb@apache.org", "creation_time": "2013-08-14T07:23:36Z", "time": "2013-08-14T07:23:36Z", "text": "(In reply to Danny Lade from comment #9)\n> \n> IMHO this is not necessary to synchronize the sample store if you're using\n> an own  store for each thread (see my attachment). \n\nOnly true if there is no access from other threads.\n\n> The only catch is, that testEnded() runs in the main thread. This is why I\n> use the queue of maps to store all maps of the threads on one central point.\n> But the queue is only accessed two times 1) at the initializing for each\n> thread (see statisticalMapSelector) and 2) at the testEnded() method.\n> \n> This is why I don't need to synchronize or lock at all.\n\nSynchronisation is not only needed to guarantee single-threaded access to critical points in the code. It is also needed to ensure safe publication across threads. The Java memory model allows threads cache values locally; threads only have to update/fetch main memory at a memory synch. point. If one thread updates a field, another thread may not see the new value unless both the threads synch. on the same lock (volatile can also be used in some cases)."}, {"count": 11, "tags": [], "bug_id": 54717, "text": "That's all true and well known, but where is the connection to the SampleSender?\n\nEach Thread (which produces load) can store and send the sample data by it's own using the SampleSender. The only catch is the end of the tests where the main thread calls testEnded() method. \nWhen does one thread need access to the sample data of another thread, especially inside the SampleSender???\n\nThere might be several scenarios where one thread need access to the sample events of another thread. But IMO this is bad practise for a high load test because one would provoke synchronization/blocking.\n(we never use these technics, each thread has it's own data, nothing shared)\n\nHowever, if the data is already given to the SampleSender, to send it to the jmeter (remote) client, no thread needs to share the data stored INSIDE the SampleSender (fire and forget).\n\nAs I already mentioned, the solution we've made works quite well in our high load scenarios - believe me.", "id": 169427, "time": "2013-08-14T08:14:20Z", "creator": "dlade@web.de", "creation_time": "2013-08-14T08:14:20Z", "is_private": false, "attachment_id": null}, {"count": 12, "tags": [], "text": "(In reply to Danny Lade from comment #11)\n> That's all true and well known, but where is the connection to the\n> SampleSender?\n\nIn comment #9 you wrote:\n\n> But the queue is only accessed two times 1) at the initializing for each\n> thread (see statisticalMapSelector) and 2) at the testEnded() method.\n \nOne thread initialises the queue, another processes it.\n\n> As I already mentioned, the solution we've made works quite well in our high\n> load scenarios - believe me.\n\nUnfortunately that does not prove anything.", "attachment_id": null, "id": 169428, "creator": "sebb@apache.org", "time": "2013-08-14T09:08:15Z", "bug_id": 54717, "creation_time": "2013-08-14T09:08:15Z", "is_private": false}, {"count": 13, "tags": [], "creator": "dlade@web.de", "is_private": false, "text": "> In comment #9 you wrote:\n> \n> > But the queue is only accessed two times 1) at the initializing for each\n> > thread (see statisticalMapSelector) and 2) at the testEnded() method.\n>  \n> One thread initialises the queue, another processes it.\n> \nNo, the same thread does this. \n\nMain: create SampleSender, therefore create queue\nMain: start threads\nThread 1: append map to queue\nThread 1: add sample data to own map\n...\nThread N: append map to queue\nThread 1: add sample data to own map\n...\nThread N: add sample data to own map\nMain: all threads ended\nMain: call testEnded(), therefore read queue and send sample data\n\n> > As I already mentioned, the solution we've made works quite well in our high\n> > load scenarios - believe me.\n> \n> Unfortunately that does not prove anything.\n>\nNo it doesn't, but it also sounds like 'Don't trust anyone' to me. \n\nSo, how to prove? What do you have in mind?", "id": 169431, "time": "2013-08-14T10:14:52Z", "bug_id": 54717, "creation_time": "2013-08-14T10:14:52Z", "attachment_id": null}, {"count": 14, "tags": [], "bug_id": 54717, "is_private": false, "id": 169433, "attachment_id": null, "creator": "sebb@apache.org", "creation_time": "2013-08-14T10:50:58Z", "time": "2013-08-14T10:50:58Z", "text": "(In reply to Danny Lade from comment #13)\n> > In comment #9 you wrote:\n> > \n> > > But the queue is only accessed two times 1) at the initializing for each\n> > > thread (see statisticalMapSelector) and 2) at the testEnded() method.\n> >  \n> > One thread initialises the queue, another processes it.\n> > \n> No, the same thread does this. \n> \n> Main: create SampleSender, therefore create queue\n> Main: start threads\n> Thread 1: append map to queue\n\nThe queue entry is set up (i.e. initialised) by a different thread.\n\nAlso Thread 1 adds items to the queue, which are later accessed by a different thread in testEnded(). This also needs to be done in a way that ensures safe publication, e.g. by using a thread-safe queue (which seems to be the case).\n\n> Thread 1: add sample data to own map\n> ...\n> Thread N: append map to queue\n> Thread 1: add sample data to own map\n> ...\n> Thread N: add sample data to own map\n> Main: all threads ended\n> Main: call testEnded(), therefore read queue and send sample data\n> \n> > > As I already mentioned, the solution we've made works quite well in our high\n> > > load scenarios - believe me.\n> > \n> > Unfortunately that does not prove anything.\n> >\n> No it doesn't, but it also sounds like 'Don't trust anyone' to me. \n\nI'm just saying it proves nothing.\n\n> So, how to prove? What do you have in mind?\n\nCode inspection should be used to show that objects shared between threads are protected by a common lock."}, {"count": 15, "tags": [], "bug_id": 54717, "is_private": false, "id": 169434, "creation_time": "2013-08-14T11:28:58Z", "time": "2013-08-14T11:28:58Z", "creator": "dlade@web.de", "text": "> > Main: create SampleSender, therefore create queue\n> > Main: start threads\n> > Thread 1: append map to queue\n> \n> The queue entry is set up (i.e. initialised) by a different thread.\n> \n> Also Thread 1 adds items to the queue, which are later accessed by a\n> different thread in testEnded(). This also needs to be done in a way that\n> ensures safe publication, e.g. by using a thread-safe queue (which seems to\n> be the case).\n> \nI see, yes it is a ConcurrentLinkedQueue.\n\n> > So, how to prove? What do you have in mind?\n> \n> Code inspection should be used to show that objects shared between threads\n> are protected by a common lock.\n\nAs you already found out the lock is only necessary at the beginning (init). Feel free to inspect the ConcurrentLinkedQueue (java.util.concurrent) about it.\n\nHowever, this code works only for a HoldSampleSender, which sends all data at the end at once. \nI was also thinking about a BatchSampleSender using the same principles in the past. But my project does not needed one, therefore I got no time to implement it.", "attachment_id": null}, {"count": 16, "tags": [], "bug_id": 54717, "attachment_id": null, "text": "Looking at your code, I think it is fine regarding multi-threading.\nThere is something misleading in the comments of this Bugzilla as you spoke about BatchSampleSender at first.\n\nThanks for the patch, although not in expected format and with too many dependencies that could be avoided.", "id": 169481, "time": "2013-08-15T22:34:35Z", "creator": "p.mouawad@ubik-ingenierie.com", "creation_time": "2013-08-15T22:34:35Z", "is_private": false}, {"count": 17, "tags": [], "bug_id": 54717, "text": "(In reply to Philippe Mouawad from comment #16)\n> Looking at your code, I think it is fine regarding multi-threading.\n> There is something misleading in the comments of this Bugzilla as you spoke\n> about BatchSampleSender at first.\n> \nThe BatchSampleSender has exactly the same problem like all samplers which are synchronizing in sampleOccurred() method. We just wrote the  StatisticalHoldSampleSender because it is much easier to implement.\n\n> Thanks for the patch, although not in expected format and with too many\n> dependencies that could be avoided.\n\nSorry for that, but we just use the implementation above as it is by patching the jmeter.properties for \"mode=net.bigpoint.jmeter.samplers.StatisticalHoldSampleSender\". It should have been just an example how one may solve the problem described first.", "id": 169492, "attachment_id": null, "creator": "dlade@web.de", "creation_time": "2013-08-16T07:52:43Z", "time": "2013-08-16T07:52:43Z", "is_private": false}]