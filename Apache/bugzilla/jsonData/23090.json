[{"count": 0, "attachment_id": null, "creator": "gthb@dimon.is", "is_private": false, "id": 44011, "time": "2003-09-11T00:50:05Z", "bug_id": 23090, "creation_time": "2003-09-11T00:50:05Z", "tags": [], "text": "When a FileSet is cloned, using the copy constructor or the clone() method\n(which calls the copy constructor internally anyway), the mutable-object\nmembers of AbstractFileSet are copied to the new instance by reference, not\nby cloning. These are:\n\n    private PatternSet defaultPatterns = new PatternSet();\n    private Vector additionalPatterns = new Vector();\n    private Vector selectors = new Vector();\n\nand they are modified through their mutator methods (setExcludes, append,\netc.) by the AbstractFileSet class.\n\nThis means the cloned FileSet will be coupled to the original one: changes\nmade to the original FileSet *after* cloning will be reflected in the new\nFileSet. Worse: only *some* changes to the original FileSet affect the clone.\nThe primitive-type members are not shared, of course, so these methods:\n\n    setDefaultexcludes\n    setCaseSensitive\n    setFollowSymlinks\n\ndo not affect the cloned object when called on the original object after\ncloning. Also setDir won't affect things, since the dir member is replaced\nby setDir, not modified (File is immutable anyway). But adding excludes or\nincludes to the original fileset certainly affects the cloned fileset, and\nvice versa.\n\nThis makes it unnecessarily hard for a custom task developer to do useful\nthings like allowing the task user to specify one fileset for copying and\nthen a pattern that specifies which files should have filters applied to\nthem and which should not. I was trying to do this in a custom task by\ninvoking two successive copy tasks, first cloning the fileset and adding the\n\"nofilter\" as an exclusion pattern with setExcludes on the clone, and then\ncloning the original fileset again and adding the same \"nofilter\" pattern\nas an inclusion pattern with setIncludes on the new clone. This doesn't\nwork, because the filesets all share the same pattern sets: the inclusion\npattern I tried to add was already an exclusion pattern in the new cloned\nfileset, so the inclusion pattern is overriden.\n\nThis is not easy to work around without modifying Ant code itself. The\nfields are private in AbstractFileSet -- which makes sense I guess, but\namplifies the need for a fix to this.\n\nI can't know for sure, but I doubt that anyone is actually depending on\nthis behavior in their tasks! I sure hope not :) ... but if so, then this\ncould at least be worked around e.g. with a deepClone() method. If the\ncopy constructor and clone method are not fixed, then a warning should\nbe added to their javadocs pointing out that the resulting clone may have\na few surprises in store for the unwary developer :)"}, {"count": 1, "attachment_id": null, "creator": "bodewig@apache.org", "is_private": false, "id": 44048, "time": "2003-09-11T15:45:20Z", "bug_id": 23090, "creation_time": "2003-09-11T15:45:20Z", "tags": [], "text": "clone() has been rationalized (i.e. it doesn't invoke the copy constructor any\nlonger) but still creates a shallow copy.\n\nI'm not sure whether we should add a deepClone or can simply make clone create\na deep copy - I'll look into it before making any changes."}, {"count": 2, "attachment_id": null, "creator": "gthb@dimon.is", "is_private": false, "id": 44063, "time": "2003-09-11T19:22:36Z", "bug_id": 23090, "creation_time": "2003-09-11T19:22:36Z", "tags": [], "text": "For reference, here's a snippet from the Object.clone() \"contract\" (javadoc):\n\n    By convention, the object returned by this method should be independent\n    of this object (which is being cloned). To achieve this independence, it\n    may be necessary to modify one or more fields of the object returned by\n    super.clone before returning it. Typically, this means copying any mutable\n    objects that comprise the internal \"deep structure\" of the object being\n    cloned and replacing the references to these objects with references to\n    the copies.\n\nIt's your call of course -- these specifications are marked \"by convention\" --\nbut this does seem to lean strongly towards changing the clone() method (and\nperhaps introducing a shallowClone() method, if somebody actually wants that)\nrather than leaving clone() unchanged and introducing deepClone(). I can't\nthink of a compelling use case for a FileSet clone() implementation that\nleaves the clone and original fileset coupled.\n"}, {"count": 3, "tags": [], "bug_id": 23090, "is_private": false, "text": "I couldn't find a good reason for a shallow clone either, and in fact all our\ntests passed after I changed it, we'll see what Gump says.\n\nIt turned out to be slightly more work as PatternSets are mutable and I had\nto make them Clonable (good idea anyway) and explicitly clone the PatternSets\nthat make up the additionalPatterns Vector as the instances wouldn't have been\nindependent otherwise.  Same would go for selectors, but I couldn't easily\ndecide which selectors should be clonable (and which not, if any), so I stopped\nwith the pattern sets.\n\nThis means that if anybody modifies a selector already present in the original,\nthe original is going to be modified as well - which I've documented for now.\n\nFixed in nightly build 2003-09-18.\n\n", "id": 44261, "time": "2003-09-17T09:23:28Z", "creator": "bodewig@apache.org", "creation_time": "2003-09-17T09:23:28Z", "attachment_id": null}]