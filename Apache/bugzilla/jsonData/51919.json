[{"count": 0, "tags": [], "creator": "p.mouawad@ubik-ingenierie.com", "is_private": false, "id": 149954, "attachment_id": 27636, "bug_id": 51919, "creation_time": "2011-09-29T20:33:43Z", "time": "2011-09-29T20:33:43Z", "text": "Created attachment 27636\nScenario that reproduces the issue\n\nHello,\nUsing options:\n- HTTPCLient 3.1\n- Retrieve All Embedded Resources from HTML\n- Use Concurrent Pool to 5\n\nI randomly get those 2 exceptions:\n2011/09/29 22:31:16 WARN  - jmeter.protocol.http.sampler.HTTPSamplerBase: Execution issue when fetching embedded resources java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException\n\tat java.util.concurrent.FutureTask$Sync.innerGet(FutureTask.java:222)\n\tat java.util.concurrent.FutureTask.get(FutureTask.java:83)\n\tat org.apache.jmeter.protocol.http.sampler.HTTPSamplerBase.downloadPageResources(HTTPSamplerBase.java:1213)\n\tat org.apache.jmeter.protocol.http.sampler.HTTPSamplerBase.resultProcessing(HTTPSamplerBase.java:1428)\n\tat org.apache.jmeter.protocol.http.sampler.HTTPAbstractImpl.resultProcessing(HTTPAbstractImpl.java:244)\n\tat org.apache.jmeter.protocol.http.sampler.HTTPHC3Impl.sample(HTTPHC3Impl.java:327)\n\tat org.apache.jmeter.protocol.http.sampler.HTTPSamplerProxy.sample(HTTPSamplerProxy.java:62)\n\tat org.apache.jmeter.protocol.http.sampler.HTTPSamplerBase.sample(HTTPSamplerBase.java:1019)\n\tat org.apache.jmeter.protocol.http.sampler.HTTPSamplerBase.sample(HTTPSamplerBase.java:1005)\n\tat org.apache.jmeter.threads.JMeterThread.process_sampler(JMeterThread.java:411)\n\tat org.apache.jmeter.threads.JMeterThread.run(JMeterThread.java:297)\n\tat java.lang.Thread.run(Thread.java:680)\nCaused by: java.util.ConcurrentModificationException\n\tat java.util.AbstractList$Itr.checkForComodification(AbstractList.java:372)\n\tat java.util.AbstractList$Itr.next(AbstractList.java:343)\n\tat org.apache.jmeter.testelement.property.PropertyIteratorImpl.next(PropertyIteratorImpl.java:39)\n\tat org.apache.jmeter.protocol.http.control.CookieManager.removeMatchingCookies(CookieManager.java:466)\n\tat org.apache.jmeter.protocol.http.control.CookieManager.add(CookieManager.java:258)\n\tat org.apache.jmeter.protocol.http.control.CookieManager.addCookieFromHeader(CookieManager.java:430)\n\tat org.apache.jmeter.protocol.http.sampler.HTTPHC3Impl.saveConnectionCookies(HTTPHC3Impl.java:1071)\n\tat org.apache.jmeter.protocol.http.sampler.HTTPHC3Impl.sample(HTTPHC3Impl.java:319)\n\tat org.apache.jmeter.protocol.http.sampler.HTTPSamplerProxy.sample(HTTPSamplerProxy.java:62)\n\tat org.apache.jmeter.protocol.http.sampler.HTTPSamplerBase$ASyncSample.call(HTTPSamplerBase.java:1709)\n\tat org.apache.jmeter.protocol.http.sampler.HTTPSamplerBase$ASyncSample.call(HTTPSamplerBase.java:1)\n\tat java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:138)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)\n\t... 1 more\n\nOr 2011/09/29 21:59:12 WARN  - jmeter.protocol.http.sampler.HTTPSamplerBase: Execution issue when fetching embedded resources java.util.concurrent.ExecutionException: java.util.NoSuchElementException\n\tat java.util.concurrent.FutureTask$Sync.innerGet(FutureTask.java:222)\n\tat java.util.concurrent.FutureTask.get(FutureTask.java:83)\n\tat org.apache.jmeter.protocol.http.sampler.HTTPSamplerBase.downloadPageResources(HTTPSamplerBase.java:1213)\n\tat org.apache.jmeter.protocol.http.sampler.HTTPSamplerBase.resultProcessing(HTTPSamplerBase.java:1428)\n\tat org.apache.jmeter.protocol.http.sampler.HTTPAbstractImpl.resultProcessing(HTTPAbstractImpl.java:244)\n\tat org.apache.jmeter.protocol.http.sampler.HTTPHC3Impl.sample(HTTPHC3Impl.java:327)\n\tat org.apache.jmeter.protocol.http.sampler.HTTPSamplerProxy.sample(HTTPSamplerProxy.java:62)\n\tat org.apache.jmeter.protocol.http.sampler.HTTPSamplerBase.sample(HTTPSamplerBase.java:1019)\n\tat org.apache.jmeter.protocol.http.sampler.HTTPSamplerBase.sample(HTTPSamplerBase.java:1005)\n\tat org.apache.jmeter.threads.JMeterThread.process_sampler(JMeterThread.java:411)\n\tat org.apache.jmeter.threads.JMeterThread.run(JMeterThread.java:297)\n\tat java.lang.Thread.run(Thread.java:680)\nCaused by: java.util.NoSuchElementException\n\tat java.util.AbstractList$Itr.next(AbstractList.java:350)\n\tat org.apache.jmeter.testelement.property.PropertyIteratorImpl.next(PropertyIteratorImpl.java:39)\n\tat org.apache.jmeter.protocol.http.control.CookieManager.removeMatchingCookies(CookieManager.java:466)\n\tat org.apache.jmeter.protocol.http.control.CookieManager.add(CookieManager.java:258)\n\tat org.apache.jmeter.protocol.http.control.CookieManager.addCookieFromHeader(CookieManager.java:430)\n\tat org.apache.jmeter.protocol.http.sampler.HTTPHC3Impl.saveConnectionCookies(HTTPHC3Impl.java:1071)\n\tat org.apache.jmeter.protocol.http.sampler.HTTPHC3Impl.sample(HTTPHC3Impl.java:319)\n\tat org.apache.jmeter.protocol.http.sampler.HTTPSamplerProxy.sample(HTTPSamplerProxy.java:62)\n\tat org.apache.jmeter.protocol.http.sampler.HTTPSamplerBase$ASyncSample.call(HTTPSamplerBase.java:1709)\n\tat org.apache.jmeter.protocol.http.sampler.HTTPSamplerBase$ASyncSample.call(HTTPSamplerBase.java:1)\n\tat java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:138)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)\n\t... 1 more\n\n\nTo reproduce issue set number of threads to > 20 you will have more chance to get it.\nRegards\nPhilippe Mouawad"}, {"count": 1, "tags": [], "bug_id": 51919, "attachment_id": 27643, "id": 149967, "time": "2011-09-30T07:43:39Z", "creator": "p.mouawad@ubik-ingenierie.com", "creation_time": "2011-09-30T07:43:39Z", "is_private": false, "text": "Created attachment 27643\nFix to the issue\n\nHello,\nI synchronized 2 methods of CookieManager that were concerned.\nSince CookieManager is per User thread, there should be performance impact only when concurrent download of embedded resources is on.\nI think it is acceptable, and browser have the same isse I think.\nI first thought about cloning CookieManager but I don't think it's right.\n\nRegards\nPhilippe"}, {"count": 2, "tags": [], "bug_id": 51919, "attachment_id": null, "id": 150003, "time": "2011-10-01T07:34:04Z", "creator": "milamber@apache.org", "creation_time": "2011-10-01T07:34:04Z", "is_private": false, "text": "A better way is to synchronize only the code section referred to the variables from JMeterContext\n(in add() and removeMatchingCookies() methods, I thinks)"}, {"count": 3, "tags": [], "creator": "p.mouawad@ubik-ingenierie.com", "attachment_id": 27654, "is_private": false, "id": 150005, "time": "2011-10-01T09:51:48Z", "bug_id": 51919, "creation_time": "2011-10-01T09:51:48Z", "text": "Created attachment 27654\nFix to issue\n\nHello Milamber,\nI changed my initial patch to use ReentrantLock.\nRegards\nPhilippe"}, {"count": 4, "tags": [], "creator": "sebb@apache.org", "attachment_id": null, "is_private": false, "id": 150006, "time": "2011-10-01T10:28:29Z", "bug_id": 51919, "creation_time": "2011-10-01T10:28:29Z", "text": "Cookies are currently stored in an ArrayList. The Javadoc says:\n\n\"If multiple threads access an ArrayList instance concurrently, and at least one of the threads modifies the list structurally, it must be synchronized externally.\"\n\nThis means that all accesses must be synchronised, not just modifications.\n\nThe simplest way to do this would be to use Collections.synchronizedList.\n\nThere is a concurrent list:\n\nhttp://download.oracle.com/javase/6/docs/api/java/util/concurrent/CopyOnWriteArrayList.html\n\nHowever this is only worth it if there are many more reads than writes.\nI'm not sure that's the case with Cookies.\n\n==\n\nAn alternative might be to somehow defer the cookie setting to the main sample thread. It should not matter if the cookies are stored after all the resources have been read, because the order of responses is not guaranteed. Any cookies required by the resource download must exist before the request is made."}, {"count": 5, "tags": [], "bug_id": 51919, "attachment_id": null, "text": "(In reply to comment #3)\n> Created attachment 27654 [details]\n> Fix to issue\n> \n> Hello Milamber,\n> I changed my initial patch to use ReentrantLock.\n> Regards\n> Philippe\n\nThe CONTEXT_VARIABLES_LOCK needs to be applied to reads as well as writes.\n\nA write lock only protects against lost updates, it does not guarantee thread-safety.", "id": 150007, "time": "2011-10-01T10:35:46Z", "creator": "sebb@apache.org", "creation_time": "2011-10-01T10:35:46Z", "is_private": false}, {"count": 6, "tags": [], "text": "What if I remove CONTEXT_VARIABLES_LOCK and use a ConcurrentHashMap in JMeterVariables?\n\nRegards\nPhilippe", "attachment_id": null, "id": 150008, "creation_time": "2011-10-01T11:04:31Z", "time": "2011-10-01T11:04:31Z", "creator": "p.mouawad@ubik-ingenierie.com", "bug_id": 51919, "is_private": false}, {"count": 7, "tags": [], "text": "(In reply to comment #6)\n> What if I remove CONTEXT_VARIABLES_LOCK and use a ConcurrentHashMap in\n> JMeterVariables?\n\nThat would solve the immediate problem for JMeterVariables.\nIt probably would not have too much of a performance or memory impact.\n\nHowever, that is only one aspect of this issue; JMeter was designed on the basis that samplers etc are cloned for each thread and so don't need to worry about thread-safety issues.", "attachment_id": null, "bug_id": 51919, "id": 150009, "time": "2011-10-01T11:14:16Z", "creator": "sebb@apache.org", "creation_time": "2011-10-01T11:14:16Z", "is_private": false}, {"count": 8, "tags": [], "bug_id": 51919, "attachment_id": null, "id": 150010, "time": "2011-10-01T11:30:39Z", "creator": "p.mouawad@ubik-ingenierie.com", "creation_time": "2011-10-01T11:30:39Z", "is_private": false, "text": "(In reply to comment #4)\n> Cookies are currently stored in an ArrayList. The Javadoc says:\n> \n> \"If multiple threads access an ArrayList instance concurrently, and at least\n> one of the threads modifies the list structurally, it must be synchronized\n> externally.\"\n> \n> This means that all accesses must be synchronised, not just modifications.\n> \n> The simplest way to do this would be to use Collections.synchronizedList.\n> \n> There is a concurrent list:\n> \n> http://download.oracle.com/javase/6/docs/api/java/util/concurrent/CopyOnWriteArrayList.html\n> \n> However this is only worth it if there are many more reads than writes.\n> I'm not sure that's the case with Cookies.\n> \n> ==\n> \n> An alternative might be to somehow defer the cookie setting to the main sample\n> thread. It should not matter if the cookies are stored after all the resources\n> have been read, because the order of responses is not guaranteed. Any cookies\n> required by the resource download must exist before the request is made.\n\nHello Sebb,\nI knwo about this rule regarding the need to synchronize all methods.\nBut sometimes it is acceptable to only synchronize methods that modify, the\ntrade-off will be that:\n- You can get obsolete informations (size, element removed)\n- But collection state will stay OK.\nThat's the approach I chose.\n\nI used it a lot of times and I am sure it works on ArrayList. It can have issues with LinkerList but not arrayList.\n\nI think Collections.synchronizedList() can have performance impact, I am not\nsure I understand what you want to do, you want to modify CollectionProperty to\nuse a Collections.synchronizedList() wrapper ?\n\nRegards\nPhilippe"}, {"count": 9, "tags": [], "creator": "sebb@apache.org", "text": "(In reply to comment #8)\n> (In reply to comment #4)\n> > Cookies are currently stored in an ArrayList. The Javadoc says:\n> > \n> > \"If multiple threads access an ArrayList instance concurrently, and at least\n> > one of the threads modifies the list structurally, it must be synchronized\n> > externally.\"\n> > \n> > This means that all accesses must be synchronised, not just modifications.\n> > \n> > The simplest way to do this would be to use Collections.synchronizedList.\n> > \n> > There is a concurrent list:\n> > \n> > http://download.oracle.com/javase/6/docs/api/java/util/concurrent/CopyOnWriteArrayList.html\n> > \n> > However this is only worth it if there are many more reads than writes.\n> > I'm not sure that's the case with Cookies.\n> > \n> > ==\n> > \n> > An alternative might be to somehow defer the cookie setting to the main sample\n> > thread. It should not matter if the cookies are stored after all the resources\n> > have been read, because the order of responses is not guaranteed. Any cookies\n> > required by the resource download must exist before the request is made.\n> \n> Hello Sebb,\n> I knwo about this rule regarding the need to synchronize all methods.\n> But sometimes it is acceptable to only synchronize methods that modify, the\n> trade-off will be that:\n> - You can get obsolete informations (size, element removed)\n> - But collection state will stay OK.\n\nA thread that reads the collection can still experience ConcurrentModificationException if it does not use synch.\n\n> That's the approach I chose.\n> \n> I used it a lot of times and I am sure it works on ArrayList. It can have\n> issues with LinkerList but not arrayList.\n\nI think you have been lucky.\n\n> I think Collections.synchronizedList() can have performance impact, I am not\n> sure I understand what you want to do, you want to modify CollectionProperty to\n> use a Collections.synchronizedList() wrapper ?\n\nI know it has an impact; that's why we should not rush into partial fixes.\n\nBut I intended it only for the Cookie ArrayList.", "id": 150011, "attachment_id": null, "bug_id": 51919, "creation_time": "2011-10-01T11:44:23Z", "time": "2011-10-01T11:44:23Z", "is_private": false}, {"count": 10, "tags": [], "creator": "p.mouawad@ubik-ingenierie.com", "text": "Created attachment 27656\nExample of ConcurrentModificationException with Collections.synchronizedCollection\n\nHello Sebb,\nJust to clarify what I think.\nIn my opinion wrapping the List with Collections.synchronizedList doesn't protect from ConcurrentModificationException when iterator are used, see attached example.\n\nSo Locking is necessary when Iterations are done.\n\nThis is just to say that I think my fix with ReentrantLock + ConcurrentHashMap in JMEterVariables should fix the issue in immediate although I agree a better long term solution is to be found.\n\nAt present, using concurrent download in a test is broken.\n\nPS: And trust me I was not lucky regarding what I did on syncing in the past :-). Fixes concerned high concurrent systems like ecommerce websites.\nRegards\nPhilippe", "id": 150014, "attachment_id": 27656, "bug_id": 51919, "creation_time": "2011-10-01T12:51:27Z", "time": "2011-10-01T12:51:27Z", "is_private": false}, {"count": 11, "tags": [], "bug_id": 51919, "text": "Created attachment 27657\nFix to issue\n\nFix that uses ConcurrentReaderHashmap.\nRegards\nPhilippe Mouawad", "id": 150018, "time": "2011-10-01T14:09:24Z", "creator": "p.mouawad@ubik-ingenierie.com", "creation_time": "2011-10-01T14:09:24Z", "is_private": false, "attachment_id": 27657}, {"count": 12, "tags": [], "text": "Another way to solve this would be to process any cookies on return from the asynch. task.\n\nThis would mean changing the task to return a different class that included the cookies. If the cookie array list were cloned for each thread, any differences could be merged back on return.", "attachment_id": null, "id": 150161, "creation_time": "2011-10-04T23:54:18Z", "time": "2011-10-04T23:54:18Z", "creator": "sebb@apache.org", "bug_id": 51919, "is_private": false}, {"count": 13, "tags": [], "creator": "p.mouawad@ubik-ingenierie.com", "attachment_id": 27716, "is_private": false, "id": 150289, "time": "2011-10-07T08:46:36Z", "bug_id": 51919, "creation_time": "2011-10-07T08:46:36Z", "text": "Created attachment 27716\nProposition with CookieManager in ThreadLocal\n\nA discussed on dev list, the prototype."}, {"count": 14, "tags": [], "bug_id": 51919, "attachment_id": null, "text": "Date: Sun Oct 23 17:38:38 2011\nNew Revision: 1187939\n\nURL: http://svn.apache.org/viewvc?rev=1187939&view=rev\nLog:\nBug 51919 - Random ConcurrentModificationException or NoSuchElementException in CookieManager#removeMatchingCookies when using Concurrent Download\n\nFix proposition:\n- Clone Sampler\n- Clone CookieManager for each AsyncSampler\n- Implement custom thread factory to add thread end notification that will call threadFinished on cloned sampler\n\n we can revert if you don't agree\n\nModified:\n   jakarta/jmeter/trunk/src/protocol/http/org/apache/jmeter/protocol/http/sampler/HTTPSamplerBase.java\n   jakarta/jmeter/trunk/xdocs/changes.xml", "id": 150845, "time": "2011-10-23T17:37:26Z", "creator": "p.mouawad@ubik-ingenierie.com", "creation_time": "2011-10-23T17:37:26Z", "is_private": false}]