[{"count": 0, "attachment_id": null, "bug_id": 47405, "text": "The methods RowRecordsAggregate.getStartRowNumberForBlock / getEndRowNumberForBlock iterate over the rows for every block in the sheet.\nAn increasing row number increases the time for serialization enormously.\nThe following code improvement decreases the time for serialization of a workbook with 1 sheet, 25 columns and 30000 rows from 7.5 seconds down to 1.6 seconds on my test environment.\n\n    private List _rowRecordsList = null;\n    \n    /** Returns the physical row number of the first row in a block*/\n    private int getStartRowNumberForBlock(int block) {\n      //Given that we basically iterate through the rows in order,\n      // TODO - For a performance improvement, it would be better to return an instance of\n      //an iterator and use that instance throughout, rather than recreating one and\n      //having to move it to the right position.\n        \n      if (_rowRecordsList==null) {\n          // build up block-based list of row records\n          _rowRecordsList = new ArrayList(_rowRecords.values());\n      }\n      int startIndex = block * DBCellRecord.BLOCK_SIZE;\n      RowRecord row = null;\n      if (startIndex < _rowRecordsList.size()) {\n          row = (RowRecord) _rowRecordsList.get(startIndex);\n      }\n      /*\n      Iterator rowIter = _rowRecords.values().iterator();\n      //Position the iterator at the start of the block\n      for (int i=0; i<=startIndex;i++) {\n        row = (RowRecord)rowIter.next();\n      }\n      */\n      if (row == null) {\n          throw new RuntimeException(\"Did not find start row for block \" + block);\n      }\n\n      \n      return row.getRowNumber();\n    }\n\n    /** Returns the physical row number of the end row in a block*/\n    private int getEndRowNumberForBlock(int block) {\n        if (_rowRecordsList==null) {\n            // build up block-based list of row records\n            _rowRecordsList = new ArrayList(_rowRecords.values());\n        }\n\n      int endIndex = ((block + 1)*DBCellRecord.BLOCK_SIZE)-1;\n      if (endIndex >= _rowRecords.size())\n        endIndex = _rowRecords.size()-1;\n\n      RowRecord row = null;\n      if (endIndex < _rowRecordsList.size()) {\n          row = (RowRecord) _rowRecordsList.get(endIndex);\n      }\n      /*\n      Iterator rowIter = _rowRecords.values().iterator();\n      for (int i=0; i<=endIndex;i++) {\n        row = (RowRecord)rowIter.next();\n      }\n      */\n      if (row == null) {\n          throw new RuntimeException(\"Did not find start row for block \" + block);\n      }\n      return row.getRowNumber();", "id": 128163, "time": "2009-06-23T00:33:40Z", "creator": "alex2@wienerkaffeehaus.de", "creation_time": "2009-06-23T00:33:40Z", "tags": [], "is_private": false}, {"count": 1, "tags": [], "bug_id": 47405, "attachment_id": 26362, "id": 142244, "time": "2010-12-01T08:04:01Z", "creator": "perle@lysator.liu.se", "creation_time": "2010-12-01T08:04:01Z", "is_private": false, "text": "Created attachment 26362\nA patch to speed up serialization\n\nI have also had this very problem with the Poi trunk. I used Alexander's approach and that produces a great speedup. It is still worse than O(N) but it's a lot better than the original version (3.5 to .8 seconds). Serializing Excel ought to be O(N) where N is the total number of rows, but I'll admit I know nothing about the Excel file format.\n\nI have attached a patch against Poi 3.7 that implements Alexander's approach. In addition to his version I discard the values list when the map is modified."}, {"count": 2, "tags": [], "bug_id": 47405, "attachment_id": null, "text": "Can you upload a file that we can use for a performance benchmark? I understand the intention to speed up serialization, but without a benchmark it is hard to tell how much we will get from this patch. \n\nRegards,\nYegor", "id": 142250, "time": "2010-12-01T08:57:53Z", "creator": "yegor@dinom.ru", "creation_time": "2010-12-01T08:57:53Z", "is_private": false}, {"count": 3, "tags": [], "bug_id": 47405, "attachment_id": null, "text": "I'll get the test case we used when I get to work tomorrow. But really, any kind of speadsheet with many row (>30000) would probably illustrate this problem. Rows/s being serialized drops rather sharply (like 1/n^2) as the number of row increases. Our worst case, as our application is today, is 10 sheets with about 40000 rows each.\n\nExcel might not be the best format for this, but our clients want to use Excel. We use POI for other files we produce and it would be great if we could produce all files the same way.", "id": 142263, "time": "2010-12-01T14:34:44Z", "creator": "perle@lysator.liu.se", "creation_time": "2010-12-01T14:34:44Z", "is_private": false}, {"count": 4, "tags": [], "creator": "yegor@dinom.ru", "text": "Applied in r1043517\n\nRegards,\nYegor", "id": 142492, "time": "2010-12-08T11:53:54Z", "bug_id": 47405, "creation_time": "2010-12-08T11:53:54Z", "is_private": false, "attachment_id": null}, {"count": 5, "tags": [], "bug_id": 47405, "attachment_id": null, "text": "I really appreciate it. Now we won't have to maintain this patch in our own tree. Thanks!", "id": 142659, "time": "2010-12-13T15:01:04Z", "creator": "perle@lysator.liu.se", "creation_time": "2010-12-13T15:01:04Z", "is_private": false}]