[{"count": 0, "tags": [], "text": "Background/Expected Behavior:\nOur application is a RESTful web service, we return error responses with status code 400 in situations, like for example when a POST to access a request token contains a valid username but invalid password.  In such cases we return a specific error message, and we would not like to have the TCP connection closed (SSL Handshake is very expensive).  In these cases, if we add the header \"Connection: keep-alive\" to our outgoing response the assumption is that it will be honored by the container.  This does not appear to be the case.  \n\nActual Behavior:\nIn the above situation, what actually happens is that two Connection headers are added to the response.  The first, with a value of \"keep-alive\" from my exception handler in the application, and the second, with a value of \"close\" added by the container.\n\nAnalysis:\nLooking into the tomcat code, specifically, We can see the following:\n--Begin code snippet from AbstractHttp11Processor (lines: 1513-1524)--\n        // If we know that the request is bad this early, add the\n        // Connection: close header.\n        keepAlive = keepAlive && !statusDropsConnection(statusCode);\n        if (!keepAlive) {\n            // Avoid adding the close header twice\n            if (!connectionClosePresent) {\n                headers.addValue(Constants.CONNECTION).setString(\n                        Constants.CLOSE);\n            }\n        } else if (!http11 && !error) {\n            headers.addValue(Constants.CONNECTION).setString(Constants.KEEPALIVE);\n        }\n--End code snippet--\n\nThe value for connectionClosePresent comes from the following:\n--Begin code snippet from AbstractHttp11Processor (lines: 1546-1552)--\n    private boolean isConnectionClose(MimeHeaders headers) {\n        MessageBytes connection = headers.getValue(Constants.CONNECTION);\n        if (connection == null) {\n            return false;\n        }\n        return connection.equals(Constants.CLOSE);\n    }\n--End code snippet--\n\nThis code only checks for a \"Connection: close\" header, not for the presence of a Connection header already.  Should the code from line 1518 ('if (!connectionClosePresent)') not also check for the presence of a Connection header to avoid adding multiple conflicting entries, not just duplicate entries?\n\nThanks in advance!", "attachment_id": null, "id": 175396, "creator": "lee.brett@gmail.com", "time": "2014-05-22T18:48:20Z", "bug_id": 56555, "creation_time": "2014-05-22T18:48:20Z", "is_private": false}, {"count": 1, "tags": [], "creator": "markt@apache.org", "text": "(In reply to Brett from comment #0)\n> Should the code from line 1518 ('if\n> (!connectionClosePresent)') not also check for the presence of a Connection\n> header to avoid adding multiple conflicting entries, not just duplicate\n> entries?\n\nMost likely yes, but the end result is still going to be a \"Connection: close\" header for a 400 response code.", "id": 175397, "time": "2014-05-22T19:05:33Z", "bug_id": 56555, "creation_time": "2014-05-22T19:05:33Z", "is_private": false, "attachment_id": null}, {"count": 2, "tags": [], "bug_id": 56555, "is_private": false, "text": "Thanks for the quick reply.  So is it expected behavior, even in cases where \"Connection: keep-alive\" is set, for the container to force it to \"Connection: close\"?\n\nI would think that if the response header is already set by the application, that the container should honor it (unless maxKeepAlive is exceeded, or persistent connections are disabled).  I haven't seen anything in the HTTP 1.1 spec saying that a status of 400 requires that the connection be closed.  The only case where a server is required to close a connection is when the request includes \"Connection: close\" but other than that, it appears to be optional (with the default being persistent connections).  Am I missing something?", "id": 175398, "time": "2014-05-22T19:37:13Z", "creator": "lee.brett@gmail.com", "creation_time": "2014-05-22T19:37:13Z", "attachment_id": null}, {"count": 3, "tags": [], "bug_id": 56555, "text": "(In reply to Brett from comment #0)\n> Background/Expected Behavior:\n> Our application is a RESTful web service, we return error responses with\n> status code 400 in situations, like for example when a POST to access a\n> request token contains a valid username but invalid password.\n\nShouldn't this be 403?\n\n(In reply to Brett from comment #2)\n> Thanks for the quick reply.  So is it expected behavior, even in cases where\n> \"Connection: keep-alive\" is set, for the container to force it to\n> \"Connection: close\"?\n\nNot generally, but \"400 Bad Request\" is kind of a killer. Tomcat defines a few deal-breaker status codes that will close the connection regardless of the wishes of the application. You can find them in the statusDropsConnection method called by the code you already posted. Here's the meat of the method:\n\n        return status == 400 /* SC_BAD_REQUEST */ ||\n               status == 408 /* SC_REQUEST_TIMEOUT */ ||\n               status == 411 /* SC_LENGTH_REQUIRED */ ||\n               status == 413 /* SC_REQUEST_ENTITY_TOO_LARGE */ ||\n               status == 414 /* SC_REQUEST_URI_TOO_LONG */ ||\n               status == 500 /* SC_INTERNAL_SERVER_ERROR */ ||\n               status == 503 /* SC_SERVICE_UNAVAILABLE */ ||\n               status == 501 /* SC_NOT_IMPLEMENTED */;\n\nBasically, any of those status codes should close the connection. The code docs say that Apache httpd will do the same thing for those status codes (i.e. drop the connection), but I see no reference to any spec that requires such behavior.\n\nOne could make the argument that the above list covers too much ground (e.g. NOT IMPLEMENTED or LENGTH_REQUIRED -- why kill the connection in those cases?) but for the case of \"400 Bad Request\", the server (application, actually) is saying that the request itself is garbled, indicating that something horrible has happened to the connection (or the client). Closing the connection is appropriate in this case.\n\nI think if you use a 403 response code (which really makes much more sense in the case presented above, IMO), then you should avoid this problem and go back to being able to use keepalives.", "id": 175399, "time": "2014-05-22T20:52:18Z", "creator": "chris@christopherschultz.net", "creation_time": "2014-05-22T20:52:18Z", "is_private": false, "attachment_id": null}, {"count": 4, "attachment_id": null, "creator": "lee.brett@gmail.com", "text": "Thanks for the info, but the conflict here is the OAuth2 specification requires a status code 400 in this case.\n\nFrom http://tools.ietf.org/html/rfc6749#section-5.2 :\n\"The authorization server responds with an HTTP 400 (Bad Request) status code (unless specified otherwise)...\" and goes on to list the only exception as \"invalid_client\" wherein \"[t]he authorization server MAY return an HTTP 401 (Unauthorized) status code to indicate which HTTP authentication schemes are supported.\"  Our particular error condition in this case is \"invalid_grant\" which according to the spec appears to get the default 400 status code.  This is how we've implemented it, and this is how our clients are expecting it :/\n\nI am puzzled because we can't be the only ones that have encountered this issue. However, I have not found anything in the last two days online where anyone has even brought this up as an issue before.", "id": 175401, "time": "2014-05-22T22:40:40Z", "bug_id": 56555, "creation_time": "2014-05-22T22:40:40Z", "tags": [], "is_private": false}, {"count": 5, "tags": [], "bug_id": 56555, "is_private": false, "text": "Having re-read RFC2616 the use of a 400 response code in this case looks wrong. 400 is meant to be used to indicate a syntax error in the request which is why Tomcat closes the connection. Tomcat can not be sure that it has correctly identified the end of the faulty request and continuing to process the connection could lead to security problems.\n\nThe correct response code for invalid credentials should be 401.\n\nI do not recall anyone raising this as an issue previously.\n\nTomcat has no way of telling which component set the 400 response status and therefore no way of distinguishing between a correct use of a 400 where there has been a syntax error and the connection needs to be closed and any other use of a 400 where it is safe to leave the connection open. The presense (or not) of the connection header may provide a hint but it is not reliable indicator.\n\nYou are not going to like it but the only safe option for Tomcat with a 400 response is to close the connection (and yes we need to up the connection header handling when this happens).", "id": 175519, "time": "2014-05-28T11:38:15Z", "creator": "markt@apache.org", "creation_time": "2014-05-28T11:38:15Z", "attachment_id": null}, {"count": 6, "attachment_id": null, "creator": "markt@apache.org", "text": "The multiple connection headers aspect of this has been fixed in 8.0.x for 8.0.9 onwards and in 7.0.x for 7.0.55 onwards. I'm marking this as RESOLVED on that basis.\n\nI recognise that this doesn't address the connection being closed part of the problem. I don't see an easy solution to that. Suggestions welcome and the dev list is probably the place to start that discussion. Alternatively, you can open a BZ enahncement request for a solution to the connection being closed in this case but, without a concrete proposal, the enhancement request is likely to make little/no progress.", "id": 175522, "time": "2014-05-28T13:06:53Z", "bug_id": 56555, "creation_time": "2014-05-28T13:06:53Z", "tags": [], "is_private": false}, {"count": 7, "tags": [], "bug_id": 56555, "attachment_id": null, "is_private": false, "id": 175549, "time": "2014-05-29T20:13:57Z", "creator": "chris@christopherschultz.net", "creation_time": "2014-05-29T20:13:57Z", "text": "(In reply to Mark Thomas from comment #5)\n> The correct response code for invalid credentials should be 401.\n\nUse of 401 is only appropriate when using WWW-Authenticate, as RFC2616 says 401 RFC-MUST include a WWW-Authenticate header. I don't think this happens with OAuth. If it's just a lack of (other) credentials, I think 403 is more appropriate.\n\n> Tomcat has no way of telling which component set the 400 response status and\n> therefore no way of distinguishing between a correct use of a 400 where\n> there has been a syntax error and the connection needs to be closed and any\n> other use of a 400 where it is safe to leave the connection open. The\n> presense (or not) of the connection header may provide a hint but it is not\n> reliable indicator.\n> \n> You are not going to like it but the only safe option for Tomcat with a 400\n> response is to close the connection (and yes we need to up the connection\n> header handling when this happens).\n\nWhat about using some kind of Tomcat-specific request attribute that says \"Don't close this connection; I know what I'm doing\"?"}, {"count": 8, "tags": [], "creator": "knst.kolinko@gmail.com", "text": "I am -1 to r1598007\n\nSee how \"Connection\" header is defined in RFC2616 section 14.10 and processing of \"close\" token in section 8.1.2.1.\n\nThe Connection header is a multi-value header that declares names of header fields that are for this connection only and are not forwarded by proxies.\n\nIf you drop the Connection header you must drop any other headers that are referenced in it. There are no grounds to do that.", "id": 175556, "time": "2014-05-30T02:14:02Z", "bug_id": 56555, "creation_time": "2014-05-30T02:14:02Z", "is_private": false, "attachment_id": null}, {"count": 9, "tags": [], "bug_id": 56555, "attachment_id": null, "text": "(In reply to Konstantin Kolinko from comment #8)\n> I am -1 to r1598007\n> \n> See how \"Connection\" header is defined in RFC2616 section 14.10 and\n> processing of \"close\" token in section 8.1.2.1.\n> \n> The Connection header is a multi-value header that declares names of header\n> fields that are for this connection only and are not forwarded by proxies.\n> \n> If you drop the Connection header you must drop any other headers that are\n> referenced in it. There are no grounds to do that.\n\nI understand (and agree with) your objections to r1598007. What isn't clear is what you think Tomcat should do here. Is your position that this issue should simply have been resolved as invalid as multiple connection headers are allowed and the presence of a connection: close will always close the connection?", "id": 175560, "time": "2014-05-30T07:26:29Z", "creator": "markt@apache.org", "creation_time": "2014-05-30T07:26:29Z", "is_private": false}, {"count": 10, "tags": [], "bug_id": 56555, "text": "It seems enough to me, +1 for a simple revert.", "id": 175561, "time": "2014-05-30T08:13:12Z", "creator": "remm@apache.org", "creation_time": "2014-05-30T08:13:12Z", "is_private": false, "attachment_id": null}, {"count": 11, "tags": [], "bug_id": 56555, "attachment_id": null, "text": "> multiple connection headers are allowed and the presence of a connection: close > will always close the connection?\n\nYes. (and multiple tokens in the same Connection header are allowed).\n\nIf you strive for cleanness then a) remove \"keep-alive\" token only, b) remove \"Keep-Alive:\" header if there is any (a header defined by RFC2068). I do not think that it is worth pursuing.\n\nAs for OP, I see no sense why they explicitly add a \"keep-alive\" header. First, container takes care of that (and will use keep-alive whenever possible, taking into account the protocol version and how many keep-alive requests have already been processed).\nSecond, HTTP/1.1 connections are keep-alive by default. No header needed.\nThird, as this is a header for the current hop/connection only, it further makes no sense to rely on it in an application.\nThus I think that the original claim is INVALID.\n\nRegarding the original code of AbstractHttp11Processor:\nI think Tomcat adds keep-alive header in some cases when it should not.\nPer the above, it does not matter, as the close header wins.\n\nThe issues are the following:\n1) isConnectionClose(headers) call happens in one branch of an if/else only. It shall be called in both cases.\n2) If isConnectionClose(headers) returns true, then keepAlive flag shall be set to false and no header added.\n3) isConnectionClose( ) method looks for the value of the first header only. It does not enumerate all Connection headers, nor it looks for multiple tokens in the same header.", "id": 175563, "time": "2014-05-30T11:52:01Z", "creator": "knst.kolinko@gmail.com", "creation_time": "2014-05-30T11:52:01Z", "is_private": false}, {"count": 12, "tags": [], "creator": "markt@apache.org", "text": "Fixes reverted for trunk and 7.0x. as discussed. Closing this issue as INVALID.", "id": 175593, "time": "2014-06-02T12:24:10Z", "bug_id": 56555, "creation_time": "2014-06-02T12:24:10Z", "is_private": false, "attachment_id": null}]