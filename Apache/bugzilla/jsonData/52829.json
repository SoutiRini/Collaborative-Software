[{"count": 0, "tags": [], "creator": "jarekczek@poczta.onet.pl", "text": "While script task is able to use the following syntax:\nfor (f: fs)\nit is not possible for custom tasks written in java. Since a switch to Java5 all classes implementing iterator() should be declared as \"implements Iterable\". See the relevant java documentation:\nhttp://docs.oracle.com/javase/specs/jls/se5.0/html/statements.html#14.14.2\n\nThe idea is on the mailing list:\nhttp://mail-archives.apache.org/mod_mbox/ant-dev/201203.mbox/%3CCAE9L6G3-uLwA2EQV_mbdXtnZs_PYb_UMLB5iEX71N%2BqRb1C86g%40mail.gmail.com%3E\nand was accepted by Matt Benson.", "id": 154532, "attachment_id": null, "bug_id": 52829, "creation_time": "2012-03-05T08:06:43Z", "time": "2012-03-05T08:06:43Z", "is_private": false}, {"attachment_id": null, "tags": [], "creator": "jglick@apache.org", "is_private": false, "count": 1, "id": 154551, "time": "2012-03-05T20:42:14Z", "bug_id": 52829, "creation_time": "2012-03-05T20:42:14Z", "text": "Such types should indeed implement Iterable. The question is what the type parameter should be. In the case of ResourceCollection, probably the parameter should be Resource.\n\nNow if this were actually \"? extends Resource\" then FileSet could override this to be an Iterable<FileResource>, or ResourceCollection could even itself take a type parameter describing the subtype of Resource it contains, but I am not sure we want to get this complicated with generics - it can be rather tricky to understand such code and make it work correctly with extensions.\n\nProbably simpler and better would be to leverage the Resource.as method and do not allow covariant Resource subtypes. Then FileResource can continue to be an implementation detail, which FileSet and friends would not be obliged to use, and your client code would do something like:\n\nfor (Resource r : someFileSetOrOtherResourceCollection) {\n  File f = r.as(FileProvider.class).getFile();\n  // ...\n}\n\nwhich extends naturally to other extension interfaces like URLProvider. I believe this works in Rhino JavaScript as well (just omit the \".class\" on the type token and of course qualify it if needed). Of course if you are unsure what the collection might consist of, you must check each call to as(FileProvider) for a null return value.\n\nThere could also be convenience methods somewhere (Resource? Resources? Files?) such as\n\n/** call {@link Resource#as} on each element, throw NPE or similar if missing */\npublic static <P> Iterable<P> as(ResourceCollection rc, Class<P> type);\n/** obtains {@link FileProvider} from each element; must be filesystemOnly */\npublic static Iterable<File> asFiles(ResourceCollection rc);\n\nto simplify loops."}, {"count": 2, "tags": [], "bug_id": 52829, "attachment_id": null, "id": 154727, "time": "2012-03-09T10:24:38Z", "creator": "jarekczek@poczta.onet.pl", "creation_time": "2012-03-09T10:24:38Z", "is_private": false, "text": "To add some background: FileSet.iterator() returns Object type. So one using iterator() must do the conversion manually.\n\nTo make \"for\" loops more convenient you suggest that Iterable should return a specific, more useful type. But it would be inconsistent with iterator(). I don't mind it, just commenting.\n\nIf that's too difficult to choose the ideal Iterable type at the moment, you could simply implement Iterable<Object>. I guess making a specialized Iterable in the future would not break any code relying on Iterable<Object>.\n\nAnyway I don't feel competent to make directions in this matter, so I'll switch to a listening mode from now on."}, {"count": 3, "tags": [], "bug_id": 52829, "attachment_id": null, "id": 154750, "time": "2012-03-09T14:54:19Z", "creator": "jglick@apache.org", "creation_time": "2012-03-09T14:54:19Z", "is_private": false, "text": "(In reply to comment #2)\n> FileSet.iterator() returns Object type.\n\nIt returns (raw) Iterable today, the elements of which are in fact guaranteed to be assignable to Resource. The proposal is to specify it as Iterable<Resource> now that we can use generics."}, {"count": 4, "tags": [], "bug_id": 52829, "is_private": false, "text": "FWIW, I'd prefer Iterable<Resource> and as(FileProvider.class).", "id": 155027, "time": "2012-03-18T19:50:21Z", "creator": "bodewig@apache.org", "creation_time": "2012-03-18T19:50:21Z", "attachment_id": null}, {"attachment_id": null, "tags": [], "creator": "mbenson@apache.org", "is_private": false, "count": 5, "id": 155059, "time": "2012-03-19T17:29:18Z", "bug_id": 52829, "creation_time": "2012-03-19T17:29:18Z", "text": "Hi all!  Some observations:\n\n 1.  Jesse's proposal, despite being a workable plan, felt to me at first read like implementing generics in a \"halfway\" manner.\n 2.  I haven't done any Ant work to speak of in quite some time and thus my voice doesn't carry so much weight in the doocracy that is an ASF project, hence my delayed response here.\n 3.  I did particularly like the concept in Jesse's proposal of keeping things specified to e.g. FileProvider rather than FileResource.\n 4.  I did some experiments with implementing generics more fully along these lines, but was ultimately unable to get a working structure in place.  I feel that this is because when we fully Resource-ized Ant back with v1.7 (about 7 years ago now!), we were bound by the fact that Resource was a class rather than an interface.  I think that if ever we implement Ant 2, e.g. FileProvider would directly extend a Resource interface and e.g. DirSet|FileSet|FileList would expose FileProvider.\n\nMy conclusion, speaking (if I'm not overstating the case) as the committer most directly responsible for the current state of affairs of Ant's Resource API, is that for the Ant 1.x codebase, Jesse's proposal works where implementing generics any more deeply will have more drawbacks than benefits, as he guessed.  This is nobody's fault, but just a \"shit happens\" situation (shituation?).  For Ant 2, I think we can accomplish \"full generics done right,\" if and when that time ever comes.\n\nMatt"}, {"count": 6, "tags": [], "text": "Ah, I did not even notice that FileProvider is not assignable to Resource.\n\nEven ignoring FileProvider for a moment, my fear about FileSet implements Iterable<FileResource> was that the generics could become more trouble than they are worth. The only project I know of which made a real attempt to use generics like this (where you have two parallel type hierarchies linked in a \"ladder\" by type parameters) is Hudson(/Jenkins):\n\n  class Job<JobT extends Job<JobT,RunT>,RunT extends Run<JobT,RunT>>\n  class Run<JobT extends Job<JobT,RunT>,RunT extends Run<JobT,RunT>>\n  class AbstractProject<P extends AbstractProject<P,R>,R extends AbstractBuild<P,R>> extends Job<P,R>\n  class AbstractBuild<P extends AbstractProject<P,R>,R extends AbstractBuild<P,R>> extends Run<P,R>\n  ...\n\nand in practice the code base (1) is full of unchecked/rawtype warnings no one has ever figured out how to resolve, (2) sometimes fails to compile using new versions of javac and/or ecj.", "attachment_id": null, "bug_id": 52829, "id": 155293, "time": "2012-03-26T20:26:43Z", "creator": "jglick@apache.org", "creation_time": "2012-03-26T20:26:43Z", "is_private": false}, {"attachment_id": null, "tags": [], "creator": "jglick@apache.org", "text": "Committed revision 1326760.", "count": 7, "id": 158113, "time": "2012-04-16T19:30:40Z", "bug_id": 52829, "creation_time": "2012-04-16T19:30:40Z", "is_private": false}]