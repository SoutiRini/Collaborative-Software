[{"count": 0, "tags": [], "bug_id": 41988, "attachment_id": null, "text": "I've written a Batik torture test that loads an SVG document and makes zillions\nof DOM changes. Running this test on some (but not all) SVG documents that I've\ntried eventually leads to an OutOfMemoryException.\n\nTherefore, there must be a memory leak in Batik somewhere relating to (or\ntriggered by) DOM manipulation.\n\nExample of a document that triggers the memory leak:\n \nhttp://svn.apache.org/repos/asf/xmlgraphics/batik/trunk/samples/tests/spec/linking/linkingViewBox.svg\n\nExample of a document that doesn't seem to trigger the memory leak:\n  http://www.living-pages.de/de/projects/xop/samples/tiger.svg\n\nHere is the torture test and the little shell script I use to run it:\n\n--------------------------------------------------------------------\n\nimport java.awt.Dimension;\nimport java.awt.GraphicsEnvironment;\nimport java.awt.Point;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Random;\n\nimport javax.swing.JFrame;\nimport javax.swing.SwingUtilities;\n\nimport org.apache.batik.bridge.UpdateManager;\nimport org.apache.batik.bridge.UpdateManagerEvent;\nimport org.apache.batik.bridge.UpdateManagerListener;\nimport org.apache.batik.swing.JSVGCanvas;\nimport org.apache.batik.swing.gvt.GVTTreeRendererEvent;\nimport org.apache.batik.swing.gvt.GVTTreeRendererListener;\nimport org.apache.batik.swing.svg.GVTTreeBuilderEvent;\nimport org.apache.batik.swing.svg.GVTTreeBuilderListener;\nimport org.apache.batik.swing.svg.SVGDocumentLoaderEvent;\nimport org.apache.batik.swing.svg.SVGDocumentLoaderListener;\nimport org.apache.batik.swing.svg.SVGLoadEventDispatcherEvent;\nimport org.apache.batik.swing.svg.SVGLoadEventDispatcherListener;\nimport org.apache.log4j.BasicConfigurator;\nimport org.apache.log4j.ConsoleAppender;\nimport org.apache.log4j.Level;\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.PatternLayout;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.svg.SVGDefsElement;\nimport org.w3c.dom.svg.SVGDocument;\nimport org.w3c.dom.svg.SVGElement;\nimport org.w3c.dom.svg.SVGGElement;\n\npublic class DOMScrambler extends WindowAdapter implements\n  SVGDocumentLoaderListener, GVTTreeBuilderListener,\n  SVGLoadEventDispatcherListener, GVTTreeRendererListener,\n  UpdateManagerListener {\n\n    // Tweak these parameters to increase/decrease the torture\n    public static final int SCRAMBLER_TIME = 100;           // lower = more torture\n    public static final int SCRAMBLER_NUM_CHANGES = 10;     // higher = more torture\n\n    private final Logger log = Logger.getLogger(getClass());\n    private final String url;\n    private final JFrame frame;\n    private final JSVGCanvas canvas;\n    private final Random random = new Random();\n    private final ArrayList<SVGGElement> gnodes = new ArrayList<SVGGElement>();\n\n    private SVGDocument dom;\n\n    public abstract class RepeatingThread extends Thread {\n        public void run() {\n            try {\n                while (true) {\n                    execute();\n                }\n            } catch (Throwable t) {\n                t.printStackTrace(System.err);\n            }\n        }\n        protected abstract void execute();\n        protected void delay(int millis) {\n            try {\n                Thread.sleep(millis);\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n\n    public class MemoryReportingThread extends RepeatingThread {\n        protected void execute() {\n            Runtime runtime = Runtime.getRuntime();\n            runtime.gc();\n            System.out.println(\"MEMORY:\");\n            System.out.println(\"\\tFREE:\\t\" + runtime.freeMemory());\n            System.out.println(\"\\tTOTAL:\\t\" + runtime.totalMemory());\n            System.out.println(\"\\tMAX:\\t\" + runtime.maxMemory());\n            delay(10000);\n        }\n    }\n\n    public class SleeperThread extends RepeatingThread {\n        protected void execute() {\n            delay(nextInt(500));\n        }\n    }\n\n    public class SwingNoise extends SleeperThread {\n        protected void execute() {\n            SwingUtilities.invokeLater(new Runnable() {\n                public void run() {\n                    delay(nextInt(20));\n                }\n            });\n            super.execute();\n        }\n    }\n\n    public class BatikNoise extends SleeperThread {\n        protected void execute() {\n            updateSVG(new Runnable() {\n                public void run() {\n                    delay(nextInt(20));\n                }\n            });\n            super.execute();\n        }\n    }\n\n    public class Scrambler extends SleeperThread {\n        protected void execute() {\n            updateSVG(new Runnable() {\n                public void run()  {\n                    for (int i = 0; i < nextInt(SCRAMBLER_NUM_CHANGES); i++)\n                        scramble();\n                }\n            });\n            delay(nextInt(SCRAMBLER_TIME));\n        }\n        protected void scramble() {\n          tryagain:\n            while (true) {\n                SVGGElement g1 = gnodes.get(nextInt(gnodes.size()));\n                SVGGElement g2 = gnodes.get(nextInt(gnodes.size()));\n                NodeList kids1 = g1.getChildNodes();\n                NodeList kids2 = g2.getChildNodes();\n                if (kids1.getLength() == 0 && kids2.getLength() == 0)\n                    continue;\n                Element parent1 = kids1.getLength() > 0 ? g1 : g2;\n                Element parent2 = parent1 == g1 ? g2 : g1;\n                kids1 = parent1.getChildNodes();\n                Node child = kids1.item(nextInt(kids1.getLength()));\n\n                // Verify parent2 is not child or in child's subtree\n                for (Node ancestor = parent2; ancestor != null;\n                  ancestor = ancestor.getParentNode()) {\n                    if (ancestor == child)\n                        continue tryagain;\n                }\n\n                // Swizzle child node\n                //log.debug(\"moving child \" + child + \" from \" + parent1 + \" to\n\" + parent2);\n                parent1.removeChild(child);\n                parent2.appendChild(child);\n                break;\n            }\n        }\n    }\n\n    public DOMScrambler(String url) {\n        this.url = url;\n        frame = new JFrame(\"DOMScrambler: \"\n          + url.substring(url.lastIndexOf('/') + 1));\n        canvas = new JSVGCanvas(null, true, true);\n        canvas.setDocumentState(JSVGCanvas.ALWAYS_DYNAMIC);\n        canvas.addSVGDocumentLoaderListener(this);\n        canvas.addGVTTreeBuilderListener(this);\n        canvas.addGVTTreeRendererListener(this);\n        canvas.addSVGLoadEventDispatcherListener(this);\n        canvas.addUpdateManagerListener(this);\n        canvas.setFocusable(true);\n        frame.addWindowListener(this);\n    }\n\n    public void go() {\n        canvas.setURI(this.url);\n    }\n\n    public void cancel() {\n        System.err.println(\"Something went wrong\");\n    }\n\n    protected void updateSVG(final Runnable rable) {\n        UpdateManager updateManager = canvas.getUpdateManager();\n        updateManager.getUpdateRunnableQueue().invokeLater(\n          new Runnable() {\n            public void run() {\n                try {\n                    rable.run();\n                } catch (Throwable t) {\n                    t.printStackTrace(System.err);\n                    System.exit(1);\n                }\n            }\n        });\n    }\n\n    protected int nextInt(int bound) {\n        synchronized (random) {\n            return random.nextInt(bound);\n        }\n    }\n\n    protected void ready() {\n\n        // Get SVG DOM\n        this.dom = canvas.getSVGDocument();\n\n        // Locate all <g> nodes\n        findGNodes(this.dom.getDocumentElement());\n\n        // Start threads\n        new MemoryReportingThread().start();\n        new SleeperThread().start();\n        new SleeperThread().start();\n        new SleeperThread().start();\n        new SwingNoise().start();\n        new SwingNoise().start();\n        new BatikNoise().start();\n        new BatikNoise().start();\n        new Scrambler().start();\n    }\n\n    private void findGNodes(Element elem) {\n        if (elem instanceof SVGDefsElement)\n            return;\n        NodeList nodeList = elem.getChildNodes();\n        for (int i = 0; i < nodeList.getLength(); i++) {\n            Node item = nodeList.item(i);\n            if (item instanceof SVGGElement)\n                gnodes.add((SVGGElement)item);\n            if (item instanceof Element)\n                findGNodes((Element)item);\n        }\n    }\n\n    public void showFrame() {\n        SwingUtilities.invokeLater(new Runnable() {\n            public void run() {\n                frame.getContentPane().add(canvas);\n                frame.pack();\n                Dimension size = frame.getSize();\n                Point center = GraphicsEnvironment\n                  .getLocalGraphicsEnvironment().getCenterPoint();\n                int x = (int)(center.getX() - size.getWidth() / 2);\n                int y = (int)(center.getY() - size.getHeight() / 2);\n                frame.setLocation(new Point(x, y));\n                frame.setVisible(true);\n                frame.toFront();\n            }\n        });\n    }\n\n    // SVGDocumentLoaderListener methods\n\n    public void documentLoadingStarted(SVGDocumentLoaderEvent e) {\n        log.debug(\"Document loading started\");\n    }\n\n    public void documentLoadingCompleted(SVGDocumentLoaderEvent e) {\n        log.debug(\"Document loading completed\");\n    }\n\n    public void documentLoadingCancelled(SVGDocumentLoaderEvent e) {\n        log.debug(\"Document loading canceled\");\n    }\n\n    public void documentLoadingFailed(SVGDocumentLoaderEvent e) {\n        log.debug(\"Document loading failed: \" + e);\n        cancel();\n    }\n\n    // GVTTreeBuilderListener methods\n\n    public void gvtBuildStarted(GVTTreeBuilderEvent e) {\n        log.debug(\"GVT build started\");\n    }\n\n    public void gvtBuildCompleted(GVTTreeBuilderEvent e) {\n        log.debug(\"GVT build completed\");\n        showFrame();\n    }\n\n    public void gvtBuildCancelled(GVTTreeBuilderEvent e) {\n        log.debug(\"GVT build canceled\");\n    }\n\n    public void gvtBuildFailed(GVTTreeBuilderEvent e) {\n        log.debug(\"GVT build failed: \" + e);\n        cancel();\n    }\n\n    // GVTTreeRendererListener methods\n\n    public void gvtRenderingPrepare(GVTTreeRendererEvent e) {\n        log.debug(\"GVT rendering preparing\");\n    }\n\n    public void gvtRenderingStarted(GVTTreeRendererEvent e) {\n        log.debug(\"GVT rendering started\");\n    }\n\n    public void gvtRenderingCompleted(GVTTreeRendererEvent e) {\n        log.debug(\"GVT rendering complete\");\n        ready();\n    }\n\n    public void gvtRenderingCancelled(GVTTreeRendererEvent e) {\n        log.debug(\"GVT rendering canceled\");\n    }\n\n    public void gvtRenderingFailed(GVTTreeRendererEvent e) {\n        log.debug(\"GVT rendering failed: \" + e);\n        cancel();\n    }\n\n    // SVGLoadEventDispatcherListener methods\n\n    public void svgLoadEventDispatchCancelled(SVGLoadEventDispatcherEvent e) {\n        log.debug(\"Load event dispatch cancelled\");\n    }\n\n    public void svgLoadEventDispatchCompleted(SVGLoadEventDispatcherEvent e) {\n        log.debug(\"Load event dispatch completed\");\n    }\n\n    public void svgLoadEventDispatchFailed(SVGLoadEventDispatcherEvent e) {\n        log.debug(\"Load event dispatch failed: \" + e);\n    }\n\n    public void svgLoadEventDispatchStarted(SVGLoadEventDispatcherEvent e) {\n        log.debug(\"Load event dispatch started\");\n    }\n\n    // UpdateManagerListener\n\n    public void managerStarted(UpdateManagerEvent e) {\n        log.debug(\"Update manager started\");\n    }\n\n    public void managerSuspended(UpdateManagerEvent e) {\n        log.debug(\"Update manager suspended\");\n    }\n\n    public void managerResumed(UpdateManagerEvent e) {\n        log.debug(\"Update manager resumed\");\n    }\n\n    public void managerStopped(UpdateManagerEvent e) {\n        log.debug(\"Update manager stopped\");\n    }\n\n    public void updateStarted(UpdateManagerEvent e) {\n        //log.debug(\"Update manager started\");\n    }\n\n    public void updateCompleted(UpdateManagerEvent e) {\n        //log.debug(\"Update manager completed\");\n    }\n\n    public void updateFailed(UpdateManagerEvent e) {\n        log.debug(\"Update manager failed: \" + e);\n    }\n\n    // WindowListener methods\n\n    public void windowClosing(WindowEvent e) {\n        System.exit(0);\n    }\n\n    public static void main(String[] args) throws Exception {\n        ConsoleAppender consoleAppender = new ConsoleAppender(\n          new PatternLayout(PatternLayout.TTCC_CONVERSION_PATTERN),\n          ConsoleAppender.SYSTEM_ERR);\n        consoleAppender.setThreshold(Level.DEBUG);\n        BasicConfigurator.configure(consoleAppender);\n        if (args.length != 1) {\n            System.err.println(\"Usage: java DOMScrambler <file | URL>\");\n            System.exit(1);\n        }\n        File file = new File(args[0]);\n        if (file.exists())\n            args[0] = file.toURL().toString();\n        new DOMScrambler(args[0]).go();\n    }\n}\n\n--------------------------------------------------------------------\n\n#!/bin/sh\n\nLIBS=`build-classpath batik jakarta-commons-collections jakarta-commons-lang\njakarta-commons-logging log4j spring xerces-j2 xml-commons-apis`\n\nset -e\nmkdir -p classes\njavac -d classes -classpath \"${LIBS}\" DOMScrambler.java\njava -Xmx40m -classpath classes:\"${LIBS}\" DOMScrambler ${1+\"$@\"}\n\n--------------------------------------------------------------------", "id": 101193, "time": "2007-03-29T16:30:19Z", "creator": "archie@dellroad.org", "creation_time": "2007-03-29T16:30:19Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 41988, "attachment_id": null, "is_private": false, "id": 101299, "time": "2007-04-01T07:48:10Z", "creator": "archie@dellroad.org", "creation_time": "2007-04-01T07:48:10Z", "text": "I tried this test on Batik 1.7beta1 and the bug is still present in that version.\n"}, {"count": 2, "tags": [], "bug_id": 41988, "attachment_id": null, "is_private": false, "id": 101304, "time": "2007-04-01T10:29:09Z", "creator": "archie@dellroad.org", "creation_time": "2007-04-01T10:29:09Z", "text": "Here's a stack histogram (acquired via \"jmap\") showing the classes responsible\nfor the memory leak. All of these classes were increasing as the test ran and\nhave abnormally high instance counts. The list is sorted by memory usage per class:\n\nObject Histogram:\n\nSize    Count   Class description\n-------------------------------------------------------\n\n... lots of other classes ...\n10128   422     java.util.LinkedList\n11312   202     org.apache.batik.dom.GenericAttr\n11640   485     org.apache.batik.css.engine.value.StringMap$Entry\n11696   1462    java.lang.ref.ReferenceQueue$Lock\n12896   87      org.apache.batik.css.engine.value.Value[]\n15096   51      org.apache.batik.gvt.font.AWTGlyphGeometryCache$Entry[]\n15720   393     java.util.HashMap\n15984   666     sun.font.FontLineMetrics\n19632   409     org.apache.batik.dom.GenericText\n19968   290     java.lang.String[]\n20136   839     java.util.LinkedList$Entry\n20736   648     org.apache.batik.dom.util.DoublyIndexedTable$Entry\n22160   1385   \norg.apache.batik.bridge.SVGTextElementBridge$DOMChildNodeRemovedEventListener\n22160   1385   \norg.apache.batik.bridge.SVGTextElementBridge$DOMSubtreeModifiedEventListener\n22640   1415    org.apache.batik.bridge.UnitProcessor$DefaultContext\n22960   205     org.apache.batik.gvt.ShapeNode\n32400   2025    java.lang.Integer\n32664   1361    sun.font.TrueTypeFont$DirectoryEntry\n33240   1385    org.apache.batik.gvt.text.AttributedCharacterSpanIterator\n35040   1460    java.lang.ref.ReferenceQueue\n37296   666     sun.font.CoreMetrics\n45328   1446    boolean[]\n46328   1410    org.apache.batik.gvt.GraphicsNode[]\n52352   1636    java.awt.BasicStroke\n55400   1385    org.apache.batik.gvt.renderer.StrokingTextPainter$TextRun\n58064   191     * ObjArrayKlassKlass\n59040   1476    java.util.WeakHashMap$Entry\n62040   2585    org.apache.batik.gvt.font.AWTGVTFont\n67104   1398    java.util.WeakHashMap\n77136   3214    java.lang.ref.WeakReference\n81360   2034    java.awt.Color\n88640   1385    org.apache.batik.gvt.font.GVTLineMetrics\n88640   1385    org.apache.batik.gvt.text.GlyphLayout\n89504   2797    org.apache.batik.dom.events.EventListenerList$Entry\n91320   1415    double[]\n99720   1385    sun.font.StandardGlyphVector\n99864   1387    org.apache.batik.bridge.SVGTextElementBridge\n99912   398     java.util.HashMap$Entry[]\n103416  4309    java.util.ArrayList\n107912  1385    org.apache.batik.gvt.font.GVTGlyphMetrics[]\n107992  1386    java.awt.geom.AffineTransform[]\n110840  2771    java.text.AttributedString$AttributedStringIterator\n112176  1398    java.util.WeakHashMap$Entry[]\n115456  3608    java.lang.ref.Finalizer\n121880  1385    org.apache.batik.gvt.font.AWTGVTGlyphVector\n130592  4081    org.apache.batik.bridge.BridgeContext$EventListenerMememto\n132992  4156    java.text.AttributedString\n136672  8542    java.lang.Float\n137200  3430    java.util.Hashtable\n144000  6000    org.apache.batik.gvt.event.GraphicsNodeChangeEvent\n157584  1407    org.apache.batik.gvt.CompositeGraphicsNode\n158304  4947    java.lang.ref.SoftReference\n166200  1385    org.apache.batik.gvt.TextNode\n201456  2798    org.apache.batik.gvt.text.TextPaintInfo\n202064  4379    java.lang.Object[]\n220224  2770    java.awt.geom.Point2D$Float[]\n238920  9955    java.util.HashMap$Entry\n252792  3511    java.awt.Font\n259248  2946    java.lang.Class\n285208  3442    java.util.Hashtable$Entry[]\n287152  4113    short[]\n323736  4155    java.awt.Shape[]\n326480  8162    org.apache.batik.bridge.BridgeContext$SoftReferenceMememto\n347408  21713   org.apache.batik.gvt.font.GVTGlyphMetrics\n404448  16852   java.util.Vector\n462024  19251   java.lang.String\n465360  8310    java.util.Vector[]\n521112  21713   java.awt.font.GlyphMetrics\n631392  26308   java.awt.geom.Rectangle2D$Float\n674400  28100   java.util.Hashtable$Entry\n707840  11060   java.awt.geom.AffineTransform\n748448  23389   java.awt.geom.GeneralPath\n806064  50379   java.awt.geom.Point2D$Float\n866592  2455    * ConstantPoolCacheKlass\n869400  21735   java.awt.geom.Rectangle2D$Double\n1170248 2726    * InstanceKlassKlass\n1338248 2726    * ConstantPoolKlass\n1474768 19051   char[]\n1588336 42517   * SymbolKlass\n1610328 28645   * MethodKlass\n1780632 21463   java.lang.Object[]\n2297040 26531   byte[]\n2621256 11208   int[]\n3064456 28645   * ConstMethodKlass\n13801968        28294   float[]\n"}, {"count": 3, "tags": [], "text": "Created attachment 19933\nPatch to improve stress test\n\nIf you run the test on a slow enough computer, then updates will be added at a\nrate faster than Batik can process them.\n\nWhile such an \"update pileup\" will indeed cause a memory leak as well, that is\nNOT the bug being described here - there is a memory leak even when Batik is\nable to keep up with all the updates.\n\nIn any case, you can apply the attached patch to have the test program print\nout the number of pending updates as it runs, so you can see how many there\nare.", "attachment_id": 19933, "bug_id": 41988, "id": 101591, "time": "2007-04-11T13:33:33Z", "creator": "archie@dellroad.org", "creation_time": "2007-04-11T13:33:33Z", "is_private": false}, {"count": 4, "tags": [], "text": "I've done some further investigation...\n\n1. This leak appears to be related to <text> nodes; <text> nodes are being\n   referenced in the heap even after they are removed from the DOM.\n2. Heap inspection reveals that a zillions of SVGTextElementBridge nodes are\n   lying around, still registered as EventListeners on the DOM.\n3. When the <text> node is directly removed from the DOM, no memory leak\n   appears to occur. However, when the parent of a <text> node is removed\n   from the DOM, the memory leak does occur.\n\nIn SVGTextElementBridge.java, the removeTextEventListeners() method must be\ncalled when the node is removed from the DOM to avoid a memory leak. This\nmethod is only ever called from handleDOMNodeRemovedEvent() (in same class).\n\nCurent theory: handleDOMNodeRemovedEvent() is being properly called when the\n<text> node is the node being removed, but not when the <text> node is a\ndescendant of the node being removed.\n\nHere is the smallest input file that exhibits the bug when run with the\nDOMScrambler program:\n\n<?xml version=\"1.0\" standalone=\"no\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.0//EN\"\n  \"http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd\">\n<svg xmlns=\"http://www.w3.org/2000/svg\"\n  xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n  width=\"200\" height=\"200\" viewBox=\"0 0 200 200\"><g><g><text/></g></g></svg>\n\nNote the two nested <g> elements. If you remove one of the <g> elements, the\nleak does not occur (which is what led me to conclusion #3 above).\n\nThe above test input will take a long time to run out of memory. If you put a\nbunch of actual text inside the <text> node then the leak will happen much\nfaster (as expected).\n\n", "is_private": false, "bug_id": 41988, "id": 102146, "time": "2007-04-23T13:11:37Z", "creator": "archie@dellroad.org", "creation_time": "2007-04-23T13:11:37Z", "attachment_id": null}, {"count": 5, "tags": [], "text": "Created attachment 20022\nFix for this bug.\n\nI think I've found the problem. The SVGTextElementBridge class must override\nthe dispose() method to unregister the listeners, but it was not doing this.\n\nThe attached patch fixes this particular memory leak bug for me.\n\nNOTE however that there may be other instances of this kind of bug in the code.\nThe thing to do it seems would be to look for subclasses of\nAbstractGraphicsNodeBridge that allocate resources in\ninitializeDynamicSupport()  but don't free them in dispose() (or don't override\ndispose() at all).\n\nIn particular, does SVG12TextElementBridge have this same bug?", "attachment_id": 20022, "id": 102150, "creator": "archie@dellroad.org", "time": "2007-04-23T13:42:35Z", "bug_id": 41988, "creation_time": "2007-04-23T13:42:35Z", "is_private": false}, {"count": 6, "text": "Hi Archie.\n\nThanks for looking into this.  You are right in that SVGTextElementBridge needs\nto remove its event listeners regardless of how the element is removed from the\ndocument.  I could not reproduce the OOME using the small test document you\nprovided (the listeners that are added in\nSVGTextElementBridge.addTextEventListeners() are stored in a SoftReference cache\nby the ctx.storeEventListenerNS() calls, and this was sufficient for them to be\ncleared when memory filled up).  However, the linkingViewBox.svg document did\ncause the OOME.\n\nI've applied a similar fix to the one you provided.\n\n> In particular, does SVG12TextElementBridge have this same bug?\n\nIt would have, since it inherits the bug from SVGTextElementBridge.", "bug_id": 41988, "is_private": false, "id": 108602, "time": "2007-09-25T20:13:47Z", "creator": "cam@apache.org", "creation_time": "2007-09-25T20:13:47Z", "tags": [], "attachment_id": null}]