[{"count": 0, "tags": [], "creator": "Fusayuki.Minamoto@fujixerox.co.jp", "attachment_id": null, "is_private": false, "id": 4426, "time": "2001-08-09T18:44:51Z", "bug_id": 3072, "creation_time": "2001-08-09T18:44:51Z", "text": "We are using Apache 1.3.20+Ajp13 connector+Tomcat 3.2.3 in Japanese \nenvironments. Our server is running on the sparc Solaris and the clients are \nonly on Windows. We've found a HTTP header encoding problem only using Ajp13. \n\nWhen downloading files with SJIS encoded filenames from the server whose \nplatform default encoding is EUC, we always see the broken filenames at the \nfile selection dialogs of the client browsers. The problem is always reproduced \nif character encoding of filenames is different from the server encoding. We \ndon't think this is a browser problem. We tried both browsers of IE 5.5 and \nNetscape 4.73 on Windows 98/NT/2000 but the result is only dependent on the \nserver configuration. We don't see this problem using neither Apache+Ajp12 nor \nTomcat standalone HTTP server.\n\nThe situation seems a little complicated. Let me explain first how we set \nmultibyte characters to HTTP headers. Because Tomcat 3.2.x only accepts ISO8859 \nstrings as header values, we try to get the SJIS bytes form filename strings \nthen make a new string of the ISO8859 encoding before calling setHeader methods \nas follows:\n\n  String iso8859String= convertToSJISstring(retrieveFile);\n  res.setContentType(\"application/octet-stream\");\n  res.setHeader(\"Content-Length\", Integer.toString(fileSize));\n  res.setHeader(\"Content-Disposition\", \"inline; filename=\" + iso8859String);\n\nThe problem is that the SJIS filenames are endoded to EUC before sending to the \nAjp13 socket above example. We've finally found the following \nBuffTool.addString method is called only by Ajp13ConnectorResponse and it \nconverts the parameter string to bytes by \"getBytes()\". \n\npublic static int addString( byte buff[], int pos, String v ) {\n\tif(v!=null) {\n\t    int len=v.length();\n\t    addInt( buff, pos, len );\n\t    System.arraycopy( v.getBytes(), 0, buff, pos+2, len);\n\t    buff[pos+len+2]=0;\n\t    return len+pos+3;\n\t}  else {\n\t    addInt( buff, pos, 0);\n\t    buff[pos+2] = 0;\n\t    return pos+3;\n\t}                   \n    }\n\nThe getBytes() converts the string to bytes according to the platform's default \nencoding. Thus, it should to be called like \"getBytes\n(Constants.DEFAULT_CHAR_ENCODING)\", or not to use the getBytes() like the \nHttpResponseAdapter.printHead() for Ajp12.\n\nWe are about to switch the connector from Ajp12 to Ajp13 for security reason \nand we recognize the impact of this problem is serious for our users. Not only \nfor our system, however, I guess this difference behavior between Ajp12 and \nAjp13 connector is also troublesome for multibyte character environments."}, {"count": 1, "tags": [], "bug_id": 3072, "attachment_id": null, "text": "I believe this is fixed in 3.3, as well as many other 'multibyte' bugs. We use\nan OutputBuffer to send the strings with ajp13, which uses a Writer with the\nright encoding to generate the bytes.\n\nPlease test and reopen the bug if you still have problems.", "id": 4982, "time": "2001-08-28T22:40:17Z", "creator": "cmanolache@yahoo.com", "creation_time": "2001-08-28T22:40:17Z", "is_private": false}]