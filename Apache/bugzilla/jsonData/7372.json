[{"count": 0, "attachment_id": null, "bug_id": 7372, "is_private": false, "id": 12196, "time": "2002-03-22T19:49:19Z", "creator": "david.coffin@srs.gov", "creation_time": "2002-03-22T19:49:19Z", "tags": [], "text": "We want to maintain a list of allowable CONNECT sites via ProxyConnAllow \ndirectives - providing opposite functionality from that provided by ProxyBlock, \nonly for the CONNECT (SSL, etc) protocol.  If not set (default) or set to *, \nall CONNECT sessions are allowed.\n\nWe are filtering <EMBED> and other html tags after the proxy via other firewall \nsoftware to keep from html/browser-based viruses, etc.  However, filtering is \nnot possible with SSL encrypted sessions via CONNECT through the proxy, in \nwhich case we cannot read/filter the content.  Rather than turning SSL CONNECT \nsessions off (via AllowCONNECT directive), we would like to maintain a list of \nallowable sites, rather than a list of known bad sites (via ProxyBlock \ndirective.)  For that, we have devised the ProxyConnAllow directive with a few \nminor code additions, described below.\n\n3 diff files (diff from 1.3.22) are cut/pasted in suggested fix block, below\n\n\n*** mod_proxy-old.h\tFri Oct  5 04:19:15 2001\n--- mod_proxy.h\tMon Mar 18 14:09:30 2002\n***************\n*** 170,175 ****\n--- 170,180 ----\n      struct in_addr addr;\n  };\n\n+ struct connallowproxy_entry {\n+     char *name;\n+     struct in_addr addr;\n+ };\n+\n  struct nocache_entry {\n      char *name;\n      struct in_addr addr;\n***************\n*** 209,214 ****\n--- 214,220 ----\n      array_header *aliases;\n      array_header *raliases;\n      array_header *noproxies;\n+     array_header *conallowproxies;\n      array_header *dirconn;\n      array_header *nocaches;\n      array_header *allowed_connect_ports;\n\n\n\n*** mod_proxy-old.c\tMon Sep 24 16:14:28 2001\n--- mod_proxy.c\tMon Mar 18 14:11:24 2002\n***************\n*** 413,418 ****\n--- 413,419 ----\n      ps->aliases = ap_make_array(p, 10, sizeof(struct proxy_alias));\n      ps->raliases = ap_make_array(p, 10, sizeof(struct proxy_alias));\n      ps->noproxies = ap_make_array(p, 10, sizeof(struct noproxy_entry));\n+ \tps->conallowproxies = ap_make_array(p, 10, sizeof(struct \nconnallowproxy_entry));\n      ps->dirconn = ap_make_array(p, 10, sizeof(struct dirconn_entry));\n      ps->nocaches = ap_make_array(p, 10, sizeof(struct nocache_entry));\n      ps->allowed_connect_ports = ap_make_array(p, 10, sizeof(int));\n***************\n*** 458,463 ****\n--- 459,465 ----\n      ps->aliases = ap_append_arrays(p, base->aliases, overrides->aliases);\n      ps->raliases = ap_append_arrays(p, base->raliases, overrides->raliases);\n      ps->noproxies = ap_append_arrays(p, base->noproxies, overrides-\n>noproxies);\n+     ps->conallowproxies = ap_append_arrays(p, base->conallowproxies, \noverrides->conallowproxies);\n      ps->dirconn = ap_append_arrays(p, base->dirconn, overrides->dirconn);\n      ps->nocaches = ap_append_arrays(p, base->nocaches, overrides->nocaches);\n      ps->allowed_connect_ports = ap_append_arrays(p, base-\n>allowed_connect_ports, overrides->allowed_connect_ports);\n***************\n*** 583,588 ****\n--- 585,621 ----\n      return NULL;\n  }\n  \n+ static const char *\n+      set_proxy_conn_allow(cmd_parms *parms, void *dummy, char *arg)\n+ {\n+     server_rec *s = parms->server;\n+     proxy_server_conf *conf =\n+     ap_get_module_config(s->module_config, &proxy_module);\n+     struct connallowproxy_entry *new;\n+     struct connallowproxy_entry *list = (struct connallowproxy_entry *) conf-\n>conallowproxies->elts;\n+     struct hostent hp;\n+     int found = 0;\n+     int i;\n+ \n+     /* Don't duplicate entries */\n+     for (i = 0; i < conf->conallowproxies->nelts; i++) {\n+ \tif (strcasecmp(arg, list[i].name) == 0) /* ignore case for host names */\n+ \t    found = 1;\n+     }\n+ \n+     if (!found) {\n+ \tnew = ap_push_array(conf->conallowproxies);\n+ \tnew->name = arg;\n+ \t/* Don't do name lookups on things that aren't dotted */\n+ \tif (strchr(arg, '.') != NULL && ap_proxy_host2addr(new->name, &hp) == \nNULL)\n+ \t    /*@@@FIXME: This copies only the first of (possibly many) IP addrs \n*/\n+ \t    memcpy(&new->addr, hp.h_addr, sizeof(struct in_addr));\n+ \telse\n+ \t    new->addr.s_addr = 0;\n+     }\n+     return NULL;\n+ }\n+ \n  /*\n   * Set the ports CONNECT can use\n   */\n***************\n*** 901,906 ****\n--- 934,941 ----\n       \"a virtual path and a URL for reverse proxy behaviour\"},\n      {\"ProxyBlock\", set_proxy_exclude, NULL, RSRC_CONF, ITERATE,\n       \"A list of names, hosts or domains to which the proxy will not connect\"},\n+ \t{\"ProxyConnAllow\", set_proxy_conn_allow, NULL, RSRC_CONF, ITERATE,\n+      \"A list of names, hosts or domains to which the proxy will allow \nCONNECT\"},\n      {\"ProxyReceiveBufferSize\", set_recv_buffer_size, NULL, RSRC_CONF, TAKE1,\n       \"Receive buffer size for outgoing HTTP and FTP connections in bytes\"},\n      {\"NoProxy\", set_proxy_dirconn, NULL, RSRC_CONF, ITERATE,\n\n\n\n*** proxy_connect-old.c\tFri Oct  5 04:19:16 2001\n--- proxy_connect.c\tMon Mar 18 14:28:32 2002\n***************\n*** 122,132 ****\n--- 122,134 ----\n      char buffer[HUGE_STRING_LEN];\n      int nbytes, i, j;\n      fd_set fds;\n+     int pcaTst;\n  \n      void *sconf = r->server->module_config;\n      proxy_server_conf *conf =\n      (proxy_server_conf *) ap_get_module_config(sconf, &proxy_module);\n      struct noproxy_entry *npent = (struct noproxy_entry *) conf->noproxies-\n>elts;\n+     struct connallowproxy_entry *capent = (struct connallowproxy_entry *) \nconf->conallowproxies->elts;\n  \n      memset(&server, '\\0', sizeof(server));\n      server.sin_family = AF_INET;\n***************\n*** 151,156 ****\n--- 153,185 ----\n  \t\t\t\t \"Connect to remote machine blocked\");\n      }\n  \n+ /* check if ProxyConnAllow directive on this host */\n+     destaddr.s_addr = ap_inet_addr(host);\n+ \tpcaTst = 0; // 0 = fails to match\n+     if (conf->conallowproxies->nelts == 0) {\n+         // default, if no entries, allow all\n+         // disallow all via AllowCONNECT directive\n+     \tpcaTst = 1; // 1 = matched\n+     }\n+     else {\n+         for (i = 0; i < conf->conallowproxies->nelts; i++) {\n+             /* matches if first char of conf entry is *\n+                 or entry is contained in hostname\n+                 or address equals address of entry\n+             */\n+             if( capent[i].name[0] == '*'\n+                 || (capent[i].name != NULL && strstr(host, capent[i].name) != \nNULL)\n+                 || destaddr.s_addr == capent[i].addr.s_addr )\n+             {\n+                 pcaTst = 1; // 1 = matched\n+                 break;\n+             }\n+         }\n+     }\n+     if( pcaTst == 0 )\n+ \t    return ap_proxyerror(r, HTTP_FORBIDDEN,\n+ \t\t\t\t \"Connect to remote machine blocked\");\n+ \n      /* Check if it is an allowed port */\n      if (conf->allowed_connect_ports->nelts == 0) {\n \t/* Default setting if not overridden by AllowCONNECT */"}, {"count": 1, "attachment_id": null, "bug_id": 7372, "is_private": false, "id": 12765, "time": "2002-04-03T15:25:30Z", "creator": "wrowe@apache.org", "creation_time": "2002-04-03T15:25:30Z", "tags": [], "text": "\nThere is no reason to bloat the code, since the existing <Limit CONNECT> \nand <LimitExcept CONNECT>, nested in the appropriate <Directory \"proxy:*\">\nor (in Apache 2.0) <Proxy \"*\"> directives should accomplish what you wish."}]