[{"count": 0, "tags": [], "bug_id": 50056, "attachment_id": 26136, "is_private": false, "id": 140552, "time": "2010-10-07T07:38:09Z", "creator": "a6537691@bofthew.com", "creation_time": "2010-10-07T07:38:09Z", "text": "Created attachment 26136\nThe WMF file that failed\n\nI use WMFTranscoder to convert WMF files to SVG. I found a image, that fails with following exception:\n\njava.lang.ArrayIndexOutOfBoundsException: 108248\n\tat org.apache.batik.transcoder.wmf.tosvg.AbstractWMFPainter.getImage(AbstractWMFPainter.java:194)\n\tat org.apache.batik.transcoder.wmf.tosvg.AbstractWMFPainter.getImage(AbstractWMFPainter.java:74)\n\tat org.apache.batik.transcoder.wmf.tosvg.WMFPainter.paint(WMFPainter.java:859)\n\tat org.apache.batik.transcoder.wmf.tosvg.WMFTranscoder.transcode(WMFTranscoder.java:187)\n\t...\n\nThe length of the array that caused the exception was 108248, so 1 byte after the end was attempted to read.\n\nThe problem was on line 194 in AbstractWMFPainter, where next byte for the next iteration, which could be after the end, if there is no padding.\n\nHere is fixed code for the getImage(byte[]) method:\n\n/** Return the image associated with a bitmap in a Metafile.\n     *  24 bits and 8 bits bitmaps are handled.\n     *  @param bit the bitmap byte array\n     *  @return the Image associated with the bitmap (null if the dimensions detected in the\n     *     header are not consistent with the assumed dimensions)\n     */\n    protected BufferedImage getImage(byte[] bit) {\n        // get the header of the bitmap, first the width and height\n        int _width = (((int)bit[7] & 0x00ff) << 24) | (((int)bit[6] & 0x00ff) << 16)\n                    | (((int)bit[5] & 0x00ff) << 8) | (int)bit[4] & 0x00ff;\n        int _height = (((int)bit[11] & 0x00ff) << 24) | (((int)bit[10] & 0x00ff) << 16)\n                    | (((int)bit[9] & 0x00ff) << 8) | (int)bit[8] & 0x00ff;\n\n        // OK, we can safely create the data array now\n        int[] bitI = new int[_width * _height];\n        BufferedImage img = new BufferedImage(_width, _height, BufferedImage.TYPE_INT_RGB);\n        WritableRaster raster = img.getRaster();\n\n        // retrieve useful informations in bitmap header\n        // size of header\n        int _headerSize = (((int)bit[3] & 0x00ff) << 24) | (((int)bit[2] & 0x00ff)<<16)\n                            | (((int)bit[1] & 0x00ff) << 8) | (int)bit[0] & 0x00ff;\n        // number of planes\n        int _planes = (((int)bit[13] & 0x00ff) << 8) | (int)bit[12] & 0x00ff;\n        // number of bits per pixel\n        int _nbit = (((int)bit[15] & 0x00ff) << 8) | (int)bit[14] & 0x00ff;\n        // compression factor : unused\n        // size of the image\n        int _size = (((int)bit[23] & 0x00ff) << 24) | (((int)bit[22] & 0x00ff) << 16)\n                        | (((int)bit[21] & 0x00ff) << 8) | (int)bit[20] & 0x00ff;\n        // infer the size of image if it is not given in the file\n        if (_size == 0) _size = ((((_width * _nbit) + 31) & ~31 ) >> 3) * _height;\n\n        // number of used colors\n        int _clrused = (((int)bit[35] & 0x00ff) << 24) | (((int)bit[34]&0x00ff) << 16)\n                        | (((int)bit[33] & 0x00ff) << 8) | (int)bit[32]&0x00ff;\n\n        // 24 bit image\n        if (_nbit == 24) {\n            // read the scan lines\n            int pad = (_size / _height) - _width * 3;\n            int offset = _headerSize; // begin to read data after header\n            // populate the int array\n            for (int j = 0; j < _height; j++) {\n                for (int i = 0; i < _width; i++) {\n                    bitI[_width * (_height - j - 1) + i] =\n                        (255 & 0x00ff) << 24 | (((int)bit[offset+2] & 0x00ff) << 16)\n                        | (((int)bit[offset+1] & 0x00ff) << 8) | (int)bit[offset] & 0x00ff;\n                    offset += 3;\n                }\n                offset += pad;\n            }\n        // 8 bit image\n        } else if (_nbit == 8) {\n            // Determine the number of colors\n            int nbColors = 0;\n            if (_clrused > 0) nbColors = _clrused;\n            else nbColors = (1 & 0x00ff) << 8;\n            // Read the palette colors.\n            int offset = _headerSize;\n            int[]  palette = new int[nbColors];\n            for (int i = 0; i < nbColors; i++) {\n                palette[i] = (255 & 0x00ff) << 24 | (((int)bit[offset+2] & 0x00ff) << 16)\n                            | (((int)bit[offset+1] & 0x00ff) << 8)\n                            | (int)bit[offset] & 0x00ff;\n                offset += 4;\n            }\n\n            // populate the int array\n            /* need to recalculate size because the offset used for palette must be substracted\n             * to overall size, else we will go after the end of the byte array...\n             */\n            _size = bit.length - offset;\n            int pad = (_size / _height) - _width;\n            for (int j = 0; j < _height; j++) {\n                for (int i = 0; i < _width; i++) {\n                    bitI[_width*(_height-j-1)+i] = palette [((int)bit[offset] & 0x00ff)];\n                    offset++;\n                }\n                offset += pad;\n            }\n        // black and white image\n        } else if (_nbit == 1) {\n            // 2 colors only (black and white image)\n            int nbColors = 2;\n            // Read the palette colors.\n            int offset = _headerSize;\n            int[]  palette = new int[nbColors];\n            for (int i = 0; i < nbColors; i++) {\n                palette[i] = (255 & 0x00ff) << 24 | (((int)bit[offset+2] & 0x00ff) << 16)\n                            | (((int)bit[offset+1] & 0x00ff) << 8)\n                            | (int)bit[offset] & 0x00ff;\n                offset += 4;\n            }\n\n            // populate the int array : each pixel corresponds to a bit in the byte array\n            int pos = 7;\n            byte currentByte = bit[offset];\n            // padded to long words\n            int pad = (_size / _height) - _width/8;\n            for (int j = 0; j < _height; j++) {\n                for (int i = 0; i < _width; i++) {\n                    if ((currentByte & (1 << pos)) != 0) bitI[_width*(_height-j-1)+i] = palette[1];\n                    else bitI[_width*(_height-j-1)+i] = palette[0];\n                    pos--;\n                    if (pos == -1) {\n                        pos = 7;\n                        offset++;\n                        if (offset < bit.length)\n                        \tcurrentByte = bit[offset];\n                    }\n                }\n                offset +=pad;\n                pos = 7;\n                if (offset < bit.length) currentByte = bit[offset];\n            }\n        }\n        raster.setDataElements(0, 0, _width, _height, bitI);\n        return img;\n    }"}, {"count": 1, "tags": [], "bug_id": 50056, "attachment_id": null, "id": 140553, "creation_time": "2010-10-07T07:54:31Z", "time": "2010-10-07T07:54:31Z", "creator": "helder.magalhaes@gmail.com", "text": "Thanks for reporting! :-)\n\n\n(In reply to comment #0)\n> Created an attachment (id=26136) [details]\n> The WMF file that failed\n\nIt's good to have the causer attached. ;-)\n\n\n> I use WMFTranscoder to convert WMF files to SVG.\n\nCould you provide the command-line used, if any? (If the conversion is triggered by Java source, I was mostly interested of any hints/parameters were passed to the transcoder).\n\n\n> The length of the array that caused the exception was 108248, so 1 byte after\n> the end was attempted to read.\n> \n> The problem was on line 194 in AbstractWMFPainter, where next byte for the next\n> iteration, which could be after the end, if there is no padding.\n> \n> Here is fixed code for the getImage(byte[]) method:\n\nI haven't yet checked for the solution, but the problem seems well evaluated. Could you turn your fix proposal into a patch? It's far better for reviewing and for allowing local testing (among other reasons). If you are unable to do that, please just state so. ;-)\n\n\nFinally, please provide some details on your current environment: at a minimum, I'd say operating system, Java version and Batik version/SVN source code revision.", "is_private": false}, {"count": 2, "tags": [], "bug_id": 50056, "attachment_id": 26141, "is_private": false, "id": 140597, "time": "2010-10-08T11:03:29Z", "creator": "a6537691@bofthew.com", "creation_time": "2010-10-08T11:03:29Z", "text": "Created attachment 26141\nA patch\n\nThe problem reproduces in the current trunk version, it is platform and java version idependent, but I use Windows XP and java 1.6. Problem was caused from command line. Here is a test case, you could merge it somewhere:\n\npackage test;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\n\nimport org.apache.batik.transcoder.TranscoderInput;\nimport org.apache.batik.transcoder.TranscoderOutput;\nimport org.apache.batik.transcoder.wmf.tosvg.WMFTranscoder;\n\nimport junit.framework.TestCase;\n\npublic class TestBug50056 extends TestCase {\n\n\tpublic void test() throws Exception {\n\t\tFile f = new File(\"D:/tmp/failingfile.wmf\");\n\t\tInputStream is = new FileInputStream(f);\n\t\t\n\t\tTranscoderInput wmfInput = new TranscoderInput(new FileInputStream(f));\n\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n\t\tTranscoderOutput svgOutput = new TranscoderOutput(baos);\n        WMFTranscoder wmfTranscoder = new WMFTranscoder();\n        wmfTranscoder.addTranscodingHint(WMFTranscoder.KEY_WIDTH, new Float(100));\n        wmfTranscoder.addTranscodingHint(WMFTranscoder.KEY_HEIGHT, new Float(100));\n        \n        // this fails with an ArrayIndexOutOfBoundsException if bug 50056 reproduces\n        wmfTranscoder.transcode(wmfInput, svgOutput);\n\t}\n\t\n}"}, {"count": 3, "tags": [], "bug_id": 50056, "text": "Created attachment 26142\nThe WMF file that failed\n\nI mistakenly uploaded a working file, here is non-working one.", "id": 140598, "time": "2010-10-08T11:06:18Z", "creator": "a6537691@bofthew.com", "creation_time": "2010-10-08T11:06:18Z", "is_private": false, "attachment_id": 26142}]