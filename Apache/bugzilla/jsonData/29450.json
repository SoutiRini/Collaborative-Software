[{"count": 0, "tags": [], "bug_id": 29450, "attachment_id": null, "is_private": false, "id": 58902, "time": "2004-06-09T02:12:14Z", "creator": "rici@ricilake.net", "creation_time": "2004-06-09T02:12:14Z", "text": "The following patch logs the location in the config file responsible for a mod_access denial. It appears \nthat it is very common for inexperienced Apache users to have difficulty untangling the various \n<directory> <location> and .htaccess configurations, particularly in distributions which divide the \nconfiguration system into multiple files.\n\nFollowing some suggestions from the apache-dev mailing list, I modified the patch to produce two log \nmessages; the first at level \"error\" which is identical to the current behaviour, and the second at level \n\"info\" with the debugging information. I don't regard this as ideal, but it is hard to find consensus. I was \ngoing to put it at level \"notice\" but it turns out that level \"notice\" is logged regardless of the  setting of \nLogLevel, which is slightly odd behaviour.\n\nThe patch is dependent on the filename/linenumber information stored in the struct directive for the \nmod_access directives. Since I couldn't convince myself that it was safe to store the pointer from that \nstructure, the patch copies the first 80 bytes of the filename into a static buffer. This is obviously not \nideal either, but it works and the storage impact is limited to 80*(number of mod_access directives).\n\nI think this same strategy could be extended to other directives which frequently frustrate new users, \nparticularly the \"AllowOverride\" and \"Options\" directives. But it would be useful to have some better \nunderstanding of the memory-pool strategy for struct directive. There is a note in the source code that \nthe filename/linenumber info should be removed from struct directive; I think this patch demonstrates \nthe utility of that information.\n\n---- patch follows ----\n\n--- httpd-2.0.49-orig/modules/aaa/mod_access.c\tMon Feb  9 15:53:14 2004\n+++ httpd-2.0.49/modules/aaa/mod_access.c\tTue Jun  8 20:55:00 2004\n@@ -39,6 +39,9 @@\n #include <netinet/in.h>\n #endif\n \n+/* If their config pathnames are longer than this, they deserve what they get */\n+#define AP_ACCESS_MAXPATH 80\n+\n enum allowdeny_type {\n     T_ENV,\n     T_ALL,\n@@ -54,6 +57,7 @@\n         apr_ipsubnet_t *ip;\n     } x;\n     enum allowdeny_type type;\n+    unsigned line_number;\n } allowdeny;\n \n /* things in the 'order' array */\n@@ -65,6 +69,8 @@\n     int order[METHODS];\n     apr_array_header_t *allows;\n     apr_array_header_t *denys;\n+    char filename[AP_ACCESS_MAXPATH];\n+    unsigned line_number;\n } access_dir_conf;\n \n module AP_MODULE_DECLARE_DATA access_module;\n@@ -80,10 +86,38 @@\n     }\n     conf->allows = apr_array_make(p, 1, sizeof(allowdeny));\n     conf->denys = apr_array_make(p, 1, sizeof(allowdeny));\n-\n+    conf->filename[0] = 0;\n+    conf->line_number = 0;\n     return (void *)conf;\n }\n \n+/* it's like you see this cute directive and you have to...*/\n+static void get_name_and_number(cmd_parms *cmd, char *name, unsigned *number)\n+{\n+  /* There is a comment saying directive->filename might go away. It is not at\n+   * all clear to me how we are supposed to get this info if it does\n+   * On the other hand, no other module seems to care\n+   */\n+  const char *fname = NULL;\n+  if (cmd->directive && cmd->directive->filename) {\n+    fname = cmd->directive->filename;\n+    *number = cmd->directive->line_num;\n+  }\n+  /* You gotta love the consistent naming convention */\n+  else if (cmd->config_file && cmd->config_file->name) {\n+    fname = cmd->config_file->name;\n+    *number = cmd->config_file->line_number;\n+  }\n+  if (fname) {\n+    if (apr_cpystrn(name, fname, AP_ACCESS_MAXPATH) == &name[AP_ACCESS_MAXPATH-1])\n+      name[AP_ACCESS_MAXPATH-2] = name[AP_ACCESS_MAXPATH-3] = name[AP_ACCESS_MAXPATH\n-4] = '.';\n+  } else {\n+    name[0] = name[1] = name[2] = '?'; name[3] = '\\0';\n+    *number = 0;\n+  }\n+}\n+\n+\n static const char *order(cmd_parms *cmd, void *dv, const char *arg)\n {\n     access_dir_conf *d = (access_dir_conf *) dv;\n@@ -102,6 +136,7 @@\n \tif (cmd->limited & (AP_METHOD_BIT << i))\n \t    d->order[i] = o;\n \n+    get_name_and_number(cmd, d->filename, &d->line_number);\n     return NULL;\n }\n \n@@ -122,6 +157,8 @@\n     a->x.from = where;\n     a->limited = cmd->limited;\n \n+    get_name_and_number(cmd, d->filename, &a->line_number);\n+\n     if (!strncasecmp(where, \"env=\", 4)) {\n \ta->type = T_ENV;\n \ta->x.from += 4;\n@@ -193,7 +230,7 @@\n \treturn 0;\n }\n \n-static int find_allowdeny(request_rec *r, apr_array_header_t *a, int method)\n+static allowdeny *find_allowdeny(request_rec *r, apr_array_header_t *a, int method)\n {\n \n     allowdeny *ap = (allowdeny *) a->elts;\n@@ -209,16 +246,16 @@\n \tswitch (ap[i].type) {\n \tcase T_ENV:\n \t    if (apr_table_get(r->subprocess_env, ap[i].x.from)) {\n-\t\treturn 1;\n+\t\treturn &ap[i];\n \t    }\n \t    break;\n \n \tcase T_ALL:\n-\t    return 1;\n+\t    return &ap[i];\n \n \tcase T_IP:\n             if (apr_ipsubnet_test(ap[i].x.ip, r->connection->remote_addr)) {\n-                return 1;\n+                return &ap[i];\n             }\n             break;\n \n@@ -236,7 +273,7 @@\n \t    }\n \n \t    if ((gothost == 2) && in_domain(ap[i].x.from, remotehost))\n-\t\treturn 1;\n+\t\treturn &ap[i];\n \t    break;\n \n \tcase T_FAIL:\n@@ -245,13 +282,14 @@\n \t}\n     }\n \n-    return 0;\n+    return NULL;\n }\n \n static int check_dir_access(request_rec *r)\n {\n     int method = r->method_number;\n     int ret = OK;\n+    allowdeny *which = NULL;\n     access_dir_conf *a = (access_dir_conf *)\n         ap_get_module_config(r->per_dir_config, &access_module);\n \n@@ -259,18 +297,18 @@\n         ret = HTTP_FORBIDDEN;\n         if (find_allowdeny(r, a->allows, method))\n             ret = OK;\n-        if (find_allowdeny(r, a->denys, method))\n+        if (which = find_allowdeny(r, a->denys, method))\n             ret = HTTP_FORBIDDEN;\n     }\n     else if (a->order[method] == DENY_THEN_ALLOW) {\n-        if (find_allowdeny(r, a->denys, method))\n+        if (which = find_allowdeny(r, a->denys, method))\n             ret = HTTP_FORBIDDEN;\n         if (find_allowdeny(r, a->allows, method))\n             ret = OK;\n     }\n     else {\n         if (find_allowdeny(r, a->allows, method)\n-            && !find_allowdeny(r, a->denys, method))\n+            && !(which = find_allowdeny(r, a->denys, method)))\n             ret = OK;\n         else\n             ret = HTTP_FORBIDDEN;\n@@ -281,6 +319,14 @@\n         ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n             \"client denied by server configuration: %s\",\n             r->filename);\n+        if (which) \n+          ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n+            \"client denied by deny directive at line %d of %s\",\n+                        which->line_number, a->filename);\n+        else\n+          ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n+            \"client denied by order directive at line %d of %s\",\n+                        a->line_number, a->filename);\n     }\n \n     return ret;"}, {"count": 1, "tags": [], "creator": "rici@ricilake.net", "attachment_id": null, "text": "Here is sample output, with LogLevel set to info. What is illustrated here is that:\n\n-- .htaccess files are identified\n-- deny directives are logged unless there isn't one (i.e. default is deny) in which case\n     the order directive is logged.\n\n[Tue Jun 08 20:57:18 2004] [error] [client 192.168.1.65] client denied by server configuration: /opt/\napache2a/htdocs/foo/\n[Tue Jun 08 20:57:18 2004] [info] [client 192.168.1.65] client denied by deny directive at line 2 of /opt/\napache2a/htdocs/foo/.htaccess\n[Tue Jun 08 20:57:26 2004] [error] [client 192.168.1.65] client denied by server configuration: /opt/\napache2a/htdocs/bar\n[Tue Jun 08 20:57:26 2004] [info] [client 192.168.1.65] client denied by order directive at line 362 of /\nopt/apache2a/conf/httpd.conf\n[Tue Jun 08 20:58:18 2004] [error] [client 192.168.1.65] client denied by server configuration: /opt/\napache2a/htdocs/foo/.htaccess\n[Tue Jun 08 20:58:18 2004] [info] [client 192.168.1.65] client denied by deny directive at line 411 of /\nopt/apache2a/conf/httpd.conf\n", "id": 58903, "time": "2004-06-09T02:15:30Z", "bug_id": 29450, "creation_time": "2004-06-09T02:15:30Z", "is_private": false}, {"count": 2, "tags": [], "bug_id": 29450, "attachment_id": null, "is_private": false, "id": 58946, "time": "2004-06-09T16:59:39Z", "creator": "slive@apache.org", "creation_time": "2004-06-09T16:59:39Z", "text": "I can't provide code review for the most important issue here (the handling of\nstorage), but I can confirm that this would be very helpful for debugging access\ncontrol problems.\n\nI also support having it available always, rather than just at level \"info\"\n(although I am the one who suggested the separate-logging approach)."}, {"count": 3, "tags": [], "bug_id": 29450, "attachment_id": null, "is_private": false, "id": 75935, "time": "2005-06-03T04:22:58Z", "creator": "chip@force-elite.com", "creation_time": "2005-06-03T04:22:58Z", "text": "I completely agree that logging of this should be more verbose.\n\nRici, do you think you can do an updated patch?"}]