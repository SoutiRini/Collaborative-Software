[{"count": 0, "tags": [], "bug_id": 43136, "attachment_id": null, "is_private": false, "id": 106805, "time": "2007-08-15T14:10:06Z", "creator": "rfrovarp@apache.org", "creation_time": "2007-08-15T14:10:06Z", "text": "Still having some issues with multiple people trying to edit the sitetree at the\nsame time, or close anyway. I login with two users. Have both create a new xhtml\npage. Put everything in, hit create. One will create, one will throw this error:\n\nThe object [node lenya://lenya/pubs/default/content/authoring/sitetree.xml] was\nmodified after it has been locked.\n\nIf I was creating an xhtml document, hitting cancel will ask me if I want to\ncreate the document I was trying to create. Hitting cancel on a media type\nthrows a NPE that I will take a look at, or post a different bug. \n\nI can also get this sitetree modified error to fire by going to create a page.\nNudging from a different session, then hitting create on my page creation. \n\nIt would appear that we need either stronger or weaker locking. Either we\nstrongly lock the sitetree on any operation, including going to create. Or we\ndon't lock the sitetree until create is hit. People can't fill out the create\nform as quickly as a script can. At least it is no longer creating entries in\nthe sitetree without the content being present."}, {"count": 1, "tags": [], "creator": "rfrovarp@apache.org", "text": "Here's what I can find in the logs:\n\nSocketListener0-5 DEBUG nodefactory.source - Get OutputStream for\nlenya://lenya/pubs/default/content/authoring/bdcca230-4b6f-11dc-a878-d3883d520e6a/en.meta\nSocketListener0-5 DEBUG nodefactory.source - Get OutputStream for\nlenya://lenya/pubs/default/content/authoring/bdcca230-4b6f-11dc-a878-d3883d520e6a/en.meta\nSocketListener0-5 DEBUG core.manager - ComponentFactory creating new instance of\norg.apache.lenya.cms.site.tree2.TreeSiteManager.\nSocketListener0-5 DEBUG core.manager - logger attribute is lenya.site\nSocketListener0-5 DEBUG core.manager - IdentityMapImpl::get() looked up type\n[site], key [default:authoring] in map, is it there ? true\nSocketListener0-5 DEBUG core.manager - ComponentFactory decommissioning instance\nof org.apache.lenya.cms.site.tree2.TreeSiteManager.\nSocketListener0-5 DEBUG core.manager - IdentityMapImpl::get() looked up type\n[publication], key [default] in map, is it there ? true\nSocketListener0-5 DEBUG lenya.site - Setting parameter\n[private.defaultTargetUrl] = [/default/authoring/index/richard.html]\nSocketListener0-5 DEBUG core.manager - ComponentFactory decommissioning instance\nof org.apache.lenya.cms.publication.DocumentManagerImpl.\nSocketListener0-5 DEBUG core.manager - UnitOfWorkImpl::commit() called\nSocketListener0-5 ERROR lenya.site - Could not commit usecase\n[sitemanagement.create]: The object [node\nlenya://lenya/pubs/default/content/authoring/sitetree.xml] was modified after it\nhas \nbeen locked.\nSocketListener0-5 DEBUG lenya.site - AbstractUsecase::hasErrors() called,\nreturning true\nSocketListener0-5 DEBUG lenya.site - AbstractUsecase::hasErrors() called,\nreturning true\nSocketListener0-5 DEBUG core.manager - ComponentFactory decommissioning instance\nof org.apache.lenya.cms.site.usecases.CreateDocument.\nSocketListener0-5 DEBUG flow - usecases.js::executeUsecase() : Creating view and\ncontinuation, calling Cocoon with viewUri =\n[usecases-view/nomenu/modules/sitemanagement/usecases/site/creat\ne.jx]\nSocketListener0-5 DEBUG flow.manager - WK: Created continuation\n363b2a4b345e555539214d40443d6d46685c495f\nSocketListener0-5 INFO  sitemap - Redirecting to\n'cocoon:/usecases-view/nomenu/modules/sitemanagement/usecases/site/create.jx'\nSocketListener0-5 DEBUG sitemap - Setting uri (prefix=null,\nuris=usecases-view/nomenu/modules/sitemanagement/usecases/site/create.jx)\nSocketListener0-5 DEBUG core.manager - Resolving\n'file:///home/rfrovarp/asf/lenya-1.4.x/build/lenya/webapp/lenya/modules/usecase/'\nwith base 'file:///home/rfrovarp/asf/lenya-1.4.x/build/len\nya/webapp/lenya/modules/usecase/' in context\n'file:/home/rfrovarp/asf/lenya-1.4.x/build/lenya/webapp/'\nSocketListener0-5 DEBUG core.manager - Resolved to systemID :\nfile:///home/rfrovarp/asf/lenya-1.4.x/build/lenya/webapp/lenya/modules/usecase/\nSocketListener0-5 DEBUG sitemap - Matcher 'wildcard' matched pattern\n'usecases-view/*/**' at <map:match> -\nfile:///home/rfrovarp/asf/lenya-1.4.x/build/lenya/webapp/lenya/modules/usecase/use\ncase.xmap:56:47\nSocketListener0-5 DEBUG sitemap - \nCurrent Sitemap Parameters:\nLEVEL 2\nPARAM: '2' VALUE: 'modules/sitemanagement/usecases/site/create.jx'\nPARAM: '0' VALUE:\n'usecases-view/nomenu/modules/sitemanagement/usecases/site/create.jx'\nPARAM: '1' VALUE: 'nomenu'\nLEVEL 1\nPARAM: '../1' VALUE: '8a1d6e40024a194b168e845b498e350f20207b89'\n\nSocketListener0-5 DEBUG sitemap - ComponentFactory creating new instance of\norg.apache.cocoon.components.pipeline.impl.NonCachingProcessingPipeline.\nSocketListener0-5 DEBUG sitemap - no logger attribute available, using standard\nlogger\nSocketListener0-5 DEBUG sitemap - Created a new\norg.apache.cocoon.components.pipeline.impl.NonCachingProcessingPipeline from the\nobject factory.\nSocketListener0-5 DEBUG sitemap - Got a\norg.apache.cocoon.components.pipeline.impl.NonCachingProcessingPipeline from the\npool.\nSocketListener0-5 DEBUG sitemap - Got a\norg.apache.cocoon.generation.JXTemplateGenerator from the pool.\nSocketListener0-5 DEBUG sitemap - ComponentFactory creating new instance of\norg.apache.cocoon.ajax.BrowserUpdateTransformer.\n", "id": 106807, "time": "2007-08-15T14:18:45Z", "bug_id": 43136, "creation_time": "2007-08-15T14:18:45Z", "is_private": false, "attachment_id": null}, {"count": 2, "tags": [], "bug_id": 43136, "attachment_id": null, "is_private": false, "id": 106812, "time": "2007-08-15T16:05:03Z", "creator": "andreas@apache.org", "creation_time": "2007-08-15T16:05:03Z", "text": "(In reply to comment #0)\n\n> It would appear that we need either stronger or weaker locking. Either we\n> strongly lock the sitetree on any operation, including going to create. Or we\n> don't lock the sitetree until create is hit. People can't fill out the create\n> form as quickly as a script can. At least it is no longer creating entries in\n> the sitetree without the content being present.\n\nStronger locking would mean to check out the sitetree repo node. You can do this\nby setting the usecase transaction policy to pessimistic (see usecase framework\ndocs). This increases the danger of a checked-out sitetree which nobody can edit\nuntil a check-in is forced.\n\nWeaker locking is dangerous. Imagine the following scenario:\n\n* Alice opens the form to create /foo/bar\n* Bob deletes /foo\n* Alice hits \"OK\"\n\nWith the current setting, Alice's transaction cannot be committed. If we don't\ncheck for sitetree modifications, Alice's transaction would either override\nBob's changes to the sitetree (resulting in stale sitetree nodes) or run into\nserious trouble because the parent doesn't exist anymore.\n\nIf we don't lock the sitetree, we have to implement the usecases very carefully:\n\n* reload the sitetree before committing\n* check out the sitetree\n* re-check the preconditions (parent exists, no node with same name)\n* apply the changes\n* commit the transaction\n* check in the sitetree\n"}, {"count": 3, "tags": [], "bug_id": 43136, "attachment_id": null, "is_private": false, "id": 106825, "time": "2007-08-16T07:52:36Z", "creator": "rfrovarp@apache.org", "creation_time": "2007-08-16T07:52:36Z", "text": "(In reply to comment #2)\n>  \n> Stronger locking would mean to check out the sitetree repo node. You can do this\n> by setting the usecase transaction policy to pessimistic (see usecase framework\n> docs). This increases the danger of a checked-out sitetree which nobody can edit\n> until a check-in is forced.\n> \n\nI agree, this doesn't sound like a good plan, people will hit back out of create\nand lock the sitetree causing huge amounts of issue.\n\n> Weaker locking is dangerous. Imagine the following scenario:\n> \n> * Alice opens the form to create /foo/bar\n> * Bob deletes /foo\n> * Alice hits \"OK\"\n> \n> With the current setting, Alice's transaction cannot be committed. If we don't\n> check for sitetree modifications, Alice's transaction would either override\n> Bob's changes to the sitetree (resulting in stale sitetree nodes) or run into\n> serious trouble because the parent doesn't exist anymore.\n> \n\nYes, this could happen. But the alternative is worse. On a busy site (like when\nwe're doing training with 20+ people at a time), a person may never be able to\ncreate a page. All of the atomic sitetree actions (nudge, delete, restore, etc)\ncan be taking place much quicker than someone can fill out the form. They get an\nerror message. Fill it out again, but someone else beat them to the punch. We\ndon't have corruption, and it makes life easy for us, but makes it very bad for\nthem. Chances are in many cases, actions will be taking part on different of the\ntree anyway. \n\n> If we don't lock the sitetree, we have to implement the usecases very carefully:\n> \n> * reload the sitetree before committing\n> * check out the sitetree\n> * re-check the preconditions (parent exists, no node with same name)\n> * apply the changes\n> * commit the transaction\n> * check in the sitetree\n> \n\nThis sounds good to me. I don't see that we have much of an option when it comes\nto usecases that modify the sitetree and wait for user input. We have to be able\nto support multiple users at the same time, and these usecases only do through\nluck or persistence of the user. "}, {"count": 4, "tags": [], "creator": "andreas@apache.org", "attachment_id": null, "id": 106961, "time": "2007-08-21T07:00:00Z", "bug_id": 43136, "creation_time": "2007-08-21T07:00:00Z", "is_private": false, "text": "The big problem is that we handle the sitetree as a single object. This way, we\ncan only save the sitetree as a whole. Therefore we need to lock it to avoid\noverriding other people's changes, even if the changes don't affect the same\nsubtree.\n\nIMO the only reasonable solution is allowing to commit single nodes. This would\nmean that the sitetree is not handled as a Transactionable, but single nodes."}, {"count": 5, "tags": [], "text": "I see two approaches for committing single nodes:\n\n1. Store each node in a separate repository node.\n\n2. Let the sitetree live in the background and load only single nodes in the\nsession. The nodes could be merged back (committed) into the sitetree if the\nhasChanged() method returns false (i.e., nothing in the node (flat lock) or in\nthe subtree (deep lock) has changed).", "attachment_id": null, "id": 106962, "creator": "andreas@apache.org", "time": "2007-08-21T07:05:08Z", "bug_id": 43136, "creation_time": "2007-08-21T07:05:08Z", "is_private": false}, {"count": 6, "tags": [], "text": "(In reply to comment #2)\n\n> If we don't lock the sitetree, we have to implement the usecases\n> very carefully:\n> \n> * reload the sitetree before committing\n> * check out the sitetree\n> * re-check the preconditions (parent exists, no node with same name)\n> * apply the changes\n> * commit the transaction\n> * check in the sitetree\n \nI just tried that, but it is quite a complex change. IMO the single-node locking\napproach would be much cleaner and much more generic, though I don't know how\ncomplex the implementation will be.\n", "attachment_id": null, "id": 106965, "creator": "andreas@apache.org", "time": "2007-08-21T07:52:43Z", "bug_id": 43136, "creation_time": "2007-08-21T07:52:43Z", "is_private": false}, {"count": 7, "tags": [], "bug_id": 43136, "attachment_id": null, "is_private": false, "id": 107017, "time": "2007-08-22T02:11:05Z", "creator": "andreas@apache.org", "creation_time": "2007-08-22T02:11:05Z", "text": "Now the optimistic usecases lock their objects right before the execution.\nActually this is not a correct behaviour from the user's point of view - if she\nrelied on the state of a resource when the confirmation screen is shown, the\nresource might now change while she fills in the form.\n\nI see this rather as a workaround until we can lock single sitetree nodes. The\nerror (\"object has been modified\") can still occur if another session is\ncommitted while the usecase is executed, but the probability is reduced. To\navoid even this, we could synchronize AbstractUsecase.execute() globally, but I\nwouldn't recommend this."}, {"count": 8, "tags": [], "bug_id": 43136, "is_private": false, "text": "It doesn't appear to be checking conditions. Add spaces to the end of a node\nname upon creation to see what I mean.", "id": 107031, "time": "2007-08-22T08:09:48Z", "creator": "rfrovarp@apache.org", "creation_time": "2007-08-22T08:09:48Z", "attachment_id": null}, {"count": 9, "tags": [], "bug_id": 43136, "attachment_id": null, "is_private": false, "id": 107037, "time": "2007-08-22T08:59:53Z", "creator": "andreas@apache.org", "creation_time": "2007-08-22T08:59:53Z", "text": "(In reply to comment #8)\n> It doesn't appear to be checking conditions. Add spaces to the end of a node\n> name upon creation to see what I mean.\n\nThat's a bug in the CreateDocument usecase:\n\nString nodeName = getParameterAsString(NODE_NAME).trim();\nif (nodeName.equals(\"\")) {\n   addErrorMessage(\"missing-node-name\");\n} else if (!builder.isValidDocumentName(nodeName)) {\n   addErrorMessage(\"node-name-special-characters\");\n}\n"}, {"count": 10, "tags": [], "bug_id": 43136, "attachment_id": null, "is_private": false, "id": 107039, "time": "2007-08-22T09:13:46Z", "creator": "andreas@apache.org", "creation_time": "2007-08-22T09:13:46Z", "text": "(In reply to comment #8)\n> It doesn't appear to be checking conditions. Add spaces to the end of a node\n> name upon creation to see what I mean.\n\nThis should be OK now (spaces properly stripped)."}, {"count": 11, "tags": [], "bug_id": 43136, "attachment_id": null, "is_private": false, "id": 107464, "time": "2007-08-30T04:57:50Z", "creator": "andreas@apache.org", "creation_time": "2007-08-30T04:57:50Z", "text": "To summarize my thoughts on this issue: The only reasonable way to deal with\nthis is to allow locking and committing single site nodes and subtrees. That\nwill be a complex change and should be postponed to 2.1 or later.\n\nRichard, is this OK with you?\nAre there any other ideas?"}, {"count": 12, "tags": [], "text": "The current behavior is acceptable. Users can create pages without having to be\nlightening quick or lucky. With cuts, deletes, and the like the new page might\nhave a weird location as a result, but it was created. It does need to be fully\nfixed in a later version. However, the current implementation provides good\nusability.", "attachment_id": null, "id": 107472, "creator": "rfrovarp@apache.org", "time": "2007-08-30T07:18:55Z", "bug_id": 43136, "creation_time": "2007-08-30T07:18:55Z", "is_private": false}, {"count": 13, "tags": [], "creator": "rfrovarp@apache.org", "is_private": false, "text": "I take that back. Nodes are disappearing between revisions. I'm going to upload\ntwo version of the sitetree. No deletes or archives were done. Only page\ncreation, and some of them were lost.", "id": 107492, "time": "2007-08-30T14:15:14Z", "bug_id": 43136, "creation_time": "2007-08-30T14:15:14Z", "attachment_id": null}, {"count": 14, "tags": [], "text": "Created attachment 20744\nfirst sitetree", "attachment_id": 20744, "id": 107493, "creator": "rfrovarp@apache.org", "time": "2007-08-30T14:15:52Z", "bug_id": 43136, "creation_time": "2007-08-30T14:15:52Z", "is_private": false}, {"count": 15, "tags": [], "bug_id": 43136, "attachment_id": 20745, "is_private": false, "id": 107494, "time": "2007-08-30T14:16:59Z", "creator": "rfrovarp@apache.org", "creation_time": "2007-08-30T14:16:59Z", "text": "Created attachment 20745\nsecond site tree\n\nNext iteration of tree with only page creations done. Pages are being lost."}, {"count": 16, "tags": [], "creator": "rfrovarp@apache.org", "text": "Created attachment 20746\nbefore the first sitetree", "id": 107496, "time": "2007-08-30T14:33:04Z", "bug_id": 43136, "creation_time": "2007-08-30T14:33:04Z", "is_private": false, "attachment_id": 20746}, {"count": 17, "tags": [], "text": "Created attachment 20747\nthe sitetree rcml file", "attachment_id": 20747, "id": 107497, "creator": "rfrovarp@apache.org", "time": "2007-08-30T14:33:29Z", "bug_id": 43136, "creation_time": "2007-08-30T14:33:29Z", "is_private": false}, {"count": 18, "tags": [], "creator": "andreas@apache.org", "text": "Maybe there is a timespan between the loading and the locking of the sitetree in\na session. If the sitetree is changed between these events, the changes will be\noverwritten:\n\n1. Session A loads sitetree (revision 1)\n2. Session A adds node 1.1\n3. Session B loads sitetree (revision 1)\n4. Session A saves sitetree (check-in of revision 2)\n5. Session B locks sitetree\n6. Session B adds node 1.2\n7. Session B saves sitetree (check-in of revision 3)\n\nAt this point, node 1.1 will be removed from the sitetree.\n\nWe have to avoid the timespan between loading and locking. Actually I can't\nimagine how this occurs since the locking of the sitetree repo node is the first\naction when the transaction is started, it should happen before the tree data\nare loaded. I'll add a check and run some tests.", "id": 107530, "time": "2007-08-31T03:39:54Z", "bug_id": 43136, "creation_time": "2007-08-31T03:39:54Z", "is_private": false, "attachment_id": null}, {"count": 19, "tags": [], "text": "(In reply to comment #18)\n> Maybe there is a timespan between the loading and the locking of\n> the sitetree in a session.\n\nI added a check for this (rev. 571429), but couldn't yet confirm that it occurs.", "attachment_id": null, "id": 107532, "creator": "andreas@apache.org", "time": "2007-08-31T03:59:48Z", "bug_id": 43136, "creation_time": "2007-08-31T03:59:48Z", "is_private": false}, {"count": 20, "tags": [], "bug_id": 43136, "attachment_id": null, "is_private": false, "id": 107534, "time": "2007-08-31T04:03:12Z", "creator": "andreas@apache.org", "creation_time": "2007-08-31T04:03:12Z", "text": "Apparently the problem is caused by something else. I just ran a test:\n\n- 5 threads\n- each creating 10 documents\n\n6 commits failed (sitetree was modified by another session).\nAfter the test, 41 nodes had been created.\nThis means that 3 nodes didn't end up in the final sitetree."}, {"count": 21, "tags": [], "creator": "andreas@apache.org", "attachment_id": null, "id": 107535, "time": "2007-08-31T04:08:52Z", "bug_id": 43136, "creation_time": "2007-08-31T04:08:52Z", "is_private": false, "text": "Interestingly, there weren't any 404s during the test, which means that the\ninserted nodes had been available during the next request."}, {"count": 22, "tags": [], "text": "Yeah, one more detail from the session that showed this happening yesterday.\nPeople were creating children of their particular node. They then were able to\nget into the editor and create links to those children, using the insert link\nfrom FCK. Then some point after inserting the link and the end of the day, those\nnodes would disappear. So, we're not talking about quick race conditions, we're\ntalking the span of a minute or more where the nodes were there, then they were not.", "attachment_id": null, "id": 107538, "creator": "rfrovarp@apache.org", "time": "2007-08-31T05:31:21Z", "bug_id": 43136, "creation_time": "2007-08-31T05:31:21Z", "is_private": false}, {"count": 23, "tags": [], "bug_id": 43136, "attachment_id": null, "text": "(In reply to comment #21)\n> Interestingly, there weren't any 404s during the test, which means that the\n> inserted nodes had been available during the next request.\n\nI re-ran the test. There weren't any 404s because the nodes haven't been created\nin the first place. The usecase couldn't be excecuted because involved objects\nhave been checked out. So far, I couldn't detect any unpredictable behaviour.", "id": 107539, "time": "2007-08-31T05:32:13Z", "creator": "andreas@apache.org", "creation_time": "2007-08-31T05:32:13Z", "is_private": false}, {"count": 24, "tags": [], "creator": "andreas@apache.org", "is_private": false, "text": "(In reply to comment #22)\n> Yeah, one more detail from the session that showed this happening yesterday.\n> People were creating children of their particular node. They then were able to\n> get into the editor and create links to those children, using the insert link\n> from FCK. Then some point after inserting the link and the end of the day, those\n> nodes would disappear. So, we're not talking about quick race conditions, we're\n> talking the span of a minute or more where the nodes were there, then they\nwere not.\n\nInteresting, thanks for the clarification! This probably means I don't have to\ndig deeper in the transaction code. Maybe there's a bug in the sitetree?\n", "id": 107540, "time": "2007-08-31T05:33:19Z", "bug_id": 43136, "creation_time": "2007-08-31T05:33:19Z", "attachment_id": null}, {"count": 25, "tags": [], "bug_id": 43136, "attachment_id": null, "is_private": false, "id": 107541, "time": "2007-08-31T05:41:25Z", "creator": "rfrovarp@apache.org", "creation_time": "2007-08-31T05:41:25Z", "text": "(In reply to comment #24)\n> (In reply to comment #22)\n> > Yeah, one more detail from the session that showed this happening yesterday.\n> > People were creating children of their particular node. They then were able to\n> > get into the editor and create links to those children, using the insert link\n> > from FCK. Then some point after inserting the link and the end of the day, those\n> > nodes would disappear. So, we're not talking about quick race conditions, we're\n> > talking the span of a minute or more where the nodes were there, then they\n> were not.\n> \n> Interesting, thanks for the clarification! This probably means I don't have to\n> dig deeper in the transaction code. Maybe there's a bug in the sitetree?\n> \n\nOne symptom of this is you end up with more directories under authoring than\nUUID values in sitetree.xml\nls -l|grep drwx|wc\ncat sitetree.xml|grep UUID|wc\n\nIf everything is right, those numbers should be equal, but they weren't. I did\nfind one thing in SiteTreeImpl I think it was. I'll commit that once I get into\nwork in about an hour. How many sitetrees are kept around? I saw that\nSiteTreeImpl was being frequently created as a new object for the same person."}, {"count": 26, "tags": [], "bug_id": 43136, "attachment_id": null, "text": "(In reply to comment #25)\n> How many sitetrees are kept around? I saw that SiteTreeImpl was being\n> frequently created as a new object for the same person.\n\nA SiteTreeImpl object is created for each modifiable session which requests it,\ni.e. everytime someone executes a sitetree-related usecase. The unmodifiable\nsessions use a single instance from the SharedItemStore.\n\nIn a future version we could optimize that by only creating single sitetree\nnodes in modifiable sessions. This would also help to solve the locking issue\n(see comment #4).", "id": 107543, "time": "2007-08-31T05:59:23Z", "creator": "andreas@apache.org", "creation_time": "2007-08-31T05:59:23Z", "is_private": false}, {"count": 27, "tags": [], "bug_id": 43136, "is_private": false, "text": "(In reply to comment #25)\n> \n> I did\n> find one thing in SiteTreeImpl I think it was. I'll commit that once I get into\n> work in about an hour. \n\nI've fixed the synchronization issue I found in r571466. Don't know the effect\nit will have with this bug.\n", "id": 107548, "time": "2007-08-31T07:17:01Z", "creator": "rfrovarp@apache.org", "creation_time": "2007-08-31T07:17:01Z", "attachment_id": null}, {"count": 28, "tags": [], "bug_id": 43136, "attachment_id": null, "text": "(In reply to comment #26)\n> (In reply to comment #25)\n> > How many sitetrees are kept around? I saw that SiteTreeImpl was being\n> > frequently created as a new object for the same person.\n> \n> A SiteTreeImpl object is created for each modifiable session which requests it,\n> i.e. everytime someone executes a sitetree-related usecase. The unmodifiable\n> sessions use a single instance from the SharedItemStore.\n> \n> In a future version we could optimize that by only creating single sitetree\n> nodes in modifiable sessions. This would also help to solve the locking issue\n> (see comment #4).\n\nOkay, and SiteTreeImpl is the object that really controls the sitetree? And it\ngets its information from sitetree.xml? How is synchronization to this file handled?", "id": 107549, "time": "2007-08-31T07:19:08Z", "creator": "rfrovarp@apache.org", "creation_time": "2007-08-31T07:19:08Z", "is_private": false}, {"count": 29, "tags": [], "creator": "andreas@apache.org", "attachment_id": null, "id": 107550, "time": "2007-08-31T07:25:44Z", "bug_id": 43136, "creation_time": "2007-08-31T07:25:44Z", "is_private": false, "text": "(In reply to comment #28)\n\n> Okay, and SiteTreeImpl is the object that really controls the sitetree?\n\nYes, it allows to manipulate the tree.\n\n> And it gets its information from sitetree.xml?\n> How is synchronization to this file handled?\n\nThe write access to all files (including RCML files) is synchronized via the\nglobal transaction lock in SessionImpl.commit()."}, {"count": 30, "tags": [], "creator": "rfrovarp@apache.org", "is_private": false, "text": "(In reply to comment #24)\n> (In reply to comment #22)\n> > Yeah, one more detail from the session that showed this happening yesterday.\n> > People were creating children of their particular node. They then were able to\n> > get into the editor and create links to those children, using the insert link\n> > from FCK. Then some point after inserting the link and the end of the day, those\n> > nodes would disappear. So, we're not talking about quick race conditions, we're\n> > talking the span of a minute or more where the nodes were there, then they\n> were not.\n> \n> Interesting, thanks for the clarification! This probably means I don't have to\n> dig deeper in the transaction code. Maybe there's a bug in the sitetree?\n> \n\nTaking another look at my data, I have one node that was not deleted that shows\nup in sitetree.xml.*.bak files from 15:30 to 15:52 local through 40 files\nspanning 55 revisions. Then after that it no longer is in the sitetree.xml or\nbak files.", "id": 107551, "time": "2007-08-31T07:26:54Z", "bug_id": 43136, "creation_time": "2007-08-31T07:26:54Z", "attachment_id": null}, {"count": 31, "tags": [], "creator": "rfrovarp@apache.org", "text": "Created attachment 20751\nsitetree files\n\nUse dab31720-5737-11dc-8bd5-9987c5e5e713 as the node being talked about in\ncomment #30", "id": 107552, "time": "2007-08-31T07:28:26Z", "bug_id": 43136, "creation_time": "2007-08-31T07:28:26Z", "is_private": false, "attachment_id": 20751}, {"count": 32, "tags": [], "bug_id": 43136, "attachment_id": null, "text": "(In reply to comment #18)\n> Maybe there is a timespan between the loading and the locking of the sitetree in\n> a session. If the sitetree is changed between these events, the changes will be\n> overwritten:\n> \n> 1. Session A loads sitetree (revision 1)\n> 2. Session A adds node 1.1\n> 3. Session B loads sitetree (revision 1)\n> 4. Session A saves sitetree (check-in of revision 2)\n> 5. Session B locks sitetree\n> 6. Session B adds node 1.2\n> 7. Session B saves sitetree (check-in of revision 3)\n> \n> At this point, node 1.1 will be removed from the sitetree.\n> \n> We have to avoid the timespan between loading and locking. Actually I can't\n> imagine how this occurs since the locking of the sitetree repo node is the first\n> action when the transaction is started, it should happen before the tree data\n> are loaded. I'll add a check and run some tests.\n\nr571429 said you added code to detect issues related to this comment. Do a clean\nbuild, import into default publication, submit a page, then publish it. It will\nalways trip your detection code. I just rolled back to that revision and am\nstill having trouble, so it's not anything I've done today to make this trip.\nGiven the time line, it might have something to do with publishing pages.", "id": 107572, "time": "2007-08-31T14:06:19Z", "creator": "rfrovarp@apache.org", "creation_time": "2007-08-31T14:06:19Z", "is_private": false}, {"count": 33, "tags": [], "creator": "rfrovarp@apache.org", "is_private": false, "text": "(In reply to comment #32)\n> Given the time line, it might have something to do with publishing pages.\n\nForgot to include the node it is complaining about:\nlenya://lenya/pubs/default/content/authoring/sitetree.xml\n\nHowever, it doesn't sound like people were publishing or even able to publish in\nthe session yesterday as their parents hadn't been published.", "id": 107573, "time": "2007-08-31T14:10:14Z", "bug_id": 43136, "creation_time": "2007-08-31T14:10:14Z", "attachment_id": null}, {"count": 34, "tags": [], "text": "(In reply to comment #33)\n> (In reply to comment #32)\n> > Given the time line, it might have something to do with publishing pages.\n> \n> Forgot to include the node it is complaining about:\n> lenya://lenya/pubs/default/content/authoring/sitetree.xml\n\nInteresting, the authoring sitetree shouldn't have to be locked during\npublishing. I could imagine that it occurs with the live sitetree as well,\nbecause IIRC it isn't locked. \n\n", "attachment_id": null, "id": 107576, "creator": "andreas@apache.org", "time": "2007-08-31T15:15:35Z", "bug_id": 43136, "creation_time": "2007-08-31T15:15:35Z", "is_private": false}, {"count": 35, "tags": [], "creator": "rfrovarp@apache.org", "is_private": false, "text": "When an item is queried out of an IdentityMap, it is put into its list of\nobjects to know. What I see happening is the editor's getNodesToLock triggers a\nquery to check if a document node is being requested which eventually goes to\nSessionImpl.getRepositoryItem which calls identityMap.get(). Then it shows up\nunder savePersistables in SessionImpl. To see how it is being called, see the\ntrace below. The line numbers might be off due to my crude debugging statements.\nThe trace is generated by creating an exception object and is not something in\nthe trunk.\n\nat\norg.apache.lenya.cms.repository.SessionImpl.getRepositoryItem(SessionImpl.java:208)\nat\norg.apache.lenya.cms.site.tree2.SiteTreeImpl.getRepositoryNode(SiteTreeImpl.java:433)\nat org.apache.lenya.cms.site.tree2.SiteTreeImpl.load(SiteTreeImpl.java:99)\nat org.apache.lenya.cms.site.tree2.SiteTreeImpl.contains(SiteTreeImpl.java:334)\nat\norg.apache.lenya.cms.publication.DefaultDocumentBuilder.isDocument(DefaultDocumentBuilder.java:111)\nat sun.reflect.GeneratedMethodAccessor40.invoke(Unknown Source)\nat\nsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\nat java.lang.reflect.Method.invoke(Method.java:597)\nat\norg.apache.avalon.excalibur.component.ComponentProxyGenerator$ComponentInvocationHandler.invoke(ComponentProxyGenerator.java:143)\nat $Proxy35.isDocument(Unknown Source)\nat\norg.apache.lenya.cms.publication.DocumentFactoryImpl.isDocument(DocumentFactoryImpl.java:189)\nat\norg.apache.lenya.cms.usecase.DocumentUsecase.getSourceDocument(DocumentUsecase.java:95)\nat\norg.apache.lenya.cms.editors.fckeditor.Fckeditor.getNodesToLock(Fckeditor.java:68)\nat\norg.apache.lenya.cms.usecase.AbstractUsecase.lockInvolvedObjects(AbstractUsecase.java:778)\n", "id": 107787, "time": "2007-09-06T13:55:47Z", "bug_id": 43136, "creation_time": "2007-09-06T13:55:47Z", "attachment_id": null}, {"count": 36, "tags": [], "bug_id": 43136, "attachment_id": null, "text": "Debugging output from the save after the trace in comment #35.\n\nsavePersistables: node lenya://lenya/pubs/default/content/authoring/sitetree.xml\ngetRepoItem key: lenya://lenya/pubs/default/content/authoring/sitetree.xml\norg.apache.lenya.cms.repository.SessionImpl@1549f0e\njava.lang.Exception\n        at\norg.apache.lenya.cms.repository.SessionImpl.getRepositoryItem(SessionImpl.java:208)\n        at\norg.apache.lenya.cms.site.tree2.SiteTreeImpl.getRepositoryNode(SiteTreeImpl.java:433)\n        at org.apache.lenya.cms.site.tree2.SiteTreeImpl.save(SiteTreeImpl.java:177)\n        at\norg.apache.lenya.cms.repository.SessionImpl.savePersistables(SessionImpl.java:171)\n        at org.apache.lenya.cms.repository.SessionImpl.commit(SessionImpl.java:135)\n        at\norg.apache.lenya.cms.usecase.AbstractUsecase.execute(AbstractUsecase.java:332)\n", "id": 107788, "time": "2007-09-06T13:58:05Z", "creator": "rfrovarp@apache.org", "creation_time": "2007-09-06T13:58:05Z", "is_private": false}, {"count": 37, "tags": [], "bug_id": 43136, "attachment_id": null, "text": "(In reply to comment #32)\n\n> r571429 said you added code to detect issues related to this comment. Do a clean\n> build, import into default publication, submit a page, then publish it. It will\n> always trip your detection code. I just rolled back to that revision and am\n> still having trouble, so it's not anything I've done today to make this trip.\n> Given the time line, it might have something to do with publishing pages.\n\nTo make things easier, SourceNode.lock() now re-dates the lock to the revision\nwhen the node content or meta data were loaded. Actually this is not totally\nclean (content and meta data should be forced to load at the same time, i.e. no\nseparate lazy loading could be applied - worse performance), but IMO it's good\nenough for the moment.", "id": 108020, "time": "2007-09-11T07:13:58Z", "creator": "andreas@apache.org", "creation_time": "2007-09-11T07:13:58Z", "is_private": false}, {"count": 38, "tags": [], "bug_id": 43136, "attachment_id": null, "text": "(In reply to comment #37)\n> (In reply to comment #32)\n> \n> > r571429 said you added code to detect issues related to this comment. Do a clean\n> > build, import into default publication, submit a page, then publish it. It will\n> > always trip your detection code. I just rolled back to that revision and am\n> > still having trouble, so it's not anything I've done today to make this trip.\n> > Given the time line, it might have something to do with publishing pages.\n> \n> To make things easier, SourceNode.lock() now re-dates the lock to the revision\n> when the node content or meta data were loaded. Actually this is not totally\n> clean (content and meta data should be forced to load at the same time, i.e. no\n> separate lazy loading could be applied - worse performance), but IMO it's good\n> enough for the moment.\n\nSaving in an editor still wipes out any sitetree changes made between load and save.", "id": 108024, "time": "2007-09-11T07:46:47Z", "creator": "rfrovarp@apache.org", "creation_time": "2007-09-11T07:46:47Z", "is_private": false}, {"count": 39, "tags": [], "creator": "andreas@apache.org", "text": "(In reply to comment #38)\n\n> Saving in an editor still wipes out any sitetree changes made between load and\nsave.\n\nThat should be fixed now (see bug 43291).", "id": 108053, "time": "2007-09-12T01:35:33Z", "bug_id": 43136, "creation_time": "2007-09-12T01:35:33Z", "is_private": false, "attachment_id": null}, {"count": 40, "tags": [], "bug_id": 43136, "attachment_id": null, "is_private": false, "id": 108084, "time": "2007-09-12T08:38:31Z", "creator": "rfrovarp@apache.org", "creation_time": "2007-09-12T08:38:31Z", "text": "This does appear to be mostly fixed. I'll be testing this with over a dozen\npeople this afternoon. I do still see it as described in bug 43297."}, {"count": 41, "tags": [], "bug_id": 43136, "attachment_id": null, "is_private": false, "id": 109196, "time": "2007-10-10T08:48:21Z", "creator": "rfrovarp@apache.org", "creation_time": "2007-10-10T08:48:21Z", "text": "I had 5 people create standard web pages. They all hit create at the same time.\nThis triggered the error on at least 1 or 2 during testing. No sitetree\ncorruption occurred, but it is still not a good thing. "}, {"count": 42, "tags": [], "bug_id": 43136, "attachment_id": null, "text": "I ran the jmeter tests. 5 threads with 50 pages for each to create. I ended up\nwith two failures. This didn't lead to any sitetree corruption. I'm moving this\noff of blocker since no longer causes corruption and no longer requires luck to\nmake it work right.", "id": 109477, "time": "2007-10-18T12:17:41Z", "creator": "rfrovarp@apache.org", "creation_time": "2007-10-18T12:17:41Z", "is_private": false}, {"count": 43, "tags": [], "bug_id": 43136, "attachment_id": null, "text": "\n\n*** This bug has been marked as a duplicate of 42496 ***", "id": 109482, "time": "2007-10-18T12:34:21Z", "creator": "rfrovarp@apache.org", "creation_time": "2007-10-18T12:34:21Z", "is_private": false}]