[{"count": 0, "tags": [], "creator": "aogburn@redhat.com", "text": "The recover_time applies correctly the first time, but only the first time.  This becomes evident when setting recover_time larger than 60 seconds and larger than worker.maintain.  After the first recover attempt passes and the worker errors back out to its global error state, the worker will be placed in recovery mode again on the next invocation of the worker.maintain method.\n\nTesting with recover_time at 120 and error_escalation_time at 0 for simplicity and worker.maintain at the default 60, I see the worker is in global error upon a failure and then goes to recovery properly the first time after >120 seconds, but each subsequent time, it is placed in recovery after ~60 seconds when the maintenance method fires.  I then tested this with a drastically lowered worker.maintain at 5 seconds.  Again, I see the first time the 2 minute recover_time is correctly used.  But here, the worker is retried and placed into ERR/REC after just 5 seconds.  I tested again with worker.maintain at 15 seconds.  Again, I see the first time the 2 minute recover_time is correctly used.  But here, the worker is retried and placed into ERR/REC after 15 seconds.\n\nWith these tests, I see that the LE (last error time) reported for the worker by jkstatus never changes after it is set on the initial error, which may be due to the following generic error block in jk_lb_worker.c's service method as it only sets error_time when it is 0:\n\n                else {\n                    /*\n                     * Various unspecific error cases.\n                     * Keep previous global state, if we are not in local error since to long.\n                     * Do not try to reuse the same node for the same request.\n                     * Failing over to another node could help.\n                     */\n                    time_t now = time(NULL);\n                    rec->s->errors++;\n                    if (rec->s->busy == 0 ||\n                        p->worker->error_escalation_time == 0 ||\n                        (rec->s->error_time > 0 &&\n                         (int)difftime(now, rec->s->error_time) >= p->worker->error_escalation_time)) {\n                        if (JK_IS_DEBUG_LEVEL(l))\n                            jk_log(l, JK_LOG_DEBUG,\n                                   \"worker %s escalating local error to global error\",\n                                   rec->name);\n                        rec->s->state = JK_LB_STATE_ERROR;\n                    }\n                    p->states[rec->i] = JK_LB_STATE_ERROR;\n                    if (rec->s->error_time == 0) {\n                        rec->s->error_time = now;\n                    }\n                    rc = JK_FALSE;\n                }\n\nAnd the unchanged error time appears to be the root cause of the improper recoveries after checking code from recover_workers in jk_lb_worker.c:\n\n        if (w->s->state == JK_LB_STATE_ERROR) {\n            elapsed = (int)difftime(now, w->s->error_time);\n            if (elapsed <= p->recover_wait_time) {\n                if (JK_IS_DEBUG_LEVEL(l))\n                    jk_log(l, JK_LOG_DEBUG,\n                           \"worker %s will recover in %d seconds\",\n                           w->name, p->recover_wait_time - elapsed);\n            }\n            else {\n                if (JK_IS_DEBUG_LEVEL(l))\n                    jk_log(l, JK_LOG_DEBUG,\n                           \"worker %s is marked for recovery\",\n                           w->name);\n                if (p->lbmethod != JK_LB_METHOD_BUSYNESS)\n                    w->s->lb_value = curmax;\n                aw->s->reply_timeouts = 0;\n                w->s->state = JK_LB_STATE_RECOVER;\n                non_error++;\n            }\n        }\n\n\nSo after the first pass, error_time never updates again and so elapsed is always > recover_wait_time, resulting in the worker being placed in recovery on each call of the worker maintenance.\n\nBut I see too from the service method that escalation to global error is also based upon this error_time, which might could cause issues if error_time is updated for the sake of the recover_time check.  A node should be sent back to global error if it fails in recovery mode, but if error_time is updated for recover_time to function properly, would this still resolve to a global error state?\n\nPerhaps, the best route would be two separate variables: the error_time used for the sake of error_escalation and only set/updated on error when error_time is 0 and then a last_error_time for the sake of recover wait time that is updated on any error occurrence.", "id": 152171, "time": "2011-12-14T21:47:16Z", "bug_id": 52334, "creation_time": "2011-12-14T21:47:16Z", "is_private": false, "attachment_id": null}, {"count": 1, "tags": [], "bug_id": 52334, "is_private": false, "id": 152172, "creation_time": "2011-12-14T21:50:20Z", "time": "2011-12-14T21:50:20Z", "creator": "aogburn@redhat.com", "text": "A workaround could be to set the worker.maintain interval to the desired recover_time asw well.", "attachment_id": null}, {"count": 2, "tags": [], "bug_id": 52334, "text": "I think this is desired behavior.\ns->error_time is set to zero after the request made returns OK.\nIn case worker never went from recovery it'l be checked more aggressively.", "id": 166680, "time": "2013-04-17T16:37:36Z", "creator": "mturk@apache.org", "creation_time": "2013-04-17T16:37:36Z", "is_private": false, "attachment_id": null}, {"count": 3, "tags": [], "bug_id": 52334, "text": "This should be fixed by 1647636 which will be part of version 1.2.41.\n\nWe now track two time stamps, the original error time, mostly used for reporting in the status worker and for error_escalation_time, and the last recovery attempt timestamp to determine the time of the next recovery attempt using recover_wait_time.\n\nRegards,\n\nRainer", "id": 180002, "time": "2014-12-23T18:21:54Z", "creator": "rainer.jung@kippdata.de", "creation_time": "2014-12-23T18:21:54Z", "is_private": false, "attachment_id": null}]