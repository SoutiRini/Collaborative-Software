[{"count": 0, "tags": [], "text": "I am facing a strange performance problem in our production environment when I\nuse the conversion pattern \"C:L\" to output class name and line number.  I DO\nexpect the performance to be slower but what I got was a gradual slowdown where\nour application would literally slow down to a grinding halt after a few days of\nrunning.  The application would get back to normal if I force it to run a full\nGC.  After working with HP JVM engineer on this issue, the problem was found to\nbe the use of String.intern() in CategoryKey class AND the use of\njava.lang.Throwable.getStackTraceElement() (to get line number and classname). \nThe use of intern() causes the StringTable in JVM (in the Permanent heap) to\nfill up very quickly as each call to Logger.getLogger() will create an instance\nof CategoryKey object.  The method getStackTraceElement()  will use the\nStringTable for lookup and it will take longer for it to run as time goes. The\nStringTable may contain Strings which are not live in the java program. \nHowever, the collection of Strings in StringTable is done only in Full GC. \nThat's the reason a Full GC recovered the application performance. I have\nattached a sample program that will reproduce the problem easily on any\nplatforms using 1.4.2 JVM.\n\nMy question to the logging group is whether the call to intern() is necessary in\ncreating the CategoryKey? Is it used to speed up hash lookup?  This seems like a\nVM bug but I doubt it will get fixed by Sun anytime soon and I am worried that\nother system will experience the same problem I do. (took us a few weeks to\nfigure out the problem!)\n\nMy workaround is to adopt the use of Apache Common Logging API which will cache\neach instance of logger and eliminate the need to call Logger.getLogger() which\nin turn eliminate the need for CategoryKey to call String.intern().\n\nThe code that will duplicate the problem is here, run it as followed:\n\n\"java --XX:MaxPermSize=512m -XX:PermSize=512m st\" and telnet to port 12345 to\ntrigger garbage collection\n\n\nimport java.io.*;\nimport java.net.*;\n\npublic class st {\n  public static void main(String[] args) {\n    gc_monitor_thread gcm = new gc_monitor_thread();\n    gcm.start();\n    trace_thread  tt = new trace_thread();\n    tt.start();\n    for (int i = 0; i < 4; i++) {\n      string_thread st = new string_thread();\n      st.start();\n    }\n  }\n}\n\nclass string_thread extends Thread {\n  boolean alive = false;\n  String tstr = \"abc\";\n  public void run() {\n    alive = true; \n    long lcnt = 0;\n    int  mcnt = 0;\n    while (alive) {\n      String s = getName() + Long.toHexString(lcnt);\n      if (s.equals(tstr)) mcnt++;\n      s.intern();\n      lcnt++; \n      if (lcnt % 100000 == 0) {\n        try { Thread.sleep(10); } catch (InterruptedException ie) {}\n      }\n    }\n  }\n}\n\nclass trace_thread extends Thread {\n  boolean alive = false;\n  public void run() {\n    alive = true;\n    while (alive) {\n      long t0 = System.currentTimeMillis();\n      for (int i = 0; i < 100; i++) {\n        do_stack_trace_op();\n      }\n      long t1 = System.currentTimeMillis();\n      \n      System.out.println(\"time for trace: \" + (t1 - t0));\n      try { Thread.sleep(1000); } catch (InterruptedException ie) {}\n    }\n  }\n  void do_stack_trace_op() {\n    Throwable t = get_throwable();\n    PrintWriter pw = null;\n    // try {\n      pw = new PrintWriter(new StringWriter());\n      t.printStackTrace(pw);\n    // } catch (IOException ioe) {\n    //   System.out.println(ioe);\n    //   System.exit(2);\n    // }\n  }\n  Throwable get_throwable() {\n    return new Throwable(\"dummy\");\n  }\n}\n\nclass gc_monitor_thread extends Thread {\n  boolean alive = false;\n  public void run() {\n    alive = true;\n    int try_limit = 100;\n    int try_count = 0;\n    while (alive) {\n      int pn = 12345;\n      ServerSocket ss = null;\n      while (ss == null) {\n        try {\n          ss = new ServerSocket(pn);\n        } catch (IOException ioe) {\n          pn++;\n          try_count++;\n          if (try_count > try_limit) {\n            System.out.println(\"too many failures while creating server socket.\");\n            System.out.println(\"exitting...\");\n            System.exit(2);\n          }\n        }\n      }      \n\n      if (ss == null) {\n        System.out.println(\"unexpected situation.  server socket null\");\n        System.exit(3);\n      }\n\n      System.out.println(\"GC monitor thread started on port \" +\n        ss.getLocalPort() + \". Connect to this port to run GC.\");\n\n      while (alive) {\n        Socket s = null;\n        try {\n          s = ss.accept(); \n        } catch (IOException ioe) {\n          System.out.println(\"GC monitor thread got an exception in accept.\");\n          ioe.printStackTrace();\n          System.exit(4);\n        }\n\n        if (s == null) {\n          System.out.println(\"accept returned a null Socket.\");\n          System.exit(5); \n        }\n        System.out.print(\"Performing System.gc()...\");\n        System.out.flush();\n        System.gc();\n        System.out.println(\"done.\");\n        try {\n          s.close(); \n        } catch (IOException ioe) {\n          System.out.println(\"error while closing socket.\");\n          ioe.printStackTrace();\n        }\n      }\n    }\n  }\n}\n\n\nVincent", "is_private": false, "id": 75316, "creator": "wsshek@taifook.com", "time": "2005-05-25T04:47:35Z", "bug_id": 35052, "creation_time": "2005-05-25T04:47:35Z", "attachment_id": null}, {"count": 1, "tags": [], "text": "It doesn't seem like it makes much sense for intern() to be used...  I find it\ndoes save a lot on memory, if you are reading values from a file or database and\nexpect the same values to appear multiple times, but this is not that use case.\n\nIn any case, the typical usage pattern is Logger.getLogger() is called once and\nthe returned value is kept in a static variable.\n\nI don't see any other use of String.intern() in mainline, which is good.", "is_private": false, "bug_id": 35052, "id": 75317, "time": "2005-05-25T06:20:34Z", "creator": "eross@m-qube.com", "creation_time": "2005-05-25T06:20:34Z", "attachment_id": null}, {"count": 2, "attachment_id": null, "bug_id": 35052, "text": "1.2.12 candidate\n\nI don't know if this is fixable, but I think it should be looked at to \nunderstand why we are using String.intern().", "id": 76887, "time": "2005-07-01T18:56:59Z", "creator": "mwomack@apache.org", "creation_time": "2005-07-01T18:56:59Z", "tags": [], "is_private": false}, {"count": 3, "tags": [], "text": "So, this is the code for CategoryKey:\n\nclass CategoryKey {\n\n  String   name;  \n  int hashCache;\n\n  CategoryKey(String name) {\n    this.name = name.intern();\n    hashCache = name.hashCode();\n  }\n\n  final\n  public  \n  int hashCode() {\n    return hashCache;\n  }\n\n  final\n  public\n  boolean equals(Object rArg) {\n    if(this == rArg)\n      return true;\n    \n    if(rArg != null && CategoryKey.class == rArg.getClass()) \n      return  name == ((CategoryKey)rArg ).name;\n    else \n      return false;\n  }\n}\n\nI think we are using the String.intern() call so that we can do the == between \nthe two CategoryKey objects.  Theoretically the String.intern() call will \nreturn the same String object for the same string value.  I am assuming that \nusing this instead of String.equals() is the speed increase.  But I don't \nunderstand why this is really an issue.  Only one version of the String should \nbe added/created in the StringTable.  Once a given logger has been created, no \nmore entries to the StringTable should be added related to that logger.  Are \nyou creating that many unique Loggers over time?", "is_private": false, "id": 77055, "creator": "mwomack@apache.org", "time": "2005-07-07T03:55:45Z", "bug_id": 35052, "creation_time": "2005-07-07T03:55:45Z", "attachment_id": null}, {"count": 4, "tags": [], "text": "I am not creating many unique loggers over time, but Logger.getLogger() will\nstill call new CategoryKey() even thought I am accessing the same logger.\n\ne.g. String.intern() will be called twice if I do the following:\n\nLogger.getLogger(\"logger1\");\nLogger.getLogger(\"logger1\");", "is_private": false, "bug_id": 35052, "id": 77058, "time": "2005-07-07T04:33:44Z", "creator": "wsshek@taifook.com", "creation_time": "2005-07-07T04:33:44Z", "attachment_id": null}, {"count": 5, "tags": [], "creator": "mwomack@apache.org", "text": "Right.  But this \"should\" not matter, as per the String Javadoc for intern():\n\n\"A pool of strings, initially empty, is maintained privately by the class \nString. \n\nWhen the intern method is invoked, if the pool already contains a string equal \nto this String object as determined by the equals(Object) method, then the \nstring from the pool is returned. Otherwise, this String object is added to the \npool and a reference to this String object is returned. \n\nIt follows that for any two strings s and t, s.intern() == t.intern() is true \nif and only if s.equals(t) is true.\"\n\nSo, for any given logger, only one String object should be in the StringTable, \nnot multiple.  Unless String.equal() is returning not equal for Strings with \nthe same values?  I wonder if this problem is related to CategoryKey or \nsomething more to do with the \"C:L\" conversion pattern.", "id": 77063, "time": "2005-07-07T06:45:33Z", "bug_id": 35052, "creation_time": "2005-07-07T06:45:33Z", "is_private": false, "attachment_id": null}, {"count": 6, "tags": [], "bug_id": 35052, "attachment_id": null, "is_private": false, "id": 77064, "time": "2005-07-07T07:19:16Z", "creator": "skitching@apache.org", "creation_time": "2005-07-07T07:19:16Z", "text": "I can't see any problem with the use of intern here either. \n\nClass CategoryKey is used in only one way: as the key to the hashtable of named\nLogger objects maintained by a Hierarchy. And under normal patterns of use, even\na very large program is only likely to have a few hundreds of differently-named\nLogger objects.\n\nAnd as mark said, calling\n  String.intern(\"foo\") \nany number of times still creates just one entry in the interned-string table.\nThat's the whole point of intern!\n\nAre you perhaps dynamically generating category names, eg by\n  Logger l = Logger.getLogger(\"some.category.\" + currentDateTime);\n\nThis would cause large numbers of distinctly-named Logger objects to be created,\nand of course all those distinct names *would* clutter the interned-string\ntable. However it's a pretty odd way to use log4j.."}, {"count": 7, "tags": [], "creator": "wsshek@taifook.com", "text": "I agree with both of you that in most cases, the String.intern() should not\ncause any problems.  I have to revisit my application to make sure I am not\ncreating so many unique loggers which led to my original problem.  However, if\nyou using a small fixed size permanent heap, a few thousands different loggers\nwould start to create problem in the stringtable.  ", "id": 77067, "time": "2005-07-07T08:52:57Z", "bug_id": 35052, "creation_time": "2005-07-07T08:52:57Z", "is_private": false, "attachment_id": null}, {"count": 8, "attachment_id": null, "bug_id": 35052, "is_private": false, "id": 77068, "time": "2005-07-07T10:33:50Z", "creator": "skitching@apache.org", "creation_time": "2005-07-07T10:33:50Z", "tags": [], "text": "A few thousand distinct logger names implies one monstrous app. I wouldn't ever\nexpect to see something like that running with \"a small heap\". What kind of app\nare you writing that has \"thousands\" of distinct logger names but only a small heap?\n\nNote that the number of *loggers* is irrelevant. It's the *names* of those\nloggers  that go into the String.intern pool, so a thousand Logger objects with\nthe same name --> one entry in the intern pool.\n\nIn addition, the String.intern method says this:\n \"All literal strings and string-valued constant expressions are interned.\"\nI've checked this and it is definitely true. So if these loggers are created like\n  Logger l = new Logger(\"some.literal.string\")\nthen that constant string is automatically interned anyway; it happens when the\nclass is loaded. So the CategoryKey call to String.intern isn't adding any new\nentries to the constant string pool; it simply locates the literal value that\nwas put there by the classloading process.\n\nOnly when the logger name is dynamically generated like:\n  l = new Logger(\"foo\" + someParam)\nwill the ConstantKey's call to String.intern force the constant string pool to\nget a new value. And that just isn't a common logging idiom.\n\nI really think your initial problem diagnosis is wrong and you should look\nagain. You've clearly got a problem but I find it hard to believe it's due to\ncalls to String.intern. NB: this is all just my personal opinion of course."}, {"count": 9, "tags": [], "bug_id": 35052, "attachment_id": null, "is_private": false, "id": 77070, "time": "2005-07-07T10:45:00Z", "creator": "skitching@apache.org", "creation_time": "2005-07-07T10:45:00Z", "text": "NB: your example code does show that a problem can occur when many hundreds of\nthousands of *unique* strings are generated and interned. But that isn't the\ncase for logging - unless you're generating logger names via some process like\n  Logger l = Logger.getLogger(\"some.category.\" + currentDateTime);\nas I described earlier. If you are -- don't do that!"}, {"count": 10, "tags": [], "bug_id": 35052, "attachment_id": null, "text": "It sounds to me that getting rid of intern doesn't hurt performance considerably.\n\nConsider these three cases:\n\n1.  You're doing:\n\nLogger.getLogger(\"logger1\");\n...\nLogger.getLogger(\"logger1\");\n\nUsing a string constant here, \"logger1\" was already interned and\n\"logger1\".equals(\"logger1\") is fast.  No need to explicitly do an intern()\n\n2.  You're evaluating the string, you're doing:\n\nint i = 1;\nLogger.getLogger(\"logger\" + i);\n...\nLogger.getLogger(\"logger\" + i);\n\nIn which case, the cost of intern() is MUCH more expensive than intern anyway,\nso why bother?\n\n3.  You're storing the evaluated string and a combination of above.  Again,\nintern() is more expensive than equals() so why bother.\n\nI don't understand the need for intern() at all.  Sounds like a premature\noptimization bug.", "id": 77193, "time": "2005-07-11T22:01:55Z", "creator": "eross@m-qube.com", "creation_time": "2005-07-11T22:01:55Z", "is_private": false}, {"count": 11, "tags": [], "creator": "skitching@apache.org", "text": "(In reply to comment #10)\n> Logger.getLogger(\"logger1\");\n> \n> Using a string constant here, \"logger1\" was already interned\n\ntrue\n\n> \"logger1\".equals(\"logger1\") is fast.  No need to explicitly do an intern()\n\nI agree that the literal strings in code are automatically interned, and the\nString.equals method should be checking for identity before bothering to do a\nloop checking the string content [1]. There's still the overhead of a\n(non-virtual) method invocation and return though.\n\nHowever the main point of this is to optimise the comparisons executed as part\nof Hashtable.get when looking up the logger from the map of all loggers. And\nHashtable.get may well do several *failed* comparisons before finding the right\nlogger to return.\n\nThe operation \"string1\" == \"string2\" is fast always; if the references are\ndifferent then the result is false.\n\nHowever \"string1\".equals(\"string2\") has a fair bit of overhead. The\nString.equals method needs to do:\n * if (param instanceof String)\n * cast param to String\n * if string lengths differ: return false\n * otherwise compare each byte [1]\n[1] or potentially compare hashcodes.\n\nThe reference comparison starts to look nice..\n\nHow many such non-equal comparisons occur in the Hashtable lookup? Well that\ndepends upon the hashcode collision rate inside the hashtable; obviously two\nstrings whose hashcodes cause them to be allocated to different buckets never\nget compared. The java.util.HashMap class has a default loadFactory of 0.75. So\nat a wild guess I would think only about 30% of lookups would hit a bucket with\nmore than one entry, and in 50% of those cases the right entry would be first.\n\nSo I agree this optimisation is not critical, but it could have a measurable\nimprovement.\n\n> 2.  You're evaluating the string, you're doing:\n> \n> int i = 1;\n> Logger.getLogger(\"logger\" + i);\n> ...\n> Logger.getLogger(\"logger\" + i);\n> \n> In which case, the cost of intern() is MUCH more expensive than intern anyway,\n> so why bother?\n\nTrue. However such usage really is a little bizarre.\n\n> \n> 3.  You're storing the evaluated string and a combination of above.  Again,\n> intern() is more expensive than equals() so why bother.\n> \n> I don't understand the need for intern() at all.  Sounds like a premature\n> optimization bug.\n\nA very common pattern is:\n  Logger.getLogger(someClass.getName());\n\nI've checked with Sun java 1.3.1 and 1.5 and the string returned by\nsomeClass.getName does get interned automatically like literal strings in the\ncode. The question is whether that behaviour should be relied on or not. I'm not\naware of anything in the java specs that mandate this string going into the\nintern pool (unlike literals in the code which *must* go there) but I think it\nlikely that all Java implementations *will* do this; when the JVM is loading the\nraw .class file into memory it needs to store the literal strings somewhere and\nputting them in the intern pool seems as good a place as any.\n\n\n\nSo: first of all, string comparisons in the logger Hashtable lookup will not be\ncommon (maybe 30% of lookups). And in all the scenarios where interning makes\nsense, the strings seem to already be interned; comparing two equal interned\nstrings with .equals should be close to the speed of comparing them with ==.\nWhere the two strings are actually different (maybe 15% of lookups) there are\ntwo cases:\n* strings have different length (most of the time)\n  --> minor win for the interned comparison\n* strings have same length (pretty rare)\n  --> major win for the interned comparison\n\nSummary: From a theoretical point I tend to agree that this use of String.intern\nwon't have much effect and could have been omitted. Of course actually testing\nthis might be wise -- real stats win over theory any day :-). \n\nBut on the other hand, String.intern only does active harm when the user is\ngenerating large numbers of logger names dynamically - and I can't see any sane\nreason for anyone to do that. \n\n[1] Actually, GNU Classpath doesn't! Currently comparison of a string object\nwith itself does a reasonable amount of work (though not a scan of the actual\nstring data). I've sent off an email querying this.", "id": 77200, "time": "2005-07-12T01:27:41Z", "bug_id": 35052, "creation_time": "2005-07-12T01:27:41Z", "is_private": false, "attachment_id": null}, {"count": 12, "tags": [], "bug_id": 35052, "text": "The String.intern (potentially mal-) optimization appears to be the only reason that CategoryKey exists.  \nSwitching to a String-keyed hashtable would eliminate the need to create and reclaim CategoryKey objects \non the calls to getLogger().  Unfortunately, Hierarchy.Hashtable is package-visible, so it might be \nnecessary to maintain a distinct string-keyed hashmap/hashtable in preference and preserve ht for classes \nsquatting in our package.", "id": 77529, "time": "2005-07-22T02:53:42Z", "creator": "carnold@apache.org", "creation_time": "2005-07-22T02:53:42Z", "is_private": false, "attachment_id": null}, {"count": 13, "tags": [], "text": "I've committed a performance test for Logger.getLogger on the CVS HEAD.  To run:\n\ncd tests\nant build ' once to build unit tests\nant -f performance.xml getLogger\n\nI've run the tests with the current implementation and two alternative implementations.  The test, by \ndefault, calls getLogger() for 1000 different logger names of typical length.  The first pass is much \nmore expensive than the subsequent passes since new instances of Logger will be created for each \nname.  Subsequent passes simply retrieve the previously created loggers.\n\nThe baseline results were ~3200 ms for the pass 0 and 123 ms on average for passes 1-9.\n\nThe first modification was:\n\ndiff -r1.5 CategoryKey.java\n29c29\n<     this.name = name.intern();\n---\n>     this.name = name;\n43c43\n<       return name == ((CategoryKey) rArg).name;\n---\n>       return name.equals(((CategoryKey) rArg).name);\n\nAfter this change: pass 0: ~1900 ms, 77 ms average, 38 ms min for passes 1- 9 \n\nThis indicates that (at least on this JVM), that initial call to String.intern adds substantial time to the \ncreation of a new Logger and use of == is slower than name.equals() surprisingly.\n\nThe second change was to eliminate the use of CategoryKey altogether:\n\nRCS file: /home/cvs/logging-log4j/src/java/org/apache/log4j/Hierarchy.java,v\nretrieving revision 1.62\ndiff -r1.62 Hierarchy.java\n79c79\n<   Hashtable ht;\n---\n>   private Hashtable ht;\n227c227\n<     Object o = ht.get(new CategoryKey(name));\n---\n>     Object o = ht.get(name);\n447c447\n<     CategoryKey key = new CategoryKey(name);\n---\n>     String key = name;\n726c726\n<       CategoryKey key = new CategoryKey(substr); // simple constructor\n---\n>       String key = substr; // simple constructor\n\nThe results for this mod were, on average, slightly better than the previous iteration at ~1800 ms and \n61 ms average, 20 ms min for passes 1-9.\n\nThese results were from: \n\njava version \"1.4.2_07\"\nJava(TM) 2 Runtime Environment, Standard Edition (build 1.4.2_07-215)\nJava HotSpot(TM) Client VM (build 1.4.2-50, mixed mode)\n\non Mac OS/X.\n\nRunning a JRE 1.2 on Win98 SE:\n\nStock: Pass 0: 1000 ms, pass 1-9: avg 66, min 0\nMod 1: Pass 0: 550 ms, Pass 1-9: avg 48, min 0\nMod 2: Pass 0: 550 ms, pass 1-9: avg 67, min 0\n \nRunning JRE 1.5.0 on Win XP\n\nStock: Pass 0: 390 ms, pass 1-9: avg 12 ms, min 0\nMod 1: Pass 0: 203 ms, pass 1-9: avg 5 ms, min 0\nMod 2: Pass 0: 172 ms, pass 1-9: avg 3 ms, min 0\n\nMy take is that anything 1.2 or later would likely not benefit from the String.intern \"optimization\".\n\nUnless we can find a platform where it does offer a compelling advantage, my current take would be to \ndo Mod 1 on the log4j 1.2 branch and mark CategoryKey deprecated (it is already only visible within the \npackage) and do Mod 2 on the CVS HEAD.  ", "is_private": false, "id": 77535, "creator": "carnold@apache.org", "time": "2005-07-22T07:15:28Z", "bug_id": 35052, "creation_time": "2005-07-22T07:15:28Z", "attachment_id": null}, {"count": 14, "attachment_id": null, "bug_id": 35052, "text": "Did the minor change to CategoryKey in both the CVS HEAD and 1.2 branch.  Expect to eliminate \nCategoryKey in 2.0.", "id": 77587, "time": "2005-07-22T21:41:44Z", "creator": "carnold@apache.org", "creation_time": "2005-07-22T21:41:44Z", "tags": [], "is_private": false}, {"count": 15, "tags": [], "bug_id": 35052, "attachment_id": null, "text": "Wow.  This change is in the 1.2.12rc1 build.  Vincent, please check that it \nfixes the reported problem.  I will run some benchmarks to see if I get the \nsame performance results.", "id": 77739, "time": "2005-07-28T04:58:25Z", "creator": "mwomack@apache.org", "creation_time": "2005-07-28T04:58:25Z", "is_private": false}, {"count": 16, "tags": [], "creator": "wsshek@taifook.com", "text": "Thx so much.  I will check out rc1 and will report my findings (but not too soon)", "id": 77740, "time": "2005-07-28T05:39:15Z", "bug_id": 35052, "creation_time": "2005-07-28T05:39:15Z", "is_private": false, "attachment_id": null}, {"count": 17, "tags": [], "bug_id": 35052, "text": "I tried this on my Windows machine using jdk 1.4.2_07.  I modified the \nperformance.xml to reference the 1.2.11 and 1.2.12rc2 jars instead of the \nclasses build in the cvs head.  I see an improvement in the 1.2.12 version:\n\ngetLogger: (using jdk 1.4.2_07, log4j 1.2.11)\n     [java] Usage: java org.apache.log4j.GetLoggerTest passes [nameCount \nnameLength]\n     [java] Pass 0: 1232 ms.\n     [java] Average non-initial pass: 34 ms.\n     \ngetLogger: (using jdk 1.4.2_07, log4j 1.2.12rc2)\n     [java] Usage: java org.apache.log4j.GetLoggerTest passes [nameCount \nnameLength]\n     [java] Pass 0: 832 ms.\n     [java] Average non-initial pass: 21 ms.\n\nNot an incredible improvement in my environment (WinXP HE, Pentium III, 652 \nMHz, 256 MB RAM), but an improvement.  More interestingly to me is that with \nthe 1.2.12 code, the times for the non-initial passes is highly variable (in my \ntests from 0 - 70ms).  The avg is less though.", "id": 78204, "time": "2005-08-07T23:52:52Z", "creator": "mwomack@apache.org", "creation_time": "2005-08-07T23:52:52Z", "is_private": false, "attachment_id": null}, {"count": 18, "tags": [], "text": "Vincent, get a chance to try this in your environment?", "is_private": false, "id": 78205, "creator": "mwomack@apache.org", "time": "2005-08-07T23:53:24Z", "bug_id": 35052, "creation_time": "2005-08-07T23:53:24Z", "attachment_id": null}]