[{"count": 0, "tags": [], "bug_id": 57719, "attachment_id": null, "id": 181832, "time": "2015-03-17T09:27:51Z", "creator": "chuchiperriman@gmail.com", "creation_time": "2015-03-17T09:27:51Z", "is_private": false, "text": "All tasks are loaded with ComponentHelper but Mapper doesn't. In our environment we hack some classpath (and more things) when load the tasks but the mapper task is not loaded by the componente helper, the Tasks are creating the object (Copy task, MappingSelector, MappedResourceCollection, etc)"}, {"count": 1, "tags": [], "bug_id": 57719, "is_private": false, "id": 182481, "creation_time": "2015-04-19T04:59:17Z", "time": "2015-04-19T04:59:17Z", "creator": "bodewig@apache.org", "text": "This applies to all nested elements of tasks that are using the createXYZ() method rather than the addXYZ() variant.  This means in order to change this we'd need to modify all Ant tasks using create(), which is certainly possible for Ant's own tasks but not for third party tasks.\n\nThe \"create\" variant is there so that tasks can have full control over the classloader they use.  I don't think this applies to the Mapper case so it may be possible to replace create with add - but that would be breaking API backwards compatibility.\n\nAre you using the <mapper class=\"xxxx\"/> way of specifying the mapper?  If your class implements FileNameMapper you should be able to typedef it and add it to copy directly (since it also contains an add method for FileNameMapper) and use the core loader.  This would also work for all other tasks supporting mappers since <mapper> itself has an add method for FileNameMapper.\n\nSo rather than\n\n<copy>\n  <mapper classname=\"foo.bar.Mapper\"/>\n</copy>\n\nyou'd use\n\n<typedef name=\"mymapper\" classname=\"foo.bar.Mapper\"/>\n<copy>\n  <mymapper/>\n</copy>\n\nor \n\n<typedef name=\"mymapper\" classname=\"foo.bar.Mapper\"/>\n<copy>\n  <mapper>\n    <mymapper/>\n  </mapper>\n</copy>\n\nand should be able to control the classloader used for the typedef.", "attachment_id": null}]