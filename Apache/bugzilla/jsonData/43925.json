[{"count": 0, "text": "BodyContentImpl buffers all output from a custom tag ready to be written when\nthe tag execution ends. However, the way in which it grows this buffer is\nextremely inefficient and has two undesirable effects:\n\n- garbage collection is triggered very frequently to tidy up the waste.\n- CPU load ramps up as large, unnecessary array copies take place.\n\nAll that's needed is a more intelligent buffer-management algorithm. I have\nrewritten this class and can forward it if that would be useful (can't see a way\nof attaching it here).", "creator": "brian.remmington@celestialservices.co.uk", "attachment_id": null, "id": 110922, "time": "2007-11-21T06:23:58Z", "bug_id": 43925, "creation_time": "2007-11-21T06:23:58Z", "tags": [], "is_private": false}, {"count": 1, "tags": [], "text": "There is an option to attach patches just above comment box on the bugzilla page\nfor each bug.", "is_private": false, "id": 111031, "creator": "markt@apache.org", "time": "2007-11-23T12:11:42Z", "bug_id": 43925, "creation_time": "2007-11-23T12:11:42Z", "attachment_id": null}, {"count": 2, "tags": [], "text": "Created attachment 21500\nProposed changes to BodyContentImpl\n\nThe attachment \"buzilla43925.jar\" contains a new implementation of the\nBodyContentImpl class (named \"NewBodyContentImpl\") and a new class on which it\ndepends named \"CharBuffer\". I have also included two JUnit test cases.\n\nThis new implementation performs 45% faster than the current implementation on\nmy test machine and is substantially more efficient in memory usage, causing no\ncharacter arrays to be left to the garbage collector unnecessarily.\n\nI would greatly appreciate it if people would review this code, and let me have\nany comments or suggestions.", "is_private": false, "id": 113568, "creator": "brian.remmington@celestialservices.co.uk", "time": "2008-02-08T07:33:57Z", "bug_id": 43925, "creation_time": "2008-02-08T07:33:57Z", "attachment_id": 21500}, {"count": 3, "tags": [], "text": "Ok, so I not sure I got everything, but:\n- I don't see where memory usage is bounded in the code (if it's not, you should\ncompare performance with the unbounded mode of Jasper, which will never\nreallocate anything); that's a problem\n- The opportunity is the ability to share the buffer list per thread, so the\nCharBuffer.bufList should be ThreadLocal<LinkedList> (and should be limited in\nsize, which should solve item 1); as a configuration option, it could be a\nconcurrent static structure, for use with thread intensive connectors\n- CharBuffer.toArray is expensive (no other option, though), so you should try\nto show a (real) test result", "is_private": false, "id": 113596, "creator": "remm@apache.org", "time": "2008-02-10T18:20:23Z", "bug_id": 43925, "creation_time": "2008-02-10T18:20:23Z", "attachment_id": null}, {"count": 4, "tags": [], "bug_id": 43925, "attachment_id": null, "is_private": false, "id": 113653, "time": "2008-02-12T01:44:29Z", "creator": "brian.remmington@celestialservices.co.uk", "creation_time": "2008-02-12T01:44:29Z", "text": "Thanks very much, Remy.\n\n> - I don't see where memory usage is bounded in the code (if it's not, you should\n> compare performance with the unbounded mode of Jasper, which will never\n> reallocate anything); that's a problem\n\nPerhaps you could help me here. The memory usage doesn't appear to be bounded in\nthe current implementation of BodyContentImpl which *always* appears to\nreallocate exponentially-larger blocks (in the reAllocBuff method at the\nbottom). I must be missing something, but am not sure what. I'm looking at the\nhead of 5.5, which is the version affected by this change.\n\n\n> - The opportunity is the ability to share the buffer list per thread, so the\n> CharBuffer.bufList should be ThreadLocal<LinkedList> (and should be limited in\n> size, which should solve item 1); as a configuration option, it could be a\n> concurrent static structure, for use with thread intensive connectors\n\nThis would require CharBuffer objects to be pooled to be of use. At the moment\nthey aren't (and neither are BodyContentImpl objects, as far as I can see). If I\nunderstand you correctly, this would have the undesirable effect of holding onto\nblocks of memory once allocated rather than making them available for garbage\ncollection. This would certainly require a bounded memory pool approach, but its\ndebatable whether that would be preferable. It would certainly be a bigger change.\n\n> - CharBuffer.toArray is expensive (no other option, though), so you should try\n> to show a (real) test result\n\nI will put together a suitable test case for this. Is there a set of test cases\nfor the current implementation? If so I could just add new ones to it.\n\n\nRegards\nBrian"}, {"count": 5, "tags": [], "bug_id": 43925, "attachment_id": null, "id": 113743, "time": "2008-02-14T05:35:08Z", "creator": "remm@apache.org", "creation_time": "2008-02-14T05:35:08Z", "is_private": false, "text": "About the upper memory bound, I had missed the clear method. I thought the\noriginal purpose was to keep the list of buffers around, now it looks to me the\nmemory usage is equivalent to the LIMIT_BUFFER mode."}, {"count": 6, "tags": [], "bug_id": 43925, "attachment_id": null, "id": 115276, "time": "2008-04-02T23:42:44Z", "creator": "jonsson.thomas@gmail.com", "creation_time": "2008-04-02T23:42:44Z", "is_private": false, "text": "What is the status of this \"bug\"? This causes problems in our jsf based application with a couple of hundreds users. I tried Brians fix with no improvement, memory is still occupied and not gc:d. However, I deployed the application in Glassfish and there the charcater array gets gc:d. Any ideas what to do?"}, {"count": 7, "tags": [], "bug_id": 43925, "attachment_id": null, "id": 115286, "time": "2008-04-03T04:07:15Z", "creator": "funkman@joedog.org", "creation_time": "2008-04-03T04:07:15Z", "is_private": false, "text": "\n\n*** This bug has been marked as a duplicate of bug 37793 ***"}, {"attachment_id": null, "tags": [], "bug_id": 43925, "is_private": false, "count": 8, "id": 115344, "time": "2008-04-06T00:10:46Z", "creator": "brian.remmington@celestialservices.co.uk", "creation_time": "2008-04-06T00:10:46Z", "text": "This is not a duplicate of 37793.\n\nThat one is related to the unbounded growth of cb without the ability for the garbage collector to kick in to collect it. The LIMIT_BUFFER option goes some way to resolve that problem. Thomas (comment #6) does seem to be suffering from 37793 rather than this one.\n\n*This* problem, however, is about the way in which, while cb grows, large numbers of exponentially-larger char arrays are reallocated, copied, and discarded.\n\nEvery time chars are written that cause cb to grow, the following process occurs:\n\na. Allocate a new char array that is twice as large as the current \"cb\";\nb. Copy the contents of cb into the new array;\nc. Assign the new array to cb;\nd. Garbage collector collects the old cb array.\n\n\nThis, I think, is obviously inefficient. It fills up the heap with large, unwanted character arrays and forces the garbage collector to activate more frequently, thus reducing the CPU available for doing useful work. It also uses CPU to copy exponentially-growing arrays from one block of memory to another. It is all unnecessary.\n\nMy suggested resolution is to improve the way this buffering is managed. No array copies occur. No unnecessarily large heap allocations occur. Nothing is left to the garbage collector that doesn't have to be. The performance of this part of the code is improved. The drain that this code places on system resources is reduced.\n\nGiven that widespread use of various tag libraries, I still feel that this is a very worthwhile change. \n\n\nRegards\nBrian"}, {"count": 9, "tags": [], "bug_id": 43925, "attachment_id": null, "is_private": false, "id": 152338, "time": "2011-12-20T20:35:50Z", "creator": "markt@apache.org", "creation_time": "2011-12-20T20:35:50Z", "text": "This Tomcat 5 enhancement request has been moved to Tomcat 7 (the latest version) since Tomcat 5 development is limited and focussed on bugs and security issues whereas Tomcat 7 is still seeing new feature development."}, {"count": 10, "tags": [], "creator": "flop.m@usa.net", "is_private": false, "text": "Hi,\n\nFor this issue,\n\n- is there already a chosen new architecture for the new version of the buffering ?\n\nor\n\n- should it be discussed ?\n\nor\n\n- you let the numbers speak for any new implementation ?\n\n\nI'm willing to spend time on this for Tomcat 7, so answers from Tomcat devs are expected.\n\nThx\n--\nIssa", "id": 175985, "time": "2014-06-23T15:29:42Z", "bug_id": 43925, "creation_time": "2014-06-23T15:29:42Z", "attachment_id": null}, {"count": 11, "tags": [], "bug_id": 43925, "attachment_id": null, "id": 175992, "time": "2014-06-23T20:16:54Z", "creator": "markt@apache.org", "creation_time": "2014-06-23T20:16:54Z", "is_private": false, "text": "I don't recall any solutions being discussed but you should search the archives and review any discussions that there may have been about this feature.\n\nIt is up to you whether to discuss it first. Generally, the more complex and invasive the change the more useful early discussion is.\n\nA patch for this enhancement will be judged like any other. It isn't just about raw performance we also take into account the complexity of the resulting code, the invasiveness of the patch, the usefulness of the feature and so on.\n\nLarger changes are best reviewed as a series of smaller patches. See my WebSocket compression changes earlier today as an example of breaking a large patch down into a series of smaller patches to make it easier to review.\n\nNote that you should provide patches against tomcat trunk and they will then be back-ported to the release branches as appropriate."}, {"count": 12, "tags": [], "bug_id": 43925, "attachment_id": null, "is_private": false, "id": 176076, "time": "2014-06-27T14:48:02Z", "creator": "flop.m@usa.net", "creation_time": "2014-06-27T14:48:02Z", "text": "Brian, I've taken a look into the code you've submitted but I failed to understand how this code reduce the number of array copies in comparison with Tomcat's current implementation. I've ran the test cases with different values for the iteration and can't see real improvements.\n\nCalls to write(String) [1] will always induce a array copy, unfortunately, because they are immutable.\n\nCalls to write(char[]) [2] are not improvable because we don't know if the caller will reuse the char array - so we need to copy it.\n\nI don't know if calls to [1] are more frequent in a web app than calls to [2]. If it is the case, then trying to avoid the array copy from the String would be good overall. In fact, having to manage both char[] and Strings makes it harder to improve the whole class!\n\n\n\nSo as it seems that reducing the number of array copies is difficult while calling write() (even doable ?), maybe improving the way the buffer grows is the way to go - reducing the number of array copies and garbage creation.\n\nAny comment on my reflections ?"}, {"count": 13, "tags": [], "bug_id": 43925, "attachment_id": null, "is_private": false, "id": 176078, "time": "2014-06-27T17:44:57Z", "creator": "brian.remmington@celestialservices.co.uk", "creation_time": "2014-06-27T17:44:57Z", "text": "Hi Issa\n\nIt's been a while since I raised this (6 years), so I had to refresh my memory.\n\nI've just checked out the trunk of Tomcat 8, and the same problem exists, and I still think my code addresses it.\n\nYour final sentence describes exactly what my suggested solution does: it improves the way the buffer grows to reduce array copies and reduce garbage collection. Your other comments don't relate to my proposal.\n\nIn the current Tomcat class (org.apache.jasper.runtime.BodyContentImpl), the problem is with the method reAllocBuff(int) which is right at the bottom of the class. This is called when the buffer array (cb) needs to grow, and it's terribly inefficient.\n\nMy code replaces cb with an instance (named \"buffer\") of a new class CharBuffer which manages a LinkedList of char arrays to ensure that, upon growth (CharBuffer.grow), no array copy occurs, and nothing is left to the garbage collector."}, {"count": 14, "tags": [], "creator": "brian.remmington@celestialservices.co.uk", "is_private": false, "text": "I've just run the tests I provided again against Tomcat 8, ramping up the iterations in the BodyContentTest steadily to 1500000 (hardware is *so* much better now...).\n\nMy version is consistently 40% faster than the current version, however both are pretty quick these days. My machine can chew through 1000000 iterations in 1378ms with the current version (BodyContentImpl) and 824ms with my version (NewBodyContentImpl).\n\nSpeed isn't the main point of this, however. It's the very wasteful use of memory that was causing the real problem when I initially raised this issue. The garbage collector was kicking in constantly, completely draining CPU cycles.\n\nFor example, take the iterations up to 1500000 on my test machine, and the current version blows up with an OutOfMemory error. My version continues to work and scales fairly linearly (1341ms). Take it up further to 2000000 iterations, and mine starts to plateau (2393ms), but it still continues to work. At 3000000 iterations, my version completes in 4543ms.", "id": 176084, "time": "2014-06-28T10:37:36Z", "bug_id": 43925, "creation_time": "2014-06-28T10:37:36Z", "attachment_id": null}, {"attachment_id": null, "tags": [], "bug_id": 43925, "is_private": false, "count": 15, "id": 176125, "time": "2014-07-01T09:35:09Z", "creator": "flop.m@usa.net", "creation_time": "2014-07-01T09:35:09Z", "text": "I made some changes to the test case you provided to excluded the random (so that the random numbers are always the same for both cases) and run the test for one target only. JVM is Java HotSpot(TM) 64-Bit Server VM (25.5-b02) for linux-amd64 JRE (1.8.0_05-b13), ran with settings -server -Xloggc:gc.log -Xmx4G.\n\nI don't get the same results as yours and GC is running a lot more on your class than Tomcat's. (I can send you the results if you'd like)\n\nIt's true I can increase the number of iteration with your class before getting a OOE more than with Tomcat's.\n\nBut is this test case emulating real usage ? My next tests will be to run both class under Tomcat with a test case of several pages with tags triggered by jmeter. This will take me some time so I will not be back before several weeks.\n\nThx"}, {"count": 16, "tags": [], "text": "Created attachment 31841\nTest case to compare default and suggested implementation\n\nI've ran some tests with JMeter 2.11 against some small custom tags running under Tomcat 8.0.9.\n\nThe results from the Jmeter test in file show that the default implementation is a little bit faster than suggested one (number of jmeter samples being higher for the same amout of running time).\n\nCan someone run the tests I provided and report the results ? If any improvement or suggestion is found for the tests I provide, please report as well. Thx!", "attachment_id": 31841, "id": 176585, "creator": "flop.m@usa.net", "time": "2014-07-22T10:07:26Z", "bug_id": 43925, "creation_time": "2014-07-22T10:07:26Z", "is_private": false}, {"count": 17, "tags": [], "text": "This is being addressed under the following pull request:\nhttps://github.com/apache/tomcat70/pull/4\n\nI'm therefore marking this as resolved as I can't mark it as a duplicate of a PR.", "is_private": false, "id": 203228, "creator": "markt@apache.org", "time": "2018-01-11T20:09:29Z", "bug_id": 43925, "creation_time": "2018-01-11T20:09:29Z", "attachment_id": null}]