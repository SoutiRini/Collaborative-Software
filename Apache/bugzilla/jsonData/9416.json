[{"count": 0, "tags": [], "text": "We are using Tomcat 3.2.3 on Windows 2000/IIS 5 and we have a problem in that. \nThe memory allocated to Tomcat.exe is not getting released. Even many hours \nafter the usage has been stopped, the memory used is not coming down. \nDepending on the load, Tomcat reports Out of Memory error in a few hours or \ndays and the process occupies all available memory. The only option is to \nrestart the server. We had the same problem in Tomcat 4.03 also. And we have \ntried Tomcat with Apache also. This problem has already been reported by few \nother people in Tomcat3 bug database and has been resolved as fixed. What is \nthe possible cause of this problem? Is it a Tomcat bug?\n\nWe tried the following test program. After the memory allocated to Tomcat \nreaches 64 MB (Maximum set), Tomcat reports Out of memeory - can't create new \nthread error. But other normal JSP pages run without any problem. When we \nmonitor the heap memory, 99 to 100% remains used even after hours of \ninactivity. The only option is to restart Tomcat. Can any one tell whether \nanything is wrong with our test program?\n\n<%\nfor(int j=0;j<1000;j++)\n{\n   out.println(\"<hr>\"+j);\n   for(int i=0;i<10000;i++)\n   {\n      out.println(i);\n      String s1=\"\"+i;\n      Thread t = null;\n      t = new Thread(s1);\n      t = null;\n      s1 = null;\n   }\n   //System.gc();\n}\n%>", "attachment_id": null, "id": 16703, "creator": "netcomindia@vsnl.com", "time": "2002-05-25T14:22:14Z", "bug_id": 9416, "creation_time": "2002-05-25T14:22:14Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 9416, "attachment_id": null, "is_private": false, "id": 16704, "time": "2002-05-25T14:37:12Z", "creator": "pier@betaversion.org", "creation_time": "2002-05-25T14:37:12Z", "text": "Your code is bogus because it keeps creating thread object, which are stored as a reference by \nthe ThreadGroup of the thread which created them (it should be a weak referece, so at the end \nit should go away, but I'm not that positive about it, AFAICR the reference in the thread group \ngets removed only after the run method returns or throws an exception).\nAlso, creating 1000 threads in a process, is surely a recipe for going into troubles soon.\n"}, {"count": 2, "tags": [], "text": "Hi, \n    The idea of going for such a test code was just out of desperation and \nonly to try some small code with which we can get some help. Can u suggest \nsome code we can try out?\n", "attachment_id": null, "id": 16773, "creator": "netcomindia@vsnl.com", "time": "2002-05-27T15:20:28Z", "bug_id": 9416, "creation_time": "2002-05-27T15:20:28Z", "is_private": false}, {"count": 3, "attachment_id": null, "bug_id": 9416, "is_private": false, "id": 16851, "time": "2002-05-29T06:40:18Z", "creator": "netcomindia@vsnl.com", "creation_time": "2002-05-29T06:40:18Z", "tags": [], "text": "\tOur Java Web application is running on Tomcat 3.2.3 and once in every \nfew days,we are getting the following sort of error.\n\njava.lang.OutOfMemoryError: unable to create new native thread\n\tat java.lang.Thread.start(Native Method)\n\tat SeBase.DataConnection.createConnection(DataConnection.java:211)\n\tat SeBase.DataConnection.getConnection(DataConnection.java:191)\n\tat SeBase.CommonLogin.checkDatabase(CommonLogin.java:100)\n\tat SeBase.CommonLogin.setValues(CommonLogin.java:88)\n\tat \nsebase._0002fsebase_0002fcommon_0005floginaction_0002ejspcommon_0005floginactio\nn_jsp_0._jspService\n(_0002fsebase_0002fcommon_0005floginaction_0002ejspcommon_0005floginaction_jsp_\n0.java:211)\n\n\nThis happens only on pages which access the Database. Other JSPs are running \nfine even after the error has occurred. Because we are not creating threads in \nour application except for Database connection.\n\n\tFor Database connection, we are using a custom Data connection pooling \nmechanism (code given below). In that, while creating every new connection, we \nare creating a new thread which will check the usage of the connections after \nput to sleep for 2 minutes. If the connections are not in use for more than 1 \nminute, it will  close the connections and come out of run method. We have \nverified that the data connections are getting closed properly. But the \nthreads created during the process are not getting removed. \n\n\tIs it the right way? Or can we use one single thread which will check \nall the data connections every 2 minutes and will run from the starting of the \napplication server till it is closed? Can it lead us to any other problem?\n\n/**\n * Returns a JDCConnecton object if it is availabe in vector or creates a\n * new connection add it to vector and returns the same\n */\n   public synchronized Connection getConnection() throws Exception,SQLException\n   {\n      ConnectionPool f_obj_conn;   //for storing the connection pool object\n      for(int i = 0; i < f_obj_connections.size(); i++) //for loop for getting \nany free connection\n      {\n         f_obj_conn = (ConnectionPool)f_obj_connections.elementAt(i);\n         if (f_obj_conn.lease() && !f_obj_conn.isClosed())   //check for status\n         {\n\t\t\t\tSystem.out.print(\"\\nUsing Old Connection #\" +  \nf_int_total_conn + \"Connection name \" + f_obj_conn);\n            return f_obj_conn;\n         }   //end of if loop\n      }   //end of for loop\n      f_obj_conn = createConnection();\n      return f_obj_conn;\n   }\n\n\n/**\n * Creates a physical connection with the concerned database\n */\n   public synchronized ConnectionPool createConnection()throws Exception\n   {\n      ConnectionPool f_obj_conn_pool = null;   //for storing the pool object\n      if(f_obj_connections.size() < f_int_max_conn)   //check for max size\n      {\n        Class.forName(f_str_driver);\n        Connection f_obj_connection;   //for storing the connection\n        f_obj_connection = DriverManager.getConnection\n(f_str_url,f_str_user,f_str_password);\n        f_obj_conn_pool = new ConnectionPool(f_obj_connection, this);\n        f_obj_reaper = new ConnectionReaper(f_obj_conn_pool);\n  \t\t  f_int_total_conn = f_int_total_conn + 1;\t\n        f_obj_conn_pool.putThread(f_obj_reaper);\n        f_obj_conn_pool.lease();\n        f_obj_connections.addElement(f_obj_conn_pool);\n\t\t  f_obj_reaper.start();\t\n  \t\t  System.out.print(\"\\nNo Of Connection #\" +  f_int_total_conn \n+ \"New Connection Created \" + f_obj_connection);\n      }\n      if(f_obj_conn_pool == null)throw new Exception(\"SERVER TOO BUSY\");\n      return f_obj_conn_pool;\n   }\n\n\n/**\n * Closes all the stale connection as per specfied in vector size\n */\n\n   public synchronized void reapConnections()throws Exception\n   {\n      int f_int_index = 0;\n      long f_long_stale;   //for storing the stale or elapse time of connection\n      f_long_stale = System.currentTimeMillis() - f_long_timeout;\n      Enumeration f_obj_connlist;   //for getting the enumeration of connection\n      f_obj_connlist = f_obj_connections.elements();\n      //while loop for reaping connection\n      while((f_obj_connlist != null) && (f_obj_connlist.hasMoreElements()))\n      {\n         ConnectionPool f_obj_pool;   //for storing the connection pool object\n         f_obj_pool = (ConnectionPool)f_obj_connlist.nextElement();\n         //checking for status of connection\n         if(!f_obj_pool.inUse())\n         {\n            removeConnection(f_obj_pool.f_obj_conn);\n            Thread thread = f_obj_pool.getThread();\n            thread = null;\n\t\t\t\tf_int_removed_conn = f_int_removed_conn + 1;\n\t\t\t\tf_obj_connections.removeElement(f_obj_pool);\n     \t\t\tf_obj_connections.trimToSize();     \n         }\n         if((f_obj_pool.inUse()) && (f_long_stale > f_obj_pool.getLastUse()))\n         {\n            removeConnection(f_obj_pool.f_obj_conn);\n            Thread thread = f_obj_pool.getThread();\n            thread = null;\n  \t\t\t   f_int_removed_conn = f_int_removed_conn + 1;\n\t\t\t\tf_obj_connections.removeElement(f_obj_pool);\n     \t\t\tf_obj_connections.trimToSize();                 \n         }\n      }   //end of while loop\n   }\n\n\n\n/**\n * Removes the connecton object stored in the Connection vector\n * @param ConnectionPool\n */\n\n   private synchronized void removeConnection(Connection f_obj_conn)throws \nException\n   {\n      Connection connection = f_obj_conn;\n      connection.close();\n\t\tif(connection.isClosed())\n\t\t\tSystem.out.print(\"\\nConnection Closed  Connection Size \n#\" +  f_int_removed_conn + \"Connection \" + connection);\n\t\telse\n\t\t\tSystem.out.print(\"Connection not closed\");      \n   }\n\n/**\n * Run Method for a each  Thread of DataConnection object\n */\n   public void run()\n   {\n      while(true)   //while loop for invoking sleep method\n      {\n         try\n         {\n            //System.out.println(\"sleep called \" + this.f_obj_pool);\n              sleep(f_long_delay);\n         }\n         catch( InterruptedException e)\n         {\n\n         }\n         try\n         {\n         f_obj_pool.closeConnections();\n         }\n         catch(Exception e)\n         {}\n\n      }   //end of while loop\n   }\n}"}, {"count": 4, "attachment_id": null, "bug_id": 9416, "text": "Tomcat 3.2.x is known to have memory problems (TC 3.2 creating way to much \nobjects).\nUpgrade to Tomcat 3.3 or 4.0\n", "id": 18339, "time": "2002-06-21T16:06:05Z", "creator": "hgomez@slib.fr", "creation_time": "2002-06-21T16:06:05Z", "tags": [], "is_private": false}]