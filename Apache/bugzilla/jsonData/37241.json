[{"count": 0, "tags": [], "text": "<junit> tests that timeout do not perform their teardown if fork is set to\n\"true\", this can cause lots of trouble if database handles need to be closed or\nservers need to be shut down in the teardown.\n\nConsider the following junit test:\n\npackage org.example;\nimport junit.framework.TestCase;\npublic class TimeoutTest extends TestCase {\n\n\tpublic void setUp() {\n\t\tSystem.out.println(\"setUp\");\n\t}\n\n\tpublic void tearDown() {\n\t\tSystem.out.println(\"tearDown\");\n\t}\n\n\tpublic void testTimeout() {\n\t\tSystem.out.println(\"Test started\");\n\t\ttry {\n\t\t\tThread.sleep(5000);\n\t\t} catch (InterruptedException e) {\n\t\t\tSystem.out.println(\"Interrupted!\");\n\t\t}\n\t\tSystem.out.println(\"Test finished\");\n\t}\n}\n\n\nAnd the following ant buildfile fragment:\n\n<target name=\"test\" depends=\"compile\">\n\t<junit fork=\"yes\" timeout=\"3000\" showoutput=\"true\">\n\t\t<classpath path=\"classes\"/>\n\t\t<test name=\"org.example.TimeoutTest\"/>\n\t</junit>\n</target>\n\n\n\nIf run the test will timeout, the output on the console shows that the tearDown\nmethod is never executed:\ntest:\n    [junit] setUp\n    [junit] Test started\n    [junit] Test org.example.TimeoutTest FAILED (timeout)\n\nIf the timeout property in the buildfile is set to 6000 the test won't timeout\nand the output on the console is:\ntest:\n    [junit] setUp\n    [junit] Test started\n    [junit] Test finished\n    [junit] tearDown", "is_private": false, "bug_id": 37241, "id": 81706, "time": "2005-10-25T14:42:25Z", "creator": "wander@xs4all.nl", "creation_time": "2005-10-25T14:42:25Z", "attachment_id": null}, {"count": 1, "tags": [], "bug_id": 37241, "attachment_id": null, "text": "I see what you mean. I think this is probably the case. when we timeout we kill\nthe test process because they are deemed to have crashed in some way. \n\nRefactoring the junit test runner to do a cleaner shutdown would be a very\ncomplex process indeed. Maybe you could add some signal handler to do explicit\ncleanup for your tests,", "id": 81711, "time": "2005-10-25T15:04:54Z", "creator": "stevel@apache.org", "creation_time": "2005-10-25T15:04:54Z", "is_private": false}, {"count": 2, "tags": [], "creator": "wander@xs4all.nl", "text": "Adding a signal handler would probably solve the problem yes, but where do I\nhook it in? Is there some listener or eventhandler interface that I can\nimplement? I have tried it with a custom ResultFormatter, but that didn't work,\nit's endTestSuite() method is never called after a timeout.", "id": 81713, "time": "2005-10-25T15:19:46Z", "bug_id": 37241, "creation_time": "2005-10-25T15:19:46Z", "is_private": false, "attachment_id": null}, {"count": 3, "tags": [], "bug_id": 37241, "attachment_id": null, "text": "Correction: If the usefile attribute of a nested <formatter> element is set to\n\"true\" it's addError() and endTestSuite() methods ARE called after a timeout. \n\nThe addError method is called with an AssertionFailedError with message \"Timeout\noccured\" as argument.\n\nThis is as close as I can get to an entry point for the signal handler you\nmentioned. I could write a custom JUnitResultFormatter called\n\"JUnitTimeoutListener\" that calls the tearDown method of the current test if\nit's addError method is called with an AssertionFailedError with message\n\"Timeout occured\" as argument.\n\nSounds like an ugly hack, but I cannot think of anything better. Or is there a\nbetter way?", "id": 81718, "time": "2005-10-25T17:08:36Z", "creator": "wander@xs4all.nl", "creation_time": "2005-10-25T17:08:36Z", "is_private": false}, {"count": 4, "tags": [], "creator": "stevel@apache.org", "text": "That is an \"interesting hack\"; I'm not sure how it works and will probably have\nto look at some code to see. I always assumed that the timeout killed the\nprocess; what that does to the formatter i dont know -unless it is in the Ant\nprocess.\n\nMaybe timeouts is the kind of feature that junit-4 will deliver cleanly, but\nonly on java1.5. ", "id": 81722, "time": "2005-10-25T18:31:42Z", "bug_id": 37241, "creation_time": "2005-10-25T18:31:42Z", "is_private": false, "attachment_id": null}, {"count": 5, "tags": [], "bug_id": 37241, "attachment_id": 16817, "is_private": false, "id": 81832, "time": "2005-10-27T17:46:03Z", "creator": "wander@xs4all.nl", "creation_time": "2005-10-27T17:46:03Z", "text": "Created attachment 16817\nAn elaborate hack around bug#37241 using a custom JUnitResultFormatter\n\nThis attachment contains four files: \n\n(1) org.example.TimeoutTest: a test that can timeout\n(2) org.example.TimeoutTestSetup: a TestSetup that leaves a trace if it's\ntearDown method isn't executed\n(3) org.example.TimeoutTestListener: an implementation of JUnitResultFormatter\nthat calls the tearDown method of the TestSetup if a timeout occurs.\n(4) build.xml: a buildfile for compiling and running the test.\n\nNOTE that before this works you need to copy junit.jar, ant.jar and\nant-junit.jar to the lib directory.\n\n\nAlthough it works I am not really satisfied with it, especially the part with\nthe custom TestRunner and TestSuiteLoader, but I have no idea how to solve this\nbetter."}, {"count": 6, "tags": [], "text": "Created attachment 16819\nFixed bug in previous attachment\n\nThis fix calls the attention to another drawback of this hack: the tearDown\nmethod called by the ResultFormatter must be stateless since the fixture set up\nby the setUp method is gone. \n\nThe only difference between this version and the previous is that the tearDown\nin TimeoutTestSetup has been made stateless (doesn't depend on a fixture)", "is_private": false, "bug_id": 37241, "id": 81838, "time": "2005-10-27T18:02:08Z", "creator": "wander@xs4all.nl", "creation_time": "2005-10-27T18:02:08Z", "attachment_id": 16819}, {"attachment_id": null, "tags": [], "bug_id": 37241, "is_private": false, "count": 7, "id": 81855, "time": "2005-10-27T21:12:21Z", "creator": "wander@xs4all.nl", "creation_time": "2005-10-27T21:12:21Z", "text": "Ofcourse a stateless tearDown is of very limited use. But anyway this workaround\nis nessessary only in the case of things like open database handles or an\nexternal server which has been started in the setUp (or, as in the example, a\nfile with a known name)."}, {"count": 8, "tags": [], "creator": "wander@xs4all.nl", "text": "Created attachment 16843\nA workaround for this bug\n\nThis attachment obsoletes the previous ones:\n1>It is much simpler, no more complicated classsloader/ant properties stuff,\nthat was unnessessary.\n2>It can handle nested TestSetups\n\nStill a stateless tearDown, for my purposes that is sufficient.", "id": 81996, "time": "2005-10-31T17:45:53Z", "bug_id": 37241, "creation_time": "2005-10-31T17:45:53Z", "is_private": false, "attachment_id": 16843}, {"count": 9, "tags": [], "text": "a modified version has been committed as svn revision 689751.\n\nPlease note that the listener's usefulness is pretty limited (and the manual will say so).\n\n* it runs in a different VM than the original test did\n\n* it can only run if there was just a single test in the forked VM - since there is no way to determine which test case failed if running multiple tests.  This also means we can't do anything if the test contains a suite() method\n\n* the listener may see a different classloader than the forked VM and may be unable to load the test class.\n\nI haven't used you code to deal with nested TestSetups since it used a different logic than Ant's testrunner itself and thus may identify different test classes than the runner executed.", "is_private": false, "bug_id": 37241, "id": 120164, "time": "2008-08-28T00:56:49Z", "creator": "bodewig@apache.org", "creation_time": "2008-08-28T00:56:49Z", "attachment_id": null}]