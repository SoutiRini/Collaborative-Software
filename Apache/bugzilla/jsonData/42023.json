[{"count": 0, "tags": [], "text": "When a LoggingEvent object is serialized, the message object is lost.  This is\nbecause the message object is a transient field, so it is rendered as a String\nupon Serialization.\n\nI am submitting this as a bug, instead of a feature request, because the current\nfunctionality is broken when using custom objects and certain combinations of\nAppenders.  If I use only a database Appender with a custom object, I can insert\nall of the custom log data into the correct database fields with correct types.\n If I use a SocketAppender followed by a file Appender, I can render all of my\nlog data properly in the file.  However, if I use a SocketAppender followed by\nmy database Appender, the current log4j will not allow me to access all of the\ndata in a custom object to insert them into the correct database fields.  A\ncorrect implementation should allow Appenders to function in the same way\nregardless of whether they are called on a machine generating log events or a\nmachine collecting log events.\n\nThe other solution, which I find less desirable, would be to change the API to\nallow only logging of Strings, and not Objects.  Being able to use custom\nobjects as log events is very valuable, as it allows for logging application\nspecific details such as IP address, username, application version, and much\nmuch more.\n\nI created a patch to spi/LoggingEvent.java in log4j version 1.2.14.  The basic\nidea is that if the message object implements Serializable, it is stored in a\nnon-transient field.  If the object is not serializable, the functionality is\nunchanged.  I can create a similar patch for the latest development version if\nthat is desirable.\n\n\n--- LoggingEvent.java.orig\t2007-03-21 18:58:50.000000000 -0400\n+++ LoggingEvent.java\t2007-04-02 14:14:19.000000000 -0400\n@@ -23,6 +23,7 @@\n import java.lang.reflect.Method;\n import java.io.ObjectOutputStream;\n import java.io.ObjectInputStream;\n+import java.io.Serializable;\n import java.util.Hashtable;\n \n // Contributors:   Nelson Minar <nelson@monkey.org>\n@@ -106,6 +107,9 @@\n   /** The application supplied message of logging event. */\n   transient private Object message;\n \n+  /** A non-transient place holder for the serialized message Object. */\n+  private Serializable serializableMessage;\n+\n   /** The application supplied message rendered through the log4j\n       objet rendering mechanism.*/\n   private String renderedMessage;\n@@ -377,6 +381,9 @@\n   private void readObject(ObjectInputStream ois)\n                         throws java.io.IOException, ClassNotFoundException {\n     ois.defaultReadObject();\n+    if(serializableMessage != null) {\n+      message = serializableMessage;\n+    }\n     readLevel(ois);\n \n     // Make sure that no location info is available to Layouts\n@@ -386,6 +393,11 @@\n \n   private\n   void writeObject(ObjectOutputStream oos) throws java.io.IOException {\n+    // If the message can be serialized, save it off in a non-transient field.\n+    if(message instanceof Serializable) {\n+      serializableMessage = (Serializable)message;\n+    }\n+\n     // Aside from returning the current thread name the wgetThreadName\n     // method sets the threadName variable.\n     this.getThreadName();", "attachment_id": null, "id": 101339, "creator": "peter@oskrafts.org", "time": "2007-04-02T13:04:51Z", "bug_id": 42023, "creation_time": "2007-04-02T13:04:51Z", "is_private": false}, {"attachment_id": null, "tags": [], "bug_id": 42023, "text": "I'm unclear whether you are saying the SocketAppender corrupts the original LoggingEvent so that other \nappenders can't access the original message object.  Basically, that you have a log4j configuration with a \nSocketAppender and your custom DBAppender and your DBAppender stops working when the \nSocketAppender is added. I reviewed the code and didn't see a mechanism for that to happen, but maybe I \nmissed something.\n\nIf you are saying that a deserialized LoggingEvent (perhaps reconstituted by a SocketReceiver) is missing \nthe original message, that is by design and would have to wait until 1.2.16 to be looked at since it would \nchange the wire format for SocketAppender.", "count": 1, "id": 106993, "time": "2007-08-21T15:27:45Z", "creator": "carnold@apache.org", "creation_time": "2007-08-21T15:27:45Z", "is_private": false}, {"count": 2, "tags": [], "bug_id": 42023, "text": "To clarify the original submission, the later scenario from above is what I am\nreferring to.  I believe it is a design flaw for the log4j paradigm to fall\napart when LoggingEvents are serialized.  Log4j should either cause serialized\nmessage objects to be reconstituted when a LoggingEvent is deserialized (which\nis what my patch accomplishes), or should refuse to allow logging of arbitrary\nmessage objects.\n\nI understand the need for keeping the SocketAppender and SocketReceiver\nunchanged, but the sample patch I submitted should accomplish the intended\npurpose while being completely transparent to the rest of the log4j codebase,\nincluding any Appenders.", "id": 107352, "time": "2007-08-28T10:18:47Z", "creator": "peter@oskrafts.org", "creation_time": "2007-08-28T10:18:47Z", "is_private": false, "attachment_id": null}, {"count": 3, "tags": [], "bug_id": 42023, "attachment_id": null, "text": "I don't think that an \"old\" SocketAppender and a \"new\" SocketReciver can talk together with your patch.\n\nI think it would be better to create a super class of LoggingEvent which has the serializable field, and then create a SocketAppenderIncludingLoggingEvent (or something) appender which does the necessary voodoo as it will be backward compatible.\n\nCould you elaborate on the circumstances where this missing field is an issue when deserialized?", "id": 119313, "time": "2008-08-03T03:11:56Z", "creator": "thorbjoern@gmail.com", "creation_time": "2008-08-03T03:11:56Z", "is_private": false}, {"count": 4, "tags": [], "bug_id": 42023, "attachment_id": null, "text": "Discarding the message object and only transmitting the rendered form was an explicit and documented design decision in log4j 1.2.  It is much too late to surprise existing users who may be using an expensive to serialize message object with a potentially huge performance hit on a maintenance release.\n\nChanging the API to not allow arbitrary objects is even worse than a performance hit.  We absolutely can't change the API in anything other than a major release.\n\nI have added a log4j 2.0 bug to keep this on the log4j 2.0 radar (https://issues.apache.org/jira/browse/LOG4J2-21).\n\n\n\n\n", "id": 119469, "time": "2008-08-05T22:28:05Z", "creator": "carnold@apache.org", "creation_time": "2008-08-05T22:28:05Z", "is_private": false}]