[{"count": 0, "attachment_id": 23408, "creator": "rc46fi@googlemail.com", "is_private": false, "id": 125756, "time": "2009-03-24T07:10:05Z", "bug_id": 46902, "creation_time": "2009-03-24T07:10:05Z", "tags": [], "text": "Created attachment 23408\nPatch-file for Tomcat's latest trunk\n\nImplementation of the <b>Valve</b> interface forcing any request to protected\ncontent to a pre-configured login-page if no valid session exists\n\nSince j_security_check always forwards to the last request after presenting\nthe credentials, it's sometimes annoying that after a session-timeout and re-entering the credentials, the last url requested often points to some location which might be included in a website but should not be served on their own (i.e. a graphics-file, some JavaScript, a css-file or similar.\n\nThis problem especially exists for website using frames / iframes.\nWithin LoginValve, protected paths and their default redirect-paths after\nsuccessful authentication can be specified.\n\nExample:\n <Context>\n       <Valve  className=\"org.apache.catalina.valves.LoginValve\"\n                       protectedPath=\"/foo/baar\"\n                       redirectAfterAuth=\"/foo/index.html\"/>\n </Context>\n\nIn the example above there are two paths specified:\n   protectedPath \t- protected Path (recursive) having a default redirect\n   redirectAfterAuth\t- url to be displayed after successful authentication"}, {"count": 1, "attachment_id": 23410, "creator": "rc46fi@googlemail.com", "is_private": false, "id": 125760, "time": "2009-03-24T08:15:03Z", "bug_id": 46902, "creation_time": "2009-03-24T08:15:03Z", "tags": [], "text": "Created attachment 23410\nPatch-file for Tomcat 6.0.x-trunk\n\nAdded patch for Tomcat 6.0.x-trunk"}, {"count": 2, "tags": [], "creator": "chris@christopherschultz.net", "text": "A few questions:\n1. Why can't the \"redirectAfterAuth\" path be within the protected space?\n2. Why do you check to see if the request URI /startsWith/ the\n   redirectAfterAuth instead of being equal to it?\n3. Why are you checking to see if characters 10 - 16 of the request URI\n   are \"y_check\". Why not check for the whole \"j_security_check\" string?\n   Why not check the /end/ of the request URI for j_security_check,\n   since the URI for j_security_check is not required to be\n   /j_security_check but pretty much */j_security_check?\n4. Why are killing the session if the authtype is null?\n5. Why does your valve pass-through any requests before the component\n   has \"started\"? Is there a valid use case where NOT performing these\n   checks and redirects is appropriate?\n\nIt appears that your valve does nothing but murder the session and redirect the user if authtype=null and you are requesting a resource from a particular URI space. This does not seem particularly useful.\n\nMaybe I'm missing something subtle.", "id": 126829, "attachment_id": null, "bug_id": 46902, "creation_time": "2009-05-06T19:08:09Z", "time": "2009-05-06T19:08:09Z", "is_private": false}, {"count": 3, "tags": [], "bug_id": 46902, "is_private": false, "id": 126851, "creation_time": "2009-05-07T04:16:18Z", "time": "2009-05-07T04:16:18Z", "creator": "rc46fi@googlemail.com", "text": "Chris,\n\nOn Thu, May 7, 2009 at 4:07 AM, Christopher Schultz <chris@christopherschultz.net> wrote:\n>\n> A few questions:\n>\nChris, maybe you'll get the hang of this Valve if I explain the business-requirement I had:\n\nMy primary target was to cirumvent the problem having a framed web-app, where some content is requested after the session has timed out.\n\nlet's say we have the following website-structure:\n\n+----------------------------------------+\n| menue1 |                               |    \n| menue2 |     some_content              |    \n| menue3 |                               |    \n| menue4 |                               |    \n| menue5 |                               |    \n+----------------------------------------+\n\n(hope the formatting is ok )\n\n\"some_content\" is an iframe, and the content of this iframe is changed by selecting one of the left menue-items.\nThe iframe is specified in \"index.html such as:\n\n<html>\n    <body>\n           <iframe name=\"some_content\" src=\"/protected/somepage.html\">\n                    Some iframe-error-message\n            </iframe>\n    </body>\n</html>\n\nNow let's assume, session is timing out, and after that timeout the user selects one of the menue-entries on the left side.\nWhat's happening?\n\nThe url requested will look like \"http://mysite/protected/some_stuff\"\n\nThe HTML in that case looks like\n\n<a href=\"http://mysite/protected/some_stuff.html\" target=\"some_content\">menue4</a>\n\nNow this triggers j_security_check, but unfortunately j_security_check just stores the last request, and after passing the credentials,\nyou'll won't see your \"index.html\" but \"/protected/some_stuff.html\" - without the iframe and aboviously without the menue.\n\nSo the purpose of this Valve is to provide a mechanism which makes sure, that if a non-authorized request comes in requesting anything else but your \"/protected/index.html\", that the original request (i.e. \"/protected/some_stuff\") is replaced by\n\"/protected/index.html\" (or any other url being specified in the Valve-descriptor).\n\nNow take a look at some example-Valve-descriptor:\n\n<Context>\n    <Valve  className=\"org.apache.catalina.valves.LoginValve\"\n            protectedPath=\"/protected\"\n            redirectAfterAuth=\"/protected/index.html\"/>\n</Context>\n\nThis basically says, that all /non-authorized/ requests to the protected content will be re-routed to \"/protected/index.html\" (redirectAfterAuth).\n\n> 1. Why can't the \"redirectAfterAuth\" path be within the protected space?\n>\n\nActually I do not see why this shouldn't be possible: Actually the idea is, that redirectAfterAuth /must/ be in the protected area\n\nIf you take a look at the first condition:\n\nif (aRequest.getRequestURI().startsWith(protectedPath)\n    && \n    !aRequest.getRequestURI().startsWith(redirectAfterAuth)\n    && \n    !aRequest.getRequestURI().startsWith(\"/j_security_check\", 10)) {\n\nBasically it says:\n\n- Only URLs are handled being in my protected area\n- the URL must /not/ be equal my default protected starting-URL\n- the URL requested must /not/ be j_security_check\n\nThe two latter conditions are necessary to avoid an infinite loop when accessing protected content\n\n> 2. Why do you check to see if the request URI /startsWith/ the\n>   redirectAfterAuth instead of being equal to it?\n\nBecause there might be some parameters after the adress in the URL - i.e., if Cookies are not possible so that the session-information is stored within the URL\n\n> 3. Why are you checking to see if characters 10 - 16 of the request URI\n>   are \"y_check\". Why not check for the whole \"j_security_check\" string?\n>   Why not check the /end/ of the request URI for j_security_check,\n>   since the URI for j_security_check is not required to be\n>   /j_security_check but pretty much */j_security_check?\n\nYou are right with this:\n\nActually I made a mistake here:\n\nWhen \"j_security_check\" is triggered, the URL will look like\n\n/protected/j_security_check\n\nAs you can see, in this example it works since \"/protected\" is exactly 10 characters long.\n\nTherefore, the correct code would be \n\n\t&& !aRequest.getRequestURI().startsWith(\"/j_security_check\"\n\t\t, protectedPath.length())) {\n\nI'll correct that with a new patch during the weekend.\n\nWhy do I not ask for the String ending with \"j_security_check\"? \nI was not sure how that URL looks like if session-info is encoded within the URL - therefore I'm using startsWith()\n\n> 4. Why are killing the session if the authtype is null?\n\nBecause we experienced with some users, esp. behind company-proxies, that situations may occur where a session still exists, but the Principal was null.\nTherefore, if Principal is null, better be safe than sorry and make sure you definately have a new session\n\n> 5. Why does your valve pass-through any requests before the component\n>   has \"started\"? Is there a valid use case where NOT performing these\n>   checks and redirects is appropriate?\n\nNope. I took this code from AccessLogValve (I believe it was that one), and my assumption was those checks don't make sense /before/ the Valve is completely set (started).\nIf you feel that a different approach does make more sense here, I'm happy for your suggestions\n\n>\n> It appears that your valve does nothing but murder the session and\n> redirect the user if authtype=null and you are requesting a resource\n> from a particular URI space. This does not seem particularly useful.\n>\n> Maybe I'm missing something subtle.\n>\n\nSeems to be - see my explanations on top.\n\nCheers", "attachment_id": null}, {"count": 4, "attachment_id": null, "creator": "markt@apache.org", "is_private": false, "id": 180781, "time": "2015-02-05T10:41:43Z", "bug_id": 46902, "creation_time": "2015-02-05T10:41:43Z", "tags": [], "text": "Getting back to this after far too long.\n\nI understand the problem you are trying to solve but I don't think that this Valveis generic enough to include in Tomcat. My largest concern is that the requirement that all the protected pages are under a single URL space.\n\nSince this enhancement request was made, the landingPage option has been added to the FORM authenticator. I believe an additional option of \"forceLandingPageAfterAuth\" that always redirected the user to the landing page rather than their requested page would meet this requirement. This should be fairly easy to implement."}, {"count": 5, "tags": [], "text": "(In reply to Mark Thomas from comment #4)\n> I don't think that this Valve is generic enough to include in Tomcat.\n\nAgreed.\n\n> \n> I believe an additional option of\n> \"forceLandingPageAfterAuth\" that always redirected the user to the landing\n> page rather than their requested page would meet this requirement. This\n> should be fairly easy to implement.\n\nI think it does not match the OP's use case of iframes.\n\n\nIn OP's use case #1 (Comment 3) request for protected resource http://mysite/protected/some_stuff.html  goes to iframe.  So the login form will be displayed in the iframe.  Generally you wouldn't want login form in a iframe, so I think that the login page has to perform some logic to detect that it is an iframe and to change the URL of the containing page.\n\nIn this case the form page shall adapt its behaviour depending on requested URI. Instead of displaying a form it shall redirect the top frame to /protected/index.html. (E.g. return a small placeholder page that changes top frame URL via javascript).\n\nIf the top frame URL is /protected/index.html then after authentication the User will be directed to /protected/index.html, as expected.\n\n\nIn OP's use case #2 (Comment 1) - request to a graphics-file, some JavaScript, a css-file.\n\nAgain, the form page shall adapt its behaviour dependent on requested URI. It shall not return a HTML form instead of an image. A browser won't be happy to receive one.\n\n\nI think that instead of using \"forceLandingPageAfterAuth\" one shall implement a dynamic login form page that does check request URI, and when (requestURI != landingPageURI) it responds with 302 redirect to the landing page instead of displaying a form.\n\nNote \"forceLandingPageAfterAuth\" feature and using 302 redirect in login form differ in the URL that is displayed in location bar of a web browser during authentication.\n\nIn case of \"forceLandingPageAfterAuth\":\nThe URL displayed in location bar of a browser will be the one of the protected resource.\n\nIt is confusing. After authentication you are not directed to that URL but 302-redirected to the landing page. What have you been authenticating for?\n\nIn case of login form page sending a 302-redirect to the landing page:\nThe displayed URL during authentication will be the same as the one after authentication - the landing page.  I think that this behaviour is better.", "attachment_id": null, "bug_id": 46902, "id": 180793, "time": "2015-02-05T13:36:24Z", "creator": "knst.kolinko@gmail.com", "creation_time": "2015-02-05T13:36:24Z", "is_private": false}, {"count": 6, "attachment_id": null, "creator": "markt@apache.org", "is_private": false, "id": 180794, "time": "2015-02-05T13:44:33Z", "bug_id": 46902, "creation_time": "2015-02-05T13:44:33Z", "tags": [], "text": "In which case the logic has to exist in the login page and there is nothing for us to do here."}, {"count": 7, "tags": [], "bug_id": 46902, "is_private": false, "id": 180809, "creation_time": "2015-02-05T19:43:09Z", "time": "2015-02-05T19:43:09Z", "creator": "chris@christopherschultz.net", "text": "As much as I like this kind of capability (particularly the addition of \"landingPage\" and something like the proposal to add \"forceLandingPageAfterAuth\"), I don't think is belongs in Tomcat because it's out-of-spec.\n\nI implemented a bunch of things in securityfilter to get around holes I saw in the spec and while tempted to bring them into Tomcat, discarded the notion because of that very fact (out-of-spec). I really hate product lock-in and it would be a shame for Tomcat to go down that path.\n\nSpecifically, I implemented the following features in this area:\n\n1. A landing page if there was no protected-page-access that caused the login form to be displayed (same as the \"langingPage\" feature)\n2. The ability for the login page to accept a \"next\" page that would basically take the place of a \"landing page\", or override it\n3. The ability for the client to specify whether or not the post-authentication action would be to REDIRECT or FORWARD to the landing page\n4. The ability to pass request parameters to the login page which would then be forwarded to the landing page\n\nSome of this doesn't make sense unless you have very specific requirements (which we did). In our use-case, we had two web applications that share a URL space and one of them does not use sessions at all... it just passes-through the session-id of the other application when we make loopback-requests to the \"other\" application. If there's no session in the authenticated-application, we have to sent the user to a login page, but then have them sent back to the resource they were trying to access (which is in the non-authenticated application). So, we can't just send the user to the \"protected resource\" because that resource isn't directly-protected... instead, it's protected-by-proxy.\n\nIt sounds outrageously stupid, but I promise it makes sense, and these features helped us pull it off. :)\n\nThese days, with HttpServletRequest.authenticate() and HttpServletRequest.login() being available, it seems like all of the capability could be provided by a Filter on an unprotected resource rather than trying to shoehorn it into the existing authentication valve.", "attachment_id": null}]