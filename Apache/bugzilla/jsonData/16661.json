[{"count": 0, "tags": [], "bug_id": 16661, "attachment_id": null, "text": "Example: If you have CookieName set to \"ID\", then use of strstr() in\nspot_cookie() mod_usertrack.c will get false positives on the following sorts of\ncookies: \"MyID=binky\", \"MyCookie=IDExpired\". This follows up bugs 11998, 8906,\n8048, 5811, and probably others. This bug keeps getting submitted. Here is a\npatch that has been thoroughly tested (more details at\nhttp://www.manniwood.net/mod_usertrack_patch.html):\n\n--- mod_usertrack.c\t2002-03-13 16:05:34.000000000 -0500\n+++ mod_usertrack_1.3_fixed.c\t2003-01-31 12:10:46.000000000 -0500\n@@ -119,6 +119,8 @@\n     cookie_type_e style;\n     char *cookie_name;\n     char *cookie_domain;\n+    char *regexp_string;  /* used to compile regexp; save for debugging */\n+    regex_t *regexp;  /* used to find usertrack cookie in cookie header */\n } cookie_dir_rec;\n \n /* Define this to allow post-2000 cookies. Cookies use two-digit dates,\n@@ -250,31 +252,44 @@\n {\n     cookie_dir_rec *dcfg = ap_get_module_config(r->per_dir_config,\n \t\t\t\t\t\t&usertrack_module);\n-    const char *cookie;\n-    char *value;\n+    const char *cookie_header;\n+\n+    /* There are only three possibilities from the regexp\n+     * ^cookie_name=([^;]+)|;[ \\t]+cookie_name=([^;]+)\n+     * because $0 is always filled with the whole match, and $1 and $2 will\n+     * be filled with either of the parenthesis matches. So, I \n+     * allocate regm[3] to cover all these cases. */\n+    regmatch_t regm[3];\n+    int i;\n \n     if (!dcfg->enabled) {\n         return DECLINED;\n     }\n \n-    if ((cookie = ap_table_get(r->headers_in,\n-                               (dcfg->style == CT_COOKIE2\n-                                ? \"Cookie2\"\n-                                : \"Cookie\"))))\n-        if ((value = strstr(cookie, dcfg->cookie_name))) {\n-            char *cookiebuf, *cookieend;\n-\n-            value += strlen(dcfg->cookie_name) + 1;  /* Skip over the '=' */\n-            cookiebuf = ap_pstrdup(r->pool, value);\n-            cookieend = strchr(cookiebuf, ';');\n-            if (cookieend)\n-                *cookieend = '\\0';      /* Ignore anything after a ; */\n-\n-            /* Set the cookie in a note, for logging */\n-            ap_table_setn(r->notes, \"cookie\", cookiebuf);\n+    if ((cookie_header = ap_table_get(r->headers_in,\n+                                      (dcfg->style == CT_COOKIE2\n+                                       ? \"Cookie2\"\n+                                       : \"Cookie\")))) {\n+\tif (!ap_regexec(dcfg->regexp, cookie_header, dcfg->regexp->re_nsub + 1, regm,\n0)) {\n+\t    char *cookieval = NULL;\n+\t    /* Our regexp,\n+\t     * ^cookie_name=([^;]+)|;[ \\t]+cookie_name=([^;]+)\n+\t     * only allows for $1 or $2 to be available. ($0 is always\n+\t     * filled with the entire matched expression, not just\n+\t     * the part in parentheses.) So just check for either one\n+\t     * and assign to cookieval if present. */\n+\t    if (regm[1].rm_so != -1) {\n+\t\tcookieval = ap_pregsub(r->pool, \"$1\", cookie_header, dcfg->regexp->re_nsub +\n1, regm);\n+\t    }\n+\t    if (regm[2].rm_so != -1) {\n+\t\tcookieval = ap_pregsub(r->pool, \"$2\", cookie_header, dcfg->regexp->re_nsub +\n1, regm);\n+\t    }\n+\t    /* Set the cookie in a note, for logging */\n+\t    ap_table_setn(r->notes, \"cookie\", cookieval);\n \n-            return DECLINED;    /* There's already a cookie, no new one */\n-        }\n+\t    return DECLINED;    /* There's already a cookie, no new one */\n+\t}\n+    }\n     make_cookie(r);\n     return OK;                  /* We set our cookie */\n }\n@@ -382,7 +397,20 @@\n {\n     cookie_dir_rec *dcfg = (cookie_dir_rec *) mconfig;\n \n+    /* The goal is to end up with this regexp, \n+     * ^cookie_name=([^;]+)|;[ \\t]+cookie_name=([^;]+)\n+     * with cookie_name\n+     * obviously substituted with the real cookie name set by the\n+     * user in httpd.conf. */\n+    dcfg->regexp_string = ap_pstrcat(cmd->pool, \"^\", name, \"=([^;]+)|;[ \\t]+\",\nname, \"=([^;]+)\", NULL);\n+\n     dcfg->cookie_name = ap_pstrdup(cmd->pool, name);\n+\n+    dcfg->regexp = ap_pregcomp(cmd->pool, dcfg->regexp_string, REG_EXTENDED);\n+    if (dcfg->regexp == NULL) {\n+\treturn \"Regular expression could not be compiled.\";\n+    }\n+\n     return NULL;\n }", "id": 30454, "time": "2003-02-01T00:19:29Z", "creator": "manniwood@planet-save.com", "creation_time": "2003-02-01T00:19:29Z", "is_private": false}, {"count": 1, "attachment_id": 4674, "bug_id": 16661, "is_private": false, "id": 30455, "time": "2003-02-01T00:22:42Z", "creator": "manniwood@planet-save.com", "creation_time": "2003-02-01T00:22:42Z", "tags": [], "text": "Created attachment 4674\npatch for spot_cookie() bug in mod_usertrack"}, {"count": 2, "attachment_id": null, "creator": "jwoolley@apache.org", "is_private": false, "id": 44547, "time": "2003-09-23T22:37:55Z", "bug_id": 16661, "creation_time": "2003-09-23T22:37:55Z", "tags": [], "text": "*** Bug 11998 has been marked as a duplicate of this bug. ***"}, {"count": 3, "attachment_id": null, "bug_id": 16661, "is_private": false, "id": 44549, "time": "2003-09-23T22:38:15Z", "creator": "jwoolley@apache.org", "creation_time": "2003-09-23T22:38:15Z", "tags": [], "text": "*** Bug 16662 has been marked as a duplicate of this bug. ***"}, {"count": 4, "attachment_id": null, "bug_id": 16661, "is_private": false, "id": 44550, "time": "2003-09-23T22:39:00Z", "creator": "jwoolley@apache.org", "creation_time": "2003-09-23T22:39:00Z", "tags": [], "text": "Fixed in 2.1.0-dev, thanks Manni.  Backports to 2.0-dev and 1.3-dev will be \nproposed. "}]