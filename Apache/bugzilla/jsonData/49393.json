[{"count": 0, "tags": [], "text": "When we have a cached-and-stale entry, and the entry is updated with a 200 OK, mod_cache attempts to remove the old cached entity:\n\n        else if (!r->header_only) {\n            /* Oh, well.  Toss it. */\n            cache->provider->remove_entity(cache->stale_handle);\n            /* Treat the request as if it wasn't conditional. */\n            cache->stale_handle = NULL;\n            /*\n             * Restore the original request headers as they may be needed\n             * by further output filters like the byterange filter to make\n             * the correct decisions.\n             */\n            r->headers_in = cache->stale_headers;\n        }\n\nremove_entity() just NULLs out the cache object, it does not remove the stale file on disk. This creates a race condition where for a brief time, the headers from the new entity exist alongside the body of the stale entry.\n\nTo work around this, remove_entity() should be replaced with remove_url().\n\nTo properly fix this on trunk, we need to relook at the format for the data file. The data file needs to be linked to from the headers file, and the headers file needs to be written after the data file is written. This removes the race completely, and allows us to update the cache atomically. This is not something that is likely to be backportable to v2.2 though, thus the workaround first.", "is_private": false, "bug_id": 49393, "id": 137382, "time": "2010-06-06T10:18:31Z", "creator": "minfrin@sharp.fm", "creation_time": "2010-06-06T10:18:31Z", "attachment_id": null}, {"count": 1, "attachment_id": null, "creator": "minfrin@sharp.fm", "is_private": false, "id": 140805, "time": "2010-10-18T18:58:53Z", "bug_id": 49393, "creation_time": "2010-10-18T18:58:53Z", "tags": [], "text": "Fixed on trunk, writes are now atomic."}]