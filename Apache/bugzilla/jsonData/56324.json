[{"count": 0, "attachment_id": null, "creator": "dclarke@blastwave.org", "is_private": false, "id": 174135, "time": "2014-03-27T16:39:07Z", "bug_id": 56324, "creation_time": "2014-03-27T16:39:07Z", "tags": [], "text": "n.b. : This may be related to 49277 or 52542\n\nIn lines 517 onwards of modules/ssl/ssl_util_ssl.c I see : \n\n   517  /*  _________________________________________________________________\n   518  **\n   519  **  Session Stuff\n   520  **  _________________________________________________________________\n   521  */\n   522  \n   523  char *SSL_SESSION_id2sz(unsigned char *id, int idlen,\n   524                          char *str, int strsize)\n   525  {\n   526      if (idlen > SSL_MAX_SSL_SESSION_ID_LENGTH)\n   527          idlen = SSL_MAX_SSL_SESSION_ID_LENGTH;\n   528          \n   529      /* We must ensure not to process more than what would fit in the\n   530       * destination buffer, including terminating NULL */\n   531      if (idlen > (strsize-1) / 2)\n   532          idlen = (strsize-1) / 2;\n   533  \n   534      ap_bin2hex(id, idlen, str);\n   535  \n   536      return str;\n   537  }\n\n\nWhat I don't see if a check for idlen being 0 and therefore a need for a \nvalid id as per section 7 ( page 26 ) of RFC 5246 which states : \n\n\n\n The Handshake Protocol is responsible for negotiating a session,\n   which consists of the following items:\n\n   session identifier\n      An arbitrary byte sequence chosen by the server to identify an\n      active or resumable session state.\n\n\nOne would think that with TLS1.2 that the handshake process is complete in \norder to receive a page of data in a modern browser via https and therefore\nthe SSL_SESSION_ID is not blank.\n\nOn initial connect and GET from Apache 2.4.9 ( Apache/2.4.9 (Unix) \nPHP/5.4.26 OpenSSL/1.0.1e ) I do get other reasonable SSL environment \nvariables and they look correct thus : \n\nSSL_CIPHER: DHE-RSA-AES256-SHA\nSSL_CIPHER_ALGKEYSIZE: 256\nSSL_CIPHER_EXPORT: false\nSSL_CIPHER_USEKEYSIZE: 256\nSSL_CLIENT_VERIFY: NONE\nSSL_COMPRESS_METHOD: NULL\nSSL_PROTOCOL: TLSv1.2\nSSL_SECURE_RENEG: true\nSSL_SERVER_A_KEY: rsaEncryption\nSSL_SERVER_A_SIG: sha1WithRSAEncryption\nSSL_SERVER_I_DN: CN=VeriSign Class 3 Extended Validation SSL CA,OU=Terms of use at https://www.verisign.com/rpa (c)06,OU=VeriSign Trust Network,O=VeriSign\\, Inc.,C=US\nSSL_SERVER_I_DN_C: US\nSSL_SERVER_I_DN_CN: VeriSign Class 3 Extended Validation SSL CA\nSSL_SERVER_I_DN_O: VeriSign, Inc.\nSSL_SERVER_I_DN_OU: VeriSign Trust Network\n\netc etc. \n\nHowever : \n\nSSL_SESSION_ID:\nSSL_SESSION_RESUMED: Initial\nSSL_VERSION_INTERFACE: mod_ssl/2.4.4\nSSL_VERSION_LIBRARY: OpenSSL/1.0.1e\n\nSeems wrong that SSL_SESSION_ID is blank.\n\nDennis"}, {"count": 1, "tags": [], "text": "Just FYI : \n\n# /usr/local/bin/httpd -V \nServer version: Apache/2.4.9 (Unix)\nServer built:   Mar 26 2014 03:50:32\nServer's Module Magic Number: 20120211:31\nServer loaded:  APR 1.5.0, APR-UTIL 1.5.3\nCompiled using: APR 1.5.0, APR-UTIL 1.5.3\nArchitecture:   64-bit\nServer MPM:     event\n  threaded:     yes (fixed thread count)\n    forked:     yes (variable process count)\nServer compiled with....\n -D APR_HAS_SENDFILE\n -D APR_HAS_MMAP\n -D APR_USE_PROC_PTHREAD_SERIALIZE\n -D APR_USE_PTHREAD_SERIALIZE\n -D SINGLE_LISTEN_UNSERIALIZED_ACCEPT\n -D APR_HAS_OTHER_CHILD\n -D AP_HAVE_RELIABLE_PIPED_LOGS\n -D DYNAMIC_MODULE_LIMIT=256\n -D HTTPD_ROOT=\"/usr/local\"\n -D SUEXEC_BIN=\"/usr/local/bin/suexec\"\n -D DEFAULT_PIDLOG=\"www/var/logs/httpd.pid\"\n -D DEFAULT_SCOREBOARD=\"logs/apache_runtime_status\"\n -D DEFAULT_ERRORLOG=\"logs/error_log\"\n -D AP_TYPES_CONFIG_FILE=\"www/conf/mime.types\"\n -D SERVER_CONFIG_FILE=\"www/conf/httpd.conf\"", "is_private": false, "bug_id": 56324, "id": 174136, "time": "2014-03-27T16:41:06Z", "creator": "dclarke@blastwave.org", "creation_time": "2014-03-27T16:41:06Z", "attachment_id": null}, {"count": 2, "tags": [], "bug_id": 56324, "attachment_id": null, "id": 174195, "time": "2014-03-31T21:51:09Z", "creator": "dclarke@blastwave.org", "creation_time": "2014-03-31T21:51:09Z", "is_private": false, "text": "Not sure how deep this rabbit hole goes but I created a simple html file \nthat does a redirect to another file which prints out all the cgi \nenvironment variables. The objective here was to for the browser to \nland initially on a page and then get redirected to another on the \nsame server and therefore the SSL_SESSION_RESUMED should not just be\nInitial and SSL_SESSION_ID should contain data. \n\nI was wrong and even after the recirect the SSL_SESSION_ID is blank. \n\nThis must be a bug .. somewhere."}, {"count": 3, "tags": [], "bug_id": 56324, "is_private": false, "text": "Solution was found at Red Hat site which states that SSLv3 must be in the\nSSLProtocol list and the there is no promise to deliver a SSL_SESSION_ID \nin the TLS protocol spec. \n\nTherefore change SSLProtocol config to : \n\n    SSLProtocol +SSLv3 -TLSv1.1 -TLSv1 -TLSv1.2\n\nThis results in the following standard ssl envionment variables with the\nSSL_SESSION_ID set : \n\nSERVER_SOFTWARE: Apache/2.4.9 (Unix) PHP/5.4.26 OpenSSL/1.0.1e\nSSL_CIPHER: DHE-RSA-AES256-SHA\nSSL_CIPHER_ALGKEYSIZE: 256\nSSL_CIPHER_EXPORT: false\nSSL_CIPHER_USEKEYSIZE: 256\nSSL_CLIENT_VERIFY: NONE\nSSL_COMPRESS_METHOD: NULL\nSSL_PROTOCOL: SSLv3\nSSL_SECURE_RENEG: true\nSSL_SERVER_A_KEY: rsaEncryption\nSSL_SERVER_A_SIG: sha1WithRSAEncryption\nSSL_SESSION_ID: 0d1e27e44864fba71d718fb6ef2b71971b8fd4468f9641d59c1dd36ad2761a24\nSSL_SESSION_RESUMED: Initial\nSSL_VERSION_INTERFACE: mod_ssl/2.4.9\nSSL_VERSION_LIBRARY: OpenSSL/1.0.1e\n\nThe docs at the Red Hat site state : \n\nA generic web browser sends \"Client Hello\" message with \"SessionTicket TLS\"\nextension of data length=0 during TLS handshake. If \"SessionTicket TLS\"(data\nlength=0) is presented by the client, the server will handle a session ticket\ninstead of a session id. Therefore, the server does not generate a session id.\nOn the second access, it sends \"Client Hello\" with a session ticket which was\nreceived in the first access, and the server validate it and, if it is valid,\ngenerates a session id. This behavior is defined by RFC5077 and the reason why\na session id does not appear at a first access and appears at a second access.\nThis is an unavoidable limitation as long as TLSv1 is used and the client\nimplementation uses the \"SessionTicket TLS\" extension, however, when\nconfiguring the client to use SSLv3 instead of TLSv1, a session id always\nappears, because SSLv3 has no such extension. Please consider using SSLv3 if\npossible.\n\n\nI can confirm that the same \"limitation\" exists with TLS v1.1 and v1.2.\n\nDennis \n\nps: reduced bug report to P4 normal", "id": 174310, "time": "2014-04-05T20:03:21Z", "creator": "dclarke@blastwave.org", "creation_time": "2014-04-05T20:03:21Z", "attachment_id": null}, {"count": 4, "tags": [], "bug_id": 56324, "attachment_id": null, "id": 174319, "time": "2014-04-07T09:41:04Z", "creator": "ylavic.dev@gmail.com", "creation_time": "2014-04-07T09:41:04Z", "is_private": false, "text": "Thanks (again) Dennis for these investigations.\n\nIt seems that there is nothing we can do at httpd level, hence I mark this bug as INVALID."}, {"count": 5, "tags": [], "creator": "dclarke@blastwave.org", "attachment_id": null, "id": 180346, "time": "2015-01-17T20:16:23Z", "bug_id": 56324, "creation_time": "2015-01-17T20:16:23Z", "is_private": false, "text": "This bug may be valid after all. \n\nA site running with the httpd-ssl.conf config that only supports TLSv1.2 seems to issue a valid Session-ID to an openssl client but not to a browser when the SSL_SESSION_ID is requested via a cgi binary or script which executes via the option ExecCGI. \n\nThus : \n\n$ /usr/local/ssl/bin/openssl version \nOpenSSL 1.0.1j 15 Oct 2014\n\n$ /usr/local/ssl/bin/openssl s_client -state -tls1_2 -status -connect node.mysite.com:443\n\nCONNECTED(00000003)\nSSL_connect:before/connect initialization\nSSL_connect:SSLv3 write client hello A\nOCSP response: no response sent\nSSL_connect:SSLv3 read server hello A\n.\n.\n.snip\n.\n---\nSSL handshake has read 1734 bytes and written 443 bytes\n---\nNew, TLSv1/SSLv3, Cipher is ECDHE-RSA-AES256-GCM-SHA384\nServer public key is 2048 bit\nSecure Renegotiation IS supported\nCompression: NONE\nExpansion: NONE\nSSL-Session:\n    Protocol  : TLSv1.2\n    Cipher    : ECDHE-RSA-AES256-GCM-SHA384\n    Session-ID: 19E91F71ABDFBDCE5A2E1D523741B7FC3C1B40603B3E9CE82A1FA553B7ACFC7C\n    Session-ID-ctx: \n.\n.\n.\netc etc\n\n\nThere we see a SSL session identifier returned even from a site running only TLS v 1.2 however the same SSL_SESSION_ID is blank within any cgi script which requests it. \n\nSeems like a valid bug.\n\nWithin ssl_engine_vars.c down in modules/ssl we see that if SESSION_RESUMED is Initial then we should get valid data for SESSION_ID via SSL_SESSION *pSession = SSL_get_session(ssl) because pSession->session_id should not be blank. \n\nIn any case, I continue to dig into this as the existence of a valid SSL_SESSION_ID seems very useful and almost essential. Certainly for http traffic load balance switches."}, {"count": 6, "tags": [], "creator": "dclarke@blastwave.org", "attachment_id": null, "is_private": false, "id": 180349, "time": "2015-01-17T21:20:59Z", "bug_id": 56324, "creation_time": "2015-01-17T21:20:59Z", "text": "A bit of followup. \n\nI run httpd in forground and in a debugger and then query for a webpage which is actually a cgi script that fetches SSL_SESSION_ID and I see this with a breakpoint inside ssl_engine_vars.c at line 356 : \n\nReading libmd_psr.so.1\n(dbx)\nt@27 (l@27) stopped in ssl_var_lookup_ssl at line 356 in file \"ssl_engine_vars.c\"\n  356               result = \"Initial\";\n(dbx) print sslconn\nsslconn = 0x10030c368\n(dbx) print sslconn\nsslconn = 0x10030c368\n(dbx) print *sslconn\n*sslconn = {\n    ssl             = 0x10032dac0\n    client_dn       = (nil)\n    client_cert     = (nil)\n    shutdown_type   = SSL_SHUTDOWN_TYPE_STANDARD\n    verify_info     = (nil)\n    verify_error    = (nil)\n    verify_depth    = 1\n    is_proxy        = 0\n    disabled        = 0\n    non_ssl_request = NON_SSL_OK\n    reneg_state     = RENEG_REJECT\n    server          = 0x100242018\n}\n(dbx) print var\nvar = 0xffffffff71141944 \"SESSION_RESUMED\"\n\nThis makes sense given my breakpoint. \n\nWhat truely is of interest to me is if we have a valid session identifier or not.\n\n(dbx) print SSL_SESSION_ID_STRING_LEN\nSSL_SESSION_ID_STRING_LEN = 66\n(dbx) print SSL_get_session(ssl)\nSSL_get_session(ssl) = 0x10032d4b0\n(dbx) x 0x10032d4b0 / 64 x\n0x000000010032d4b0:      0x0000 0x0303 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000\n0x000000010032d4c0:      0x0000 0x0030 0xf085 0xf49e 0x4744 0xb570 0xac8c 0x9eff\n0x000000010032d4d0:      0x9126 0xc226 0x82fc 0xd10e 0xfbc4 0x5161 0x0e32 0x1466\n0x000000010032d4e0:      0x41fc 0x5ff0 0x9ea3 0x56c3 0xb5e2 0x8f80 0xd31c 0xd1a7\n0x000000010032d4f0:      0x99b3 0x02e2 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000\n0x000000010032d500:      0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000\n0x000000010032d510:      0x0000 0x0000 0x0000 0x0000 0x0000 0x0020 0x3734 0x6538\n0x000000010032d520:      0x6262 0x6435 0x6266 0x3162 0x3863 0x3739 0x3965 0x6539\n(dbx)\n\nThis last bit looks like an error on my part and I may need to write a bit of hackary into ssl_engine_vars.c at line 356 wherein we know we have an initial session.  There I can perhaps use \n\n   id = pSession->session_id;\n   idlen = pSession->session_id_length;\n\nTo see what session identifier should be. \n\nThe RFCs are not entirely clear on the need for SSL_SESSION_ID and I must check this further. However the initial client hello in the SSL handshake does return a session identifier when tested with openssl client."}, {"count": 7, "attachment_id": null, "creator": "ylavic.dev@gmail.com", "is_private": false, "id": 180542, "time": "2015-01-24T07:26:26Z", "bug_id": 56324, "creation_time": "2015-01-24T07:26:26Z", "tags": [], "text": "The new directive SSLSessionTickets (off) available in upcoming 2.4.12 will restore legacy session-id management by OpenSSL.\n\nYou may try it with httpd < 2.4.11 by using the patch r1652074."}]