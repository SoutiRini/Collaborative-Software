[{"count": 0, "tags": [], "creator": "kmoon@autonomy.com", "attachment_id": 25759, "id": 138405, "time": "2010-07-13T14:08:24Z", "bug_id": 49591, "creation_time": "2010-07-13T14:08:24Z", "is_private": false, "text": "Created attachment 25759\nSmall JSP which should easily fit in the output buffer.\n\nWhen using a small custom error JSP page (which easily fits in the output buffer, and so would not usually require chunking), error responses always use chunked encoding, while non-error responses do not.\n\nFor example, visiting a missing resource (resulting in a 404) serves the error page as chunked, while visiting the error page directly (resulting in a 200) serves the error page without chunking.\n\nStatic resources are always served unchunked.\n\nI would like to request that a custom error JSP is not served chunked if it fits entirely within the output buffer, just like a regular JSP would. While not a bug, I like to avoid chunked encoding (and the extra flushes involved) whenever possible.\n\nI initially encountered this issue in 6.0.24, but verified it is still present in 7.0.0, and the source code seems unchanged in the trunk.\n\nTo replicate this issue, I modified the ROOT webapp of a fresh 7.0.0 install as follows:\n\n1. I added these lines to webapps/ROOT/WEB-INF/web.xml:\n\n  <error-page>\n    <error-code>404</error-code>\n    <location>/404.jsp</location>\n  </error-page>\n\n2. I added the attached 404.jsp to webapps/ROOT/.\n\n3. I visited http://localhost:8080/404 and received a chunked response.\n\n4. I visited http://localhost:8080/404.jsp and received an unchunked response.\n\nStepping through the code, I discovered that the issue seems to be caused by a flushBuffers() call in org.apache.catalina.core.StandardHostValve.status(Request, Response). The code looks something like this:\n\n  if (custom(request, response, errorPage)) {\n      try {\n          response.flushBuffer();\n      } catch (ClientAbortException e) {\n          // Ignore\n      } catch (IOException e) {\n          container.getLogger().warn(\"Exception Processing \" + errorPage, e);\n      }\n  }\n\nA normal page doesn't flush buffers until finishResponse() occurs, at which point it can decide to set the content length or use chunked encoding. Flushing earlier than that triggers chunked encoding (if possible)."}, {"count": 1, "tags": [], "bug_id": 49591, "attachment_id": null, "text": "The only way to fix this is to call Response.finishResponse() after sending of the error page, or to remove the flushBuffer() call.\n\nThe former seems dubious, and the latter means that we wouldn't be flushing the error response (headers and data) as soon as possible, which is probably desirable.\n\nChunked encoding isn't itself an issue, so for the sake of optimising small error pages I'm leaning towards WONTFIX on this one.", "id": 140097, "time": "2010-09-23T07:13:23Z", "creator": "timw@apache.org", "creation_time": "2010-09-23T07:13:23Z", "is_private": false}, {"count": 2, "tags": [], "bug_id": 49591, "text": "Flushing the error response as soon as possible sounds desirable, but after giving it some thought, the response still can't be flushed until the JSP has flushed at least once (explicitly or due to end of page), in order to allow the JSP to set headers (as required by the JSP specification: version 2.2, section JSP 11.3, Buffering).\n\nSo in the case that the response is complete, flushing the headers immediately is simply an extra flush (the data should already be in the buffer).\n\nAgreed this isn't actually a problem, and doesn't need to be fixed. I just think it would be nice. :-) I can see how it might get complicated, though.\n\n\nTo provide some context, the reason I initially reported this is because I ran into an issue with Internet Explorer's \"friendly error page\" feature.\n\nInternet Explorer will display a friendly error page if the error response body is under a certain number of bytes (512 or so by default, I think). The interesting part is that if the response body is chunked, it doesn't wait for the entire response body to arrive; it decides as soon as it has any part of the response body.\n\nSo if you have a very short first chunk, and the next chunk arrives in a later network packet, it'll assume the response is actually under the limit, and display the friendly error page. (However, it does combine chunks that arrive in the same packets; I'm guessing it runs the check immediately after the first read() or whatever.) This sorta makes sense, since a chunked response is unbounded in size, although I'm still a bit dubious as to the rationale.\n\nAnyway, this IE-specific behavior is easy enough to work around simply by ensuring the first chunk is large enough. (My application was flushing very frequently, resulting in lots of small chunks. The behavior was sensitive to network latency, so it was a bit of pain to track down.) I just reported this because I was surprised to still see a single chunk body for errors (but not non-errors), even after I had eliminated all the explicit flushes.", "id": 140115, "time": "2010-09-23T12:33:12Z", "creator": "kmoon@autonomy.com", "creation_time": "2010-09-23T12:33:12Z", "is_private": false, "attachment_id": null}, {"count": 3, "tags": [], "bug_id": 49591, "text": "I agree with Tim.", "id": 148205, "time": "2011-07-27T09:47:01Z", "creator": "markt@apache.org", "creation_time": "2011-07-27T09:47:01Z", "is_private": false, "attachment_id": null}]