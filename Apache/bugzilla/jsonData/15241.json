[{"count": 0, "text": "Added the ability to specify a file parameter that contains a list of resources \nto get from a URL.  The dest must be a directory and the files are copied \nwithout renaming.\n\n--- Get.java.Orig       Tue Dec  3 12:47:26 2002\n+++ Get.java    Tue Dec  3 12:48:19 2002\n@@ -56,17 +56,22 @@\n \n import java.io.File;\n import java.io.FileOutputStream;\n-import java.io.IOException;\n import java.io.InputStream;\n-import java.net.HttpURLConnection;\n+import java.io.IOException;\n+import java.io.FileReader;\n+import java.io.BufferedReader;\n import java.net.URL;\n+import java.net.MalformedURLException;\n import java.net.URLConnection;\n+import java.net.HttpURLConnection;\n import java.util.Date;\n import org.apache.tools.ant.BuildException;\n-import org.apache.tools.ant.Project;\n import org.apache.tools.ant.Task;\n+import org.apache.tools.ant.Project;\n import org.apache.tools.ant.util.FileUtils;\n+import org.apache.tools.ant.util.StringUtils;\n import org.apache.tools.ant.util.JavaEnvUtils;\n+import java.util.ArrayList;\n \n /**\n  * Gets a particular file from a URL source.\n@@ -84,11 +89,13 @@\n public class Get extends Task {\n     private URL source; // required\n     private File dest; // required\n+    private File file; // optional\n     private boolean verbose = false;\n     private boolean useTimestamp = false; //off by default\n     private boolean ignoreErrors = false;\n     private String uname = null;\n     private String pword = null;\n+    private int i;\n \n \n     /**\n@@ -97,174 +104,57 @@\n      * @exception BuildException Thrown in unrecoverable error.\n      */\n     public void execute() throws BuildException {\n+       ArrayList modules = null;\n+     \n         if (source == null) {\n-            throw new BuildException(\"src attribute is required\", getLocation\n());\n+            throw new BuildException(\"src attribute is required\", location);\n         }\n \n         if (dest == null) {\n-            throw new BuildException(\"dest attribute is required\", getLocation\n());\n-        }\n-\n-        if (dest.exists() && dest.isDirectory()) {\n-            throw new BuildException(\"The specified destination is a \ndirectory\",\n-                                     getLocation());\n+            throw new BuildException(\"dest attribute is required\", location);\n         }\n \n         if (dest.exists() && !dest.canWrite()) {\n             throw new BuildException(\"Can't write to \" + dest.getAbsolutePath\n(),\n-                                     getLocation());\n+                                     location);\n         }\n \n-        try {\n-\n-            log(\"Getting: \" + source);\n-\n-            //set the timestamp to the file date.\n-            long timestamp = 0;\n-\n-            boolean hasTimestamp = false;\n-            if (useTimestamp && dest.exists()) {\n-                timestamp = dest.lastModified();\n-                if (verbose) {\n-                    Date t = new Date(timestamp);\n-                    log(\"local file date : \" + t.toString());\n-                }\n-\n-                hasTimestamp = true;\n-            }\n-\n-            //set up the URL connection\n-            URLConnection connection = source.openConnection();\n-            //modify the headers\n-            //NB: things like user authentication could go in here too.\n-            if (useTimestamp && hasTimestamp) {\n-                connection.setIfModifiedSince(timestamp);\n-            }\n-            // prepare Java 1.1 style credentials\n-            if (uname != null || pword != null) {\n-                String up = uname + \":\" + pword;\n-                String encoding;\n-                // check to see if sun's Base64 encoder is available.\n-                try {\n-                    sun.misc.BASE64Encoder encoder =\n-                        (sun.misc.BASE64Encoder)\n-                        Class.forName(\"sun.misc.BASE64Encoder\").newInstance();\n-                    encoding = encoder.encode (up.getBytes());\n-\n-                } catch (Exception ex) { // sun's base64 encoder isn't \navailable\n-                    Base64Converter encoder = new Base64Converter();\n-                    encoding = encoder.encode(up.getBytes());\n-                }\n-                connection.setRequestProperty (\"Authorization\",\n-                                               \"Basic \" + encoding);\n-            }\n-\n-            //connect to the remote site (may take some time)\n-            connection.connect();\n-            //next test for a 304 result (HTTP only)\n-            if (connection instanceof HttpURLConnection) {\n-                HttpURLConnection httpConnection\n-                    = (HttpURLConnection) connection;\n-                if (httpConnection.getResponseCode()\n-                    == HttpURLConnection.HTTP_NOT_MODIFIED)  {\n-                    //not modified so no file download. just return\n-                    //instead and trace out something so the user\n-                    //doesn't think that the download happened when it\n-                    //didnt\n-                    log(\"Not modified - so not downloaded\");\n-                    return;\n-                }\n-                // test for 401 result (HTTP only)\n-                if (httpConnection.getResponseCode()\n-                    == HttpURLConnection.HTTP_UNAUTHORIZED)  {\n-                    String message=\"HTTP Authorization failure\";\n-                    if(ignoreErrors) {\n-                        log(message,Project.MSG_WARN);\n-                        return;\n-                    } else {\n-                        throw new BuildException(message);\n-                    }\n-                }\n-\n+        /**\n+         * Check for file designation, if present dest must be a dir. and \nsource must not contain a filename \n+         */\n+        if (file != null){\n+            if (dest.exists() && !dest.isDirectory()) {\n+                throw new BuildException(\"The specified destination must be a \ndirectory\",\n+                                         location);\n+            }\n+            if (!dest.exists()){\n+               if(!dest.mkdirs()) \n+                       throw new BuildException(\"Could not make new \ndirectory.\");\n+            }\n+            modules = loadFile(file);\n+\n+            FileUtils fu = FileUtils.newFileUtils();\n+            StringUtils su = new StringUtils();\n+   \n+            try{\n+                source = new URL(su.replace(source.toString() + \"/\",\"//\",\"/\"));\n+                source = new URL(su.replace(source.toString(),\":/\",\"://\"));\n+                for (i = 0; i < modules.size(); i++){\n+               doWork(new URL(source.toString() + modules.get(i)), fu.normalize\n(dest.toString() + \"/\" + modules.get(i)));\n+                }\n+            }\n+            catch(MalformedURLException mfURL){\n+               throw new BuildException(\"mfURL \" + mfURL.toString());\n+            }\n+            \n+        } else {\n+            if (dest.exists() && dest.isDirectory()) {\n+                throw new BuildException(\"The specified destination is a \ndirectory\",\n+                                         location);\n             }\n-\n-            //REVISIT: at this point even non HTTP connections may\n-            //support the if-modified-since behaviour -we just check\n-            //the date of the content and skip the write if it is not\n-            //newer. Some protocols (FTP) dont include dates, of\n-            //course.\n-\n-            InputStream is = null;\n-            for (int i = 0; i < 3 ; i++) {\n-                try {\n-                    is = connection.getInputStream();\n-                    break;\n-                } catch (IOException ex) {\n-                    log(\"Error opening connection \" + ex);\n-                }\n-            }\n-            if (is == null) {\n-                log(\"Can't get \" + source + \" to \" + dest);\n-                if (ignoreErrors) {\n-                    return;\n-                }\n-                throw new BuildException(\"Can't get \" + source + \" to \" + dest,\n-                                         getLocation());\n-            }\n-\n-            FileOutputStream fos = new FileOutputStream(dest);\n-            boolean finished = false;\n-            try {\n-                byte[] buffer = new byte[100 * 1024];\n-                int length;\n-\n-                while ((length = is.read(buffer)) >= 0) {\n-                    fos.write(buffer, 0, length);\n-                    if (verbose) {\n-                        System.out.print(\".\");\n-                    }\n-                }\n-                if (verbose) {\n-                    System.out.println();\n-                }\n-                finished = true;\n-            } finally {\n-                if (fos != null) {\n-                    fos.close();\n-                }\n-                is.close();\n-                // we have started to (over)write dest, but failed.\n-                // Try to delete the garbage we'd otherwise leave\n-                // behind.\n-                if (!finished) {\n-                    dest.delete();\n-                }\n-            }\n-\n-            //if (and only if) the use file time option is set, then\n-            //the saved file now has its timestamp set to that of the\n-            //downloaded file\n-            if (useTimestamp)  {\n-                long remoteTimestamp = connection.getLastModified();\n-                if (verbose)  {\n-                    Date t = new Date(remoteTimestamp);\n-                    log(\"last modified = \" + t.toString()\n-                        + ((remoteTimestamp == 0)\n-                          ? \" - using current time instead\"\n-                          : \"\"));\n-                }\n-                if (remoteTimestamp != 0) {\n-                    FileUtils.newFileUtils()\n-                        .setFileLastModified(dest, remoteTimestamp);\n-                }\n-            }\n-        } catch (IOException ioe) {\n-            log(\"Error getting \" + source + \" to \" + dest);\n-            if (ignoreErrors) {\n-                return;\n-            }\n-            throw new BuildException(ioe, getLocation());\n+            doWork(source, dest);\n         }\n+\n     }\n \n     /**\n@@ -286,6 +176,15 @@\n     }\n \n     /**\n+     * Where to copy the source file.\n+     *\n+     * @param dest Path to file.\n+     */\n+    public void setFile(File file) {\n+        this.file = file;\n+    }\n+\n+    /**\n      * If true, show verbose progress information.\n      *\n      * @param v if \"true\" then be verbose\n@@ -428,4 +327,195 @@\n             return new String(out);\n         }\n      }\n+         /**\n+     * load properties from a file\n+     * @param file file to load\n+     */\n+    protected ArrayList loadFile(File file) throws BuildException {\n+       ArrayList _al = null;\n+    \n+        log(\"Loading \" + file.getAbsolutePath(), Project.MSG_VERBOSE);\n+        try {\n+            if (file.exists()) {\n+                BufferedReader in = new BufferedReader(new FileReader(file));\n+                //Create the list to act on.\n+                _al = new ArrayList();\n+                try {\n+                   String _st = in.readLine();\n+                       while (_st != null){\n+                          if (!_st.trim().equals(\"\") && \n+                              !_st.trim().substring(0,1).equals(\"#\")){\n+                                   _al.add(_st.trim());\n+                        }\n+                        _st = in.readLine();\n+                       }\n+                } finally {\n+                    if (in != null) {\n+                        in.close();\n+                    }\n+                }\n+            } else {\n+                log(\"Unable to find file: \" + file.getAbsolutePath(),\n+                    Project.MSG_VERBOSE);\n+                throw new BuildException(\"Unable to find file: \" + \nfile.getAbsolutePath());\n+            }\n+            return _al;\n+        } catch (IOException ex) {\n+            throw new BuildException(ex, getLocation());\n+        }\n+    }\n+    private void doWork(URL source, File dest){\n+               try {\n+\n+            log(\"Getting: \" + source);\n+\n+            //set the timestamp to the file date.\n+            long timestamp = 0;\n+\n+            boolean hasTimestamp = false;\n+            if (useTimestamp && dest.exists()) {\n+                timestamp = dest.lastModified();\n+                if (verbose) {\n+                    Date t = new Date(timestamp);\n+                    log(\"local file date : \" + t.toString());\n+                }\n+\n+                hasTimestamp = true;\n+            }\n+\n+            //set up the URL connection\n+            URLConnection connection = source.openConnection();\n+            //modify the headers\n+            //NB: things like user authentication could go in here too.\n+            if (useTimestamp && hasTimestamp) {\n+                connection.setIfModifiedSince(timestamp);\n+            }\n+            // prepare Java 1.1 style credentials\n+            if (uname != null || pword != null) {\n+                String up = uname + \":\" + pword;\n+                String encoding;\n+                // check to see if sun's Base64 encoder is available.\n+                try {\n+                    sun.misc.BASE64Encoder encoder =\n+                        (sun.misc.BASE64Encoder)\n+                        Class.forName(\"sun.misc.BASE64Encoder\").newInstance();\n+                    encoding = encoder.encode (up.getBytes());\n+\n+                } catch (Exception ex) { // sun's base64 encoder isn't \navailable\n+                    Base64Converter encoder = new Base64Converter();\n+                    encoding = encoder.encode(up.getBytes());\n+                }\n+                connection.setRequestProperty (\"Authorization\",\n+                                               \"Basic \" + encoding);\n+            }\n+\n+            //connect to the remote site (may take some time)\n+            connection.connect();\n+            //next test for a 304 result (HTTP only)\n+            if (connection instanceof HttpURLConnection) {\n+                HttpURLConnection httpConnection\n+                    = (HttpURLConnection) connection;\n+                if (httpConnection.getResponseCode()\n+                    == HttpURLConnection.HTTP_NOT_MODIFIED)  {\n+                    //not modified so no file download. just return\n+                    //instead and trace out something so the user\n+                    //doesn't think that the download happened when it\n+                    //didnt\n+                    log(\"Not modified - so not downloaded\");\n+                    return;\n+                }\n+                // test for 401 result (HTTP only)\n+                if (httpConnection.getResponseCode()\n+                    == HttpURLConnection.HTTP_UNAUTHORIZED)  {\n+                    String message=\"HTTP Authorization failure\";\n+                    if(ignoreErrors) {\n+                        log(message,Project.MSG_WARN);\n+                        return;\n+                    } else {\n+                        throw new BuildException(message);\n+                    }\n+                }\n+\n+            }\n+\n+            //REVISIT: at this point even non HTTP connections may\n+            //support the if-modified-since behaviour -we just check\n+            //the date of the content and skip the write if it is not\n+            //newer. Some protocols (FTP) dont include dates, of\n+            //course.\n+\n+            InputStream is = null;\n+            for (int i = 0; i < 3 ; i++) {\n+                try {\n+                    is = connection.getInputStream();\n+                    break;\n+                } catch (IOException ex) {\n+                    log(\"Error opening connection \" + ex);\n+                }\n+            }\n+            if (is == null) {\n+                log(\"Can't get \" + source + \" to \" + dest);\n+                if (ignoreErrors) {\n+                    return;\n+                }\n+                throw new BuildException(\"Can't get \" + source + \" to \" + dest,\n+                                          location);\n+            }\n+\n+            FileOutputStream fos = new FileOutputStream(dest);\n+            boolean finished = false;\n+            try {\n+                byte[] buffer = new byte[100 * 1024];\n+                int length;\n+\n+                while ((length = is.read(buffer)) >= 0) {\n+                    fos.write(buffer, 0, length);\n+                    if (verbose) {\n+                        System.out.print(\".\");\n+                    }\n+                }\n+                if (verbose) {\n+                    System.out.println();\n+                }\n+                finished = true;\n+            } finally {\n+                if (fos != null) {\n+                    fos.close();\n+                }\n+                is.close();\n+                // we have started to (over)write dest, but failed.\n+                // Try to delete the garbage we'd otherwise leave\n+                // behind.\n+                if (!finished) {\n+                    dest.delete();\n+                }\n+            }\n+\n+            //if (and only if) the use file time option is set, then\n+            //the saved file now has its timestamp set to that of the\n+            //downloaded file\n+            if (useTimestamp)  {\n+                long remoteTimestamp = connection.getLastModified();\n+                if (verbose)  {\n+                    Date t = new Date(remoteTimestamp);\n+                    log(\"last modified = \" + t.toString()\n+                        + ((remoteTimestamp == 0)\n+                          ? \" - using current time instead\"\n+                          : \"\"));\n+                }\n+                if (remoteTimestamp != 0) {\n+                    FileUtils.newFileUtils()\n+                        .setFileLastModified(dest, remoteTimestamp);\n+                }\n+            }\n+        } catch (IOException ioe) {\n+            log(\"Error getting \" + source + \" to \" + dest);\n+            if (ignoreErrors) {\n+                return;\n+            }\n+            throw new BuildException(ioe, location);\n+        }\n+    \n+    }\n+     \n }", "bug_id": 15241, "is_private": false, "id": 27610, "time": "2002-12-10T16:24:08Z", "creator": "robert.dobbins@equifax.com", "creation_time": "2002-12-10T16:24:08Z", "tags": [], "attachment_id": null}, {"count": 1, "tags": [], "creator": "robert.dobbins@equifax.com", "attachment_id": 4115, "id": 27612, "time": "2002-12-10T16:26:36Z", "bug_id": 15241, "creation_time": "2002-12-10T16:26:36Z", "is_private": false, "text": "Created attachment 4115\nPatch for enhancement to Get task"}, {"count": 2, "text": "<get> supports getting multiple resources since svn revision 818129 (the obvious mapper error has been fixed in svn revision 818135 ;-)\n\nIf you combine this with the skipexisting attribute, your usecase will (finally) be addressed by Ant 1.8.0.\n\nThere will likely be a resource collection that will allow reading a list of resources from a file as well.", "bug_id": 15241, "is_private": false, "id": 130743, "time": "2009-09-29T06:48:21Z", "creator": "bodewig@apache.org", "creation_time": "2009-09-29T06:48:21Z", "tags": [], "attachment_id": null}, {"count": 3, "tags": [], "bug_id": 15241, "is_private": false, "id": 130745, "creation_time": "2009-09-29T08:04:02Z", "time": "2009-09-29T08:04:02Z", "creator": "mbenson@apache.org", "text": "(In reply to comment #2)\n> <get> supports getting multiple resources since svn revision 818129 (the\n> obvious mapper error has been fixed in svn revision 818135 ;-)\n> \n> If you combine this with the skipexisting attribute, your usecase will\n> (finally) be addressed by Ant 1.8.0.\n> \n> There will likely be a resource collection that will allow reading a list of\n> resources from a file as well.\n\nSurely you mean reading a list of resources from another resource?  ;)", "attachment_id": null}]