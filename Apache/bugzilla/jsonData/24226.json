[{"count": 0, "tags": [], "bug_id": 24226, "is_private": false, "text": "Hi There,\n\nI'm a student with experience of creating large applications for tomcat. I \nlately created my own Template Engine, of course exactly the way I want a \ntemplate engine to be. In fact it is a precompiler on the jsp compiler. I would \nlike my templateengine to be a standard precompiler of the jsp compiler.\n\nI would appreciate a professional responce very much!\n\nHere follows a copy-paste of the short manual about the usage of the tool and \nthe used language:\n\n\n---------\nTemplate Engine\n\nUsage of the Tool\nThe tool expects 3 commandline arguments:\n-\tBase directory of the directory tree containing the templates \n(the \u201cinput tree\u201d);\n-\tBase directory of the directory tree where the generated files should \nbe placed (the \u201coutput tree\u201d);\n-\tThe extension of the files that the tool should manage, e.g. \u201c.jsp\u201d \nor \u201c.php4\u201d.\n\nIn general the tool reads all files in the input tree with the given extension, \nreads and remembers all their definitions and bodies and for every one that is \nnot \u201cabstract\u201d, generates a file in the same subdirectory in the output tree. \nThe tool also generates new directories if needed,  removes files with the \ngiven extension if not any more in the input tree and removes directories if \nthey just became empty by deleting one or more files.\n\nDefinitions and the Usage of definitions\nIn general the bodies of files and of all sub elements contain just 3 types of \ncontent:\n-\tLiteral content (output: The content itself);\n-\tDefinitions (output: None);\n-\tUsages of or references to definitions (output: The content of the \ndefinition);\n\nAll definitions have a name and are referred to using this name. If a file or \nother element refers to some definition it is first searched in that file or \nelement itself. If not found it is searched in the element using that element. \nIf it is also not found in that one it is searched in the element using that \none and so on.\n\nIntroducing the Language\nA File\nIf a file has \u201c##=abstract\u201d as its very first line, this file is \u201cabstract \u201c \nand must contain a definitions body. Otherwise it must contain a normal body.\n\nDefinitions Body\nA definitions body contains only definition statements. Statements end \nwith \u201c##\u2019 and are called blocks.\nNormal Body\nA normal body contains literal content, any kind of statements, and references \nto definitions. All statements start with \u201c<##\u201d and end with \u201c#/>\u201d.\nInline Body\nA inline body contains literal content and references to definitions. It is \ndelimited by quotes or brackets from any one row of the following table.\nOpen\tClose\n{\t}\n[\t]\n(\t)\n\u2018\t\u2018\n\u201c\t\u201c\n<\t>\nExamples: \u201c\u2019inline body\u2019\u201d and \u201c[another <# inline /> body]\u201d\n\nThe Reference to a Definition\nA reference starts with \u201c<#\u201d. Then contains the name of the definition referred \nto and may furthermore contain one or more definitions with inline bodies, \nstarting with the name, followed by a \u2018=\u2019 symbol. If such a definition has \nname \u201cdefault\u201d, this one is used if the definition referred to is not found. \nExample: \u201c<# definition123 subdef1=\u201daaa\u201d subdef2=\u201dbbb\u201d default=\u201ddefault \ndefin\u201d/>\u201d.\n\nThe Definition Statement\nA definition statement adds a definition to the element it appears in. It \nstarts with \u201cdef\u201d, followed by the name of the definition. If  the line ends it \nmust contain a normal body. Otherwise a inline body must follow. Examples: \u201cdef \ndefin1 \u2018body of definition defin1\u2019\u201d and\n\u201cdef  defin2\n    Body of defin2\n  [end symbol of statement or block]\u201d\n\nThe Include Statement\nA include statement is in fact a complex reference. It adds a part to the \nelement it appears in which refers to a definition. It starts with \u201cinc\u201d, \nfollowed by the name of the definition referred to till the end of the line. \nAfter this line a definitions body must follow. Example: \n\n\u201cinc  defin2\n    def subdef1\u2019 \u2018body of subdef1\u2019\n    def  subdef2\n      Body of subdef2\n     ##\n  [end symbol of statement or block]\u201d\n\n \nThe Defining Include Statement\nA defining include statement is the same as a include statement, except that is \ndoes not add a part to the element it appears in, but adds a definition to that \nelement instead. It is a definition type statement. In fact it is the same as a \ndefinition statement with a normal body containing exactly one include \nstatement. A include statement is defining if the name of the definition \nreferred to is on the same line followed by \u201cdefining\u201d followed by the name of \nthe definition it defines. Example:\n\n\u201cinc def1 defining subdef_of_def1\n    def subdef1\u2019 \u2018body of subdef1\u2019\n    def  subdef2\n      Body of subdef2\n     ##\n  [end symbol of statement or block]\u201d\n\n\nPredefined Definitions\nThe engine has predefined definitions. A definition defined in a file or \nelement may not have a name of a predefined definition.\n\nOn this moment the only predefined one is \u201clinkbase\u201d. When this one is used / \nreferred to it outputs a relative link prefix to the base of the input / output \nbase directory. For example if it is used in a file (in the read base \ndir) \u201csubdir1/subdir2/file.ext\u201d, it outputs \u201c../../\u201d. If it is used in a file \n(in the read base dir) \u201cfile.ext\u201d, it outputs nothing. \nSome Examples\nInput file / template in the input tree:\n<## def d3\n  <# centerline />\n#/>\n\n<##def d1\n  Start of d1\n  <##def centerline \u2018Centerline of d1\u2019 #/>\n  <# d3 />\n  End of  d1\n#/>\n\n<##def d2\n  Start of d2\n  <##def centerline \u2018Centerline of d2\u2019 #/>\n  <# d3 />\n  End of  d2\n#/>\n\nStart\n<# d1 />\n<# d2 />\nEnd\n\nGenerates a file in the output tree on the same place as the file above:\n\n\n\nStart\n  Start of d1\n    Centerline of d1\n  End of  d1\n  Start of d2\n    Centerline of d2\n  End of  d2\nEnd\n\n \nExample of splitting html and jsp.\nInput file / template containing the html:\n##=abstract\n\ndef myTable\n  <table border=\u201d1\u201d>\n    <##def row \u2018<tr><td><# rowcontent /></td></tr>\u2019 #/>\n    <# rows />\n  </table>\n##\n\nInput file / template containing the jsp:\n<##inc myTable\n  def rows\n     <% for(int i=0i<10;i++) { %>\n       <# row />\n     <% } %>\n     <##def rowcontent \u2018<%=i%>\u2019 #/>\n  ##\n#/>\n\nWill together generate one file in the output tree, on the same place as the \nsecond file above containing:\n  <table border=\u201d1\u201d>\n         <% for(int i=0i<10;i++) { %>\n           <tr><td><%=i%></td></tr>\n         <% } %>\n  </table>\n\n\nMark the correct indent of all lines.", "id": 46466, "time": "2003-10-29T18:57:42Z", "creator": "j.lonnee@student.utwente.nl", "creation_time": "2003-10-29T18:57:42Z", "attachment_id": null}, {"count": 1, "tags": [], "creator": "kin-man.chung@sun.com", "text": "Sounds like an interesting project, but such a preprocessor is totally outside\nTomcat's scope.  Sorry.", "id": 46538, "time": "2003-10-30T18:37:55Z", "bug_id": 24226, "creation_time": "2003-10-30T18:37:55Z", "is_private": false, "attachment_id": null}, {"count": 2, "tags": [], "creator": "j.lonnee@student.utwente.nl", "attachment_id": null, "text": "Ok, I understand.\n\nThen in what scope is it? Furthermore I think an option to let tomcat call a \n(custom) preprocessos is still a feature in the scope of tomcat?\n\nI still think many people will find it usefull.", "id": 46548, "time": "2003-10-30T19:53:51Z", "bug_id": 24226, "creation_time": "2003-10-30T19:53:51Z", "is_private": false}, {"count": 3, "tags": [], "creator": "remm@apache.org", "text": "I'm also against extending JSP support. Please do not reopen the issue.", "id": 46549, "time": "2003-10-30T19:56:20Z", "bug_id": 24226, "creation_time": "2003-10-30T19:56:20Z", "is_private": false, "attachment_id": null}]