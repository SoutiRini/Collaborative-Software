[{"count": 0, "tags": [], "bug_id": 6858, "is_private": false, "text": "We have been doing some profiling of our struts application with tomcat 4.0.1.\n\nOur application is \"tag-heavy\" (we use tags everywhere). When profiling our\napplication we noticed a significant amount of time was being spent in the\ncreation of BodyContentImpl. (Using OptimizeIt, it reported %55.00 of our\ntotal cpu time was being spent in the constructor!!) Looking into this\nfurther....the generated code for a jsp tag appears to construct these \nindirectly through pageContext.pushBody() and throw them away after the page is \nrendered.\n\nThe BIG problem was that for each BodyContentImpl created, a default\nchar buffer of 8K is created. This is MUCH bigger than it needs to be,\nat least for our struts applications. Most of our tags only output a few\ncharacters.\n\nOn a hunch, I changed the constructor for BodyContentImpl to allocate the\nstarting buffer at 512 bytes. The results were dramatic! We profiled the\napplication again, the application spent (.74%) of its time in the constructor!\nThats a 74X difference.\n\nThis problem was much more pronounced using Sun's Server Hotspot JVM and\nturning on the \"-verbocegc\" showed us that we were spending a large amount of\nour time in garbage collects. Some of them were 12+ seconds!!! ouch. Why? I\nsuspect the large volume of garbage is confusing the garbage collector. We\nreverted back to the orginal 8K buffer and attempted to play with the Hotspot\ntuning parameters and we got better performance but it STILL took an\nunacceptable amount of time to garbage collect....We were getting full GCs\neach time and some of them were still taking 6 secs. Once we added my hack in\nfor 512 bytes....we saw normal behavior from the garbage collector: Incremental\nGCs, most under a second, and a the longest collect was 2 secs.\n\nThere are two solutions that would fix this problem:\n\na) Pooling :\n    Either pool the BodyContextImpl or the char[] buffers.\n\n0r\n\nb) Change the initial buffer size to a more sane value.\n\n   512 bytes appeared worked out much better in our application...although our\n   application mainly uses struts and most of the tags output less than 512\n   bytes. Perhaps 1K might be better?\n\n\nSorry I don't have the \"patch\" utitility readily available, so here is the \nchange that I made:\n\nIn BodyContentImpl:\n\nFrom this:\n\npublic class BodyContentImpl extends BodyContent {\n\n  private char[] cb;\n  protected int bufferSize = Constants.DEFAULT_BUFFER_SIZE;\n\nTo this:\n\npublic class BodyContentImpl extends BodyContent {\n\n  private char[] cb;\n  protected int bufferSize = 512;\n\n\nThanks\n\nTyler Van Gorder\ntkv@landacorp.com\nLandacorp", "id": 11445, "time": "2002-03-04T19:44:33Z", "creator": "tkv@landacorp.com", "creation_time": "2002-03-04T19:44:33Z", "attachment_id": null}, {"count": 1, "tags": [], "text": "Just some additional data.\n\n* Allocating big arrays w/o necessity may hurt some GC engines. The allocator\n  may have a policy of skipping the young generation for objects bigger than\n  some maximum limit, so these objects would be allocated directly in the\n  old-generation and totally screw with thee benefits of generational GC;\n  the result is that you need full-GC's instead of generational-GCs for\n  deleting these buffers, which could explain big and frequent GC pauses.\n  Other VMs may segregate objects by size, having many small heaps for different\n  ranges of size, so the freespace control is faster as each heap is an array\n  and a single bit can track each slot's position; IBM is one JVM that's known\n  to have this architecture -- and very large objects will spoil the trick again\n  because the segregated heaps exist only for a small number of size ranges.\n\n* A default policy of 512 bytes looks good, this should be good enough for the\n  output of most tags.  Some tags produce a lot of output and it would be\n  important to set a bigger buffer for making the I/O more efficient, but this\n  is less severe than the memory management problem.  For pages we can set the\n  buffer size, unfortunately not for tags so this may be a good RFE for the\n  JSP spec?  Meanwhile, the lesser evil is using a small buffer.", "is_private": false, "bug_id": 6858, "id": 16877, "time": "2002-05-29T15:30:20Z", "creator": "osvaldo@visionnaire.com.br", "creation_time": "2002-05-29T15:30:20Z", "attachment_id": null}, {"count": 2, "text": "I applied the change in Jasper 2, as this seems reasonable (8K is way too much).\nThis will be in the next nightly and the 4.1.4 milestone.\n\nAs you mentioned, the buffers should be reused as much as possible, instead of\nbeing created every time.", "bug_id": 6858, "is_private": false, "id": 16910, "time": "2002-05-30T00:14:02Z", "creator": "remm@apache.org", "creation_time": "2002-05-30T00:14:02Z", "tags": [], "attachment_id": null}, {"count": 3, "tags": [], "creator": "wdixon@crd.ge.com", "attachment_id": null, "text": "It would be better if no buffer were allocated until the first bytes were\nwritten.  BodyTags can be used for many useful things - some of them having\nlittle (64 bytes) to no output.  If the allocation scheme were incremental \n(e.g. 0, 64, 256, 1K, 4k, 8k, 16k, 32k) it would be beneficial to both low and\nhigh output tags.  ", "id": 16984, "time": "2002-05-31T12:29:49Z", "bug_id": 6858, "creation_time": "2002-05-31T12:29:49Z", "is_private": false}]