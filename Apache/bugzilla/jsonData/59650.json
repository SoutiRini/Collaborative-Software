[{"count": 0, "tags": [], "bug_id": 59650, "is_private": false, "text": "Summary: On Async servlets, after one request is complete and the connection is kept alive, the next request on this connection utilizes the Async channel group thread that was used to (asynchronously) process the previous request.\n\nExpected: All incoming requests should be processed by (or at least the processing should start by) the attached executor on the connector.\n\nMore: It may be arguable that it is an implementation detail on how tomcat nio2 connector deals with async servlet requests, in this case it may use the underlying async channel group threads to process another incoming request, but it is wrong for the following reasons.\n1) The next request coming on the connection may not be for an async servlet. So semantically it should use the executor thread.\n2) Application developer may have decided (which is a very common case)to have their own executor internally to process all the async requests.\n\nProblem: There is no way to limit the number of processing threads. Also a nice to have feature would be to allow the user to control the number of threads used by the underlying async channel group (that java NIO.2 uses for callbacks). Currently tomcat8 just uses default which leads to an unbounded number of threads.", "id": 191348, "time": "2016-06-01T17:23:15Z", "creator": "rsanwal@gmail.com", "creation_time": "2016-06-01T17:23:15Z", "attachment_id": null}, {"count": 1, "attachment_id": null, "bug_id": 59650, "text": "The NIO2 connector wraps the executor as the thread group, this executor should respect the thread count limits, etc.\n        // Create worker collection\n        if ( getExecutor() == null ) {\n            createExecutor();\n        }\n        if (getExecutor() instanceof ExecutorService) {\n            threadGroup = AsynchronousChannelGroup.withThreadPool((ExecutorService) getExecutor());\n        }\n\nWhat is the problem exactly ?", "id": 191349, "time": "2016-06-01T17:33:45Z", "creator": "remm@apache.org", "creation_time": "2016-06-01T17:33:45Z", "tags": [], "is_private": false}, {"count": 2, "tags": [], "bug_id": 59650, "text": "OK,\nMy email reply didn't make it here.\n\nThe snippet you mentioned here checks if the supplied executor is instance of ExecutorService is.\nWell, an executor configured in server.xml is not. Which means that the threadGroup is never created (with the provided thread pool) and eventually it ends up using the default case. Which is an unbounded thread pool.\n\nIn addition to this undesired behavior, for NIO2 connector, these threads (the ones to process async IO) are reused as-is to process new requests. If we have configured an executor in server.xml, our expectation is that requests are processed (or in case of async, are started to be processed) by the executor threads.\n\nA small example would reveal this problem.\nConfigure a server with an executor of size 1 (max). Write an async servlet to serve a filesystem resource. Hit it from a client with lots of requests coming in parallel and see what threads on tomcat jvm are doing.\n\nAnother one to try is, have two servlets one async and one non-async. Send a request from a browser to the async servlet first and then to the other one. You'll see that the executor thread is not used for the second one, instead since the first request was \"kept-alive\" the second one lands on the same connection and so, uses the thread that was previously used to write output on that connection for the async request. Which is not an executor thread, but a thread from the async channel processor group.\n\nThe side-effect of this is that there is no way to throttle threads. They just keep growing, even if most of the just sit idle.", "id": 191382, "time": "2016-06-03T17:41:19Z", "creator": "rsanwal@gmail.com", "creation_time": "2016-06-03T17:41:19Z", "is_private": false, "attachment_id": null}, {"count": 3, "tags": [], "creator": "remm@apache.org", "attachment_id": null, "text": "The NIO2 connector only works with an ExecutorService that is exclusive to this connector. A side effect of the design really.", "id": 191384, "time": "2016-06-03T18:41:38Z", "bug_id": 59650, "creation_time": "2016-06-03T18:41:38Z", "is_private": false}, {"count": 4, "attachment_id": null, "bug_id": 59650, "is_private": false, "id": 191386, "time": "2016-06-03T21:28:28Z", "creator": "rsanwal@gmail.com", "creation_time": "2016-06-03T21:28:28Z", "tags": [], "text": "Can it at least give the user some control put a cap on the number of threads? May be I am not explaining my problem correctly.\nRegardless.\nTomcat NIO2 connector still doesn't follow the rules of a defined executor service.\nWhy are the async channel group threads processing requests? They are not supposed to. There is a dedicated executor for that.\nMoreover, if this is allowed, what's the point of having an executor at all.\n\nOne of the reasons people use an executor is to limit the number of request being processed concurrently. If we can't limit this by using an executor with bounds, then the server may just get overwhelmed with unbounded number of requests.\n\nAnyway, there is still a way to limit the number of threads by not using an executor but setting the bounds on number of threads on the connector itself so that is an internal executor thus passing the ExecutorService check. So we may have to resort to using that.\n\nWe should at lease fix the connector documentation for this behavior and explain that it is better to not use an external executor by an internal one specific to the connector."}, {"count": 5, "text": "Typo in previous comment.\nIt should be.\n\nWe should at lease fix the connector documentation for this behavior and explain that it is better to not use an external executor *but* an internal one specific to the connector.", "bug_id": 59650, "is_private": false, "id": 191387, "time": "2016-06-03T21:31:48Z", "creator": "rsanwal@gmail.com", "creation_time": "2016-06-03T21:31:48Z", "tags": [], "attachment_id": null}, {"count": 6, "attachment_id": null, "bug_id": 59650, "text": "So you're saying effectively that the NIO2 connector would be better off if it used *two* separate executors: one ExecutorService internally (NIO2 needs one), and an external executor. And most processing will need to be executed twice on two different executors. Since I didn't think the behavior would be useful, I wrapped the executor assuming it is an ExceutorService (the thread pool Tomcat provides that is the standard implementation for the Executor element is one) since that is the most efficient solution.\n\nIt is open source, you can submit a patch but I'm quite skeptical. It would have to use a master flag (most likely the internalExecutor flag can work).\n\nI would instead recommend trying to use a pool that implements ExecutorService, it looks to me like a useful interface for thread management.", "id": 191388, "time": "2016-06-03T22:38:24Z", "creator": "remm@apache.org", "creation_time": "2016-06-03T22:38:24Z", "tags": [], "is_private": false}, {"count": 7, "attachment_id": null, "bug_id": 59650, "text": "I partly understand what you said. AND as I mentioned in my previous comment about the workaround, there is a way out.\nYour statement, however, about the tomcat standard executor being an ExecutorService (for which there is a check) is not correct. It indeed is a java.util.concurrent.Executor, but not ExecutorService.", "id": 191389, "time": "2016-06-04T19:49:36Z", "creator": "rsanwal@gmail.com", "creation_time": "2016-06-04T19:49:36Z", "tags": [], "is_private": false}, {"count": 8, "tags": [], "bug_id": 59650, "is_private": false, "text": "That's a useful clarification actually, the standard executor is not an ExecutorService, there's another thread pool in there that is an ExecutorService. It is likely I'll adjust the connector startup logging to make it clear a separate executor should probably not be used with NIO2.", "id": 191418, "time": "2016-06-06T14:08:48Z", "creator": "remm@apache.org", "creation_time": "2016-06-06T14:08:48Z", "attachment_id": null}]