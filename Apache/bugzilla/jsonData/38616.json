[{"count": 0, "tags": [], "creator": "DmitryR@kyiv.vdiweb.com", "attachment_id": null, "text": "Recently I've finished implementation of missing (and so long-awaited :)\nfunctionality in HWPF that allows images extraction from .doc files\nSee the attached patch\n\nRelease Notes:\n1) Tested only on Microsoft Words 2003 format (hope that my patch will work for\n2002 version as well)\n2) Support for Pictures that are inserted via \"Insert -> Picture -> From File\"\nmenu or via clipboard.\n3) the only formats supported for embedded images: JPG, GIF, PNG, BMP, TIFF. No\nsupport for images of WMF, AutoShapes, Clipart, WordArt.\n4) It seems that Word stores all raster images in two formats: JPG or PNG. GIF,\nBMP, TIFF are converted to PNG on insertion into document.", "id": 85697, "time": "2006-02-11T16:08:00Z", "bug_id": 38616, "creation_time": "2006-02-11T16:08:00Z", "is_private": false}, {"attachment_id": 17655, "tags": [], "bug_id": 38616, "text": "Created attachment 17655\ncontains missing HWPF functionality to extract images from .doc files", "count": 1, "id": 85698, "time": "2006-02-11T16:09:29Z", "creator": "DmitryR@kyiv.vdiweb.com", "creation_time": "2006-02-11T16:09:29Z", "is_private": false}, {"count": 2, "tags": [], "bug_id": 38616, "attachment_id": 17657, "id": 85701, "time": "2006-02-11T16:43:43Z", "creator": "DmitryR@kyiv.vdiweb.com", "creation_time": "2006-02-11T16:43:43Z", "is_private": false, "text": "Created attachment 17657\nattaching the patch, that allows picture extraction from Microsoft Word"}, {"count": 3, "tags": [], "creator": "DmitryR@kyiv.vdiweb.com", "is_private": false, "id": 86135, "creation_time": "2006-02-23T14:19:31Z", "time": "2006-02-23T14:19:31Z", "bug_id": 38616, "text": "Comment on attachment 17657\nattaching the patch, that allows picture extraction from Microsoft Word\n\nIndex:\nD:/java/svn-apache/src/scratchpad/src/org/apache/poi/hwpf/HWPFDocument.java\n===================================================================\n--- D:/java/svn-apache/src/scratchpad/src/org/apache/poi/hwpf/HWPFDocument.java\n(revision 376982)\n+++ D:/java/svn-apache/src/scratchpad/src/org/apache/poi/hwpf/HWPFDocument.java\n(working copy)\n@@ -89,6 +89,9 @@\n   /** Hold list tables */\n   protected ListTables _lt;\n\n+  /** Holds pictures table */\n+  protected PicturesTable _pictures;\n+\n   protected HWPFDocument()\n   {\n\n@@ -152,6 +155,7 @@\n\t _dataStream = new byte[0];\n     }\n\n+    _pictures = new PicturesTable(_dataStream);\n     // get the start of text in the main stream\n     int fcMin = _fib.getFcMin();\n\n@@ -237,7 +241,16 @@\n   {\n     return _lt;\n   }\n+\n   /**\n+   * @return PicturesTable object, that is able to extract images from this\ndocument\n+   */\n+  public PicturesTable getPicturesTable()\n+  {\n+    return _pictures;\n+  }\n+\n+  /**\n    * Writes out the word file that is represented by an instance of this\nclass.\n    *\n    * @param out The OutputStream to write to.\nIndex:\nD:/java/svn-apache/src/scratchpad/src/org/apache/poi/hwpf/model/PicturesTable.j\nava\n===================================================================\n---\nD:/java/svn-apache/src/scratchpad/src/org/apache/poi/hwpf/model/PicturesTable.j\nava  (revision 0)\n+++\nD:/java/svn-apache/src/scratchpad/src/org/apache/poi/hwpf/model/PicturesTable.j\nava  (revision 0)\n@@ -0,0 +1,114 @@\n+/* ====================================================================\n+   Copyright 2002-2006   Apache Software Foundation\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+\thttp://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+==================================================================== */\n+\n+\n+package org.apache.poi.hwpf.model;\n+\n+import org.apache.poi.util.LittleEndian;\n+import org.apache.poi.hwpf.usermodel.CharacterRun;\n+import org.apache.poi.hwpf.usermodel.Picture;\n+\n+import java.util.List;\n+import java.util.ArrayList;\n+\n+\n+/**\n+ * Holds information about all pictures embedded in Word Document either via\n\"Insert -> Picture -> From File\" or via\n+ * clipboard. Responsible for images extraction and determining whether some\ndocument&#1058;s piece contains embedded image.\n+ * Analyzes raw data bytestream &#1059;Data&#1060; (where Word stores all\nembedded objects) provided by HWPFDocument.\n+ *\n+ * Word stores images as is within so called \"Data stream\" - the stream within\na Word docfile containing various data\n+ * that hang off of characters in the main stream. For example, binary data\ndescribing in-line pictures and/or\n+ * formfields an also embedded objects-native data. Word picture structures\nare concatenated one after the other in\n+ * the data stream if the document contains pictures.\n+ * Data stream is easily reachable via HWPFDocument._dataStream property.\n+ * A picture is represented in the document text stream as a special\ncharacter, an Unicode \\u0001 whose\n+ * CharacterRun.isSpecial() returns true. The file location of the picture in\nthe Word binary file is accessed\n+ * via CharacterRun.getPicOffset(). The CharacterRun.getPicOffset() is a byte\noffset into the data stream.\n+ * Beginning at the position recorded in picOffset, a header data structure,\nwill be stored.\n+ *\n+ * @author Dmitry Romanov\n+ */\n+public class PicturesTable\n+{\n+  static final int TYPE_IMAGE = 0x08;\n+  static final int TYPE_IMAGE_PASTED_FROM_CLIPBOARD = 0xA;\n+  static final int BLOCK_TYPE_OFFSET = 0xE;\n+\n+  private byte[] _dataStream;\n+\n+  /** @link dependency\n+   * @stereotype instantiate*/\n+  /*# Picture lnkPicture; */\n+\n+  /**\n+   *\n+   * @param _dataStream\n+   */\n+  public PicturesTable(byte[] _dataStream)\n+  {\n+    this._dataStream = _dataStream;\n+  }\n+\n+  /**\n+   * determines whether specified CharacterRun contains reference to a picture\n+   * @param run\n+   */\n+  public boolean hasPicture(CharacterRun run) {\n+    if (run.isSpecialCharacter() && !run.isObj() && !run.isOle2() &&\n!run.isData() && \"\\u0001\".equals(run.text())) {\n+      short blockType = getBlockType(_dataStream, run.getPicOffset());\n+      return (blockType == TYPE_IMAGE || blockType ==\nTYPE_IMAGE_PASTED_FROM_CLIPBOARD);\n+    }\n+    return false;\n+  }\n+\n+  private static short getBlockType(byte[] dataStream, int pictOffset) {\n+    return LittleEndian.getShort(dataStream, pictOffset + BLOCK_TYPE_OFFSET);\n+  }\n+\n+  /**\n+   * Returns picture object tied to specified CharacterRun\n+   * @param run\n+   * @param fillBytes if true, Picture will be returned with filled byte array\nthat represent picture's contents. If you don't want\n+   * to have that byte array in memory but only write picture's contents to\nstream, pass false and then use Picture.writeImageContent\n+   * @see Picture#writeImageContent(java.io.OutputStream)\n+   * @return a Picture object if picture exists for specified CharacterRun,\nnull otherwise. PicturesTable.hasPicture is used to determine this.\n+   * @see #hasPicture(org.apache.poi.hwpf.usermodel.CharacterRun) \n+   */\n+  public Picture extractPicture(CharacterRun run, boolean fillBytes) {\n+    if (hasPicture(run)) {\n+      return new Picture(run.getPicOffset(), _dataStream, fillBytes);\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * @return a list of Picture objects found in current document\n+   */\n+  public List getAllPictures() {\n+    int i = 0;\n+    ArrayList pictures = new ArrayList();\n+    while(i<_dataStream.length) {\n+      short blockType = getBlockType(_dataStream, i);\n+      if (blockType == TYPE_IMAGE ||\nblockType==TYPE_IMAGE_PASTED_FROM_CLIPBOARD) {\n+\t pictures.add(new Picture(i, _dataStream, false));\n+      }\n+      i += LittleEndian.getInt(_dataStream, i);\n+    }\n+    return pictures;\n+  }\n+\n+}\nIndex:\nD:/java/svn-apache/src/scratchpad/src/org/apache/poi/hwpf/usermodel/Picture.jav\na\n===================================================================\n---\nD:/java/svn-apache/src/scratchpad/src/org/apache/poi/hwpf/usermodel/Picture.jav\na    (revision 0)\n+++\nD:/java/svn-apache/src/scratchpad/src/org/apache/poi/hwpf/usermodel/Picture.jav\na    (revision 0)\n@@ -0,0 +1,341 @@\n+/* ====================================================================\n+   Copyright 2002-2006   Apache Software Foundation\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+\thttp://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+==================================================================== */\n+\n+\n+package org.apache.poi.hwpf.usermodel;\n+\n+import org.apache.poi.util.LittleEndian;\n+\n+import java.io.OutputStream;\n+import java.io.IOException;\n+\n+/**\n+ * Represents embedded picture extracted from Word Document\n+ * @author Dmitry Romanov\n+ */\n+public class Picture\n+{\n+//  public static final int FILENAME_OFFSET = 0x7C;\n+//  public static final int FILENAME_SIZE_OFFSET = 0x6C;\n+  static final int BLOCK_TYPE_OFFSET = 0xE;\n+  static final int PICT_HEADER_OFFSET = 0x4;\n+  static final int UNKNOWN_HEADER_SIZE = 0x49;\n+\n+  public static final byte[] GIF = new byte[]{'G', 'I', 'F'};\n+  public static final byte[] PNG = new byte[]{ (byte)0x89, 0x50, 0x4E,\n0x47,0x0D,0x0A,0x1A,0x0A};\n+  public static final byte[] JPG = new byte[]{(byte)0xFF, (byte)0xD8};\n+  public static final byte[] BMP = new byte[]{'B', 'M'};\n+  public static final byte[] TIFF = new byte[]{0x49, 0x49, 0x2A, 0x00};\n+  public static final byte[] TIFF1 = new byte[]{0x4D, 0x4D, 0x00, 0x2A};\n+\n+  public static final byte[] IHDR = new byte[]{'I', 'H', 'D', 'R'};\n+\n+  private int dataBlockStartOfsset;\n+  private int pictureBytesStartOffset;\n+  private int dataBlockSize;\n+  private int size;\n+//  private String fileName;\n+  private byte[] content;\n+  private byte[] _dataStream;\n+  private int aspectRatioX;\n+  private int aspectRatioY;\n+  private int height = -1;\n+  private int width = -1;\n+\n+\n+  public Picture(int dataBlockStartOfsset, byte[] _dataStream, boolean\nfillBytes)\n+  {\n+    this._dataStream = _dataStream;\n+    this.dataBlockStartOfsset = dataBlockStartOfsset;\n+    this.pictureBytesStartOffset =\ngetPictureBytesStartOffset(dataBlockStartOfsset, _dataStream);\n+    this.dataBlockSize = LittleEndian.getInt(_dataStream,\ndataBlockStartOfsset);\n+    this.size = dataBlockSize - (pictureBytesStartOffset -\ndataBlockStartOfsset);\n+\n+    this.aspectRatioX = extractAspectRatioX(_dataStream,\ndataBlockStartOfsset);\n+    this.aspectRatioY = extractAspectRatioY(_dataStream,\ndataBlockStartOfsset);\n+//    this.fileName = extractFileName(dataBlockStartOfsset, _dataStream);\n+//    if (fileName==null || fileName.length()==0) {\n+//\t fileName = \"clipboard\";\n+//    }\n+\n+    if (fillBytes)\n+    {\n+      fillImageContent(_dataStream);\n+    }\n+\n+    String ext = suggestFileExtension();\n+    // trying to extract width and height from pictures content:\n+    if (\"jpg\".equalsIgnoreCase(ext)) {\n+      fillJPGWidthHeight();\n+    } else if (\"png\".equalsIgnoreCase(ext)) {\n+      fillPNGWidthHeight();\n+    }\n+  }\n+\n+  private static int extractAspectRatioX(byte[] _dataStream, int\ndataBlockStartOffset)\n+  {\n+    return LittleEndian.getShort(_dataStream, dataBlockStartOffset+0x20)/10;\n+  }\n+\n+  private static int extractAspectRatioY(byte[] _dataStream, int\ndataBlockStartOffset)\n+  {\n+    return LittleEndian.getShort(_dataStream, dataBlockStartOffset+0x22)/10;\n+  }\n+\n+  /**\n+   * Tries to suggest a filename: hex representation of picture structure\noffset in \"Data\" stream plus extension that\n+   * is tried to determine from first byte of picture's content.\n+   *\n+   * @return suggested file name\n+   */\n+  public String suggestFullFileName()\n+  {\n+    String fileExt = suggestFileExtension();\n+    return Integer.toHexString(dataBlockStartOfsset) + (fileExt.length()>0 ?\n\".\"+fileExt : \"\");\n+  }\n+\n+  /**\n+   * Writes Picture's content bytes to specified OutputStream.\n+   * Is useful when there is need to write picture bytes directly to stream,\nomitting its representation in\n+   * memory as distinct byte array.\n+   *\n+   * @param out a stream to write to\n+   * @throws IOException if some exception is occured while writing to\nspecified out\n+   */\n+  public void writeImageContent(OutputStream out) throws IOException\n+  {\n+    if (content!=null && content.length>0) {\n+      out.write(content, 0, size);\n+    } else {\n+      out.write(_dataStream, pictureBytesStartOffset, size);\n+    }\n+  }\n+\n+  /**\n+   * @return picture's content as byte array\n+   */\n+  public byte[] getContent()\n+  {\n+    if (content == null || content.length<=0)\n+    {\n+      fillImageContent(this._dataStream);\n+    }\n+    return content;\n+  }\n+\n+  /**\n+   *\n+   * @return size in bytes of the picture\n+   */\n+  public int getSize()\n+  {\n+    return size;\n+  }\n+\n+  /**\n+   * returns horizontal aspect ratio for picture provided by user\n+   */\n+  public int getAspectRatioX()\n+  {\n+    return aspectRatioX;\n+  }\n+  /**\n+   * returns vertical aspect ratio for picture provided by user\n+   */\n+  public int getAspectRatioY()\n+  {\n+    return aspectRatioY;\n+  }\n+\n+  /**\n+   * tries to suggest extension for picture's file by matching signatures of\npopular image formats to first bytes\n+   * of picture's contents\n+   * @return suggested file extension\n+   */\n+  public String suggestFileExtension()\n+  {\n+    if (content!=null && content.length>0) {\n+      return suggestFileExtension(content, 0);\n+    }\n+    return suggestFileExtension(_dataStream, pictureBytesStartOffset);\n+  }\n+\n+\n+  private String suggestFileExtension(byte[] _dataStream, int\npictureBytesStartOffset)\n+  {\n+    if (matchSignature(_dataStream, JPG, pictureBytesStartOffset)) {\n+      return \"jpg\";\n+    } else if (matchSignature(_dataStream, PNG, pictureBytesStartOffset)) {\n+      return \"png\";\n+    } else if (matchSignature(_dataStream, GIF, pictureBytesStartOffset)) {\n+      return \"gif\";\n+    } else if (matchSignature(_dataStream, BMP, pictureBytesStartOffset)) {\n+      return \"bmp\";\n+    } else if (matchSignature(_dataStream, TIFF, pictureBytesStartOffset)) {\n+      return \"tiff\";\n+    } else if (matchSignature(_dataStream, TIFF1, pictureBytesStartOffset)) {\n+      return \"tiff\";\n+    }\n+    return \"\";\n+  }\n+\n+  private static boolean matchSignature(byte[] dataStream, byte[] signature,\nint pictureBytesOffset)\n+  {\n+    boolean matched = true;\n+    for (int i = 0; i < dataStream.length && i< signature.length; i++)\n+    {\n+      if (dataStream[i+pictureBytesOffset] != signature[i])\n+      {\n+\t matched = false;\n+\t break;\n+      }\n+    }\n+    return matched;\n+  }\n+\n+//  public String getFileName()\n+//  {\n+//    return fileName;\n+//  }\n+\n+//  private static String extractFileName(int blockStartIndex, byte[]\ndataStream) {\n+//\t   int fileNameStartOffset = blockStartIndex + 0x7C;\n+//\t   int fileNameSizeOffset = blockStartIndex + FILENAME_SIZE_OFFSET;\n+//\t   int fileNameSize = LittleEndian.getShort(dataStream,\nfileNameSizeOffset);\n+//\n+//\t   int fileNameIndex = fileNameStartOffset;\n+//\t   char[] fileNameChars = new char[(fileNameSize-1)/2];\n+//\t   int charIndex = 0;\n+//\t   while(charIndex<fileNameChars.length) {\n+//\t       short aChar = LittleEndian.getShort(dataStream, fileNameIndex);\n+//\t       fileNameChars[charIndex] = (char)aChar;\n+//\t       charIndex++;\n+//\t       fileNameIndex += 2;\n+//\t   }\n+//\t   String fileName = new String(fileNameChars);\n+//\t   return fileName.trim();\n+//    }\n+\n+  private void fillImageContent(byte[] dataStream)\n+  {\n+    this.content = new byte[size];\n+    System.arraycopy(dataStream, pictureBytesStartOffset, content, 0, size);\n+  }\n+\n+  private static int getPictureBytesStartOffset(int dataBlockStartOffset,\nbyte[] _dataStream)\n+  {\n+    int realPicoffset = dataBlockStartOffset;\n+\n+    int PICTFBlockSize = LittleEndian.getShort(_dataStream,\ndataBlockStartOffset +PICT_HEADER_OFFSET);\n+    int PICTF1BlockOffset = PICTFBlockSize + PICT_HEADER_OFFSET;\n+    int PICTF1BlockSize = LittleEndian.getShort(_dataStream,\ndataBlockStartOffset +PICTF1BlockOffset);\n+    int unknownHeaderOffset = PICTF1BlockSize + PICTF1BlockOffset;\n+    realPicoffset += (unknownHeaderOffset + UNKNOWN_HEADER_SIZE);\n+    return realPicoffset;\n+  }\n+\n+  private void fillJPGWidthHeight() {\n+    /*\n+    http://www.codecomments.com/archive281-2004-3-158083.html\n+\n+    Algorhitm proposed by Patrick TJ McPhee:\n+\n+    read 2 bytes\n+    make sure they are 'ffd8'x\n+    repeatedly:\n+    read 2 bytes\n+    make sure the first one is 'ff'x\n+    if the second one is 'd9'x stop\n+    else if the second one is c0 or c2 (or possibly other values ...)\n+    skip 2 bytes\n+    read one byte into depth\n+    read two bytes into height\n+    read two bytes into width\n+    else\n+    read two bytes into length\n+    skip forward length-2 bytes\n+\n+    Also used Ruby code snippet from:\nhttp://www.bigbold.com/snippets/posts/show/805 for reference\n+    */\n+    int pointer = pictureBytesStartOffset+2;\n+    int firstByte = _dataStream[pointer];\n+    int secondByte = _dataStream[pointer+1];\n+\n+    int endOfPicture = pictureBytesStartOffset + size;\n+    while(pointer<endOfPicture-1) {\n+      do {\n+\t firstByte = _dataStream[pointer];\n+\t secondByte = _dataStream[pointer+1];\n+      } while (!(firstByte==(byte)0xFF) && pointer<endOfPicture-1);\n+\n+      if (firstByte==((byte)0xFF) && pointer<endOfPicture-1) {\n+\t if (secondByte==(byte)0xD9 || secondByte==(byte)0xDA) {\n+\t   break;\n+\t } else if ( (secondByte & 0xF0) == 0xC0 && secondByte!=(byte)0xC4 &&\nsecondByte!=(byte)0xC8 && secondByte!=(byte)0xCC) {\n+\t   pointer += 5;\n+\t   this.height = getBigEndianShort(_dataStream, pointer);\n+\t   this.width = getBigEndianShort(_dataStream, pointer+2);\n+\t   break;\n+\t } else {\n+\t   pointer++;\n+\t   pointer++;\n+\t   int length = getBigEndianShort(_dataStream, pointer);\n+\t   pointer+=length;\n+\t }\n+      } else {\n+\t pointer++;\n+      }\n+    }\n+  }\n+\n+  private void fillPNGWidthHeight()\n+  {\n+    /*\n+     Used PNG file format description from\nhttp://www.wotsit.org/download.asp?f=png\n+    */\n+    int HEADER_START = pictureBytesStartOffset + PNG.length + 4;\n+    if (matchSignature(_dataStream, IHDR, HEADER_START)) {\n+      int IHDR_CHUNK_WIDTH = HEADER_START + 4;\n+      this.width = getBigEndianInt(_dataStream, IHDR_CHUNK_WIDTH);\n+      this.height = getBigEndianInt(_dataStream, IHDR_CHUNK_WIDTH + 4);\n+    }\n+  }\n+  /**\n+   * returns pixel width of the picture or -1 if dimensions determining was\nfailed\n+   */\n+  public int getWidth()\n+  {\n+    return width;\n+  }\n+  /**\n+   * returns pixel height of the picture or -1 if dimensions determining was\nfailed\n+   */\n+  public int getHeight()\n+  {\n+    return height;\n+  }\n+\n+  private static int getBigEndianInt(byte[] data, int offset)\n+  {\n+    return (((data[offset] & 0xFF)<< 24) + ((data[offset +1] & 0xFF) << 16) +\n((data[offset + 2] & 0xFF) << 8) + (data[offset +3] & 0xFF));\n+  }\n+\n+  private static int getBigEndianShort(byte[] data, int offset)\n+  {\n+    return (((data[offset] & 0xFF)<< 8) + (data[offset +1] & 0xFF));\n+  }\n+\n+}\nIndex:\nD:/java/svn-apache/src/scratchpad/testcases/org/apache/poi/hwpf/data/testPictur\nes.doc\n===================================================================\nCannot display: file marked as a binary type.\nsvn:mime-type = application/octet-stream\n\nProperty changes on:\nD:\\java\\svn-apache\\src\\scratchpad\\testcases\\org\\apache\\poi\\hwpf\\data\\testPictur\nes.doc\n___________________________________________________________________\nName: svn:mime-type\n   + application/octet-stream\n\nIndex:\nD:/java/svn-apache/src/scratchpad/testcases/org/apache/poi/hwpf/model/TestPictu\nresTable.java\n===================================================================\n---\nD:/java/svn-apache/src/scratchpad/testcases/org/apache/poi/hwpf/model/TestPictu\nresTable.java\t     (revision 0)\n+++\nD:/java/svn-apache/src/scratchpad/testcases/org/apache/poi/hwpf/model/TestPictu\nresTable.java\t     (revision 0)\n@@ -0,0 +1,71 @@\n+/* ====================================================================\n+   Copyright 2002-2006   Apache Software Foundation\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+\thttp://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+==================================================================== */\n+\n+package org.apache.poi.hwpf.model;\n+\n+import org.apache.poi.hwpf.HWPFDocument;\n+import org.apache.poi.hwpf.usermodel.Picture;\n+import junit.framework.TestCase;\n+\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.util.List;\n+\n+/**\n+ * @author Dmitry Romanov\n+ * @version $Id: $\n+ */\n+public class TestPicturesTable\n+  extends TestCase\n+{\n+  private HWPFDocument document;\n+  private String testPath;\n+\n+\n+  public TestPicturesTable(String string)\n+  {\n+    super(string);\n+  }\n+\n+  protected void setUp() throws Exception\n+  {\n+    testPath = System.getProperty(\"HWPF.testdata.path\");\n+    if (testPath == null)\n+    {\n+      testPath = \"c:\";\n+    }\n+    String testFile = testPath + \"/testPictures.doc\";\n+    document = new HWPFDocument(new FileInputStream(testFile));\n+  }\n+\n+  public void testGetAllPictures() throws Exception {\n+    PicturesTable picturesTable = document.getPicturesTable();\n+    List allPictures = picturesTable.getAllPictures();\n+    assertNotNull(allPictures);\n+    assertTrue(allPictures.size() >= 5 );\n+    for (int i = 0; i < allPictures.size(); i++)\n+    {\n+      Picture picture = (Picture) allPictures.get(i);\n+      System.out.println(picture.suggestFullFileName()+\":\n\"+picture.getSize()+\" bytes\"+\" width:\n\"+picture.getWidth()+\"(\"+picture.getAspectRatioX()+\n+\t       \"%) height:\n\"+picture.getHeight()+\"(\"+picture.getAspectRatioY()+\"%)\");\n+\n+      FileOutputStream out = new\nFileOutputStream(testPath+\"/\"+picture.suggestFullFileName());\n+      out.write(picture.getContent());\n+      out.close();\n+    }\n+  }\n+\n+}", "attachment_id": 17657}, {"count": 4, "tags": [], "bug_id": 38616, "attachment_id": 17655, "id": 86136, "creation_time": "2006-02-23T14:21:05Z", "time": "2006-02-23T14:21:05Z", "creator": "DmitryR@kyiv.vdiweb.com", "text": "Comment on attachment 17655\ncontains missing HWPF functionality to extract images from .doc files\n\nuse newer patch added near", "is_private": false}, {"count": 5, "tags": [], "bug_id": 38616, "attachment_id": 17774, "id": 86137, "time": "2006-02-23T14:28:44Z", "creator": "DmitryR@kyiv.vdiweb.com", "creation_time": "2006-02-23T14:28:44Z", "is_private": false, "text": "Created attachment 17774\nsample document with images used by TestPicturesTable testcase"}, {"count": 6, "tags": [], "bug_id": 38616, "attachment_id": null, "id": 86138, "time": "2006-02-23T14:35:20Z", "creator": "DmitryR@kyiv.vdiweb.com", "creation_time": "2006-02-23T14:35:20Z", "is_private": false, "text": "New version of the patch contains enhanced functionality: now you are able to\nget aspect ratio of a picture via Picture.getAspectRatioX(),\nPicture.getAspectRatioY()\nAlso code that tries to determine width and height of extracted picture has been\nadded: use Picture.getWidth(), Picture.getHeight()\n\nAlso see attachments for class/sequence diagrams of classes that I added to HWPF\nto enable images extraction functionality."}, {"count": 7, "tags": [], "text": "Created attachment 17775\nclass diagram that describes new added classes (Picture, PicturesTable) and attributes to existing classes (HWPFDocument._picturesTable)", "attachment_id": 17775, "bug_id": 38616, "id": 86139, "time": "2006-02-23T14:50:58Z", "creator": "DmitryR@kyiv.vdiweb.com", "creation_time": "2006-02-23T14:50:58Z", "is_private": false}, {"attachment_id": 17776, "tags": [], "bug_id": 38616, "is_private": false, "count": 8, "id": 86140, "time": "2006-02-23T14:53:09Z", "creator": "DmitryR@kyiv.vdiweb.com", "creation_time": "2006-02-23T14:53:09Z", "text": "Created attachment 17776\nsequence diagram, an example scenario of images extraction"}, {"attachment_id": 17657, "tags": [], "bug_id": 38616, "is_private": false, "count": 9, "id": 86141, "time": "2006-02-23T15:07:22Z", "creator": "DmitryR@kyiv.vdiweb.com", "creation_time": "2006-02-23T15:07:22Z", "text": "Comment on attachment 17657\nattaching the patch, that allows picture extraction from Microsoft Word\n\npatch:\nhttp://issues.apache.org/bugzilla/show_bug.cgi?id=38616#c3\ncontains the fresh updates"}, {"count": 10, "tags": [], "bug_id": 38616, "attachment_id": 18776, "text": "Created attachment 18776\nthe patch containing latest updates\n\nplease use the attached patch\nit can be applied without any problems to current state of HWPF repository", "id": 92790, "time": "2006-08-31T11:40:21Z", "creator": "DmitryR@kyiv.vdiweb.com", "creation_time": "2006-08-31T11:40:21Z", "is_private": false}, {"count": 11, "tags": [], "bug_id": 38616, "attachment_id": null, "text": "Thanks, I've written some tests to go with this, fixed a couple of bugs, and\ncommitted the code to svn. If you do a checkout, you'll see you code :)\n\nFor future reference though, code tends to get committed quicker if it comes\nwith unit tests - it makes it much less work to apply (since the person\ncommitting doesn't have to write them).", "id": 94117, "time": "2006-09-26T14:44:06Z", "creator": "apache@gagravarr.org", "creation_time": "2006-09-26T14:44:06Z", "is_private": false}]