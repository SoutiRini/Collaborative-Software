[{"count": 0, "attachment_id": null, "bug_id": 34227, "text": "In the course of testing our web application have determined a race condition \nexists when simultaneous requests come in to tomcat sharing a session.\n\nThe results are that a session will never timeout.\n\nLooking into the code and adding log entries, basically the StandardSession \nmantains an access count to determine how many threads are using the session at \nonce. The counter is incremented at the beginning of the request and decremented \nduring the recyle at the end if the session object is not null. The race \ncondition must be that the shared session object becomes unavailable to recyle \nand therefore is left with a positive access count.\n\nThe session monitor thread (in the StandardManager) uses the isValid to expire \ntimed out sessions. But when a positive access count remains the session is \nalways valid and therefore will never expire.\n\nWe've also confirmed this behavior on 5.5.8.\n\nTo see this effect, write a HttpSessionListener object for the web application \nand monitor session creation and destruction with a counter and using jmeter\nhave a web page that has 2 javascript include tags calling each a servlet that \nuses the session for processing. Run up the jmeter on the server and then note\nthe number of sessions that never expire, even though you can print out last \naccess times that are far into the past. This is easier to see right away if you \nset session timeout to something low like a couple of minutes.\n\nIf I get a chance to put more time into this I will followup with more and \npossibly have test files and scripts to highlight this.", "id": 73016, "time": "2005-03-29T21:21:01Z", "creator": "evl123@yahoo.com", "creation_time": "2005-03-29T21:21:01Z", "tags": [], "is_private": false}, {"count": 1, "tags": [], "bug_id": 34227, "is_private": false, "text": "It appears making StandardSession.endAccess() and StandardSession.access()\nsynchronized would do the trick.", "id": 73017, "time": "2005-03-29T21:36:09Z", "creator": "funkman@joedog.org", "creation_time": "2005-03-29T21:36:09Z", "attachment_id": null}, {"count": 2, "tags": [], "bug_id": 34227, "text": "We're obviously not going to sync that (which exists due to some fairly stupid\nspec requirements). If we can't find a solution, then we'll have to live with\nthis issue.", "id": 73032, "time": "2005-03-30T00:58:51Z", "creator": "remm@apache.org", "creation_time": "2005-03-30T00:58:51Z", "is_private": false, "attachment_id": null}, {"count": 3, "tags": [], "creator": "remm@apache.org", "is_private": false, "text": "Actually, this means absolutely nothing to me:\nThe race condition must be that the shared session object becomes unavailable to\nrecyle and therefore is left with a positive access count.\nIt seems you don't have a legitimate scenarion for your problem.\n\n-> INVALID", "id": 73033, "time": "2005-03-30T01:00:53Z", "bug_id": 34227, "creation_time": "2005-03-30T01:00:53Z", "attachment_id": null}, {"count": 4, "text": "Yeah, well, regardless of the description, it's obvious from looking at the \nStandardSession code that the accessCount handling can't possibly work without \na synchronized block or something like j.u.concurrent.atomic.", "bug_id": 34227, "is_private": false, "id": 73035, "time": "2005-03-30T02:02:10Z", "creator": "william.barker@wilshire.com", "creation_time": "2005-03-30T02:02:10Z", "tags": [], "attachment_id": null}, {"count": 5, "attachment_id": null, "bug_id": 34227, "text": "(In reply to comment #3)\n> Actually, this means absolutely nothing to me:\n> The race condition must be that the shared session object becomes unavailable \nto\n> recyle and therefore is left with a positive access count.\n> It seems you don't have a legitimate scenarion for your problem.\n> \n> -> INVALID\n\nTry a web page that has 2 javascript src tags each calling a servlet from the \nsame web application container. The browser will hand that off to background \nthreads (same ones used to download images) and bingo simultaneous servlet \nrequests with same JSESSIONID cookie. So while yes its rather difficult for a \nuser to pull off simultaneous requests on the same session a browser application \nhas no such problem. You could probably see this one happen with a frame page \nwith a servlet in each frame being called simultaneously as well, and multiple \nimage generating servlets on a web page customizing output based on session. So \nI see more than one valid scenario for this.\n", "id": 73038, "time": "2005-03-30T04:00:18Z", "creator": "evl123@yahoo.com", "creation_time": "2005-03-30T04:00:18Z", "tags": [], "is_private": false}, {"count": 6, "attachment_id": null, "bug_id": 34227, "text": "On thing is for sure, we're not going to add any synchronization for this. If\nsomething goes away, it will be the call to endAccess (which was added due to\n*one* user whining about a stupid use case). I think a hack should be added\ninstead (if the inactivity period gets too long or something).\n\nI do not understand the problem still: is it actually the accessCount int which\nends up having the wrong value due to concurrent access ? That's actually almost\nimpossible.", "id": 73062, "time": "2005-03-30T13:16:26Z", "creator": "remm@apache.org", "creation_time": "2005-03-30T13:16:26Z", "tags": [], "is_private": false}, {"count": 7, "attachment_id": null, "bug_id": 34227, "is_private": false, "id": 73132, "time": "2005-03-31T03:19:19Z", "creator": "evl123@yahoo.com", "creation_time": "2005-03-31T03:19:19Z", "tags": [], "text": "(In reply to comment #6)\n> On thing is for sure, we're not going to add any synchronization for this. If\n> something goes away, it will be the call to endAccess (which was added due to\n> *one* user whining about a stupid use case). I think a hack should be added\n> instead (if the inactivity period gets too long or something).\n> \n> I do not understand the problem still: is it actually the accessCount int \nwhich\n> ends up having the wrong value due to concurrent access ? That's actually \nalmost\n> impossible.\nYes the accessCount within StandardSession is bumped up to 2 during concurrent \nrequest (StandardSession.access() increment call) and after both requests are \ncompleted it remains with value 1.\nThe recycle on the CoyoteRequest is where endAccess is called that decrements.\nSomehow the second request no longer has the session object to call the \nendAccess the second time. Note: this does not always happen - hence race \ncondition. I agree its difficult to time but a machine can do it easily via \nbrowser multiple background download calling servlets that execute in nearly \nequal time.\n\nI also agree that synchronizing is not a desired solution to this.\n"}, {"count": 8, "tags": [], "text": "It becomes a little bit more rational (although it is still impossible), as you\nare describing a scenario which wouldn't rely on a race condition incrementing\nthe int. If the session field becomes null, then endAccess is not going to be\ncalled. The request objects are per thread, are fully independent, and I don't\nsee any scenario (other than the session becoming invalid, in which case there\nwon't be any problem, of course) when the session field would become null.", "attachment_id": null, "id": 73143, "creator": "remm@apache.org", "time": "2005-03-31T11:36:09Z", "bug_id": 34227, "creation_time": "2005-03-31T11:36:09Z", "is_private": false}]