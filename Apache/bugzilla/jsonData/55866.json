[{"count": 0, "tags": [], "bug_id": 55866, "attachment_id": null, "id": 171692, "time": "2013-12-11T19:45:36Z", "creator": "mi+apache@aldan.algebra.com", "creation_time": "2013-12-11T19:45:36Z", "is_private": false, "text": "Consider the following sample configuration for Apache running on front.example.com:\n\nSSLProxyEngine  on\n...\n<Location /foo/>\n        Require all granted\n        ProxyPreserveHost       on\n        ProxyPass       https://back.example.com/foo/\n</Location>\n\nAccessing http://front.example.com/foo/ will cause an SSL-connection to be opened from front to back, as expected.\n\nUnfortunately, the SSL-engine on the client-side (on front) will expect the certificate presented by the back to contain \"front.example.com\" in its CN, rather than the \"back.example.com\":\n\nAH02005: SSL Proxy: Peer certificate CN mismatch: Certificate CN: back.example.com Requested hostname: front.example.com\n\nThis is not happening, when ProxyPreserveHost is set to off, as is the default.\n\nAs a work-around, one can set SSLProxyCheckPeerCN to off, but that defeats most of the usefulness of SSL between front and back.\n\nThe fix would change things so that the proxy-code still passes the original front.example.com in the Host:-header (because the ProxyPreserveHost is set to \"on\"), but expects the back.example.com in the CN of the certificate returned by the back end."}, {"count": 1, "tags": [], "bug_id": 55866, "attachment_id": null, "text": "If your backend does not use the same host name (and hence certificate CN) the client is requesting on the frontend, you shouldn't use ProxyPreserveHost (or expect SSLProxyCheckPeerCN to accept the peer certificate).\n\nSee http://www.mail-archive.com/dev@httpd.apache.org/msg56672.html for a discussion about this.", "id": 171694, "time": "2013-12-11T21:04:14Z", "creator": "ylavic.dev@gmail.com", "creation_time": "2013-12-11T21:04:14Z", "is_private": false}, {"count": 2, "tags": [], "text": "Possible duplicate of Bug 54656.", "attachment_id": null, "id": 171695, "creator": "ylavic.dev@gmail.com", "time": "2013-12-11T21:17:25Z", "bug_id": 55866, "creation_time": "2013-12-11T21:17:25Z", "is_private": false}, {"count": 3, "text": "(In reply to Yann Ylavic from comment #1)\n> If your backend does not use the same host name (and hence certificate CN)\n> the client is requesting on the frontend, you shouldn't use\n> ProxyPreserveHost (or expect SSLProxyCheckPeerCN to accept the peer\n> certificate).\n\nI'm using ProxyPreserveHost because the back-end's behavior depends on the Host-header, that's simple enough. In our particular case, the back-end needs to set a cookie for mod_auth_form. Though cookie-verification happens on the front-ends, the cookie-settings is proxied to the central server.\n\nThat central server is setting the same cookie for dozens (if not hundreds) of domains. Placing them all into its certificate -- and remaking the certificate each time a new front is added -- is impractical. The cookie-issuing back should not even need to know about all possible fronts -- indeed, there may be an infinite number of them.\n\nNor should it be necessary -- the purpose of using SSL on the proxy->back connection is to ensure the integrity of THAT connection only. The client->proxy may or may not even be using SSL at all, but the SSL's rejection of the back-end should signal the danger of back-end having been hijacked.\n\nDisabling SSLProxyCheckPeerCN defeats the major purpose of using SSL -- allowing man-in-the-middle attack against the proxy->back connections.\n\n> Possible duplicate of Bug 54656.\n\nWell, they are related, yes. And I agree with William's comment-3 there. But whereas Bug 54656 seeks to add a new configuration directive to allow turning the alternative behavior on, I argue, that the current behavior is plainly incorrect and ought to be corrected.", "bug_id": 55866, "attachment_id": null, "id": 171699, "time": "2013-12-12T01:01:50Z", "creator": "mi+apache@aldan.algebra.com", "creation_time": "2013-12-12T01:01:50Z", "tags": [], "is_private": false}, {"count": 4, "tags": [], "text": "The proxy is requesting front.example.com but gets a certificate from back.example.com, how could it validate the peer's CN positively?\nIsn't back.example.com the man-in-the-middle?\n\nWhen ProxyPreserveHost is on, the host part of the ProxyPass's URL is used only to resolve the IP address (which could be used there instead, with no difference).\n\nContrariwise, if one uses ProxyPreserveHost because the/some backend uses the same Host as the requested one, should the check fail because (s)he sets an IP address (or a private hostname) in the ProxyPass?\n\nWhen ProxyPreserveHost is on, either a new directive has to be added to select the expected peer's hostname (Host vs ProxyPass, bug 54656), or the current behaviour be applied.", "attachment_id": null, "id": 171918, "creator": "ylavic.dev@gmail.com", "time": "2013-12-24T13:04:38Z", "bug_id": 55866, "creation_time": "2013-12-24T13:04:38Z", "is_private": false}]