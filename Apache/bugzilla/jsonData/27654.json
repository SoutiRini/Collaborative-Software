[{"count": 0, "tags": [], "creator": "klaus.keppler@informatik.stud.uni-erlangen.de", "is_private": false, "id": 53985, "attachment_id": null, "bug_id": 27654, "creation_time": "2004-03-15T00:12:14Z", "time": "2004-03-15T00:12:14Z", "text": "There seems to be a bug in the condition variable implementation\non WIN32 platforms (see locks/win32/thread_cond.c).\n\nAn application using apr_thread_cond_wait will run very\nwell under linux (see httpd2's worker-mpm:\nfdqueue.c -> ap_queue_pop uses condition variables).\nBut under WIN32 already with two threads using the same\ncondition variable a deadlock occurs after short time.\n\nDebugging brought me to the source of apr_thread_cond_wait();\nas you can see the function \"apr_thread_mutex_unlock(mutex)\"\nis called every time the while(1)-loop is run.\nI think this shouldn't be a problem in general (since an unlocked\nmutex can't be unlocked once more), but at least on WIN32 it *did*\ncause trouble. And I am no windows guru so I don't know\nif/how windows bothers about multiple unlocking.\n\nAfter changing the code to unlock the mutex only once\neverything worked very fine. :-)\n\nI tested the patch with Win2K.\nWithout patch, my application ran (with 2 worker threads) only up to 20-30\nloops before ending in an deadlock; now I tested 200.000 loops without\nproblems.\n\nAnother approach would be to add a counter to every mutex and\nignore unlock calls when counter==0.\n\nKlaus\n\n\n--- locks/win32/thread_cond-old.c       Mon Feb 23 11:56:45 2004\n+++ locks/win32/thread_cond.c   Mon Feb 23 12:01:46 2004\n@@ -85,6 +85,8 @@\n {\n     DWORD res;\n\n+    int unlock_once = 1;\n+\n     while (1) {\n         res = WaitForSingleObject(cond->mutex, INFINITE);\n         if (res != WAIT_OBJECT_0) {\n@@ -93,7 +95,10 @@\n         cond->num_waiting++;\n         ReleaseMutex(cond->mutex);\n\n-        apr_thread_mutex_unlock(mutex);\n+        if (unlock_once) {\n+            unlock_once = 0;\n+            apr_thread_mutex_unlock(mutex);\n+        }\n         res = WaitForSingleObject(cond->event, INFINITE);\n         cond->num_waiting--;\n         if (res != WAIT_OBJECT_0) {\n@@ -125,6 +130,8 @@\n     DWORD res;\n     DWORD timeout_ms = (DWORD) apr_time_as_msec(timeout);\n\n+    int unlock_once = 1;\n+\n     while (1) {\n         res = WaitForSingleObject(cond->mutex, timeout_ms);\n         if (res != WAIT_OBJECT_0) {\n@@ -136,7 +143,10 @@\n         cond->num_waiting++;\n         ReleaseMutex(cond->mutex);\n\n-        apr_thread_mutex_unlock(mutex);\n+        if (unlock_once) {\n+            unlock_once = 0;\n+            apr_thread_mutex_unlock(mutex);\n+        }\n         res = WaitForSingleObject(cond->event, timeout_ms);\n         cond->num_waiting--;\n         if (res != WAIT_OBJECT_0) {"}, {"count": 1, "tags": [], "bug_id": 27654, "is_private": false, "text": "PatchAvailable is a special term for the Keywords field, but close enough ;)\n", "id": 53986, "time": "2004-03-15T00:14:13Z", "creator": "trawick@apache.org", "creation_time": "2004-03-15T00:14:13Z", "attachment_id": null}, {"count": 2, "tags": [], "bug_id": 27654, "text": "There's a general problem when calling apr_mutex_unlock several times under \nWIN32; since this might call the WIN32 API function \"LeaveCriticalSection\".\n\nQuoting MSDN docs on LeaveCriticalSection:\n---snip---\n[...]\nIf a thread calls LeaveCriticalSection when it does not have ownership of the \nspecified critical section object, an error occurs that may cause another \nthread using EnterCriticalSection to wait indefinitely.\n[...]\n---snip---\n\nHowever - this patch removes problems when using condvars under WIN32.\nAnother solution would be to add a \"lock counter\" to APR mutexes.\n", "id": 62648, "time": "2004-08-28T16:58:08Z", "creator": "klaus.keppler@informatik.stud.uni-erlangen.de", "creation_time": "2004-08-28T16:58:08Z", "is_private": false, "attachment_id": null}, {"count": 3, "tags": [], "bug_id": 27654, "is_private": false, "id": 77471, "attachment_id": 15721, "creator": "eholyat@yahoo.com", "creation_time": "2005-07-20T20:47:48Z", "time": "2005-07-20T20:47:48Z", "text": "Created attachment 15721\nThis patch avoid race conditions.  The previous patch does not\n\nThe previous patch addressed only the unlock being called more than once.\n\nThis attachment avoids race conditions that the previous patch doesn't. This\npatch also fixes the multiple calls to unlock. This patch also consolidates the\nthe duplicate efforts in apr_thread_cond_wait and apr_thread_cond_timedwait"}, {"count": 4, "tags": [], "bug_id": 27654, "is_private": false, "text": "Created attachment 15722\nPatch tested with jxta-c project\n\nanother patch to address the same issue and which would also fix bug 34336 as\nit totally removing the cond->mutex. I believe using the mutex passed in to\nensure mutual access should be sufficient.\n\nUnless the different threads can use different mutex for the same cond,\nbut I don't see that as a valid usage and nor can I think of a use case\nfor that.", "id": 77472, "time": "2005-07-20T21:14:05Z", "creator": "henryjen@ztune.net", "creation_time": "2005-07-20T21:14:05Z", "attachment_id": 15722}, {"count": 5, "tags": [], "bug_id": 27654, "is_private": false, "text": "Created attachment 15725\nnew patch also fix broadcast problems pointed by E Holyat\n\nThis patch fix the broadcast issue pointed out by E Holyat", "id": 77476, "time": "2005-07-21T01:39:09Z", "creator": "henryjen@ztune.net", "creation_time": "2005-07-21T01:39:09Z", "attachment_id": 15725}, {"text": "Patch had been applied and available in 1.2.1, also had been backported.\n ", "tags": [], "bug_id": 27654, "is_private": false, "count": 6, "id": 79143, "time": "2005-08-29T23:05:55Z", "creator": "henryjen@ztune.net", "creation_time": "2005-08-29T23:05:55Z", "attachment_id": null}]