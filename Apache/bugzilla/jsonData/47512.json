[{"count": 0, "tags": [], "bug_id": 47512, "attachment_id": null, "id": 128758, "creation_time": "2009-07-11T23:09:33Z", "time": "2009-07-11T23:09:33Z", "creator": "mrrtnn@gmail.com", "text": "I've created a custom javax.naming.spi.ObjectFactory that is able to bind javax.naming.Reference(s) into the global JNDI naming directory during startup time using a org.apache.catalina.LifecycleListener.\n\nI want two separate web contexts invoke the custom ObjectFactory#getObjectInstance method indirectly, getting through the local to the global JNDI context with a ResourceLink by invoking the local InitialContext#lookup method. Since both contexts have different classloaders my intention is to create a java.lang.reflect.Proxy given the current thread classloader.\n\nFor the first web context, everything goes Ok. The thread reaches the ObjectFactory, the object factory peeks the current thread classloader (always a webapp classloader), peeks the name of the interface to use for Proxy#newProxyInstance method, and the object to proxify for an internal collection and returns the proxy.\n\nThe problem arises for the second web context. The InitialContext#lookup method resolves the name and, although the thread never reaches the ObjectFactory, the object is resolved. Surprisingly, the returned object is the proxy created for the first web context. This proxy implements an interface available in the first web context's classloader. This interface is present in the second context classpath, but is loaded by a different webapp classloader. Thus, a java.lang.ClassCastException is raised.\n\nDigging into the tomcat codebase, I found in org.apache.naming.NamingContext that once a reference is resolved, the resolved object is sort of rebound to the original name. Thus, when the second lookup invocation arrives, the name is associated to an object (not a reference) and the ObjectFactory is never invoked.\n\nHere's the org.apache.naming.NamingContext code, lines 791 to 799:\n\n } else if (entry.type == NamingEntry.REFERENCE) {\n       try {\n          Object obj = NamingManager.getObjectInstance(entry.value, name, this, env);\n             if (obj != null) {\n               entry.value = obj;\n               entry.type = NamingEntry.ENTRY;\n             }\n          return obj;\n\nWhen a NamingEntry.REFERENCE arrive, the reference is resolved with the help of a javax.naming.spi.NamingManager. If the resolved object is null, the entry is converted to a NamingEntry.ENTRY instead of leaving it as a NamingEntry.REFERENCE.\n\nIn my opinion, the entry should be left as a REFERENCE, so the next invocation to the method, no matter who is the invoker nor its classloader, resolves the reference again with the javax.naming.spi.NamingManager's help. This \"cache\" policy of references should be left to the ObjectFactory itself, which will have all the necessary information to apply such a policy.\n\nThe code change would only imply the removal of the if I've shown above.\n\nRegards,\n\nMartin.", "is_private": false}, {"count": 1, "attachment_id": null, "creator": "mrrtnn@gmail.com", "text": "errata: in \"If the resolved object is null, the entry is\nconverted to a NamingEntry.ENTRY instead of leaving it as a\nNamingEntry.REFERENCE.\" I meant \"if the resolved object is not null\".", "id": 128759, "time": "2009-07-11T23:26:20Z", "bug_id": 47512, "creation_time": "2009-07-11T23:26:20Z", "tags": [], "is_private": false}, {"count": 2, "tags": [], "creator": "mrrtnn@gmail.com", "attachment_id": 23963, "is_private": false, "id": 128774, "time": "2009-07-12T18:34:01Z", "bug_id": 47512, "creation_time": "2009-07-12T18:34:01Z", "text": "Created attachment 23963\nadded the patch"}, {"text": "in trunk as http://svn.apache.org/viewvc?rev=832638&view=rev\n\nupdated STATUS.txt for tomcat 6 inclusion", "tags": [], "bug_id": 47512, "attachment_id": null, "count": 3, "id": 131662, "time": "2009-11-03T17:21:20Z", "creator": "funkman@apache.org", "creation_time": "2009-11-03T17:21:20Z", "is_private": false}, {"count": 4, "tags": [], "bug_id": 47512, "attachment_id": null, "id": 131675, "creation_time": "2009-11-04T01:50:51Z", "time": "2009-11-04T01:50:51Z", "creator": "knst.kolinko@gmail.com", "text": "So, Martin wants to have a global JNDI entry, that behaves differently depending on the caller.\n\nI think that relying on ObjectFactory to do the trick is wrong. Factories, as the name implies, are supposed to be called to create an object. Creation is something that is done once. It would be wrong to do it on every access. The Javadoc for NamingManager#getObjectInstance() clearly states that it \"Creates an instance of an object\".\n\nThus caching the result, as NamingContext#lookup(Name,boolean) does, is valid.\n\n\nI think that implementing a custom javax.naming.Context would be one of possible proper ways to implement what you do want. Though I have not tried so myself, so I do not really know.", "is_private": false}, {"count": 5, "tags": [], "bug_id": 47512, "attachment_id": null, "id": 131691, "creation_time": "2009-11-04T08:42:38Z", "time": "2009-11-04T08:42:38Z", "creator": "funkman@apache.org", "text": "patch withdrawn based on feedback", "is_private": false}, {"count": 6, "attachment_id": null, "creator": "funkman@apache.org", "is_private": false, "id": 131693, "time": "2009-11-04T09:53:09Z", "bug_id": 47512, "creation_time": "2009-11-04T09:53:09Z", "tags": [], "text": "Would this do what you need? (This might be worth moving the the tomcat user list if you need ideas/help)\n\nhttp://tomcat.apache.org/tomcat-6.0-doc/jndi-resources-howto.html#Adding%20Custom%20Resource%20Factories"}, {"count": 7, "tags": [], "bug_id": 47512, "attachment_id": null, "id": 131749, "creation_time": "2009-11-05T19:01:45Z", "time": "2009-11-05T19:01:45Z", "creator": "mrrtnn@gmail.com", "text": "(In reply to comment #4)\n> So, Martin wants to have a global JNDI entry, that behaves differently\n> depending on the caller.\n> \n> I think that relying on ObjectFactory to do the trick is wrong. Factories, as\n> the name implies, are supposed to be called to create an object. Creation is\n> something that is done once. It would be wrong to do it on every access. The\n> Javadoc for NamingManager#getObjectInstance() clearly states that it \"Creates\n> an instance of an object\".\n> \n> Thus caching the result, as NamingContext#lookup(Name,boolean) does, is valid.\n> \n> \n> I think that implementing a custom javax.naming.Context would be one of\n> possible proper ways to implement what you do want. Though I have not tried so\n> myself, so I do not really know.\n\nKonstantin,\n\nwhen you say \"So, Martin wants to have a global JNDI entry, that behaves differently depending on the caller.\" I think you might be forgetting that ObjectFactories classes are solved in the invoking classloader. Thus, the behavior will depend on the local ObjectFactory implementation.\n\nFor Tomcat programming purposes, it would seem to be enough to put the ObjectFactory class in the common classloader. Nevertheless, nothing prohibits someone to fill the classname field (see javax.naming.Rerefence constructor and #getClassName() method) with name of classes that don't exist in the common classloader.\n\nSo for instance, suppose that I fill classname with \"xyz.MyClass\" in a Reference published in the global Tomcat JNDI directory. Suppose that in the the web context \"A\" (with its own classloader as you surely already know) that class exists. When performing a lookup, the class will be successfully resolved, and an instance returned (depending on object class implementation).\n\nIn the same scenario, another lookup but in web context \"B\" (also containing xyz.MyClass) happens. org.apache.naming.NamingContext will return the cached object from context A. Which in turn, cannot be cast to the local xyz.MyClass, since its class belongs to a different classloader, producing a ClassCastException.\n\nI reported the issue for java.lang.reflect.Proxy because I was working with proxies, but this might happen with any Object.\n\nWhy I'm trying to implement? to share objects among contexts whose classes are not know until JNDI-name-resolving time, although present in invoking classloaders.\n\nThe link to customer resource factories won't help. Those factories are always local to the context they're declared.\n\nI would love to customize naming context implementation, but it's deeply hardcoded into Tomcat's codebase. Besides, I think the implementation of Context is just flawed, not wrong.\n\nSo, please guys, proof wrong the concept of ObjectFactories are resolved/ran in the invoking classloader/thread before withdrawing this issue.\n\nBest regards.\n\nMartin.", "is_private": false}, {"text": "Whilst binding objects into the global JNDI directory where the classes are only available to the web application class loader may be possible, this is asking from all sorts of class loading pain and memory leaks.\n\nOn that basis I am marking this as WONTFIX.\n\nIf you want this functionality in your environment the simplest way to achieve it is to patch org.apache.naming.NamingContext, compile the class and then place the class file in CATALINA_HOME/lib/org/apache/naming/NamingContext.class I'd also put the .java file alongside it so people can easily see what you changed.", "tags": [], "bug_id": 47512, "is_private": false, "count": 8, "id": 132732, "time": "2009-12-10T13:24:48Z", "creator": "markt@apache.org", "creation_time": "2009-12-10T13:24:48Z", "attachment_id": null}, {"count": 9, "tags": [], "bug_id": 47512, "attachment_id": null, "id": 133384, "time": "2010-01-06T06:51:50Z", "creator": "mrrtnn@gmail.com", "creation_time": "2010-01-06T06:51:50Z", "is_private": false, "text": "(In reply to comment #8)\n> Whilst binding objects into the global JNDI directory where the classes are\n> only available to the web application class loader may be possible, this is\n> asking from all sorts of class loading pain and memory leaks.\n> \n> On that basis I am marking this as WONTFIX.\n> \n> If you want this functionality in your environment the simplest way to achieve\n> it is to patch org.apache.naming.NamingContext, compile the class and then\n> place the class file in CATALINA_HOME/lib/org/apache/naming/NamingContext.class\n> I'd also put the .java file alongside it so people can easily see what you\n> changed.\n\nI've found another workaround. Thanks for your time, guys.\n\nPlease review these ideas when you have the time. As I said, NamingContext implementation is flawed and *that's* a cause for class loading pain. Please allow me to recommend you to check Sun's JNDI/RMI Service Provider (Object Factory implementation code available here http://www.docjar.com/html/api/com/sun/jndi/rmi/registry/RegistryContextFactory.java.html) or JBoss JNP client naming implementation as a reference.\n\nBest Regards.\n\nMartin."}]