[{"count": 0, "tags": [], "bug_id": 44358, "attachment_id": null, "id": 113442, "time": "2008-02-05T10:45:01Z", "creator": "mihail@us.ibm.com", "creation_time": "2008-02-05T10:45:01Z", "is_private": false, "text": "When testing fop.war application, we run out of memory while generating large \npdf - 560 pages.  Environment - WAS 5.1.1.13  JRE 1.4.2 (SR9). After the first \nrun we observe that large portion of the memory does not get GC. The heap  \nanalisys shows the following hirarchy holds 64% of the mem \nPrimaryGridUnit\n  TableCellLayoutManager\n    TableLayoutManager\n      TableContentLayout\n        TableRowIterator"}, {"count": 1, "tags": [], "bug_id": 44358, "text": "\nAre you at liberty to try out more recent versions of FOP (0.94 or even FOP Trunk), and see if that gets you \nany further? Some enhancements have been made, and the table-related code in FOP Trunk has changed \na lot. It would be much appreciated if you could report back on that.\n\nApart from that: Is it possible to alter the structure of the input FO? From what you're telling, it seems like \nyour FO document consists of one gigantic table (or at least contains a page-sequence with a table that \nspans a lot of pages). Correct? If so, you may be out of luck, but that depends on whether you really need \nto have the table completely in one page-sequence...", "id": 113444, "time": "2008-02-05T10:55:30Z", "creator": "adelmelle@apache.org", "creation_time": "2008-02-05T10:55:30Z", "is_private": false, "attachment_id": null}, {"count": 2, "tags": [], "creator": "mihail@us.ibm.com", "attachment_id": null, "is_private": false, "id": 113445, "time": "2008-02-05T11:11:16Z", "bug_id": 44358, "creation_time": "2008-02-05T11:11:16Z", "text": "Thanks for the suggestion. \n\nWe tried  fop 0.94 with the xml/xsl that we use to test 0.93 -- unfirtunatelly \nwe could not get it working. It appears to be sitting in an endless loop and \ndoes not produce any output pdf.\n\nCould you please advise what is the status of the FOP Trunk code.  Thanks!\n\n\n"}, {"count": 3, "tags": [], "creator": "mihail@us.ibm.com", "attachment_id": null, "text": "A few more comments with the hope they will clarify the situation. Any help \nand/or suggestions will be highly appreciated.  \n\n\n1) We have tried FOP 0.94. The stylesheet that runs fine with 0.93 runs into an \ninfinite loop with 0.94. I'm not sure why this happens, but when I searched on \ngoogle, I found that other users have run into this problem as well. I haven't \nbeen able to find a solution to this. \n\n2) The FO stylesheet does have a page sequence with a table that can span a lot \nof pages based on the data. \n\nCould please let us know why this is a problem? If this is a known problem, can \nyou let us know if there are any work arounds or fixes to get by this? I would \nappreciate if you can send us some examples with alternate implementations so \nwe can try that out. \n", "id": 113447, "time": "2008-02-05T12:28:54Z", "bug_id": 44358, "creation_time": "2008-02-05T12:28:54Z", "is_private": false}, {"count": 4, "tags": [], "bug_id": 44358, "attachment_id": null, "id": 113471, "time": "2008-02-06T01:11:08Z", "creator": "bowditch_chris@hotmail.com", "creation_time": "2008-02-06T01:11:08Z", "is_private": false, "text": "1) There was a bug in the Layout code that meant an infinite loop could be \nentered for certain FO. IIRC, preserve-whitespace property had something to do \nwith it. This has been fixed in the Trunk code.\n2) long page-sequences are a problem for FOP because FOP uses a total-fit \nalgorithm to layout the FO. This has the advantage of achieving more elegant \nlayout but the disadvantage of requiring the whole page-sequence to be kept in \nmemory and it is only released when the whole page-sequence has been finished. \nI think forward references via fo:page-number-cititation can also cause FOP to \nhang onto more objects in memory until the forward reference is resolved."}, {"count": 5, "tags": [], "creator": "mihail@us.ibm.com", "attachment_id": null, "is_private": false, "id": 113486, "time": "2008-02-06T09:18:48Z", "bug_id": 44358, "creation_time": "2008-02-06T09:18:48Z", "text": "Thanks for the response. \n\nWe are using preserve-whitespace property in our stylesheets. That could be\ncausing the infinite loop. We don't want to go to production with Trunk code.\nBut, if you could please point out to the classes from the Trunk code that fixed\nthis problem, I can get those and include them in the 0.94 jar and run our\nstylesheets. Let us know. \n\n(In reply to comment #4)\n> 1) There was a bug in the Layout code that meant an infinite loop could be \n> entered for certain FO. IIRC, preserve-whitespace property had something to do \n> with it. This has been fixed in the Trunk code.\n> 2) long page-sequences are a problem for FOP because FOP uses a total-fit \n> algorithm to layout the FO. This has the advantage of achieving more elegant \n> layout but the disadvantage of requiring the whole page-sequence to be kept in \n> memory and it is only released when the whole page-sequence has been finished. \n> I think forward references via fo:page-number-cititation can also cause FOP to \n> hang onto more objects in memory until the forward reference is resolved."}, {"count": 6, "tags": [], "bug_id": 44358, "attachment_id": null, "text": "(In reply to comment #5)\n> Thanks for the response. \n> \n> We are using preserve-whitespace property in our stylesheets. That could be\n> causing the infinite loop. We don't want to go to production with Trunk code.\n> But, if you could please point out to the classes from the Trunk code that fixed\n> this problem, I can get those and include them in the 0.94 jar and run our\n> stylesheets. Let us know. \n\nEdit the src/java/org/apache/fop/layoutmgr/table/TableContentLayoutManager.java\nfile and delete lines 145 and 166, which correspond to the following lines of code:\n    ElementListUtils.removeLegalBreaks(this.headerList);\n    ElementListUtils.removeLegalBreaks(this.footerList);\nThey are causing the infinite loop. Removing them is totally safe and won't\naffect the quality of the layout.\n\nVincent\n> \n> (In reply to comment #4)\n> > 1) There was a bug in the Layout code that meant an infinite loop could be \n> > entered for certain FO. IIRC, preserve-whitespace property had something to do \n> > with it. This has been fixed in the Trunk code.\n> > 2) long page-sequences are a problem for FOP because FOP uses a total-fit \n> > algorithm to layout the FO. This has the advantage of achieving more elegant \n> > layout but the disadvantage of requiring the whole page-sequence to be kept in \n> > memory and it is only released when the whole page-sequence has been finished. \n> > I think forward references via fo:page-number-cititation can also cause FOP to \n> > hang onto more objects in memory until the forward reference is resolved.\n\n", "id": 113517, "time": "2008-02-07T03:23:37Z", "creator": "vhennebert@gmail.com", "creation_time": "2008-02-07T03:23:37Z", "is_private": false}, {"count": 7, "tags": [], "creator": "mihail@us.ibm.com", "attachment_id": null, "text": "Hi all:\n\nWe modified FOP 0.94 as Vincent suggested (thanks!). This resolved the infinite \nloop problem.  However we still get the OutOfMemory exception.  I am wondering \nif the FOP framework holds large amount of memory in static class variables. \nAlso I noticed that there are a very large number of fop.fo.StaticPropertyList \nobjects created - 35000; each of those objects holds two arrays - size 252.  \nThis correlates with the heapdump analyses we performed - large number of \narrays without parent and the GC cannot dispose them. (I am under the \nimpression that these objects get allocated in a recursive manner.)\nWould it be possible to reduce the number of arrays using static var or object \ncache?  \n\nThank you all for the prompt response!\n\nRegards\nMihail\n    \n", "id": 113714, "time": "2008-02-13T07:19:09Z", "bug_id": 44358, "creation_time": "2008-02-13T07:19:09Z", "is_private": false}, {"count": 8, "tags": [], "bug_id": 44358, "attachment_id": null, "id": 113720, "time": "2008-02-13T11:11:13Z", "creator": "adelmelle@apache.org", "creation_time": "2008-02-13T11:11:13Z", "is_private": false, "text": "(In reply to comment #7)\n> \n> We modified FOP 0.94 as Vincent suggested (thanks!). This resolved the infinite \n> loop problem.  However we still get the OutOfMemory exception.  \n\nOK, thanks a lot for trying this out. Can you judge whether the exception occurred sooner or later than \nwith FOP 0.93?\n\n> I am wondering if the FOP framework holds large amount of memory in static class variables.\n\nNot that I'm aware of. There are some static variables in the property classes, but those only serve to \nreduce the footprint. (caches that are shared between different FOs in the same document, or even in \ndifferent documents if they are processed concurrently in the same JVM)\n\n> Also I noticed that there are a very large number of fop.fo.StaticPropertyList \n> objects created - 35000\n\nThat means your FO contains 35000 objects, which is not abnormal for larger documents. If those are \nall inside the same page-sequence, there is only little you can do for the moment, apart from making \nsure that such an FO document is never generated in the first place. This could be done by \nrestructuring the stylesheet to generate multiple page-sequences, but we realize that this is not always \npossible.\n\nIn the old days, those PropertyLists were never released. Being attached to the corresponding FONode \n(hard member reference), they were only released when that FONode was no longer referenced.\nCurrently, they are more like a window, from which the relevant properties are transferred to the \nFONode during parsing. As soon as the endElement() event occurs for that FONode, the PropertyList \ngoes out of scope and should theoretically be 100% garbage-collectable (including the backing arrays)\n\n> ; each of those objects holds two arrays - size 252.  \n\nYep. 252 is the total number of possible properties.\n\n> This correlates with the heapdump analyses we performed - large number of \n> arrays without parent and the GC cannot dispose them. (I am under the \n> impression that these objects get allocated in a recursive manner.)\n\nCorrect, although the number of StaticPropertyLists to which there exists a hard reference will be \ndetermined not by the number of FOs, but by the nesting level. If you have a document with a \nmaximum nesting depth of 10 nodes, then there will be at most 10 StaticPropertyList instances alive at \nany given point during the processing. I've literally seen this with my own eyes during a profiling \nsession.\n\nIs it normal that the backing arrays are not collected? I'd think not, but I'm not 100% sure.\n\nWhich JVM is used? Are you using Sun's implementation, or an IBM JVM? Is there a way to rule out the \npossibility of the GC algorithm being at fault here? Can you try other Java Runtimes?\n\n> Would it be possible to reduce the number of arrays using static var or object \n> cache?\n\nNot really, I think... The properties themselves are already cached for a large part, i.e. a simple \nFixedLength with a value of \"10pt\" will be the same instance for all occurrences in the document.\nInitially, each FixedLength is a separate instance, but we check immediately whether we already have \none cached with the same value. If that is the case, then the separate instance exists purely on the \nstack, and is substituted with the cached instance before it is attached/bound to the FONode."}, {"count": 9, "tags": [], "bug_id": 44358, "attachment_id": null, "id": 113767, "time": "2008-02-14T15:12:35Z", "creator": "adelmelle@apache.org", "creation_time": "2008-02-14T15:12:35Z", "is_private": false, "text": "\nSmall update:\nI've been browsing around, and may have found the possible cause of the arrays not being collected.\nTheoretically, it is possible that an implementation of a tracing GC algorithm would still view the arrays \nas reachable if their first element is still strongly reachable... Since this is the default absolute-position \nproperty, and it is possibly referenced by a significant amount of FObjs.\n\nMaybe you could try something like:\n* add an empty protected cleanup() method to org.apache.fop.fo.PropertyList\n* add an override for this method to StaticPropertyList, and explicitly null out the first element of the \nmember arrays\n* in FOTreeBuilder.MainFOHandler.endElement(), inside the if-block right after \ncurrentFObj.endOfNode(), add currentPropertyList.cleanup() as a first line\n\n"}, {"count": 10, "tags": [], "creator": "thesing@gmx.de", "attachment_id": null, "text": "This problem is still present in FOP trunk version.\nAs I see it there are several things contributing to the huge memory footprint\n 1) If the documents contains forward references (e.g. in the TOC or in \n     a \"page X of Y\" still footer), then FOP keeps all page sequences around,\n     together with the Areas until the references have been resolved\n 2) Even when a page has been rendered in a sequence, the FO that generated\n     that page is kept around, which is especially bad for tables, as they\n      generate quite a lot of objects for borders, etc.\n    It should be possible to discard a FO object as soon as all pages it\n     contributes areas for have been rendered.\n 3) At several places, page-sequences are kept around solely for computing\n      things like the number of pages generated so far from them. \n     It suffices to keep the needed information (e.g. number pages) around\n\nOn fop-dev a two pass approach has been discussed in order to solve 1):\n  In the first pass, no pages are rendered, only layout is done. All unknown\n    references are treated as \"XXX\" (as they are now). The definitions of\n    IDs are recorded for the second pass with the corresponding page number.\n  In the second pass, the defs from the first pass are used to resolve\n   references. When the definitions are encountered again in the second pass,\n   it is checked that they correspond to the ones made in the first pass.\n\nFor 2) and 3) an analysis and redesign has to be done in order to find all\nplaces, where Area or FO information for a page is kept beyond the point when the page has been rendered.", "id": 133674, "time": "2010-01-17T23:21:03Z", "bug_id": 44358, "creation_time": "2010-01-17T23:21:03Z", "is_private": false}, {"count": 11, "tags": [], "creator": "gadams@apache.org", "attachment_id": null, "is_private": false, "id": 157282, "time": "2012-04-07T01:37:26Z", "bug_id": 44358, "creation_time": "2012-04-07T01:37:26Z", "text": "resetting severity from major to normal pending further review"}, {"count": 12, "tags": [], "bug_id": 44358, "attachment_id": null, "id": 157296, "time": "2012-04-07T01:39:43Z", "creator": "gadams@apache.org", "creation_time": "2012-04-07T01:39:43Z", "is_private": false, "text": "resetting P1 open bugs to P3 pending further review"}]