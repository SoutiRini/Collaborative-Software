[{"count": 0, "tags": [], "bug_id": 31930, "attachment_id": null, "id": 65869, "time": "2004-10-28T01:49:50Z", "creator": "ant-venkatp@sneakemail.com", "creation_time": "2004-10-28T01:49:50Z", "is_private": false, "text": "We have a big web application and we use Ant to build it. We also have written a\nconfig util to be used during deploy time using Ant.\n\nBeginning with 1.6.x, the build as well as the config utility has slowed down\nsignificantly. The difference is in the order of two times for build and for the\nconfig util in the order of four times. Upon digging into it further, I\ndiscovered that the replacement Zip/Unzip functions to support file name\nencodings from the following files are very slow:\n\norg.apache.tools.zip.ZipFile\norg.apache.tools.zip.ZipOutputStream\n\nMy test included three class of processors Pentium III, Pentium IV, and Pentium\nM. Of the three, the problem is almost not visible in Pentium M. The P IV is\nslower than Pentium M and Pentium III is slower than Pentium IV. To prove this\nproblem, I conducted the following tests (files are attached to the case). My\ntest case only demonstrate the problem with ZipFile class though there is a\nproblem with ZipOutputStream also: \n\nI have taken three different ZipFile classes namely from Sun JDK's built-in\n(java.util.zip package), JazzLib (Same as the one that comes with GNU Classpath\nbut available as standalone from http://jazzlib.sourceforge.net) and Apache Util\nZipFile (The one mentioned above and used by Ant to support file encoding).\nUsing each of the three, I read the JDK's tools.jar and throw away the read\ndata. This operation is timed for comparison. I run this test in both a Pentium\nM laptop and Pentium III laptop. I picked JazzLib because it is also a pure Java\nimplementation of ZipFile. Here are the results. Times are in milliseconds:\n\nPentium M\n\nTime taken for JazzZipFile Read: 70\nTime taken for JavaZipFile Read: 40\nTime taken for ApacheZipFile Read: 321\n\nPentium III\n\nTime taken for JazzZipFile Read: 250\nTime taken for JavaZipFile Read: 151\nTime taken for ApacheZipFile Read: 941\n\nThe above results show that JazzZipFile is only slighly slower than the Sun's\nJDK ZipFile but Apache ZipFile is quite a bit slower when compared to Sun.\n\nAttached:\n\nZipFilePerfTestCase.java\njazzlib-binary-0.07.jar (JazzLib jar file. 50k size)\n\nTo compile and run the file you will need, ant.jar, junit.jar and\njazzlib-binary-0.07.jar."}, {"count": 1, "tags": [], "bug_id": 31930, "attachment_id": 13236, "id": 65870, "time": "2004-10-28T01:51:14Z", "creator": "ant-venkatp@sneakemail.com", "creation_time": "2004-10-28T01:51:14Z", "is_private": false, "text": "Created attachment 13236\nJUnit test case"}, {"count": 2, "tags": [], "text": "Created attachment 13237\nJazzLib jar file", "attachment_id": 13237, "id": 65871, "creator": "ant-venkatp@sneakemail.com", "time": "2004-10-28T01:51:49Z", "bug_id": 31930, "creation_time": "2004-10-28T01:51:49Z", "is_private": false}, {"count": 3, "tags": [], "bug_id": 31930, "is_private": false, "id": 65872, "creation_time": "2004-10-28T02:01:09Z", "time": "2004-10-28T02:01:09Z", "creator": "ant-venkatp@sneakemail.com", "text": "The JUnit test method names ", "attachment_id": null}, {"count": 4, "tags": [], "bug_id": 31930, "attachment_id": null, "id": 66607, "time": "2004-11-08T14:29:24Z", "creator": "g.brand@interface-business.de", "creation_time": "2004-11-08T14:29:24Z", "is_private": false, "text": "We are using the zip part (only the expanding/reading part - so I can only\nspeak for that one), too. And also noticed how slow it is.\n\nYou might also want to change your test script that it displays 2 times:\n- The time used to open create the Zipfile instance\n- The time used to iterate over the files and directories and expand them.\nIf you do that, you will see that ant's zipfile implementation needs a long \ntime to open a zip. Why will become clear soon.\n\nI am currently checking and changing the sourcecode (unfortunately for ant this\nis going to be 1.4 java) but I can line out some of the flaws here.\n\n- Zipfiles use intel byte order, also known as little Endian.\n  The sources do the conversion correctly, but speak of \"Big Endian\" all\n  the time. This is a cosmetic bug, but wrong doc leads to wrong derivated work.\n\n- ZipShort/ZipLong classes should have static helper methods to get primitive\n  values. Instantiating an object just for the sake of getValue() doesn't help\n  performance.\n\n- When a zip is opened, the central directory is read in entry for entry and \n  each entry is parsed. This should be ok, it might be beneficial to read the\n  whole directory into memory, but not really that much thanks to modern\n  filesystems and caching (depends on directory size).\n  The only point skipped are the extra information. I have no idea why.\n  Wouldn't it be better to parse the extra data, or keep the raw data for\n  later on-demand parsing? (No real flaws here ;)\n\n- After that, local header information for each entry is gathered.\n  This is the starting offset for the compressed data and the extra\n  information that has been skipped before.\n  Now\n  a) is this only necessary if decompression or extra data is requested\n  b) does that cause a lot of stress for the filesystem as larg scale seeking\n     throughout the zip file is necessary\n  c) is the iteration order of the entries _NOT_ with increasing file offset\n     but randomly because the method is iterating over the values collection\n     of the hashtable. That really bogs down the performance (for uncached\n     files).\n\nMy ideas are:\n- Add static methods to the ZipDatatype classes.\n- Parse extra data when requested.\n- Read local header only if necessary (extra data, decompression)\n- If not then at least read the local headers in the right order.\n\nI implemented lazy header reading and this sped up opening a file over a \"slow\" \nnetwork connection from 18 to 2 seconds. Ordered header reading brought it down \nto 12 seconds.\nThe decompression to /dev/null isn't all that much slower than the java \nimplementation, no matter if lazy local headers were used or not.\n\nI also didn't graps the idea behind the two ZipFile tables \"entries\" \nand \"dataOffsets\", I simply store those two offsets in the ZipEntry instance.\n"}, {"count": 5, "tags": [], "text": "I looked at this last night, and noticed that there are a lot of enumerations\nand Vectors in ths code.  I'm not sure that synchronisation issues would occur\nif the implementation was changed to an unsynchronised collection (ArrayList for\nexample), but that should speed up reading the entries (I've not made any\nchanges and tested, so this is only supposition based on the performance hit\nthat synchronisation incurs).  \n\nAlso, the loops are not optimal in terms of the idioms used\nwhile(enumeration.hasMoreElements()) is an extra method call per iteration\n\nfor(int i=0, size=vector.size; i< size;) {\nvector.get(i);\n}\nis a little faster (in my experience) for tighter loops, and you don't have to\ncreate an enumeration.  Problem is code is more difficult to parse quickly!\n\nsmall loop unrolls *may* help, but only in the case where there are large\nfilesets, small Zip files would probably show little or no benefit.", "is_private": false, "bug_id": 31930, "id": 66618, "time": "2004-11-09T02:57:55Z", "creator": "kevin.jackson@it.fts-vn.com", "creation_time": "2004-11-09T02:57:55Z", "attachment_id": null}, {"count": 6, "tags": [], "text": "Any idea if we can use the JazzLib (GPL) code in Ant? Will there be any\nlicensing conflicts? I am thinking that it is easier to use a fresh code that is\nfaster than  trying to optimize the existing one. Based on my numbers it is a\nlot closer to the Sun's ZipFile and adding non unicode file name encoding\nsupport shouldn't be adding a lot of overhead?", "is_private": false, "bug_id": 31930, "id": 66620, "time": "2004-11-09T05:06:17Z", "creator": "ant-venkatp@sneakemail.com", "creation_time": "2004-11-09T05:06:17Z", "attachment_id": null}, {"count": 7, "tags": [], "text": "No, GPL code cannot be used in Apache code.", "is_private": false, "id": 66621, "creator": "conor@apache.org", "time": "2004-11-09T06:22:00Z", "bug_id": 31930, "creation_time": "2004-11-09T06:22:00Z", "attachment_id": null}, {"count": 8, "tags": [], "text": "Just looking again, and the method toDosTime() get's called frquently and\nreturns a ZipLong, each time it's used (in only two places), the ZipLong is\nqueried to extract the bytes (getBytes()).  Why not simply return a byte array\nand save the needless method call?\n\n- is toDosTime() called anywhere else in the code (it doesn't seem to be)?\n- is there a code convention where we must always return an object?\n\nAlso the change I made to remove deprecated (Date) code, means that a new\ncalendar instance is retrieved each call to toDosTime().  Making the calendar a\nclass variable would save another method call.  Small things like this *may*\nhelp, but again, there could be a much larger problem that I'm not aware of as\nI've only just started looking at the code base.", "is_private": false, "id": 66622, "creator": "kevin.jackson@it.fts-vn.com", "time": "2004-11-09T06:58:03Z", "bug_id": 31930, "creation_time": "2004-11-09T06:58:03Z", "attachment_id": null}, {"count": 9, "tags": [], "bug_id": 31930, "attachment_id": null, "id": 66741, "time": "2004-11-11T17:37:15Z", "creator": "sbailliez@apache.org", "creation_time": "2004-11-11T17:37:15Z", "is_private": false, "text": "Did someone ran a profiler on the code to figure out where we should focus ?"}, {"count": 10, "tags": [], "text": "It looks like a major slowdown is the hashtable put/get on the ZipEntry \nelement that seems to be due by collisions in the hashtable.\n\nThe problem seems to be caused by o.a.t.z.ZipEntry incorrectly inheriting from \nj.u.z.ZipEntry. In ZipFile it creates all ZipEntries but the initial name when \nbeing inserted in the hashtable is always \"\", and this is the one being used \nfor the instance hashcode (oups !)...and equals is not overriden in the base \nclass too.\n\nIf I override hashcode() and add a equals to ZipEntry and move the hashtable \ninsertion down a few lines in ZipFile so that the entry is initialized with \nthe right name, I have a nearly 3x improvement.\n\nUsing j2sdk-1_4_2-doc.doc.zip (9525 entries, 35.8MB) as a zip file, I can run \nthe attached testcase with the following timing:\n\nClient VM\nTime taken for JazzZipFile Read: 6239\nTime taken for JavaZipFile Read: 4216\nTime taken for ApacheZipFile Read: 4827\n\nServer VM\nTime taken for JazzZipFile Read: 5198\nTime taken for JavaZipFile Read: 4296\nTime taken for ApacheZipFile Read: 5588\n\n(JDK 1.4.2_06 on a Centrino 1.7GHz)\nI did a couple of small optimizations as well to avoid unecessary object \ncreation ie new ZipShort(..).getValue() as ZipShort.getValue(...), same for \nZipLong.\n\n", "attachment_id": null, "bug_id": 31930, "id": 66824, "time": "2004-11-12T23:50:54Z", "creator": "sbailliez@apache.org", "creation_time": "2004-11-12T23:50:54Z", "is_private": false}, {"count": 11, "tags": [], "bug_id": 31930, "attachment_id": null, "id": 67928, "time": "2004-12-04T12:49:12Z", "creator": "sbailliez@apache.org", "creation_time": "2004-12-04T12:49:12Z", "is_private": false, "text": "I committed some little changes in CVS HEAD, it does not seem to be extremely \nbeneficial for small zip file, but there should be definite improvement for \nbig ones. Next step is to look over at header reading.\nFeedback welcome"}, {"count": 12, "tags": [], "bug_id": 31930, "attachment_id": null, "id": 70564, "time": "2005-02-07T07:47:33Z", "creator": "sbailliez@apache.org", "creation_time": "2005-02-07T07:47:33Z", "is_private": false, "text": "Closing this. It normally is fixed (to some extent) in HEAD."}]