[{"count": 0, "tags": [], "bug_id": 29093, "attachment_id": null, "text": "We have noticed the following behaviour of manager application: sometimes when \nreloading context, it is stopped and than it is not started. It happens when \nserver is heavily loaded.\n\nWe think, that the reason of it is the following:\n\norg.apache.catalina.core.StandardContext, method reload()\n\n...\n        try {\n            stop();\n        } catch (LifecycleException e) {\n            log.error(sm.getString(\"standardContext.stoppingContext\"), e);\n        }\n\n        try {\n            start();\n        } catch (LifecycleException e) {\n            log.error(sm.getString(\"standardContext.startingContext\"), e);\n        }\n...\n\nMethod stop() can throw a runtime exception \n(org.apache.catalina.session.StandardSession):\n\n    public void removeAttribute(String name, boolean notify) {\n\n        // Validate our current state\n        if (!isValid())\n            throw new IllegalStateException\n                (sm.getString(\"standardSession.removeAttribute.ise\"));\n\n        removeAttributeInternal(name, notify);\n\n    }\n\n\n\nIs it possible to catch this exception:\n\n\n        try {\n            stop();\n        } catch (LifecycleException e) {\n            log.error(sm.getString(\"standardContext.stoppingContext\"), e);\n        } catch (IllegalStateException illegalStateException) {\n            log.error(sm.getString(\"standardContext.stoppingContext\"), \nillegalStateException);\n        }\n\n\nStack trace is provided:\n\njava.lang.IllegalStateException: removeAttribute: Session already invalidated\n        at org.apache.catalina.session.StandardSession.removeAttribute\n(StandardSession.java:1144)\n        at org.apache.catalina.session.StandardSession.removeAttribute\n(StandardSession.java:1119)\n        at org.apache.catalina.session.StandardSession.writeObject\n(StandardSession.java:1401)\n        at org.apache.catalina.session.StandardSession.writeObjectData\n(StandardSession.java:899)\n        at org.apache.catalina.session.StandardManager.doUnload\n(StandardManager.java:539)\n        at org.apache.catalina.session.StandardManager.unload\n(StandardManager.java:485)\n        at org.apache.catalina.session.StandardManager.stop\n(StandardManager.java:687)\n        at org.apache.catalina.core.StandardContext.stop\n(StandardContext.java:4474)\n        at org.apache.catalina.core.StandardContext.reload\n(StandardContext.java:3015)\n        at org.apache.catalina.manager.ManagerServlet.reload\n(ManagerServlet.java:1014)\n        at org.apache.catalina.manager.HTMLManagerServlet.reload\n(HTMLManagerServlet.java:477)\n        at org.apache.catalina.manager.HTMLManagerServlet.doGet\n(HTMLManagerServlet.java:100)\n        at javax.servlet.http.HttpServlet.service(HttpServlet.java:697)\n        at javax.servlet.http.HttpServlet.service(HttpServlet.java:810)\n        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter\n(ApplicationFilterChain.java:237)\n        at org.apache.catalina.core.ApplicationFilterChain.doFilter\n(ApplicationFilterChain.java:157)\n        at org.apache.catalina.core.StandardWrapperValve.invoke\n(StandardWrapperValve.java:214)\n        at org.apache.catalina.core.StandardValveContext.invokeNext\n(StandardValveContext.java:104)\n        at org.apache.catalina.core.StandardPipeline.invoke\n(StandardPipeline.java:520)\n        at org.apache.catalina.core.StandardContextValve.invokeInternal\n(StandardContextValve.java:198)\n        at org.apache.catalina.core.StandardContextValve.invoke\n(StandardContextValve.java:152)\n        at org.apache.catalina.core.StandardValveContext.invokeNext\n(StandardValveContext.java:104)\n        at org.apache.catalina.authenticator.AuthenticatorBase.invoke\n(AuthenticatorBase.java:540)\n        at org.apache.catalina.core.StandardValveContext.invokeNext\n(StandardValveContext.java:102)\n        at org.apache.catalina.valves.RequestFilterValve.process\n(RequestFilterValve.java:287)\n        at org.apache.catalina.valves.RemoteAddrValve.invoke\n(RemoteAddrValve.java:84)\n        at org.apache.catalina.core.StandardValveContext.invokeNext\n(StandardValveContext.java:102)\n        at org.apache.catalina.core.StandardPipeline.invoke\n(StandardPipeline.java:520)\n        at org.apache.catalina.core.StandardHostValve.invoke\n(StandardHostValve.java:137)\n        at org.apache.catalina.core.StandardValveContext.invokeNext\n(StandardValveContext.java:104)\n        at org.apache.catalina.valves.ErrorReportValve.invoke\n(ErrorReportValve.java:117)\n        at org.apache.catalina.core.StandardValveContext.invokeNext\n(StandardValveContext.java:102)\n        at org.apache.catalina.core.StandardPipeline.invoke\n(StandardPipeline.java:520)\n        at org.apache.catalina.core.StandardEngineValve.invoke\n(StandardEngineValve.java:109)\n        at org.apache.catalina.core.StandardValveContext.invokeNext\n(StandardValveContext.java:104)\n        at org.apache.catalina.core.StandardPipeline.invoke\n(StandardPipeline.java:520)\n        at org.apache.catalina.core.ContainerBase.invoke(ContainerBase.java:929)\n        at org.apache.coyote.tomcat5.CoyoteAdapter.service\n(CoyoteAdapter.java:160)\n        at org.apache.coyote.http11.Http11Processor.process\n(Http11Processor.java:793)\n        at \norg.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.processConnectio\nn(Http11Protocol.java:702)\n        at org.apache.tomcat.util.net.TcpWorkerThread.runIt\n(PoolTcpEndpoint.java:571)\n        at org.apache.tomcat.util.threads.ThreadPool$ControlRunnable.run\n(ThreadPool.java:644)\n        at java.lang.Thread.run(Thread.java:534)", "id": 57653, "time": "2004-05-19T15:44:58Z", "creator": "ia_rud@mail.ru", "creation_time": "2004-05-19T15:44:58Z", "is_private": false}, {"count": 1, "attachment_id": null, "creator": "ia_rud@mail.ru", "text": "Could somebody please comment this bug? It was opened two weeks ago ...\n\nI think, code should be changed to:\n\n        try {\n            stop();\n        } catch (LifecycleException e) {\n            log.error(sm.getString(\"standardContext.stoppingContext\"), e);\n        } catch (IllegalStateException illegalStateException) {\n        }\n", "id": 58824, "time": "2004-06-07T05:05:54Z", "bug_id": 29093, "creation_time": "2004-06-07T05:05:54Z", "tags": [], "is_private": false}, {"count": 2, "tags": [], "creator": "remm@apache.org", "attachment_id": null, "is_private": false, "id": 58826, "time": "2004-06-07T07:27:33Z", "bug_id": 29093, "creation_time": "2004-06-07T07:27:33Z", "text": "Ok, I'll comment: I think not, this case requires user intervention. How about\ntrying to find the cause of the exception instead ? (which I don't get, but was\nthe only reason why I didn't close your bug as INVALID in the first place)"}, {"count": 3, "tags": [], "creator": "ia_rud@mail.ru", "is_private": false, "text": "Yes, I agree, I have to find a reason of this behavior. But please imagine the \nsituation: server is loaded with 500 \u2013 1000 sessions or even more. And there is \na necessity of reloading context. And if this situation occurs, application \nwill not be available for several minutes, because the only thing we can do \u2013 \nrestart tomcat.\n\nIt is very convenient \u2013 possibility of context reload, but now we afraid reload \ncontext because if this happens, it is the same as tomcat restart.\n\n\nI am sorry, I do not know tomcat structure well enough. I may be wrong, but I \nhave a hypothesis how this can happen.\n\nThere is background thread that calls StoreBase.processExpires() method. This \nmethod walks through sessions and it may call StandardSession.recycle() or \nStandardSession.expire(). Both of this methods may set the following fields of \nSession object:\n\nexpiring         to          false;\nisValid           to          false;\naccessCount   to         0;\n\n\n\nSuppose, we reloading context - in StandardManager.doUnload we walk through \nsessions and call writeObjectData on each session, which will call writeObject \nmethod. It calls removeAttribute method, which may throw a runtime exception, \nif isValid() == false.\n\nisValid() == false \n\nif \n\nexpiring == false;\nisValid  == false;\naccessCount == 0;\n\nSuppose, at the same time background thread sets this fields to\n\nexpiring = false;\nisValid  = false;\naccessCount = 0;\n\nThan we will have this situation.\n\nI do not know is this hypothesis true or not. I may be wrong, but it is \nimportant for us that is why I am moving a suggestion.\n\nCould you please tell your opinion?", "id": 58828, "time": "2004-06-07T09:36:41Z", "bug_id": 29093, "creation_time": "2004-06-07T09:36:41Z", "attachment_id": null}, {"count": 4, "tags": [], "bug_id": 29093, "is_private": false, "text": "I would probably -1 catching this exception, as I'd like tomcat's lifecycle \nhandling code to handle lifecycle exceptions only, and leave other things \nhigher up the hierarchy.\n\nIf you really need this functionality, at least for the time being, I suggest \nextending StandardContext with your own context.  This is why Tomcat is open-\nsource and why we have the className attribute on the Context element: it's \ntrivial to extend and customize.  If over time you can't find a cause and are \nconvinced your fix is essential to the global tomcat community, we can reopen \nthis bug and/or re-discuss this issue on the tomcat-dev list.  So for now I'm \nclosing it.  If you do customize StandardContext and it works, please post \nyour findings to tomcat-user, to see if others find it helpful.", "id": 59073, "time": "2004-06-10T23:50:46Z", "creator": "yoavs@computer.org", "creation_time": "2004-06-10T23:50:46Z", "attachment_id": null}]