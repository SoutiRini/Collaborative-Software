[{"count": 0, "tags": [], "text": "While improving code for a logger at hand I found it useful to define my own levels to be suited to every application I have. That is, different logging levels defined for different applications.\n\nMoreover, I needed to be able to log a certain type of events no matter what the chosen level was (see logger.transparentLevels below).\n\nAt the beginning, I created a new config parameter as:\n\nlogger.referenceDescendingLevels=err,inf,deb\n\nwhich means that err (error) > inf (information) > deb (debug)\n\nwhich is practically the same story as Apache Log4J' Basic Selection Rule.\n\nTo be able to log CDR (Call Detail Records) type events, I have created a new config parameter as: \n\nlogger.transparentLevels=cdr\n\n(we can add / modify / displace levels in both parameters according to our needs)\n\nThe name 'transparent' was chosen to indicate that the levels listed in logger.transparentLevels are transparent to the Selection Rule ! A request with a level listed here passes the Selection Rule no matter what other application logging settings are.\n\n\nTill now, we have defined a Reference list and a Transparent List of levels, we just need one thing, a chosen log level which will define the current logging settings of our application:\n\nlogger.chosenLogLevel=inf.5\n\n\nFor the currently defined reference logging levels, values could be as listed below:\n\nerr (same as err.0)\ninf (same as inf.0)\ndeb (same as deb.0)\nerr.2 (any number)\ninf.3 (any number)\ndeb.8 (any number)\n\n\nI will explain what is the .5 for (in the logger.chosenLogLevel config) below:\n\nThe next interesting feature I've added is to be able to use Sub Levels into each level in an arbitrary fashion using a simple approach: the numbering system !\n\nlogger.chosenLogLevel=deb.4 means:\nlog all log requests (Logger.Log(\"deb.4\", \"This is your log request\");) till level deb and sub level 4\nExamples: \n     1. a request with deb.10 will be ignored.\n     2. a request with deb.3 / deb.2 / deb.1 / deb / inf / inf.2 / inf.10000, etc. / err.4, etc. / err will certainly be served.\n\n\nNote that the technique illustrated here can be used in a way to enable debugging for an application deployed on a live server, and be able to do further debugging (for instance, by specifying logger.chosenLogLevel=deb.7) when a problem is to be debugged. Of course, software developers are required to include adequate logging requests wherever useful it might be.\n\nOf course, software developers are invited to plan their logging software architecture so that they define which 'things' are to be considered at which 'level', 'sub level'; and code their sub levels in the most appropriate way, such as to use 'sub level' numbers in a meaningful way. \n\nFor this purpose, I propose to use SubLevel classes where useful sub levels are defined as:\n\npublic static int sub_level_live = 0;\n\npublic static int sub_level_deb = 0;\n\npublic static int sub_level_deb_transactions_summary = 1;\n\npublic static int sub_level_deb_transactions_full = 2;\n\npublic static int sub_level_deb_show_low_level_handshaking = 3;\n\n\nThose sub levels definitions should be suitable for your application logic.\n\nCan this be implemented in Log4J ? If it already can be done, how is that ? Can you provide a clear example please ?\n\nIf not, what about adding it to Log4J's TODO list ?\n\nBest Regards,\nRoger Tannous", "is_private": false, "id": 125899, "creator": "roger77_lb@hotmail.com", "time": "2009-03-31T02:49:22Z", "bug_id": 46941, "creation_time": "2009-03-31T02:49:22Z", "attachment_id": null}, {"count": 1, "tags": [], "bug_id": 46941, "attachment_id": null, "id": 125952, "time": "2009-04-02T05:36:28Z", "creator": "roger77_lb@hotmail.com", "creation_time": "2009-04-02T05:36:28Z", "is_private": false, "text": "(In reply to comment #0)\n\nThe 'requirement' is modified (improved) as described below:\n\n\nlogger.referenceDescendingLevels=err,general_info,(connection_status,handshaking),deb\n\nAs you can see, we can put sets of levels into parentheses to indicate that we wish the 'grouped levels' to be considered in the same 'logical level'.\n\nFor the example above, connection_status and handshaking both belong to the same 'logical level' 2 (levels are 0 based in my implementation).\n\nOf course, we can include more than one group of parentheses like in the below:\n\nlogger.referenceDescendingLevels=a,(b,c,d),e,(f,g),h,i\n\nLEVEL     LOGICAL_LEVEL\na         0\nb         1\nc         1\nd         1\ne         2\nf         3\ng         3\nh         4\ni         5\n\n\nFurthermore, we can include levels in \"full format\" into this config value, but this has one drawback, continue reading...\n\nlogger.referenceDescendingLevels=a,b,(c,d),(e,e.1,e.2,e.3),e.4,e.5,f\n\nOnce e,e.1,e.2,e.3 are defined in 'logical level' 3, we are obliged to state all other available levels belonging to the level named 'e' in \"full format\" (currently: e.4 and e.5) to prevent them from being missed !"}, {"count": 2, "text": "This really seems like you are trying to use levels to accomplish what the logger hierarchy was designed to do.  Many people make the assumption that since a common pattern for logger names is to follow class names that is the only way they can be used.  Logger names are, in general, are \"topics\" and you can use any system that works to give you the type of control that you'd want.\n\nIf you are trying to assign a \"topic\" (network, database, etc) to a level, then you not messing up the \"topic\" or \"audience\" concept up with the \"severity\" concept.  Logger names are really flexible and you can likely accomplish you goals without nearly as many complications.", "creator": "carnold@apache.org", "attachment_id": null, "id": 125962, "time": "2009-04-02T19:28:08Z", "bug_id": 46941, "creation_time": "2009-04-02T19:28:08Z", "tags": [], "is_private": false}, {"count": 3, "tags": [], "text": "I would suggest that you take a look at the Marker support in SLF4J and Logback and see if that would meet your needs. If so I would suggest asking for that feature in a future release instead of sub levels.", "is_private": false, "id": 125963, "creator": "Ralph.Goers@dslextreme.com", "time": "2009-04-02T22:20:35Z", "bug_id": 46941, "creation_time": "2009-04-02T22:20:35Z", "attachment_id": null}, {"count": 4, "text": "(In reply to comment #2)\n> This really seems like you are trying to use levels to accomplish what the\n> logger hierarchy was designed to do.  Many people make the assumption that\n> since a common pattern for logger names is to follow class names that is the\n> only way they can be used.  Logger names are, in general, are \"topics\" and you\n> can use any system that works to give you the type of control that you'd want.\n> \n> If you are trying to assign a \"topic\" (network, database, etc) to a level, then\n> you not messing up the \"topic\" or \"audience\" concept up with the \"severity\"\n> concept.  Logger names are really flexible and you can likely accomplish you\n> goals without nearly as many complications.\n\n\nUsing sub-levels is quite different from the standard logger hierarchy in that a new sub level can be introduced without being defined (because it's already a numeric value !)\n\nFor example, if we have already defined our logging by: \n\nlogger.referenceDescendingLevels=a,b,(c,d),e,f\n\nWe can use in the code: \n\nLogger.Log(\"e.11\", \"log text here\");\n\nwithout having to define sub-level 11 for logging level 'e' anywhere.\n(<start_of_parenthesis>\nI'm using here a direct String value as: \"e.11\", but in reality, you can have a class where levels are defined like: \npublic static String LOG_LEVEL_DATABASE_CONNECTION = \"e\";\npublic static String LOG_LEVEL_DATABASE_QUERY = \"f\";\n\nthen use: \n\nLogger.Log(LOG_LEVEL_DATABASE_CONNECTION + \".11\", \"DB connection logging here\");\n// Remember, I call this Logger.Log(...); function call a \" log request \" or a \" logging request \"; you'll find this name in the text below.\n<end_of_parenthesis>\n)\n\n\nAdditionally, suppose you have defined your levels and your application is up and running, then after a certain time you need a new logging \"level\" and need to separate its logging from the rest of the 'logs'; without the proposed technique, you have to 'insert' your new level _in_between_ existing ones. Doesn't this mean that you have to do additional work as you'll have to modify all \" logging requests \" that are usually \"below\" the newly introduced one ?\n\n\nAt the contrary, using the proposed technique, all you have to do is add the \" logging requests \" and add your new entry ANYWHERE in the logger.referenceDescendingLevels like:\n\nlogger.referenceDescendingLevels=a,b,MY_NEW_LEVEL,(c,d),e,f\n\nNow within MY_NEW_LEVEL, you can use as many sub-levels as you need without having to define them here.\n\n\nFinally, in the proposed technique, the method does not oblige you to abide by a certain rule as how to design levels and sub-levels. Most importantly, it doesn't tell sub-levels are strictly to be considered as severity ! This can be regarded as your own application design issue.\n\nYou can use sub-levels for one application as a severity indicator; for others as a sub-category, or even as a dummy number that you plan to deny logging for later after you test your new feature set.\n\n\n\nRemember that we can do this:\n\nlogger.referenceDescendingLevels=a,b,MY_NEW_LEVEL,MY_NEW_LEVEL.1,MY_NEW_LEVEL.2,(c,d),e,f\n\nHere is an example scenario:\n\nSuppose MY_NEW_LEVEL is newly introduced so we can do:\n\nlogger.referenceDescendingLevels=a,b,MY_NEW_LEVEL,(c,d),e,f\n\nsupposing:\nlogger.chosenLogLevel=e\n\nand the following \" logging requests \" are all allowed:\n\nLogger.Log(MY_NEW_LEVEL, \"your log text here\");\nLogger.Log(MY_NEW_LEVEL + \".0\", \"your log text here\"); // same as first line\nLogger.Log(MY_NEW_LEVEL + \".1\", \"your log text here\");\nLogger.Log(MY_NEW_LEVEL + \".2\", \"your log text here\");\nLogger.Log(MY_NEW_LEVEL + \".3\", \"your log text here\");\n\nYou do your tests, then want to restrict logging beyond MY_NEW_LEVEL.2 for the logging level MY_NEW_LEVEL. All you'll have to do is:\n\nlogger.referenceDescendingLevels=a,b,MY_NEW_LEVEL,MY_NEW_LEVEL.1,MY_NEW_LEVEL.2,(c,d),e,f\n\nsupposing:\nlogger.chosenLogLevel=e\n\nAs a result, the following \" logging requests \" are allowed:\n\nLogger.Log(MY_NEW_LEVEL, \"your log text here\");\nLogger.Log(MY_NEW_LEVEL + \".0\", \"your log text here\"); // same as first line\nLogger.Log(MY_NEW_LEVEL + \".1\", \"your log text here\");\nLogger.Log(MY_NEW_LEVEL + \".2\", \"your log text here\");\n\nBut this one is not:\n\nLogger.Log(MY_NEW_LEVEL + \".3\", \"your log text here\");\n\nFor this example value, the following \" logging requests \" for an undefined level is not allowed (i.e., they don't generate an error, but are simply not logged):\n\nLogger.Log(\"x\", \"your log text here\");\nLogger.Log(\"x.5\", \"your log text here\");\n\nThe idea in the example is that \" logging requests \" with levels that are not defined anywhere will not generate any error, they're simply ignored.", "creator": "roger77_lb@hotmail.com", "attachment_id": null, "id": 125967, "time": "2009-04-03T02:57:42Z", "bug_id": 46941, "creation_time": "2009-04-03T02:57:42Z", "tags": [], "is_private": false}]