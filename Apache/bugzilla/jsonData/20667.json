[{"count": 0, "tags": [], "text": "I think this is the same as:\n\nBUG# 15463\nBUG# 18609\n\nAt each request, access() is called, setting the following:\n\nlastAccessedTime = thisAccessedTime\nthisAccessedTime = the current system time/request time\n\nWhich is fine except that session expiration is driven by lastAccessedTime and \nnot thisAccessedTime as seen in processExpires().\n\nSo... lets say we have a 10 minute session timeout and a request comes in at \n12:00:00 PM.\n\nlastAccessedTime = 12:00:00 PM ( milli equivalent )\nthisAccessedTime = 12:00:00 PM\n\nSession will expire at 12:10:00 PM ( equivalent to lastAccessedTime + \nmaxInactiveInterval )\n\nThe next request is made at 12:09:00 PM... calls access()\n\nlastAccessedTime = 12:00:00 PM ( previous thisAccessTime )\nthisAccessedTime = 12:09:00 PM\n\nSession will expire at 12:10:00 PM ( because processExpires() uses timeNow - \nsession.getLastAccessedTime() )\n\n---------------------------------------------------------------------------\n\nStandardSession.access()\n\n    /**\n     * Update the accessed time information for this session.  This method\n     * should be called by the context when a request comes in for a particular\n     * session, even if the application does not reference it.\n     */\n    public void access() {\n\n        this.isNew = false;\n        this.lastAccessedTime = this.thisAccessedTime;\n        this.thisAccessedTime = System.currentTimeMillis();\n\n    }\n\n\nStandardManager.processExpires()\n\n    /**\n     * Invalidate all sessions that have expired.\n     */\n    private void processExpires() {\n\n        long timeNow = System.currentTimeMillis();\n        Session sessions[] = findSessions();\n\n        for (int i = 0; i < sessions.length; i++) {\n            StandardSession session = (StandardSession) sessions[i];\n            if (!session.isValid())\n                continue;\n            int maxInactiveInterval = session.getMaxInactiveInterval();\n            if (maxInactiveInterval < 0)\n                continue;\n            int timeIdle = // Truncate, do not round up\n                (int) ((timeNow - session.getLastAccessedTime()) / 1000L);\n            if (timeIdle >= maxInactiveInterval) {\n                try {\n                    expiredSessions++;\n                    session.expire();\n                } catch (Throwable t) {\n                    log(sm.getString(\"standardManager.expireException\"), t);\n                }\n            }\n        }\n\n    }", "is_private": false, "bug_id": 20667, "id": 38699, "time": "2003-06-10T23:19:05Z", "creator": "djo_34@yahoo.com", "creation_time": "2003-06-10T23:19:05Z", "attachment_id": null}, {"count": 1, "tags": [], "creator": "tom.clowers@expeditors.com", "attachment_id": null, "text": "\n\n*** This bug has been marked as a duplicate of 15463 ***", "id": 51254, "time": "2004-01-27T16:23:38Z", "bug_id": 20667, "creation_time": "2004-01-27T16:23:38Z", "is_private": false}]