[{"count": 0, "tags": [], "bug_id": 45368, "attachment_id": 22238, "id": 118410, "time": "2008-07-09T08:39:00Z", "creator": "abertuzzi@datamanagement.it", "creation_time": "2008-07-09T08:39:00Z", "is_private": false, "text": "Created attachment 22238\ndiff of the modificated progect files\n\nI have improved log4j, adding  Category.isCategoryAndAlmostOneAppenderDebugEnabled() and its generalization Category.isCategoryAndAlmostOneAppenderEnabledFor(Priority level) methods.\n\nThey are improvements respectively of Category.isDebugEnabled() and Category.isEnabledFor(Priority level).\n\nCategory.isCategoryAndAlmostOneAppenderDebugEnabled checks whether category and almost one appender are enabled for DEBUG level. \nCategory.isCategoryAndAlmostOneAppenderEnabledFor(Priority level) do the same thing for a given level.\n\nI need these new methods because Category.isDebugEnabled() is too restrictive. It checks only the category level, but I have to check also the appender threshold.\n\nTo help you understand I explain my application context.\n\nI work for a web application and I need one main log file and other user-dedicated log files. All files must have root category, because they must log all classes.\nMain log file logs at ERROR threshold, to log only exception (for faster application run).\nUser-dedicated log files log at DEBUG threshold, to log all things a particular user do.\n\nThis mechanism is achieved using org.apache.log4j.NDC and Servlet. \nWhen a user logs in, the login servlet pushes username in org.apache.log4j.NDC if user is present in a user-dedicated list; pushes \u201c\u201d if user is not present. The same value is also stored in session. Each time a servlet is used, NDC of the current thread is popped off and pushed in using the value stored in session. \nFileNDCAppender.subAppend(LoggingEvent event), an hand-made appender who works in a slightly different manner compared to buil-in appenders,  reads event.getNDC() and, according to its value, it writes on main log file or on a corresponding dedicated log file.\nSo a small number of final users can create log files at DEBUG threshold without restarting application, without changing log4j.properties and without creating delays to the normal application\u2019s performances, but only logging the application in by a specific username.\n\nTo do this, my log4j.properties is set as follows:\n\n\n# -------------------------   main log file\nlog4j.rootCategory= DEBUG, main, dedicated\nlog4j.appender.main=Logging.FileNDCAppender\nlog4j.appender.main.NDC=false\nlog4j.appender.main.Threshold=ERROR\n...\n\n# -------------------------   dedicated log file\nlog4j.appender.dedicated=Logging.FileNDCAppender\nlog4j.appender.dedicated.NDC=true\nlog4j.appender.dedicated.Threshold=DEBUG\n...\n\nI have only one category and two appenders named main and dedicated. Both appenders use Logging.FileNDCAppender. Main appender writes on main log file; dedicated appender writes on all dedicated log files. The difference is set by NDC attribute.\n\nAll works well, and I use this settings since 2004 at many customer.   \nRecently I have wrote one method (called logIndex) very heavy. It creates a big string reporting the state of a cache memory. \n\n         I want execute logIndex only if the string will be logged, \n\nhence only if the user is in user-dedicated list as above mentioned. So, at a first time I thought to Category.isDebugEnabled():\n\nif (log.isDebugEnabled())\n{\n\tlog.debug(logIndex());\n}\n\nObviously it don\u2019t work, because I\u2019m forced to set category at DEBUG level (otherwise\n dedicated appender can not write at DEBUG level). I achieved my target by\n\nif (log.isCategoryAndAlmostOneAppenderDebugEnabled ())\n{\n\tlog.debug(logIndex());\n}\n\nIt satisfies the condition:\n\nCategory is a DEBUG level and almost one appender is enabled\n\n\nI means one appender is enabled when it satisfies threshold checks and a new method called AppenderSkeleton.isEnabledFor(priority level) returns true.\nAppenderSkeleton.isEnabledFor(priority level) checks appender\u2019s threshold and if satisfied executes AppenderSkeleton.isSubEnabledFor(priority level), who returns true by default. If overridden it is possible to personalize appender enable check.\n\nIn my application context I wrote Logging.FileNDCAppender.isSubEnabledFor(Priority level) in this way:\n\n      public boolean isSubEnabledFor(Priority level)\n      {\n            boolean dedicated = (org.apache.log4j.NDC.peek().length() > 0);\n\n            if (NDC == false && dedicated)\n            {\n                  return false;\n            }\n            else if (NDC && dedicated == false)\n            {\n                  return false;\n            }\n\n            return true;\n      }\n\nwhere NDC is attribute NDC in log4j.properties.\n\nBest Regards,\n\nAntonio Bertuzzi"}, {"count": 1, "tags": [], "bug_id": 45368, "is_private": false, "text": "I made a mistake. In all the names of methods I wrote ALMOST in place AT LEAST. \nFeel free to correct ", "id": 118677, "time": "2008-07-15T07:41:21Z", "creator": "abertuzzi@datamanagement.it", "creation_time": "2008-07-15T07:41:21Z", "attachment_id": null}, {"count": 2, "tags": [], "bug_id": 45368, "attachment_id": null, "id": 119739, "creation_time": "2008-08-12T10:36:35Z", "time": "2008-08-12T10:36:35Z", "creator": "carnold@apache.org", "text": "I appreciate the patch, but it doesn't seem generally useful enough to justify the changes to the log4j API at this point in the release cycle.  Adding as a wish list item to log4j 2.0 (https://issues.apache.org/jira/browse/LOG4J2-24).", "is_private": false}, {"count": 3, "tags": [], "text": "I think your situation might be better addressed by a combination of LogMF from the extras companion (with possible enhancements for deferring construction of messages that require evaluating Object.toString()), the long dormant MultiFileAppender project and use of message objects that can delay evaluation until message formatting.  Those should not require changes to the core log4j API and should offer similar performance to your approach.\n\nIf your performance issue is the unnecessary evaluation of functions in the message parameter, you can delay those evaluations until message layout time by passing a class whose toString() evaluates the expensive function.\n\nprivate static class LogIndexEvaluator {\n    private final MyClass obj;\n    public LogIndexEvaluator(MyClass o) {\n        if (o == null) {\n           throw NullPointerException();\n        }\n       obj = o;\n    }\n    public String toString() {\n       return String.valueOf(o.logIndex());\n    }\n}\n\n....\n\n\nif (log.isDebugEnabled()) {\n    log.debug(new LogIndexEvaluator(this));\n}\n\nConstruction of a small short lived object is pretty inexpensive in modern JVM's.", "is_private": false, "bug_id": 45368, "id": 119838, "time": "2008-08-14T08:37:34Z", "creator": "carnold@apache.org", "creation_time": "2008-08-14T08:37:34Z", "attachment_id": null}]