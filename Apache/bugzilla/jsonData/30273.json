[{"count": 0, "tags": [], "bug_id": 30273, "text": "We have a number of servers that handle requests that, from the perspective of\nthe client, only occur once in a great while.  Because holding the connection\nopen in such a situation only uses system resources unnecessarily; we have the\nservlet add a \"Connection: close\" header field to the response object.\n\nHowever, the Http11Processor class does not check for this header value in the\nresponse object and merrily assumes that the connection will stay open if the\nclient says that it should.  Thus, we have a situation where the client sees\nthat the connection is supposed to go away (because it sees the \"Connection:\nclose\" header), and the server thinks that the client is going to send another\nrequest (because it doesn't check).  Now, some number of clients appear to close\nthe connection immediately upon receipt of the response, while others wait for\nthe server to perform the socket shutdown operation.  The latter situation\nusually results in both client and server hanging until the server times the\nconnection out.\n\nWhile we can work around this issue in many cases by setting the (undocumented!)\n\"maxKeepAliveRequests\" parameter on the connector to \"1\", this is somewhat\nunsatisfactory because then ALL requests for ALL servlets made through that\nconnection are closed immediately.\n\nThis makes it difficult to support situations where we have one servlet that\nneeds to force close connections based either on information held in the\nresponse, or on specific APIs (URLs) being handled through that servlet; and\nanother servlet (or URL/API) that can take full advantage of the streamlined\ncommunication that can take place when the connection is retained.\n\nWhile we could handle many such situations by configuring several connectors,\none for short term and one for long term connectivity needs, and simply\nconnecting to the short term or long term port as needed, we only have API level\npolicy on connection term lengths rather than full program control over when the\nconnection actually should be dropped.\n\nWhile this behavior is not spelled out in the Java Servlet Specification (v2.3)\nit IS spelled out in RFC 2068 (section 14.10) - the HTTP v1.1 definition. \nCorrect behavior is to close the socket after the response is sent if\n\"Connection: close\" is sent to the client.  Whether this header is sent by the\nHttp11Processor or by the servlet the processor must respect this functionality.\n\nAs an aside on implementation: the Http11Processor should NOT add a second\n\"Connection: Keep-Alive\" or \"Connection: close\" field to the header if a\n\"Connection\" header field has already been set.  However, a \"Connection:\nKeep-Alive\" may reasonably be replaced with a \"Connection: close\" if necessary,\nbut a \"Connection: close\" should never be replaced with a \"Connection: Keep-Alive\".", "id": 60994, "time": "2004-07-22T21:00:42Z", "creator": "ksitze@yahoo.com", "creation_time": "2004-07-22T21:00:42Z", "is_private": false, "attachment_id": null}, {"count": 1, "tags": [], "creator": "remm@apache.org", "text": "The servlet should not attempt to control the connection state; handling\nanything the servlet would do would make the HTTP stack too complex. Please do\nnot reopen this report.", "id": 61000, "time": "2004-07-22T21:42:17Z", "bug_id": 30273, "creation_time": "2004-07-22T21:42:17Z", "is_private": false, "attachment_id": null}, {"count": 2, "tags": [], "creator": "minfrin@apache.org", "text": "I don't think it's unreasonable for the servlet to control the HTTP connection -\nit is supported by both the servlet spec (in that it is possible to set headers\non the response) and is required by RFC2616 (HTTP 1.1).\n\nIt should be a simple thing for the HTTP connector to check for values in the\nConnection header, and if \"close\" is present, to cancel any effort at keepalive.\n\nI think the behaviour described is definitely a bug.\n", "id": 61002, "time": "2004-07-22T22:03:37Z", "bug_id": 30273, "creation_time": "2004-07-22T22:03:37Z", "is_private": false, "attachment_id": null}, {"attachment_id": null, "tags": [], "creator": "remm@apache.org", "is_private": false, "count": 3, "id": 61003, "time": "2004-07-22T22:07:25Z", "bug_id": 30273, "creation_time": "2004-07-22T22:07:25Z", "text": "While I do respect your opinion, I disagree with that."}, {"count": 4, "tags": [], "bug_id": 30273, "text": "In matters of how the an HTTP connector should work, I think RFC2616 should have\nthe final say - but as I don't have time to come up with a patch right now, I\nwill shut up now :)\n", "id": 61010, "time": "2004-07-22T22:24:06Z", "creator": "minfrin@apache.org", "creation_time": "2004-07-22T22:24:06Z", "is_private": false, "attachment_id": null}, {"count": 5, "attachment_id": null, "creator": "remm@apache.org", "text": "There are a lot of other things: transfer encoding, content encoding, etc. I\ndon't want to start touching these functionality, since there are *way* too many\nchecks that would have to be done. My opinion in the end is that the servlet\nshould have as little control as possible on the transport (which makes sense,\nsince it's non portable); I'm already not too happy about the way a servlet can\nflush and end a response (but I think these have a few use cases).\n\nIn this bug report, if there is a broken client, you should use a restricted\nuser-agent parameter rather than hack the servlets.\n\nSo definitely WONTFIX.", "id": 61011, "time": "2004-07-22T22:33:17Z", "bug_id": 30273, "creation_time": "2004-07-22T22:33:17Z", "tags": [], "is_private": false}, {"count": 6, "attachment_id": null, "creator": "ksitze@yahoo.com", "text": "While I will not reopen this bug, I simply want to put my $0.10 cents in here\n(there's more than $0.02 cents of material here).\n\nFirst, my opinion is that the servlet container simply cannot have the kind of\ninsight into the various needs of any given client/server system to do the\n\"Right Thing\" (tm) with respect to the transport layer all of the time.  The\nworking defaults provided by the container may be good enough for the 80% of\ntypical work loads, however the other 20% will have to go elsewhere and/or deal\nwith the situation using cumbersome workarounds.  These kinds of limitations\ndesigned into the servlet container will reduce its ability to become an upward\npath for legacy systems and will in addition place artifical limits on systems\nwith unusual work loads.\n\nSecond, I would like to point out that your last argument sound suspiciously\nlike \"this is too hard to do right, therefore I'll ignore the problem.\"  This\nproblem will not go away because you deem it difficult to do right by all cases\nyou can think of.  From our experience, most of the clients we are right now\nhaving problems with appear to be Windows clients with a relatively recent\nsecurity patch installed.  In other words, this specific problem will likely\nbecome a larger issue than it is now, and you will likely have to deal with\ndropping in a fix anyway, because for *damn* sure M$ isn't going to care.\n\nThird, I can appreciate that time constraints may prevent a full out fix for all\nof the issues you have raised, however, many of these header issues you have\noutlined are already not handled (at all) by the servlet container, and thus are\ncurrently put into place by the servlet anyway.  In other words you are FORCING\nservlets to deal with the transport layer *today*.\n\nFor example, the only way that I can push a gzipped response to the client\n*right now* is to check to see if the client issued me an \"Accept-Encoding\"\nheader field containing \"gzip\" and then respond with a \"Content-Encoding: gzip\"\nheader field and gzipping the response.  This is ALL done at the servlet layer,\nbecause the container isn't doing this for me, I had to write a subclass of\njavax.servlet.http.HttpServlet to do the right thing for all of my servlets.\n\nBy your argument, the connector should have done this check by default for the\nservlet (with an option to turn off this behavior, of course).\n\nBecause this situation exists today, if you (the connector programmers as a\ngroup) decide to handle the transport level \"Accept-Encoding\" header field from\nwithin the container layer, then you'll have to deal with the compatability\nissues of servlets that already handle this behavior.\n\nThus, your \"WONTFIX\" is simply putting off the inevitable, because while I'm\nprobably in a small minority of programmers actually pushing \"Connection: close\"\nto clients, I'm sure that I am not the only developer that had to write code for\ngzipping response bodies.\n\n-- Not to mention that you STILL leave other servlets who are expecting that the\ncontainer will manifest the HTTP protocol properly (even in the corner cases) as\nbeing broken by (your) design.\n\nThis is a definite \"SHOULDFIX\" in my book.", "id": 61213, "time": "2004-07-28T06:07:24Z", "bug_id": 30273, "creation_time": "2004-07-28T06:07:24Z", "tags": [], "is_private": false}, {"count": 7, "tags": [], "bug_id": 30273, "attachment_id": null, "text": "If M$ no longer supports connection keep-alive properly (!!! can you actually\ngive details on what's broken exactly, I need a good laugh ;) ), then you should\nadd a user-agent regexp filter on the connector, and handle them as legacy\nclients. My problem with this issue (you did read my reply, right ? ;) ) is that\nit would open the door to supporting everything else, which is extremely complex\n(and what if the servlet wants to do chunking or TEs by itself, etc, etc).\n\nThe connector supports gzipping, and would have supported transfer encoding,\nexcept I ran into trouble with that because of the implementation from my\nfriends from M$.", "id": 61222, "time": "2004-07-28T10:12:48Z", "creator": "remm@apache.org", "creation_time": "2004-07-28T10:12:48Z", "is_private": false}]