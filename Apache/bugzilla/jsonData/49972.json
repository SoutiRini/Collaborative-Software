[{"count": 0, "tags": [], "bug_id": 49972, "attachment_id": null, "text": "r998053\nclass org/apache/tomcat/util/http/FastHttpDateFormat\nhttp://svn.apache.org/repos/asf/tomcat/tc6.0.x/trunk/java/org/apache/tomcat/util/http/FastHttpDateFormat.java\n\nThere is double-check anti-pattern in public static final String getCurrentDate() method\non protected static long currentDateGenerated variable\n\nConcurrent read on line 112\nConcurrent write on line 115\n\nP.S.: Maybe I have mistake with determine component", "id": 140043, "time": "2010-09-22T04:44:02Z", "creator": "sergeyvorobyev@google.com", "creation_time": "2010-09-22T04:44:02Z", "is_private": false}, {"count": 1, "tags": [], "creator": "sebb@apache.org", "attachment_id": null, "id": 140054, "time": "2010-09-22T06:53:24Z", "bug_id": 49972, "creation_time": "2010-09-22T06:53:24Z", "is_private": false, "text": "The currentDateGenerated field is read outside the synch. block, and is not volatile.\n\nSo if one thread calls getCurrentDate() and updates the field, another thread calling getCurrentDate() may see a stale value. \n\nNow a stale value will be smaller than the proper value, so the worst that can happen is that the synch. block is invoked unnecessarily. The synch. block will pick up the true value, and skip the format call if necessary.\n\nHowever, this assumes that the field is only updated by the getCurrentDate() method. As the field is not private, that is not guranteed.\n\nSeems to me that the field should be made private, and a comment added to explain why the double-check is OK in this case.\n\nIf read-only access is needed, a getter could be added for the binary field."}, {"count": 2, "text": "It looks scarier than that. \nIn short, see http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html\n\nCase1: \n\nThread1 executes: \n        long now = System.currentTimeMillis();\n        if ((now - currentDateGenerated) > 1000) {\n            synchronized (format) {\n                if ((now - currentDateGenerated) > 1000) {\n                    currentDateGenerated = now;\nThread2 executes: \n        long now = System.currentTimeMillis();\n        if ((now - currentDateGenerated) > 1000) {\nThread2 skips the \"if\" part.\n\nIf these were the first calls to this function the return value in Thread2 will be null. \n\n-----\nCase2: \n\nThread1 executes: \n                  currentDate = format.format(new Date(now));\nThread2 goes through fast path and executes         \n    return currentDate;\n\nThe object currentDate was not properly published and according to the Java memory model (if I understand it correctly) may be incomplete. \n\n\nOf course, in practice you will not see any problem in 99.9% of the cases.", "creator": "konstantin.s.serebryany@gmail.com", "is_private": false, "id": 140063, "time": "2010-09-22T09:56:49Z", "bug_id": 49972, "creation_time": "2010-09-22T09:56:49Z", "tags": [], "attachment_id": null}, {"count": 3, "tags": [], "creator": "chuck.caldarale@unisys.com", "attachment_id": null, "id": 140066, "time": "2010-09-22T10:20:36Z", "bug_id": 49972, "creation_time": "2010-09-22T10:20:36Z", "is_private": false, "text": "(In reply to comment #2)\n> It looks scarier than that. \n> In short, see\n> http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html\n\nNot all double-checked locking is evil.\n\nThe simple fix is to just reverse these two lines:\n\n                    currentDateGenerated = now;\n                    currentDate = format.format(new Date(now));\n\nBy setting currentDate prior to currentDateGenerated, the potential of returning null is eliminated, and unnecessary locking is still avoided.  (This is in addition to making the field private, as Sebb noted.)\n\nCase 2 is not a problem; the Java language spec requires operations to be visible to other threads in program order, so the all operations for building the new formatted String must be complete before the reference to it is stored in the field.\n\n - Chuck"}, {"count": 4, "tags": [], "creator": "konstantin.s.serebryany@gmail.com", "text": ">> The simple fix is to just reverse these two lines:\nI afraid, it won't work. \nThe compiler is free to reverse these lines back. \n(maybe not in this particular case, but certainly in general). \n\n>> the Java language spec requires operations to be visible to other threads in program order\nDoes it? \n(I am a C++ guy, could you point me to the place in Java docs where this is stated?)\nFrom what I can see, the order is guaranteed only in the presence of happens-before relation (volatile write followed by volatile read or a mutex unlock followed by a mutex lock).", "id": 140068, "time": "2010-09-22T10:53:58Z", "bug_id": 49972, "creation_time": "2010-09-22T10:53:58Z", "is_private": false, "attachment_id": null}, {"attachment_id": null, "tags": [], "bug_id": 49972, "text": "Also, there are problem with 64 bit variable currentDateGenerated\n\nhttp://java.sun.com/docs/books/jls/third_edition/html/memory.html\nquote:\nFor the purposes of the Java programming language memory model, a single write to a non-volatile long or double value is treated as two separate writes: one to each 32-bit half. This can result in a situation where a thread sees the first 32 bits of a 64 bit value from one write, and the second 32 bits from another write. Writes and reads of volatile long and double values are always atomic. Writes to and reads of references are always atomic, regardless of whether they are implemented as 32 or 64 bit values.\n\nSo in first (lock-free) check\nif ((now - currentDateGenerated) > 1000)\nWe can read inconsistante state", "count": 5, "id": 140074, "time": "2010-09-22T11:46:36Z", "creator": "sergeyvorobyev@google.com", "creation_time": "2010-09-22T11:46:36Z", "is_private": false}, {"count": 6, "text": "(In reply to comment #4)\n> > The simple fix is to just reverse these two lines:\n> I afraid, it won't work. \n> The compiler is free to reverse these lines back.\n\nNot in this case, due to the possibility of the new operator throwing an exception and the constraint specified in section 11.3.1:\n\n\"Exceptions are precise: when the transfer of control takes place, all effects of the statements executed and expressions evaluated before the point from which the exception is thrown must appear to have taken place. No expressions, statements, or parts thereof that occur after the point from which the exception is thrown may appear to have been evaluated.\"\n\nIf there were no possibility of an exception, your statement would be true.\n\n> > the Java language spec requires operations to be \n> > visible to other threads in program order\n> Does it? \n\nThat's my interpretation of this statement in section 17.4:\n\n\"Each time the evaluation of thread t generates an inter-thread action, it must match the inter-thread action a of t that comes next in program order.\"\n\nAll reads and writes of shared variables are inter-thread actions.\n\n - Chuck", "creator": "chuck.caldarale@unisys.com", "is_private": false, "id": 140076, "time": "2010-09-22T12:53:46Z", "bug_id": 49972, "creation_time": "2010-09-22T12:53:46Z", "tags": [], "attachment_id": null}, {"count": 7, "text": "(In reply to comment #5)\n> Also, there are problem with 64 bit variable currentDateGenerated\n\nThis is a problem (albeit a fairly minor one); technically, the field should be marked volatile to insure all 64 bits are read and written together.  Not sure what that does to code generation on a 32-bit machine, but I suspect it's not pretty.  Another reason we should all be running 64-bit boxes...\n\n - Chuck", "creator": "chuck.caldarale@unisys.com", "is_private": false, "id": 140077, "time": "2010-09-22T12:58:53Z", "bug_id": 49972, "creation_time": "2010-09-22T12:58:53Z", "tags": [], "attachment_id": null}, {"attachment_id": null, "tags": [], "bug_id": 49972, "is_private": false, "count": 8, "id": 140090, "time": "2010-09-23T04:03:35Z", "creator": "konstantin.s.serebryany@gmail.com", "creation_time": "2010-09-23T04:03:35Z", "text": ">> If there were no possibility of an exception, your statement would be true.\nI am not sure about this particular case, but in general a compiler (JIT) may statically figure out that an exception will never be thrown and eliminate the exception handling code completely -- and then shuffle the code in arbitrary way. \nI don't think that 'this code may throw exception' may be used as synchronization."}, {"count": 9, "tags": [], "bug_id": 49972, "attachment_id": null, "text": "Fixed in trunk and proposed for 6.0.x", "id": 140559, "time": "2010-10-07T10:07:22Z", "creator": "markt@apache.org", "creation_time": "2010-10-07T10:07:22Z", "is_private": false}, {"attachment_id": null, "tags": [], "bug_id": 49972, "is_private": false, "count": 10, "id": 140724, "time": "2010-10-13T11:07:03Z", "creator": "markt@apache.org", "creation_time": "2010-10-13T11:07:03Z", "text": "Fixed in 6.0.x for 6.0.30 onwards."}]