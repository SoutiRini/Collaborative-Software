[{"count": 0, "tags": [], "bug_id": 48110, "attachment_id": null, "is_private": false, "id": 131613, "time": "2009-11-03T05:41:30Z", "creator": "strube@physik3.gwdg.de", "creation_time": "2009-11-03T05:41:30Z", "text": "In the documentation page of mod_fcgid, there is a paragraph concerning \"PHP child process management\":\n*BEGIN CITATION*\nPHP child process management (PHP_FCGI_CHILDREN) should always be disabled with mod_fcgid, which will only route requests to application processes it has spawned.  Any child processes created by PHP will be unused and may not be terminated properly.  By default, and with the environment variable setting PHP_FCGI_CHILDREN=0, PHP child process management is disabled.\n*END CITATION*\nThis appears incorrect according to my long experience with mod_fastcgi and recent tests with mod_fcgid. With PHP_FCGI_CHILDREN > 0, the PHP process spawned by the module does no actual work but only spawns (and, if necessary, respawns) children that do the processing of the data stream passed to them by the parent PHP. It is easily seen (e.g., using \"top\") that practically only the child PHP processes consume CPU time -- that they \"will be unused\" is completely wrong. mod_fcgid does not need any knowledge about the child processes. Of course, one should then configure mod_fcgid so that (for one class) there is exactly one parent PHP process, which should run permanently, and leave the distribution of work to this process rather than to mod_fcgid.\nWe have such a configuration running on our webserver (with mod_fastcgi, but also tested with mod_fcgid) for a long time. Especially, using the APC extension of PHP, this allows the common usage of the shared-memory code cache of APC by the spawned PHP processes."}, {"count": 1, "tags": [], "bug_id": 48110, "attachment_id": null, "is_private": false, "id": 131619, "time": "2009-11-03T06:58:53Z", "creator": "trawick@apache.org", "creation_time": "2009-11-03T06:58:53Z", "text": "Hi there,\n\nI'm glad to see that someone is reading the new docs, and I must confess that the PHP-related information is particularly deserving of scrutiny due to the lack of PHP documentation in this area as well as the wide distribution of conflicting information about behavior with mod_fcgid.\n\nThe heart of the matter is that mod_fcgid will not route a request to a process it has not created, and will not route to a process if a request previously routed to it is still in progress.  Thus, if the PHP process created by mod_fcgid is idle or has an idle child process because it has passed a current request to a child, mod_fcgid still will not send another request to it.\n\nI think this incomplete+incorrect information\n\n\"... which will only route requests to application processes it has spawned. Any child processes created by PHP will be unused ...\"\n\ncan be replaced with\n\n\"... which will only route requests to application processes it has spawned, and is not aware that PHP may have passed active requests to another PHP process.  Any child processes created by PHP will not be effectively utilized ...\"\n\nDoes this make sense?\n\nDo you have empirical evidence to the contrary?\n\nThanks!"}, {"count": 2, "tags": [], "bug_id": 48110, "is_private": false, "text": "Well, I think that the PHP child processes are simply irrelevant to mod_fcgid; the  parent PHP is the only one seen and treated like a single PHP process. I do not understand \"if the PHP process created by mod_fcgid is idle or has an idle child process because it has passed a current request to a child, mod_fcgid still will not send another request to it.\" How can the parent PHP process possibly be considered idle by mod_fcgid as long as one of its children is still processing a request?\nBut you really make an important point: \"will not route to a process if a request previously routed to it is still in progress.\" This could mean that a PHP parent with several children would not be faster than a single PHP process. (I have not really measured this, also don't know whether mod_fastcgi and mod_fcgid act differently in this respect.) Then your replacement would make sense.\nHowever, in my scenario with APC extension, the child management by a PHP parent is even then advantageous, since crashed children are replaced without losing the content of the APC shared-memory cache (which is created during parent startup and is shared with the children).", "id": 131626, "time": "2009-11-03T07:49:28Z", "creator": "strube@physik3.gwdg.de", "creation_time": "2009-11-03T07:49:28Z", "attachment_id": null}, {"count": 3, "tags": [], "bug_id": 48110, "attachment_id": null, "is_private": false, "id": 131685, "time": "2009-11-04T05:26:37Z", "creator": "strube@physik3.gwdg.de", "creation_time": "2009-11-04T05:26:37Z", "text": "More info re \"This could mean that a PHP parent with several children would not be faster than a single PHP process.(I have not really measured this, also don't know whether mod_fastcgi and mod_fcgid act differently in this respect.)\"\n\nI just compared mod_fastcgi and mod_fcgid using PHP_FCGI_CHILDREN = 1 or 2 in both cases and benchmarking with \"ab -n 50 -c 2 http://....\" on a multiprocessor SPARC server (Solaris 10). Indeed, with mod_fastcgi, the time was halved for PHP_FCGI_CHILDREN=2, whereas this was not the case with mod_fcgid! Thus, mod_fastcgi is superior in this respect. (On a single-processor machine, this will probably be irrelevant.) Configuration was:\n    FcgidIPCDir /some/dir\n    FcgidProcessTableFile /some/file\n    FcgidIdleTimeout 0\n    FcgidMaxProcesses 1\n    FcgidMaxProcessesPerClass 1\n    FcgidMinProcessesPerClass 1\n    FcgidInitialEnv PHPRC /some/path\n    FcgidInitialEnv PHP_FCGI_CHILDREN 2 # or 1 or 0\n    FcgidInitialEnv TZ MET\n    FcgidFixPathinfo 1"}, {"count": 4, "tags": [], "bug_id": 48110, "text": "corrected inaccuracies and added note about APC cache in\n\nhttp://svn.apache.org/viewvc?view=revision&revision=901480", "id": 133758, "time": "2010-01-20T17:22:33Z", "creator": "trawick@apache.org", "creation_time": "2010-01-20T17:22:33Z", "is_private": false, "attachment_id": null}]