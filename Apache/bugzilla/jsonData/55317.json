[{"count": 0, "tags": [], "bug_id": 55317, "text": "Most application servers provide a mechanism whereby web applications can instrument class bytecode. This is normally in the form of two or three instrumentation methods on the ClassLoader implementation responsible for web application class loading. Spring Framework, for example, provides a way to automatically detect and use the various instrumentable ClassLoaders provided by different application servers. However, since Tomcat's o.a.catalina.loader.WebappClassLoader is not instrumentable, Spring cannot use it directly. Instead, it provides a class that extends WebappClassLoader to implement the instrumentation. Users must place this special spring-instrument-tomcat.jar file in $TOMCAT_HOME/lib and put a loader declaration in META-INF/context.xml in order to get this to work--rather a pain in the rear.\n\nSpring's changes in the extended WebappClassLoader are really very trivial and involve only 2 classes: a helper class called WeavingTransformer [1] and the extended TomcatInstrumentableClassLoader [2]. I intend to port these changes to Tomcat for Tomcat 7 and 8 and submit a patch.\n\nHowever, before I get started I needed to get two answers from the community:\n\n1) Is there any objection to such a simple addition to WebappClassLoader? I think it would be an easy-but-big improvement to Tomcat.\n\n2) What steps do I need to take to get this Spring code officially \"donated\" to Tomcat so that all legal requirements are met? The code is licensed Apache 2.0, so that at least should make it easier.\n\n[1] https://github.com/SpringSource/spring-framework/blob/master/spring-instrument-tomcat/src/main/java/org/springframework/instrument/classloading/WeavingTransformer.java\n[2] https://github.com/SpringSource/spring-framework/blob/master/spring-instrument-tomcat/src/main/java/org/springframework/instrument/classloading/tomcat/TomcatInstrumentableClassLoader.java", "id": 168845, "time": "2013-07-28T07:17:28Z", "creator": "nicholas@nicholaswilliams.net", "creation_time": "2013-07-28T07:17:28Z", "is_private": false, "attachment_id": null}, {"count": 1, "tags": [], "bug_id": 55317, "attachment_id": null, "id": 168846, "time": "2013-07-28T07:52:25Z", "creator": "markt@apache.org", "creation_time": "2013-07-28T07:52:25Z", "is_private": false, "text": "I have no objections in principle but obviously I'd want to see the proposed patch first.\n\nI will say that someone from the Spring project will need to confirm that any proposed patch is a) correct and b) helpful."}, {"count": 2, "tags": [], "bug_id": 55317, "text": "Why would one need to extend the webapp class loader? A quick look to java.lang.instrument indicates that one should be able to do it with a normal instrumentation agent. Can you clarify?\n\nThe registered ClassFileTransformers will get the classloader passed in in their transform() call so can decide whether it is a webapp classloader and it wants to act on the class.\n\nProbably it would be nice if there were an easy way to associate the webapp with the WebappClassLoader, or at least the WebappLoader could be retrieved from the WebappClassLoader. From there one can get the necessary info about the webapp via the container.", "id": 168847, "time": "2013-07-28T08:15:31Z", "creator": "rainer.jung@kippdata.de", "creation_time": "2013-07-28T08:15:31Z", "is_private": false, "attachment_id": null}, {"count": 3, "tags": [], "creator": "rainer.jung@kippdata.de", "attachment_id": null, "text": "Sorry, me again: if we want to support it in an agent free way, it seems it woul suffice to add a addTransformer() (or probably better registerTransformer() and unregisterTranformer()) call to the WebappClassLoader that maintains a list of added tranformers and calls them in findResourceInternal() similar to the original spring code. The original spring code calls all of them in turn until the first one succeeds. Don't know whether it would be better to proceed calling in registration order to allow mutliple transformations to occur.\n\nThere's no real need to support the proprietry getThrowawayClassLoader() method, which makes most of the lines unnecessary and we'll also not need the WeavingTransformer because we can call the registered Transformers directly.\n\nAs far as I can see spring can support the getThrowawayClassLoader() on top of that without subclassing our class loader.\n\nWDYT?", "id": 168848, "time": "2013-07-28T09:25:09Z", "bug_id": 55317, "creation_time": "2013-07-28T09:25:09Z", "is_private": false}, {"count": 4, "tags": [], "text": "First, here's the companion Spring Framework enhancement request: https://jira.springsource.org/browse/SPR-10788\n\n/I/ don't need to extend WebappClassLoader. I plan on simply adding to the existing WebappClassLoader. Spring Framework extends it because that's the only way to make it work without changing Tomcat directly. The reason any changes are needed at all is because a standard ClassLoader does not just support instrumentation out-of-the-box. You must instrument a class file /as it is being loaded/, before it is initialized/instantiated.\n\nI like the idea of creating registerTransformer() and unregisterTranformer() instead of addTransformer(), but that is a deviation from the unofficial convention that other containers abide by. If Mark is also okay with registerTransformer() and unregisterTranformer(), I'll take that approach.\n\nI'm not exactly sure what getThrowawayClassLoader() is for, either. I have asked some Spring folks to clarify. It exists consistently across containers and Spring container-support classes, so I assume it must be important. We'll see.", "attachment_id": null, "bug_id": 55317, "id": 168852, "time": "2013-07-28T15:15:08Z", "creator": "nicholas@nicholaswilliams.net", "creation_time": "2013-07-28T15:15:08Z", "is_private": false}, {"count": 5, "tags": [], "creator": "jboynes@apache.org", "attachment_id": null, "text": "I have reservations around the security consequences of providing anything that has access to the webapp classloader the ability to modify any code defined by that classloader. \n\nCurrently, that has to be specifically enabled by adding an agent to the JVM or by adding special classloader to the container installation and enabling it in a web application's Context. This change would automatically enable this for all applications. Further, if an application was enabled for cross-context dispatch it would also be able to register a transformer to modify the code of other applications.\n\nSome sort of check seems needed here - for example, that transformers can only transform classes for their own web application where permission has been explicitly granted (perhaps based on ProtectionDomain). I'd think the ProtectionDomain should also be passed to any ClassFileTransformer called.", "id": 168856, "time": "2013-07-28T17:37:08Z", "bug_id": 55317, "creation_time": "2013-07-28T17:37:08Z", "is_private": false}, {"count": 6, "tags": [], "bug_id": 55317, "attachment_id": null, "text": "How does this interact with annotation scanning and ServletContainerInitializers?\n\nFor example, a transformer could add or remove annotations or class dependencies (e.g. adding new interfaces) that related to component scans or types handled by SCIs. Tomcat reads the bytecode directly for this, which would be different to bytecode returned from a transformed class and could result in ambiguous or inconsistent application behaviour.", "id": 168857, "time": "2013-07-28T17:47:22Z", "creator": "jboynes@apache.org", "creation_time": "2013-07-28T17:47:22Z", "is_private": false}, {"count": 7, "tags": [], "bug_id": 55317, "text": "Updated summary to indicate this is more about application driven bytecode weaving rather than Instrumentation (in the way the JRE defines instrumentation).", "id": 168860, "time": "2013-07-28T17:57:30Z", "creator": "jboynes@apache.org", "creation_time": "2013-07-28T17:57:30Z", "is_private": false, "attachment_id": null}, {"count": 8, "tags": [], "text": "To address Jeremy's concerns/questions:\n\n1) I don't see a security issue. JBoss, GlassFish, WebLogic, and WebSphere, for example, all \"automatically enable this for all applications.\" You say, \"Currently, that has to be specifically enabled by adding an agent to the JVM or by adding special classloader to the container installation and enabling it in a web application's Context,\" and I say that's a bad thing. It makes weaving difficult to configure, and sometimes impossible in hosted environments where the consumer doesn't have the ability to jump through these hoops.\n\n2) I took some time to peruse the code on GlassFish, particularly  org.glassfish.web.loader.WebappClassLoader. It performs no special security checks. If someone calls addTransformer, it just lets them add the transformer. That's all. It doesn't use a ProtectionDomain, and it passes null to the transformer's transform method. JBoss also performs no security checks in its code, though it does pass the existing ProtectionDomain to the transformer. It's up to the transformer to use or not use the ProtectionDomain, but apparently it's allowed to be null.\n\n3) If a user enables cross-context dispatch (off by default), they don't do so accidentally (they may do so ignorantly, but that's not our concern). Enabling cross-context dispatch already has its own whole set of security concerns, and I consider the possibilities with this minor compared to those other security concerns.\n\n4) I don't have any particular objection to some sort of Tomcat setting (maybe in catalina.properties?) that disables/disallows transformation, though I strongly believe it should be enabled by default.\n\n5) \"How does this interact with annotation scanning and ServletContainerInitializers?\" All of this scanning happens /before/ any application code is allowed to execute. As such, it happens before any code is capable of adding transformers. Thus, this won't affect such scanning at all. Transformers are only going to want to instrument classes that they use--that won't be SCIs. As far as adding/removing annotations, the creator of a transformer to be used in a web application knows better than to attempt to add or remove annotations that might be scanned for by the container. None of the other containers do anything to anticipate/detect/prevent this bad programming practice, which wouldn't work but also wouldn't hurt anything.\n\nNow, to address what Rainer was saying about getThrowawayClassLoader(). After reading some GlassFish and JBoss source code, I've figured out what it's for. Code that adds transformers to a ClassLoader may need to initially load a class to determine whether it requires transformation (for example, Spring looks for classes annotated @Configurable and only adds a transformer for them if it finds a class annotated @Configurable). GlassFish implements this with a copy() method that simply returns a new UrlClassLoader with the same URL and parent class loader as the WebappClassLoader.", "is_private": false, "bug_id": 55317, "id": 168861, "time": "2013-07-28T18:52:19Z", "creator": "nicholas@nicholaswilliams.net", "creation_time": "2013-07-28T18:52:19Z", "attachment_id": null}, {"count": 9, "tags": [], "text": "I've received some guidance from the folks over at SpringSource (https://jira.springsource.org/browse/SPR-10788) and I'd like to get started on a patch for this now. However, I've yet to hear from Mark whether he has a preference for adding a single addTransformer() method as I had originally suggested or adding registerTransformer() and unregisterTranformer() methods as Rainer suggested (or, a third alternative, addTransformer() and removeTransformer()).\n\nMark, what do you think? If you don't have a preference, I'll probably go Rainer's route but with addTransformer() and removeTransformer() as it's more flexible but also uses a convention (addTransformer()) that other containers use.\n\nThoughts?", "attachment_id": null, "id": 169074, "creator": "nicholas@nicholaswilliams.net", "time": "2013-08-03T16:35:22Z", "bug_id": 55317, "creation_time": "2013-08-03T16:35:22Z", "is_private": false}, {"count": 10, "tags": [], "text": "(In reply to Nick Williams from comment #9)\n\n> Mark, what do you think?\n\nMy primary concern has already been articulated in comment #1.\n\n> If you don't have a preference, I'll probably go\n> Rainer's route but with addTransformer() and removeTransformer() as it's\n> more flexible but also uses a convention (addTransformer()) that other\n> containers use.\n\nI have a very small preference for addTransformer() and removeTransformer() but I'm happy to defer to the preferences of the Spring folks.\n\nMark", "attachment_id": null, "bug_id": 55317, "id": 169133, "time": "2013-08-05T14:27:46Z", "creator": "markt@apache.org", "creation_time": "2013-08-05T14:27:46Z", "is_private": false}, {"count": 11, "tags": [], "creator": "nicholas@nicholaswilliams.net", "attachment_id": null, "text": "Okeydokey. addTransformer() and removeTransformer() is my preference and also what's easiest on the Spring folks (it will require no code change on their part to work), so that's the direction we'll go.", "id": 169141, "time": "2013-08-05T17:42:07Z", "bug_id": 55317, "creation_time": "2013-08-05T17:42:07Z", "is_private": false}, {"count": 12, "tags": [], "text": "I noticed WebappClassLoader's toString() method includes a lot of information about the ClassLoader, such as the parent ClassLoader, context name, delegation setting, and repository. Should I also change toString() to append information about any attached transformers?", "attachment_id": null, "bug_id": 55317, "id": 169146, "time": "2013-08-05T18:08:03Z", "creator": "nicholas@nicholaswilliams.net", "creation_time": "2013-08-05T18:08:03Z", "is_private": false}, {"count": 13, "tags": [], "creator": "jboynes@apache.org", "attachment_id": 30678, "text": "Created attachment 30678\nProposal for transformer registration API\n\n(In reply to Nick Williams from comment #11)\n> Okeydokey. addTransformer() and removeTransformer() is my preference and\n> also what's easiest on the Spring folks (it will require no code change on\n> their part to work), so that's the direction we'll go.\n\nI'd suggest adding these in a separate interface for just this functionality so that applications don't need to depend on the actual implementation. The Tomcat API package (org.apache.tomcat) might be a good location.", "id": 169166, "time": "2013-08-06T06:08:19Z", "bug_id": 55317, "creation_time": "2013-08-06T06:08:19Z", "is_private": false}, {"count": 14, "tags": [], "bug_id": 55317, "text": "Created attachment 30748\nProposed implementation of this feature\n\nI have attached a patch with the implementation complete. In addition to 10 thorough unit tests, my functional testing with Spring Framework indicates that it works great.\n\nThe only remaining question I have, which may require a slight tweak, is regarding memory leaks. I can't figure out whether transformers added to the WebappClassLoader (which will come from application classes) constitute a potential memory leak. It seems to me that the WebappClassLoader instance is cleaned up when the application is shut down, so it shouldn't be a problem. But I wanted to get someone's opinion on whether the WebappClassLoader should clear out the contents of the \"transformers\" LinkedList when it shuts down. I'm not convinced it's necessary, so I left it out for now.", "id": 169650, "time": "2013-08-21T23:15:45Z", "creator": "nicholas@nicholaswilliams.net", "creation_time": "2013-08-21T23:15:45Z", "is_private": false, "attachment_id": 30748}, {"count": 15, "tags": [], "bug_id": 55317, "attachment_id": 30749, "id": 169651, "time": "2013-08-21T23:21:04Z", "creator": "nicholas@nicholaswilliams.net", "creation_time": "2013-08-21T23:21:04Z", "is_private": false, "text": "Created attachment 30749\nProposed implementation of this feature\n\nThere was an error in my previous patch. Please disregard and accept this one instead."}, {"count": 16, "tags": [], "creator": "markt@apache.org", "text": "(In reply to Nick Williams from comment #15)\n> Created attachment 30749 [details]\n> Proposed implementation of this feature\n\n1. Why loop over list rather than using contains() in addTransformer() ?\n\n2. Should addTransformer() be looking for multiple instances of the same Transformer or multiple instances of the same class of Transformer?\n\n3. Why not use List.remove(Object) in removeTransformer() ?\n\n4. I'm concerned that synchronizing on the list of transformers while classes are transformed will become a bottleneck when lots of classes are being loaded and the transformer is relatively slow. A separate ReadWriteLock for the transformer list is probably the way to go but really some testing is required to determine if there is an issue here or not.\n\n5. I'm not a fan of the org.apache.tomcat.unittest package unless the classes concerned are going to be used by multiple tests across multiple packages.", "id": 169794, "attachment_id": null, "bug_id": 55317, "creation_time": "2013-08-29T09:28:17Z", "time": "2013-08-29T09:28:17Z", "is_private": false}, {"count": 17, "tags": [], "bug_id": 55317, "text": "Created attachment 30825\nProposed implementation of this feature\n\n(In reply to Mark Thomas from comment #16)\n> 1. Why loop over list rather than using contains() in addTransformer() ?\n>  \n> 3. Why not use List.remove(Object) in removeTransformer() ?\n\nThat was my own mistake. I didn't read the Javadoc properly. I have corrected this in the attached revised patch.\n\n> 4. I'm concerned that synchronizing on the list of transformers while classes are transformed will become a bottleneck when lots of classes are being loaded and the transformer is relatively slow. A separate ReadWriteLock for the transformer list is probably the way to go but really some testing is required to determine if there is an issue here or not.\n\nAnother mistake of mine. This could DEFINITELY be a problem if multiple threads are loading classes at the same time. A ReadWriteLock is definitely preferable over synchronization here. I have corrected this in the attached revised patch.\n\n> 5. I'm not a fan of the org.apache.tomcat.unittest package unless the classes concerned are going to be used by multiple tests across multiple packages.\n\nUnderstood. I have relocated/renamed these two classes in accordance with the discussion on the mailing list. The changes are in the attached revised patch.\n\n> 2. Should addTransformer() be looking for multiple instances of the same Transformer or multiple instances of the same class of Transformer?\n\nNo, this was correct. It could be valid to have multiple instances of the same transformer class, but not multiple copies of the same instance.\n\nAn example use case is an application using JPA with Spring Framework. JPA abstracts away from the java.lang.instrument.ClassFileTransformer by specifying a javax.persistence.spi.ClassTransformer. JPA providers add ClassTransformers to the persistence unit instead of ClassFileTransformers. Applying this directly would require the ClassLoader to support javax.persistence.spi.ClassTransformer, which won't work in many cases (such as Tomcat). To get around this, Spring Framework uses a org.springframework.orm.jpa.persistenceunit.ClassFileTransformerAdapter to wrap a ClassTransformer with a ClassFileTransformer. If a provider adds multiple ClassTransformer implementations to the persistence unit, Spring will in turn add multiple ClassFileTransformerAdapter instances to the ClassLoader. All of these instances will do something different, but they will be of the same class as far as WebappClassLoader can tell.", "id": 170074, "time": "2013-09-12T19:30:44Z", "creator": "nicholas@nicholaswilliams.net", "creation_time": "2013-09-12T19:30:44Z", "is_private": false, "attachment_id": 30825}, {"count": 18, "tags": [], "bug_id": 55317, "attachment_id": null, "id": 170094, "time": "2013-09-13T15:11:29Z", "creator": "jboynes@apache.org", "creation_time": "2013-09-13T15:11:29Z", "is_private": false, "text": "1) CopyOnWriteArrayList would simplify managing added transformers and is intended for this use-case.\n\n2) I would not try to de-dupe the list at all. There's no contract around equals() for transformers and this will be different from how JRE's Instrumentation manages them.\n\n3) You're applying the transformers in findResourceInternal() which, I think, means getResource() will return transformed data. The transform should be moved into findClass() so only defined classes are transformed.\n\n4) In the messages, we typically wrap [] around the substituted values i.e. [{0}]"}, {"count": 19, "tags": [], "bug_id": 55317, "text": "(In reply to Jeremy Boynes from comment #18)\n> 1) CopyOnWriteArrayList would simplify managing added transformers and is\n> intended for this use-case.\n\nHow have I never heard of this class before? Certainly, mutation operations will definitely vastly outnumber traversal operations. Perhaps CopyOnWriteArrayList is the way to go here, instead of any locking. Mark? Thoughts?\n \n> 2) I would not try to de-dupe the list at all. There's no contract around\n> equals() for transformers and this will be different from how JRE's\n> Instrumentation manages them.\n\nYou're correct, there's no contract for equals in ClassFileTransformer. By default a \"duplicate\" will be if the transformers are the exact same instance (==). Only if the person who implemented the transformer overrides Object#equals will a different behavior occur. Arguably, if the person overrides Object#equals, they likely did so to specify a different definition of \"duplicate.\" I disagree that we shouldn't try to keep duplicates out of the list. I /would/ be open to saying that we should specifically look for duplicate instances (==) and not rely on Object#equals, in which case we need to go back to iterating over the list instead of using List#contains.\n\n> 3) You're applying the transformers in findResourceInternal() which, I\n> think, means getResource() will return transformed data. The transform\n> should be moved into findClass() so only defined classes are transformed.\n\n#findResourceInternal definitely feels like the right place for this. Re: \"so only defined classes are transformed,\" how I've written it means only classes are transformed because the transformers are only applied if isClassResource is true. I don't see a problem here, but maybe I don't understand what you're saying.\n\n> 4) In the messages, we typically wrap [] around the substituted values i.e.\n> [{0}]\n\nI would challenge \"typically\". Looks like about 50% of the time to me. If I'm being told that only [{0}] is right, I'll change it. But there is /plenty/ of code that isn't \"correct\" if this is the case. How are contributors to know which to use? They can't.", "id": 170095, "time": "2013-09-13T15:27:36Z", "creator": "nicholas@nicholaswilliams.net", "creation_time": "2013-09-13T15:27:36Z", "is_private": false, "attachment_id": null}, {"count": 20, "tags": [], "creator": "markt@apache.org", "text": "(In reply to Nick Williams from comment #19)\n> (In reply to Jeremy Boynes from comment #18)\n> > 1) CopyOnWriteArrayList would simplify managing added transformers and is\n> > intended for this use-case.\n> \n> How have I never heard of this class before? Certainly, mutation operations\n> will definitely vastly outnumber traversal operations. Perhaps\n> CopyOnWriteArrayList is the way to go here, instead of any locking. Mark?\n> Thoughts?\n\nAs long as the solution is reasonable and meets the requirements there won't be any objection from me. I can't speak for any other committer.\n\n> > 4) In the messages, we typically wrap [] around the substituted values i.e.\n> > [{0}]\n> \n> I would challenge \"typically\". Looks like about 50% of the time to me. If\n> I'm being told that only [{0}] is right, I'll change it. But there is\n> /plenty/ of code that isn't \"correct\" if this is the case. How are\n> contributors to know which to use? They can't.\n\nAll new code uses [{0}] for clarity on what exactly the value is (makes it easier to spot empty values and unexpected white space). We are fixing older values slowly over time.\n\nMark", "id": 170096, "attachment_id": null, "bug_id": 55317, "creation_time": "2013-09-13T17:20:59Z", "time": "2013-09-13T17:20:59Z", "is_private": false}, {"count": 21, "tags": [], "bug_id": 55317, "is_private": false, "id": 170100, "attachment_id": 30838, "creator": "nicholas@nicholaswilliams.net", "creation_time": "2013-09-14T02:30:12Z", "time": "2013-09-14T02:30:12Z", "text": "Created attachment 30838\nProposed implementation of this feature\n\nRevised patch again. Switched to using CopyOnWriteArrayList, which should be much faster than synchronization or a ReadWriteLock to protect from concurrency issues. Wrapped [] around substitution values. Fixed mergability issues due to changes to WebappClassLoader in last couple of days.\n\nI think this is very close. Juergen has been at SpringOne all week, but he should be home in the next day or two. Hopefully he can look at this soon now that things are less stressful over there. I'd like to get all the issues settled on the Tomcat side so that, once Juergen gives it the thumbs up, it can be committed ASAP. I'd really love to get this in 8.0.RC2 and 7.0.44, if at all possible."}, {"count": 22, "tags": [], "bug_id": 55317, "text": "The patch looks fine to me. Would be great to merge it into Tomcat proper as soon as possible.\n\nFortunately, since we're reflectively discovering those methods, we don't need to wait for Tomcat binaries to get Spring's part done: Based on the conventions in the patch, we'll adapt our discovery mechanism for Spring Framework 4.0 RC1, due on Oct 15th. Of course, it would be great if a corresponding Tomcat 8 release wasn't far beyond that...\n\nJuergen", "id": 170295, "time": "2013-09-26T19:05:28Z", "creator": "jhoeller@gopivotal.com", "creation_time": "2013-09-26T19:05:28Z", "is_private": false, "attachment_id": null}, {"count": 23, "tags": [], "creator": "markt@apache.org", "text": "The patch has been applied with a few minor tweaks to fix the various warnings Eclipse threw up. It will be included in 8.0.0-RC4 onwards. I anticipate the next 8.0.0-RCx release around (maybe even before) the Spring 4 RC1 release.", "id": 170298, "time": "2013-09-26T22:57:01Z", "bug_id": 55317, "creation_time": "2013-09-26T22:57:01Z", "is_private": false, "attachment_id": null}, {"count": 24, "tags": [], "creator": "nicholas@nicholaswilliams.net", "attachment_id": null, "text": "Excellent. Thanks! Two things:\n\n1) InstrumentableClassLoader, as committed, says \"@since 8.0, 7.0.44.\" At the time I submitted my most recent patch, 7.0.44 was \"next.\" As you know, due to several recent vote cancellations, 7.0.44 was actually never released. At the very least, it should say \"@since 8.0, 7.0.44.\" Which brings me to point 2...\n\n2) CAN this be included in 7.0.46? I'd like it to be. It will be some time before 8.0 obtains widespread adoption, and I don't see this as a breaking change, so I believe it would be beneficial to include it in 7.0.46. If it can't be in 7.0, then InstrumentableClassLoader just needs to be changed to say \"@since 8.0.\"", "id": 170299, "time": "2013-09-26T23:15:50Z", "bug_id": 55317, "creation_time": "2013-09-26T23:15:50Z", "is_private": false}, {"count": 25, "tags": [], "bug_id": 55317, "text": "*** At the very least, it should say \"@since 8.0, 7.0.46.\"", "id": 170300, "time": "2013-09-26T23:16:34Z", "creator": "nicholas@nicholaswilliams.net", "creation_time": "2013-09-26T23:16:34Z", "is_private": false, "attachment_id": null}, {"count": 26, "tags": [], "text": "The feature is backported to 7.0.x for 7.0.64 onwards.", "attachment_id": null, "id": 184054, "creator": "violetagg@apache.org", "time": "2015-07-17T08:02:02Z", "bug_id": 55317, "creation_time": "2015-07-17T08:02:02Z", "is_private": false}]