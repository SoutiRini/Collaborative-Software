[{"count": 0, "tags": [], "creator": "jeffwu75@gmail.com", "attachment_id": null, "text": "/**\n * Run all registered child cleanups, in preparation for an exec()\n * call in a forked child -- close files, etc., but *don't* flush I/O\n * buffers, *don't* wait for subprocesses, and *don't* free any\n * memory.\n */\nAPR_DECLARE(void) apr_pool_cleanup_for_exec(void);\n\nHere is my simple test code to show this issue. After running this code,\n/tmp/testfile will be 30 bytes instead of 20 bytes.\n\n#include <apr_general.h>\n#include <apr_thread_proc.h>\n#include <unistd.h>\n#include <stdlib.h>\n\nint main(void)\n{\n    apr_size_t length, written;\n\n    apr_pool_t *pool;\n    apr_file_t *file;\n    char *buf = \"0123456789\";\n\n    apr_app_initialize(NULL,NULL,NULL);\n    apr_pool_create(&pool, NULL);\n    \n    //system(\"rm -f /tmp/testfile\");\n\n    apr_file_open(&file, \"/tmp/testfile\",\n                    APR_CREATE | APR_WRITE | APR_BINARY |\n                    APR_BUFFERED | APR_EXCL, \n\t\t    APR_OS_DEFAULT, pool);\n    length = 10;\n    apr_file_write_full(file, buf, length, &written);\n\n    apr_proc_t *child;\n    apr_procattr_t *child_attr;\n    child = (apr_proc_t *)apr_pcalloc(pool, sizeof(*child));\n    apr_procattr_create(&child_attr, pool);\n    \n    char *args[] = {\"/bin/ls\", NULL};\n    apr_proc_create(child, \"/bin/ls\", args, NULL, child_attr, pool);\n\n    //sleep(5);\n    length = 10;\n    apr_file_write_full(file, buf, length, &written);\n    apr_file_close(file);\n\n    apr_pool_destroy(pool);\n    pool = NULL;\n    apr_terminate();\n\n    return 0;\n}", "id": 96575, "time": "2006-12-06T11:45:58Z", "bug_id": 41119, "creation_time": "2006-12-06T11:45:58Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 41119, "is_private": false, "text": "In summary, what the reporter is trying to say is that the cleanup after\nfork before exec should be dumping all I/O that persists in the parent\nprocess and will be flushed by the parent in due course.", "id": 101832, "time": "2007-04-17T17:49:56Z", "creator": "wrowe@apache.org", "creation_time": "2007-04-17T17:49:56Z", "attachment_id": null}, {"attachment_id": null, "tags": [], "creator": "bojan@rexursive.com", "text": "Yes, I can confirm this. This is what the _child_ process does:\n\n------------------------------------------\n(gdb) bt\n#0  apr_unix_file_cleanup (thefile=0x8aa40d8) at file_io/unix/open.c:32\n#1  0x009910ee in run_child_cleanups (cref=0x8aa40b0)\n    at memory/unix/apr_pools.c:2090\n#2  0x00991112 in cleanup_pool_for_exec (p=0x8aa40a0)\n    at memory/unix/apr_pools.c:2097\n#3  0x00991128 in cleanup_pool_for_exec (p=0x8aa40a0)\n    at memory/unix/apr_pools.c:2100\n#4  0x00991159 in apr_pool_cleanup_for_exec () at memory/unix/apr_pools.c:2115\n#5  0x0099cf43 in apr_proc_create (new=0x8aa5148, \n    progname=0x8048919 \"/bin/ls\", args=0xbfc7944c, env=0xbfc793ec, \n    attr=0x8aa5158, pool=0x8aa40a0) at threadproc/unix/proc.c:403\n#6  0x080487d1 in main () at test.c:32\n------------------------------------------\n\nWith this in *file:\n\n------------------------------------------\n(gdb) p *file\n$9 = {pool = 0x8aa40a0, filedes = 7, fname = 0x8aa4128 \"/tmp/testfile\", \n  flags = 230, eof_hit = 0, is_pipe = 0, timeout = -1, buffered = 1, \n  blocking = BLK_ON, ungetchar = -1, buffer = 0x8aa4138 \"0123456789\", \n  bufpos = 10, bufsize = 4096, dataRead = 0, direction = 1, filePtr = 0, \n  thlock = 0x0}\n------------------------------------------\n\nThat's what writes the first 10 bytes from the example. Of course, the same 10\nbytes are in the parent's buffer. Later on the parent comes to\napr_unix_file_cleanup() too and flushes out 20 bytes (another 10 were written in\nthe meantime), giving the total of 30.\n\nAs it stands, the cleanup (when it gets called) has no idea if it should flush\nthe stuff out or not.\n\nOne solution may be to create linked list of opened files and put every file in\nit on apr_file_open(). The files would also have to unlinked on\napr_file_close(), of course.\n\nThis list could then be traversed in apr_pool_cleanup_for_exec() and all\nfile->buffered flags could be set to zero before running the actual cleanup.\nThen the buffer wouldn't get flushed. Yeah, pretty corny, I know...", "count": 2, "id": 101835, "time": "2007-04-17T23:15:28Z", "bug_id": 41119, "creation_time": "2007-04-17T23:15:28Z", "is_private": false}, {"count": 3, "tags": [], "creator": "bojan@rexursive.com", "attachment_id": null, "text": "Another solution may be to introduce run_child_cleanups_on_exec() instead of\nrunning regular run_child_cleanups(), where it would be checked if\n(*c->child_cleanup_fn) is in fact apr_unix_file_cleanup() or equivalent (which\nis now private, so it would have to be made \"known\" somehow) and if yes, the\nargument (which is *file) would get its buffered flag zeroed before the cleanup\nis actually called. Hackish...", "id": 101836, "time": "2007-04-17T23:28:11Z", "bug_id": 41119, "creation_time": "2007-04-17T23:28:11Z", "is_private": false}, {"count": 4, "tags": [], "creator": "bojan@rexursive.com", "attachment_id": null, "text": "I did some quick and dirty patches for my second suggestion (against APR trunk)\nand that appears to be fixing issue. Let me know if you want to pursue this and\nI'll try to find out how to do it properly.", "id": 101842, "time": "2007-04-18T00:16:04Z", "bug_id": 41119, "creation_time": "2007-04-18T00:16:04Z", "is_private": false}, {"attachment_id": null, "tags": [], "creator": "jorton@redhat.com", "text": "The comment dates back to Apache 1.3 where cleanups for FILE * were handled\nexactly as stated (and as expected by this reporter).\n\nThe APR file implementation has simply never implemented this guarantee -\nwhether  by intent or not, I don't know.  Changing it should be as simple as\nregistering a different child_cleanup in apr_file_open() - a cleanup which\ndoesn't call flush like apr_unix_file_cleanup().\n\nI've avoided touching this since I think it's vaguely conceivable that an\napplication could rely on the current behaviour, and it would kind of be an\ninterface break.  You can get into a philosophical debate here about whether API\nis defined by random comments in headers or by actual implementation behaviour.", "count": 5, "id": 101872, "time": "2007-04-18T06:32:16Z", "bug_id": 41119, "creation_time": "2007-04-18T06:32:16Z", "is_private": false}, {"attachment_id": null, "tags": [], "creator": "bojan@rexursive.com", "is_private": false, "count": 6, "id": 101901, "time": "2007-04-18T15:51:35Z", "bug_id": 41119, "creation_time": "2007-04-18T15:51:35Z", "text": "> Changing it should be as simple as registering a different child_cleanup in\napr_file_open() - a cleanup which doesn't call flush like apr_unix_file_cleanup().\n\nIf there is only one possible behaviour of the child cleanup here, then that's a\nreally easy fix. I wasn't sure if that would be the case, so I went on inventing\nhackish ways of having two, probably completely unnecessary :-)\n\n> You can get into a philosophical debate here about whether API is defined by\nrandom comments in headers or by actual implementation behaviour.\n\nI would view this from the \"does it make sense\" point of view. At present, the\nexact same piece of data stored in the buffer gets written into the file twice.\nThat seems to be the bit that doesn't make sense to me, so changing the\nbehaviour would be warranted.\n\nBut then again, if we historically didn't do this, we should just change the\ndocumentation and let people know that they _must_ flush all buffered files\nbefore calling apr_proc_create(), or they will suffer from this."}, {"count": 7, "text": "> they _must_ flush all buffered files before calling apr_proc_create()\n\nThis may be a difficult thing to do, of course, especially within software like\nhttpd, where one doesn't control many open files.", "bug_id": 41119, "is_private": false, "id": 101903, "time": "2007-04-18T16:02:22Z", "creator": "bojan@rexursive.com", "creation_time": "2007-04-18T16:02:22Z", "tags": [], "attachment_id": null}, {"count": 8, "tags": [], "bug_id": 41119, "text": "> Changing it should be as simple as registering a different child_cleanup in\napr_file_open() - a cleanup which doesn't call flush like apr_unix_file_cleanup().\n\nActually, we'd probably have to re-implement the APR_IMPLEMENT_INHERIT_SET/UNSET\nmacros as well, in that case. The macros would take two args: regular and child\ncleanup (this would affect sockets code as well, not just file_io) - I don't\nthink this can be done for 1.2.x at all.\n\nHmm, complicated...", "id": 102046, "time": "2007-04-22T23:33:38Z", "creator": "bojan@rexursive.com", "creation_time": "2007-04-22T23:33:38Z", "is_private": false, "attachment_id": null}, {"count": 9, "tags": [], "bug_id": 41119, "text": "Created attachment 20168\nProposed patch", "id": 103069, "time": "2007-05-10T22:50:50Z", "creator": "bojan@rexursive.com", "creation_time": "2007-05-10T22:50:50Z", "is_private": false, "attachment_id": 20168}, {"count": 10, "tags": [], "creator": "davi@apache.org", "attachment_id": 20184, "text": "Created attachment 20184\ndon't flush the file buffer on child cleanup\n\nDoes this fix the issue?", "id": 103124, "time": "2007-05-11T21:57:38Z", "bug_id": 41119, "creation_time": "2007-05-11T21:57:38Z", "is_private": false}, {"attachment_id": null, "tags": [], "creator": "bojan@rexursive.com", "text": "Regarding comment #10, did you take into account\nAPR_IMPLEMENT_INHERIT_SET/UNSET? This can reset you child cleanup back to\napr_unix_file_cleanup. Maybe we should implement those two by hand for Unix\ninstead of using the macro?", "count": 11, "id": 103125, "time": "2007-05-11T22:05:49Z", "bug_id": 41119, "creation_time": "2007-05-11T22:05:49Z", "is_private": false}, {"count": 12, "tags": [], "bug_id": 41119, "text": "Created attachment 20185\nDavi's patch with implementation of _set/unset by hand", "id": 103126, "time": "2007-05-11T22:27:07Z", "creator": "bojan@rexursive.com", "creation_time": "2007-05-11T22:27:07Z", "is_private": false, "attachment_id": 20185}, {"count": 13, "tags": [], "bug_id": 41119, "text": "Created attachment 20186\nDavi's patch with implementation of _unset by hand.", "id": 103127, "time": "2007-05-11T22:34:21Z", "creator": "bojan@rexursive.com", "creation_time": "2007-05-11T22:34:21Z", "is_private": false, "attachment_id": 20186}, {"count": 14, "tags": [], "bug_id": 41119, "text": "Also, there are other places where apr_pool_cleanup_register is called for files\n(grep for apr_unix_file_cleanup),  so those will need to be fixed too.", "id": 103136, "time": "2007-05-12T11:31:10Z", "creator": "davi@apache.org", "creation_time": "2007-05-12T11:31:10Z", "is_private": false, "attachment_id": null}, {"count": 15, "tags": [], "bug_id": 41119, "text": "Which means that child_file_cleanup() will probably have to become\napr_unix_child_file_cleanup() and be made public. I'll prepare a more complete\npatch.", "id": 103142, "time": "2007-05-12T17:20:23Z", "creator": "bojan@rexursive.com", "creation_time": "2007-05-12T17:20:23Z", "is_private": false, "attachment_id": null}, {"count": 16, "text": "Created attachment 20188\nDavi's patch with implementation of _unset by hand and public apr_unix_child_file_cleanup()", "bug_id": 41119, "is_private": false, "id": 103143, "time": "2007-05-12T21:29:47Z", "creator": "bojan@rexursive.com", "creation_time": "2007-05-12T21:29:47Z", "tags": [], "attachment_id": 20188}, {"count": 17, "tags": [], "bug_id": 41119, "text": "Fixed in trunk r538045. Awaiting feedback from other developers.", "id": 103210, "time": "2007-05-14T19:38:02Z", "creator": "bojan@rexursive.com", "creation_time": "2007-05-14T19:38:02Z", "is_private": false, "attachment_id": null}, {"attachment_id": null, "tags": [], "creator": "bojan@rexursive.com", "is_private": false, "count": 18, "id": 103399, "time": "2007-05-20T23:51:34Z", "bug_id": 41119, "creation_time": "2007-05-20T23:51:34Z", "text": "Fixed in 1.2.x in r540039. Fixed in 0.9.x in r540040."}, {"count": 19, "tags": [], "creator": "bnicholes@apache.org", "attachment_id": null, "is_private": false, "id": 103419, "time": "2007-05-21T08:28:52Z", "bug_id": 41119, "creation_time": "2007-05-21T08:28:52Z", "text": "This portion of the patch in file_io/unix/open.c breaks APR 0.9.x because it \nremoves the deprecated function apr_file_unset_inherit().  The deprecated \nfunction needs to be reimplemented as well.\n\n-APR_IMPLEMENT_INHERIT_UNSET(file, flags, pool, apr_unix_file_cleanup)\n+/* We need to do this by hand instead of using APR_IMPLEMENT_INHERIT_UNSET\n+ * because the macro sets both cleanups to the same function, which is not\n+ * suitable on Unix (see PR 41119). */\n+APR_DECLARE(apr_status_t) apr_file_inherit_unset(apr_file_t *thefile)\n+{\n+    if (thefile->flags & APR_FILE_NOCLEANUP) {\n+        return APR_EINVAL;\n+    }\n+    if (thefile->flags & APR_INHERIT) {\n+        thefile->flags &= ~APR_INHERIT;\n+        apr_pool_child_cleanup_set(thefile->pool,\n+                                   (void *)thefile,\n+                                   apr_unix_file_cleanup,\n+                                   apr_unix_child_file_cleanup);\n+    }\n+    return APR_SUCCESS;\n+}\n"}, {"count": 20, "tags": [], "bug_id": 41119, "text": "Regarding comment #19, fixed in r540365.", "id": 103454, "time": "2007-05-21T16:57:29Z", "creator": "bojan@rexursive.com", "creation_time": "2007-05-21T16:57:29Z", "is_private": false, "attachment_id": null}]