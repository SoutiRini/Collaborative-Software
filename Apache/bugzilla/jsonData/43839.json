[{"count": 0, "tags": [], "bug_id": 43839, "is_private": false, "text": "Hello,\nI think the document for context\n\"http://tomcat.apache.org/tomcat-6.0-doc/config/context.html\" describe\nthe configuration item \"cookies\" difference the implement.\nPlease think this case.\n1. In the same computer I start two tomcat, one is linsten 80, other\nlinsten 8080.\n2. The tomcat bind at 80, it set the cookies to true.\n3. The tomcat bind at 8080, it set the cookies to false. It will use the\nURL rewrite to post the jsessionid.\n4. First time I access the 80, it will return the JSESSIONID in cookie.\n5. Don't close the IE, the access with the 8080 without URL rewrite.\nWhat will happen. The tomcat linsten 8080 will use the jsession id of\n80. It very strange.\nSo I modify the source code for file.\n\"apache-tomcat-6.0.14-src\\java\\org\\apache\\catalina\\connector\\CoyoteAdapter.java\".\nChange the code at line 472 from\nparseSessionCookiesId(req, request);\nto\nif (((Context)request.getMappingData().context).getCookies())\nparseSessionCookiesId(req, request);\n\nIf I modify it in wrong way, I want to know how to resoluate the case\nthat I list previous. Please tell me why the praseSessionCookiesId don't\ncare about the configuration item \"cookies\" in \"Context\".\nThanks.\nMars Engle\n\n\n\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\npackage org.apache.catalina.connector;\n\nimport java.io.IOException;\n\nimport org.apache.catalina.CometEvent;\nimport org.apache.catalina.Context;\nimport org.apache.catalina.Globals;\nimport org.apache.catalina.Wrapper;\nimport org.apache.catalina.util.StringManager;\nimport org.apache.coyote.ActionCode;\nimport org.apache.coyote.Adapter;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\nimport org.apache.tomcat.util.buf.B2CConverter;\nimport org.apache.tomcat.util.buf.ByteChunk;\nimport org.apache.tomcat.util.buf.CharChunk;\nimport org.apache.tomcat.util.buf.MessageBytes;\nimport org.apache.tomcat.util.http.Cookies;\nimport org.apache.tomcat.util.http.ServerCookie;\nimport org.apache.tomcat.util.net.SocketStatus;\n\n/**\n * Implementation of a request processor which delegates the processing to a\n * Coyote processor.\n *\n * @author Craig R. McClanahan\n * @author Remy Maucherat\n * @version $Revision: 555304 $ $Date: 2007-07-11 17:28:52 +0200 (mer., 11 juil.\n2007) $\n */\n\npublic class CoyoteAdapter\n    implements Adapter \n {\n    private static Log log = LogFactory.getLog(CoyoteAdapter.class);\n\n    // -------------------------------------------------------------- Constants\n\n\n    public static final int ADAPTER_NOTES = 1;\n\n\n    protected static final boolean ALLOW_BACKSLASH = \n       \nBoolean.valueOf(System.getProperty(\"org.apache.catalina.connector.CoyoteAdapter.ALLOW_BACKSLASH\",\n\"false\")).booleanValue();\n\n\n    // ----------------------------------------------------------- Constructors\n\n\n    /**\n     * Construct a new CoyoteProcessor associated with the specified connector.\n     *\n     * @param connector CoyoteConnector that owns this processor\n     */\n    public CoyoteAdapter(Connector connector) {\n\n        super();\n        this.connector = connector;\n\n    }\n\n\n    // ----------------------------------------------------- Instance Variables\n\n\n    /**\n     * The CoyoteConnector with which this processor is associated.\n     */\n    private Connector connector = null;\n\n\n    /**\n     * The match string for identifying a session ID parameter.\n     */\n    private static final String match =\n        \";\" + Globals.SESSION_PARAMETER_NAME + \"=\";\n\n\n    /**\n     * The string manager for this package.\n     */\n    protected StringManager sm =\n        StringManager.getManager(Constants.Package);\n\n\n    // -------------------------------------------------------- Adapter Methods\n\n    \n    /**\n     * Event method.\n     * \n     * @return false to indicate an error, expected or not\n     */\n    public boolean event(org.apache.coyote.Request req, \n            org.apache.coyote.Response res, SocketStatus status) {\n\n        Request request = (Request) req.getNote(ADAPTER_NOTES);\n        Response response = (Response) res.getNote(ADAPTER_NOTES);\n\n        if (request.getWrapper() != null) {\n            \n            boolean error = false;\n            boolean read = false;\n            try {\n                if (status == SocketStatus.OPEN) {\n                    if (response.isClosed()) {\n                        // The event has been closed asynchronously, so call end\ninstead of\n                        // read to cleanup the pipeline\n                        request.getEvent().setEventType(CometEvent.EventType.END);\n                        request.getEvent().setEventSubType(null);\n                    } else {\n                        try {\n                            // Fill the read buffer of the servlet layer\n                            if (request.read()) {\n                                read = true;\n                            }\n                        } catch (IOException e) {\n                            error = true;\n                        }\n                        if (read) {\n                           \nrequest.getEvent().setEventType(CometEvent.EventType.READ);\n                            request.getEvent().setEventSubType(null);\n                        } else if (error) {\n                           \nrequest.getEvent().setEventType(CometEvent.EventType.ERROR);\n                           \nrequest.getEvent().setEventSubType(CometEvent.EventSubType.CLIENT_DISCONNECT);\n                        } else {\n                           \nrequest.getEvent().setEventType(CometEvent.EventType.END);\n                            request.getEvent().setEventSubType(null);\n                        }\n                    }\n                } else if (status == SocketStatus.DISCONNECT) {\n                    request.getEvent().setEventType(CometEvent.EventType.ERROR);\n                   \nrequest.getEvent().setEventSubType(CometEvent.EventSubType.CLIENT_DISCONNECT);\n                    error = true;\n                } else if (status == SocketStatus.ERROR) {\n                    request.getEvent().setEventType(CometEvent.EventType.ERROR);\n                   \nrequest.getEvent().setEventSubType(CometEvent.EventSubType.IOEXCEPTION);\n                    error = true;\n                } else if (status == SocketStatus.STOP) {\n                    request.getEvent().setEventType(CometEvent.EventType.END);\n                   \nrequest.getEvent().setEventSubType(CometEvent.EventSubType.SERVER_SHUTDOWN);\n                } else if (status == SocketStatus.TIMEOUT) {\n                    if (response.isClosed()) {\n                        // The event has been closed asynchronously, so call end\ninstead of\n                        // read to cleanup the pipeline\n                        request.getEvent().setEventType(CometEvent.EventType.END);\n                        request.getEvent().setEventSubType(null);\n                    } else {\n                        request.getEvent().setEventType(CometEvent.EventType.ERROR);\n                       \nrequest.getEvent().setEventSubType(CometEvent.EventSubType.TIMEOUT);\n                    }\n                }\n\n               \nreq.getRequestProcessor().setWorkerThreadName(Thread.currentThread().getName());\n                \n                // Calling the container\n                connector.getContainer().getPipeline().getFirst().event(request,\nresponse, request.getEvent());\n\n                if (!error && !response.isClosed() &&\n(request.getAttribute(Globals.EXCEPTION_ATTR) != null)) {\n                    // An unexpected exception occurred while processing the\nevent, so\n                    // error should be called\n                    request.getEvent().setEventType(CometEvent.EventType.ERROR);\n                    request.getEvent().setEventSubType(null);\n                    error = true;\n                   \nconnector.getContainer().getPipeline().getFirst().event(request, response,\nrequest.getEvent());\n                }\n                if (response.isClosed() || !request.isComet()) {\n                    res.action(ActionCode.ACTION_COMET_END, null);\n                } else if (!error && read && request.getAvailable()) {\n                    // If this was a read and not all bytes have been read, or\nif no data\n                    // was read from the connector, then it is an error\n                    request.getEvent().setEventType(CometEvent.EventType.ERROR);\n                   \nrequest.getEvent().setEventSubType(CometEvent.EventSubType.IOEXCEPTION);\n                    error = true;\n                   \nconnector.getContainer().getPipeline().getFirst().event(request, response,\nrequest.getEvent());\n                }\n                return (!error);\n            } catch (Throwable t) {\n                if (!(t instanceof IOException)) {\n                    log.error(sm.getString(\"coyoteAdapter.service\"), t);\n                }\n                error = true;\n                return false;\n            } finally {\n                req.getRequestProcessor().setWorkerThreadName(null);\n                // Recycle the wrapper request and response\n                if (error || response.isClosed() || !request.isComet()) {\n                    request.recycle();\n                    request.setFilterChain(null);\n                    response.recycle();\n                }\n            }\n            \n        } else {\n            return false;\n        }\n    }\n    \n\n    /**\n     * Service method.\n     */\n    public void service(org.apache.coyote.Request req, \n    \t                org.apache.coyote.Response res)\n        throws Exception {\n\n        Request request = (Request) req.getNote(ADAPTER_NOTES);\n        Response response = (Response) res.getNote(ADAPTER_NOTES);\n\n        if (request == null) {\n\n            // Create objects\n            request = (Request) connector.createRequest();\n            request.setCoyoteRequest(req);\n            response = (Response) connector.createResponse();\n            response.setCoyoteResponse(res);\n\n            // Link objects\n            request.setResponse(response);\n            response.setRequest(request);\n\n            // Set as notes\n            req.setNote(ADAPTER_NOTES, request);\n            res.setNote(ADAPTER_NOTES, response);\n\n            // Set query string encoding\n            req.getParameters().setQueryStringEncoding\n                (connector.getURIEncoding());\n\n        }\n\n        if (connector.getXpoweredBy()) {\n            response.addHeader(\"X-Powered-By\", \"Servlet/2.5\");\n        }\n\n        boolean comet = false;\n        \n        try {\n\n            // Parse and set Catalina and configuration specific \n            // request parameters\n           \nreq.getRequestProcessor().setWorkerThreadName(Thread.currentThread().getName());\n            if (postParseRequest(req, request, res, response)) {\n                // Calling the container\n               \nconnector.getContainer().getPipeline().getFirst().invoke(request, response);\n\n                if (request.isComet()) {\n                    if (!response.isClosed() && !response.isError()) {\n                        if (request.getAvailable()) {\n                            // Invoke a read event right away if there are\navailable bytes\n                            if (event(req, res, SocketStatus.OPEN)) {\n                                comet = true;\n                                res.action(ActionCode.ACTION_COMET_BEGIN, null);\n                            }\n                        } else {\n                            comet = true;\n                            res.action(ActionCode.ACTION_COMET_BEGIN, null);\n                        }\n                    } else {\n                        // Clear the filter chain, as otherwise it will not be\nreset elsewhere\n                        // since this is a Comet request\n                        request.setFilterChain(null);\n                    }\n                }\n\n            }\n\n            if (!comet) {\n                response.finishResponse();\n                req.action(ActionCode.ACTION_POST_REQUEST , null);\n            }\n\n        } catch (IOException e) {\n            ;\n        } catch (Throwable t) {\n            log.error(sm.getString(\"coyoteAdapter.service\"), t);\n        } finally {\n            req.getRequestProcessor().setWorkerThreadName(null);\n            // Recycle the wrapper request and response\n            if (!comet) {\n                request.recycle();\n                response.recycle();\n            } else {\n                // Clear converters so that the minimum amount of memory \n                // is used by this processor\n                request.clearEncoders();\n                response.clearEncoders();\n            }\n        }\n\n    }\n\n\n    // ------------------------------------------------------ Protected Methods\n\n\n    /**\n     * Parse additional request parameters.\n     */\n    protected boolean postParseRequest(org.apache.coyote.Request req, \n                                       Request request,\n    \t\t                       org.apache.coyote.Response res, \n                                       Response response)\n            throws Exception {\n\n        // XXX the processor needs to set a correct scheme and port prior to\nthis point, \n        // in ajp13 protocols dont make sense to get the port from the connector..\n        // XXX the processor may have set a correct scheme and port prior to\nthis point, \n        // in ajp13 protocols dont make sense to get the port from the connector...\n        // otherwise, use connector configuration\n        if (! req.scheme().isNull()) {\n            // use processor specified scheme to determine secure state\n            request.setSecure(req.scheme().equals(\"https\"));\n        } else {\n            // use connector scheme and secure configuration, (defaults to\n            // \"http\" and false respectively)\n            req.scheme().setString(connector.getScheme());\n            request.setSecure(connector.getSecure());\n        }\n\n        // FIXME: the code below doesnt belongs to here, \n        // this is only have sense \n        // in Http11, not in ajp13..\n        // At this point the Host header has been processed.\n        // Override if the proxyPort/proxyHost are set \n        String proxyName = connector.getProxyName();\n        int proxyPort = connector.getProxyPort();\n        if (proxyPort != 0) {\n            req.setServerPort(proxyPort);\n        }\n        if (proxyName != null) {\n            req.serverName().setString(proxyName);\n        }\n\n        // Parse session Id\n        parseSessionId(req, request);\n\n        // URI decoding\n        MessageBytes decodedURI = req.decodedURI();\n        decodedURI.duplicate(req.requestURI());\n\n        if (decodedURI.getType() == MessageBytes.T_BYTES) {\n            // Remove any path parameters\n            ByteChunk uriBB = decodedURI.getByteChunk();\n            int semicolon = uriBB.indexOf(';', 0);\n            if (semicolon > 0) {\n                decodedURI.setBytes\n                    (uriBB.getBuffer(), uriBB.getStart(), semicolon);\n            }\n            // %xx decoding of the URL\n            try {\n                req.getURLDecoder().convert(decodedURI, false);\n            } catch (IOException ioe) {\n                res.setStatus(400);\n                res.setMessage(\"Invalid URI: \" + ioe.getMessage());\n                return false;\n            }\n            // Normalization\n            if (!normalize(req.decodedURI())) {\n                res.setStatus(400);\n                res.setMessage(\"Invalid URI\");\n                return false;\n            }\n            // Character decoding\n            convertURI(decodedURI, request);\n        } else {\n            // The URL is chars or String, and has been sent using an in-memory\n            // protocol handler, we have to assume the URL has been properly\n            // decoded already\n            decodedURI.toChars();\n            // Remove any path parameters\n            CharChunk uriCC = decodedURI.getCharChunk();\n            int semicolon = uriCC.indexOf(';');\n            if (semicolon > 0) {\n                decodedURI.setChars\n                    (uriCC.getBuffer(), uriCC.getStart(), semicolon);\n            }\n        }\n\n        // Set the remote principal\n        String principal = req.getRemoteUser().toString();\n        if (principal != null) {\n            request.setUserPrincipal(new CoyotePrincipal(principal));\n        }\n\n        // Set the authorization type\n        String authtype = req.getAuthType().toString();\n        if (authtype != null) {\n            request.setAuthType(authtype);\n        }\n\n        // Request mapping.\n        MessageBytes serverName;\n        if (connector.getUseIPVHosts()) {\n            serverName = req.localName();\n            if (serverName.isNull()) {\n                // well, they did ask for it\n                res.action(ActionCode.ACTION_REQ_LOCAL_NAME_ATTRIBUTE, null);\n            }\n        } else {\n            serverName = req.serverName();\n        }\n        connector.getMapper().map(serverName, decodedURI, \n                                  request.getMappingData());\n        request.setContext((Context) request.getMappingData().context);\n        request.setWrapper((Wrapper) request.getMappingData().wrapper);\n\n        // Filter trace method\n        if (!connector.getAllowTrace() \n                && req.method().equalsIgnoreCase(\"TRACE\")) {\n            Wrapper wrapper = request.getWrapper();\n            String header = null;\n            if (wrapper != null) {\n                String[] methods = wrapper.getServletMethods();\n                if (methods != null) {\n                    for (int i=0; i<methods.length; i++) {\n                        if (\"TRACE\".equals(methods[i])) {\n                            continue;\n                        }\n                        if (header == null) {\n                            header = methods[i];\n                        } else {\n                            header += \", \" + methods[i];\n                        }\n                    }\n                }\n            }                               \n            res.setStatus(405);\n            res.addHeader(\"Allow\", header);\n            res.setMessage(\"TRACE method is not allowed\");\n            return false;\n        }\n\n        // Possible redirect\n        MessageBytes redirectPathMB = request.getMappingData().redirectPath;\n        if (!redirectPathMB.isNull()) {\n            String redirectPath = redirectPathMB.toString();\n            String query = request.getQueryString();\n            if (request.isRequestedSessionIdFromURL()) {\n                // This is not optimal, but as this is not very common, it\n                // shouldn't matter\n                redirectPath = redirectPath + \";\" +\nGlobals.SESSION_PARAMETER_NAME + \"=\" \n                    + request.getRequestedSessionId();\n            }\n            if (query != null) {\n                // This is not optimal, but as this is not very common, it\n                // shouldn't matter\n                redirectPath = redirectPath + \"?\" + query;\n            }\n            response.sendRedirect(redirectPath);\n            return false;\n        }\n\n        // Parse session Id\n        if (((Context)request.getMappingData().context).getCookies())\n       \t    parseSessionCookiesId(req, request);\n\n        return true;\n    }\n\n\n    /**\n     * Parse session id in URL.\n     */\n    protected void parseSessionId(org.apache.coyote.Request req, Request request) {\n\n        ByteChunk uriBC = req.requestURI().getByteChunk();\n        int semicolon = uriBC.indexOf(match, 0, match.length(), 0);\n\n        if (semicolon > 0) {\n\n            // Parse session ID, and extract it from the decoded request URI\n            int start = uriBC.getStart();\n            int end = uriBC.getEnd();\n\n            int sessionIdStart = semicolon + match.length();\n            int semicolon2 = uriBC.indexOf(';', sessionIdStart);\n            if (semicolon2 >= 0) {\n                request.setRequestedSessionId\n                    (new String(uriBC.getBuffer(), start + sessionIdStart, \n                            semicolon2 - sessionIdStart));\n                // Extract session ID from request URI\n                byte[] buf = uriBC.getBuffer();\n                for (int i = 0; i < end - start - semicolon2; i++) {\n                    buf[start + semicolon + i] \n                        = buf[start + i + semicolon2];\n                }\n                uriBC.setBytes(buf, start, end - start - semicolon2 + semicolon);\n            } else {\n                request.setRequestedSessionId\n                    (new String(uriBC.getBuffer(), start + sessionIdStart, \n                            (end - start) - sessionIdStart));\n                uriBC.setEnd(start + semicolon);\n            }\n            request.setRequestedSessionURL(true);\n\n        } else {\n            request.setRequestedSessionId(null);\n            request.setRequestedSessionURL(false);\n        }\n\n    }\n\n\n    /**\n     * Parse session id in URL.\n     */\n    protected void parseSessionCookiesId(org.apache.coyote.Request req, Request\nrequest) {\n\n        // Parse session id from cookies\n        Cookies serverCookies = req.getCookies();\n        int count = serverCookies.getCookieCount();\n        if (count <= 0)\n            return;\n\n        for (int i = 0; i < count; i++) {\n            ServerCookie scookie = serverCookies.getCookie(i);\n            if (scookie.getName().equals(Globals.SESSION_COOKIE_NAME)) {\n                // Override anything requested in the URL\n                if (!request.isRequestedSessionIdFromCookie()) {\n                    // Accept only the first session id cookie\n                    convertMB(scookie.getValue());\n                    request.setRequestedSessionId\n                        (scookie.getValue().toString());\n                    request.setRequestedSessionCookie(true);\n                    request.setRequestedSessionURL(false);\n                    if (log.isDebugEnabled())\n                        log.debug(\" Requested cookie session id is \" +\n                            request.getRequestedSessionId());\n                } else {\n                    if (!request.isRequestedSessionIdValid()) {\n                        // Replace the session id until one is valid\n                        convertMB(scookie.getValue());\n                        request.setRequestedSessionId\n                            (scookie.getValue().toString());\n                    }\n                }\n            }\n        }\n\n    }\n\n\n    /**\n     * Character conversion of the URI.\n     */\n    protected void convertURI(MessageBytes uri, Request request) \n        throws Exception {\n\n        ByteChunk bc = uri.getByteChunk();\n        int length = bc.getLength();\n        CharChunk cc = uri.getCharChunk();\n        cc.allocate(length, -1);\n\n        String enc = connector.getURIEncoding();\n        if (enc != null) {\n            B2CConverter conv = request.getURIConverter();\n            try {\n                if (conv == null) {\n                    conv = new B2CConverter(enc);\n                    request.setURIConverter(conv);\n                } else {\n                    conv.recycle();\n                }\n            } catch (IOException e) {\n                // Ignore\n                log.error(\"Invalid URI encoding; using HTTP default\");\n                connector.setURIEncoding(null);\n            }\n            if (conv != null) {\n                try {\n                    conv.convert(bc, cc);\n                    uri.setChars(cc.getBuffer(), cc.getStart(), \n                                 cc.getLength());\n                    return;\n                } catch (IOException e) {\n                    log.error(\"Invalid URI character encoding; trying ascii\");\n                    cc.recycle();\n                }\n            }\n        }\n\n        // Default encoding: fast conversion\n        byte[] bbuf = bc.getBuffer();\n        char[] cbuf = cc.getBuffer();\n        int start = bc.getStart();\n        for (int i = 0; i < length; i++) {\n            cbuf[i] = (char) (bbuf[i + start] & 0xff);\n        }\n        uri.setChars(cbuf, 0, length);\n\n    }\n\n\n    /**\n     * Character conversion of the a US-ASCII MessageBytes.\n     */\n    protected void convertMB(MessageBytes mb) {\n\n        // This is of course only meaningful for bytes\n        if (mb.getType() != MessageBytes.T_BYTES)\n            return;\n        \n        ByteChunk bc = mb.getByteChunk();\n        CharChunk cc = mb.getCharChunk();\n        int length = bc.getLength();\n        cc.allocate(length, -1);\n\n        // Default encoding: fast conversion\n        byte[] bbuf = bc.getBuffer();\n        char[] cbuf = cc.getBuffer();\n        int start = bc.getStart();\n        for (int i = 0; i < length; i++) {\n            cbuf[i] = (char) (bbuf[i + start] & 0xff);\n        }\n        mb.setChars(cbuf, 0, length);\n\n    }\n\n\n    /**\n     * Normalize URI.\n     * <p>\n     * This method normalizes \"\\\", \"//\", \"/./\" and \"/../\". This method will\n     * return false when trying to go above the root, or if the URI contains\n     * a null byte.\n     * \n     * @param uriMB URI to be normalized\n     */\n    public static boolean normalize(MessageBytes uriMB) {\n\n        ByteChunk uriBC = uriMB.getByteChunk();\n        byte[] b = uriBC.getBytes();\n        int start = uriBC.getStart();\n        int end = uriBC.getEnd();\n\n        // URL * is acceptable\n        if ((end - start == 1) && b[start] == (byte) '*')\n          return true;\n\n        int pos = 0;\n        int index = 0;\n\n        // Replace '\\' with '/'\n        // Check for null byte\n        for (pos = start; pos < end; pos++) {\n            if (b[pos] == (byte) '\\\\') {\n                if (ALLOW_BACKSLASH) {\n                    b[pos] = (byte) '/';\n                } else {\n                    return false;\n                }\n            }\n            if (b[pos] == (byte) 0) {\n                return false;\n            }\n        }\n\n        // The URL must start with '/'\n        if (b[start] != (byte) '/') {\n            return false;\n        }\n\n        // Replace \"//\" with \"/\"\n        for (pos = start; pos < (end - 1); pos++) {\n            if (b[pos] == (byte) '/') {\n                while ((pos + 1 < end) && (b[pos + 1] == (byte) '/')) {\n                    copyBytes(b, pos, pos + 1, end - pos - 1);\n                    end--;\n                }\n            }\n        }\n\n        // If the URI ends with \"/.\" or \"/..\", then we append an extra \"/\"\n        // Note: It is possible to extend the URI by 1 without any side effect\n        // as the next character is a non-significant WS.\n        if (((end - start) >= 2) && (b[end - 1] == (byte) '.')) {\n            if ((b[end - 2] == (byte) '/') \n                || ((b[end - 2] == (byte) '.') \n                    && (b[end - 3] == (byte) '/'))) {\n                b[end] = (byte) '/';\n                end++;\n            }\n        }\n\n        uriBC.setEnd(end);\n\n        index = 0;\n\n        // Resolve occurrences of \"/./\" in the normalized path\n        while (true) {\n            index = uriBC.indexOf(\"/./\", 0, 3, index);\n            if (index < 0)\n                break;\n            copyBytes(b, start + index, start + index + 2, \n                      end - start - index - 2);\n            end = end - 2;\n            uriBC.setEnd(end);\n        }\n\n        index = 0;\n\n        // Resolve occurrences of \"/../\" in the normalized path\n        while (true) {\n            index = uriBC.indexOf(\"/../\", 0, 4, index);\n            if (index < 0)\n                break;\n            // Prevent from going outside our context\n            if (index == 0)\n                return false;\n            int index2 = -1;\n            for (pos = start + index - 1; (pos >= 0) && (index2 < 0); pos --) {\n                if (b[pos] == (byte) '/') {\n                    index2 = pos;\n                }\n            }\n            copyBytes(b, start + index2, start + index + 3,\n                      end - start - index - 3);\n            end = end + index2 - index - 3;\n            uriBC.setEnd(end);\n            index = index2;\n        }\n\n        uriBC.setBytes(b, start, end);\n\n        return true;\n\n    }\n\n\n    // ------------------------------------------------------ Protected Methods\n\n\n    /**\n     * Copy an array of bytes to a different position. Used during \n     * normalization.\n     */\n    protected static void copyBytes(byte[] b, int dest, int src, int len) {\n        for (int pos = 0; pos < len; pos++) {\n            b[pos + dest] = b[pos + src];\n        }\n    }\n\n\n}", "id": 110412, "time": "2007-11-11T19:35:39Z", "creator": "engle_mars@yahoo.com.cn", "creation_time": "2007-11-11T19:35:39Z", "attachment_id": null}, {"count": 1, "tags": [], "creator": "a@gaydenko.com", "is_private": false, "id": 111610, "attachment_id": null, "bug_id": 43839, "creation_time": "2007-12-10T10:01:41Z", "time": "2007-12-10T10:01:41Z", "text": "Whit v.5.5.x the issue takes place also. Surprisingly long-standing game :-)\nWill somebody from development team be so kind to rise the issue severity? Thanks!"}, {"attachment_id": null, "tags": [], "creator": "markt@apache.org", "text": "Yes, this is a bug. Looking for the cookie when cookies are disabled means that\nthe session ID from the cookie is taken as the requested session ID rather than\nthe ID in the URL.\n\nYour proposed patch looks to be heading in the right direction. I'll do some\ntesting and commit a fix.\n\nAs an aside, patches in diff -u format are a lot easier to manage. Anything more\nthan a few lines is best provided as an attachment rather then in-line.", "count": 2, "id": 112206, "time": "2007-12-26T12:43:15Z", "bug_id": 43839, "creation_time": "2007-12-26T12:43:15Z", "is_private": false}, {"count": 3, "tags": [], "text": "A modified patch has been applied to trunk and proposed for 6.0.x and 5.5.x", "is_private": false, "bug_id": 43839, "id": 112208, "time": "2007-12-26T12:57:20Z", "creator": "markt@apache.org", "creation_time": "2007-12-26T12:57:20Z", "attachment_id": null}, {"count": 4, "tags": [], "creator": "markt@apache.org", "attachment_id": null, "is_private": false, "id": 112257, "time": "2007-12-28T13:14:51Z", "bug_id": 43839, "creation_time": "2007-12-28T13:14:51Z", "text": "This has been fixed in svn for 6.0.x and will be included in 6.0.16 onwards."}, {"attachment_id": null, "tags": [], "creator": "a@gaydenko.com", "text": "(In reply to comment #4)\n> This has been fixed in svn for 6.0.x and will be included in 6.0.16 onwards.\n\nThanks, it's great! Can 6.0.16 release date be estimated?", "count": 5, "id": 112270, "time": "2007-12-28T18:54:56Z", "bug_id": 43839, "creation_time": "2007-12-28T18:54:56Z", "is_private": false}, {"count": 6, "tags": [], "creator": "engle_mars@yahoo.com.cn", "attachment_id": 21341, "is_private": false, "id": 112479, "time": "2008-01-03T18:50:18Z", "bug_id": 43839, "creation_time": "2008-01-03T18:50:18Z", "text": "Created attachment 21341\nPatch for java.org.apache.catalina.connector.CoyoteAdapter\n\nThe change of parseSessionCookiesId has problem. If access a invalid web\napplication path it will throw NullPointerException. This is unexpect. The\nnormal is return 404. The follow is the steps.\n1. Deploy a web application that is name 'CookiesBug' in webapps. \n2. Start tomcat.\n3. Access /cookiesBug. Notice the characters are all in lower.\n4. Will show NullPointerExecption at line 554 of class\njava.org.apache.catalina.connector.CoyoteAdapter.\n\n   The reason is the access URL is invalid and tomcat can't find the context\nelement for it. So it will throw NullPointerExecption. From\n'http://tomcat.apache.org/tomcat-6.0-doc/config/context.html', I think if can't\nfind the context, tomcat should trate it as default value, the 'cookies' is\ntrue. So we should get session tracing from cookies."}, {"count": 7, "tags": [], "creator": "engle_mars@yahoo.com.cn", "is_private": false, "id": 112480, "attachment_id": null, "bug_id": 43839, "creation_time": "2008-01-03T18:50:59Z", "time": "2008-01-03T18:50:59Z", "text": "The patch is for tomcat6.0.x"}, {"count": 8, "tags": [], "creator": "markt@apache.org", "attachment_id": null, "is_private": false, "id": 112504, "time": "2008-01-04T13:17:31Z", "bug_id": 43839, "creation_time": "2008-01-04T13:17:31Z", "text": "The NPE only occurs if the ROOT web app is not present. I have fixed the coed in\nsvn and proposed the improved fix for 6.0.x and 5.5.x"}, {"count": 9, "tags": [], "bug_id": 43839, "text": "Fixed in 5.5.x and will be included in 5.5.26 onwards.", "id": 112553, "time": "2008-01-06T15:14:29Z", "creator": "markt@apache.org", "creation_time": "2008-01-06T15:14:29Z", "is_private": false, "attachment_id": null}, {"count": 10, "tags": [], "text": "Updating version", "is_private": false, "bug_id": 43839, "id": 112554, "time": "2008-01-06T15:15:30Z", "creator": "markt@apache.org", "creation_time": "2008-01-06T15:15:30Z", "attachment_id": null}, {"count": 11, "tags": [], "bug_id": 43839, "text": "There is same problem in function parseSessionId() at line 505. If user declear\nuse cookie to store the session id, why need parse the session id from encode URI?", "id": 112566, "time": "2008-01-06T18:58:54Z", "creator": "engle_mars@yahoo.com.cn", "creation_time": "2008-01-06T18:58:54Z", "is_private": false, "attachment_id": null}, {"count": 12, "tags": [], "bug_id": 43839, "is_private": false, "text": "Please think about the test case. User declear use cookie to store the session\nand user rewrite the URI. For some reason the cookie is lost, in current code,\nwhat will happen. Tomcat will use the URI session, right? So, it the implement\nstill has problem. So I suggestion add the follow code at the parseSessionId.\n        Context context = (Context) request.getMappingData().context;\n        if (context == null || context.getCookies())\n            return;", "id": 112567, "time": "2008-01-06T19:08:57Z", "creator": "engle_mars@yahoo.com.cn", "creation_time": "2008-01-06T19:08:57Z", "attachment_id": null}, {"count": 13, "tags": [], "bug_id": 43839, "text": "The NPE has been fixed for 6.0.x and will be included in 6.0.16.\n\nI don't think you have a valid use case for the reverse case. Please discuss on\nthe dev list if you disagree.", "id": 112749, "time": "2008-01-10T13:42:52Z", "creator": "markt@apache.org", "creation_time": "2008-01-10T13:42:52Z", "is_private": false, "attachment_id": null}]