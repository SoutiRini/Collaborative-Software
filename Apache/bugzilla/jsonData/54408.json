[{"count": 0, "tags": [], "creator": "dickey@freeshell.org", "is_private": false, "text": "Created attachment 29848\nbuild file and accompanying documents exercising 3 examples of SSHExec task\n\nWhen using the SSHExec task to try to pass a password to the sudo command using inputproperty attribute my password was being printed to the tasks logging, and my sudo command would never complete.\nI found that the InputStream and OutputStream of the JSch ChannelExec object where configured reverse to how they should be according to the JSch Sudo Example at http://www.jcraft.com/jsch/examples/Sudo.java\n\nI developed the following patch to address the issue, and have attached a test case using the 3 input styles (inputproperty, inputstring, and input attributes).\n\n$ svn diff SSHExec.java\nIndex: SSHExec.java\n===================================================================\n--- SSHExec.java        (revision 1431539)\n+++ SSHExec.java        (working copy)\n@@ -28,6 +28,8 @@\n import java.io.InputStream;\n import java.io.InputStreamReader;\n import java.io.StringReader;\n+import java.io.OutputStream;\n+import java.util.ArrayList;\n\n import org.apache.tools.ant.BuildException;\n import org.apache.tools.ant.Project;\n@@ -63,7 +65,7 @@\n     private File outputFile = null;   // like <exec>\n     private String inputProperty = null;\n     private String inputString = null;   // like <exec>\n-    private File inputFile = null;   // like <exec>\n+    private Resource inputFile = null;\n     private boolean append = false;   // like <exec>\n     private boolean usePty = false;\n\n@@ -125,7 +127,7 @@\n      * @since Ant 1.8.0\n      */\n     public void setInput(File input) {\n-        inputFile = input;\n+        inputFile = new FileResource(input);\n     }\n\n     /**\n@@ -181,11 +183,11 @@\n     }\n\n     /**\n-     * Execute the command on the remote host.\n+     * Has the user set all necessary attributes?\n      *\n-     * @exception BuildException  Most likely a network error or bad parameter.\n+     * @exception BuildException if there are missing required parameters.\n      */\n-    public void execute() throws BuildException {\n+    private void checkConfiguration() throws BuildException {\n         if (getHost() == null) {\n             throw new BuildException(\"Host is required.\");\n         }\n@@ -208,40 +210,37 @@\n                                      + \" inputFile, inputProperty and\"\n                                      + \" inputString.\");\n         }\n-        if (inputFile != null && !inputFile.exists()) {\n+        if (inputFile != null && !inputFile.isExists()) {\n             throw new BuildException(\"The input file \"\n-                                     + inputFile.getAbsolutePath()\n+                                     + ((FileResource)inputFile).getFile().getAbsolutePath()\n                                      + \" does not exist.\");\n         }\n\n+    }\n+\n+    /**\n+     * Execute the command on the remote host.\n+     *\n+     * @exception BuildException Most likely a network error or bad parameter.\n+     */\n+    public void execute() throws BuildException {\n+        checkConfiguration();\n+        ArrayList inputs = getInputs();\n+        ArrayList cmds = getCmds();\n+        checkInputCmdCounts(inputs, cmds);\n         Session session = null;\n         StringBuffer output = new StringBuffer();\n         try {\n-            session = openSession();\n-            /* called once */\n-            if (command != null) {\n-                log(\"cmd : \" + command, Project.MSG_INFO);\n-                executeCommand(session, command, output);\n-            } else { // read command resource and execute for each command\n-                try {\n-                    BufferedReader br = new BufferedReader(\n-                            new InputStreamReader(commandResource.getInputStream()));\n-                    String cmd;\n-                    while ((cmd = br.readLine()) != null) {\n-                        log(\"cmd : \" + cmd, Project.MSG_INFO);\n-                        output.append(cmd).append(\" : \");\n-                        executeCommand(session, cmd, output);\n-                        output.append(\"\\n\");\n-                    }\n-                    FileUtils.close(br);\n-                } catch (IOException e) {\n-                    if (getFailonerror()) {\n-                        throw new BuildException(e);\n-                    } else {\n-                        log(\"Caught exception: \" + e.getMessage(),\n-                            Project.MSG_ERR);\n-                    }\n-                }\n+            session = openSession();  /* called once */\n+            for(int i = 0; i < cmds.size(); i++) {\n+                String cmd = (String)cmds.get(i);\n+                String input = null;\n+                if (inputs.size() > 0 && i < inputs.size())\n+                    input=(String)inputs.get(i);\n+                log(\"cmd : \" + cmd, Project.MSG_INFO);\n+                output.append(cmd).append(\" : \");\n+                executeCommand(session, cmd, input, output);\n+                output.append(\"\\n\");\n             }\n         } catch (JSchException e) {\n             if (getFailonerror()) {\n@@ -259,17 +258,35 @@\n         }\n     }\n\n-    private void executeCommand(Session session, String cmd, StringBuffer sb)\n-        throws BuildException {\n-        ByteArrayOutputStream out = new ByteArrayOutputStream();\n-        TeeOutputStream tee =\n-            new TeeOutputStream(out,\n-                                KeepAliveOutputStream.wrapSystemOut());\n+    private void checkInputCmdCounts(ArrayList inputs, ArrayList cmds) {\n+        int cmdsCnt = cmds.size();\n+        if (cmdsCnt == 0) {\n+            throw new BuildException(\"There are no commands to execute in \"\n+                                     + ((FileResource)commandResource).getFile().getAbsolutePath());\n+        }\n+        int diff = cmdsCnt-inputs.size();\n+        if (diff > 0 && cmdsCnt > 1) {\n+            log(\"There are fewer inputs than commands provided so the last \"+diff\n+               +\" commands won't be provided any input\", Project.MSG_WARN);\n+        }\n+        if (diff < 0) {\n+            log(\"There are more inputs than commands provided so the last \"+Math.abs(diff)\n+                    +\" inputs won't used\", Project.MSG_WARN);\n\n-        InputStream istream = null ;\n+        }\n+    }\n+\n+    private ArrayList getInputs() {\n+        ArrayList inputData = new ArrayList();\n         if (inputFile != null) {\n             try {\n-                istream = new FileInputStream(inputFile) ;\n+                String line;\n+                BufferedReader lines = new BufferedReader(\n+                        new InputStreamReader(inputFile.getInputStream()));\n+                while ((line = lines.readLine()) != null) {\n+                    inputData.add(line+\"\\n\");\n+                }\n+                FileUtils.close(lines);\n             } catch (IOException e) {\n                 // because we checked the existence before, this one\n                 // shouldn't happen What if the file exists, but there\n@@ -278,37 +295,111 @@\n                     + e.getMessage(), Project.MSG_WARN);\n             }\n         }\n-        if (inputProperty != null) {\n-            String inputData = getProject().getProperty(inputProperty) ;\n-            if (inputData != null) {\n-                istream = new ByteArrayInputStream(inputData.getBytes()) ;\n-            }\n+        else if (inputProperty != null) {\n+            String propertyValue = getProject().getProperty(inputProperty);\n+            if (propertyValue != null)\n+                inputData.add(propertyValue+\"\\n\");\n         }\n-        if (inputString != null) {\n-            istream = new ByteArrayInputStream(inputString.getBytes());\n+        else if (inputString != null) {\n+            inputData.add(inputString+\"\\n\");\n         }\n+        return inputData;\n+    }\n\n+    private ArrayList getCmds() {\n+        ArrayList cmds = new ArrayList();\n+        if (commandResource != null) {\n+            try {\n+                BufferedReader br = new BufferedReader(\n+                        new InputStreamReader(commandResource.getInputStream()));\n+                String cmd;\n+                while ((cmd = br.readLine()) != null) {\n+                    cmds.add(cmd);\n+                }\n+                FileUtils.close(br);\n+            } catch (IOException e) {\n+                if (getFailonerror()) {\n+                    throw new BuildException(e);\n+                } else {\n+                    log(\"Caught exception: \" + e.getMessage(),\n+                        Project.MSG_ERR);\n+                }\n+            }\n+        }\n+        else if (command != null) {\n+            cmds.add(command);\n+        }\n+        return cmds;\n+    }\n+\n+    private InputStream inputFromCmd = null;\n+    private OutputStream outputToCmd = null;\n+    private TeeOutputStream teeToSysOut = null;\n+\n+    private void executeCommand(Session session, String cmd, String input, StringBuffer sb)\n+            throws BuildException {\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        teeToSysOut = new TeeOutputStream(out,\n+                KeepAliveOutputStream.wrapSystemOut());\n+        ByteArrayOutputStream err = new ByteArrayOutputStream();\n+        TeeOutputStream teeToSysErr = new TeeOutputStream(err,\n+                KeepAliveOutputStream.wrapSystemErr());\n+\n         try {\n             final ChannelExec channel;\n             session.setTimeout((int) maxwait);\n             /* execute the command */\n             channel = (ChannelExec) session.openChannel(\"exec\");\n             channel.setCommand(cmd);\n-            channel.setOutputStream(tee);\n-            channel.setExtOutputStream(tee);\n-            if (istream != null) {\n-                channel.setInputStream(istream);\n-            }\n             channel.setPty(usePty);\n+\n+            if (input != null) {\n+                outputToCmd = channel.getOutputStream();\n+            } else\n+                channel.setOutputStream(null);\n+\n+            inputFromCmd = channel.getInputStream();\n+            channel.setErrStream(teeToSysErr);\n             channel.connect();\n+            log(\"successfully connected\");\n+            if (input != null) {\n+                outputToCmd.write(input.getBytes());\n+                outputToCmd.flush();\n+            }\n+\n             // wait for it to finish\n             thread =\n                 new Thread() {\n                     public void run() {\n-                        while (!channel.isClosed()) {\n+                        byte[] tmp = new byte[1024];\n+                        while (true) {\n+                            log(\"attempting to read input from SSHExec command\", Project.MSG_DEBUG);\n+                            try {\n+                                while (inputFromCmd.available() > 0) {\n+                                    int read = inputFromCmd.read(tmp);\n+                                    if (read < 0)\n+                                        break;\n+                                    // sb.append((char[]) tmp, 0, read);\n+                                    teeToSysOut.write(tmp, 0, read);\n+                                }\n+                            } catch (IOException ioe) {\n+                                handleErrorFlush(\"Error handling output from cmd:\"\n+                                                 + ioe.getMessage());\n+                            }\n                             if (thread == null) {\n                                 return;\n                             }\n+                            if (channel.isClosed()) {\n+                                String str = \"cmd exited with status: \"\n+                                            + channel.getExitStatus();\n+                                try {\n+                                    teeToSysOut.write(str.getBytes());\n+                                } catch (IOException ioe) {\n+                                    handleErrorFlush(\"Error handling channel close message:\"\n+                                                     + ioe.getMessage());\n+                                }\n+                                return;\n+                            }\n                             try {\n                                 sleep(RETRY_INTERVAL);\n                             } catch (Exception e) {\n@@ -372,7 +463,6 @@\n             }\n         } finally {\n             sb.append(out.toString());\n-            FileUtils.close(istream);\n         }\n     }\n\n@@ -407,4 +497,4 @@\n             }\n         }\n     }\n-}\n\\ No newline at end of file\n+}", "id": 164588, "time": "2013-01-11T21:29:15Z", "bug_id": 54408, "creation_time": "2013-01-11T21:29:15Z", "attachment_id": 29848}, {"text": "Ben, I am not able to reproduce your problem using Java 1.7 or Java 1.6 and jsch 0.1.49 and the current code of Ant. I have targetted my own Mac and an ubuntu VM, running the build file on Mac if this matters.", "tags": [], "bug_id": 54408, "is_private": false, "count": 1, "id": 165070, "time": "2013-02-05T04:43:02Z", "creator": "antoine@apache.org", "creation_time": "2013-02-05T04:43:02Z", "attachment_id": null}, {"count": 2, "attachment_id": null, "bug_id": 54408, "is_private": false, "id": 172174, "time": "2014-01-08T13:26:45Z", "creator": "ymnk@jcraft.com", "creation_time": "2014-01-08T13:26:45Z", "tags": [], "text": "I'm the author of JSch, and have also tried the attached build.xml with Apache Ant 1.9.3, but I can't find the problem for the test case of sudo.  I think the status should be changed to \"NEEDINFO\"."}, {"count": 3, "tags": [], "text": "Thanks for checking!", "is_private": false, "bug_id": 54408, "id": 172182, "time": "2014-01-08T14:48:23Z", "creator": "bodewig@apache.org", "creation_time": "2014-01-08T14:48:23Z", "attachment_id": null}]