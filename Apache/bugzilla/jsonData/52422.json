[{"count": 0, "tags": [], "bug_id": 52422, "attachment_id": 28120, "is_private": false, "id": 152571, "time": "2012-01-04T23:57:56Z", "creator": "thiagobart@gmail.com", "creation_time": "2012-01-04T23:57:56Z", "text": "Created attachment 28120\nChanges the check to add the end instruction length to the local variable length\n\nIt seems that getLocalVariable computes incorrect length for the returning LocalVariable if its range is not the whole method. This is the original code:\n\npublic LocalVariable getLocalVariable( ConstantPoolGen cp ) {\n        int start_pc = start.getPosition();\n        int length = end.getPosition() - start_pc;\n        if (length > 0) {\n            length += end.getInstruction().getLength();\n        }\n        int name_index = cp.addUtf8(name);\n        int signature_index = cp.addUtf8(type.getSignature());\n        return new LocalVariable(start_pc, length, name_index, signature_index, index, cp.getConstantPool());\n}\n\n\nI think that the check \"if (length > 0)\" is a \"workaround\" for local variables whose end targets the last instruction. In this case, we must add the instruction length to recover the actual range for the local variable. However, we should not add the instruction's length if it is not the last instruction of the list because variable ranges are exclusive in the end_pc (note that the JVM spec used to say that the range is inclusive, but this was corrected in JVM5 - see http://java.sun.com/docs/books/jvms/second_edition/jvms-clarify.html or more specifically page 143 of http://java.sun.com/docs/books/jvms/second_edition/ClassFileFormat-Java5.pdf ).\n\nThis error can be verified by parsing a method that has local variables whose range is not the whole method (like variables for exceptions in an exception handler), creating a MethodGen and then comparing the local variable tables. Something like this:\n\nClassParser parser = new ClassParser(...);\t\t\nJavaClass clazz = parser.parse();\nMethod m = clazz.getMethods()[...];\nConstantPoolGen cpg = new ConstantPoolGen(clazz.getConstantPool());\nMethodGen mg = new MethodGen(m, clazz.getClassName(), cpg);\nSystem.out.println(mg.getLocalVariableTable(cpg));\nSystem.out.println(\"==\");\nSystem.out.println(m.getLocalVariableTable());\n\nwould produce some output which includes:\n\nLocalVariable(start_pc = 17, length = 7, index = 2:Exception e1)\n...\n==\n...\nLocalVariable(start_pc = 17, length = 6, index = 2:Exception e1)\n\n\nNote that the length is greater than the original.\n\nIf this is really a bug, I believe a fix is to use if (end.getNext() == null) instead (see the patch in attachment). I ran the whole test suite with this fix and it passes, but I am not sure what else it affects.\n\nCheers,\nThiago"}, {"count": 1, "tags": [], "bug_id": 52422, "attachment_id": null, "is_private": false, "id": 152793, "time": "2012-01-15T02:50:23Z", "creator": "dbrosius@apache.org", "creation_time": "2012-01-15T02:50:23Z", "text": "Agreed, thanks for the patch, \nCommitted revision 1231616."}]