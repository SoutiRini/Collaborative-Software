[{"count": 0, "tags": [], "creator": "poirier@pobox.com", "is_private": false, "text": "Created attachment 24124\nAdd a per-memcache object lock to protect the cached object pool\n\nI can produce a seg fault out of mod_mem_cache by setting the cache\nexpiration very short (1 second), then hitting it with bursts of\nrequests for the same URL every few seconds.  The stack looks like:\n\n#0  apr_table_add (t=0x9ee2230, key=0x9f8b630 \"ETag\", val=0x9f8c1c8\n\"\\\"3ee9f6-22-4533a9a40f700\\\"\") at tables/apr_tables.c:792\n#1  0xb7e10521 in deep_table_copy (p=<value optimized out>, table=<value\noptimized out>) at mod_mem_cache.c:559\n#2  0xb7e10a9d in store_headers (h=0x9f8b2e0, r=0x9f8a200, info=0x9f2eed8) at\nmod_mem_cache.c:642\n#3  0xb806ed7c in cache_save_filter (f=0x9f8b988, in=0x9f8c220) at\nmod_cache.c:797\n#4  0x0807628b in default_handler (r=0x9f8a200) at core.c:3757\n...\n\nThis appears to be due to concurrent use of mobj->pool when updating\nthe stored headers for a stale cached object.  Adding a lock per\nmemory cache object and using it to protect use of mobj->pool, I'm no\nlonger able to reproduce the problem.  Since the lock is per cached\nobject, there should be little contention for it.  (The fault was very\nrare in real-world traffic.)\n\nI'm attaching my fix for 2.2.x, since mod_mem_cache is no longer in\ntrunk.", "id": 129601, "time": "2009-08-10T12:40:14Z", "bug_id": 47672, "creation_time": "2009-08-10T12:40:14Z", "attachment_id": 24124}, {"count": 1, "tags": [], "text": "looks necessary to me, can you propose for \"backport\" in 2.2.x STATUS?", "attachment_id": null, "id": 129628, "creator": "covener@gmail.com", "time": "2009-08-11T12:37:40Z", "bug_id": 47672, "creation_time": "2009-08-11T12:37:40Z", "is_private": false}, {"count": 2, "tags": [], "creator": "poirier@pobox.com", "text": "Fixed in 2.2.x, r808904", "id": 130563, "time": "2009-09-21T11:19:18Z", "bug_id": 47672, "creation_time": "2009-09-21T11:19:18Z", "is_private": false, "attachment_id": null}]