[{"text": "Hi,\n\nWe use Tomcat 4.0.3, with Apache 1.3.24 and mod_jk, all in a loadbalanced \nsetup. We experience an intermittent bug in Tomcat that I fixed by changing the \nserver code. I would like to describe the problem in the following by hoping \nsomeone can tell me what this is about.\n\nThe problem is in the Ajp13Processor class. Once a processor is taken from the \npool the AJP details are read with \n\n                status = ajp13.receiveNextRequest(ajpRequest);\n\nThen later it is assigned to the supposedly recycled Ajp13Request from the \nprevious use\n\n                // set up request\n                request.setAjpRequest(ajpRequest);\n\nSo far so good. What happens for us is that at least 5 times every minute (up \nto 20-30 times) the flag \"parsed\" in Ajp13Request (the \"request\" instance \nvariable of the Ajp13Processor class) is suddenly set to \"true\"!\n\nThis causes the following problem. The incoming query string is not parsed \nanymore because the request thinks it had done this already. Therefore in our \ncode when we use getParamXXXX() methods they all return \"null\" or an empty map. \nThis of course means ours servlets assume that no parameters have been provided \nand they do whatever they should do in this case - which of course fails what \nthe customer expects.\n\nWhat I did to quickly fix this problem is to add the following lines into \nAjp13Request.java\n\n    void setAjpRequest(BaseRequest ajp) throws UnsupportedEncodingException {\n        // XXX make this guy wrap AjpRequest so\n        // we're more efficient (that's the whole point of\n        // all of the MessageBytes in AjpRequest)\n\n        /** @todo DEBUG */\n        if (parsed == true) {\n          parsed = false;\n          System.err.println(\"!!! parsed was true in recycled request !!!\");\n        }\n        /** @todo DEBUG */\n\n        setMethod(ajp.method().toString());\n        setProtocol(ajp.protocol().toString());\n        ....\n\nNote the DEBUG lines above, when I detect that, although the request should \nhave been recycled, that the \"parsed\" flag is already set before even anything \nis assigned to it I reset the flag to \"false\" and everything is working fine. \nThe error message I print out above is the one that shows up in our \ncatalina.out the specified number of times (see above).\n\nI then went on and added this to the HttpRequestBase.java\n\n    public void setQueryString(String query) {\n\n        /** @todo DEBUG */\n        if (parsed) {\n          System.err.println(\"### reassigned query string ###\\nqueryString: \" +\n          queryString + \"\\nnew value: \" + query);\n        }\n        /** @todo DEBUG */\n\n        this.queryString = query;\n\n    }\n\nAlthough this should never happen - or am I wrong here - this is what I see in \nthe catalina.out\n\n### reassigned query string ###\nqueryString: null\nnew value: wl_srclang=ES&wl_trglang=FR&wl_gloss=7&wl_text=Provinc%\nEDa+de+la+direcci%F3n+destino+de+la+mercanc%EDa\n!!! parsed was true in recycled request !!!\n\n\nClearly, the request gets some values assigned twice somehow. But what puzzles \nme is that \"parsed\" is only set to \"true\" when someone calls any of the \ngetParameterXXXX() methods. But because userland code hasn't been executed so \nfar this is impossible. This all happens within a single thread and within two \nclasses of Tomcat source code. What is going on?\n\nI also had some debug code in the \"recycle\" method to check - assuming that \nrecycle is called fine - if everything gets cleared, including the \"parsed\" \nflag. This shows the correct behaviour during all my testing, ie. everything is \ncleared fine. Also I wrapped the call to \"recycle\" in Ajp13Request with a \ntry/catch to see if maybe an error is thrown that would prevent a \"recycle\" \nbeing called - again, I never had any errors showing up at this point. Also \nwhen dumping the values from the request instance it looks like it is always \ncleared correctly; I have never seen some sort of \"left overs\" from a previous \nrequest, so recycling the request does not seem to be the issue.\n\nThe only explanation I have so far is that somehow \nHttpRequestBase.parseParameters is called before the BaseRequest values (from \nthe Ajp13 connection) are assigned to it. But having one single thread running \nthrough the Ajp13Processor and no trace of someone calling getParamXXXX(), how \nwhould that happen?\n\nJust to explain, we use three servers that all show the same problem. Two are \nrunning Sun JDK 1.3.0_02 and one the newest Sun JDK 1.3.1_03, again to note, \nall show this behaviour. Tomcat was built with the Sun JDK 1.3.1_03 version for \nall of them.\n\nI recompiled Tomcat heaps of times with different debug output to find the \nproblem and this has not changed anything, so it does not look like the \ninfamous Heisenberg uncertainty, ie. recompiling or monitoring the code does \nnot make the problem go away. Always the same problem, same spot. \n\nIt does not seem to be load related as the number of errors just increases \nproportionally with the load; and even minor load causes the problem to show up.\n\nI am at the end of my wisdom here as to what this is related to or caused by. I \nappreciate any comments, ideas, suggestions etc. to clarify this issue. \n\nYours faithfully,\n\nLars", "tags": [], "bug_id": 9334, "attachment_id": null, "count": 0, "id": 16577, "time": "2002-05-23T00:50:02Z", "creator": "lars@worldlingo.com", "creation_time": "2002-05-23T00:50:02Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 9334, "attachment_id": null, "id": 59503, "time": "2004-06-18T18:43:03Z", "creator": "markt@apache.org", "creation_time": "2004-06-18T18:43:03Z", "is_private": false, "text": "This component is now deprecated. If you still experience this issue, please \nupgrade to the Coyote JK2 connector.\n\nNo further work will take place against this bug report.\n\n"}]