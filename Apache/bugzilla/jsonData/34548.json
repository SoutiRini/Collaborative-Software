[{"count": 0, "tags": [], "text": "We discovered that the RE constructor \"new RE(pattern)\" is not thread safe.\n\nI've attached a class which creates 1600 RE instances in their own threads\nrunning at random times and which illustrates the problem. The sample class\nincludes an synchronisation wrapper which if invoked synchronizes the RE\nconstructors and makes the problem go away.\n\nWe might be submitting a patch for this; suggest anyone contact me before doing\nany work to fix this bug.\n\nTo invoke the test class use the following command line.\n\nUsage : \nRegexSynchronizer -nosynch -nowrapper <delay>\n\nExample showing errors :\nRegexSynchronizer -nosynch -nowrapper 10\n\nExample showing fewer errors because of lesser collisions :\nRegexSynchronizer -nosynch -nowrapper 30000\n\nExample showing no errors because we wrap the RE usage :\nRegexSynchronizer -nosynch -wrapper 10\n\nOptions :\n-nosynch = runs tests without internal synchronisation\n-synch = runs tests with internal synchronisation\n-nowrapper = runs tests without internal synch wrapper\n-wrapper = runs tests with internal wrapper\n<delay> = internal random delay for each test; lower means more collisions\n\n\nCode follows :\n===============\npackage utility;\n\nimport org.apache.regexp.*;\nimport java.util.*;\n\npublic class RegexSynchronizer {\n\n    private static final String NO_SYNCH = \"-nosynch\";\n    private static final String SYNCH = \"-synch\";\n    private static final String NO_WRAPPER = \"-nowrapper\";\n    private static final String WRAPPER = \"-wrapper\";\n\n\n    public static synchronized RE getRegex(String thePattern) throws\nRESyntaxException {\n\n        RE r = new RE(thePattern);\n\n        return(r);\n    }\n\n\n\n\n    /**\n     * Run some regexs in parallel to prove that the regex RE class is not\nthread safe.\n     *\n     * @param args .\n     */\n    public static void main(String args[]) {\n\n        boolean showUsage = false;\n\n        if (args.length == 0)\n            showUsage = true;\n\n        boolean synch = false;\n        boolean wrap = false;\n        int delay = 10;\n\n        for (int i = 0; i < args.length; i++) {\n\n            String arg = args[i];\n\n            if (arg.equals(NO_SYNCH))\n                synch = false;\n            else if (arg.equals(SYNCH))\n                synch = true;\n            else if (arg.equals(NO_WRAPPER))\n                wrap = false;\n            else if (arg.equals(WRAPPER))\n                wrap = true;\n            else {\n                try {\n                    int d = Integer.parseInt(arg);\n                    delay = d;\n                }\n                catch (NumberFormatException nfe) {\n                    showUsage = true;\n                }\n            }\n        }\n\n\n        if (showUsage) {\n            System.out.println(\"Usage : \\n\" +\n                               \"RegexSynchronizer \" + NO_SYNCH + \" \" +\nNO_WRAPPER + \" <delay>\\n\" +\n                               \"\\n\" +\n                               \"Example showing errors :\\n\" +\n                               \"RegexSynchronizer \" + NO_SYNCH + \" \" +\nNO_WRAPPER + \" 10\\n\" +\n                               \"\\n\" +\n                               \"Example showing fewer errors because of lesser\ncollisions :\\n\" +\n                               \"RegexSynchronizer \" + NO_SYNCH + \" \" +\nNO_WRAPPER + \" 30000\\n\" +\n                               \"\\n\" +\n                               \"Example showing no errors because we wrap the RE\nusage :\\n\" +\n                               \"RegexSynchronizer \" + NO_SYNCH + \" \" + WRAPPER +\n\" 10\\n\" +\n                               \"\\n\" +\n                               \"Options :\\n\" +\n                               NO_SYNCH + \" = runs tests without internal\nsynchronisation\\n\" +\n                               SYNCH + \" = runs tests with internal\nsynchronisation\\n\" +\n                               NO_WRAPPER + \" = runs tests without internal\nsynch wrapper\\n\" +\n                               WRAPPER + \" = runs tests with internal wrapper\\n\" +\n                               \"<delay> = internal random delay for each test;\nlower means more collisions\"\n                               );\n            System.exit(-1);\n        }\n\n        System.out.println(\"Synch=\" + synch + \", wrap=\" + wrap + \", delay=\" +\ndelay);\n\n        // To demonstrate the threading bug use the following settings :\n        //   doSynchronised = false\n        //   useOurSynchWrapper = false\n        //   sleepDelay = 10\n\n\n\n        // Change from false/true to test the two cases synchronised and not\nsynchronised in the test code\n        final boolean doSynchronised = synch;\n\n        // Change from true/false to test the native class or our synchronized\nwrapper\n        final boolean useOurSynchWrapper = wrap;\n\n\n        // The amount of time the test threads sleep before starting. Increasing\nthis reduces the likelihood of a threading problem\n        // and hence reduces the number of errors we find.\n        final int sleepDelay = delay;\n\n\n\n        // Some sample regexs to try compiling\n        String[] regexs = {\"[A-Z]{3}:\", \"<TAG[^>]*>(.*?)</TAG>\", \"^[ \\t]+\",\n                         \n\"\\\\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b\",\n                          \"(A:\\\\d{1,3}\\\\.){3}\\\\d{1,3}\\\\b\",\n                          \"(m/[0-9]{2}[\\\\/|-][0-9]{2}[\\\\/|-][0-9]{4}/)\",\n                          \"<a +href=\\\"http://([\\\\w\\\\.-]+)\",\n                         \n\"a(a(a(a(a(a(a(a(a(a(a(a(a(a(a(a(a(a(a(a(<[b^>]*>)c)c)c)c)c)c)c)c)c)c)c)c)c)c)c)c)c)c)c)c\",\n                         \n\"a(a(a(a(a(a(a(a(a(a(a(a(a(a(a(a(a(a(a(a(<[b^>]*>)c)c)c)c)c)c)c)c)c)c)c)c)c)c)c)c)c)c)c)c\",\n                         \n\"a(a(a(a(a(a(a(a(a(a(a(a(a(a(a(a(a(a(a(a(<[b^>]*>)c)c)c)c)c)c)c)c)c)c)c)c)c)c)c)c)c)c)c)c\",\n                         \n\"a(a(a(a(a(a(a(a(a(a(a(a(a(a(a(a(a(a(a(a(<[b^>]*>)c)c)c)c)c)c)c)c)c)c)c)c)c)c)c)c)c)c)c)c\",\n                         \n\"a(a(a(a(a(a(a(a(a(a(a(a(a(a(a(a(a(a(a(a(<[b^>]*>)c)c)c)c)c)c)c)c)c)c)c)c)c)c)c)c)c)c)c)c\",\n                          \"(A{1,5}){4}B{1,5}\",\n                          \"(A{1,5}){4}B{1,5}\",\n                          \"(A{1,5}){4}B{1,5}\",\n                          \"(A{1,5}){4}B{1,5}\",\n                          \"(A{1,5}){4}B{1,5}\",\n                          \"(A{1,5}){4}B{1,5}\"\n        };\n\n\n        // The number of test loops we do\n        int numberOfTestLoops = 100;\n\n\n        // ArrayList of test threads waiting to start\n        ArrayList threads = new ArrayList();\n\n\n        // Random instance for thread sleep time\n        final Random rand = new Random();\n\n        // Say we have started\n        System.out.println(\"Start\");\n\n        // Loop for the tests\n        for (int i = 0; i < numberOfTestLoops; i++) {\n\n            // For each test we compile each of our regexs\n            for (int j = 0; j < regexs.length; j++) {\n\n            final String pattern = regexs[j];\n\n            // Create a new thread to compile this regex\n            Thread t = new Thread() {\n\n\n                // Test method to compile the RE\n                private void getRe() {\n                    int sleep = rand.nextInt(sleepDelay);\n\n                    try {\n                        // Randomise the start time for this thread so we get a\ndifferent mix of tests each time through\n                        Thread.sleep(sleep);\n\n                        // Either use our wrapper or use the raw RE compiler\n                        if (useOurSynchWrapper) {\n                            RE r = RegexSynchronizer.getRegex(pattern);\n                        } else {\n                            RE r = new RE(pattern);\n                        }\n\n                    }\n                    catch (Throwable e) {\n                        // We should ideally never get here...\n                        System.out.println(e.toString() + \", \" + pattern);\n                    }\n\n                }\n\n                // Run method for the thread\n                public void run() {\n\n                    // If we're doing a synchronised test then synch here\n                    if (doSynchronised) {\n                        synchronized (Thread.class) {\n                            getRe();\n                        }\n                    } else {\n                        // Otherwise do the unsynch test\n                        getRe();\n                    }\n\n                }\n\n            };\n\n            // Store the thread ready to start them all together\n            threads.add(t);\n        }\n    }\n\n\n    // Start all the threads\n    for (Iterator i = threads.iterator(); i.hasNext(); ) {\n        Thread t = (Thread)i.next();\n        t.start();\n    }\n\n\n    // Wait for the last one to finish\n    try {\n        Thread.sleep(sleepDelay + 1000);\n    }\n    catch (Exception ex) {\n        // ignore\n    }\n\n    // Say we're done\n    System.out.println(\"\\nEnd\");\n\n    }\n}", "attachment_id": null, "id": 73879, "creator": "james.cherryh@defence.gov.au", "time": "2005-04-21T07:53:56Z", "bug_id": 34548, "creation_time": "2005-04-21T07:53:56Z", "is_private": false}, {"count": 1, "tags": [], "creator": "james.cherryh@defence.gov.au", "attachment_id": null, "text": "OK, I've read the comments in the RE header and I see there that they note the\nclass is not threadsafe. Obviously whoever implemented the code here didn't know\nthat. We're using the RE constructors in code running in an app server, so we\ncan get concurrent threads of execution trying to create an RE at the same time.\nWe've worked around it by introducing a synchronised wrapper as in the test case\nI included.\n\nI'd suggest that many people wouldn't have realised that RE isn't threadsafe. We\npropose a new class REThreadsafe which simply wraps the RE constructors in a\nthreadsafe way. That way developer's attention would be drawn to the issue and\nthey could use the threadsafe constructors if they have a multi-threaded context\nand correctness is more important than performance :-)", "id": 73934, "time": "2005-04-22T07:13:03Z", "bug_id": 34548, "creation_time": "2005-04-22T07:13:03Z", "is_private": false}, {"count": 2, "tags": [], "text": "So something like this perhaps. We create a new class REThreadsafe (code below)\nwhich wraps the RE constructor in a synchronized block. We create an interface\nREInterface (code below) for the public methods on RE and REThreadsafe to ensure\nthat they stay in step.\n\nThe naive user can then create and use a new REThreadsafe just like they use an\nRE instance. Existing users of RE are not affected or impacted.\n\nREThreadsafe \n============\n\npackage org.apache.regexp;\n\npublic class REThreadsafe implements REInterface {\n\n  final RE wrappedRE;\n\n\n  public REThreadsafe(REProgram program, int matchFlags) {\n\n     synchronized (REThreadsafe.class) {\n        wrappedRE = new RE(program, matchFlags);\n     }\n   }\n\n\n   public REThreadsafe(REProgram program) {\n       this(program, RE.MATCH_NORMAL);\n   }\n\n\n   public REThreadsafe() {\n       this((REProgram)null, RE.MATCH_NORMAL);\n   }\n\n\n   public REThreadsafe(String pattern) throws RESyntaxException {\n       this(pattern, RE.MATCH_NORMAL);\n   }\n\n\n   public REThreadsafe(String pattern, int matchFlags) throws RESyntaxException {\n       this(new RECompiler().compile(pattern));\n       setMatchFlags(matchFlags);\n   }\n\n\n  public REProgram getProgram() {\n    return wrappedRE.getProgram();\n  }\n  public String getParen(int which) {\n    return wrappedRE.getParen(which);\n  }\n  public void setMatchFlags(int matchFlags) {\n    wrappedRE.setMatchFlags(matchFlags);\n  }\n  public String[] split(String s) {\n    return wrappedRE.split(s);\n  }\n  public boolean match(String search) {\n    return wrappedRE.match(search);\n  }\n  public String subst(String substituteIn, String substitution) {\n    return wrappedRE.subst(substituteIn, substitution);\n  }\n  public boolean match(CharacterIterator parm1, int parm2) {\n    return wrappedRE.match(parm1, parm2);\n  }\n  public String[] grep(Object[] parm1) {\n    return wrappedRE.grep(parm1);\n  }\n  public int getParenCount() {\n    return wrappedRE.getParenCount();\n  }\n  public boolean match(String search, int i) {\n    return wrappedRE.match(search, i);\n  }\n  public String subst(String substituteIn, String substitution, int flags) {\n    return wrappedRE.subst(substituteIn, substitution, flags);\n  }\n  public void setProgram(REProgram parm1) {\n    wrappedRE.setProgram(parm1);\n  }\n  public int getMatchFlags() {\n    return wrappedRE.getMatchFlags();\n  }\n\n\n}\n\n\n\nREInterface\n===========\n\npackage org.apache.regexp;\n\ninterface REInterface {\n\n  REProgram getProgram();\n\n  String getParen(int which);\n\n  void setMatchFlags(int matchFlags);\n\n  String[] split(String s);\n\n  boolean match(String search);\n\n  String subst(String substituteIn, String substitution);\n\n  boolean match(CharacterIterator parm1, int parm2);\n\n  String[] grep(Object[] parm1);\n\n  int getParenCount();\n\n  boolean match(String search, int i);\n\n  String subst(String substituteIn, String substitution, int flags);\n\n  void setProgram(REProgram parm1);\n\n}\n", "is_private": false, "bug_id": 34548, "id": 73937, "time": "2005-04-22T08:12:35Z", "creator": "james.cherryh@defence.gov.au", "creation_time": "2005-04-22T08:12:35Z", "attachment_id": null}, {"count": 3, "tags": [], "bug_id": 34548, "attachment_id": 16008, "id": 78390, "time": "2005-08-11T05:10:24Z", "creator": "vgritsenko@apache.org", "creation_time": "2005-08-11T05:10:24Z", "is_private": false, "text": "Created attachment 16008\nReformatted / simplified test case\n\nRemoved all options, and formatted to make it compile."}, {"count": 4, "attachment_id": null, "bug_id": 34548, "is_private": false, "id": 78391, "time": "2005-08-11T05:13:13Z", "creator": "vgritsenko@apache.org", "creation_time": "2005-08-11T05:13:13Z", "tags": [], "text": "I ran testcase (attached) with different parameters (5, 10, 15, 500) with no\nerrors. Thread unsafety you are referring to most probably was fixed more than 2\nyears ago (see Bug #3877). Please test your code against current code from\nsubversion, or at least against latest released version.\n\n*** This bug has been marked as a duplicate of 3877 ***"}]