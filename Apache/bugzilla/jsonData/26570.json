[{"count": 0, "tags": [], "text": "In 1.6.0, interface com.sun.javadoc.RootDoc is loaded twice.  Finding it via \nClass.forName produces an instance with a different hashCode than what's in \nthe parameter signature of a loaded doclet in our doclet path.  Note that we \nare doing this call from within a custom task, NOT from the forked javadoc \nprocess, so we are talking about loading in the main thread, not for a new \njavadoc VM.\n\nHaving two instances of a loaded class is a problem.  It could be alleviated \nif java.lang.Class defined an equals method that tested based on the name, \nrather than the instance, then getMethod could find the appropriate Method in \neither case.  But the official position is that you shouldn't have two \ninstances of the same class floating around.\n\nWe've exhausted the workarounds we know of, once the duplicates are loaded\nthere doesn't seem to be much way around this.  If you have any suggestions \nplease let me know.\n\nI don't know where to start looking for this in the Ant code.  I'm presuming \nit was forced in at some point?  Version 1.5.4 works fine, so we'll use that \nfor now and check subsequent releases as they happen.\n\nthanks,\n-ep", "is_private": false, "id": 51532, "creator": "eric@sandservices.com", "time": "2004-01-31T20:05:20Z", "bug_id": 26570, "creation_time": "2004-01-31T20:05:20Z", "attachment_id": null}, {"count": 1, "attachment_id": null, "bug_id": 26570, "text": "I think you need to provide more information here.\n\n1. How are you loading your custom task. Where does the task class reside - is\nit a taskdef with a classpath? Can you give a build file snippet.\n\n2. Where are you getting the two instances from - one is a Class.forName and the\nother is ? (not sure what you mean by \"the parameter signature of a loaded\ndoclet in our doclet path\")\n\n3. How is having two instances of a loaded class a problem? Are you getting\nClassCastExceptions?\n\n4. What is your classpath set to? Does it include tools.jar (where the interface\nclassfile lives)?\n\nIn the end you need to make sure the same loader is being used to load the\ndifferent instances. One step would be to get the class loader for the instance\nand see what the loader class is for the two instances, and then try to\nunderstand how that comes about. We'll need a lot more info to get there.", "id": 51535, "time": "2004-02-01T00:59:13Z", "creator": "conor@apache.org", "creation_time": "2004-02-01T00:59:13Z", "tags": [], "is_private": false}, {"attachment_id": null, "tags": [], "creator": "eric@sandservices.com", "is_private": false, "count": 2, "id": 51553, "time": "2004-02-01T19:35:59Z", "bug_id": 26570, "creation_time": "2004-02-01T19:35:59Z", "text": "This has been extraordinarily difficult to track down, and the only way I\nknow to reproduce it is through all the steps I actually took.  I'm not\nsure what of this is critical to the process and what isn't.  Within a\nsingle ant build:\n  - javac Foo.java containing public class Foo that has a method\n        public static boolean start(com.sun.javadoc.RootDoc root)\n  - jar Foo.class into FooStuff.jar\n  - call MyCustomTask (a custom Ant task built previously and available\n    from the environment CLASSPATH) passing it the full classname of Foo \n    and the location of FooStuff.jar.  MyCustomTask then\n    - creates a URLClassLoader with the URL of FooStuff.jar\n    - loads class Foo\n    - finds the start method via reflection\n    - notes that the method has one parameter, which is a \n      com.sun.javadoc.RootDoc interface with hashCode 23894119\n    - notes that Class.forName(\"com.sun.javadoc.RootDoc\") returns a\n      com.sun.javadoc.RootDoc interface with hashCode 9030750\nSo there are two separate instances of RootDoc at that point.\n\nThis is a problem because if I'm trying to find the start method via\nreflection, the start method can't be found.  It's using the second hash to\ntry and find the method, so it doesn't see the method signature as == and\nhence doesn't find it.\n\nMy environment CLASSPATH has c:\\apache-ant-1.6.0\\lib\\ant.jar; and\nMyCustomTasks.jar in it.  It doesn't have tools.jar.\n\nGood point on getting ClassLoader info.  I should have tried that.  Here's\nwhat that yielded (getClassLoader call for each RootDoc instance, and then\nwalk upwards from each via getParent):\n\n\"param\" RootDoc CL: java.net.URLClassLoader@18a49e0\nparent of \"param\" RootDoc CL: sun.misc.Launcher$AppClassLoader@e80a59\nparent of parent of \"param\" RootDoc CL: \nsun.misc.Launcher$ExtClassLoader@1ff5ea7\nparent of parent of parent of \"param\" RootDoc CL: null\n\n\"forName\" RootDoc CL: java.net.URLClassLoader@affc70\nparent of \"forName\" RootDoc CL: sun.misc.Launcher$AppClassLoader@e80a59\nparent of parent of \"forName\" RootDoc CL: \nsun.misc.Launcher$ExtClassLoader@1ff5ea7\nparent of parent of parent of \"forName\" RootDoc CL: null\n\nSo apparently there are two ClassLoaders off the main launcher.  Each\napparently has its own instance of RootDoc.  That doesn't sound like a good\nstate for things to be in given that this is such a common class, but I\ndon't know what the rules are for setting up ClassLoader instances or how\nthat's generally supposed to work.\n\nWith Ant 1.5.4, RootDoc was found in the main launcher, so apparently there\nwas only one instance of RootDoc loaded.  That explains why 1.5.4 works and\n1.6.0 doesn't.\n\n"}, {"count": 3, "tags": [], "creator": "conor@apache.org", "attachment_id": null, "is_private": false, "id": 51567, "time": "2004-02-02T04:59:32Z", "bug_id": 26570, "creation_time": "2004-02-02T04:59:32Z", "text": "In your custom task, I presume you are using the URLClassLoader constructor\nwithout specifying a parent. This causes ClassLoader.java to use the\nSystemClassLoader. That is probably not what you want - you really want to use\nyour task's classloader as the parent - that way you'll be sure to get the same\nversion of RootDoc.\n\nTry changing the URLClassLoader constructor to something like\n       URLClassLoader urlc = new URLClassLoader(new URL[] {url},\ngetClass().getClassLoader());\n\nIn Ant 1.6, the system class loader is fairly empty - just consisting of the JVM\nitself and the Ant launcher jar. In Ant 1.5.4, everything is in the system class\nloader.\n\nI do find it odd that your custom task could even load your Foo class since I'm\nnot sure how it is finding tools.jar (which contains RootDoc) when it only uses\nthe system loader and your FooStuff.jar.\n\nThe above change should work in both Ant 1.5.4 and Ant 1.6\n\nBTW, you should not need ant.jar in your classpath.\n     "}, {"count": 4, "tags": [], "bug_id": 26570, "is_private": false, "text": "Point of clarification: The custom task loads\n  FooStuff.jar\n  tools.jar\n  ant.jar\nI was abbreviating.  Pardon any confusion.\n\nYour suggestion works.  Unfortunately I can't change how this class loading\nhappens because that code is not mine.  In real life it's buried in the\ncalls off java.sun.com.javadoc.Main, so I tested this using some separate\ncode just to prove the concept.  Actually what I did was something like\n    ClassLoader cl=Thread.currentThread().getContextClassLoader();\n    Class docletClass=Class.forName(docletName,true,cl);\nwhich worked.\n\nIn one sense this could be considered a Sun bug, however there was a\nsimilar bug submitted (which I can't #$%^ find now even after looking for\n30 minutes, but it had something to do with duplicate class instances in\nreference to an ORB) and Sun's position was essentially that there\nshouldn't be two class instances for the same class period.\n\nSo it seems either they flex, or you folks do, or we're stuck in the\nmiddle.  Any reason not to load tools.jar into the system loader like in\n1.5.4?  \n", "id": 51592, "time": "2004-02-02T14:51:23Z", "creator": "eric@sandservices.com", "creation_time": "2004-02-02T14:51:23Z", "attachment_id": null}, {"count": 5, "attachment_id": null, "bug_id": 26570, "text": "The reason we don't add tools.jar is that we have tried to move that processing\ninto Java code out of platform specific scripts because it is easier to develop\nand maintain across multiple platforms.\n\nA workaround is to force the tools.jar into the boot loader. This works for me\nwith my simple sample:\n\nset ANT_OPTS=-Xbootclasspath/a:%JAVA_HOME%\\lib\\tools.jar\n\n\n", "id": 51633, "time": "2004-02-02T23:22:50Z", "creator": "conor@apache.org", "creation_time": "2004-02-02T23:22:50Z", "tags": [], "is_private": false}, {"count": 6, "tags": [], "bug_id": 26570, "is_private": false, "text": "That was a good idea, and it fixes RootDoc, but my own linkage is still\nbroken at runtime.  What I end up with is a Class instance being found for\nRootDoc where getClassLoader() returns null.  There's still not enough\nloaded in at startup for my custom task to have the view of the world it\nhad when it was compiled. \n\nHere's what is needed in the default ClassLoader:\n    FooStuff.jar (necessary for callbacks into custom task info)\n    tools.jar (so my custom task can get to com.sun.javadoc.RootDoc)\n    ant.jar (so my custom tasks can extend org.apache.tools.ant.Task)\n\nThe first two should be specified in ANT_OPTS, but FooStuff.jar won't load\nwithout Task, Project and other base Ant classes.  In trying to force this\nby specifying all 3 in ANT_OPTS, I've kind of hit a wall: ant.jar won't\nload because it needs AntMain, but when I add ant-launcher.jar in it fails\non an NPE in getResourceSource.  Clearly at this point I am swimming\nagainst the tide of how Ant 1.6.0 wants to launch.  If there were an\nindependent ant-kernel.jar file with just Task, Project and other base Ant\nClass declarations, then this approach might work. \n\nFrom what I can tell, if the base class declarations and the Launcher were\njarred together, that could provide an \"Ant kernel\" capable of boot linkage\nand easy generalized extension.  I think something like that might solve my\nproblem, and provide an easier migration path from 1.5.4 where ant.jar was\nfully self-contained.  It might also help segmentation of custom tasks,\nsince they would compile against ant-kernel.jar and only require that at\nruntime, which allows for more flexibility in what gets launched.  Any\nchance of something like this in the works? \n\nAny other thoughts/ideas/suggestions? \n\n", "id": 51675, "time": "2004-02-03T19:55:52Z", "creator": "eric@sandservices.com", "creation_time": "2004-02-03T19:55:52Z", "attachment_id": null}, {"attachment_id": null, "tags": [], "creator": "conor@apache.org", "is_private": false, "count": 7, "id": 51685, "time": "2004-02-04T04:32:44Z", "bug_id": 26570, "creation_time": "2004-02-04T04:32:44Z", "text": "Eric, let's rollback a bit. You have a custom task that you cannot change -\ncorrect? This custom task launches Javadoc? I'm not really clear on the train of\nevents here - how it constructs its ClassLoader and how the task ends up loading\nRootDoc. Is it using the context classloader? Not sure what your reference to\nthat implied.\n\nOverall I would like to see your custom task just being loaded with a taskdef\ncontaining a classpath of FooStuff.jar. It should not need tools.jar and ant.jar\nas they should be available to the taskdef's parent classloader. IOW, you should\nremove FooStuff.jar from your classpath and add a classpath to the taskdef.\n\n"}, {"attachment_id": null, "tags": [], "creator": "eric@sandservices.com", "is_private": false, "count": 8, "id": 51703, "time": "2004-02-04T15:48:05Z", "bug_id": 26570, "creation_time": "2004-02-04T15:48:05Z", "text": "Indeed, let's recap.\n\nAt compile time my code references ant.jar and tools.jar which completes\nthe linkage references.  At run time, these classes are only available in\nthe VM below the new Ant ClassLoader, so any code which starts from the\ndefault system ClassLoader will not have access.\n\nWhile it is possible to write code which always starts from the new Ant\nClassLoader, not all existing code works this way.  Some of this existing\ncode is not under our control, and is therefore broken.\n\nAnt needs to somehow provide runtime access that mirrors what is happening\nat compile time, or provide a way for developers to set this up.\n"}, {"count": 9, "tags": [], "creator": "conor@apache.org", "attachment_id": null, "is_private": false, "id": 51751, "time": "2004-02-05T07:49:05Z", "bug_id": 26570, "creation_time": "2004-02-05T07:49:05Z", "text": "If you prefer you may use the old ant.bat/lcp.bat combination to start Ant\nwithout the new launch code. This should give you the same class loader config\nas Ant 1.5. You may run into command line length limits under Windows when doing\nso. If necessary this could be added to the release as ant-compat.bat.\n\nI would note that creation of a URLClassLoader without specifying a parent,\nassumes the availability of classes in the system loader. This assumption, in\nturn, limits you to certain configurations of Ant. For example, an IDE which\nruns Ant natively, even based on Ant 1.5, is unlikely to run your build properly\nsince it's system loader will not necessarily have the required classes.\n\nThis is not quite an issue of Ant providing a runtime environment that is the\nsame as compile time. Ant does that already as a task has access to tools.jar,\nant.jar and the ant libraries. Rather it is the code that is in the custom task\nthat is not providing that runtime environment, by making assumptions about the\ncontent of the system classloader.\n\nI was hoping you would clarify the usage of the Context ClassLoader you\nmentioned briefly as it may offer a workaround in the form of a wrapper task or\nsomething similar. IOW, derive a new task from the one you can't change and in\nit's execute methos set the context classloader, then invoke super.execute(). If\nthe custom task uses the context class loader you'd have a workaround."}, {"count": 10, "tags": [], "creator": "eric@sandservices.com", "text": "The point about IDEs is interesting.  I've often wondered why you folks\nstill fork a process for javadoc even though there is a programmatic\ninterface, but since javadoc uses the default class loader you would\nprobably have the same problem we are facing.  If you wanted to call\nprogrammatically, you would depend on the IDE having loaded tools.jar\nin the default system context.\n\nIf an IDE provides for setting what gets loaded into the default system\ncontext when calling another tool, then your programmatic javadoc call\ncould work, and so could our build, except for the fact that our compile\ntime linkage is not the same as our runtime linkage.\n\nI still think that a single .jar file that is available for resolution at\ncompile time, and part of the main system context at run time, would make\nlife much better for project-specific custom tasks.  Why not provide an\nant-kernel.jar with just the base Ant definitions in it (like Task, Project\netc) plus a launcher for the rest?\n", "id": 52012, "time": "2004-02-09T20:01:48Z", "bug_id": 26570, "creation_time": "2004-02-09T20:01:48Z", "is_private": false, "attachment_id": null}, {"count": 11, "attachment_id": null, "bug_id": 26570, "is_private": false, "id": 118466, "time": "2008-07-10T07:32:57Z", "creator": "bodewig@apache.org", "creation_time": "2008-07-10T07:32:57Z", "tags": [], "text": "I don't expect us to change our classloader structure, so WONTFIX is realistic."}]