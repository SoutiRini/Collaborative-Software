[{"count": 0, "tags": [], "bug_id": 43435, "attachment_id": null, "text": "The following codes are in the memberDisappeared method of \norg.apache.catalina.tribes.tipis.AbstractReplicatedMap. \n\n  public void memberDisappeared(Member member) {\n        boolean removed = false;\n        synchronized (mapMembers) {\n            removed = (mapMembers.remove(member) != null );\n        }\n        \n        Iterator i = super.entrySet().iterator();\n        while (i.hasNext()) {\n        ** omit Relocate of session. **\n        \nThis means relocate of the session is done every time after \nmember is deleted from mapMembers \n(The value of removed : regardless of true/false). \n\nI think that if the member has already been deleted, \nthe relocate of the session need not be done. \n\nThis most strongly influencing is \nstop Tomcat(setting TcpFailureDetector) in Cluster at a high load\n(A lot of requests are processed at the same time).\n\nAbove-mentioned case is \nThe relocate of the session is done at all requests \nwhere memberDisappeared is detected by TcpFailureDetector. \n\nThe relocate of the session is a little heavy processing. \nIMHO, this is not good thing.\n\nI made AbstractReplicatedMap's patch.\n\nIndex: /tomcat6-\ntrunk/java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java\n===================================================================\n--- /tomcat6-\ntrunk/java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java\n\t(revision 577691)\n+++ /tomcat6-\ntrunk/java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java\n\t(working copy)\n@@ -713,6 +713,7 @@\n         boolean removed = false;\n         synchronized (mapMembers) {\n             removed = (mapMembers.remove(member) != null );\n+            if (!removed) return;\n         }\n         \n         Iterator i = super.entrySet().iterator();\n\nRegards.", "id": 108441, "time": "2007-09-20T04:51:07Z", "creator": "keiichi.fujino@gmail.com", "creation_time": "2007-09-20T04:51:07Z", "is_private": false}, {"attachment_id": null, "tags": [], "creator": "fhanik@apache.org", "is_private": false, "count": 1, "id": 108480, "time": "2007-09-21T11:26:36Z", "bug_id": 43435, "creation_time": "2007-09-21T11:26:36Z", "text": "Fixed.\nSince memberDisappeared is called when any member goes away, not just map members.\nIf you see scenarios where the memberDisappeared is called multiple times with\nthe same member, please let me know, as that should not happen"}, {"count": 2, "tags": [], "creator": "keiichi.fujino@gmail.com", "is_private": false, "id": 108567, "attachment_id": null, "bug_id": 43435, "creation_time": "2007-09-25T03:03:50Z", "time": "2007-09-25T03:03:50Z", "text": "(In reply to comment #1)\n> Fixed.\n\nThanks for the correction.\n\n> Since memberDisappeared is called when any member goes away, not just map \nmembers.\n> If you see scenarios where the memberDisappeared is called multiple times \nwith\n> the same member, please let me know, as that should not happen\n\nI think that AbstractReplicatedMap.memberDisappeared is called is the \nfollowing cases.\n\n1:McastServiceImpl$run -> ... -> AbstractReplicatedMap.memberDisappeared\n2:GroupChannel.heartbeat() -> ... -> AbstractReplicatedMap.memberDisappeared\n3:GroupChannel.send  -> ReplicationTransmitter.sendMessage -> ... ->\n   -> ChannelException occurs \n   -> TcpFailureDetector.memberDisappeared\n   -> AbstractReplicatedMap.memberDisappeared\n\nCase3 says.\nWhen Tomcat in the cluster is downed, \nthe all of thread sending the replication message to downed Tomcat does throw \nChannelException and calls TcpFailureDetector.memberDisappeared.\nTcpFailureDetector.memberDisappeared calls \nAbstractReplicatedMap.memberDisappeared.\n\nIf the replication message is sended to downed Tomcat by multiple threads, \nAbstractReplicatedMap.memberDisappeared is called multiple times with the same \nmember.\n\nThe following logs are repeatedly output. \n# log.debug(\"Member[\"+member+\"] disappeared, but was not present in the map.\");\n# is called.\n\n***********log*************\n...\nSep 25, 2007 5:27:10 PM \norg.apache.catalina.tribes.group.interceptors.TcpFailureDetector \nmemberDisappeared\nINFO: Received memberDisappeared\n[org.apache.catalina.tribes.membership.MemberImpl\n[tcp://XXXXXXXX:4001,XXXXXXXX,4001, alive=22797,id={74 41 4 115 77 -55 69 21 -\n68 -127 79 110 -55 45 -36 -45 }, payload={}, command={}, domain={}, ]] \nmessage. Will verify.\nSep 25, 2007 5:27:10 PM org.apache.catalina.tribes.tipis.AbstractReplicatedMap \nmemberDisappeared\nFINE: Member[org.apache.catalina.tribes.membership.MemberImpl\n[tcp://XXXXXXXX:4001,XXXXXXXX,4001, alive=22797,id={74 41 4 115 77 -55 69 21 -\n68 -127 79 110 -55 45 -36 -45 }, payload={}, command={}, domain={}, ]] \ndisappeared, but was not present in the map.\nSep 25, 2007 5:27:10 PM org.apache.catalina.tribes.tipis.AbstractReplicatedMap \nreplicate\nSEVERE: Unable to replicate data.\norg.apache.catalina.tribes.ChannelException: Send failed, attempt:2 max:1; \nFaulty members:tcp://XXXXXXXX:4001; \n     at org.apache.catalina.tribes.transport.nio.ParallelNioSender.doLoop\n(ParallelNioSender.java:172)\n     at org.apache.catalina.tribes.transport.nio.ParallelNioSender.sendMessage\n(ParallelNioSender.java:78)\n     at \norg.apache.catalina.tribes.transport.nio.PooledParallelSender.sendMessage\n(PooledParallelSender.java:53)\n     at org.apache.catalina.tribes.transport.ReplicationTransmitter.sendMessage\n(ReplicationTransmitter.java:80)\n     at org.apache.catalina.tribes.group.ChannelCoordinator.sendMessage\n(ChannelCoordinator.java:78)\n     at org.apache.catalina.tribes.group.ChannelInterceptorBase.sendMessage\n(ChannelInterceptorBase.java:75)\n     at \norg.apache.catalina.tribes.group.interceptors.TcpFailureDetector.sendMessage\n(TcpFailureDetector.java:87)\n     at org.apache.catalina.tribes.group.ChannelInterceptorBase.sendMessage\n(ChannelInterceptorBase.java:75)\n     at \norg.apache.catalina.tribes.group.interceptors.MessageDispatchInterceptor.sendMe\nssage(MessageDispatchInterceptor.java:73)\n     at org.apache.catalina.tribes.group.ChannelInterceptorBase.sendMessage\n(ChannelInterceptorBase.java:75)\n     at org.apache.catalina.tribes.group.GroupChannel.send\n(GroupChannel.java:216)\n     at org.apache.catalina.tribes.group.GroupChannel.send\n(GroupChannel.java:175)\n     at org.apache.catalina.tribes.tipis.AbstractReplicatedMap.replicate\n(AbstractReplicatedMap.java:421)\n     at org.apache.catalina.ha.session.BackupManager.requestCompleted\n(BackupManager.java:131)\n     at org.apache.catalina.ha.tcp.ReplicationValve.send\n(ReplicationValve.java:548)\n     at org.apache.catalina.ha.tcp.ReplicationValve.sendMessage\n(ReplicationValve.java:535)\n     at \norg.apache.catalina.ha.tcp.ReplicationValve.sendSessionReplicationMessage\n(ReplicationValve.java:517)\n     at org.apache.catalina.ha.tcp.ReplicationValve.sendReplicationMessage\n(ReplicationValve.java:428)\n     at org.apache.catalina.ha.tcp.ReplicationValve.invoke\n(ReplicationValve.java:362)\n     at org.apache.catalina.valves.ErrorReportValve.invoke\n(ErrorReportValve.java:102)\n    ... omit ...\nCaused by: java.net.ConnectException: Connection refused: no further \ninformation\n     at sun.nio.ch.SocketChannelImpl.checkConnect(Native Method)\n     at sun.nio.ch.SocketChannelImpl.finishConnect(SocketChannelImpl.java:525)\n     at org.apache.catalina.tribes.transport.nio.NioSender.process\n(NioSender.java:88)\n     at org.apache.catalina.tribes.transport.nio.ParallelNioSender.doLoop\n(ParallelNioSender.java:130)\n     ... 26 more\n...\n\nRegards.\n"}]