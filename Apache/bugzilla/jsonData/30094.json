[{"count": 0, "tags": [], "bug_id": 30094, "attachment_id": null, "is_private": false, "id": 60590, "time": "2004-07-14T07:14:09Z", "creator": "jbleijen@csc.com", "creation_time": "2004-07-14T07:14:09Z", "text": "-Added NIO support to FileUtils \n-Changed call to File.exists(), File.isDir() & File.lastModified() in Resource \nto use a lazy approach\n\n/*\n * Copyright  2000-2004 The Apache Software Foundation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n */\n\npackage org.apache.tools.ant;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Hashtable;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.Vector;\n\nimport org.apache.tools.ant.taskdefs.condition.Os;\nimport org.apache.tools.ant.types.Resource;\nimport org.apache.tools.ant.types.ResourceFile;\nimport org.apache.tools.ant.types.ResourceFactory;\nimport org.apache.tools.ant.types.selectors.FileSelector;\nimport org.apache.tools.ant.types.selectors.SelectorScanner;\nimport org.apache.tools.ant.types.selectors.SelectorUtils;\nimport org.apache.tools.ant.util.FileUtils;\n\n/**\n * Class for scanning a directory for files/directories which match certain\n * criteria.\n * <p>\n * These criteria consist of selectors and patterns which have been specified.\n * With the selectors you can select which files you want to have included.\n * Files which are not selected are excluded. With patterns you can include\n * or exclude files based on their filename.\n * <p>\n * The idea is simple. A given directory is recursively scanned for all files\n * and directories. Each file/directory is matched against a set of selectors,\n * including special support for matching against filenames with include and\n * and exclude patterns. Only files/directories which match at least one\n * pattern of the include pattern list or other file selector, and don't match\n * any pattern of the exclude pattern list or fail to match against a required\n * selector will be placed in the list of files/directories found.\n * <p>\n * When no list of include patterns is supplied, \"**\" will be used, which\n * means that everything will be matched. When no list of exclude patterns is\n * supplied, an empty list is used, such that nothing will be excluded. When\n * no selectors are supplied, none are applied.\n * <p>\n * The filename pattern matching is done as follows:\n * The name to be matched is split up in path segments. A path segment is the\n * name of a directory or file, which is bounded by\n * <code>File.separator</code> ('/' under UNIX, '\\' under Windows).\n * For example, \"abc/def/ghi/xyz.java\" is split up in the segments \"abc\",\n * \"def\",\"ghi\" and \"xyz.java\".\n * The same is done for the pattern against which should be matched.\n * <p>\n * The segments of the name and the pattern are then matched against each\n * other. When '**' is used for a path segment in the pattern, it matches\n * zero or more path segments of the name.\n * <p>\n * There is a special case regarding the use of <code>File.separator</code>s\n * at the beginning of the pattern and the string to match:<br>\n * When a pattern starts with a <code>File.separator</code>, the string\n * to match must also start with a <code>File.separator</code>.\n * When a pattern does not start with a <code>File.separator</code>, the\n * string to match may not start with a <code>File.separator</code>.\n * When one of these rules is not obeyed, the string will not\n * match.\n * <p>\n * When a name path segment is matched against a pattern path segment, the\n * following special characters can be used:<br>\n * '*' matches zero or more characters<br>\n * '?' matches one character.\n * <p>\n * Examples:\n * <p>\n * \"**\\*.class\" matches all .class files/dirs in a directory tree.\n * <p>\n * \"test\\a??.java\" matches all files/dirs which start with an 'a', then two\n * more characters and then \".java\", in a directory called test.\n * <p>\n * \"**\" matches everything in a directory tree.\n * <p>\n * \"**\\test\\**\\XYZ*\" matches all files/dirs which start with \"XYZ\" and where\n * there is a parent directory called test (e.g. \"abc\\test\\def\\ghi\\XYZ123\").\n * <p>\n * Case sensitivity may be turned off if necessary. By default, it is\n * turned on.\n * <p>\n * Example of usage:\n * <pre>\n *   String[] includes = {\"**\\\\*.class\"};\n *   String[] excludes = {\"modules\\\\*\\\\**\"};\n *   ds.setIncludes(includes);\n *   ds.setExcludes(excludes);\n *   ds.setBasedir(new File(\"test\"));\n *   ds.setCaseSensitive(true);\n *   ds.scan();\n *\n *   System.out.println(\"FILES:\");\n *   String[] files = ds.getIncludedFiles();\n *   for (int i = 0; i < files.length; i++) {\n *     System.out.println(files[i]);\n *   }\n * </pre>\n * This will scan a directory called test for .class files, but excludes all\n * files in all proper subdirectories of a directory called \"modules\"\n *\n */\npublic class DirectoryScanner\n       implements FileScanner, SelectorScanner, ResourceFactory {\n\n    /** Is OpenVMS the operating system we're running on? */\n    private static final boolean ON_VMS = Os.isFamily(\"openvms\");\n\n    /**\n     * Patterns which should be excluded by default.\n     *\n     * <p>Note that you can now add patterns to the list of default\n     * excludes.  Added patterns will not become part of this array\n     * that has only been kept around for backwards compatibility\n     * reasons.</p>\n     *\n     * @deprecated use the {@link #getDefaultExcludes\n     * getDefaultExcludes} method instead.\n     */\n    protected static final String[] DEFAULTEXCLUDES = {\n        // Miscellaneous typical temporary files\n        \"**/*~\",\n        \"**/#*#\",\n        \"**/.#*\",\n        \"**/%*%\",\n        \"**/._*\",\n\n        // CVS\n        \"**/CVS\",\n        \"**/CVS/**\",\n        \"**/.cvsignore\",\n\n        // SCCS\n        \"**/SCCS\",\n        \"**/SCCS/**\",\n\n        // Visual SourceSafe\n        \"**/vssver.scc\",\n\n        // Subversion\n        \"**/.svn\",\n        \"**/.svn/**\",\n\n        // Mac\n        \"**/.DS_Store\"\n    };\n\n    /**\n     * Patterns which should be excluded by default.\n     *\n     * @see #addDefaultExcludes()\n     */\n    private static Vector defaultExcludes = new Vector();\n    static {\n        resetDefaultExcludes();\n    }\n\n    /** The base directory to be scanned. */\n    protected File basedir;\n\n    /** The patterns for the files to be included. */\n    protected String[] includes;\n\n    /** The patterns for the files to be excluded. */\n    protected String[] excludes;\n\n    /** Selectors that will filter which files are in our candidate list. */\n    protected FileSelector[] selectors = null;\n\n    /** The files which matched at least one include and no excludes\n     *  and were selected.\n     */\n    protected Vector filesIncluded;\n\n    /** The files which did not match any includes or selectors. */\n    protected Vector filesNotIncluded;\n\n    /**\n     * The files which matched at least one include and at least\n     * one exclude.\n     */\n    protected Vector filesExcluded;\n\n    /** The directories which matched at least one include and no excludes\n     *  and were selected.\n     */\n    protected Vector dirsIncluded;\n\n    /** The directories which were found and did not match any includes. */\n    protected Vector dirsNotIncluded;\n\n    /**\n     * The directories which matched at least one include and at least one\n     * exclude.\n     */\n    protected Vector dirsExcluded;\n\n    /** The files which matched at least one include and no excludes and\n     *  which a selector discarded.\n     */\n    protected Vector filesDeselected;\n\n    /** The directories which matched at least one include and no excludes\n     *  but which a selector discarded.\n     */\n    protected Vector dirsDeselected;\n\n    /** Whether or not our results were built by a slow scan. */\n    protected boolean haveSlowResults = false;\n\n    /**\n     * Whether or not the file system should be treated as a case sensitive\n     * one.\n     */\n    protected boolean isCaseSensitive = true;\n\n    /**\n     * Whether or not symbolic links should be followed.\n     *\n     * @since Ant 1.5\n     */\n    private boolean followSymlinks = true;\n\n    /** Helper. */\n    private static final FileUtils FILE_UTILS = FileUtils.newFileUtils();\n\n    /** Whether or not everything tested so far has been included. */\n    protected boolean everythingIncluded = true;\n\n    /**\n     * Sole constructor.\n     */\n    public DirectoryScanner() {\n    }\n\n    /**\n     * Tests whether or not a given path matches the start of a given\n     * pattern up to the first \"**\".\n     * <p>\n     * This is not a general purpose test and should only be used if you\n     * can live with false positives. For example, <code>pattern=**\\a</code>\n     * and <code>str=b</code> will yield <code>true</code>.\n     *\n     * @param pattern The pattern to match against. Must not be\n     *                <code>null</code>.\n     * @param str     The path to match, as a String. Must not be\n     *                <code>null</code>.\n     *\n     * @return whether or not a given path matches the start of a given\n     * pattern up to the first \"**\".\n     */\n    protected static boolean matchPatternStart(String pattern, String str) {\n        return SelectorUtils.matchPatternStart(pattern, str);\n    }\n    /**\n     * Tests whether or not a given path matches the start of a given\n     * pattern up to the first \"**\".\n     * <p>\n     * This is not a general purpose test and should only be used if you\n     * can live with false positives. For example, <code>pattern=**\\a</code>\n     * and <code>str=b</code> will yield <code>true</code>.\n     *\n     * @param pattern The pattern to match against. Must not be\n     *                <code>null</code>.\n     * @param str     The path to match, as a String. Must not be\n     *                <code>null</code>.\n     * @param isCaseSensitive Whether or not matching should be performed\n     *                        case sensitively.\n     *\n     * @return whether or not a given path matches the start of a given\n     * pattern up to the first \"**\".\n     */\n    protected static boolean matchPatternStart(String pattern, String str,\n                                               boolean isCaseSensitive) {\n        return SelectorUtils.matchPatternStart(pattern, str, isCaseSensitive);\n    }\n\n    /**\n     * Tests whether or not a given path matches a given pattern.\n     *\n     * @param pattern The pattern to match against. Must not be\n     *                <code>null</code>.\n     * @param str     The path to match, as a String. Must not be\n     *                <code>null</code>.\n     *\n     * @return <code>true</code> if the pattern matches against the string,\n     *         or <code>false</code> otherwise.\n     */\n    protected static boolean matchPath(String pattern, String str) {\n        return SelectorUtils.matchPath(pattern, str);\n    }\n\n    /**\n     * Tests whether or not a given path matches a given pattern.\n     *\n     * @param pattern The pattern to match against. Must not be\n     *                <code>null</code>.\n     * @param str     The path to match, as a String. Must not be\n     *                <code>null</code>.\n     * @param isCaseSensitive Whether or not matching should be performed\n     *                        case sensitively.\n     *\n     * @return <code>true</code> if the pattern matches against the string,\n     *         or <code>false</code> otherwise.\n     */\n    protected static boolean matchPath(String pattern, String str,\n                                       boolean isCaseSensitive) {\n        return SelectorUtils.matchPath(pattern, str, isCaseSensitive);\n    }\n\n    /**\n     * Tests whether or not a string matches against a pattern.\n     * The pattern may contain two special characters:<br>\n     * '*' means zero or more characters<br>\n     * '?' means one and only one character\n     *\n     * @param pattern The pattern to match against.\n     *                Must not be <code>null</code>.\n     * @param str     The string which must be matched against the pattern.\n     *                Must not be <code>null</code>.\n     *\n     * @return <code>true</code> if the string matches against the pattern,\n     *         or <code>false</code> otherwise.\n     */\n    public static boolean match(String pattern, String str) {\n        return SelectorUtils.match(pattern, str);\n    }\n\n    /**\n     * Tests whether or not a string matches against a pattern.\n     * The pattern may contain two special characters:<br>\n     * '*' means zero or more characters<br>\n     * '?' means one and only one character\n     *\n     * @param pattern The pattern to match against.\n     *                Must not be <code>null</code>.\n     * @param str     The string which must be matched against the pattern.\n     *                Must not be <code>null</code>.\n     * @param isCaseSensitive Whether or not matching should be performed\n     *                        case sensitively.\n     *\n     *\n     * @return <code>true</code> if the string matches against the pattern,\n     *         or <code>false</code> otherwise.\n     */\n    protected static boolean match(String pattern, String str,\n                                   boolean isCaseSensitive) {\n        return SelectorUtils.match(pattern, str, isCaseSensitive);\n    }\n\n\n    /**\n     * Get the list of patterns that should be excluded by default.\n     *\n     * @return An array of <code>String</code> based on the current\n     *         contents of the <code>defaultExcludes</code>\n     *         <code>Vector</code>.\n     *\n     * @since Ant 1.6\n     */\n    public static String[] getDefaultExcludes() {\n        return (String[]) defaultExcludes.toArray(new String[defaultExcludes\n                                                             .size()]);\n    }\n\n    /**\n     * Add a pattern to the default excludes unless it is already a\n     * default exclude.\n     *\n     * @param s   A string to add as an exclude pattern.\n     * @return    <code>true</code> if the string was added\n     *            <code>false</code> if it already\n     *            existed.\n     *\n     * @since Ant 1.6\n     */\n    public static boolean addDefaultExclude(String s) {\n        if (defaultExcludes.indexOf(s) == -1) {\n            defaultExcludes.add(s);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Remove a string if it is a default exclude.\n     *\n     * @param s   The string to attempt to remove.\n     * @return    <code>true</code> if <code>s</code> was a default\n     *            exclude (and thus was removed),\n     *            <code>false</code> if <code>s</code> was not\n     *            in the default excludes list to begin with\n     *\n     * @since Ant 1.6\n     */\n    public static boolean removeDefaultExclude(String s) {\n        return defaultExcludes.remove(s);\n    }\n\n    /**\n     *  Go back to the hard wired default exclude patterns\n     *\n     * @since Ant 1.6\n     */\n    public static void resetDefaultExcludes() {\n    defaultExcludes = new Vector();\n\n        for (int i = 0; i < DEFAULTEXCLUDES.length; i++) {\n            defaultExcludes.add(DEFAULTEXCLUDES[i]);\n        }\n    }\n\n    /**\n     * Sets the base directory to be scanned. This is the directory which is\n     * scanned recursively. All '/' and '\\' characters are replaced by\n     * <code>File.separatorChar</code>, so the separator used need not match\n     * <code>File.separatorChar</code>.\n     *\n     * @param basedir The base directory to scan.\n     *                Must not be <code>null</code>.\n     */\n    public void setBasedir(String basedir) {\n        setBasedir(new File(basedir.replace('/', File.separatorChar).replace(\n                '\\\\', File.separatorChar)));\n    }\n\n    /**\n     * Sets the base directory to be scanned. This is the directory which is\n     * scanned recursively.\n     *\n     * @param basedir The base directory for scanning.\n     *                Should not be <code>null</code>.\n     */\n    public void setBasedir(File basedir) {\n        this.basedir = basedir;\n    }\n\n    /**\n     * Returns the base directory to be scanned.\n     * This is the directory which is scanned recursively.\n     *\n     * @return the base directory to be scanned\n     */\n    public File getBasedir() {\n        return basedir;\n    }\n\n    /**\n     * Find out whether include exclude patterns are matched in a\n     * case sensitive way\n     * @return whether or not the scanning is case sensitive\n     * @since ant 1.6\n     */\n    public boolean isCaseSensitive() {\n        return isCaseSensitive;\n    }\n    /**\n     * Sets whether or not include and exclude patterns are matched\n     * in a case sensitive way\n     *\n     * @param isCaseSensitive whether or not the file system should be\n     *                        regarded as a case sensitive one\n     */\n    public void setCaseSensitive(boolean isCaseSensitive) {\n        this.isCaseSensitive = isCaseSensitive;\n    }\n\n    /**\n     * gets whether or not a DirectoryScanner follows symbolic links\n     *\n     * @return flag indicating whether symbolic links should be followed\n     *\n     * @since ant 1.6\n     */\n    public boolean isFollowSymlinks() {\n        return followSymlinks;\n    }\n\n    /**\n     * Sets whether or not symbolic links should be followed.\n     *\n     * @param followSymlinks whether or not symbolic links should be followed\n     */\n    public void setFollowSymlinks(boolean followSymlinks) {\n        this.followSymlinks = followSymlinks;\n    }\n\n    /**\n     * Sets the list of include patterns to use. All '/' and '\\' characters\n     * are replaced by <code>File.separatorChar</code>, so the separator used\n     * need not match <code>File.separatorChar</code>.\n     * <p>\n     * When a pattern ends with a '/' or '\\', \"**\" is appended.\n     *\n     * @param includes A list of include patterns.\n     *                 May be <code>null</code>, indicating that all files\n     *                 should be included. If a non-<code>null</code>\n     *                 list is given, all elements must be\n     * non-<code>null</code>.\n     */\n    public void setIncludes(String[] includes) {\n        if (includes == null) {\n            this.includes = null;\n        } else {\n            this.includes = new String[includes.length];\n            for (int i = 0; i < includes.length; i++) {\n                String pattern;\n                pattern = includes[i].replace('/', File.separatorChar).replace(\n                        '\\\\', File.separatorChar);\n                if (pattern.endsWith(File.separator)) {\n                    pattern += \"**\";\n                }\n                this.includes[i] = pattern;\n            }\n        }\n    }\n\n\n    /**\n     * Sets the list of exclude patterns to use. All '/' and '\\' characters\n     * are replaced by <code>File.separatorChar</code>, so the separator used\n     * need not match <code>File.separatorChar</code>.\n     * <p>\n     * When a pattern ends with a '/' or '\\', \"**\" is appended.\n     *\n     * @param excludes A list of exclude patterns.\n     *                 May be <code>null</code>, indicating that no files\n     *                 should be excluded. If a non-<code>null</code> list is\n     *                 given, all elements must be non-<code>null</code>.\n     */\n    public void setExcludes(String[] excludes) {\n        if (excludes == null) {\n            this.excludes = null;\n        } else {\n            this.excludes = new String[excludes.length];\n            for (int i = 0; i < excludes.length; i++) {\n                String pattern;\n                pattern = excludes[i].replace('/', File.separatorChar).replace(\n                        '\\\\', File.separatorChar);\n                if (pattern.endsWith(File.separator)) {\n                    pattern += \"**\";\n                }\n                this.excludes[i] = pattern;\n            }\n        }\n    }\n\n\n    /**\n     * Sets the selectors that will select the filelist.\n     *\n     * @param selectors specifies the selectors to be invoked on a scan\n     */\n    public void setSelectors(FileSelector[] selectors) {\n        this.selectors = selectors;\n    }\n\n\n    /**\n     * Returns whether or not the scanner has included all the files or\n     * directories it has come across so far.\n     *\n     * @return <code>true</code> if all files and directories which have\n     *         been found so far have been included.\n     */\n    public boolean isEverythingIncluded() {\n        return everythingIncluded;\n    }\n\n    /**\n     * Scans the base directory for files which match at least one include\n     * pattern and don't match any exclude patterns. If there are selectors\n     * then the files must pass muster there, as well.\n     *\n     * @exception IllegalStateException if the base directory was set\n     *            incorrectly (i.e. if it is <code>null</code>, doesn't exist,\n     *            or isn't a directory).\n     */\n    public void scan() throws IllegalStateException {\n        if (basedir == null) {\n            throw new IllegalStateException(\"No basedir set\");\n        }\n        if (!basedir.exists()) {\n            throw new IllegalStateException(\"basedir \" + basedir\n                                            + \" does not exist\");\n        }\n        if (!basedir.isDirectory()) {\n            throw new IllegalStateException(\"basedir \" + basedir\n                                            + \" is not a directory\");\n        }\n\n        if (includes == null) {\n            // No includes supplied, so set it to 'matches all'\n            includes = new String[1];\n            includes[0] = \"**\";\n        }\n        if (excludes == null) {\n            excludes = new String[0];\n        }\n\n        filesIncluded    = new Vector();\n        filesNotIncluded = new Vector();\n        filesExcluded    = new Vector();\n        filesDeselected  = new Vector();\n        dirsIncluded     = new Vector();\n        dirsNotIncluded  = new Vector();\n        dirsExcluded     = new Vector();\n        dirsDeselected   = new Vector();\n\n        if (isIncluded(\"\")) {\n            if (!isExcluded(\"\")) {\n                if (isSelected(\"\", basedir)) {\n                    dirsIncluded.addElement(\"\");\n                } else {\n                    dirsDeselected.addElement(\"\");\n                }\n            } else {\n                dirsExcluded.addElement(\"\");\n            }\n        } else {\n            dirsNotIncluded.addElement(\"\");\n        }\n        checkIncludePatterns();\n        clearCaches();\n    }\n\n    /**\n     * this routine is actually checking all the include patterns in\n     * order to avoid scanning everything under base dir\n     * @since ant1.6\n     */\n    private void checkIncludePatterns() {\n        Hashtable newroots = new Hashtable();\n        // put in the newroots vector the include patterns without\n        // wildcard tokens\n        for (int icounter = 0; icounter < includes.length; icounter++) {\n            String newpattern =\n                SelectorUtils.rtrimWildcardTokens(includes[icounter]);\n            newroots.put(newpattern, includes[icounter]);\n        }\n\n        if (newroots.containsKey(\"\")) {\n            // we are going to scan everything anyway\n            scandir(basedir, \"\", true);\n        } else {\n            // only scan directories that can include matched files or\n            // directories\n            Enumeration enum2 = newroots.keys();\n\n            File canonBase = null;\n            try {\n                canonBase = basedir.getCanonicalFile();\n            } catch (IOException ex) {\n                throw new BuildException(ex);\n            }\n\n            while (enum2.hasMoreElements()) {\n                String currentelement = (String) enum2.nextElement();\n                String originalpattern = (String) newroots.get(currentelement);\n                File myfile = new File(basedir, currentelement);\n\n                if (myfile.exists()) {\n                    // may be on a case insensitive file system.  We want\n                    // the results to show what's really on the disk, so\n                    // we need to double check.\n                    try {\n                        File canonFile = myfile.getCanonicalFile();\n                        String path = FILE_UTILS.removeLeadingPath(canonBase,\n                                                                  canonFile);\n                        if (!path.equals(currentelement) || ON_VMS) {\n                            myfile = findFile(basedir, currentelement);\n                            if (myfile != null) {\n                                currentelement =\n                                    FILE_UTILS.removeLeadingPath(basedir,\n                                                                 myfile);\n                            }\n                        }\n                    } catch (IOException ex) {\n                        throw new BuildException(ex);\n                    }\n                }\n\n                if ((myfile == null || !myfile.exists()) && !isCaseSensitive) {\n                    File f = findFileCaseInsensitive(basedir, currentelement);\n                    if (f.exists()) {\n                        // adapt currentelement to the case we've\n                        // actually found\n                        currentelement = FILE_UTILS.removeLeadingPath(basedir,\n                                                                     f);\n                        myfile = f;\n                    }\n                }\n\n                if (myfile != null && myfile.exists()) {\n                    if (!followSymlinks\n                        && isSymlink(basedir, currentelement)) {\n                        continue;\n                    }\n\n                    if (myfile.isDirectory()) {\n                        if (isIncluded(currentelement)\n                            && currentelement.length() > 0) {\n                            accountForIncludedDir(currentelement, myfile, true);\n                        }  else {\n                            if (currentelement.length() > 0) {\n                                if (currentelement.charAt(currentelement\n                                                          .length() - 1)\n                                    != File.separatorChar) {\n                                    currentelement =\n                                        currentelement + File.separatorChar;\n                                }\n                            }\n                            scandir(myfile, currentelement, true);\n                        }\n                    } else {\n                        if (isCaseSensitive\n                            && originalpattern.equals(currentelement)) {\n                            accountForIncludedFile(currentelement, myfile);\n                        } else if (!isCaseSensitive\n                                   && originalpattern\n                                   .equalsIgnoreCase(currentelement)) {\n                            accountForIncludedFile(currentelement, myfile);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Top level invocation for a slow scan. A slow scan builds up a full\n     * list of excluded/included files/directories, whereas a fast scan\n     * will only have full results for included files, as it ignores\n     * directories which can't possibly hold any included files/directories.\n     * <p>\n     * Returns immediately if a slow scan has already been completed.\n     */\n    protected void slowScan() {\n        if (haveSlowResults) {\n            return;\n        }\n\n        String[] excl = new String[dirsExcluded.size()];\n        dirsExcluded.copyInto(excl);\n\n        String[] notIncl = new String[dirsNotIncluded.size()];\n        dirsNotIncluded.copyInto(notIncl);\n\n        for (int i = 0; i < excl.length; i++) {\n            if (!couldHoldIncluded(excl[i])) {\n                scandir(new File(basedir, excl[i]),\n                        excl[i] + File.separator, false);\n            }\n        }\n\n        for (int i = 0; i < notIncl.length; i++) {\n            if (!couldHoldIncluded(notIncl[i])) {\n                scandir(new File(basedir, notIncl[i]),\n                        notIncl[i] + File.separator, false);\n            }\n        }\n\n        haveSlowResults  = true;\n    }\n\n    /**\n     * Scans the given directory for files and directories. Found files and\n     * directories are placed in their respective collections, based on the\n     * matching of includes, excludes, and the selectors.  When a directory\n     * is found, it is scanned recursively.\n     *\n     * @param dir   The directory to scan. Must not be <code>null</code>.\n     * @param vpath The path relative to the base directory (needed to\n     *              prevent problems with an absolute path when using\n     *              dir). Must not be <code>null</code>.\n     * @param fast  Whether or not this call is part of a fast scan.\n     *\n     * @see #filesIncluded\n     * @see #filesNotIncluded\n     * @see #filesExcluded\n     * @see #dirsIncluded\n     * @see #dirsNotIncluded\n     * @see #dirsExcluded\n     * @see #slowScan\n     */\n    protected void scandir(File dir, String vpath, boolean fast) {\n        if (dir == null) {\n            throw new BuildException(\"dir must not be null.\");\n        } else if (!dir.exists()) {\n            throw new BuildException(dir + \" doesn't exists.\");\n        } else if (!dir.isDirectory()) {\n            throw new BuildException(dir + \" is not a directory.\");\n        }\n\n        // avoid double scanning of directories, can only happen in fast mode\n        if (fast && hasBeenScanned(vpath)) {\n            return;\n        }\n        String[] newfiles = dir.list();\n\n        if (newfiles == null) {\n            /*\n             * two reasons are mentioned in the API docs for File.list\n             * (1) dir is not a directory. This is impossible as\n             *     we wouldn't get here in this case.\n             * (2) an IO error occurred (why doesn't it throw an exception\n             *     then???)\n             */\n            throw new BuildException(\"IO error scanning directory \"\n                                     + dir.getAbsolutePath());\n        }\n\n        if (!followSymlinks) {\n            Vector noLinks = new Vector();\n            for (int i = 0; i < newfiles.length; i++) {\n                try {\n                    if (FILE_UTILS.isSymbolicLink(dir, newfiles[i])) {\n                        String name = vpath + newfiles[i];\n                        File   file = new File(dir, newfiles[i]);\n                        if (file.isDirectory()) {\n                            dirsExcluded.addElement(name);\n                        } else {\n                            filesExcluded.addElement(name);\n                        }\n                    } else {\n                        noLinks.addElement(newfiles[i]);\n                    }\n                } catch (IOException ioe) {\n                    String msg = \"IOException caught while checking \"\n                        + \"for links, couldn't get canonical path!\";\n                    // will be caught and redirected to Ant's logging system\n                    System.err.println(msg);\n                    noLinks.addElement(newfiles[i]);\n                }\n            }\n            newfiles = new String[noLinks.size()];\n            noLinks.copyInto(newfiles);\n        }\n\n        for (int i = 0; i < newfiles.length; i++) {\n            String name = vpath + newfiles[i];\n            File   file = new File(dir, newfiles[i]);\n            if (file.isDirectory()) {\n                if (isIncluded(name)) {\n                    accountForIncludedDir(name, file, fast);\n                } else {\n                    everythingIncluded = false;\n                    dirsNotIncluded.addElement(name);\n                    if (fast && couldHoldIncluded(name)) {\n                        scandir(file, name + File.separator, fast);\n                    }\n                }\n                if (!fast) {\n                    scandir(file, name + File.separator, fast);\n                }\n            } else if (file.isFile()) {\n                if (isIncluded(name)) {\n                    accountForIncludedFile(name, file);\n                } else {\n                    everythingIncluded = false;\n                    filesNotIncluded.addElement(name);\n                }\n            }\n        }\n    }\n    /**\n     * process included file\n     * @param name  path of the file relative to the directory of the fileset\n     * @param file  included file\n     */\n    private void accountForIncludedFile(String name, File file) {\n        if (!filesIncluded.contains(name)\n            && !filesExcluded.contains(name)\n            && !filesDeselected.contains(name)) {\n\n            if (!isExcluded(name)) {\n                if (isSelected(name, file)) {\n                    filesIncluded.addElement(name);\n                } else {\n                    everythingIncluded = false;\n                    filesDeselected.addElement(name);\n                }\n            } else {\n                everythingIncluded = false;\n                filesExcluded.addElement(name);\n            }\n        }\n    }\n\n    /**\n     *\n     * @param name path of the directory relative to the directory of\n     * the fileset\n     * @param file directory as file\n     * @param fast\n     */\n    private void accountForIncludedDir(String name, File file, boolean fast) {\n        if (!dirsIncluded.contains(name)\n            && !dirsExcluded.contains(name)\n            && !dirsDeselected.contains(name)) {\n\n            if (!isExcluded(name)) {\n                if (isSelected(name, file)) {\n                    dirsIncluded.addElement(name);\n                    if (fast) {\n                        scandir(file, name + File.separator, fast);\n                    }\n                } else {\n                    everythingIncluded = false;\n                    dirsDeselected.addElement(name);\n                    if (fast && couldHoldIncluded(name)) {\n                        scandir(file, name + File.separator, fast);\n                    }\n                }\n\n            } else {\n                everythingIncluded = false;\n                dirsExcluded.addElement(name);\n                if (fast && couldHoldIncluded(name)) {\n                    scandir(file, name + File.separator, fast);\n                }\n            }\n        }\n    }\n    /**\n     * Tests whether or not a name matches against at least one include\n     * pattern.\n     *\n     * @param name The name to match. Must not be <code>null</code>.\n     * @return <code>true</code> when the name matches against at least one\n     *         include pattern, or <code>false</code> otherwise.\n     */\n    protected boolean isIncluded(String name) {\n        for (int i = 0; i < includes.length; i++) {\n            if (matchPath(includes[i], name, isCaseSensitive)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Tests whether or not a name matches the start of at least one include\n     * pattern.\n     *\n     * @param name The name to match. Must not be <code>null</code>.\n     * @return <code>true</code> when the name matches against the start of at\n     *         least one include pattern, or <code>false</code> otherwise.\n     */\n    protected boolean couldHoldIncluded(String name) {\n        for (int i = 0; i < includes.length; i++) {\n            if (matchPatternStart(includes[i], name, isCaseSensitive)) {\n                if (isMorePowerfulThanExcludes(name, includes[i])) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     *  find out whether one particular include pattern is more powerful\n     *  than all the excludes\n     *  note : the power comparison is based on the length of the include \npattern\n     *  and of the exclude patterns without the wildcards\n     *  ideally the comparison should be done based on the depth\n     *  of the match, that is to say how many file separators have been matched\n     *  before the first ** or the end of the pattern\n     *\n     *  IMPORTANT : this function should return false \"with care\"\n     *\n     *  @param name the relative path that one want to test\n     *  @param includepattern  one include pattern\n     *  @return true if there is no exclude pattern more powerful than this \ninclude pattern\n     *  @since ant1.6\n     */\n    private boolean isMorePowerfulThanExcludes(String name, String \nincludepattern) {\n        String soughtexclude = name + File.separator + \"**\";\n        for (int counter = 0; counter < excludes.length; counter++) {\n            if (excludes[counter].equals(soughtexclude))  {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Tests whether or not a name matches against at least one exclude\n     * pattern.\n     *\n     * @param name The name to match. Must not be <code>null</code>.\n     * @return <code>true</code> when the name matches against at least one\n     *         exclude pattern, or <code>false</code> otherwise.\n     */\n    protected boolean isExcluded(String name) {\n        for (int i = 0; i < excludes.length; i++) {\n            if (matchPath(excludes[i], name, isCaseSensitive)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Tests whether a name should be selected.\n     *\n     * @param name the filename to check for selecting\n     * @param file the java.io.File object for this filename\n     * @return <code>false</code> when the selectors says that the file\n     *         should not be selected, <code>true</code> otherwise.\n     */\n    protected boolean isSelected(String name, File file) {\n        if (selectors != null) {\n            for (int i = 0; i < selectors.length; i++) {\n                if (!selectors[i].isSelected(basedir, name, file)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns the names of the files which matched at least one of the\n     * include patterns and none of the exclude patterns.\n     * The names are relative to the base directory.\n     *\n     * @return the names of the files which matched at least one of the\n     *         include patterns and none of the exclude patterns.\n     */\n    public String[] getIncludedFiles() {\n        String[] files = new String[filesIncluded.size()];\n        filesIncluded.copyInto(files);\n        Arrays.sort(files);\n        return files;\n    }\n\n    /**\n     * Returns the names of the files which matched none of the include\n     * patterns. The names are relative to the base directory. This involves\n     * performing a slow scan if one has not already been completed.\n     *\n     * @return the names of the files which matched none of the include\n     *         patterns.\n     *\n     * @see #slowScan\n     */\n    public String[] getNotIncludedFiles() {\n        slowScan();\n        String[] files = new String[filesNotIncluded.size()];\n        filesNotIncluded.copyInto(files);\n        return files;\n    }\n\n    /**\n     * Returns the names of the files which matched at least one of the\n     * include patterns and at least one of the exclude patterns.\n     * The names are relative to the base directory. This involves\n     * performing a slow scan if one has not already been completed.\n     *\n     * @return the names of the files which matched at least one of the\n     *         include patterns and at least one of the exclude patterns.\n     *\n     * @see #slowScan\n     */\n    public String[] getExcludedFiles() {\n        slowScan();\n        String[] files = new String[filesExcluded.size()];\n        filesExcluded.copyInto(files);\n        return files;\n    }\n\n    /**\n     * <p>Returns the names of the files which were selected out and\n     * therefore not ultimately included.</p>\n     *\n     * <p>The names are relative to the base directory. This involves\n     * performing a slow scan if one has not already been completed.</p>\n     *\n     * @return the names of the files which were deselected.\n     *\n     * @see #slowScan\n     */\n    public String[] getDeselectedFiles() {\n        slowScan();\n        String[] files = new String[filesDeselected.size()];\n        filesDeselected.copyInto(files);\n        return files;\n    }\n\n    /**\n     * Returns the names of the directories which matched at least one of the\n     * include patterns and none of the exclude patterns.\n     * The names are relative to the base directory.\n     *\n     * @return the names of the directories which matched at least one of the\n     * include patterns and none of the exclude patterns.\n     */\n    public String[] getIncludedDirectories() {\n        String[] directories = new String[dirsIncluded.size()];\n        dirsIncluded.copyInto(directories);\n        Arrays.sort(directories);\n        return directories;\n    }\n\n    /**\n     * Returns the names of the directories which matched none of the include\n     * patterns. The names are relative to the base directory. This involves\n     * performing a slow scan if one has not already been completed.\n     *\n     * @return the names of the directories which matched none of the include\n     * patterns.\n     *\n     * @see #slowScan\n     */\n    public String[] getNotIncludedDirectories() {\n        slowScan();\n        String[] directories = new String[dirsNotIncluded.size()];\n        dirsNotIncluded.copyInto(directories);\n        return directories;\n    }\n\n    /**\n     * Returns the names of the directories which matched at least one of the\n     * include patterns and at least one of the exclude patterns.\n     * The names are relative to the base directory. This involves\n     * performing a slow scan if one has not already been completed.\n     *\n     * @return the names of the directories which matched at least one of the\n     * include patterns and at least one of the exclude patterns.\n     *\n     * @see #slowScan\n     */\n    public String[] getExcludedDirectories() {\n        slowScan();\n        String[] directories = new String[dirsExcluded.size()];\n        dirsExcluded.copyInto(directories);\n        return directories;\n    }\n\n    /**\n     * <p>Returns the names of the directories which were selected out and\n     * therefore not ultimately included.</p>\n     *\n     * <p>The names are relative to the base directory. This involves\n     * performing a slow scan if one has not already been completed.</p>\n     *\n     * @return the names of the directories which were deselected.\n     *\n     * @see #slowScan\n     */\n    public String[] getDeselectedDirectories() {\n        slowScan();\n        String[] directories = new String[dirsDeselected.size()];\n        dirsDeselected.copyInto(directories);\n        return directories;\n    }\n\n    /**\n     * Adds default exclusions to the current exclusions set.\n     */\n    public void addDefaultExcludes() {\n        int excludesLength = excludes == null ? 0 : excludes.length;\n        String[] newExcludes;\n        newExcludes = new String[excludesLength + defaultExcludes.size()];\n        if (excludesLength > 0) {\n            System.arraycopy(excludes, 0, newExcludes, 0, excludesLength);\n        }\n        String[] defaultExcludesTemp = getDefaultExcludes();\n        for (int i = 0; i < defaultExcludesTemp.length; i++) {\n            newExcludes[i + excludesLength] =\n                defaultExcludesTemp[i].replace('/', File.separatorChar)\n                .replace('\\\\', File.separatorChar);\n        }\n        excludes = newExcludes;\n    }\n\n    /**\n     * Get the named resource\n     * @param name path name of the file relative to the dir attribute.\n     *\n     * @return the resource with the given name.\n     * @since Ant 1.5.2\n     */\n    public Resource getResource(String name) {\n        File f = FILE_UTILS.resolveFile(basedir, name);\n        return new ResourceFile(name);\n    }\n\n    /**\n     * temporary table to speed up the various scanning methods below\n     *\n     * @since Ant 1.6\n     */\n    private Map fileListMap = new HashMap();\n\n    /**\n     * Returns a cached result of list performed on file, if\n     * available.  Invokes the method and caches the result otherwise.\n     *\n     * @since Ant 1.6\n     */\n    private String[] list(File file) {\n        String[] files = (String[]) fileListMap.get(file);\n        if (files == null) {\n            files = file.list();\n            if (files != null) {\n                fileListMap.put(file, files);\n            }\n        }\n        return files;\n    }\n\n    /**\n     * From <code>base</code> traverse the filesystem in a case\n     * insensitive manner in order to find a file that matches the\n     * given name.\n     *\n     * @return File object that points to the file in question.  if it\n     * hasn't been found it will simply be <code>new File(base,\n     * path)</code>.\n     *\n     * @since Ant 1.6\n     */\n    private File findFileCaseInsensitive(File base, String path) {\n        File f = findFileCaseInsensitive(base,\n                                         SelectorUtils.tokenizePath(path));\n        return  f == null ? new File(base, path) : f;\n    }\n\n    /**\n     * From <code>base</code> traverse the filesystem in a case\n     * insensitive manner in order to find a file that matches the\n     * given stack of names.\n     *\n     * @return File object that points to the file in question or null.\n     *\n     * @since Ant 1.6\n     */\n    private File findFileCaseInsensitive(File base, Vector pathElements) {\n        if (pathElements.size() == 0) {\n            return base;\n        } else {\n            if (!base.isDirectory()) {\n                return null;\n            }\n            String[] files = list(base);\n            if (files == null) {\n                throw new BuildException(\"IO error scanning directory \"\n                                         + base.getAbsolutePath());\n            }\n            String current = (String) pathElements.remove(0);\n            for (int i = 0; i < files.length; i++) {\n                if (files[i].equals(current)) {\n                    base = new File(base, files[i]);\n                    return findFileCaseInsensitive(base, pathElements);\n                }\n            }\n            for (int i = 0; i < files.length; i++) {\n                if (files[i].equalsIgnoreCase(current)) {\n                    base = new File(base, files[i]);\n                    return findFileCaseInsensitive(base, pathElements);\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * From <code>base</code> traverse the filesystem in order to find\n     * a file that matches the given name.\n     *\n     * @return File object that points to the file in question or null.\n     *\n     * @since Ant 1.6\n     */\n    private File findFile(File base, String path) {\n        return findFile(base, SelectorUtils.tokenizePath(path));\n    }\n\n    /**\n     * From <code>base</code> traverse the filesystem in order to find\n     * a file that matches the given stack of names.\n     *\n     * @return File object that points to the file in question or null.\n     *\n     * @since Ant 1.6\n     */\n    private File findFile(File base, Vector pathElements) {\n        if (pathElements.size() == 0) {\n            return base;\n        } else {\n            if (!base.isDirectory()) {\n                return null;\n            }\n            String[] files = list(base);\n            if (files == null) {\n                throw new BuildException(\"IO error scanning directory \"\n                                         + base.getAbsolutePath());\n            }\n            String current = (String) pathElements.remove(0);\n            for (int i = 0; i < files.length; i++) {\n                if (files[i].equals(current)) {\n                    base = new File(base, files[i]);\n                    return findFile(base, pathElements);\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Do we have to traverse a symlink when trying to reach path from\n     * basedir?\n     * @since Ant 1.6\n     */\n    private boolean isSymlink(File base, String path) {\n        return isSymlink(base, SelectorUtils.tokenizePath(path));\n    }\n\n    /**\n     * Do we have to traverse a symlink when trying to reach path from\n     * basedir?\n     * @since Ant 1.6\n     */\n    private boolean isSymlink(File base, Vector pathElements) {\n        if (pathElements.size() > 0) {\n            String current = (String) pathElements.remove(0);\n            try {\n                if (FILE_UTILS.isSymbolicLink(base, current)) {\n                    return true;\n                } else {\n                    base = new File(base, current);\n                    return isSymlink(base, pathElements);\n                }\n            } catch (IOException ioe) {\n                String msg = \"IOException caught while checking \"\n                    + \"for links, couldn't get canonical path!\";\n                // will be caught and redirected to Ant's logging system\n                System.err.println(msg);\n                return false;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * List of all scanned directories.\n     *\n     * @since Ant 1.6\n     */\n    private Set scannedDirs = new HashSet();\n\n    /**\n     * Has the directory with the given path relative to the base\n     * directory already been scanned?\n     *\n     * <p>Registers the given directory as scanned as a side effect.</p>\n     *\n     * @since Ant 1.6\n     */\n    private boolean hasBeenScanned(String vpath) {\n        return !scannedDirs.add(vpath);\n    }\n\n    /**\n     * Clear internal caches.\n     *\n     * @since Ant 1.6\n     */\n    private void clearCaches() {\n        fileListMap.clear();\n        scannedDirs.clear();\n    }\n}\n\n/*\n * Copyright  2003-2004 The Apache Software Foundation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n */\npackage org.apache.tools.ant.types;\n\n/**\n * describes a File or a ZipEntry\n *\n * this class is meant to be used by classes needing to record path\n * and date/time information about a file, a zip entry or some similar\n * resource (URL, archive in a version control repository, ...)\n *\n * @since Ant 1.5.2\n */\npublic abstract class Resource implements Cloneable, Comparable {\n    protected String name = null;\n \n    /**\n     * default constructor\n     */\n    protected Resource() {\n    }\n\n \n    /**\n     * name attribute will contain the path of a file relative to the\n     * root directory of its fileset or the recorded path of a zip\n     * entry.\n     *\n     * <p>example for a file with fullpath /var/opt/adm/resource.txt\n     * in a file set with root dir /var/opt it will be\n     * adm/resource.txt.</p>\n     *\n     * <p>&quot;/&quot; will be used as the directory separator.</p>\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * @param name relative path of the resource.  Expects\n     * &quot;/&quot; to be used as the directory separator.\n     */\n    public void setName(String name) {\n        this.name = name;\n    }\n    /**\n     * the exists attribute tells whether a file exists\n     */\n    public abstract boolean isExists();\n\n    public abstract void setExists(boolean exists);\n\n    /**\n     * tells the modification time in milliseconds since 01.01.1970 of\n     *\n     * @return 0 if the resource does not exist to mirror the behavior\n     * of {@link java.io.File File}.\n     */\n    public abstract long getLastModified();\n\n    public abstract void setLastModified(long lastmodified);\n    \n    /**\n     * tells if the resource is a directory\n     * @return boolean flag indicating if the resource is a directory\n     */\n    public abstract boolean isDirectory();\n\n    public abstract void setDirectory(boolean directory);\n\n    /**\n     * @return copy of this\n     */\n    public Object clone() {\n        try {\n            return super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new Error(\"CloneNotSupportedException for a \"\n                            + \"Clonable Resource caught?\");\n        }\n    }\n\n    /**\n     * delegates to a comparison of names.\n     *\n     * @since Ant 1.6\n     */\n    public int compareTo(Object other) {\n        if (!(other instanceof Resource)) {\n            throw new IllegalArgumentException(\"Can only be compared with \"\n                                               + \"Resources\");\n        }\n        Resource r = (Resource) other;\n        return getName().compareTo(r.getName());\n    }\n}\n\n/*\n * Created on Jul 10, 2004\n *\n * TODO To change the template for this generated file go to\n * Window - Preferences - Java - Code Style - Code Templates\n */\npackage org.apache.tools.ant.types;\n\nimport java.io.*;\n\n/**\n * @author jbleijen\n * \n * TODO To change the template for this generated type comment go to Window -\n * Preferences - Java - Code Style - Code Templates\n */\npublic class ResourceFile extends Resource {\n\tprotected File file;\n\n\tprivate final static int UNKNOWN = 1;\n\n\tprivate final static int FILE_EXISTS = 2;\n\n\tprivate final static int FILE_DOES_NOT_EXISTS = 3;\n\n\tprivate final static int IS_DIRECTORY = 4;\n\n\tprivate final static int IS_NOT_DIRECTORY = 5;\n\n\tprivate int exists = UNKNOWN;\n\n\tprivate int isDir = UNKNOWN;\n\n\tprivate long lastModified = -1l;\n\n\t/**\n\t * only sets the name.\n\t * \n\t * <p>\n\t * This is a dummy, used for not existing resources.\n\t * </p>\n\t * \n\t * @param name\n\t *            relative path of the resource. Expects &quot;/&quot; to be\n\t *            used as the directory separator.\n\t */\n\tpublic ResourceFile(String name) {\n\t\tthis(name, new File(name));\n\t}\n\n\tpublic ResourceFile(String name, File file) {\n\t\tthis.name = name;\n\t\tthis.file = file;\n\t}\n\n\t/**\n\t * the exists attribute tells whether a file exists\n\t */\n\tpublic boolean isExists() {\n\t\tvalidateFileExists();\n\t\treturn exists == FILE_EXISTS;\n\t}\n\n\tpublic void setExists(boolean exists) {\n\t\tif (exists) {\n\t\t\tthis.exists = FILE_EXISTS;\n\t\t} else {\n\t\t\tthis.exists = FILE_DOES_NOT_EXISTS;\n\t\t}\n\t}\n\n\t/**\n\t * tells the modification time in milliseconds since 01.01.1970 of\n\t * \n\t * @return 0 if the resource does not exist to mirror the behavior of\n\t *         {@link java.io.File File}.\n\t */\n\tpublic long getLastModified() {\n\t\tif (!isExists())\n\t\t\treturn 0;\n\t\tif (lastModified == -1) {\n\t\t\tlastModified = file.lastModified();\n\t\t}\n\t\treturn lastModified;\n\t}\n\n\tpublic void setLastModified(long lastmodified) {\n\t\tthis.lastModified = lastmodified;\n\t}\n\n\t/**\n\t * tells if the resource is a directory\n\t * \n\t * @return boolean flag indicating if the resource is a directory\n\t */\n\tpublic boolean isDirectory() {\n\t\tvalidateFileIsDir();\n\t\treturn isDir == IS_DIRECTORY;\n\t}\n\n\tpublic void setDirectory(boolean directory) {\n\t\tif (directory) {\n\t\t\tthis.isDir = IS_DIRECTORY;\n\t\t} else {\n\t\t\tthis.isDir = IS_NOT_DIRECTORY;\n\t\t}\n\t}\n\n\t/**\n\t * @return copy of this\n\t */\n\tpublic Object clone() {\n\t\treturn super.clone();\n\t}\n\n\t/**\n\t * delegates to a comparison of names.\n\t * \n\t * @since Ant 1.6\n\t */\n\tpublic int compareTo(Object other) {\n\t\tif (!(other instanceof Resource)) {\n\t\t\tthrow new IllegalArgumentException(\"Can only be \ncompared with \"\n\t\t\t\t\t+ \"Resources\");\n\t\t}\n\t\tResource r = (Resource) other;\n\t\treturn getName().compareTo(r.getName());\n\t}\n\n\t/*\n\t * TODO\n\t */\n\tprotected void validateFileExists() {\n\t\tif (exists == UNKNOWN) {\n\t\t\tthis.lastModified = file.lastModified();\n\t\t\tif (this.lastModified == 0l) {\n\t\t\t\tthis.exists = FILE_DOES_NOT_EXISTS;\n\t\t\t} else {\n\t\t\t\tthis.exists = FILE_EXISTS;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * TODO @author jbleijen\n\t *  \n\t */\n\tprotected void validateFileIsDir() {\n\t\tif (exists == FILE_DOES_NOT_EXISTS) {\n\t\t\tisDir = IS_NOT_DIRECTORY;\n\t\t\treturn;\n\t\t}\n\t\tif (isDir == UNKNOWN) {\n\t\t\tif (file.isDirectory()) {\n\t\t\t\tisDir = IS_DIRECTORY;\n\t\t\t} else {\n\t\t\t\tisDir = IS_NOT_DIRECTORY;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n * Created on Jul 10, 2004\n *\n * TODO To change the template for this generated file go to\n * Window - Preferences - Java - Code Style - Code Templates\n */\npackage org.apache.tools.ant.types;\n\n/**\n * @author jbleijen\n *\n * TODO To change the template for this generated type comment go to\n * Window - Preferences - Java - Code Style - Code Templates\n */\npublic class ResourceZipEntry extends Resource\n{\n\t  protected boolean exists = true;\n\t    protected long lastmodified = 0;\n\t    protected boolean directory = false;\n\n\t   /**\n     * only sets the name.\n     *\n     * <p>This is a dummy, used for not existing resources.</p>\n     *\n     * @param name relative path of the resource.  Expects\n     * &quot;/&quot; to be used as the directory separator.\n     */\n    public ResourceZipEntry(String name) {\n        this(name, false, 0, false);\n    }\n\n    /**\n     * sets the name, lastmodified flag, and exists flag\n     *\n     * @param name relative path of the resource.  Expects\n     * &quot;/&quot; to be used as the directory separator.\n     */\n    public ResourceZipEntry(String name, boolean exists, long lastmodified) {\n        this(name, exists, lastmodified, false);\n    }\n\n    /**\n     * @param name relative path of the resource.  Expects\n     * &quot;/&quot; to be used as the directory separator.\n     */\n    public ResourceZipEntry(String name, boolean exists, long lastmodified,\n                    boolean directory) {\n        this.name = name;\n        this.exists = exists;\n        this.lastmodified = lastmodified;\n        this.directory = directory;\n    }\n    \n    /**\n     * the exists attribute tells whether a file exists\n     */\n    public boolean isExists() {\n        return exists;\n    }\n\n    public void setExists(boolean exists) {\n        this.exists = exists;\n    }\n\n    /**\n     * tells the modification time in milliseconds since 01.01.1970 of\n     *\n     * @return 0 if the resource does not exist to mirror the behavior\n     * of {@link java.io.File File}.\n     */\n    public long getLastModified() {\n        return !exists || lastmodified < 0 ? 0 : lastmodified;\n    }\n\n    public void setLastModified(long lastmodified) {\n        this.lastmodified = lastmodified;\n    }\n    /**\n     * tells if the resource is a directory\n     * @return boolean flag indicating if the resource is a directory\n     */\n    public boolean isDirectory() {\n        return directory;\n    }\n\n    public void setDirectory(boolean directory) {\n        this.directory = directory;\n    }\n\n    /**\n     * @return copy of this\n     */\n    public Object clone() {\n            return super.clone();\n    }\n\n    /**\n     * delegates to a comparison of names.\n     *\n     * @since Ant 1.6\n     */\n    public int compareTo(Object other) {\n        if (!(other instanceof ResourceZipEntry)) {\n            throw new IllegalArgumentException(\"Can only be compared with \"\n                                               + \"Resources\");\n        }\n        ResourceZipEntry r = (ResourceZipEntry) other;\n        return getName().compareTo(r.getName());\n    }\n}\n/*\n * Copyright  2001-2004 The Apache Software Foundation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n */\n\npackage org.apache.tools.ant.types;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Vector;\nimport java.util.Hashtable;\nimport java.util.Enumeration;\nimport java.util.zip.ZipException;\n\nimport org.apache.tools.ant.BuildException;\nimport org.apache.tools.ant.DirectoryScanner;\nimport org.apache.tools.zip.ZipEntry;\nimport org.apache.tools.zip.ZipFile;\n\n/**\n * ZipScanner accesses the pattern matching algorithm in DirectoryScanner,\n * which are protected methods that can only be accessed by subclassing.\n *\n * This implementation of FileScanner defines getIncludedFiles to return\n * the matching Zip entries.\n *\n */\npublic class ZipScanner extends DirectoryScanner {\n\n    /**\n     * The zip file which should be scanned.\n     */\n    protected File srcFile;\n    /**\n     * to record the last scanned zip file with its modification date\n     */\n    private Resource lastScannedResource;\n    /**\n     * record list of all zip entries\n     */\n    private Hashtable myentries;\n\n    /**\n     * encoding of file names.\n     *\n     * @since Ant 1.6\n     */\n    private String encoding;\n\n    /**\n     * Sets the srcFile for scanning. This is the jar or zip file that\n     * is scanned for matching entries.\n     *\n     * @param srcFile the (non-null) zip file name for scanning\n     */\n    public void setSrc(File srcFile) {\n        this.srcFile = srcFile;\n    }\n\n    /**\n     * Sets encoding of file names.\n     *\n     * @since Ant 1.6\n     */\n    public void setEncoding(String encoding) {\n        this.encoding = encoding;\n    }\n\n    /**\n     * Returns the names of the files which matched at least one of the\n     * include patterns and none of the exclude patterns.\n     * The names are relative to the base directory.\n     *\n     * @return the names of the files which matched at least one of the\n     *         include patterns and none of the exclude patterns.\n     */\n    public String[] getIncludedFiles() {\n        if (srcFile != null) {\n            Vector myvector = new Vector();\n            // first check if the archive needs to be scanned again\n            scanme();\n            for (Enumeration e = myentries.elements(); e.hasMoreElements();) {\n                Resource myresource = (Resource) e.nextElement();\n                if (!myresource.isDirectory() && match(myresource.getName())) {\n                    myvector.addElement(myresource.getName());\n                }\n            }\n            String[] files = new String[myvector.size()];\n            myvector.copyInto(files);\n            Arrays.sort(files);\n            return files;\n        } else {\n            return super.getIncludedFiles();\n        }\n    }\n\n    /**\n     * Returns the names of the directories which matched at least one of the\n     * include patterns and none of the exclude patterns.\n     * The names are relative to the base directory.\n     *\n     * @return the names of the directories which matched at least one of the\n     * include patterns and none of the exclude patterns.\n     */\n    public String[] getIncludedDirectories() {\n        if (srcFile != null) {\n            Vector myvector = new Vector();\n            // first check if the archive needs to be scanned again\n            scanme();\n            for (Enumeration e = myentries.elements(); e.hasMoreElements();) {\n                Resource myresource = (Resource) e.nextElement();\n                if (myresource.isDirectory() && match(myresource.getName())) {\n                    myvector.addElement(myresource.getName());\n                }\n            }\n            String[] files = new String[myvector.size()];\n            myvector.copyInto(files);\n            Arrays.sort(files);\n            return files;\n        } else {\n            return super.getIncludedDirectories();\n        }\n    }\n\n    /**\n     * Initialize DirectoryScanner data structures.\n     */\n    public void init() {\n        if (includes == null) {\n            // No includes supplied, so set it to 'matches all'\n            includes = new String[1];\n            includes[0] = \"**\";\n        }\n        if (excludes == null) {\n            excludes = new String[0];\n        }\n    }\n\n    /**\n     * Matches a jar entry against the includes/excludes list,\n     * normalizing the path separator.\n     *\n     * @param path the (non-null) path name to test for inclusion\n     *\n     * @return <code>true</code> if the path should be included\n     *         <code>false</code> otherwise.\n     */\n    public boolean match(String path) {\n        String vpath = path.replace('/', File.separatorChar).\n            replace('\\\\', File.separatorChar);\n        return isIncluded(vpath) && !isExcluded(vpath);\n    }\n\n    /**\n     * @param name path name of the file sought in the archive\n     *\n     * @since Ant 1.5.2\n     */\n    public Resource getResource(String name) {\n        if (srcFile == null) {\n            return super.getResource(name);\n        } else if (name.equals(\"\")) {\n            // special case in ZIPs, we do not want this thing included\n            return new ResourceZipEntry(\"\", true, Long.MAX_VALUE, true);\n        }\n\n        // first check if the archive needs to be scanned again\n        scanme();\n        if (myentries.containsKey(name)) {\n            return (Resource) myentries.get(name);\n        } else if (myentries.containsKey(name + \"/\")) {\n            return (Resource) myentries.get(name + \"/\");\n        } else {\n            return new ResourceZipEntry(name);\n        }\n    }\n\n    /**\n     * if the datetime of the archive did not change since\n     * lastScannedResource was initialized returns immediately else if\n     * the archive has not been scanned yet, then all the zip entries\n     * are put into the vector myentries as a vector of the resource\n     * type\n     */\n    private void scanme() {\n        Resource thisresource = new ResourceZipEntry(srcFile.getAbsolutePath(),\n                                             srcFile.exists(),\n                                             srcFile.lastModified());\n\n        // spare scanning again and again\n        if (lastScannedResource != null\n            && lastScannedResource.getName().equals(thisresource.getName())\n            && lastScannedResource.getLastModified()\n            == thisresource.getLastModified()) {\n            return;\n        }\n\n        ZipEntry entry = null;\n        ZipFile zf = null;\n        myentries = new Hashtable();\n        try {\n            try {\n                zf = new ZipFile(srcFile, encoding);\n            } catch (ZipException ex) {\n                throw new BuildException(\"problem reading \" + srcFile, ex);\n            } catch (IOException ex) {\n                throw new BuildException(\"problem opening \" + srcFile, ex);\n            }\n\n            Enumeration e = zf.getEntries();\n            while (e.hasMoreElements()) {\n                entry = (ZipEntry) e.nextElement();\n                myentries.put(new String(entry.getName()),\n                              new ResourceZipEntry(entry.getName(), true,\n                                           entry.getTime(),\n                                           entry.isDirectory()));\n            }\n        } finally {\n            if (zf != null) {\n                try {\n                    zf.close();\n                } catch (IOException ex) {\n                    // swallow\n                }\n            }\n        }\n        // record data about the last scanned resource\n        lastScannedResource = thisresource;\n    }\n}\n\n/*\n * Copyright  2001-2004 The Apache Software Foundation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n */\n\npackage org.apache.tools.ant.util;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.lang.reflect.Method;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.text.CharacterIterator;\nimport java.text.DecimalFormat;\nimport java.text.StringCharacterIterator;\nimport java.util.Random;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\nimport org.apache.tools.ant.BuildException;\nimport org.apache.tools.ant.Project;\nimport org.apache.tools.ant.filters.util.ChainReaderHelper;\nimport org.apache.tools.ant.taskdefs.condition.Os;\nimport org.apache.tools.ant.types.FilterSetCollection;\nimport org.apache.tools.ant.launch.Locator;\n\n/**\n * This class also encapsulates methods which allow Files to be refered to using\n * abstract path names which are translated to native system file paths at\n * runtime as well as copying files or setting there last modification time.\n * \n * @version $Revision: 1.56.2.7 $\n */\n\npublic class FileUtils {\n\tprivate static Random rand = new Random(System.currentTimeMillis());\n\n\tprivate static Object lockReflection = new Object();\n\n\tprivate static java.lang.reflect.Method setLastModified = null;\n\n\tprivate boolean onNetWare = Os.isFamily(\"netware\");\n\n\t// for toURI\n\tprivate static boolean[] isSpecial = new boolean[256];\n\n\tprivate static char[] escapedChar1 = new char[256];\n\n\tprivate static char[] escapedChar2 = new char[256];\n\n\t/**\n\t * the granularity of timestamps under FAT\n\t */\n\tpublic static final long FAT_FILE_TIMESTAMP_GRANULARITY = 2000;\n\n\t// stolen from FilePathToURI of the Xerces-J team\n\tstatic {\n\t\tfor (int i = 0; i <= 0x20; i++) {\n\t\t\tisSpecial[i] = true;\n\t\t\tescapedChar1[i] = Character.forDigit(i >> 4, 16);\n\t\t\tescapedChar2[i] = Character.forDigit(i & 0xf, 16);\n\t\t}\n\t\tisSpecial[0x7f] = true;\n\t\tescapedChar1[0x7f] = '7';\n\t\tescapedChar2[0x7f] = 'F';\n\t\tchar[] escChs = \n{ '<', '>', '#', '%', '\"', '{', '}', '|', '\\\\', '^',\n\t\t\t\t'~', '[', ']', '`' };\n\t\tint len = escChs.length;\n\t\tchar ch;\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tch = escChs[i];\n\t\t\tisSpecial[ch] = true;\n\t\t\tescapedChar1[ch] = Character.forDigit(ch >> 4, 16);\n\t\t\tescapedChar2[ch] = Character.forDigit(ch & 0xf, 16);\n\t\t}\n\t}\n\n\t/**\n\t * Factory method.\n\t * \n\t * @return a new instance of FileUtils.\n\t */\n\tpublic static FileUtils newFileUtils() {\n\t\tString version = System.getProperty(\"java.version\");\n\t\tStringTokenizer st = new StringTokenizer(version, \".\");\n\t\tboolean supportsNio = false;\n\t\ttry {\n\t\t\tif (st.countTokens() > 2) {\n\t\t\t\tint major = Integer.parseInt(st.nextToken());\n\t\t\t\tint minor = Integer.parseInt(st.nextToken());\n\n\t\t\t\tif (major > 1 || (major == 1 && minor >= 4)) {\n\t\t\t\t\tsupportsNio = true;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tClass.forName\n(\"org.apache.tools.ant.util.NioFileUtils\");\n\t\t\t\t\t\treturn new NioFileUtils();\n\t\t\t\t\t} catch (ClassNotFoundException e1) {\n\t\t\t\t\t    // class not included\n\t\t\t\t\t\t// fall back\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (NumberFormatException e) { \n\t\t\t//ignore\n\t\t}\n\t\treturn new FileUtils();\n\t}\n\n\t/**\n\t * Empty constructor.\n\t */\n\tprotected FileUtils() {\n\t}\n\n\t/**\n\t * Get the URL for a file taking into account # characters\n\t * \n\t * @param file\n\t *            the file whose URL representation is required.\n\t * @return The FileURL value\n\t * @throws MalformedURLException\n\t *             if the URL representation cannot be formed.\n\t */\n\tpublic URL getFileURL(File file) throws MalformedURLException {\n\t\treturn new URL(toURI(file.getAbsolutePath()));\n\t}\n\n\t/**\n\t * Convienence method to copy a file from a source to a destination. No\n\t * filtering is performed.\n\t * \n\t * @param sourceFile\n\t *            Name of file to copy from. Must not be <code>null</code>.\n\t * @param destFile\n\t *            Name of file to copy to. Must not be <code>null</code>.\n\t * \n\t * @throws IOException\n\t *             if the copying fails\n\t */\n\tpublic void copyFile(String sourceFile, String destFile) throws \nIOException {\n\t\tcopyFile(new File(sourceFile), new File(destFile), null, false, \nfalse);\n\t}\n\n\t/**\n\t * Convienence method to copy a file from a source to a destination\n\t * specifying if token filtering must be used.\n\t * \n\t * @param sourceFile\n\t *            Name of file to copy from. Must not be <code>null</code>.\n\t * @param destFile\n\t *            Name of file to copy to. Must not be <code>null</code>.\n\t * @param filters\n\t *            the collection of filters to apply to this copy\n\t * \n\t * @throws IOException\n\t *             if the copying fails\n\t */\n\tpublic void copyFile(String sourceFile, String destFile,\n\t\t\tFilterSetCollection filters) throws IOException {\n\t\tcopyFile(new File(sourceFile), new File(destFile), filters, \nfalse,\n\t\t\t\tfalse);\n\t}\n\n\t/**\n\t * Convienence method to copy a file from a source to a destination\n\t * specifying if token filtering must be used and if source files may\n\t * overwrite newer destination files.\n\t * \n\t * @param sourceFile\n\t *            Name of file to copy from. Must not be <code>null</code>.\n\t * @param destFile\n\t *            Name of file to copy to. Must not be <code>null</code>.\n\t * @param filters\n\t *            the collection of filters to apply to this copy\n\t * @param overwrite\n\t *            Whether or not the destination file should be overwritten \nif\n\t *            it already exists.\n\t * \n\t * @throws IOException\n\t *             if the copying fails\n\t */\n\tpublic void copyFile(String sourceFile, String destFile,\n\t\t\tFilterSetCollection filters, boolean overwrite) throws \nIOException {\n\t\tcopyFile(new File(sourceFile), new File(destFile), filters, \noverwrite,\n\t\t\t\tfalse);\n\t}\n\n\t/**\n\t * Convienence method to copy a file from a source to a destination\n\t * specifying if token filtering must be used, if source files may \noverwrite\n\t * newer destination files and the last modified time of\n\t * <code>destFile</code> file should be made equal to the last modified\n\t * time of <code>sourceFile</code>.\n\t * \n\t * @param sourceFile\n\t *            Name of file to copy from. Must not be <code>null</code>.\n\t * @param destFile\n\t *            Name of file to copy to. Must not be <code>null</code>.\n\t * @param filters\n\t *            the collection of filters to apply to this copy\n\t * @param overwrite\n\t *            Whether or not the destination file should be overwritten \nif\n\t *            it already exists.\n\t * @param preserveLastModified\n\t *            Whether or not the last modified time of the resulting \nfile\n\t *            should be set to that of the source file.\n\t * \n\t * @throws IOException\n\t *             if the copying fails\n\t */\n\tpublic void copyFile(String sourceFile, String destFile,\n\t\t\tFilterSetCollection filters, boolean overwrite,\n\t\t\tboolean preserveLastModified) throws IOException {\n\t\tcopyFile(new File(sourceFile), new File(destFile), filters, \noverwrite,\n\t\t\t\tpreserveLastModified);\n\t}\n\n\t/**\n\t * Convienence method to copy a file from a source to a destination\n\t * specifying if token filtering must be used, if source files may \noverwrite\n\t * newer destination files and the last modified time of\n\t * <code>destFile</code> file should be made equal to the last modified\n\t * time of <code>sourceFile</code>.\n\t * \n\t * @param sourceFile\n\t *            Name of file to copy from. Must not be <code>null</code>.\n\t * @param destFile\n\t *            Name of file to copy to. Must not be <code>null</code>.\n\t * @param filters\n\t *            the collection of filters to apply to this copy\n\t * @param overwrite\n\t *            Whether or not the destination file should be overwritten \nif\n\t *            it already exists.\n\t * @param preserveLastModified\n\t *            Whether or not the last modified time of the resulting \nfile\n\t *            should be set to that of the source file.\n\t * @param encoding\n\t *            the encoding used to read and write the files.\n\t * \n\t * @throws IOException\n\t *             if the copying fails\n\t * \n\t * @since Ant 1.5\n\t */\n\tpublic void copyFile(String sourceFile, String destFile,\n\t\t\tFilterSetCollection filters, boolean overwrite,\n\t\t\tboolean preserveLastModified, String encoding) throws \nIOException {\n\t\tcopyFile(new File(sourceFile), new File(destFile), filters, \noverwrite,\n\t\t\t\tpreserveLastModified, encoding);\n\t}\n\n\t/**\n\t * Convienence method to copy a file from a source to a destination\n\t * specifying if token filtering must be used, if filter chains must be\n\t * used, if source files may overwrite newer destination files and the \nlast\n\t * modified time of <code>destFile</code> file should be made equal to \nthe\n\t * last modified time of <code>sourceFile</code>.\n\t * \n\t * @param sourceFile\n\t *            Name of file to copy from. Must not be <code>null</code>.\n\t * @param destFile\n\t *            Name of file to copy to. Must not be <code>null</code>.\n\t * @param filters\n\t *            the collection of filters to apply to this copy\n\t * @param filterChains\n\t *            filterChains to apply during the copy.\n\t * @param overwrite\n\t *            Whether or not the destination file should be overwritten \nif\n\t *            it already exists.\n\t * @param preserveLastModified\n\t *            Whether or not the last modified time of the resulting \nfile\n\t *            should be set to that of the source file.\n\t * @param encoding\n\t *            the encoding used to read and write the files.\n\t * @param project\n\t *            the project instance\n\t * \n\t * @throws IOException\n\t *             if the copying fails\n\t * \n\t * @since Ant 1.5\n\t */\n\tpublic void copyFile(String sourceFile, String destFile,\n\t\t\tFilterSetCollection filters, Vector filterChains,\n\t\t\tboolean overwrite, boolean preserveLastModified, String \nencoding,\n\t\t\tProject project) throws IOException {\n\t\tcopyFile(new File(sourceFile), new File(destFile), filters,\n\t\t\t\tfilterChains, overwrite, preserveLastModified, \nencoding,\n\t\t\t\tproject);\n\t}\n\n\t/**\n\t * Convienence method to copy a file from a source to a destination\n\t * specifying if token filtering must be used, if filter chains must be\n\t * used, if source files may overwrite newer destination files and the \nlast\n\t * modified time of <code>destFile</code> file should be made equal to \nthe\n\t * last modified time of <code>sourceFile</code>.\n\t * \n\t * @param sourceFile\n\t *            Name of file to copy from. Must not be <code>null</code>.\n\t * @param destFile\n\t *            Name of file to copy to. Must not be <code>null</code>.\n\t * @param filters\n\t *            the collection of filters to apply to this copy\n\t * @param filterChains\n\t *            filterChains to apply during the copy.\n\t * @param overwrite\n\t *            Whether or not the destination file should be overwritten \nif\n\t *            it already exists.\n\t * @param preserveLastModified\n\t *            Whether or not the last modified time of the resulting \nfile\n\t *            should be set to that of the source file.\n\t * @param inputEncoding\n\t *            the encoding used to read the files.\n\t * @param outputEncoding\n\t *            the encoding used to write the files.\n\t * @param project\n\t *            the project instance\n\t * \n\t * @throws IOException\n\t *             if the copying fails\n\t * \n\t * @since Ant 1.6\n\t */\n\tpublic void copyFile(String sourceFile, String destFile,\n\t\t\tFilterSetCollection filters, Vector filterChains,\n\t\t\tboolean overwrite, boolean preserveLastModified,\n\t\t\tString inputEncoding, String outputEncoding, Project \nproject)\n\t\t\tthrows IOException {\n\t\tcopyFile(new File(sourceFile), new File(destFile), filters,\n\t\t\t\tfilterChains, overwrite, preserveLastModified, \ninputEncoding,\n\t\t\t\toutputEncoding, project);\n\t}\n\n\t/**\n\t * Convienence method to copy a file from a source to a destination. No\n\t * filtering is performed.\n\t * \n\t * @param sourceFile\n\t *            the file to copy from. Must not be <code>null</code>.\n\t * @param destFile\n\t *            the file to copy to. Must not be <code>null</code>.\n\t * \n\t * @throws IOException\n\t *             if the copying fails\n\t */\n\tpublic void copyFile(File sourceFile, File destFile) throws IOException \n{\n\t\tcopyFile(sourceFile, destFile, null, false, false);\n\t}\n\n\t/**\n\t * Convienence method to copy a file from a source to a destination\n\t * specifying if token filtering must be used.\n\t * \n\t * @param sourceFile\n\t *            the file to copy from. Must not be <code>null</code>.\n\t * @param destFile\n\t *            the file to copy to. Must not be <code>null</code>.\n\t * @param filters\n\t *            the collection of filters to apply to this copy\n\t * \n\t * @throws IOException\n\t *             if the copying fails\n\t */\n\tpublic void copyFile(File sourceFile, File destFile,\n\t\t\tFilterSetCollection filters) throws IOException {\n\t\tcopyFile(sourceFile, destFile, filters, false, false);\n\t}\n\n\t/**\n\t * Convienence method to copy a file from a source to a destination\n\t * specifying if token filtering must be used and if source files may\n\t * overwrite newer destination files.\n\t * \n\t * @param sourceFile\n\t *            the file to copy from. Must not be <code>null</code>.\n\t * @param destFile\n\t *            the file to copy to. Must not be <code>null</code>.\n\t * @param filters\n\t *            the collection of filters to apply to this copy\n\t * @param overwrite\n\t *            Whether or not the destination file should be overwritten \nif\n\t *            it already exists.\n\t * \n\t * @throws IOException\n\t *             if the copying fails\n\t */\n\tpublic void copyFile(File sourceFile, File destFile,\n\t\t\tFilterSetCollection filters, boolean overwrite) throws \nIOException {\n\t\tcopyFile(sourceFile, destFile, filters, overwrite, false);\n\t}\n\n\t/**\n\t * Convienence method to copy a file from a source to a destination\n\t * specifying if token filtering must be used, if source files may \noverwrite\n\t * newer destination files and the last modified time of\n\t * <code>destFile</code> file should be made equal to the last modified\n\t * time of <code>sourceFile</code>.\n\t * \n\t * @param sourceFile\n\t *            the file to copy from. Must not be <code>null</code>.\n\t * @param destFile\n\t *            the file to copy to. Must not be <code>null</code>.\n\t * @param filters\n\t *            the collection of filters to apply to this copy\n\t * @param overwrite\n\t *            Whether or not the destination file should be overwritten \nif\n\t *            it already exists.\n\t * @param preserveLastModified\n\t *            Whether or not the last modified time of the resulting \nfile\n\t *            should be set to that of the source file.\n\t * \n\t * @throws IOException\n\t *             if the copying fails\n\t */\n\tpublic void copyFile(File sourceFile, File destFile,\n\t\t\tFilterSetCollection filters, boolean overwrite,\n\t\t\tboolean preserveLastModified) throws IOException {\n\t\tcopyFile(sourceFile, destFile, filters, overwrite,\n\t\t\t\tpreserveLastModified, null);\n\t}\n\n\t/**\n\t * Convienence method to copy a file from a source to a destination\n\t * specifying if token filtering must be used, if source files may \noverwrite\n\t * newer destination files, the last modified time of \n<code>destFile</code>\n\t * file should be made equal to the last modified time of\n\t * <code>sourceFile</code> and which character encoding to assume.\n\t * \n\t * @param sourceFile\n\t *            the file to copy from. Must not be <code>null</code>.\n\t * @param destFile\n\t *            the file to copy to. Must not be <code>null</code>.\n\t * @param filters\n\t *            the collection of filters to apply to this copy\n\t * @param overwrite\n\t *            Whether or not the destination file should be overwritten \nif\n\t *            it already exists.\n\t * @param preserveLastModified\n\t *            Whether or not the last modified time of the resulting \nfile\n\t *            should be set to that of the source file.\n\t * @param encoding\n\t *            the encoding used to read and write the files.\n\t * \n\t * @throws IOException\n\t *             if the copying fails\n\t * \n\t * @since Ant 1.5\n\t */\n\tpublic void copyFile(File sourceFile, File destFile,\n\t\t\tFilterSetCollection filters, boolean overwrite,\n\t\t\tboolean preserveLastModified, String encoding) throws \nIOException {\n\t\tcopyFile(sourceFile, destFile, filters, null, overwrite,\n\t\t\t\tpreserveLastModified, encoding, null);\n\t}\n\n\t/**\n\t * Convienence method to copy a file from a source to a destination\n\t * specifying if token filtering must be used, if filter chains must be\n\t * used, if source files may overwrite newer destination files and the \nlast\n\t * modified time of <code>destFile</code> file should be made equal to \nthe\n\t * last modified time of <code>sourceFile</code>.\n\t * \n\t * @param sourceFile\n\t *            the file to copy from. Must not be <code>null</code>.\n\t * @param destFile\n\t *            the file to copy to. Must not be <code>null</code>.\n\t * @param filters\n\t *            the collection of filters to apply to this copy\n\t * @param filterChains\n\t *            filterChains to apply during the copy.\n\t * @param overwrite\n\t *            Whether or not the destination file should be overwritten \nif\n\t *            it already exists.\n\t * @param preserveLastModified\n\t *            Whether or not the last modified time of the resulting \nfile\n\t *            should be set to that of the source file.\n\t * @param encoding\n\t *            the encoding used to read and write the files.\n\t * @param project\n\t *            the project instance\n\t * \n\t * @throws IOException\n\t *             if the copying fails\n\t * \n\t * @since Ant 1.5\n\t */\n\tpublic void copyFile(File sourceFile, File destFile,\n\t\t\tFilterSetCollection filters, Vector filterChains,\n\t\t\tboolean overwrite, boolean preserveLastModified, String \nencoding,\n\t\t\tProject project) throws IOException {\n\t\tcopyFile(sourceFile, destFile, filters, filterChains, overwrite,\n\t\t\t\tpreserveLastModified, encoding, encoding, \nproject);\n\t}\n\n\t/**\n\t * Convienence method to copy a file from a source to a destination\n\t * specifying if token filtering must be used, if filter chains must be\n\t * used, if source files may overwrite newer destination files and the \nlast\n\t * modified time of <code>destFile</code> file should be made equal to \nthe\n\t * last modified time of <code>sourceFile</code>.\n\t * \n\t * @param sourceFile\n\t *            the file to copy from. Must not be <code>null</code>.\n\t * @param destFile\n\t *            the file to copy to. Must not be <code>null</code>.\n\t * @param filters\n\t *            the collection of filters to apply to this copy\n\t * @param filterChains\n\t *            filterChains to apply during the copy.\n\t * @param overwrite\n\t *            Whether or not the destination file should be overwritten \nif\n\t *            it already exists.\n\t * @param preserveLastModified\n\t *            Whether or not the last modified time of the resulting \nfile\n\t *            should be set to that of the source file.\n\t * @param inputEncoding\n\t *            the encoding used to read the files.\n\t * @param outputEncoding\n\t *            the encoding used to write the files.\n\t * @param project\n\t *            the project instance\n\t * \n\t * \n\t * @throws IOException\n\t *             if the copying fails\n\t * \n\t * @since Ant 1.6\n\t */\n\tpublic void copyFile(File sourceFile, File destFile,\n\t\t\tFilterSetCollection filters, Vector filterChains,\n\t\t\tboolean overwrite, boolean preserveLastModified,\n\t\t\tString inputEncoding, String outputEncoding, Project \nproject)\n\t\t\tthrows IOException {\n\n\t\tif (overwrite || !destFile.exists()\n\t\t\t\t|| destFile.lastModified() < \nsourceFile.lastModified()) {\n\n\t\t\tif (destFile.exists() && destFile.isFile()) {\n\t\t\t\tdestFile.delete();\n\t\t\t}\n\n\t\t\t// ensure that parent dir of dest file exists!\n\t\t\t// not using getParentFile method to stay 1.1 compat\n\t\t\tFile parent = getParentFile(destFile);\n\t\t\tif (parent != null && !parent.exists()) {\n\t\t\t\tparent.mkdirs();\n\t\t\t}\n\n\t\t\tfinal boolean filterSetsAvailable = (filters != null && \nfilters\n\t\t\t\t\t.hasFilters());\n\t\t\tfinal boolean filterChainsAvailable = (filterChains != \nnull && filterChains\n\t\t\t\t\t.size() > 0);\n\n\t\t\tif (filterSetsAvailable) {\n\t\t\t\tBufferedReader in = null;\n\t\t\t\tBufferedWriter out = null;\n\n\t\t\t\ttry {\n\t\t\t\t\tif (inputEncoding == null) {\n\t\t\t\t\t\tin = new BufferedReader(new \nFileReader(sourceFile));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tInputStreamReader isr = new \nInputStreamReader(\n\t\t\t\t\t\t\t\tnew \nFileInputStream(sourceFile), inputEncoding);\n\t\t\t\t\t\tin = new BufferedReader(isr);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (outputEncoding == null) {\n\t\t\t\t\t\tout = new BufferedWriter(new \nFileWriter(destFile));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tOutputStreamWriter osw = new \nOutputStreamWriter(\n\t\t\t\t\t\t\t\tnew \nFileOutputStream(destFile), outputEncoding);\n\t\t\t\t\t\tout = new BufferedWriter(osw);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (filterChainsAvailable) {\n\t\t\t\t\t\tChainReaderHelper crh = new \nChainReaderHelper();\n\t\t\t\t\t\tcrh.setBufferSize(8192);\n\t\t\t\t\t\tcrh.setPrimaryReader(in);\n\t\t\t\t\t\tcrh.setFilterChains\n(filterChains);\n\t\t\t\t\t\tcrh.setProject(project);\n\t\t\t\t\t\tReader rdr = \ncrh.getAssembledReader();\n\t\t\t\t\t\tin = new BufferedReader(rdr);\n\t\t\t\t\t}\n\n\t\t\t\t\tLineTokenizer lineTokenizer = new \nLineTokenizer();\n\t\t\t\t\tlineTokenizer.setIncludeDelims(true);\n\t\t\t\t\tString newline = null;\n\t\t\t\t\tString line = lineTokenizer.getToken\n(in);\n\t\t\t\t\twhile (line != null) {\n\t\t\t\t\t\tif (line.length() == 0) {\n\t\t\t\t\t\t\t// this should not \nhappen, because the lines are\n\t\t\t\t\t\t\t// returned with the \nend of line delimiter\n\t\t\t\t\t\t\tout.newLine();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnewline = \nfilters.replaceTokens(line);\n\t\t\t\t\t\t\tout.write(newline);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tline = lineTokenizer.getToken\n(in);\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (out != null) {\n\t\t\t\t\t\tout.close();\n\t\t\t\t\t}\n\t\t\t\t\tif (in != null) {\n\t\t\t\t\t\tin.close();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (filterChainsAvailable\n\t\t\t\t\t|| (inputEncoding != null && !\ninputEncoding\n\t\t\t\t\t\t\t.equals(outputEncoding))\n\t\t\t\t\t|| (inputEncoding == null && \noutputEncoding != null)) {\n\t\t\t\tBufferedReader in = null;\n\t\t\t\tBufferedWriter out = null;\n\n\t\t\t\ttry {\n\t\t\t\t\tif (inputEncoding == null) {\n\t\t\t\t\t\tin = new BufferedReader(new \nFileReader(sourceFile));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tin = new BufferedReader(new \nInputStreamReader(\n\t\t\t\t\t\t\t\tnew \nFileInputStream(sourceFile), inputEncoding));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (outputEncoding == null) {\n\t\t\t\t\t\tout = new BufferedWriter(new \nFileWriter(destFile));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout = new BufferedWriter(new \nOutputStreamWriter(\n\t\t\t\t\t\t\t\tnew \nFileOutputStream(destFile), outputEncoding));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (filterChainsAvailable) {\n\t\t\t\t\t\tChainReaderHelper crh = new \nChainReaderHelper();\n\t\t\t\t\t\tcrh.setBufferSize(8192);\n\t\t\t\t\t\tcrh.setPrimaryReader(in);\n\t\t\t\t\t\tcrh.setFilterChains\n(filterChains);\n\t\t\t\t\t\tcrh.setProject(project);\n\t\t\t\t\t\tReader rdr = \ncrh.getAssembledReader();\n\t\t\t\t\t\tin = new BufferedReader(rdr);\n\t\t\t\t\t}\n\t\t\t\t\tchar[] buffer = new char[1024 * 8];\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tint nRead = in.read(buffer, 0, \nbuffer.length);\n\t\t\t\t\t\tif (nRead == -1) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tout.write(buffer, 0, nRead);\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (out != null) {\n\t\t\t\t\t\tout.close();\n\t\t\t\t\t}\n\t\t\t\t\tif (in != null) {\n\t\t\t\t\t\tin.close();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tFileInputStream in = null;\n\t\t\t\tFileOutputStream out = null;\n\t\t\t\ttry {\n\t\t\t\t\tin = new FileInputStream(sourceFile);\n\t\t\t\t\tout = new FileOutputStream(destFile);\n\n\t\t\t\t\tbyte[] buffer = new byte[8 * 1024];\n\t\t\t\t\tint count = 0;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tout.write(buffer, 0, count);\n\t\t\t\t\t\tcount = in.read(buffer, 0, \nbuffer.length);\n\t\t\t\t\t} while (count != -1);\n\t\t\t\t} finally {\n\t\t\t\t\tif (out != null) {\n\t\t\t\t\t\tout.close();\n\t\t\t\t\t}\n\t\t\t\t\tif (in != null) {\n\t\t\t\t\t\tin.close();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (preserveLastModified) {\n\t\t\t\tsetFileLastModified(destFile, \nsourceFile.lastModified());\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * see whether we have a setLastModified method in File and return it.\n\t * \n\t * @return a method to setLastModified.\n\t */\n\tprotected final Method getSetLastModified() {\n\t\tif (JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_1)) {\n\t\t\treturn null;\n\t\t}\n\t\tsynchronized (lockReflection) {\n\t\t\tif (setLastModified == null) {\n\t\t\t\ttry {\n\t\t\t\t\tsetLastModified = \njava.io.File.class.getMethod(\n\t\t\t\t\t\t\t\"setLastModified\", new \nClass[] { Long.TYPE });\n\t\t\t\t} catch (NoSuchMethodException nse) {\n\t\t\t\t\tthrow new BuildException(\n\t\t\t\t\t\t\t\"File.setlastModified \nnot in JDK > 1.1?\", nse);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn setLastModified;\n\t}\n\n\t/**\n\t * Calls File.setLastModified(long time) in a Java 1.1 compatible way.\n\t * \n\t * @param file\n\t *            the file whose modified time is to be set\n\t * @param time\n\t *            the time to which the last modified time is to be set.\n\t * \n\t * @throws BuildException\n\t *             if the time cannot be set.\n\t */\n\tpublic void setFileLastModified(File file, long time) throws \nBuildException {\n\t\tif (JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_1)) {\n\t\t\treturn;\n\t\t}\n\t\tLong[] times = new Long[1];\n\t\tif (time < 0) {\n\t\t\ttimes[0] = new Long(System.currentTimeMillis());\n\t\t} else {\n\t\t\ttimes[0] = new Long(time);\n\t\t}\n\n\t\ttry {\n\t\t\tgetSetLastModified().invoke(file, times);\n\t\t} catch (java.lang.reflect.InvocationTargetException ite) {\n\t\t\tThrowable nested = ite.getTargetException();\n\t\t\tthrow new BuildException(\"Exception setting the \nmodification time \"\n\t\t\t\t\t+ \"of \" + file, nested);\n\t\t} catch (Throwable other) {\n\t\t\tthrow new BuildException(\"Exception setting the \nmodification time \"\n\t\t\t\t\t+ \"of \" + file, other);\n\t\t}\n\t}\n\n\t/**\n\t * Interpret the filename as a file relative to the given file - unless \nthe\n\t * filename already represents an absolute filename.\n\t * \n\t * @param file\n\t *            the \"reference\" file for relative paths. This instance \nmust be\n\t *            an absolute file and must not contain &quot;./&quot; or\n\t *            &quot;../&quot; sequences (same for \\ instead of /). If \nit is\n\t *            null, this call is equivalent to\n\t *            <code>new java.io.File(filename)</code>.\n\t * \n\t * @param filename\n\t *            a file name\n\t * \n\t * @return an absolute file that doesn't contain &quot;./&quot; or\n\t *         &quot;../&quot; sequences and uses the correct separator for \nthe\n\t *         current platform.\n\t */\n\tpublic File resolveFile(File file, String filename) {\n\t\tfilename = filename.replace('/', File.separatorChar).replace\n('\\\\',\n\t\t\t\tFile.separatorChar);\n\n\t\t// deal with absolute files\n\t\tif (!onNetWare) {\n\t\t\tif (filename.startsWith(File.separator)\n\t\t\t\t\t|| (filename.length() >= 2\n\t\t\t\t\t\t\t&& Character.isLetter\n(filename.charAt(0)) && filename\n\t\t\t\t\t\t\t.charAt(1) == ':')) {\n\t\t\t\treturn normalize(filename);\n\t\t\t}\n\t\t} else {\n\t\t\t// the assumption that the : will appear as the second \ncharacter in\n\t\t\t// the path name breaks down when NetWare is a \nsupported platform.\n\t\t\t// Netware volumes are of the pattern: \"data:\\\"\n\t\t\tint colon = filename.indexOf(\":\");\n\t\t\tif (filename.startsWith(File.separator) || (colon > -\n1)) {\n\t\t\t\treturn normalize(filename);\n\t\t\t}\n\t\t}\n\n\t\tif (file == null) {\n\t\t\treturn new File(filename);\n\t\t}\n\n\t\tFile helpFile = new File(file.getAbsolutePath());\n\t\tStringTokenizer tok = new StringTokenizer(filename, \nFile.separator);\n\t\twhile (tok.hasMoreTokens()) {\n\t\t\tString part = tok.nextToken();\n\t\t\tif (part.equals(\"..\")) {\n\t\t\t\thelpFile = getParentFile(helpFile);\n\t\t\t\tif (helpFile == null) {\n\t\t\t\t\tString msg = \"The file or path you \nspecified (\" + filename\n\t\t\t\t\t\t\t+ \") is invalid \nrelative to \" + file.getPath();\n\t\t\t\t\tthrow new BuildException(msg);\n\t\t\t\t}\n\t\t\t} else if (part.equals(\".\")) {\n\t\t\t\t// Do nothing here\n\t\t\t} else {\n\t\t\t\thelpFile = new File(helpFile, part);\n\t\t\t}\n\t\t}\n\n\t\treturn new File(helpFile.getAbsolutePath());\n\t}\n\n\t/**\n\t * &quot;normalize&quot; the given absolute path.\n\t * \n\t * <p>\n\t * This includes:\n\t * <ul>\n\t * <li>Uppercase the drive letter if there is one.</li>\n\t * <li>Remove redundant slashes after the drive spec.</li>\n\t * <li>resolve all ./, .\\, ../ and ..\\ sequences.</li>\n\t * <li>DOS style paths that start with a drive letter will have \\ as the\n\t * separator.</li>\n\t * </ul>\n\t * Unlike <code>File#getCanonicalPath()</code> it specifically doesn't\n\t * resolve symbolic links.\n\t * \n\t * @param path\n\t *            the path to be normalized\n\t * @return the normalized version of the path.\n\t * \n\t * @throws java.lang.NullPointerException\n\t *             if the file path is equal to null.\n\t */\n\tpublic File normalize(String path) {\n\t\tString orig = path;\n\n\t\tpath = path.replace('/', File.separatorChar).replace('\\\\',\n\t\t\t\tFile.separatorChar);\n\n\t\t// make sure we are dealing with an absolute path\n\t\tint colon = path.indexOf(\":\");\n\n\t\tif (!onNetWare) {\n\t\t\tif (!path.startsWith(File.separator)\n\t\t\t\t\t&& !(path.length() >= 2\n\t\t\t\t\t\t\t&& Character.isLetter\n(path.charAt(0)) && colon == 1)) {\n\t\t\t\tString msg = path + \" is not an absolute path\";\n\t\t\t\tthrow new BuildException(msg);\n\t\t\t}\n\t\t} else {\n\t\t\tif (!path.startsWith(File.separator) && (colon == -1)) {\n\t\t\t\tString msg = path + \" is not an absolute path\";\n\t\t\t\tthrow new BuildException(msg);\n\t\t\t}\n\t\t}\n\n\t\tboolean dosWithDrive = false;\n\t\tString root = null;\n\t\t// Eliminate consecutive slashes after the drive spec\n\t\tif ((!onNetWare && path.length() >= 2\n\t\t\t\t&& Character.isLetter(path.charAt(0)) && \npath.charAt(1) == ':')\n\t\t\t\t|| (onNetWare && colon > -1)) {\n\n\t\t\tdosWithDrive = true;\n\n\t\t\tchar[] ca = path.replace('/', '\\\\').toCharArray();\n\t\t\tStringBuffer sbRoot = new StringBuffer();\n\t\t\tfor (int i = 0; i < colon; i++) {\n\t\t\t\tsbRoot.append(Character.toUpperCase(ca[i]));\n\t\t\t}\n\t\t\tsbRoot.append(':');\n\t\t\tif (colon + 1 < path.length()) {\n\t\t\t\tsbRoot.append(File.separatorChar);\n\t\t\t}\n\t\t\troot = sbRoot.toString();\n\n\t\t\t// Eliminate consecutive slashes after the drive spec\n\t\t\tStringBuffer sbPath = new StringBuffer();\n\t\t\tfor (int i = colon + 1; i < ca.length; i++) {\n\t\t\t\tif ((ca[i] != '\\\\') || (ca[i] == '\\\\' && ca[i - \n1] != '\\\\')) {\n\t\t\t\t\tsbPath.append(ca[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpath = sbPath.toString().replace('\\\\', \nFile.separatorChar);\n\n\t\t} else {\n\t\t\tif (path.length() == 1) {\n\t\t\t\troot = File.separator;\n\t\t\t\tpath = \"\";\n\t\t\t} else if (path.charAt(1) == File.separatorChar) {\n\t\t\t\t// UNC drive\n\t\t\t\troot = File.separator + File.separator;\n\t\t\t\tpath = path.substring(2);\n\t\t\t} else {\n\t\t\t\troot = File.separator;\n\t\t\t\tpath = path.substring(1);\n\t\t\t}\n\t\t}\n\n\t\tStack s = new Stack();\n\t\ts.push(root);\n\t\tStringTokenizer tok = new StringTokenizer(path, File.separator);\n\t\twhile (tok.hasMoreTokens()) {\n\t\t\tString thisToken = tok.nextToken();\n\t\t\tif (\".\".equals(thisToken)) {\n\t\t\t\tcontinue;\n\t\t\t} else if (\"..\".equals(thisToken)) {\n\t\t\t\tif (s.size() < 2) {\n\t\t\t\t\tthrow new BuildException(\"Cannot \nresolve path \" + orig);\n\t\t\t\t} else {\n\t\t\t\t\ts.pop();\n\t\t\t\t}\n\t\t\t} else { // plain component\n\t\t\t\ts.push(thisToken);\n\t\t\t}\n\t\t}\n\n\t\tStringBuffer sb = new StringBuffer();\n\t\tfor (int i = 0; i < s.size(); i++) {\n\t\t\tif (i > 1) {\n\t\t\t\t// not before the filesystem root and not after \nit, since root\n\t\t\t\t// already contains one\n\t\t\t\tsb.append(File.separatorChar);\n\t\t\t}\n\t\t\tsb.append(s.elementAt(i));\n\t\t}\n\n\t\tpath = sb.toString();\n\t\tif (dosWithDrive) {\n\t\t\tpath = path.replace('/', '\\\\');\n\t\t}\n\t\treturn new File(path);\n\t}\n\n\t/**\n\t * Returns a VMS String representation of a <code>File</code> object. \nThis\n\t * is useful since the JVM by default internally converts VMS paths to \nUnix\n\t * style. The returned String is always an absolute path.\n\t * \n\t * @param f\n\t *            The <code>File</code> to get the VMS path for.\n\t * @return The absolute VMS path to <code>f</code>.\n\t */\n\tpublic String toVMSPath(File f) {\n\t\t// format: \"DEVICE:[DIR.SUBDIR]FILE\"\n\t\tString osPath;\n\t\tString path = normalize(f.getAbsolutePath()).getPath();\n\t\tString name = f.getName();\n\t\tboolean isAbsolute = path.charAt(0) == File.separatorChar;\n\t\t// treat directories specified using .DIR syntax as files\n\t\tboolean isDirectory = f.isDirectory()\n\t\t\t\t&& !name.regionMatches(true, name.length() - \n4, \".DIR\", 0, 4);\n\n\t\tString device = null;\n\t\tStringBuffer directory = null;\n\t\tString file = null;\n\n\t\tint index = 0;\n\n\t\tif (isAbsolute) {\n\t\t\tindex = path.indexOf(File.separatorChar, 1);\n\t\t\tif (index == -1) {\n\t\t\t\treturn path.substring(1) + \":[000000]\";\n\t\t\t} else {\n\t\t\t\tdevice = path.substring(1, index++);\n\t\t\t}\n\t\t}\n\t\tif (isDirectory) {\n\t\t\tdirectory = new StringBuffer(path.substring\n(index).replace(\n\t\t\t\t\tFile.separatorChar, '.'));\n\t\t} else {\n\t\t\tint dirEnd = path.lastIndexOf(File.separatorChar, \npath.length());\n\t\t\tif (dirEnd == -1 || dirEnd < index) {\n\t\t\t\tfile = path.substring(index);\n\t\t\t} else {\n\t\t\t\tdirectory = new StringBuffer(path.substring\n(index, dirEnd)\n\t\t\t\t\t\t.replace\n(File.separatorChar, '.'));\n\t\t\t\tindex = dirEnd + 1;\n\t\t\t\tif (path.length() > index) {\n\t\t\t\t\tfile = path.substring(index);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!isAbsolute && directory != null) {\n\t\t\tdirectory.insert(0, '.');\n\t\t}\n\t\tosPath = ((device != null) ? device + \":\" : \"\")\n\t\t\t\t+ ((directory != null) ? \"[\" + directory \n+ \"]\" : \"\")\n\t\t\t\t+ ((file != null) ? file : \"\");\n\t\treturn osPath;\n\t}\n\n\t/**\n\t * Create a temporary file in a given directory.\n\t * \n\t * <p>\n\t * The file denoted by the returned abstract pathname did not exist \nbefore\n\t * this method was invoked, any subsequent invocation of this method \nwill\n\t * yield a different file name.\n\t * </p>\n\t * \n\t * <p>\n\t * This method is different to File.createTempFile of JDK 1.2 as it \ndoesn't\n\t * create the file itself. It uses the location pointed to by \njava.io.tmpdir\n\t * when the parentDir attribute is null.\n\t * </p>\n\t * \n\t * @param parentDir\n\t *            Directory to create the temporary file in - current \nworking\n\t *            directory will be assumed if this parameter is null.\n\t * \n\t * @return a File reference to the new temporary file.\n\t * @since ant 1.5\n\t */\n\tpublic File createTempFile(String prefix, String suffix, File \nparentDir) {\n\n\t\tFile result = null;\n\t\tString parent = System.getProperty(\"java.io.tmpdir\");\n\t\tif (parentDir != null) {\n\t\t\tparent = parentDir.getPath();\n\t\t}\n\t\tDecimalFormat fmt = new DecimalFormat(\"#####\");\n\t\tsynchronized (rand) {\n\t\t\tdo {\n\t\t\t\tresult = new File(parent, prefix\n\t\t\t\t\t\t+ fmt.format(Math.abs\n(rand.nextInt())) + suffix);\n\t\t\t} while (result.exists());\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Compares the contents of two files.\n\t * \n\t * <p>\n\t * simple but sub-optimal comparision algorithm. written for working \nrather\n\t * than fast. Better would be a block read into buffers followed by long\n\t * comparisions apart from the final 1-7 bytes.\n\t * </p>\n\t * \n\t * @param f1\n\t *            the file whose content is to be compared.\n\t * @param f2\n\t *            the other file whose content is to be compared.\n\t * \n\t * @return true if the content of the files is the same.\n\t * \n\t * @throws IOException\n\t *             if the files cannot be read.\n\t * \n\t * @since 1.9\n\t */\n\tpublic boolean contentEquals(File f1, File f2) throws IOException {\n\t\tif (f1.exists() != f2.exists()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!f1.exists()) {\n\t\t\t// two not existing files are equal\n\t\t\treturn true;\n\t\t}\n\n\t\tif (f1.isDirectory() || f2.isDirectory()) {\n\t\t\t// don't want to compare directory contents for now\n\t\t\treturn false;\n\t\t}\n\n\t\tif (fileNameEquals(f1, f2)) {\n\t\t\t// same filename => true\n\t\t\treturn true;\n\t\t}\n\n\t\tif (f1.length() != f2.length()) {\n\t\t\t// different size =>false\n\t\t\treturn false;\n\t\t}\n\n\t\tInputStream in1 = null;\n\t\tInputStream in2 = null;\n\t\ttry {\n\t\t\tin1 = new BufferedInputStream(new FileInputStream(f1));\n\t\t\tin2 = new BufferedInputStream(new FileInputStream(f2));\n\n\t\t\tint expectedByte = in1.read();\n\t\t\twhile (expectedByte != -1) {\n\t\t\t\tif (expectedByte != in2.read()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\texpectedByte = in1.read();\n\t\t\t}\n\t\t\tif (in2.read() != -1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t} finally {\n\t\t\tif (in1 != null) {\n\t\t\t\ttry {\n\t\t\t\t\tin1.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (in2 != null) {\n\t\t\t\ttry {\n\t\t\t\t\tin2.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Emulation of File.getParentFile for JDK 1.1\n\t * \n\t * \n\t * @param f\n\t *            the file whose parent is required.\n\t * @return the given file's parent, or null if the file does not have a\n\t *         parent.\n\t * @since 1.10\n\t */\n\tpublic File getParentFile(File f) {\n\t\tif (f != null) {\n\t\t\tString p = f.getParent();\n\t\t\tif (p != null) {\n\t\t\t\treturn new File(p);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Read from reader till EOF\n\t * \n\t * @param rdr\n\t *            the reader from which to read.\n\t * @return the contents read out of the given reader\n\t * \n\t * @throws IOException\n\t *             if the contents could not be read out from the reader.\n\t */\n\tpublic static final String readFully(Reader rdr) throws IOException {\n\t\treturn readFully(rdr, 8192);\n\t}\n\n\t/**\n\t * Read from reader till EOF\n\t * \n\t * @param rdr\n\t *            the reader from which to read.\n\t * @param bufferSize\n\t *            the buffer size to use when reading\n\t * \n\t * @return the contents read out of the given reader\n\t * \n\t * @throws IOException\n\t *             if the contents could not be read out from the reader.\n\t */\n\tpublic static final String readFully(Reader rdr, int bufferSize)\n\t\t\tthrows IOException {\n\t\tif (bufferSize <= 0) {\n\t\t\tthrow new IllegalArgumentException(\"Buffer size must be \ngreater \"\n\t\t\t\t\t+ \"than 0\");\n\t\t}\n\t\tfinal char[] buffer = new char[bufferSize];\n\t\tint bufferLength = 0;\n\t\tString text = null;\n\t\tStringBuffer textBuffer = null;\n\t\twhile (bufferLength != -1) {\n\t\t\tbufferLength = rdr.read(buffer);\n\t\t\tif (bufferLength != -1) {\n\t\t\t\tif (textBuffer == null) {\n\t\t\t\t\ttextBuffer = new StringBuffer(new String\n(buffer, 0,\n\t\t\t\t\t\t\tbufferLength));\n\t\t\t\t} else {\n\t\t\t\t\ttextBuffer.append(new String(buffer, 0, \nbufferLength));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (textBuffer != null) {\n\t\t\ttext = textBuffer.toString();\n\t\t}\n\t\treturn text;\n\t}\n\n\t/**\n\t * Emulation of File.createNewFile for JDK 1.1.\n\t * \n\t * <p>\n\t * This method does <strong>not </strong> guarantee that the operation \nis\n\t * atomic.\n\t * </p>\n\t * \n\t * @param f\n\t *            the file to be created\n\t * @return true if the file did not exist already.\n\t * @since Ant 1.5\n\t */\n\tpublic boolean createNewFile(File f) throws IOException {\n\t\tif (f != null) {\n\t\t\tif (f.exists()) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tFileOutputStream fos = null;\n\t\t\ttry {\n\t\t\t\tfos = new FileOutputStream(f);\n\t\t\t\tfos.write(new byte[0]);\n\t\t\t} finally {\n\t\t\t\tif (fos != null) {\n\t\t\t\t\tfos.close();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Checks whether a given file is a symbolic link.\n\t * \n\t * <p>\n\t * It doesn't really test for symbolic links but whether the canonical \nand\n\t * absolute paths of the file are identical - this may lead to false\n\t * positives on some platforms.\n\t * </p>\n\t * \n\t * @param parent\n\t *            the parent directory of the file to test\n\t * @param name\n\t *            the name of the file to test.\n\t * \n\t * @return true if the file is a symbolic link.\n\t * @since Ant 1.5\n\t */\n\tpublic boolean isSymbolicLink(File parent, String name) throws \nIOException {\n\t\tFile resolvedParent = new File(parent.getCanonicalPath());\n\t\tFile toTest = new File(resolvedParent, name);\n\t\treturn !toTest.getAbsolutePath().equals(toTest.getCanonicalPath\n());\n\t}\n\n\t/**\n\t * Removes a leading path from a second path.\n\t * \n\t * @param leading\n\t *            The leading path, must not be null, must be absolute.\n\t * @param path\n\t *            The path to remove from, must not be null, must be \nabsolute.\n\t * \n\t * @return path's normalized absolute if it doesn't start with leading,\n\t *         path's path with leading's path removed otherwise.\n\t * \n\t * @since Ant 1.5\n\t */\n\tpublic String removeLeadingPath(File leading, File path) {\n\t\tString l = normalize(leading.getAbsolutePath()).getAbsolutePath\n();\n\t\tString p = normalize(path.getAbsolutePath()).getAbsolutePath();\n\t\tif (l.equals(p)) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\t// ensure that l ends with a /\n\t\t// so we never think /foo was a parent directory of /foobar\n\t\tif (!l.endsWith(File.separator)) {\n\t\t\tl += File.separator;\n\t\t}\n\n\t\tif (p.startsWith(l)) {\n\t\t\treturn p.substring(l.length());\n\t\t} else {\n\t\t\treturn p;\n\t\t}\n\t}\n\n\t/**\n\t * Constructs a <code>file:</code> URI that represents the external form\n\t * of the given pathname.\n\t * \n\t * <p>\n\t * Will be an absolute URI if the given path is absolute.\n\t * </p>\n\t * \n\t * <p>\n\t * This code doesn't handle non-ASCII characters properly.\n\t * </p>\n\t * \n\t * @param path\n\t *            the path in the local file system\n\t * @return the URI version of the local path.\n\t * @since Ant 1.6\n\t */\n\tpublic String toURI(String path) {\n\t\tboolean isDir = (new File(path)).isDirectory();\n\n\t\tStringBuffer sb = new StringBuffer(\"file:\");\n\n\t\t// catch exception if normalize thinks this is not an absolute \npath\n\t\ttry {\n\t\t\tpath = normalize(path).getAbsolutePath();\n\t\t\tsb.append(\"//\");\n\t\t\t// add an extra slash for filesystems with drive-\nspecifiers\n\t\t\tif (!path.startsWith(File.separator)) {\n\t\t\t\tsb.append(\"/\");\n\t\t\t}\n\n\t\t} catch (BuildException e) {\n\t\t\t// relative path\n\t\t}\n\n\t\tpath = path.replace('\\\\', '/');\n\n\t\tCharacterIterator iter = new StringCharacterIterator(path);\n\t\tfor (char c = iter.first(); c != CharacterIterator.DONE; c = \niter\n\t\t\t\t.next()) {\n\t\t\tif (c < 256 && isSpecial[c]) {\n\t\t\t\tsb.append('%');\n\t\t\t\tsb.append(escapedChar1[c]);\n\t\t\t\tsb.append(escapedChar2[c]);\n\t\t\t} else {\n\t\t\t\tsb.append(c);\n\t\t\t}\n\t\t}\n\t\tif (isDir && !path.endsWith(\"/\")) {\n\t\t\tsb.append('/');\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\t/**\n\t * Constructs a file path from a <code>file:</code> URI.\n\t * \n\t * <p>\n\t * Will be an absolute path if the given URI is absolute.\n\t * </p>\n\t * \n\t * <p>\n\t * Swallows '%' that are not followed by two characters, doesn't deal \nwith\n\t * non-ASCII characters.\n\t * </p>\n\t * \n\t * @param uri\n\t *            the URI designating a file in the local filesystem.\n\t * @return the local file system path for the file.\n\t * @since Ant 1.6\n\t */\n\tpublic String fromURI(String uri) {\n\t\tString path = Locator.fromURI(uri);\n\n\t\t// catch exception if normalize thinks this is not an absolute \npath\n\t\ttry {\n\t\t\tpath = normalize(path).getAbsolutePath();\n\t\t} catch (BuildException e) {\n\t\t\t// relative path\n\t\t}\n\t\treturn path;\n\t}\n\n\t/**\n\t * Compares two filenames.\n\t * \n\t * <p>\n\t * Unlike java.io.File#equals this method will try to compare the \nabsolute\n\t * paths and &quot;normalize&quot; the filenames before comparing them.\n\t * </p>\n\t * \n\t * @param f1\n\t *            the file whose name is to be compared.\n\t * @param f2\n\t *            the other file whose name is to be compared.\n\t * \n\t * @return true if the file are for the same file.\n\t * \n\t * @since Ant 1.5.3\n\t */\n\tpublic boolean fileNameEquals(File f1, File f2) {\n\t\treturn normalize(f1.getAbsolutePath()).equals(\n\t\t\t\tnormalize(f2.getAbsolutePath()));\n\t}\n\n\t/**\n\t * Renames a file, even if that involves crossing file system \nboundaries.\n\t * \n\t * <p>\n\t * This will remove <code>to</code> (if it exists), ensure that\n\t * <code>to</code>'s parent directory exists and move <code>from</code>,\n\t * which involves deleting <code>from</code> as well.\n\t * </p>\n\t * \n\t * @throws IOException\n\t *             if anything bad happens during this process. Note that\n\t *             <code>to</code> may have been deleted already when this\n\t *             happens.\n\t * \n\t * @param from\n\t *            the file to move\n\t * @param to\n\t *            the new file name\n\t * \n\t * @since Ant 1.6\n\t */\n\tpublic void rename(File from, File to) throws IOException {\n\t\tif (to.exists() && !to.delete()) {\n\t\t\tthrow new IOException(\"Failed to delete \" + to\n\t\t\t\t\t+ \" while trying to rename \" + from);\n\t\t}\n\n\t\tFile parent = getParentFile(to);\n\t\tif (parent != null && !parent.exists() && !parent.mkdirs()) {\n\t\t\tthrow new IOException(\"Failed to create directory \" + \nparent\n\t\t\t\t\t+ \" while trying to rename \" + from);\n\t\t}\n\n\t\tif (!from.renameTo(to)) {\n\t\t\tcopyFile(from, to);\n\t\t\tif (!from.delete()) {\n\t\t\t\tthrow new IOException(\"Failed to delete \" + from\n\t\t\t\t\t\t+ \" while trying to rename \nit.\");\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic long getFileTimestampGranularity() {\n\t\tif (Os.isFamily(\"dos\")) {\n\t\t\treturn FAT_FILE_TIMESTAMP_GRANULARITY;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n\n/*\n * Created on Jul 12, 2004\n *\n * TODO To change the template for this generated file go to\n * Window - Preferences - Java - Code Style - Code Templates\n */\npackage org.apache.tools.ant.util;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.nio.channels.FileChannel;\nimport java.util.Vector;\nimport org.apache.tools.ant.Project;\nimport org.apache.tools.ant.filters.util.ChainReaderHelper;\nimport org.apache.tools.ant.types.FilterSetCollection;\n\n/**\n * @author jbleijen\n * \n * TODO To change the template for this generated type comment go to Window -\n * Preferences - Java - Code Style - Code Templates\n */\npublic class NioFileUtils extends FileUtils {\n\n\t/**\n\t * Empty constructor.\n\t */\n\tprotected NioFileUtils() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * Convienence method to copy a file from a source to a destination\n\t * specifying if token filtering must be used, if filter chains must be\n\t * used, if source files may overwrite newer destination files and the \nlast\n\t * modified time of <code>destFile</code> file should be made equal to \nthe\n\t * last modified time of <code>sourceFile</code>.\n\t * \n\t * @param sourceFile\n\t *            the file to copy from. Must not be <code>null</code>.\n\t * @param destFile\n\t *            the file to copy to. Must not be <code>null</code>.\n\t * @param filters\n\t *            the collection of filters to apply to this copy\n\t * @param filterChains\n\t *            filterChains to apply during the copy.\n\t * @param overwrite\n\t *            Whether or not the destination file should be overwritten \nif\n\t *            it already exists.\n\t * @param preserveLastModified\n\t *            Whether or not the last modified time of the resulting \nfile\n\t *            should be set to that of the source file.\n\t * @param inputEncoding\n\t *            the encoding used to read the files.\n\t * @param outputEncoding\n\t *            the encoding used to write the files.\n\t * @param project\n\t *            the project instance\n\t * \n\t * \n\t * @throws IOException\n\t *             if the copying fails\n\t * \n\t * @since Ant 1.6\n\t */\n\tpublic void copyFile(File sourceFile, File destFile,\n\t\t\tFilterSetCollection filters, Vector filterChains,\n\t\t\tboolean overwrite, boolean preserveLastModified,\n\t\t\tString inputEncoding, String outputEncoding, Project \nproject)\n\t\t\tthrows IOException {\n\t\tif (overwrite || !destFile.exists()\n\t\t\t\t|| destFile.lastModified() < \nsourceFile.lastModified()) {\n\n\t\t\t//if (destFile.exists() && destFile.isFile()) {\n\t\t\t//\tdestFile.delete();\n\t\t\t//}\n\n\t\t\t// ensure that parent dir of dest file exists!\n\t\t\t// not using getParentFile method to stay 1.1 compat\n\t\t\tFile parent = getParentFile(destFile);\n\t\t\tif (parent != null && !parent.exists()) {\n\t\t\t\tparent.mkdirs();\n\t\t\t}\n\n\t\t\tfinal boolean filterSetsAvailable = (filters != null && \nfilters\n\t\t\t\t\t.hasFilters());\n\t\t\tfinal boolean filterChainsAvailable = (filterChains != \nnull && filterChains\n\t\t\t\t\t.size() > 0);\n\n\t\t\tif (filterSetsAvailable) {\n\t\t\t\tBufferedReader in = null;\n\t\t\t\tBufferedWriter out = null;\n\n\t\t\t\ttry {\n\t\t\t\t\tif (inputEncoding == null) {\n\t\t\t\t\t\tin = new BufferedReader(new \nFileReader(sourceFile));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tInputStreamReader isr = new \nInputStreamReader(\n\t\t\t\t\t\t\t\tnew \nFileInputStream(sourceFile), inputEncoding);\n\t\t\t\t\t\tin = new BufferedReader(isr);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (outputEncoding == null) {\n\t\t\t\t\t\tout = new BufferedWriter(new \nFileWriter(destFile));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tOutputStreamWriter osw = new \nOutputStreamWriter(\n\t\t\t\t\t\t\t\tnew \nFileOutputStream(destFile), outputEncoding);\n\t\t\t\t\t\tout = new BufferedWriter(osw);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (filterChainsAvailable) {\n\t\t\t\t\t\tChainReaderHelper crh = new \nChainReaderHelper();\n\t\t\t\t\t\tcrh.setBufferSize(8192);\n\t\t\t\t\t\tcrh.setPrimaryReader(in);\n\t\t\t\t\t\tcrh.setFilterChains\n(filterChains);\n\t\t\t\t\t\tcrh.setProject(project);\n\t\t\t\t\t\tReader rdr = \ncrh.getAssembledReader();\n\t\t\t\t\t\tin = new BufferedReader(rdr);\n\t\t\t\t\t}\n\n\t\t\t\t\tLineTokenizer lineTokenizer = new \nLineTokenizer();\n\t\t\t\t\tlineTokenizer.setIncludeDelims(true);\n\t\t\t\t\tString newline = null;\n\t\t\t\t\tString line = lineTokenizer.getToken\n(in);\n\t\t\t\t\twhile (line != null) {\n\t\t\t\t\t\tif (line.length() == 0) {\n\t\t\t\t\t\t\t// this should not \nhappen, because the lines are\n\t\t\t\t\t\t\t// returned with the \nend of line delimiter\n\t\t\t\t\t\t\tout.newLine();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnewline = \nfilters.replaceTokens(line);\n\t\t\t\t\t\t\tout.write(newline);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tline = lineTokenizer.getToken\n(in);\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (out != null) {\n\t\t\t\t\t\tout.close();\n\t\t\t\t\t}\n\t\t\t\t\tif (in != null) {\n\t\t\t\t\t\tin.close();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (filterChainsAvailable\n\t\t\t\t\t|| (inputEncoding != null && !\ninputEncoding\n\t\t\t\t\t\t\t.equals(outputEncoding))\n\t\t\t\t\t|| (inputEncoding == null && \noutputEncoding != null)) {\n\t\t\t\tBufferedReader in = null;\n\t\t\t\tBufferedWriter out = null;\n\n\t\t\t\ttry {\n\t\t\t\t\tif (inputEncoding == null) {\n\t\t\t\t\t\tin = new BufferedReader(new \nFileReader(sourceFile));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tin = new BufferedReader(new \nInputStreamReader(\n\t\t\t\t\t\t\t\tnew \nFileInputStream(sourceFile), inputEncoding));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (outputEncoding == null) {\n\t\t\t\t\t\tout = new BufferedWriter(new \nFileWriter(destFile));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout = new BufferedWriter(new \nOutputStreamWriter(\n\t\t\t\t\t\t\t\tnew \nFileOutputStream(destFile), outputEncoding));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (filterChainsAvailable) {\n\t\t\t\t\t\tChainReaderHelper crh = new \nChainReaderHelper();\n\t\t\t\t\t\tcrh.setBufferSize(8192);\n\t\t\t\t\t\tcrh.setPrimaryReader(in);\n\t\t\t\t\t\tcrh.setFilterChains\n(filterChains);\n\t\t\t\t\t\tcrh.setProject(project);\n\t\t\t\t\t\tReader rdr = \ncrh.getAssembledReader();\n\t\t\t\t\t\tin = new BufferedReader(rdr);\n\t\t\t\t\t}\n\t\t\t\t\tchar[] buffer = new char[1024 * 8];\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tint nRead = in.read(buffer, 0, \nbuffer.length);\n\t\t\t\t\t\tif (nRead == -1) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tout.write(buffer, 0, nRead);\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (out != null) {\n\t\t\t\t\t\tout.close();\n\t\t\t\t\t}\n\t\t\t\t\tif (in != null) {\n\t\t\t\t\t\tin.close();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tFileInputStream in = null;\n\t\t\t\tFileOutputStream out = null;\n\t\t\t\tFileChannel srcChannel=null;\n\t\t\t\tFileChannel destChannel=null;\n\n\t\t\t\ttry {\n\t\t\t\t\t// we can use direct copy with nio\n\t\t\t\t\tin = new FileInputStream(sourceFile);\n\t\t\t\t\tout = new FileOutputStream(destFile);\n\t\t\t\t\t\t\n\t\t\t\t\tsrcChannel=in.getChannel();\n\t\t\t\t\tdestChannel=out.getChannel();\n\t\t\t\t\t\n\t\t\t\t\tlong \nbytesThatShouldBeCopied=srcChannel.size();\n\t\t\t\t\tlong bytesCopied=srcChannel.transferTo\n(0, bytesThatShouldBeCopied, destChannel);\n\t\t\t\t\tif (bytesThatShouldBeCopied!\n=bytesCopied)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new IOException(\"Error \ncopying file from '\"+sourceFile.getAbsolutePath()+\"' \nto '\"+destFile.getAbsolutePath()+\"' copied only:\"+bytesCopied+\" bytes instead \nof \"+bytesThatShouldBeCopied);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t} finally {\n\t\t\t\t\tif (srcChannel != null) {\n\t\t\t\t\t\tsrcChannel.close();\n\t\t\t\t\t}\n\t\t\t\t\tif (destChannel != null) {\n\t\t\t\t\t\tdestChannel.close();\n\t\t\t\t\t}\n\t\t\t\t\tif (out != null) {\n\t\t\t\t\t\tout.close();\n\t\t\t\t\t}\n\t\t\t\t\tif (in != null) {\n\t\t\t\t\t\tin.close();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (preserveLastModified) {\n\t\t\t\tsetFileLastModified(destFile, \nsourceFile.lastModified());\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n * Copyright  2003-2004 The Apache Software Foundation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n */\npackage org.apache.tools.ant.util;\n\nimport org.apache.tools.ant.Project;\nimport org.apache.tools.ant.ProjectComponent;\nimport org.apache.tools.ant.types.Resource;\nimport org.apache.tools.ant.types.ResourceFactory;\nimport org.apache.tools.ant.types.selectors.SelectorUtils;\n\nimport java.io.File;\nimport java.util.Vector;\n\n/**\n * this class provides utility methods to process resources\n *\n * @since Ant 1.5.2\n */\npublic class ResourceUtils {\n\n    /**\n     * tells which source files should be reprocessed based on the\n     * last modification date of target files\n     * @param logTo where to send (more or less) interesting output\n     * @param source array of resources bearing relative path and last\n     * modification date\n     * @param mapper filename mapper indicating how to find the target\n     * files\n     * @param targets object able to map as a resource a relative path\n     * at <b>destination</b>\n     * @return array containing the source files which need to be\n     * copied or processed, because the targets are out of date or do\n     * not exist\n     */\n    public static Resource[] selectOutOfDateSources(ProjectComponent logTo,\n                                                    Resource[] source,\n                                                    FileNameMapper mapper,\n                                                    ResourceFactory targets) {\n        return selectOutOfDateSources(logTo, source, mapper, targets,\n                                      FileUtils.newFileUtils()\n                                      .getFileTimestampGranularity());\n    }\n\n    /**\n     * tells which source files should be reprocessed based on the\n     * last modification date of target files\n     * @param logTo where to send (more or less) interesting output\n     * @param source array of resources bearing relative path and last\n     * modification date\n     * @param mapper filename mapper indicating how to find the target\n     * files\n     * @param targets object able to map as a resource a relative path\n     * at <b>destination</b>\n     * @param granularity The number of milliseconds leeway to give\n     * before deciding a target is out of date.\n     * @return array containing the source files which need to be\n     * copied or processed, because the targets are out of date or do\n     * not exist\n     * @since Ant 1.6.2\n     */\n    public static Resource[] selectOutOfDateSources(ProjectComponent logTo,\n                                                    Resource[] source,\n                                                    FileNameMapper mapper,\n                                                    ResourceFactory targets,\n                                                    long granularity) {\n        long now = (new java.util.Date()).getTime() + granularity;\n\n        Vector vresult = new Vector();\n        for (int counter = 0; counter < source.length; counter++) {\n//            if (source[counter].getLastModified() > now) {\n//                logTo.log(\"Warning: \" + source[counter].getName()\n//                         + \" modified in the future.\",\n//                         Project.MSG_WARN);\n//            }\n\n            String[] targetnames =\n                mapper.mapFileName(source[counter].getName()\n                                   .replace('/', File.separatorChar));\n            if (targetnames != null) {\n                boolean added = false;\n                StringBuffer targetList = new StringBuffer();\n                for (int ctarget = 0; !added && ctarget < targetnames.length;\n                     ctarget++) {\n                    Resource atarget =\n                        targets.getResource(targetnames[ctarget]\n                                            .replace(File.separatorChar, '/'));\n                    // if the target does not exist, or exists and\n                    // is older than the source, then we want to\n                    // add the resource to what needs to be copied\n                    if (!atarget.isExists()) {\n                        logTo.log(source[counter].getName() + \" added as \"\n                                  + atarget.getName()\n                                  + \" doesn\\'t exist.\", Project.MSG_VERBOSE);\n                        vresult.addElement(source[counter]);\n                        added = true;\n                    } else if (!atarget.isDirectory() &&\n                               SelectorUtils.isOutOfDate(source[counter],\n                                                         atarget,\n                                                         (int) granularity)) {\n                        logTo.log(source[counter].getName() + \" added as \"\n                                  + atarget.getName()\n                                  + \" is outdated.\", Project.MSG_VERBOSE);\n                        vresult.addElement(source[counter]);\n                        added = true;\n                    } else {\n                        if (targetList.length() > 0) {\n                            targetList.append(\", \");\n                        }\n                        targetList.append(atarget.getName());\n                    }\n                }\n\n                if (!added) {\n                    logTo.log(source[counter].getName()\n                              + \" omitted as \" + targetList.toString()\n                              + (targetnames.length == 1 ? \" is\" : \" are \")\n                              + \" up to date.\", Project.MSG_VERBOSE);\n                }\n            } else {\n                logTo.log(source[counter].getName()\n                          + \" skipped - don\\'t know how to handle it\",\n                          Project.MSG_VERBOSE);\n            }\n        }\n        Resource[] result = new Resource[vresult.size()];\n        vresult.copyInto(result);\n        return result;\n    }\n}\n\n/*\n * Copyright  2000-2004 The Apache Software Foundation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n */\n\npackage org.apache.tools.ant.util;\n\nimport java.io.File;\nimport java.util.Vector;\nimport org.apache.tools.ant.Task;\nimport org.apache.tools.ant.types.ResourceFactory;\nimport org.apache.tools.ant.types.Resource;\nimport org.apache.tools.ant.types.ResourceFile;\n\n/**\n * Utility class that collects the functionality of the various\n * scanDir methods that have been scattered in several tasks before.\n *\n * <p>The only method returns an array of source files. The array is a\n * subset of the files given as a parameter and holds only those that\n * are newer than their corresponding target files.</p>\n *\n */\npublic class SourceFileScanner implements ResourceFactory {\n\n    protected Task task;\n\n    private FileUtils fileUtils;\n    private File destDir;     // base directory of the fileset\n\n    /**\n     * @param task The task we should log messages through\n     */\n    public SourceFileScanner(Task task) {\n        this.task = task;\n        fileUtils = FileUtils.newFileUtils();\n    }\n\n    /**\n     * Restrict the given set of files to those that are newer than\n     * their corresponding target files.\n     *\n     * @param files   the original set of files\n     * @param srcDir  all files are relative to this directory\n     * @param destDir target files live here. if null file names\n     *                returned by the mapper are assumed to be absolute.\n     * @param mapper  knows how to construct a target file names from\n     *                source file names.\n     */\n    public String[] restrict(String[] files, File srcDir, File destDir,\n                             FileNameMapper mapper) {\n        return restrict(files, srcDir, destDir, mapper,\n                        fileUtils.getFileTimestampGranularity());\n    }\n\n    /**\n     * Restrict the given set of files to those that are newer than\n     * their corresponding target files.\n     *\n     * @param files   the original set of files\n     * @param srcDir  all files are relative to this directory\n     * @param destDir target files live here. if null file names\n     *                returned by the mapper are assumed to be absolute.\n     * @param mapper  knows how to construct a target file names from\n     *                source file names.\n     * @param granularity The number of milliseconds leeway to give\n     *                    before deciding a target is out of date.\n     *\n     * @since Ant 1.6.2\n     */\n    public String[] restrict(String[] files, File srcDir, File destDir,\n                             FileNameMapper mapper, long granularity) {\n        // record destdir for later use in getResource\n        this.destDir = destDir;\n        Vector v = new Vector();\n        for (int i = 0; i < files.length; i++) {\n            File src = fileUtils.resolveFile(srcDir, files[i]);\n            ResourceFile rf=new ResourceFile(files[i],src);\n            rf.setExists(true);\n            v.addElement(rf);\n        }\n        Resource[] sourceresources = new Resource[v.size()];\n        v.copyInto(sourceresources);\n\n        // build the list of sources which are out of date with\n        // respect to the target\n        Resource[] outofdate =\n            ResourceUtils.selectOutOfDateSources(task, sourceresources,\n                                                 mapper, this, granularity);\n        String[] result = new String[outofdate.length];\n        for (int counter = 0; counter < outofdate.length; counter++) {\n            result[counter] = outofdate[counter].getName();\n        }\n        return result;\n    }\n\n    /**\n     * Convinience layer on top of restrict that returns the source\n     * files as File objects (containing absolute paths if srcDir is\n     * absolute).\n     */\n    public File[] restrictAsFiles(String[] files, File srcDir, File destDir,\n                                  FileNameMapper mapper) {\n        return restrictAsFiles(files, srcDir, destDir, mapper,\n                               fileUtils.getFileTimestampGranularity());\n    }\n\n    /**\n     * Convinience layer on top of restrict that returns the source\n     * files as File objects (containing absolute paths if srcDir is\n     * absolute).\n     *\n     * @since Ant 1.6.2\n     */\n    public File[] restrictAsFiles(String[] files, File srcDir, File destDir,\n                                  FileNameMapper mapper, long granularity) {\n        String[] res = restrict(files, srcDir, destDir, mapper, granularity);\n        File[] result = new File[res.length];\n        for (int i = 0; i < res.length; i++) {\n            result[i] = new File(srcDir, res[i]);\n        }\n        return result;\n    }\n\n    /**\n     * returns resource information for a file at destination\n     * @param name relative path of file at destination\n     * @return data concerning a file whose relative path to destDir is name\n     *\n     * @since Ant 1.5.2\n     */\n    public Resource getResource(String name) {\n        File src = fileUtils.resolveFile(destDir, name);\n        return new ResourceFile(name,src);\n    }\n}"}, {"count": 1, "attachment_id": 12110, "bug_id": 30094, "is_private": false, "id": 60591, "time": "2004-07-14T07:17:13Z", "creator": "jbleijen@csc.com", "creation_time": "2004-07-14T07:17:13Z", "tags": [], "text": "Created attachment 12110\nSources and a jar containing the patch"}, {"count": 2, "attachment_id": null, "bug_id": 30094, "text": "The preferred form for a patch is a unified diff attachment.  This way we can \nquickly evaluate the changes suggested.\n\nThanks", "id": 60706, "time": "2004-07-16T15:43:03Z", "creator": "mbenson@apache.org", "creation_time": "2004-07-16T15:43:03Z", "tags": [], "is_private": false}, {"count": 3, "tags": [], "creator": "robin@debian.org", "text": "Created attachment 17385\n[faulty] java.nio changes against Ant 1.6.5, in unified diff format\n\nI've used the original modified source files attached to this bug and create a\npatch against 1.6.5 from them.", "id": 84472, "time": "2006-01-11T18:52:33Z", "bug_id": 30094, "creation_time": "2006-01-11T18:52:33Z", "is_private": false, "attachment_id": 17385}, {"count": 4, "tags": [], "bug_id": 30094, "attachment_id": 17386, "text": "Created attachment 17386\nlazy init changes against Ant 1.6.5, in unified diff format\n\nI've used the original modified source files attached to this bug and create a\npatch against 1.6.5 from them.", "id": 84473, "time": "2006-01-11T18:53:10Z", "creator": "robin@debian.org", "creation_time": "2006-01-11T18:53:10Z", "is_private": false}, {"count": 5, "tags": [], "text": "The second patch is completely irrelevant to Ant HEAD... one might argue the\nsecond patch could be structured into Ant HEAD in more valuable ways as well.", "attachment_id": null, "bug_id": 30094, "id": 84476, "time": "2006-01-11T19:21:00Z", "creator": "mbenson@apache.org", "creation_time": "2006-01-11T19:21:00Z", "is_private": false}, {"count": 6, "tags": [], "creator": "robin@debian.org", "attachment_id": 17385, "id": 84477, "time": "2006-01-11T19:24:03Z", "bug_id": 30094, "creation_time": "2006-01-11T19:24:03Z", "is_private": false, "text": "Comment on attachment 17385\n[faulty] java.nio changes against Ant 1.6.5, in unified diff format\n\nPatch fails on copying large files; need to change transfer size in\ntransferTo() call to a lower value."}, {"count": 7, "attachment_id": 17388, "bug_id": 30094, "text": "Created attachment 17388\n[faulty] java.nio changes against Ant 1.6.5, in unified diff format\n\nI've used the original modified source files attached to this bug and created a\n\npatch against 1.6.5 from them.", "id": 84478, "time": "2006-01-11T19:27:33Z", "creator": "robin@debian.org", "creation_time": "2006-01-11T19:27:33Z", "tags": [], "is_private": false}, {"count": 8, "tags": [], "creator": "robin@debian.org", "attachment_id": null, "id": 84479, "time": "2006-01-11T19:29:20Z", "bug_id": 30094, "creation_time": "2006-01-11T19:29:20Z", "is_private": false, "text": "Can't say I disagree with Matt Benson there; but I just wanted to make sure that\nthe original submitter's changes were both available in patch format rather than\nmodified Java code. In all fairness, the lazy init calls patch should not be in\nthis bug but in a feature request of its own."}, {"count": 9, "tags": [], "creator": "robin@debian.org", "text": "Created attachment 17389\njava.nio changes against Ant 1.6.5, in unified diff format\n\nI've used the original modified source files attached to this bug and created a\npatch against 1.6.5 from them.\n\nOne last time, to fix transferTo() buffer size.\nApologies for the attachment spam.", "id": 84480, "time": "2006-01-11T19:38:23Z", "bug_id": 30094, "creation_time": "2006-01-11T19:38:23Z", "is_private": false, "attachment_id": 17389}, {"count": 10, "tags": [], "bug_id": 30094, "attachment_id": null, "text": "(In reply to comment #5)\n> The second patch is completely irrelevant to Ant HEAD... one might argue the\n> second patch could be structured into Ant HEAD in more valuable ways as well.\n\ncorrection: the second occurrence of \"second\" should be \"first\".\n", "id": 84481, "time": "2006-01-11T19:47:40Z", "creator": "mbenson@apache.org", "creation_time": "2006-01-11T19:47:40Z", "is_private": false}, {"count": 11, "tags": [], "creator": "kevin.jackson@it.fts-vn.com", "text": "java.nio are only available as part of Java 1.4+, to accept this into the trunk\nwould mean a dependency on 1.4+ compiler to build ant - is this ok?  My\nunderstanding was that we should try to preserve bwc within ant (as a tool) and\nfor building ant itself - is this no longer a concern?", "id": 84500, "time": "2006-01-12T01:53:47Z", "bug_id": 30094, "creation_time": "2006-01-12T01:53:47Z", "is_private": false, "attachment_id": null}, {"count": 12, "tags": [], "creator": "jglick@apache.org", "text": "(In reply to comment #11)\n> java.nio are only available as part of Java 1.4+, to accept this into the trunk\n> would mean a dependency on 1.4+ compiler to build ant [...]\n\nCould probably be solved by adding to build.xml#needs.jdk1.4+ something like\n\n<filename name=\"${util.package}/NioFileUtils.java\"/>\n\nmeaning if compiled on JDK 1.3 the optimization would be unavailable.", "id": 84510, "time": "2006-01-12T07:35:34Z", "bug_id": 30094, "creation_time": "2006-01-12T07:35:34Z", "is_private": false, "attachment_id": null}, {"count": 13, "tags": [], "creator": "stevel@apache.org", "attachment_id": null, "id": 84521, "time": "2006-01-12T11:36:00Z", "bug_id": 30094, "creation_time": "2006-01-12T11:36:00Z", "is_private": false, "text": "It could be a compile-time-optional part of the runtime, something that is only\ndelegated to when the runtime is 1.4+. Which means that we'd need an\ninterface/facade to the operations and then an original+nio implementation, the\ndefault behaviour being to use nio on 1.4+, though with a switch to override\nthat so that the original code can still be tested.\n\nThis is a lot of effort; the speedup would have to be tangible. Are the any\nmeasurements, both for local and remote filesystems?\n\nThere is some justification for doing such a facade, and it isnt just possible\nspeedup -the facade could also offer access to the file permissions stuff coming\nin Java6.0, letting ant tasks work with permissions properly on the 6.0\nplatform, as and when it comes out. \n\n-steve"}, {"count": 14, "tags": [], "creator": "kevin.jackson@it.fts-vn.com", "text": "(In reply to comment #13)\n> It could be a compile-time-optional part of the runtime, something that is only\n> delegated to when the runtime is 1.4+. Which means that we'd need an\n> interface/facade to the operations and then an original+nio implementation, \n\n(pushed here from Antoine on the dev list ...)\n\nI've started looking into this and I can see that we need an interface of the\ncurrent FileUtils class (minus static methods) and then a factory to select the\nimplementation, and 2+ implementations, original/classic (ie what we have right\nnow), NioFileUtils (such as this code here in this bug report) and\nJava6FileUtils (for all the file permission goodies).\n\nI'm not sure how to resolve the problem that *a lot* of the current code\npresumes a lot about FileUtils (ie that certain methods are static etc).  Since\nwe have to maintain bwc, this will probably have to mean that the interface\ncontains definitions of all instance methods, and the original FileUtils will\nhave to keep the static methods (as they are public) and any new implementation\nwill have to delegate to the original for these methods.\n\nIs this a sensible strategy?\nKev", "id": 88309, "time": "2006-04-20T07:54:14Z", "bug_id": 30094, "creation_time": "2006-04-20T07:54:14Z", "is_private": false, "attachment_id": null}, {"count": 15, "attachment_id": null, "bug_id": 30094, "text": "Can static methods just execute non-static methods on util's singleton?", "id": 88323, "time": "2006-04-20T15:32:52Z", "creator": "alexeys@inventigo.com", "creation_time": "2006-04-20T15:32:52Z", "tags": [], "is_private": false}, {"count": 16, "tags": [], "bug_id": 30094, "attachment_id": null, "text": "(In reply to comment #15)\n> Can static methods just execute non-static methods on util's singleton?\n\nDefinetely,\n\nWe could even use the singleton  / constructor as factory and turn the FileUtils\ninto a proxy with embedded factory.", "id": 88327, "time": "2006-04-20T18:30:44Z", "creator": "jkf@apache.org", "creation_time": "2006-04-20T18:30:44Z", "is_private": false}, {"count": 17, "tags": [], "creator": "peterreilly@apache.org", "text": "I do not think that we need to make a version\nof FileUtils for java 1.3, 1.4, 5, 6, 7 etc. It is far too\nbig for that. The\nonly difference that I can see in the patch\nis part of the (overlong) copyfile method - the raw\nfile copy without filtering.\nThis part could be extracted from FileUtils.copyFile and\nit could use a runtime found implemention of the most efficient\nRawFileCopy class for this particular JVM.\n\n", "id": 93242, "time": "2006-09-08T17:12:00Z", "bug_id": 30094, "creation_time": "2006-09-08T17:12:00Z", "is_private": false, "attachment_id": null}, {"count": 18, "tags": [], "creator": "antoine@apache.org", "attachment_id": null, "id": 93247, "time": "2006-09-08T18:37:27Z", "bug_id": 30094, "creation_time": "2006-09-08T18:37:27Z", "is_private": false, "text": "Agreed Peter."}, {"count": 19, "attachment_id": 21368, "bug_id": 30094, "is_private": false, "id": 112707, "time": "2008-01-09T11:54:23Z", "creator": "verdujin@gmail.com", "creation_time": "2008-01-09T11:54:23Z", "tags": [], "text": "Created attachment 21368\n[faulty] java.nio changes against Ant 1.7.0, in unified diff format\n\nI have modified the original NIO changes and applied them against Ant 1.7.0.\nThese changes work with the new Resources framework."}, {"count": 20, "tags": [], "creator": "verdujin@gmail.com", "attachment_id": 21369, "id": 112708, "time": "2008-01-09T12:06:59Z", "bug_id": 30094, "creation_time": "2008-01-09T12:06:59Z", "is_private": false, "text": "Created attachment 21369\njava.nio changes against Ant 1.7.0, in unified diff format"}, {"count": 21, "attachment_id": null, "bug_id": 30094, "is_private": false, "id": 129914, "time": "2009-08-25T01:50:49Z", "creator": "bodewig@apache.org", "creation_time": "2009-08-25T01:50:49Z", "tags": [], "text": "since Ant 1.8.0 requires Java 1.4 the patch can go in more or less unchanged.\n\nI've kept the buffer size at 8k like we use for the loop-operation - doesn anybody know whether 64k (in the original patch) would be better/worse for specific operating systems or VMs?\n\nsvn revision 807523"}]