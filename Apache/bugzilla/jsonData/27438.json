[{"count": 0, "tags": [], "creator": "gtesei@yahoo.com", "attachment_id": null, "text": "Hi there, \n\nI think that in JDBCAppender the method execute could work unsafely \n\nprotected void execute(String sql) throws SQLException {\n\n    Connection con = null;\n    Statement stmt = null;\n\n    try {\n        con = getConnection();\n\n        stmt = con.createStatement();\n        stmt.executeUpdate(sql);\n    } catch (SQLException e) {\n       if (stmt != null)\n\t     stmt.close();\n       throw e;\n    }\n    stmt.close();\n    closeConnection(con);\n\n    //System.out.println(\"Execute: \" + sql);\n  }\n\nbecause if there is an exception,  closeConnection(con) is never called. This\nmigth be very dangerous in case the sql statement return back exceptions from db\n. In this case log4j could make busy a lot of db connections, that never will be\nreleased. I think this implementation could work better. \n\nprotected void execute(String sql) throws SQLException {\n\n\t\tConnection con = null;\n\t\tStatement stmt = null;\n\n\t\ttry {\n\t\t\tcon = getConnection();\n\n\t\t\tstmt = con.createStatement();\n\t\t\tstmt.executeUpdate(sql);\n\t\t} finally {\n\t\t\tif (stmt != null) {\n\t\t\t\ttry {\n\t\t\t\t\tstmt.close();\n\t\t\t\t} catch (SQLException e) {  }\n\t\t\t}\n\t\t\tcloseConnection(con);\n\t\t}\n\t}\n\n\n\nRegards, \n           \n            Gino Tesei", "id": 53429, "time": "2004-03-04T15:01:01Z", "bug_id": 27438, "creation_time": "2004-03-04T15:01:01Z", "is_private": false}, {"count": 1, "tags": [], "creator": "clement.ong@shinetech.com", "attachment_id": null, "text": "In environments where corporate firewall exists between the deamon process \nthat uses JDBCAppender and the database, these cached JDBC connections are \ninvalidated by the firewall as a result of being inactive beyond a certain \nperiod, .eg 30 minutes. \n\nThe manner in which the JDBCAppender has been implemented will never recover \nfrom this failed condition. What's worst is it actually introdcued memory \nleak. A study of the flush method reveals that logger events are never removed \nwhenever an exception occurs.\n\n", "id": 54796, "time": "2004-03-29T01:11:31Z", "bug_id": 27438, "creation_time": "2004-03-29T01:11:31Z", "is_private": false}, {"count": 2, "tags": [], "creator": "clement.ong@shinetech.com", "attachment_id": null, "text": "Below is our implementation that allows a retry due to error errors executing \na piece of SQL statement. It assumes that this error is caused by a stale JDBC \nConnection.\n\n   /**\n     * This method is called to execute the instance of the SQL statement\n     * for the first time.\n     * \n     * @param sql - sql to execute\n     * @throws SQLException\n     */\n    protected void execute(String sql) throws SQLException\n    {\n        execute(sql, true);\n    }\n    /** \n     *\n     * Override this to provide an alertnate method of getting\n     * connections (such as caching).  One method to fix this is to open\n     * connections at the start of flushBuffer() and close them at the\n     * end.  I use a connection pool outside of JDBCAppender which is\n     * accessed in an override of this method.\n     * \n     * Retry the statement if it failed the first time as this may due\n     * to the database connection(due to being inactive beyond the timeout\n     * value) being dropped by the firewall.\n     * \n     * @param sql - sql statement to execute\n     * @param firstTime - indicate whether this is the first time this\n     *        particular instance of the SQL is executed\n     **/\n    protected void execute(String sql, boolean firstTime) throws SQLException\n    {\n        Connection con = null;\n        Statement stmt = null;\n        try\n        {\n            con = getConnection();\n            stmt = con.createStatement();\n            stmt.executeUpdate(sql);\n        }\n        catch (SQLException e)\n        {\n            try\n            {\n                if (stmt != null)\n                    stmt.close();\n            }\n            finally\n            {\n                if (firstTime)\n                {\n                    retry(con, sql);\n                }\n                else\n                {\n                    if (con != null)\n                    {\n                        connection = null;\n                        try\n                        {\n                            con.close();\n                        }\n                        catch (Exception ignore)\n                        {}\n                    }\n                    throw e;\n                }\n            }\n        }\n        stmt.close();\n        closeConnection(con);\n    }\n    /**\n     * Retry the execution of the SQL statement only once.\n     * @param con - connection to close and reset to null\n     * @param sql - statement to reexecute\n     * @throws SQLException\n     */\n    protected void retry(Connection con, String sql) throws SQLException\n    {\n        // if there is an error executing the SQL statement then\n        // close the connection too. This is to overcome problems\n        // associated with the firewall dropping inactive \n        // connections\n        if (con != null)\n        {\n            connection = null;\n            try\n            {\n                con.close();\n            }\n            catch (Exception ignore)\n            {}\n        }\n        execute(sql, false);\n    }", "id": 54797, "time": "2004-03-29T01:14:28Z", "bug_id": 27438, "creation_time": "2004-03-29T01:14:28Z", "is_private": false}, {"count": 3, "tags": [], "bug_id": 27438, "text": "Hi Clement, \n\nyour observations concerning firewall hold. Just one thing: if sql is bad \n(e.g. \"insert intoS ...\") connections will be never closed\n\n                if (firstTime)\n                {\n                    retry(con, sql); //throws a new Exception \n                }\n                else\n                {\n                    if (con != null)\n                    {\n                        connection = null;\n                        try\n                        {\n                            con.close();\n                        }\n                        catch (Exception ignore)\n                        {}\n                    }\n                    throw e;\n                }\n            }\n        }\n        stmt.close();\n        closeConnection(con); //never reached \n\n\nAs a conseguence, for each attempt to write a log event a new connection is \nopened and \"never\" released. \n\n\n\nRegards, \n      Gino Tesei", "id": 54806, "time": "2004-03-29T09:12:47Z", "creator": "gtesei@yahoo.com", "creation_time": "2004-03-29T09:12:47Z", "is_private": false, "attachment_id": null}, {"count": 4, "tags": [], "bug_id": 27438, "text": "\nHello,\n\nIs this bug report relative to the JDBCAppender marked \"buggy not for \nproduction use\" in red that ships with 1.2.x?", "id": 54807, "time": "2004-03-29T09:36:20Z", "creator": "ceki@apache.org", "creation_time": "2004-03-29T09:36:20Z", "is_private": false, "attachment_id": null}, {"count": 5, "tags": [], "bug_id": 27438, "attachment_id": null, "id": 54809, "time": "2004-03-29T10:21:12Z", "creator": "gtesei@yahoo.com", "creation_time": "2004-03-29T10:21:12Z", "is_private": false, "text": "Yes, it is.   \n\nThere is the red label \"WARNING: This version of JDBCAppender is very likely to \nbe completely replaced in the future. Moreoever, it does not log exceptions.\" \n\nGood luck. \n"}, {"count": 6, "tags": [], "bug_id": 27438, "text": "Please try the PreparedStatementAppender in the log4j-sandbox (available via\nApache's CVS server).  The PreparedStatementAppender allows you to control how\nthe connections are obtained via the ConnectionSource interface.  Furthermore,\nit does not cache connections but allows you to install whatever caching\nmechanism is appropriate for your environment.", "id": 54843, "time": "2004-03-30T03:12:39Z", "creator": "rdecampo@twcny.rr.com", "creation_time": "2004-03-30T03:12:39Z", "is_private": false, "attachment_id": null}, {"count": 7, "tags": [], "creator": "clement.ong@shinetech.com", "attachment_id": null, "text": "Hi Gino,\n\nThe statements was there in the original version. I've left them untouched\n\n  stmt.close();\n  closeConnection(con); //never reached \n\nThe bad(potentially bad) connection is closed in the retry method and will \nalways be closed in the finally block on the second attempt.\n", "id": 54922, "time": "2004-03-31T03:32:56Z", "bug_id": 27438, "creation_time": "2004-03-31T03:32:56Z", "is_private": false}, {"count": 8, "tags": [], "bug_id": 27438, "attachment_id": null, "id": 54923, "time": "2004-03-31T03:36:10Z", "creator": "clement.ong@shinetech.com", "creation_time": "2004-03-31T03:36:10Z", "is_private": false, "text": "Before I forgot the closeConnection(con) method doesn't actually do anything. \nIt's empty.\n"}, {"count": 9, "tags": [], "bug_id": 27438, "attachment_id": null, "id": 54939, "time": "2004-03-31T08:52:39Z", "creator": "gtesei@yahoo.com", "creation_time": "2004-03-31T08:52:39Z", "is_private": false, "text": "Hi Clement, \n\nactually such an implementation is very likely to be completely replaced in the \nfuture ... hence I don't know how much could be useful spending our time fixing \nthis. Anyway, just for fun ... it was my understanding that JDBCAppender has \nbeen designed such that the (client) programmer can override \n\n_getConnection_  \"to link with your connection pooling system\" \n\n_closeConnection_ \"to return the connection to a pool, or to clean up the \nresource\"\n\nFor in production applications it not feasible opening and closing a new \nconnection for each attempt to write a log event ... for instance, \n\n*** I can get/release connection from a connection pool/connector in all my \napplications --> hence\n \nprotected void closeConnection(Connection con) {\n   _my_conn_pool.release(conn);\n}\n\nprotected Connection getConnection() ....\n\n*** I can subclass JDBCAppender such that it handles 1 ad hoc connection --> \n\npublic class MyJDBCAppender  extends JDBCAppender \n\npublic JDBCAppender(Connection conn) {\n    ...\n}\n\n\nin both cases, i shouldn't close connection directly .... this was the reason \nbecause i focused on \n\ncloseConnection(con); //never reached \n\nthough it's empty in the father class. \n\n"}, {"count": 10, "tags": [], "creator": "clement.ong@shinetech.com", "attachment_id": null, "text": "Hi Gino,\n \nYou're right that the JDBCAppender is not of production quality. This is the \nsecond problem I discovered in this class. The first was when we were using an \nold version of log4j which has the persistent major memory leak in the flush \nmethod and the most recent memory leak due to stale connection. This parcular \nproblem is very subtle(which could be caused the firewall or a *database \nrestart or crash.*) as it's very hard to pinpoint where the memory leak is \noccuring in.\n \nIn a J2EE environment it is ill advised to use file based logging destination \nas it contravene the EJB specification rule.  This is where JDBCAppender or \nJMSType destination could be use. ", "id": 55118, "time": "2004-04-01T22:46:00Z", "bug_id": 27438, "creation_time": "2004-04-01T22:46:00Z", "is_private": false}, {"count": 11, "tags": [], "bug_id": 27438, "attachment_id": null, "id": 68516, "time": "2004-12-14T21:52:58Z", "creator": "yoavs@computer.org", "creation_time": "2004-12-14T21:52:58Z", "is_private": false, "text": "This Appender is no longer maintained."}]