[{"text": "If httpd dies and leaves behind a pidfile containing a pid which later gets reused, the httpd refuses to come back up. I've already seen this in production, where a host has crashed and on coming back up the web server fails to start because something else has grabed the pid.\n\nTo reproduce the problem, do this:\n\n[root@laptop httpd]# pkill -9 httpd\n[root@laptop httpd]# pgrep httpd\n[root@laptop httpd]# echo 1 > /var/run/httpd/httpd.pid\n\n[root@laptop httpd]# /usr/sbin/httpd -k start\nhttpd: Could not reliably determine the server's fully qualified domain name, using fe80::201:4aff:fe5e:5331 for ServerName\nhttpd (pid 1) already running\n\nThis is the version I'm using:\n\n[quick@laptop ~]$ httpd -v\nServer version: Apache/2.2.22 (Unix)\nServer built:   Apr 30 2012 09:55:05\n[quick@laptop ~]$ cat /etc/redhat-release \nFedora release 17 (Beefy Miracle)\n\nI tested this out on RHEL6 which ships with httpd 2.2.15 and noted that doesn't suffer the same problem, however I can't see anything in the changelog between versions 2.2.15 and 2.2.22 which would have caused this problem to occur.", "tags": [], "bug_id": 54519, "is_private": false, "count": 0, "id": 165004, "time": "2013-02-02T09:09:20Z", "creator": "edwardquick@hotmail.com", "creation_time": "2013-02-02T09:09:20Z", "attachment_id": null}, {"count": 1, "attachment_id": null, "bug_id": 54519, "text": "I reproduced the problem on Fedora 18 with httpd 2.4.3 as well:\n\n[root@laptop httpd]# ps -ef | grep [h]ttp\nroot      2326     1  0 20:57 ?        00:00:00 /usr/sbin/httpd -DFOREGROUND\napache    2327  2326  0 20:57 ?        00:00:00 /usr/sbin/httpd -DFOREGROUND\napache    2328  2326  0 20:57 ?        00:00:00 /usr/sbin/httpd -DFOREGROUND\napache    2329  2326  0 20:57 ?        00:00:00 /usr/sbin/httpd -DFOREGROUND\napache    2330  2326  0 20:57 ?        00:00:00 /usr/sbin/httpd -DFOREGROUND\napache    2331  2326  0 20:57 ?        00:00:00 /usr/sbin/httpd -DFOREGROUND\napache    2332  2326  0 20:57 ?        00:00:00 /usr/sbin/httpd -DFOREGROUND\n\n[root@laptop httpd]# kill -9 2326\n[root@laptop httpd]# ps -ef | grep [h]ttp\n[root@laptop httpd]# echo 1 > /var/run/httpd/httpd.pid\n\n[root@laptop httpd]# /usr/sbin/httpd -k start\nhttpd (pid 1) already running\n\n[root@laptop httpd]# ps -ef | grep [h]ttp\n\n[root@laptop httpd]# httpd -v\nServer version: Apache/2.4.3 (Fedora)\nServer built:   Jan  8 2013 13:46:23\n\n\n[root@laptop httpd]# uname -a\nLinux laptop 3.7.7-201.fc18.i686 #1 SMP Tue Feb 12 22:59:10 UTC 2013 i686 i686 i386 GNU/Linux", "id": 165294, "time": "2013-02-17T21:06:40Z", "creator": "edwardquick@hotmail.com", "creation_time": "2013-02-17T21:06:40Z", "tags": [], "is_private": false}, {"count": 2, "attachment_id": null, "bug_id": 54519, "is_private": false, "id": 165295, "time": "2013-02-17T21:58:54Z", "creator": "edwardquick@hotmail.com", "creation_time": "2013-02-17T21:58:54Z", "tags": [], "text": "Just for comparison, I carried out the same test on nginx and that was fine. \n\n\n[root@laptop run]# ps -ef | grep [n]ginx\nroot      3055     1  0 21:50 ?        00:00:00 nginx: master process /usr/sbin/nginx\nnginx     3056  3055  0 21:50 ?        00:00:00 nginx: worker process\n\n[root@laptop run]# cat /run/nginx.pid \n3055\n[root@laptop run]# kill -9 3055\n[root@laptop run]# ps -ef | grep [n]ginx\n[root@laptop run]# echo 1 > /run/nginx.pid\n\n[root@laptop run]# /usr/sbin/nginx\n[root@laptop run]# ps -ef | grep [n]ginx\nroot      3144     1  0 21:53 ?        00:00:00 nginx: master process /usr/sbin/nginx\nnginx     3145  3144  0 21:53 ?        00:00:00 nginx: worker process\n[root@laptop run]# cat /run/nginx.pid \n3144\n\n[root@laptop run]# nginx -v\nnginx version: nginx/1.2.6"}, {"count": 3, "tags": [], "bug_id": 54519, "is_private": false, "text": "This issue continues to be present in 2.4.18 as shipped by RHEL 7 as package:\n\nhttpd24-httpd-2.4.18-11.el7.x86_64\n\nUntil I found this bug report, I was puzzled that an nfs process was being identified as httpd.\n\nSo if Edward Quick would like me to send him a beer, I will be delighted to do so.", "id": 194909, "time": "2016-11-10T17:55:44Z", "creator": "bucky@mightytikigod.com", "creation_time": "2016-11-10T17:55:44Z", "attachment_id": null}, {"text": "Thanks a lot for the tests, bz.apache.org/bugzilla/show_bug.cgi?id=60261 was a recent similar use case in which the same PID is re-used in Docker containers (so since it is the same PID it is safe to proceed).\n\nIn the upcoming release (2.4.24) the code looks more or less like this:\n\n#Read the pid file and store the result in 'otherpid'\nrv = ap_read_pid(pconf, ap_pid_fname, &otherpid);\nif (otherpid != getpid() && kill(otherpid, 0) == 0) { # httpd already running }\n\nIn this case, the new PID is different from the one used by the old httpd process (so otherpid != getpid()) but it is used by a completely different running process (so kill(otherpid, 0) == 0 is also true), that overlaps with the regular case in which httpd is already started and it is correct to end up in the \"httpd already running\" error case.\n\nWaiting for other feedback since I am not sure how to solve this issue simply looking at PIDs (something more might be needed).", "tags": [], "bug_id": 54519, "is_private": false, "count": 4, "id": 195225, "time": "2016-11-26T08:35:55Z", "creator": "toscano.luca@gmail.com", "creation_time": "2016-11-26T08:35:55Z", "attachment_id": null}]