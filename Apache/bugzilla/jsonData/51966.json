[{"count": 0, "tags": [], "text": "Created attachment 27699\nPatch that implements ssha passwords\n\nWe have a requirement to use ssha hashed passwords (salted SHA-1) for tomcat.  This is only supported with LDAP currently -- and we can't use LDAP.\n\nI have created a patch that implements SSHA for all other Security Realms", "is_private": false, "bug_id": 51966, "id": 150205, "time": "2011-10-05T18:34:10Z", "creator": "accaldwell@west.com", "creation_time": "2011-10-05T18:34:10Z", "attachment_id": 27699}, {"count": 1, "tags": [], "bug_id": 51966, "attachment_id": 27699, "is_private": false, "id": 150227, "time": "2011-10-05T21:44:11Z", "creator": "chris@christopherschultz.net", "creation_time": "2011-10-05T21:44:11Z", "text": "Comment on attachment 27699\nPatch that implements ssha passwords\n\n(Marked patch as patch, so we can see diffs via BZ)"}, {"count": 2, "tags": [], "text": "I like this idea (and have been considering it for a while), but I don't like the implementation due to the following reasons:\n\n1. Uses part of the password as the salt, which is not a good idea. Read-up on password salting\n2. Reveals the last 4 bytes of the user's password by using it as the salt :( (https://issues.apache.org/bugzilla/attachment.cgi?id=27699&action=diff#orig/apache-tomcat-6.0.33-src/java/org/apache/catalina/realm/RealmBase.java_sec7)\n3. Static string \"ssha\" implies SHA-1 hashing (which is flawed)\n4. Hard-coded salt-length (\"last 4 bytes = 8 characters\" which is incorrect)\n5. Overloads RealmBase.digest with a 2-argument version, and then always calls that with null instead of calling the single-arg version\n6. Looks like this patch could have been a single minor change to the RealmBase.digest method\n\nI would support a patch that:\n\n1. Didn't use part of the password to salt the password itself\n2. Allowed the realm configuration to specify the hashing algorithm to use\n3. Allowed the realm configuration to specify the salt length", "is_private": false, "bug_id": 51966, "id": 150229, "time": "2011-10-05T21:58:49Z", "creator": "chris@christopherschultz.net", "creation_time": "2011-10-05T21:58:49Z", "attachment_id": null}, {"count": 3, "tags": [], "creator": "accaldwell@west.com", "text": "Thank you for the great feedback. The salt isn't part of the users password. If you look at the digest method that's used to generate the encoded password, it is 4 random bytes. The ssha name is the same name/4 random byte method that is already used in the ldap code. \n\nMy need for this stems from a weblogic to tomcat conversion we are doing. Weblogic uses the same 4-byte random method.\n\nI do like the idea of hard-coding less though so that you could use salts with any algorithm. I'll see what I can come up with.", "id": 150236, "time": "2011-10-05T22:16:39Z", "bug_id": 51966, "creation_time": "2011-10-05T22:16:39Z", "is_private": false, "attachment_id": null}, {"count": 4, "tags": [], "bug_id": 51966, "attachment_id": 27703, "text": "Created attachment 27703\nupdated patch that uses a saltBytes attribute / can be used with any digest algorithm\n\nI've re-worked the patch to address the concerns.  I added an isValidEncodedPassword to Realm Base that is now used by the other methods.  The number of saltBytes is configurable and the RealmBase main has been updated to accept a -s ## to indicate how many salt bytes to use.", "id": 150240, "time": "2011-10-06T01:29:54Z", "creator": "accaldwell@west.com", "creation_time": "2011-10-06T01:29:54Z", "is_private": false}, {"count": 5, "tags": [], "bug_id": 51966, "attachment_id": null, "id": 150478, "time": "2011-10-11T20:30:51Z", "creator": "chris@christopherschultz.net", "creation_time": "2011-10-11T20:30:51Z", "is_private": false, "text": "(In reply to comment #3)\n> Thank you for the great feedback. The salt isn't part of the users password. If\n> you look at the digest method that's used to generate the encoded password, it\n> is 4 random bytes.\n\nGiven the small scope of the patch, it wasn't clear that Principal.getPassword was returning the hashed password from the credential store. Apologies for not reading carefully."}, {"count": 6, "tags": [], "bug_id": 51966, "attachment_id": null, "is_private": false, "id": 151021, "time": "2011-10-28T22:14:06Z", "creator": "markt@apache.org", "creation_time": "2011-10-28T22:14:06Z", "text": "*** Bug 45871 has been marked as a duplicate of this bug. ***"}, {"count": 7, "tags": [], "bug_id": 51966, "attachment_id": null, "is_private": false, "id": 155085, "time": "2012-03-20T06:50:14Z", "creator": "neale@metawerx.net", "creation_time": "2012-03-20T06:50:14Z", "text": "Hey Guys,\n\nGreat work on the patch so far Adam.\n\nI'd love to see this implemented as well.  The current hashing provides no security at all unless symbols are used in the passwords, because of the availability of good, large rainbow tables on the net these days.\n\nHowever, I'd prefer the salt to be prepended and separated with a $ symbol like other implementations typically use.  The current patch seems to rely on a fixed salt-length, which means the length can't ever be changed (all hashes would become useless).\n\neg:\narbitrary-length-hex-encoded-salt-bytes$hex-encoded-digest\n\nThe patch can check for a $ symbol, and separate the string based on it.\n\nAdvantages:\n- If no $ mark found, the digest can be treated as non-salted - so older hashes can remain valid until the users change their passwords.\n- Avoids needing to set the salt-length in a server.xml parameter, which removes a couple of functions from the patch and the necessary extra documentation for them."}, {"count": 8, "tags": [], "text": "Could also change Realmbase.main to use SecureRandom.", "attachment_id": null, "bug_id": 51966, "id": 155087, "time": "2012-03-20T07:07:08Z", "creator": "neale@metawerx.net", "creation_time": "2012-03-20T07:07:08Z", "is_private": false}, {"count": 9, "tags": [], "text": "I recently added the capability to use salted and iterated hashes to my own DataSourceRealm -- but it's been diverging from TC's realms for quite a while.\n\nMine does not use $ to separate the salt from the hash, so that essentially fixes my salt-length in stone. I might want to change my implementation ;)\n\nI'd be happy to share my code with the community, but either I or someone else will have to do some heavy work on it to get it to fit-in with the current Realm code in Tomcat.", "is_private": false, "bug_id": 51966, "id": 155247, "time": "2012-03-22T20:22:45Z", "creator": "chris@christopherschultz.net", "creation_time": "2012-03-22T20:22:45Z", "attachment_id": null}, {"text": "Just another strong vote for salted passwords. Any issues with or progress on the current patch?", "tags": [], "bug_id": 51966, "attachment_id": null, "count": 10, "id": 160881, "time": "2012-07-24T20:11:50Z", "creator": "oliver@gtwm.co.uk", "creation_time": "2012-07-24T20:11:50Z", "is_private": false}, {"count": 11, "tags": [], "creator": "david@leppik.net", "text": "Unfortunately, just adding salt to hashes doesn't provide much more security these days.  Modern password hashing algorithms, such as bcrypt, include the salt as part of the hash.  What's more, the current digest algorithms are woefully out of date, so just adding salt will just extend the illusion that they are secure.\n\nA better solution would be to allow users to plug in a digest algorithm that they trust, and perhaps to bundle a few high quality third-party algorithms as well.\n\nI'm going to create a separate bug report with more details.", "id": 161745, "time": "2012-08-27T21:00:16Z", "bug_id": 51966, "creation_time": "2012-08-27T21:00:16Z", "is_private": false, "attachment_id": null}, {"count": 12, "tags": [], "text": "David, I see your other report\n\nhttps://issues.apache.org/bugzilla/show_bug.cgi?id=53785\n\nis currently marked RESOLVED WONTFIX. I'm not a security expert but I don't think there's much argument that salting or a pluggable architecture would be an improvement on the current implementation of unsalted hashing.\n\nI for one appreciate the work others have done to date, above. It's unfortunate I don't have enough knowledge to contribute helpful patches myself but I'm sure this is going to be something that sees an increasing amount of interest.", "attachment_id": null, "bug_id": 51966, "id": 165153, "time": "2013-02-10T11:00:38Z", "creator": "oliver@gtwm.co.uk", "creation_time": "2013-02-10T11:00:38Z", "is_private": false}, {"count": 13, "tags": [], "text": "Please see http://markmail.org/thread/cipopgduels3d7yh\n\nNo responses thus far. Feel free to reply and voice your support!", "is_private": false, "bug_id": 51966, "id": 165239, "time": "2013-02-13T18:16:04Z", "creator": "chris@christopherschultz.net", "creation_time": "2013-02-13T18:16:04Z", "attachment_id": null}, {"count": 14, "tags": [], "text": "I am relatively new to Tomcat.  Has any progress been made on this issue?  I would like to use Tomcat with DataSourceRealm for a web application but am not willing to store user passwords without salting them, preferably with arbitrarily sized salt.  I am surprised that this hasn't been addressed and that fixing the issue is not a priority.  Are there alternatives I am not aware of that people are using, and is that why adding support for salt is not a priority?", "is_private": false, "bug_id": 51966, "id": 172845, "time": "2014-02-01T17:27:14Z", "creator": "gabrielesanchez@gmail.com", "creation_time": "2014-02-01T17:27:14Z", "attachment_id": null}, {"count": 15, "tags": [], "bug_id": 51966, "attachment_id": null, "id": 172865, "time": "2014-02-02T17:59:17Z", "creator": "blama@gmx.net", "creation_time": "2014-02-02T17:59:17Z", "is_private": false, "text": "Hi,\n\nwhat I'm doing is to hash the user-entered password 999x on the client with a salt (visible in the JS code) on the OK-Click in my login form. Then I send it to Tomcat and have it compared to the stored hash (1000x hashed with the same salt).\n\nThis way there is never send a unhashed password (even not when you are not using https, which you shouldn't) and you can configure the number of pre-hashing to your needs (to be safe against generating rainbow tables for your salt). This might be useful in times of modern GPUs executing billions of SHA1-hashes per second (2300M/s SHA1 hashes in 2009)."}, {"text": "(In reply to S from comment #15)\n> Hi,\n> \n> what I'm doing is to hash the user-entered password 999x on the client with\n> a salt (visible in the JS code) on the OK-Click in my login form. Then I\n> send it to Tomcat and have it compared to the stored hash (1000x hashed with\n> the same salt).\n\nThis is awful security. When the client is involved in authentication, that's called not being authenticated.\n\nIn production, we salt-hash 75000 times by default, and should probably do more. 10k times isn't nearly enough.\n\n> This way there is never send a unhashed password (even not when you are not\n> using https, which you shouldn't) and you can configure the number of\n> pre-hashing to your needs (to be safe against generating rainbow tables for\n> your salt). This might be useful in times of modern GPUs executing billions\n> of SHA1-hashes per second (2300M/s SHA1 hashes in 2009).\n\nShouldn't use HTTPS, or shouldn't send otherwise-unencrypted passwords over HTTPS? Both of those sound like bad advice.\n\nNobody should be using SHA-1 anymore for authentication.\n\nRealistically, nobody should be using crypto hashing for password hashing, anyway.", "tags": [], "bug_id": 51966, "is_private": false, "count": 16, "id": 172919, "time": "2014-02-05T22:23:35Z", "creator": "chris@christopherschultz.net", "creation_time": "2014-02-05T22:23:35Z", "attachment_id": null}, {"count": 17, "tags": [], "text": "(In reply to Christopher Schultz from comment #16)\n> This is awful security. When the client is involved in authentication,\n> that's called not being authenticated.\nI don't understand. It's the same Tomcat does out-of-the-box (send data to j_security_check and wait for the result), but with more hashing.\n\n> In production, we salt-hash 75000 times by default, and should probably do\n> more. 10k times isn't nearly enough.\nI'll test how long a client takes for 100K and if its acceptable (which I assume) I'll change.\n\n> > This way there is never send a unhashed password (even not when you are not\n> > using https, which you shouldn't) \n> Shouldn't use HTTPS, or shouldn't send otherwise-unencrypted passwords over\n> HTTPS? Both of those sound like bad advice.\nI meant: You should use https. I can't see the problem generated by sending a (salted, many-round) hash (with the exception of rainbow table attacks).\n\n> Nobody should be using SHA-1 anymore for authentication.\n> Realistically, nobody should be using crypto hashing for password hashing,\n> anyway.\nThe second Tomcat supports SCrypt or BCrypt I'll change. What's your suggestion for the time being?\nBesides changing Tomcat yourself like in http://stackoverflow.com/questions/12285604/writing-a-custom-tomcat-realm-using-bcrypt, which I really don't want to do.", "is_private": false, "bug_id": 51966, "id": 172920, "time": "2014-02-05T23:56:25Z", "creator": "blama@gmx.net", "creation_time": "2014-02-05T23:56:25Z", "attachment_id": null}, {"count": 18, "tags": [], "bug_id": 51966, "attachment_id": null, "is_private": false, "id": 172921, "time": "2014-02-06T00:22:01Z", "creator": "gabrielesanchez@gmail.com", "creation_time": "2014-02-06T00:22:01Z", "text": "The only advantage I see of hashing in the client side is not storing a String with the cleartext password in memory.  Strings are immutable objects, so they cannot be cleared once password processing is completed.  If no references point to it, then the garbage collector should eventually do the job.  I've seen that careful password authentication implementations use a char array for this reason.  Char arrays are mutable, so as soon as password processing is complete, all of the array elements are zeroed out, reducing the time an attacker might have to read the password off memory.  Tomcat's password authentication methods should follow this best practice and be changed to do the handling with char[].  \n\nA risk of receiving the cleartext password is that someone with access to the server may write code to store passwords, and if users use the same password for other web accounts, then bad things can happen.  Hashing might make it just a bit less easy for an insider to do that.  They can still do brute force and dictionary attacks, of course.  So it doesn't go a long way at all.  \n\nHashing on the server is necessary to protect passwords in the event a malicious person obtains access to the password table, even if hashing was done on the client side.  Client side hashing by itself would make no difference here.\n\nAnd of course, no kind of hashing protects from weak passwords or stolen passwords from the clients via key loggers and whatnot.  \n\nShould we change the meta data of this thread to reflect the direction the discussion has taken?  Is this still a Tomcat 6 issue, or should we say it is a proposed new feature for Tomcat 8 revisions?  Or do you think that all versions of Tomcat should be updated?"}, {"text": "(In reply to S from comment #17)\n> (In reply to Christopher Schultz from comment #16)\n> > This is awful security. When the client is involved in authentication,\n> > that's called not being authenticated.\n> I don't understand. It's the same Tomcat does out-of-the-box (send data to\n> j_security_check and wait for the result), but with more hashing.\n> \n> > In production, we salt-hash 75000 times by default, and should probably do\n> > more. 10k times isn't nearly enough.\n> I'll test how long a client takes for 100K and if its acceptable (which I\n> assume) I'll change.\n> \n> > > This way there is never send a unhashed password (even not when you are not\n> > > using https, which you shouldn't) \n> > Shouldn't use HTTPS, or shouldn't send otherwise-unencrypted passwords over\n> > HTTPS? Both of those sound like bad advice.\n> I meant: You should use https. I can't see the problem generated by sending\n> a (salted, many-round) hash (with the exception of rainbow table attacks).\n\nHashing on the client side has its merits as long as you also hash on the server side and you don't use the same salt on the client as you do on the server.  In particular, if your client code fetches the salt corresponding to a username, that lets an attacker know if they have a valid username (if they receive a salt from the server to do hashing on the client side).  If you use a random salt generated for a client session or even a constant client-side salt, it is best to also hash on the server side with an independent user-specific hash.  \n\nIf you hash on the client side but not the server side, and an attacker steals the password table, they essentially have all the passwords they need to get into your site.  They don't need to know the cleartext passwords... they can modify the javascript on the client side to send the stolen hash (and not hash again) and the server will let them in.  This is why strong hashing on the server side is necessary.\n\n> \n> > Nobody should be using SHA-1 anymore for authentication.\n> > Realistically, nobody should be using crypto hashing for password hashing,\n> > anyway.\n> The second Tomcat supports SCrypt or BCrypt I'll change. What's your\n> suggestion for the time being?\n> Besides changing Tomcat yourself like in\n> http://stackoverflow.com/questions/12285604/writing-a-custom-tomcat-realm-\n> using-bcrypt, which I really don't want to do.", "tags": [], "bug_id": 51966, "attachment_id": null, "count": 19, "id": 172922, "time": "2014-02-06T02:55:19Z", "creator": "gabrielesanchez@gmail.com", "creation_time": "2014-02-06T02:55:19Z", "is_private": false}, {"text": "(In reply to Gabriel from comment #19)\n> \n> Hashing on the client side has its merits as long as you also hash on the\n> server side and you don't use the same salt on the client as you do on the\n> server.  In particular, if your client code fetches the salt corresponding\n> to a username, that lets an attacker know if they have a valid username (if\n> they receive a salt from the server to do hashing on the client side).  If\n> you use a random salt generated for a client session or even a constant\n> client-side salt, it is best to also hash on the server side with an\n> independent user-specific hash.  \n> \nOops... random salt generated for a client session wouldn't work, would it?  It would either have to be constant or user specific.  I suppose constant is best on the client side.", "tags": [], "bug_id": 51966, "attachment_id": null, "count": 20, "id": 172923, "time": "2014-02-06T03:14:43Z", "creator": "gabrielesanchez@gmail.com", "creation_time": "2014-02-06T03:14:43Z", "is_private": false}, {"count": 21, "tags": [], "text": "In order to illustrate how I understood possibilities and their use in Tomcat, I made a list of authentication mechanisms:\n\n0) Compare the sent PW to the stored PW\n1) Hashing the sent PW on the server, compare it to stored hash (Tomcat default)\n2) Hashing the PW n times on the client, hashing the sent hashed PW once more on the server, compare it to stored n+1 rounds hash\n3) Hashing the PW n times on the client (with [fixed and user known] salt), hashing the sent hashed PW once more on the server, compare it to stored n+1 rounds hash (n with salt, 1 without salt)\n4) Using jBCrypt / scrypt\n\nAll these come in http / https flavors.\nAs far as I understand, only 1, 2 and 3 are possible today without changing Tomcat.\nDo you agree?\n\nIn terms of security it is 0<<<<<<<<<<<<<<<<<<1<<<<<<<<<<<<<<<<<<2<3<<<<<<<<<<<<<<<<<< ..... <<<<<<<<<<<<<<<<<<4\nA support for jBCrypt / scrypt would really be great!", "attachment_id": null, "bug_id": 51966, "id": 172924, "time": "2014-02-06T09:42:43Z", "creator": "blama@gmx.net", "creation_time": "2014-02-06T09:42:43Z", "is_private": false}, {"count": 22, "tags": [], "bug_id": 51966, "attachment_id": null, "is_private": false, "id": 174532, "time": "2014-04-13T16:03:57Z", "creator": "gabrielesanchez@gmail.com", "creation_time": "2014-04-13T16:03:57Z", "text": "Note Bug 56403 for Tomcat 8 deals with a pluggable interface that would make it easier to resolve this."}, {"text": "The broader solution outlined in bug 56403 is the right way to do this. I'm currently working on taking Chris's proposal there and turning it into a patch that can be applied to 8.0.x.\n\n*** This bug has been marked as a duplicate of bug 56403 ***", "tags": [], "bug_id": 51966, "attachment_id": null, "count": 23, "id": 177876, "time": "2014-09-15T10:58:15Z", "creator": "markt@apache.org", "creation_time": "2014-09-15T10:58:15Z", "is_private": false}]