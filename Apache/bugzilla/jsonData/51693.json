[{"count": 0, "tags": [], "bug_id": 51693, "text": "Using POI I'm creating an *.xls file that contains 6 sheets of data. None of the columns of data are formulas, all are either Strings or numbers (none are blank/empty). If I open the file using Excel I see all of the columns and data. If I try to read the file using Java and ODBC the first and last sheets have all their columns but the sheets in between are missing the last column (If I try to specifically select the column I get a failure - doing a Select * gets all but the missing column on the failed sheets). The sheets have no more than 14 columns. Also if I run this validator tool against the file it fails (http://blogs.msdn.com/b/officeinteroperability/archive/2011/07/12/microsoft-office-binary-file-format-validator-is-now-available.aspx). If I simply have the file open in Excel and run my java reader it finds all the columns (if I close Excel it fails to find all the columns as before). If I open, save and exit the file using Excel the file then works correctly. My work around is to add an extra \"junk\" column that contains and empty string to each sheet. This will allow me to query the missing columns without the failure (\"Select last_column from [SECOND_SHEET$]\"). This problem surfaced at work. I'm creating a file using POI and another person is trying to read it using Microsoft.Jet.OLEDB.4.0 and the file is failing when being read. Opening and saving via Excel allows the file to then be read.\n\nSample code for creating sheets (altered from actual work code):\n\n    private void writeSheetData()\n    {\n    \tint sheetNum = 0;\n    \tfor (String name : Config.instance().getSheetNames())\n    \t{\n    \t\tmyLogger.debug(\"Process sheet \" + name);\n    \t\tHSSFSheet sheet = wb.getSheet(name);\n    \t\tHSSFRow row = sheet.createRow(0);\n    \t\tHSSFCell cell = null;\n    \t\t// Populate the sheet\n    \t\tint count = 0;\n    \t\tfor (String columnname : Config.instance().getSheetColumnNames(name))\n    \t\t{\n    \t\t\tcell = row.createCell(count++);\n    \t\t\tcell.setCellValue(columnname);\n    \t\t}\n    \t\tswitch (sheetNum)\n    \t\t{\n    \t\t\tcase FIRST_SHEET:\n    \t\t        Vector<String> v = new Vector<String>(sHash.keySet());\n    \t\t        Collections.sort(v);\n\n    \t\t        for (Enumeration<String> idsenum = v.elements(); idsenum.hasMoreElements();)\n    \t\t        {\n    \t\t            String sss = idsenum.nextElement();\n    \t\t            SSS sObj = sHash.get(sss);\n\n    \t\t            row = sheet.createRow(sheet.getLastRowNum() + 1);\n\n    \t\t            cell = row.createCell(0);\n    \t\t            cell.setCellValue(sObj.getNumber());\n    \t\t            cell = row.createCell(1);\n    \t\t            cell.setCellValue(sObj.getID());\n    \t\t        }\n    \t\t\t\tbreak;\n    \t\t\tcase SECOND_SHEET:\n    \t\t        Vector<String> vt = new Vector<String>(tHash.keySet());\n    \t\t        Collections.sort(vt);\n\n    \t\t        for (Enumeration<String> idsenum = vt.elements(); idsenum.hasMoreElements();)\n    \t\t        {\n    \t\t            THelper mObj = tHash.get(idsenum.nextElement());\n\n    \t\t            row = sheet.createRow(sheet.getLastRowNum() + 1);\n    \t\t            cell = row.createCell(0);\n....\n\n            out = new FileOutputStream(filename);\n            wb.write(out);\n\n\nSample code for reading in data:\n\nNOTE: mytest is being set using Administrative Tools -> Data Sources (ODBC) and adding a User DSN for Excel Files (Microsoft Excel Driver *.xls) that is pointing to the xls workbook file that was created.\n\n\tpublic void mytest() {\n\t\tConnection connection = null;\n\t\tint numberOfColumns = 0;\n\t\ttry{\n\t\t\tClass.forName(\"sun.jdbc.odbc.JdbcOdbcDriver\");\n\t\t\tConnection con = DriverManager.getConnection(\"jdbc:odbc:mytest\",\"\",\"\");\n\n\t\t\tStatement st = con.createStatement();\n                        String query = \"Select * from [SECOND_SHEET$]\";\n\t\t\tSystem.out.println(\"Query is: '\" + query + \"'\");\n\t\t\tResultSet rs = st.executeQuery( query );\n\n\t\t\tResultSetMetaData rsmd = rs.getMetaData();\n\t\t\tnumberOfColumns = rsmd.getColumnCount();\n\t\t\tSystem.out.println(\"Column count is: \" + numberOfColumns);\n\n\t\t\tfor (int i = 1; i <= numberOfColumns; i++) {\n\t\t\t\tSystem.out.println(\"Column is: '\" + rsmd.getColumnLabel(i) + \"'\");\n\t\t\t}\n\n.....", "id": 148718, "time": "2011-08-19T20:32:15Z", "creator": "myonlyanon@gmail.com", "creation_time": "2011-08-19T20:32:15Z", "is_private": false, "attachment_id": null}, {"count": 1, "text": "Hi,\n\nThe issue concerns only files with an even number of column.\n\nIf you create a small file (2 or 4 cells in a row), import data doesn't find last column.\n\nI simulate ODBC connection via excel 2003\n    Menu Data > External data > Import data\n    \nimport_2_col_expected.xls => KO (1 cell) cell_1\nimport_3_col_expected.xls => OK (3 cell) cell_1,cell_2,cell_3\nimport_4_col_expected.xls => KO (3 cell) cell_1,cell_2,cell_3\nimport_5_col_expected.xls => OK (5 cell) cell_1,cell_2,cell_3,cell_4,cell_5\n\nHere is the code to create small test import file.\n\n// Create test files\n  public static void main(String[] args) {\n    try {\n      for (int nbCol = 2; nbCol < 6; nbCol++) {\n        HSSFWorkbook wb = new HSSFWorkbook();\n        HSSFRow row = wb.createSheet(\"test\").createRow(0);\n        for (int i = 0; i < nbCol; i++)\n          row.createCell(i).setCellValue(\"cell_\" + (i + 1));\n        String filename = \"/tmp/import_\" + nbCol + \"_col_expected.xls\";\n        System.out.println(\"writing \" + filename);\n        FileOutputStream out = new FileOutputStream(filename);\n        wb.write(out);\n        out.close();\n      }\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }", "bug_id": 51693, "is_private": false, "id": 154904, "time": "2012-03-14T14:06:14Z", "creator": "perceval.barbu@gmail.com", "creation_time": "2012-03-14T14:06:14Z", "tags": [], "attachment_id": null}]