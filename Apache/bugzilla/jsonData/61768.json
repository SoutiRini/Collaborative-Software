[{"count": 0, "tags": [], "creator": "herbert.wespi@swisscom.com", "is_private": false, "text": "Our Product offers different REST APIs based on jax-rs 2.1 and Jersey 2.26.\n\nWe are facing Problems with asynchronous Requests (using javax.ws.rs.sse.SseEventSink) and the Recycling of Processors (org.apache.coyote.http11.Http11Processor).\n\nThe SSE Endpoints are asynchronous and kept open for a long time.\nIf the async Context is completed on Server Side, then it works as expected.\n\nBut when a Client closes the Connection on Client Side, then the Processor is recycled and put to the recycled Processors: org.apache.coyote.AbstractProtocol.ConnectionHandler.release\nThe asynchronous Thread is still running and will try to write to the Response.\n\nBecause the processor (incl. request and Response object) is recycled it will be reused by another request (synchron or asynchron).\n\nJersey itself uses the javax.servlet.AsyncContext only to complete once it is finished, but it does NOT use the getResponse Method. Instead the original Response is used. This leads to a concurrent use of the very same Response.\nWe observed different failures because of this (Empty or truncated Responses or missing reponse headers)\n\nAs a Workaround we had to disable the processor pool in the connector: processorCache=\"0\"\nWith this Workaround the Problem is not happening anymore.\n\nThe proposed fix would be to release asynchronous processors only back to the poll if they asynchronous processing is completed.", "id": 202182, "time": "2017-11-16T15:58:05Z", "bug_id": 61768, "creation_time": "2017-11-16T15:58:05Z", "attachment_id": null}, {"count": 1, "tags": [], "text": "The first time an attempt is made to perform I/O after the client disconnects then the following will happen:\n\n- The code attempting to perform the I/O will see an I/O exception\n\nIf one or more AsyncListeners are configured:\n - Tomcat will call the onError event for any registered AsyncListeners.\n   It is expected that one of those listeners will complete the AsycnContext.\n\nIf no listeners are configured:\n - Tomcat will complete the AsyncContext\n\nTomcat will then go on to recycle the various objects used for the request since processing of that request is now complete.\n\nIf the application/framework needs to perform clean-up if an error occurs then it is the responsibility of the application/framework to register the appropriate listener(s) and perform that clean-up in response to an error.\n\nIf there is a scenario where an I/O error occurs and Tomcat does not trigger the async error handling then that would be a Tomcat bug. However, that is not the case here. That the processor has been recycled means that Tomcat has triggered the async error handling.", "is_private": false, "id": 202187, "creator": "markt@apache.org", "time": "2017-11-16T20:18:33Z", "bug_id": 61768, "creation_time": "2017-11-16T20:18:33Z", "attachment_id": null}, {"count": 2, "tags": [], "text": "I do have a different point of view here.\n\nI also thought in the beginning, that it is the fault of the Jersey Framework, because if I would implement an asynchronous request myself, it would be easy to get it work for tomcat.\n\nHowever, if I read corretly the chapter 5.6 of the Servlet 3.0 Specification, then it looks like that the application/Framework is allowed to use the response object as long as complete on AsyncContext is not called.\n\n5.6 Lifetime of the Response Object\n\nEach response object is valid only within the scope of a servlet\u2019s service method,\nor within the scope of a filter\u2019s doFilter method, unless the associated request\nobject has asynchronous processing enabled for the component. If asynchronous\nprocessing on the associated request is started, then the request object remains valid\nuntil complete method on AsyncContext is called. Containers commonly recycle\nresponse objects in order to avoid the performance overhead of response object\ncreation. The developer must be aware that maintaining references to response\nobjects for which startAsync on the corresponding request has not been called,\noutside the scope described above may lead to non-deterministic behavior.", "attachment_id": null, "id": 202200, "creator": "herbert.wespi@swisscom.com", "time": "2017-11-17T07:42:18Z", "bug_id": 61768, "creation_time": "2017-11-17T07:42:18Z", "is_private": false}, {"count": 3, "tags": [], "bug_id": 61768, "is_private": false, "id": 202202, "attachment_id": null, "creator": "markt@apache.org", "creation_time": "2017-11-17T08:19:21Z", "time": "2017-11-17T08:19:21Z", "text": "(In reply to Herbert Wespi from comment #2)\n\n> ... then the request object\n> remains valid  until complete method on AsyncContext is called. ...\n\ncomplete is called when the I/O error occurs. If the app/framework doesn't call it during error handling that is a further error and the container will ensure complete is called."}, {"count": 4, "tags": [], "bug_id": 61768, "attachment_id": null, "is_private": false, "id": 202203, "time": "2017-11-17T09:10:48Z", "creator": "herbert.wespi@swisscom.com", "creation_time": "2017-11-17T09:10:48Z", "text": "Thanks Mark for the clarification. I see your point. Jersey does not register any listener to AsyncContext. I will try to adress it then with the Jersey Project.\n\nAs an application developers, it would be nice if the two reference implementations (servlet and jax-rs) would just work well together out of the box ;-)"}]