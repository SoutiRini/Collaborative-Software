[{"count": 0, "tags": [], "creator": "patric@rufflar.com", "attachment_id": null, "text": "It seems that the StatementCache has issues in highly multi-threaded situations where high numbers of PreparedStatements are created.\n\nThe application quickly fails with the well-known \"Internal Exception: java.sql.SQLException: ORA-01000: maximum open cursors exceeded\"\n\nWithout the StatementCache the application just runs fine.\nAll threads invoke the same SQLs. Of course, each thread uses its own Connection exclusively.\n\nTwo things are conspicuous:\n\n1. \nThe AtomicInteger field org.apache.tomcat.jdbc.pool.interceptor.StatementCache.cacheSize \nwhich seems to be not in sync with the real size of the cache Map.\n\nIt's too high (higher than 50) and the StatementCache (erroneously) assumes that the cache capacity is exceeded.\n\nI suggest calling size() on the cache Map instead.\n\n2. \nWhen the capacity seems (or really is) exceeded, statement.close() will not causing to close the wrapped statement causing the cursor to leak.\n\nThe reason can be seen in org.apache.tomcat.jdbc.pool.interceptor.StatementCache$CachedStatement.closeInvoked() line: 244-288:\n\n            closed = true;\n            delegate = null;\n            if (shouldClose) {\n                super.closeInvoked();\n            }\n\nThe delegate is set to null but only _afterwards_ super.closeInvoked() is invoked which is unable to close the underlying preparedStatement => the statement remains unclosed. It should be the other way round.\n\nBest regards,\nPatric", "id": 164199, "time": "2012-12-21T11:31:49Z", "bug_id": 54337, "creation_time": "2012-12-21T11:31:49Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 54337, "attachment_id": null, "id": 166099, "time": "2013-03-22T17:34:11Z", "creator": "knst.kolinko@gmail.com", "creation_time": "2013-03-22T17:34:11Z", "is_private": false, "text": "(In reply to comment #0)\n> 1. \n> The AtomicInteger field\n> org.apache.tomcat.jdbc.pool.interceptor.StatementCache.cacheSize \n> which seems to be not in sync with the real size of the cache Map.\n> (..)\n\nYou are wrong:\nMap is per-connection. Size is per-pool.\n\n> 2. \n> When the capacity seems (or really is) exceeded, statement.close() will not\n> causing to close the wrapped statement causing the cursor to leak.\n\nYes, it is a bug. Duplicate of 54732.\n\n*** This bug has been marked as a duplicate of bug 54732 ***"}]