[{"text": "Trying to use NIO connector instead of APR connector using Tomcat6 HEAD, I get\nan IllegalArgumentException while in a call to sendAck.  \n\nLooking at InternalNioOutputBuffer.sendAck(), it uses ByteBuffer.wrap() to\ncreate a new ByteBuffer and uses this ByteBuffer in a call to writeToSocket.\nThere is a check in SecureNioChannel.write() that the ByteBuffer is the one\nstored in the \n\nCommenting the line 372 in SecureNioChannel.java fixes the problem.\n//if ( src != bufHandler.getWriteBuffer() ) throw new\nIllegalArgumentException(\"You can only write using the application write buffer\nprovided by the handler.\");\nBut I guess that the check is here for a valid reason, and a better fix would\nvery likely consist in fixing the sendAck or in adding an \"or\" condition to the\ntest for the case of sendAck().\n\nGRAVE: Cannot find message associated with key standardWrapper.acknowledgeException\njava.lang.IllegalArgumentException: You can only write using the application\nwrite buffer provided by the handler.\n\tat org.apache.tomcat.util.net.SecureNioChannel.write(SecureNioChannel.java:372)\n\tat org.apache.tomcat.util.net.NioSelectorPool.write(NioSelectorPool.java:111)\n\tat\norg.apache.coyote.http11.InternalNioOutputBuffer.writeToSocket(InternalNioOutputBuffer.java:434)\n\tat\norg.apache.coyote.http11.InternalNioOutputBuffer.sendAck(InternalNioOutputBuffer.java:418)\n\tat org.apache.coyote.http11.Http11NioProcessor.action(Http11NioProcessor.java:1028)\n\tat org.apache.coyote.Response.action(Response.java:183)\n\tat org.apache.coyote.Response.acknowledge(Response.java:310)\n\tat org.apache.catalina.connector.Response.sendAcknowledgement(Response.java:1154)\n\tat\norg.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:169)\n\tat\norg.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:175)\n\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:128)\n\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:105)\n\tat\norg.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:109)\n\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:212)\n\tat org.apache.coyote.http11.Http11NioProcessor.process(Http11NioProcessor.java:888)\n\tat\norg.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.process(Http11NioProtocol.java:624)\n\tat org.apache.tomcat.util.net.NioEndpoint$Worker.run(NioEndpoint.java:1467)\n\tat java.lang.Thread.run(Thread.java:595)", "tags": [], "bug_id": 41466, "attachment_id": null, "count": 0, "id": 98516, "time": "2007-01-25T09:12:11Z", "creator": "cpierret@sparus-software.com", "creation_time": "2007-01-25T09:12:11Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 41466, "attachment_id": 19460, "text": "Created attachment 19460\nA patch fixing the issue, but not meant to be a definitive patch\n\nShould fix this differently since it removes a useful check that is not valid\nin only one special case (sendAck call)", "id": 98518, "time": "2007-01-25T09:17:34Z", "creator": "cpierret@sparus-software.com", "creation_time": "2007-01-25T09:17:34Z", "is_private": false}, {"count": 2, "text": "Patch is invalid and would lead to invalid SSL data being sent, bug is\nacknowledged and will be fixed.", "bug_id": 41466, "is_private": false, "id": 98660, "time": "2007-01-28T13:28:23Z", "creator": "fhanik@apache.org", "creation_time": "2007-01-28T13:28:23Z", "tags": [], "attachment_id": null}, {"text": "The following fix has been applied\n\nIndex: java/org/apache/tomcat/util/net/NioSelectorPool.java\n===================================================================\n--- java/org/apache/tomcat/util/net/NioSelectorPool.java        (revision 500888)\n+++ java/org/apache/tomcat/util/net/NioSelectorPool.java        (working copy)\n@@ -103,6 +103,10 @@\n         boolean timedout = false;\n         int keycount = 1; //assume we can write\n         long time = System.currentTimeMillis(); //start the timeout timer\n+        if ( socket.getBufHandler().getWriteBuffer()!= buf ) {\n+            socket.getBufHandler().getWriteBuffer().put(buf);\n+            buf = socket.getBufHandler().getWriteBuffer();\n+        }\n         try {\n             while ( (!timedout) && buf.hasRemaining() ) {\n                 if ( keycount > 0 ) { //only write if we were registered for a\nwrite\n", "tags": [], "creator": "fhanik@apache.org", "attachment_id": null, "count": 3, "id": 98661, "time": "2007-01-28T13:35:22Z", "bug_id": 41466, "creation_time": "2007-01-28T13:35:22Z", "is_private": false}]