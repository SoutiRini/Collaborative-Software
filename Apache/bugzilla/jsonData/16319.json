[{"count": 0, "tags": [], "text": "In my own Tag that uses RequestDispatcher.include to make the actual include I \nget:\n\njava.lang.IllegalStateException: getOutputStream() has already been called for \nthis response\n\nin the JSP after the content written into the original output stream reaches \nthe size that requires flushBuffer() method of \norg.apache.jasper.runtime.JspWriterImpl.\n\njsp:include works, but this is not a solution, since we want to have a cross-\ncontext includes. \n\nI have seen that Jasper wrapps the response into ServletResponseWrapperInclude \nto make jsp:include, I guess this is what is missing with \nRequestDispatcher.include.\n\nI cannot use the same approach, since the same JSP needs to work with WebLogic, \ntoo.", "attachment_id": null, "id": 29854, "creator": "tomasz@rtsoftware.com", "time": "2003-01-22T11:18:49Z", "bug_id": 16319, "creation_time": "2003-01-22T11:18:49Z", "is_private": false}, {"count": 1, "tags": [], "creator": "funkman@joedog.org", "attachment_id": null, "text": "It sounds like the include made via RequestDispatcher.include is acquiring a\nServletOutputStream. Since a Writer has already been allocated - this is\nillegal. I speculate Jasper gets around this by wrapping ServletOutputStream in\na jsp:include. \n\nI guess the question to ask is: Does your include use OutputStream or Writer? If\nit uses OutputStream - rewrite it to use writer. \n", "id": 30975, "time": "2003-02-10T00:29:11Z", "bug_id": 16319, "creation_time": "2003-02-10T00:29:11Z", "is_private": false}, {"count": 2, "tags": [], "bug_id": 16319, "attachment_id": null, "id": 31034, "time": "2003-02-10T19:54:12Z", "creator": "tomasz@rtsoftware.com", "creation_time": "2003-02-10T19:54:12Z", "is_private": false, "text": "Jasper wrapps the request into its own descendant of the \nHttpServletResponseWrapper. If the page included with <jsp:include> tries to \naquire the writer, the wrapper hands over the original copy without getting a \nnew one.\n\nUsing RequestDispatcher.include and passing the pageContext.getRequest() \ndoesn't work that way, so that if the included page tries to get the \nwriter/outputstream on its own it causes the IllegalStateException. \n\nI don't feel the included page should be rewritten: the HttpResponse object \nbeing passed comes from Catalina and I think it would be awkward to have to \nchange the included page to take into account how Jasper and Catalina work \ntogether. Then switching the servlet container to another one might bring me \ninto the same situation some time later on. I think the included jsp pages \nshould have no knowledge which of the two objects (writer vs outputstream) can \nbe safely used. Besides, there are good uses of outputstream where writer \ncannot be used instead.\n\nMy workaround was similar to that of Jasper, I did a HttpServletResponseWrapper \ndescendant that makes the same trick and use it for the include stread of \npageContext.getResponse().\n\nYet I think it is a bug: RequestDispatcher.include and Jasper's jsp:include \nshould both work the same way."}, {"count": 3, "tags": [], "bug_id": 16319, "attachment_id": null, "id": 31036, "time": "2003-02-10T20:11:54Z", "creator": "funkman@joedog.org", "creation_time": "2003-02-10T20:11:54Z", "is_private": false, "text": "See Section 4.4 of the JSP Spec:\nAn included page only has access to the JspWriter object and it cannot set\nheaders.\n\nThis means an included page cannot obtain the response's ServletOutputStream.  "}, {"count": 4, "tags": [], "bug_id": 16319, "text": "Regardless of the fact what the included page can do and what it can't \naccording to the spec - IMO it should behave exactly the same way while being \nincluded using <jsp:include> and RequestDispatcher.include. \n\nI mean the included page does exactly the same regardless of the way it got \nincluded! \n\nIf it is allowed to do what it does after <jsp:include> then it complies to the \nrules, doesn't it? \n\nIf its working doesn't change after RequestDispatcher.include then it should \nalso be allowed to do what it does?\n\nI am not in a position to influence your decision except using logical \narguments, exactly as I am now trying to do. I see no reason to treat the \nincluded page differently depending on the way it got included.\n\nNow from the same place in the JSP v1.2 spec:\n\n\"An included page only has access to the JspWriter object and it cannot set\nheaders. This precludes invoking methods like setCookie(). Attempts to invoke\nthese methods will be ignored. The constraint is equivalent to the one imposed \non the include() method of the RequestDispatcher class.\"\n\nFirst it only says it cannot access headers and nothing about outputstream, \nthen it says that attempts to access would be ignored, and not that an \nexception were thrown, and lastly it says that those constaints are \"equivalent \nto the one imposed on the include() method of the RequestDispatcher class\". \nThat to be exact.\n\nNow why do you think <jsp:include> and RequestDispatcher.include should work \ndifferently?", "id": 31050, "time": "2003-02-11T08:50:32Z", "creator": "tomasz@rtsoftware.com", "creation_time": "2003-02-11T08:50:32Z", "is_private": false, "attachment_id": null}, {"count": 5, "tags": [], "bug_id": 16319, "attachment_id": null, "id": 64463, "time": "2004-09-30T22:25:22Z", "creator": "markt@apache.org", "creation_time": "2004-09-30T22:25:22Z", "is_private": false, "text": "The behaviour is different because that is what the respective specs mandate. \nThe use of the word \"equivalent\" in the JSP spec is misleading as it may be \ntaken to mean \"the constraints are exactly the same\" when really it means \"the \nconstraints are similar\". To quote the relevant parts of the specs:\nJSP.4.4\n<quote>\n...An included page only has access to the JspWriter object and it cannot set\nheaders. ...\n</quote>\nSRV.8.3\n<quote>\n...\nIt can only write information to the ServletOutputStream or Writer of the\nresponse object...\n</quote>"}]