[{"count": 0, "tags": [], "creator": "Dick.Snippe@tech.omroep.nl", "text": "One of our 2.4.3 apache stopped working after a graceful restart, leaving this error message:\n\n[Fri Oct 12 00:00:01.782399 2012] [auth_digest:notice] [pid 15960:tid 140576559888112] AH01757: generating secret for digest authentication ...\n[Fri Oct 12 00:00:01.782459 2012] [auth_digest:error] [pid 15960:tid 140576559888112] (17)File exists: AH01762: Failed to create shared memory segment on file /e/fp/smooto2a/scratch/authdigest_shm.15960\n[Fri Oct 12 00:00:01.782482 2012] [auth_digest:error] [pid 15960:tid 140576559888112] (17)File exists: AH01760: failed to initialize shm - all nonce-count checking, one-time nonces, and MD5-sess algorithm disabled\n[Fri Oct 12 00:00:01.782487 2012] [:emerg] [pid 15960:tid 140576559888112] AH00020: Configuration Failed, exiting\n\nIn our case we are running multiple apache instances on the same server and it turned out that 2 instances have a ftok() collision on their authdigest_shm\nfiles.\n\nThe current shared memory segment belongs to the \"smooti2a\" instance and when\n\"smooto2a\" tried to start it failed with:\n17725 open(\"/e/fp/smooto2a/scratch/authdigest_shm.17725\", O_WRONLY|O_CREAT|O_EXCL|0x80000, 0666) = 7\n17725 stat(\"/e/fp/smooto2a/scratch/authdigest_shm.17725\", {st_mode=S_IFREG|0664, st_size=0, ...}) = 0\n17725 shmget(0x10600aa, 1000, IPC_CREAT|IPC_EXCL|0600) = -1 EEXIST (File exists)\n\nI wrote a small C program to display the ftok on an arbitrary file and ran that on both authdigest_shm files:\n$ ftok /e/fp/smooto2a/scratch/authdigest_shm.17725 /e/fp/smooti2a/scratch/authdigest_shm.13024 \n/e/fp/smooto2a/scratch/authdigest_shm.17725 10600aa\n/e/fp/smooti2a/scratch/authdigest_shm.13024 10600aa\n\nThe inode numbers of both files happen to be very similar:\n$ ls -i  /e/fp/smooto2a/scratch/authdigest_shm.17725 /e/fp/smooti2a/scratch/authdigest_shm.13024\n 8388778 /e/fp/smooti2a/scratch/authdigest_shm.13024\n16777386 /e/fp/smooto2a/scratch/authdigest_shm.17725\n\nThis can be seen when the inode numbers are displayed in hex:\n$ printf \"%07x\\n%07x\\n\" 8388778 16777386\n08000aa\n10000aa\n\nThe similar inode numbers are possibly caused by our choice of filesystem (xfs)\n\nSo it would seem that the warning in the ftok(3) manpage applies:\n       Of course no guarantee can be given that the resulting key_t is unique.\n       Typically, a best effort attempt combines the given proj_id  byte,  the\n       lower  16 bits of the i-node number, and the lower 8 bits of the device\n       number into a 32-bit result.  Collisions may easily happen, for example\n       between files on /dev/hda1 and files on /dev/sda1.\n\nWhen browsing through the apr code (shmem/unix/shm.c) it appears that\nshmkeys are always generated with proj_id == 1:\n\n        /* ftok() (on solaris at least) requires that the file actually\n         * exist before calling ftok(). */\n        shmkey = ftok(filename, 1);\n        if (shmkey == (key_t)-1) {\n            return errno;\n        }\n\n        if ((new_m->shmid = shmget(shmkey, new_m->realsize,\n                                   SHM_R | SHM_W | IPC_CREAT | IPC_EXCL)) < 0) {\n            return errno;\n        }\n\nPerhaps ftok could be made to iterate over a number of proj_id's and use the first proj_id where shmget succeeds?\nHowever, that would require addinional logic in the apr_shm_remove function,\nbecause it also uses ftok to calculate the shmkey to remove.\nWhat would be needed is that the shmkey is stored somewhere when it is created and the stored value of shmkey is used when the time has arrived to destroy\nthe shared memory segment.", "id": 162715, "time": "2012-10-12T13:06:13Z", "bug_id": 53996, "creation_time": "2012-10-12T13:06:13Z", "is_private": false, "attachment_id": null}, {"attachment_id": null, "tags": [], "creator": "jim@apache.org", "is_private": false, "count": 1, "id": 171270, "time": "2013-11-16T22:50:41Z", "bug_id": 53996, "creation_time": "2013-11-16T22:50:41Z", "text": "Thanks for the report... a simple way could be to stat the file and use possibly the UID as the prod_id. Or create apr_shm_ftok() to generate the key and bypass ftok completely."}, {"count": 2, "tags": [], "bug_id": 53996, "attachment_id": null, "id": 171277, "time": "2013-11-17T14:30:07Z", "creator": "jim@apache.org", "creation_time": "2013-11-17T14:30:07Z", "is_private": false, "text": "Starting with APR 1.5.1, ftok uses an APR hash of the filename for the prom_id value, reducing the possibility of collisions."}, {"count": 3, "text": "Until we can expose the ftok prod_id used, we need to stay with 1 which has been the assumed value for a LOOOONG time :/", "bug_id": 53996, "attachment_id": null, "id": 172690, "time": "2014-01-24T22:14:36Z", "creator": "jim@apache.org", "creation_time": "2014-01-24T22:14:36Z", "tags": [], "is_private": false}, {"count": 4, "text": "This is fixed in apr 1.5.1, which is being rolled out now and will be announced in a couple of days.", "bug_id": 53996, "attachment_id": null, "id": 174726, "time": "2014-04-19T12:21:42Z", "creator": "trawick@apache.org", "creation_time": "2014-04-19T12:21:42Z", "tags": [], "is_private": false}]