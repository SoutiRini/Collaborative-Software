[{"count": 0, "tags": [], "bug_id": 49677, "is_private": false, "text": "Created attachment 25821\nFor test\n\n1.For HSSF\n  //When I adjust xls default column width by excel 2007.then use follow code  \n  //get defaultcolumn width ,broke a excepton\n@Test\n    public void testGetDefaultColumnWidthForHSSF() {\n\tHSSFWorkbook wb;\n\tHSSFSheet sheet;\n\tFileInputStream finput = null;\n\tFile file;\n\tString xlsSourceFile = \"testfile\\\\testcolumnwidth.xls\";\n\tfile = new File(xlsSourceFile);\n\ttry {\n\t    finput = new FileInputStream(file);\n\t    wb = new HSSFWorkbook(finput);\n\t    finput.close();\n\t    finput = null;\n\t    sheet = wb.getSheetAt(2);\n\t    System.out.println(sheet.getDefaultColumnWidth());\n\t    \n\t} catch (FileNotFoundException e) {\n\t    e.printStackTrace();\n\t} catch (IOException e) {\n\t    e.printStackTrace();\n\t} finally {\n\t    try {\n\t\tif (finput != null)\n\t\t    finput.close();\n\t\t\n\t    } catch (IOException e) {\n\t\te.printStackTrace();\n\t    }\n\t}\n  }\n// Exception :\norg.apache.poi.hssf.record.RecordFormatException: Unable to construct record instance\n\tat org.apache.poi.hssf.record.RecordFactory$ReflectionRecordCreator.create(RecordFactory.java:64)\n\tat org.apache.poi.hssf.record.RecordFactory.createSingleRecord(RecordFactory.java:263)\n\tat org.apache.poi.hssf.record.RecordFactoryInputStream.readNextRecord(RecordFactoryInputStream.java:270)\n\tat org.apache.poi.hssf.record.RecordFactoryInputStream.nextRecord(RecordFactoryInputStream.java:236)\n\tat org.apache.poi.hssf.record.RecordFactory.createRecords(RecordFactory.java:392)\n\tat org.apache.poi.hssf.usermodel.HSSFWorkbook.<init>(HSSFWorkbook.java:278)\n\tat org.apache.poi.hssf.usermodel.HSSFWorkbook.<init>(HSSFWorkbook.java:203)\n\tat org.apache.poi.hssf.usermodel.HSSFWorkbook.<init>(HSSFWorkbook.java:319)\n\tat org.apache.poi.hssf.usermodel.HSSFWorkbook.<init>(HSSFWorkbook.java:300)\n\tat poi.TestPOI.testGetDefaultColumnWidthForHSSF(TestPOI.java:437)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:597)\n\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)\n\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)\n\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)\n\tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)\n\tat org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:31)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:73)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:46)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:180)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:41)\n\tat org.junit.runners.ParentRunner$1.evaluate(ParentRunner.java:173)\n\tat org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:31)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:220)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:46)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)\nCaused by: org.apache.poi.hssf.record.RecordFormatException: Not enough data (0) to read requested (2) bytes\n\tat org.apache.poi.hssf.record.RecordInputStream.checkRecordPosition(RecordInputStream.java:215)\n\tat org.apache.poi.hssf.record.RecordInputStream.readUShort(RecordInputStream.java:260)\n\tat org.apache.poi.hssf.record.DefaultColWidthRecord.<init>(DefaultColWidthRecord.java:41)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)\n\tat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)\n\tat java.lang.reflect.Constructor.newInstance(Constructor.java:513)\n\tat org.apache.poi.hssf.record.RecordFactory$ReflectionRecordCreator.create(RecordFactory.java:56)\n\t... 33 more\n\n2.For XSSF\n  //In  XSSFSheet.getDefaultColumnWidth\n    public int getDefaultColumnWidth() {\n        CTSheetFormatPr pr = worksheet.getSheetFormatPr();\n        return pr == null ? 8 : (int)pr.getBaseColWidth();\n        //1. When pt is null ,return 8.It is error .Because I read excel 2007   \n        //help default width is 8.43 char width\n        //2. When pt not null or default width is adjusted,pr.getBaseCol is   \n       //error,It will return 8 forever.Should call pr.getDefaultColWidth(),But \n       //return type is int !\n    }", "id": 138762, "time": "2010-07-30T05:17:51Z", "creator": "longxibo@sina.com", "creation_time": "2010-07-30T05:17:51Z", "attachment_id": 25821}, {"count": 1, "tags": [], "text": "The bug with HSSFSheet.getDefaultColumnWidth() is not reproducible with the latest trunk.\n\nYegor", "is_private": false, "bug_id": 49677, "id": 147285, "time": "2011-06-20T17:09:16Z", "creator": "yegor@dinom.ru", "creation_time": "2011-06-20T17:09:16Z", "attachment_id": null}]