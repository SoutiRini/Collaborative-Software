[{"count": 0, "tags": [], "text": "Overview:\n\nAPR currently treats any sort of NTFS reparse point as a symlink (see, for instance, fillin_fileinfo). However, an NTFS reparse point may be one of several things:\n\n   * A \"symbolic link\" (very similar to n*x symbolic links)\n   * A \"hard link\"\n   * A \"directory junction\", also called a \"mounted folder\" (very similar to a mount point)\n\nIt's currently unclear to me if APR should treat hard links as APR_LNK or APR_REG (I guess APR_REG), but APR should definitely treat junctions as APR_DIR (the same as you would treat a mount point on Linux, etc.).\n\nDetermining if a reparse point is a directory junction described in the MSDN documentation: \"Determining Whether a Directory Is a Mounted Folder\"\nhttp://msdn.microsoft.com/en-us/library/aa363940(VS.85).aspx\n\nRepro steps:\n1. Use any APR API to determine the file type of a mounted folder (\"directory junction\").\n\nExpected result:\n    APR_DIR\n\nActual result:\n    APR_LNK\n\nSee: fillin_fileinfo in /apr/apr/trunk/file_io/win32/filestat.c. There may also be other places that need to be updated; I'm not familiar enough with the APR source.", "is_private": false, "id": 129425, "creator": "dan_j_thompson@hotmail.com", "time": "2009-08-03T21:10:38Z", "bug_id": 47630, "creation_time": "2009-08-03T21:10:38Z", "attachment_id": null}, {"count": 1, "attachment_id": null, "bug_id": 47630, "text": "Symbolic links on Unix are polymorphic, just as you described for Junctions.\nThis behavior is by design.\n\nUnlike a unix mount point, a Junction is not a directory.  Unlike a unix\nmount point, rm is not used to remove the intersection of the file systems.\nAnd like Unix symlinks, a Junction may refer to a nonexistent or invalid object.\n\nA Junction is never a hard link; NTFS has hard links, these are well defined\nobjects and are invisible to the consumer after creation except by comparing\nfile ID (e.g. inode) for equality.\n\nAPR_LNK must be dereferenced to discover the target resource.  Omitting the\napr_file_info flag APR_FINFO_LINK should resolve the referenced APR_DIR.  \nIs this not what  you observe?", "id": 129436, "time": "2009-08-04T04:53:20Z", "creator": "wrowe@apache.org", "creation_time": "2009-08-04T04:53:20Z", "tags": [], "is_private": false}, {"attachment_id": null, "tags": [], "creator": "dan_j_thompson@hotmail.com", "text": "(In reply to comment #1)\n> Symbolic links on Unix are polymorphic, just as you described for Junctions.\n> This behavior is by design.\n\nNo, I think reparse points are polymorphic. A junction is a specific type/usage of a reparse point. Reparse points are used to implement a lot of things; see http://msdn.microsoft.com/en-us/library/aa365511(VS.85).aspx.\n\n> Unlike a unix mount point, a Junction is not a directory.  Unlike a unix\n> mount point, rm is not used to remove the intersection of the file systems.\n\nAs far as I can tell, junctions are almost /exactly/ the same as unix mount points, perhaps minus the restrictions on reparse points (like you can have only 31 reparse points in a given path). Another term for a junction is a \"mounted folder\". The MSDN documentation states that \"Because mounted folders are directories, you can rename, remove, move, and otherwise manipulate them, as you would other directories.\" (http://msdn.microsoft.com/en-us/library/aa365237(VS.85).aspx)\n\n> And like Unix symlinks, a Junction may refer to a nonexistent or invalid\n> object.\n\nThe only case that I am aware of where a junction can refer to a nonexistent or invalid target is if the volume that the junction refers to fails. I'm not sure how unix could do anything different. This is what the documentation says (from same page referenced earlier):\n\n\"If a volume fails, any volumes that have been assigned to mounted folders on that volume can no longer be accessed through those mounted folders. For example, suppose you have two volumes, C: and D:, and that D: is associated with the mounted folder C:\\MountD\\. If volume C: fails, volume D: can no longer be accessed through the path C:\\MountD\\.\"", "count": 2, "id": 129446, "time": "2009-08-04T10:03:03Z", "bug_id": 47630, "creation_time": "2009-08-04T10:03:03Z", "is_private": false}, {"count": 3, "tags": [], "bug_id": 47630, "attachment_id": null, "text": "Understand that a unix mount point *is a directory*.  That's what the filesystem\nsees.  The driver handles those mounts, not the filesystem.\n\nUnix also allows symlinks to point to other directories.\n\nSimilarly, Windows allows any driver to register a mount without the existence\nof a Junction.  The Junction is a filesystem entity, not a driver entity.\n\nJunctions allow the user to point any directory at another.  \n\njunction.exe dir1 alias1\n\nis completely valid.  rd dir1 and you will find alias1 is broken.  There is no\ndistinction in the filesystem driver between a junction to another directory \non the same volume, or a junction to another volume.\n\n\"Mount points\" are only one use of junctions, and they are not the same as\na driver registering it's mount point in NTFS space.\n\nThis behavior is identical to the behavior of directory symlinks on Unix.\n\nYou did not answer my question of whether you are seeing these entities as\ndirectories when APR_FINFO_LINK is omitted from the apr_file_info_get flags.", "id": 129448, "time": "2009-08-04T11:09:01Z", "creator": "wrowe@apache.org", "creation_time": "2009-08-04T11:09:01Z", "is_private": false}, {"count": 4, "tags": [], "bug_id": 47630, "text": "(In reply to comment #3)\n> Understand that a unix mount point *is a directory*.\n\nBut... for all intents and purposes, a junction is just as much of a directory: The MSDN documentation states that \"Because mounted folders\nare directories, you can rename, remove, move, and otherwise manipulate them,\nas you would other directories.\"\n(http://msdn.microsoft.com/en-us/library/aa365237(VS.85).aspx)\n\n> That's what the filesystem sees. The driver handles those mounts,\n> not the filesystem.\n\nNTFS is not a driver? Anyway, I don't think the implementation matters (it does not matter where in the driver stack it is implemented, nor does it matter whether a mount point is recorded in fstab or filesystem metadata); I think that windows junctions are the moral equivalent of unix mount points. For the purposes of creating a portable runtime, they should be treated the same.\n\n> Unix also allows symlinks to point to other directories.\n\nWindows also allows symlinks (distinct from junctions) to point to other directories. Windows junctions and windows symlinks-to-directories are two different things. Just like unix mount points and unix symlinks are different things.\n\n> Similarly, Windows allows any driver to register a mount without the existence\n> of a Junction.\n\nI don't know how that is accomplished; if you happen to know how, I would be interested in that.\n\n> The Junction is a filesystem entity, not a driver entity.\n> Junctions allow the user to point any directory at another.\n> junction.exe dir1 alias1\n> is completely valid.  rd dir1 and you will find alias1 is broken.  There is no\n> distinction in the filesystem driver between a junction to another directory \n> on the same volume, or a junction to another volume.\n\nAs of Linux 2.4.0 (I don't know about other unices), it is possible to remount part of the file heirarchy somewhere else (\"mount --bind olddir newdir\"). I don't know where in the driver stack that is implemented, but again, for the purposes of creating a portable runtime, I don't think that matters.\n\n> You did not answer my question of whether you are seeing these entities as\n> directories when APR_FINFO_LINK is omitted from the apr_file_info_get flags.\n\nSorry, I have not had time to test that. But I don't think it is relevant to this bug; the point of this bug is that NTFS junctions are the moral equivalent of unix mount points and should be treated as such by the APR.\n\nFor instance, if you go into the Disk Management tool (right-click Computer, choose \"manage\", then drill into Storage-->Disk Management in the navigation heirarchy), and you choose to mount a partition somewhere (this is the windows GUI version of \"mount\"), it will create a junction. (Not a directory symlink, and not some sort of special non-junction mount point that you refer to above.)\n\nIf I do find a problem with APR_FINFO_LINK and apr_file_info_get in the future, I will be sure to open a separate bug for that issue.", "id": 129465, "time": "2009-08-04T21:33:16Z", "creator": "dan_j_thompson@hotmail.com", "creation_time": "2009-08-04T21:33:16Z", "is_private": false, "attachment_id": null}, {"attachment_id": null, "tags": [], "creator": "wrowe@apache.org", "text": "> Windows also allows symlinks (distinct from junctions) to point to other\n> directories. Windows junctions and windows symlinks-to-directories are two\n> different things. Just like unix mount points and unix symlinks are different\n> things.\n\nI am studying that relationship to determine how we will finally implement\napr_file_symlink_create() et al.  Most likely, in XP/2003 directory symlinks\nwill continue to be junctions, while Vista/2008 with upgraded NTFS file systems\nwould gain symlinks.  The 1/2 hour of testing I did today was not promising.\n\nBut Junctions have no relationship to unix mount points.  Just like symlinks,\njunctions and mount points can be renamed.  Unlike mount points, the change\nis immediate.  It is not at the driver layer.  In the unix case, the mount\nis at a much lower level, and that rename causes the system to fail (in fact,\nit isn't possible).\n\nYou are missing the distinction between kernel layer/driver driven mounts, such\nas unix and also windows drivers, and userspace controllable filesystem aliases.\nA Junction is a symlink-style alias, and for security must be represented as\nsuch, because any user can manipulate them.  End of discussion.\n\n> Sorry, I have not had time to test that. But I don't think it is relevant to\n> this bug; the point of this bug is that NTFS junctions are the moral equivalent\n> of unix mount points and should be treated as such by the APR.\n\nOk, this is clearly confusion on your point as to the flexibility of Junctions\nand where they sit on the driver stack.  Meaning no disrespect, I am closing\nthis bug as invalid.", "count": 5, "id": 129466, "time": "2009-08-04T21:50:16Z", "bug_id": 47630, "creation_time": "2009-08-04T21:50:16Z", "is_private": false}, {"count": 6, "tags": [], "text": "Closing.  If a problem exists in resolving Junctions w/o APR_FINFO_LINK flag,\nfeel free to reopen and recycle this incident.", "is_private": false, "id": 129467, "creator": "wrowe@apache.org", "time": "2009-08-04T21:51:28Z", "bug_id": 47630, "creation_time": "2009-08-04T21:51:28Z", "attachment_id": null}, {"attachment_id": null, "tags": [], "creator": "dan_j_thompson@hotmail.com", "text": "(In reply to comment #5)\n> But Junctions have no relationship to unix mount points.  Just like symlinks,\n> junctions and mount points can be renamed.  Unlike mount points, the change\n> is immediate.  It is not at the driver layer.  In the unix case, the mount\n> is at a much lower level, and that rename causes the system to fail (in fact,\n> it isn't possible).\n\nI think the layer is irrelevant. I don't understand \"unlike mount points, the change is immediate\"--you can unmount /a/b and remount it as /a/c, just as \"immediately\", right? (so what if you have to type two commands vs. one)\n\n> You are missing the distinction between kernel layer/driver driven mounts, such\n> as unix and also windows drivers, and userspace controllable filesystem\n> aliases.\n\nWhat does \"mount --bind olddir newdir\" do? And NTFS is not userspace. If you want to fool around with the reparse point information, you have to send IOCTLs via DeviceIoControl--to the kernel-mode driver.\n\n> A Junction is a symlink-style alias, and for security must be represented as\n> such, because any user can manipulate them.  End of discussion.\n\nIronically, any user can create a junction, provided it has access to the things it is linking, but for windows symlinks, you must have [elevated] administrative privileges (unless you tweak security policy).\n\nHowever, I don't understand why you think that is a security problem. On linux, normal users can mount things if those rights are granted (like cdrom). With junctions, it's as if there is a magic fstab file that grants the \"user\" option to any places that the user has rights to. And a user has rights to manipulate directories, so if the APR treated junctions as directories, why would that be a security problem?\n\n> Ok, this is clearly confusion on your point as to the flexibility of Junctions\n> and where they sit on the driver stack.  Meaning no disrespect, I am closing\n> this bug as invalid.\n\nNo disrespect taken. But what does the driver stack have to do with anything? Even if there are some behavior and implementation details that are different between windows and unices, what is important to building a portable runtime is that windows junctions are the moral equivalent to unix mount points. Differences in implementation don't matter, and even some differences in behavior don't matter, because APR treats mount points as directories, and directories can and do change, by the actions of users or superusers.\n\nFor a portable program, where you would use a mount point on linux, you would use a junction on windows. The Apache portable runtime should reflect this.", "count": 7, "id": 129468, "time": "2009-08-04T22:49:48Z", "bug_id": 47630, "creation_time": "2009-08-04T22:49:48Z", "is_private": false}, {"count": 8, "attachment_id": null, "bug_id": 47630, "is_private": false, "id": 129469, "time": "2009-08-04T23:48:00Z", "creator": "wrowe@apache.org", "creation_time": "2009-08-04T23:48:00Z", "tags": [], "text": "No, you would not.\n\nA modestly privilaged unix user cannot change mounts.\n\nAny authenticated win32 user can edit junctions.\n\nTherefore this is far less kernel-oriented and far more symlink oriented.\n\nAnd you've offered no argument for breaking the APR *portability* association\nof junctions and symlinks, other than \"I don't think it should work this way.\"\nOther than to open up a raft of new security issues, what is your technical\nargument that the existing behavior is broken?"}, {"count": 9, "tags": [], "bug_id": 47630, "is_private": false, "text": "(In reply to comment #8)\n> No, you would not.\n> A modestly privilaged unix user cannot change mounts.\n\nUnless granted those privileges. Such as for cdrom.\n\n> Any authenticated win32 user can edit junctions.\n\nAny win32 user can edit directories.\n\n> Therefore this is far less kernel-oriented and far more symlink oriented.\n> And you've offered no argument for breaking the APR *portability* association\n> of junctions and symlinks, other than \"I don't think it should work this way.\"\n> Other than to open up a raft of new security issues,\n\nWhat is the specific security concern? I.e., a win32 user can create, remove, or change a junction, so if the APR treated junctions as directories, this would cause... what? Data loss vulnerability? Spoofing vulnerability? Tampering vulnerability? DoS vulnerability? Repudiation vulnerability? Elevation of privilege vulnerability? How? Like, \"Alice creates a Junction in a directory that Bob has write access to, and he deletes the junction, so...\"\n\n> what is your technical\n> argument that the existing behavior is broken?\n\nOn windows, in my experience, if you want to \"play tricks\" with your filesystem such as store a bunch of files on some other drive but make them show up somewhere in your C: drive, you use a junction. Mountvol creates a junction. If you use the disk managment GUI to mount a volume anywhere other than as a separate drive letter, it creates a junction.\n\nThis is analogous to how mount points are used in unix. We even call them \"mounted folders\". Wherever you use \"mount\" on unix, you use \"mountvol\" on windows.\n\nIf you are using this method to play tricks with your directory structure, and then use a program that uses the APR and does not happen to omit APR_FINFO_LINK when getting info about a directory, then the trick does not work with that program.", "id": 129484, "time": "2009-08-05T08:00:22Z", "creator": "dan_j_thompson@hotmail.com", "creation_time": "2009-08-05T08:00:22Z", "attachment_id": null}, {"count": 10, "tags": [], "bug_id": 47630, "attachment_id": null, "is_private": false, "id": 129486, "time": "2009-08-05T09:04:20Z", "creator": "wrowe@apache.org", "creation_time": "2009-08-05T09:04:20Z", "text": "junction path/to/cgi-bin path/to/htdocs/revealscript\n\nis just one example, I'm not going to repeat 20 years of security issues surrounding symlinks for your benefit.\n\nJunctions are alias/symlinks.  A junction cannot point at an unmounted volume.\n\nE.g. although my checkouts to develop apr on httpd look like\n\n  build/\n        httpd-2.2/\n        apr-1.3/\n        apr-util-1.3/\n        apr-iconv-1.3/\n\nso that svn up httpd-* apr-* bring all sources up-to-date, \n\n  build/\n        httpd-2.2/\n                  srclib/\n                         apr <junction to apr-1.3>\n                         apr-util <junction to apr-util-1.3>\n                         apr-iconv <junction to apr-iconv-1.3>\n\nPlease don't tell me that this facility doesn't expose the same issues as\nsymlinks raise.  That's why APR was designed to handle symlinks in this manner.\n\nThe symlink protection is in there to help determine when aliases exist.\n\n> If you are using this method to play tricks with your directory structure, and\n> then use a program that uses the APR and does not happen to omit APR_FINFO_LINK\n> when getting info about a directory, then the trick does not work with that\n> program.\n\nPrecisely.  This is exactly the same impact on unix of a symlinked directory.  \nErgo the portability behavior is 100% correct, and this discussion really \nis finished."}, {"count": 11, "tags": [], "creator": "wrowe@apache.org", "text": "As a few follow up observations;\n\nMKLINK /J by default requires no security escalation, while MKLINK for files\nor directories is usually denied to all but administrator by default.  This\nreaffirms the conclusion that Junction must be recognized as a symlink when\ninspecting with lstat rather than stat or by open resource handle.\n\nAn arbitrary example of where junctions are effectively and frequently used as \nsymlinks can be found at;\n\n  http://www.mydigitallife.info/2007/05/22/create-symbolic-links-hard-links-and-directory-junctions-in-vista-with-mklink/\n\nwhich notes that Vista et al default to creating one such Junction on the boot\ndrive by default; C:\\Documents and Settings [C:\\Users]\n\nReviewing the behavior tonight to validate that Junctions and Dir-Symlinks\nboth resolve to the directory when APR_FINFO_LINK is omitted, along with \nFile-Symlinks as well.", "id": 130013, "time": "2009-08-27T19:07:48Z", "bug_id": 47630, "creation_time": "2009-08-27T19:07:48Z", "is_private": false, "attachment_id": null}, {"count": 12, "tags": [], "bug_id": 47630, "attachment_id": null, "text": "A variant of this trips SVN badly, and can cause surprises for Apache httpd installs too.\n\nIf SVN is running on an NTFS volume that has the Windows Data Deduplication active, it breaks miserably once files in the working set get deduplicated (and replaced by reparse points).\n\nhttps://technet.microsoft.com/en-us/library/hh831602%28v=ws.11%29.aspx\n\nWhat happens is this:\n1. Windows triggers deduplication after some time (default 5 days) and replaces a file with a reparse point for dedup\n2. When SVN scans the repository, it finds a change to the file and claims that the special file status has changed AND claims to not support symlinks, so it breaks.\n3. It is mislead into believing this is a symlink, due to this issue in APR, which turns an IO_REPARSE_TAG_DEDUP into a 'symlink', while its not.\n\nSo any SVN checkout on a data deduplicated volume is doomed and will totally break once Dedup kicks in. Especially nice as it happens with a delay, so once it happens the only cure is a totally fresh checkout. You cannot do anything with the checkout anymore.\n\nSo please reopen this and provide some better semantics for all the non-symlinky Reparse Points.\n\nThe SVN mailing list stated this is a bug in APR:\nhttps://mail-archives.apache.org/mod_mbox/subversion-dev/201210.mbox/%3C006d01cdae05$5b0d7310$11285930$@qqmail.nl%3E\n\nThe same issue trips Apache httpd when testing for Options +FollowSymlinks, reparse Points are treated as symlinks and a valid Apache install on a deduped volume may break randomly, when the content dir gets elected for deduplication.", "id": 191191, "time": "2016-05-23T15:48:15Z", "creator": "msc@contact.de", "creation_time": "2016-05-23T15:48:15Z", "is_private": false}, {"attachment_id": null, "tags": [], "creator": "wrowe@apache.org", "text": "I agree that non-Junction reparse points should be evaluated on a case-by-case\nbasis, you make a good distinction for IO_REPARSE_TAG_DEDUP, which is a system\ngenerated (safe, non-userland) equivalence.\n\nBut I disagree this bug is the correct bug to edit, the subject makes the case \nfor junctions to be treated as non-symlinks and that's simply inappropriate for\nall of the reasons listed in comments above.\n\nWould you please re-close and create a new ticket, rather than recycle an old\ntangentially-related ticket?", "count": 13, "id": 191198, "time": "2016-05-23T19:08:10Z", "bug_id": 47630, "creation_time": "2016-05-23T19:08:10Z", "is_private": false}, {"count": 14, "attachment_id": null, "bug_id": 47630, "is_private": false, "id": 191206, "time": "2016-05-23T21:32:05Z", "creator": "wrowe@apache.org", "creation_time": "2016-05-23T21:32:05Z", "tags": [], "text": "Reviewed the original comment #1 and it did raise in a general sense the specific \nissue in comment #12 (although we disagreed on the scope of examples provided,\nthe dir link was agreed as an APR_LNK, junction was debatable but should still be\npresented as APR_LNK for the security considerations outlined in #10.)\n\nBut this report called out that we did not distinguished by reparse type, which\nis the root of comment #12, so let us continue to use this ticket to explicitly\nset the behavior type-by-type (which could be patched by the dev to satisfy their\nown opinion).  I've changed the title slightly to reflect this wider scope.\n\nSorry for the confusion I introduced in my previous comment."}, {"count": 15, "tags": [], "bug_id": 47630, "text": "Agreed. The scope of this ticket went a bit toward the link/junction part, as that was the most common type encountered in the wild at the time of the ticket creation.\n\nThe reparse point tag list at MSDN lists quite a few tags, which might be encountered, although most will be rare in smaller infrastructures.\n\nhttps://msdn.microsoft.com/en-us/library/aa365511%28v=vs.85%29.aspx\n\nSlightly explaining the values:\nhttps://msdn.microsoft.com/en-us/library/dd541667.aspx\n\nThe docs are not really that informative sadly, but the tags seem to be like this, even if probably not complete:\n\nIO_REPARSE_TAG_CSV   - Cluster Shared Volumes (transparently mounting a SMB Share to share storage between cluster nodes), kind of a mount point\n\nIO_REPARSE_TAG_DEDUP - Data Deduplication in Windows Server 2012\n\nIO_REPARSE_TAG_DFS   - Seem to be related to Distributed-Filesystem Replication\nIO_REPARSE_TAG_DFSR    \n\nIO_REPARSE_TAG_HSM   - Hierarchical Storage Manager redirections\nIO_REPARSE_TAG_HSM2   \n\nIO_REPARSE_TAG_SYMLINK - Win7 Symlinks\nIO_REPARSE_TAG_MOUNT_POINT - Seems the one used for junctions and filesystem mount points\n\nIO_REPARSE_TAG_NFS - Probably the NFS Filesystem filter driver\n\nIO_REPARSE_TAG_SIS - Single Instance Storage, seems to be similar to the Dedup one (https://msdn.microsoft.com/en-us/library/windows/desktop/aa362556%28v=vs.85%29.aspx)\n\nIO_REPARSE_TAG_WIM - seems to be mountpoints for WIM images (e.g. similar to a mounted disc image), see http://permalink.gmane.org/gmane.comp.file-systems.ntfs-3g.devel/1161\n\n\nAll the dedup and installable filesystem style stuff should probably be treated as normal files/directories. The SYMLINK and MOUNT_POINT things are probably correctly treated as APR_LINK.", "id": 191216, "time": "2016-05-24T11:33:52Z", "creator": "msc@contact.de", "creation_time": "2016-05-24T11:33:52Z", "is_private": false, "attachment_id": null}, {"attachment_id": null, "tags": [], "creator": "wrowe@apache.org", "is_private": false, "count": 16, "id": 191230, "time": "2016-05-24T16:54:00Z", "bug_id": 47630, "creation_time": "2016-05-24T16:54:00Z", "text": "I wonder if we can get additional clues as to IO_REPARSE_TAG_MOUNT_POINT whether\nthis is a junction or other facility?\n\nI agree that we should devolve anything other than junction mount points and\nIO_REPARSE_TAG_SYMLINK from APR_LNK into an APR_DIR or APR_FILE as appropriate.\nI don't think we can comprehensively cover every possible and future resource type,\nand we should add user-controlled, potentially harmful symlinks as we understand\nthat list in more detail over time."}, {"count": 17, "tags": [], "creator": "msc@contact.de", "attachment_id": null, "id": 191251, "time": "2016-05-25T10:08:24Z", "bug_id": 47630, "creation_time": "2016-05-25T10:08:24Z", "is_private": false, "text": "This article has some info how to distinguish a directory junction and a volume mount point.\n\nhttp://www.codeproject.com/Articles/21202/Reparse-Points-in-Vista\n\nwhich points at the structure defintions here:\nhttps://msdn.microsoft.com/en-us/library/ff552012.aspx"}, {"attachment_id": null, "tags": [], "creator": "wrowe@apache.org", "text": "There is discussion of 1.6 and perhaps 2.0-RC releases in the very near future. This should get a closer look and patch before year end, and certainly before a tag. It is a significant behavior change, even if it is a 'bug fix'.", "count": 18, "id": 195488, "time": "2016-12-14T07:53:07Z", "bug_id": 47630, "creation_time": "2016-12-14T07:53:07Z", "is_private": false}]