[{"count": 0, "tags": [], "creator": "nicholas@nicholaswilliams.net", "is_private": false, "text": "Created attachment 30059\nThread dump when blocking\n\nI'm attempting to write a binary message using the OutputStream returned by RemoteEndpoint.Basic#getSendStream(). The code that is doing this is as follows:\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException\n    {\n        ClusterMessage message = new ClusterMessage();\n        message.setNodeId(this.nodeId);\n        message.setMessage(\"request:{ip:\\\"\" + request.getRemoteAddr() +\n                \"\\\",queryString:\\\"\" + request.getQueryString() + \"\\\"}\");\n\n        try(OutputStream output = this.session.getBasicRemote().getSendStream();\n            ObjectOutputStream stream = new ObjectOutputStream(output))\n        {\n            stream.writeObject(message);\n        }\n        response.getWriter().append(\"OK\");\n    }\n\nWhen I perform this request, the browser waits for a response forever. It never stops. Assuming there was an infinite loop somewhere, I took a thread dump (attached). An exception was logged to stderr pretty much instantaneously when I make the request:\n\nException in thread \"Thread-18\" java.lang.IllegalStateException: Message will not be sent because the WebSocket session has been closed\n\tat org.apache.tomcat.websocket.WsRemoteEndpointImplBase.writeMessagePart(WsRemoteEndpointImplBase.java:270)\n\tat org.apache.tomcat.websocket.WsRemoteEndpointImplBase.endMessage(WsRemoteEndpointImplBase.java:256)\n\tat org.apache.tomcat.websocket.WsRemoteEndpointImplBase$EndMessageHandler.onResult(WsRemoteEndpointImplBase.java:398)\n\tat org.apache.tomcat.websocket.WsRemoteEndpointImplBase$OutputBufferSendHandler.write(WsRemoteEndpointImplBase.java:647)\n\tat org.apache.tomcat.websocket.WsRemoteEndpointImplBase$OutputBufferSendHandler.onResult(WsRemoteEndpointImplBase.java:656)\n\tat org.apache.tomcat.websocket.WsRemoteEndpointImplClient$SendHandlerToCompletionHandler.completed(WsRemoteEndpointImplClient.java:77)\n\tat org.apache.tomcat.websocket.WsRemoteEndpointImplClient$SendHandlerToCompletionHandler.completed(WsRemoteEndpointImplClient.java:66)\n\tat sun.nio.ch.Invoker.invokeUnchecked(Invoker.java:126)\n\tat sun.nio.ch.Invoker.invokeUnchecked(Invoker.java:269)\n\tat sun.nio.ch.WindowsAsynchronousSocketChannelImpl$WriteTask.completed(WindowsAsynchronousSocketChannelImpl.java:814)\n\tat sun.nio.ch.Iocp$EventHandlerTask.run(Iocp.java:397)\n\tat sun.nio.ch.AsynchronousChannelGroupImpl$1.run(AsynchronousChannelGroupImpl.java:112)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)\n\tat java.lang.Thread.run(Thread.java:722)\n\nAnd I get some disconcerting log entries when I shut Tomcat down:\n\nMar 17, 2013 5:22:42 AM org.apache.catalina.core.StandardWrapper unload\nINFO: Waiting for 1 instance(s) to be deallocated\nMar 17, 2013 5:22:43 AM org.apache.catalina.core.StandardWrapper unload\nINFO: Waiting for 1 instance(s) to be deallocated\nMar 17, 2013 5:22:44 AM org.apache.catalina.core.StandardWrapper unload\nINFO: Waiting for 1 instance(s) to be deallocated\nMar 17, 2013 5:22:44 AM org.apache.catalina.loader.WebappClassLoader clearReferencesThreads\nSEVERE: The web application [/myWebApp] appears to have started a thread named [WebSocket background processing] but has failed to stop it. This is very likely to create a memory leak.\nMar 17, 2013 5:22:44 AM org.apache.catalina.loader.WebappClassLoader clearReferencesThreads\nSEVERE: The web application [/myWebApp] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation.\nMar 17, 2013 5:22:44 AM org.apache.coyote.AbstractProtocol stop\nINFO: Stopping ProtocolHandler [\"http-nio-8080\"]\nMar 17, 2013 5:22:44 AM org.apache.coyote.AbstractProtocol stop\nINFO: Stopping ProtocolHandler [\"ajp-nio-8009\"]\nMar 17, 2013 5:22:44 AM org.apache.coyote.AbstractProtocol$AbstractConnectionHandler process\nSEVERE: Error reading request, ignored\njava.lang.NullPointerException\n\tat org.apache.coyote.http11.Http11NioProcessor.isRegisteredForWrite(Http11NioProcessor.java:250)\n\tat org.apache.coyote.http11.Http11NioProcessor.process(Http11NioProcessor.java:237)\n\tat org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:620)\n\tat org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.process(Http11NioProtocol.java:223)\n\tat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1581)\n\tat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1540)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)\n\tat java.lang.Thread.run(Thread.java:722)\n\nMar 17, 2013 5:22:44 AM org.apache.coyote.AbstractProtocol destroy\nINFO: Destroying ProtocolHandler [\"http-nio-8080\"]\nMar 17, 2013 5:22:44 AM org.apache.coyote.AbstractProtocol destroy\nINFO: Destroying ProtocolHandler [\"ajp-nio-8009\"]\n\nAt this point I tried to look for the infinite loop. The first problem I found was o.a.t.websocket.WsRemoteEndpointImplBase.WsOutputStream, even though the thread dump does not suggest that this is where the problem is:\n\n        @Override\n        public void write(byte[] b, int off, int len) throws IOException {\n            int remaining = buffer.remaining();\n            int written = 0;\n\n            while (remaining < len) {\n                buffer.put(b, off + written, remaining);\n                written += remaining;\n                flush();\n                remaining = buffer.remaining();\n            }\n            buffer.put(b, off + written, len - written);\n        }\n\nIf len is ever greater than the remaining buffer size, this method will never complete. I improved the method like so:\n\n        @Override\n        public void write(byte[] b, int off, int len) throws IOException {\n            if (buffer.remaining() == 0) {\n                flush();\n            }\n\n            int remaining = buffer.remaining();\n            int written = 0;\n\n            while (remaining < len/* - written*/) {\n                buffer.put(b, off + written, remaining);\n                written += remaining;\n                flush();\n                remaining = buffer.remaining();\n            }\n            buffer.put(b, off + written, len - written);\n        }\n\nThis (obviously) did not resolve the infinite loop problem (though I AM confident that it fixes a bug that just hasn't been seen yet). Thread dumps all look the same over and over again. The symptom is intermittent: the thread dump shows that every call to WsOutputStream#close() is hanging, but sometimes the respons returns to the browser anyway (even though the message never sends).\n\nAt this point, after working on it for five hours, it is beyond my Tomcat/WebSocket expertise to solve. Which is unfortunate. I really needed this today. :-(", "id": 165893, "time": "2013-03-17T10:34:28Z", "bug_id": 54711, "creation_time": "2013-03-17T10:34:28Z", "attachment_id": 30059}, {"attachment_id": null, "tags": [], "bug_id": 54711, "text": "Please note, I pasted the wrong improved method in here. Actual version:\n\n        @Override\n        public void write(byte[] b, int off, int len) throws IOException {\n            if (buffer.remaining() == 0) {\n                flush();\n            }\n\n            int remaining = buffer.remaining();\n            int written = 0;\n\n            while (remaining < len - written) {\n                buffer.put(b, off + written, remaining);\n                written += remaining;\n                flush();\n                remaining = buffer.remaining();\n            }\n            buffer.put(b, off + written, len - written);\n        }", "count": 1, "id": 165894, "time": "2013-03-17T10:36:45Z", "creator": "nicholas@nicholaswilliams.net", "creation_time": "2013-03-17T10:36:45Z", "is_private": false}, {"count": 2, "tags": [], "bug_id": 54711, "attachment_id": 30061, "is_private": false, "id": 165903, "time": "2013-03-17T17:55:28Z", "creator": "nicholas@nicholaswilliams.net", "creation_time": "2013-03-17T17:55:28Z", "text": "Created attachment 30061\nPatch to resolve issue\n\nFixed with attached patch! Woohoo!\n\nThis was a doozy. There were several problems cause a myriad of issues here:\n\n- WsRemoteEndpointImplBase.WsOutputStream was not flipping the underlying buffer before calling endpoint.sendPartialBytes(buffer, boolean), hence the endless blocking seen in the attached thread dump.\n\n- java.io.Closeable#close() documentation says \"If the stream is already closed then invoking this method has no effect.\" Both WsOutputStream and WsRemoteEndpointImplBase.WsWriter violated this contract. If WsOutputStream or WsWriter were used in a try-with-resources block, close() would get called twice, and thus sendPartialBytes/sendPartialString would get called twice. This resulted in two messages getting sent: one with the payload and one empty.\n\n- Calls to flush() and write() methods on WsOutputStream and WsWriter should not be allowed after close is called.\n\n- Both WsOutputStream#write(byte[] b, int off, int len) and WsWriter#write(char[] c, int off, int len) would loop forever if len was greater than 8192 (not difficult).\n\n- Both WsOutputStream#write(byte[] b, int off, int len) and WsWriter#write(char[] c, int off, int len) were susceptible to unclean input.\n\n- Unrelated but found while debugging: o.a.t.websocket.WsRemoteEndpointImplClient#doWrite was calling getSendTimeout() and then setting the returned value to Long.MAX_VALUE if it was less than 1, but then it was never using that returned value; it was calling getSendTimeout() again."}, {"attachment_id": null, "tags": [], "bug_id": 54711, "text": "By the way, I'm still getting the following two disconcerting stdout messages when shutting down Tomcat. This is obviously better than it used to be and there are no more errors at all. I'm not sure how these threads are getting created or how to stop them. My guess is that this is a separate bug, unrelated to this. \"WebSocket background processing - stopping\" is obviously created by Tomcat. I did NOT create the anonymously named \"Thread-22.\"\n\nMar 17, 2013 1:05:01 PM org.apache.catalina.loader.WebappClassLoader clearReferencesThreads\nSEVERE: The web application [/myWebApp] appears to have started a thread named [WebSocket background processing - stopping] but has failed to stop it. This is very likely to create a memory leak.\nMar 17, 2013 1:05:01 PM org.apache.catalina.loader.WebappClassLoader clearReferencesThreads\nSEVERE: The web application [/myWebApp] appears to have started a thread named [Thread-22] but has failed to stop it. This is very likely to create a memory leak.", "count": 3, "id": 165904, "time": "2013-03-17T18:08:46Z", "creator": "nicholas@nicholaswilliams.net", "creation_time": "2013-03-17T18:08:46Z", "is_private": false}, {"attachment_id": null, "tags": [], "bug_id": 54711, "text": "Thanks for the work on this. Patch applied.", "count": 4, "id": 165974, "time": "2013-03-18T21:04:49Z", "creator": "markt@apache.org", "creation_time": "2013-03-18T21:04:49Z", "is_private": false}]