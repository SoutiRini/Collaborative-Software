[{"count": 0, "tags": [], "creator": "per.sil@gmx.it", "text": "I had a problem reading HSSFCell values with german specific letters (umlauts).\nMost probably the same difficulties apply to all characters from integer value\n128 to 255.\n\nThey all have ended up with high byte having all bits set to 1. It has turned\nout this is a type cast problem on J2SE 1.4.2(06). \n\nCasting from byte to char seems to take the highest bit of the byte to fill the\nhigh byte of the char value. German umlaut \u00e4 (&auml;) uses 0xe4 or 11100100.\nConverting this value to char results in 1111111111100100.\n\nSee this small code:\n----------------------\npublic class ByteConverterTest {\n    public static void main(String[] args) {\n        byte umlautChar = (byte)0xe4;  // the German umlaut &auml; \u00e4\n        char badEncoded = (char)umlautChar;\n        char goodEncoded = (char)( (short)0xff & (short)umlautChar );\n        \n        System.out.println(\"Badly converted umlaut uses hex value: \" +\nInteger.toHexString(badEncoded));\n        System.out.println(\"Good converted umlaut uses hex value: \" +\nInteger.toHexString(goodEncoded) + \"\\n\");\n    }\n}\n----------------------\n\nOutput is:\n----------------------\nBadly converted umlaut uses hex value: ffe4\nGood converted umlaut uses hex value: e4\n----------------------\n\nAttached you will find a patch to resolve this issue with the class\nUnicodeString. The function fillFields uses this type of inproper type cast.\nPerhaps ofer classes do as well.\n\nReproducible: Always (see test code)\nPlattform: Windows 2k, Linux 2.6.x\nJVM: J2SE 1.4.2(06) and J2SE 1.4.2(10)\n\n\nFor those who are experiencing the same problem but do not want to wait for this\npatch making its way to CVS, you can use the following code to convert your cell\nvalue to proper Java string:\n----------------------\nString cellValue = cell.getRichStringCellValue().getString();\n// clean invalid type casts\nif (cellValue != null) {\n    char[] buffer = cellValue.toCharArray();\n    StringBuffer newValue = new StringBuffer(buffer.length);\n    for (int i=0; i<cellValue.length; i++) {\n        char charValue = buffer[i];\n        short numValue = (short)charValue;\n\n        // strip high byte if all bits are set to 1 \n       if ((numValue & 0xff00) == 0xff00)\n            charValue = (char)(numValue & 0xff);\n\n        newValue.append(charValue);\n    }\n        \n    cellValue = newValue.toString();\n}\n\n----------------------\n\n\nI have tried to find a previously entered bug report on this subject but failed.\nI am sorry if i have missed it.", "id": 84496, "time": "2006-01-11T23:28:56Z", "bug_id": 38230, "creation_time": "2006-01-11T23:28:56Z", "is_private": false, "attachment_id": null}, {"count": 1, "tags": [], "bug_id": 38230, "attachment_id": 17394, "text": "Created attachment 17394\npoi-UnicodeString-typecast.2006-01-11.diff\n\n\npatch to correct issue with type cast from byte to char.", "id": 84497, "time": "2006-01-11T23:36:16Z", "creator": "per.sil@gmx.it", "creation_time": "2006-01-11T23:36:16Z", "is_private": false}, {"count": 2, "tags": [], "bug_id": 38230, "attachment_id": null, "id": 84694, "time": "2006-01-17T10:17:48Z", "creator": "jheight@apache.org", "creation_time": "2006-01-17T10:17:48Z", "is_private": false, "text": "Wow. Good catch. Confirmed that this happens with other versions of the JDK ie\n1.5.0_03\n\nSuggested change is Ok. I have tidied it up a bit and fixed all occurrances of\nthe cast to char (ie RecordInputStream and UnnicodeString)\n\nCommitted to SVN.\n\nJason"}]