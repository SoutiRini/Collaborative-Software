[{"count": 0, "attachment_id": null, "bug_id": 59432, "text": "XSSFName\n\npublic void setNameName(String name)\n  {\n    validateName(name);\n\n    int sheetIndex = getSheetIndex();\n\n    for (int i = 0; i < this._workbook.getNumberOfNames(); i++) {\n      XSSFName nm = this._workbook.getNameAt(i);\n      if ((nm != this) && \n        (name.equalsIgnoreCase(nm.getNameName())) && (sheetIndex == nm.getSheetIndex())) {\n        String msg = new StringBuilder().append(\"The \").append(sheetIndex == -1 ? \"workbook\" : \"sheet\").append(\" already contains this name: \").append(name).toString();\n        throw new IllegalArgumentException(msg);\n      }\n    }\n\n    this._ctName.setName(name);\n  }", "id": 190748, "time": "2016-05-06T03:29:43Z", "creator": "cgh_chen@126.com", "creation_time": "2016-05-06T03:29:43Z", "tags": [], "is_private": false}, {"count": 1, "tags": [], "creator": "onealj@apache.org", "text": "Adding a name requires checking the name manager for existing names to avoid defining the same name at the same scope (my guess is this would result in a corrupt workbook). POI uses a na\u00efve implementation, shown in comment 0, which requires O(n) time for a na\u00efve implementation. We could perform this check in O(1) using a hash table with a hashable tuple (scope, name) as the key. A less elegant, inferior solution that runs in O(1) uses nested hash tables: the first layer having scope (sheet name or global) keys and the second layer having name keys (inner and outer key could swapped). This comes at the cost of higher memory consumption and increasing the complexity of the code (and therefore higher chance for bugs).\n\nGiven the code from comment 0, I'm not surprised that adding N names is slow, as it is performing O(N\u00b2) operations.\n\nHere's what you could do:\n1) Provide a patch with a speed-optimized implementation with 100% test coverage.\n2) Provide a patch with a non-validating version of setNameName (probably called setNameNameUnsafe) [1]\n3) access the CT* classes yourself, either with introspection, subclassing, or forking POI, which gives you direct access to the CTName data structure. This would complicate upgrading POI in the future.\n\n[1] Relevant discussion on dev@poi mailing list http://apache-poi.1045710.n5.nabble.com/Preventing-corrupt-workbooks-td5722973.html", "id": 191026, "time": "2016-05-17T14:35:23Z", "bug_id": 59432, "creation_time": "2016-05-17T14:35:23Z", "is_private": false, "attachment_id": null}, {"attachment_id": null, "tags": [], "creator": "onealj@apache.org", "is_private": false, "count": 2, "id": 191030, "time": "2016-05-17T15:00:45Z", "bug_id": 59432, "creation_time": "2016-05-17T15:00:45Z", "text": "class NameManagerKeyTuple() {\n    public final String scope, name;\n    public constructor NameManagerKeyTuple(String scope, String name) {\n        this.scope = scope; // how will you represent global scope? Null?, How will you update this data structure if a sheet is renamed or re-ordered? Keeping this data structure in sync with sheet renames is the biggest hurdle.\n        this.name = name; // and assert not null and convert to canonical case a la String.toLower(Locale.ROOT)\n    }\n    @Override\n    public int hashCode() {\n        return scope.hashCode() + name.hashCode(); // whatever you use for global scope, make sure it has a consistent hash code. Null requires null check to prevent NPE.\n    }\n    @Override\n    public interest equals(Object other) {\n        if (!(other instanceof NameManagerKeyTuple)) {\n            return false;\n        }\n        NameManagerKeyTuple o = (NameManagerKeyTuple) other;\n        return scope.equals(o.scope) && name.equals(o.name); // again, check for NPE if values could be null;\n    }\n}\n\nNameManager\nprivate final Map<NameManagerKeyTuple, CTName> names = new HashMap<>();"}, {"count": 3, "attachment_id": null, "bug_id": 59432, "text": "Moved getNumberOfNames outside of the loop in r1748832.\nUsing a StringBuilder as suggested in comment 0 provides no performance benefit.", "id": 191747, "time": "2016-06-17T11:10:17Z", "creator": "onealj@apache.org", "creation_time": "2016-06-17T11:10:17Z", "tags": [], "is_private": false}, {"count": 4, "attachment_id": null, "bug_id": 59432, "text": "It seems this was actually fixed already in POI 3.15 via r1754521 and bug 59734, there we changed the access pattern to fetch by name from a ArrayListValuedHashMap from commons-collections4.\n\n*** This bug has been marked as a duplicate of bug 59734 ***", "id": 194459, "time": "2016-10-15T20:26:17Z", "creator": "dominik.stadler@gmx.at", "creation_time": "2016-10-15T20:26:17Z", "tags": [], "is_private": false}]