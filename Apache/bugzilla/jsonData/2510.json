[{"count": 0, "attachment_id": null, "bug_id": 2510, "is_private": false, "id": 3504, "time": "2001-07-09T01:21:50Z", "creator": "bernd.eilers@sun.com", "creation_time": "2001-07-09T01:21:50Z", "tags": [], "text": "The traverseImport(Element importDecl) method in \norg/apache/xerces/validators/schema/TraverseSchema.java uses it\u00b4s own \nEntityResolver and does not utilize the EntityResolver set at the Parser.\n\nThe method should first consult the EntityResolver set at the parser and only \nif that does not return an InputSource try to use it\u00b4s own EntityResolver.\n\nTo reproduce an Error:\n\nUse a simple extension of org.apache.apache.xerces.readers.XMLCatalogHandler as \nan EntityResolver at your parser. At the XMLCatalogHandler add a mapping for \nthe following system identifiers to a private internal URI scheme.\n\nmyCatalog.addSystemMapping\n(\"http://www.w3.org/2001/xml.xsd\",\"org.apache.java.resource:/org/apache/test/xml\n.xsd\");\n\nparser.setEntityResolver(myCatalog);\n\nxmlReader.setProperty(\"http://apache.org/xml/properties/schema/external-\nschemaLocation\",\"http://www.w3.org/2001/XMLSchema \norg.apache.java.resource:/org/apache/test/XMLSchema.xsd\");\n\nThe resolveEntity method of the XMLCatalog should be able to load resource from \nthe java classpath via this private URI scheme. Add XMLSchema.xsd, \nXMLSchema.dtd, datatypes.dtd and xml.xsd from W3C to the org.apache.test \npackage.\n\nEnable schema validating and namespaces at the parser and try to validate eg. \npersonal-schema.xml or personal.xsd.\n\nThe following happens:\n\nThe XMLCatalog/EntityResolver is called for XMLSchema.xsd, XMLSchema.dtd, \ndatatypes.dtd and xml.xsd.\n\nThan the ErrorHandler set at the parser will report an Error that it could not \nfind org.apache.java.resource:/org/apache/test/XMLSchema.dtd and an Exception \ncaused by traverseImport(Element importDecl) not calling the parsers \nEntityResolver is thrown."}, {"count": 1, "tags": [], "bug_id": 2510, "attachment_id": null, "id": 3509, "time": "2001-07-09T09:12:04Z", "creator": "neilg@ca.ibm.com", "creation_time": "2001-07-09T09:12:04Z", "is_private": false, "text": "This works now, and should have since 1.3.0 or thereabouts.  You might want to \nupgrade, since 1.2.3 is quite old."}, {"count": 2, "tags": [], "text": "Created attachment 301\ntestcase, run test with java -jar test1.jar, source code included", "attachment_id": 301, "id": 3531, "creator": "bernd.eilers@sun.com", "time": "2001-07-09T23:36:00Z", "bug_id": 2510, "creation_time": "2001-07-09T23:36:00Z", "is_private": false}, {"count": 3, "tags": [], "bug_id": 2510, "attachment_id": null, "text": "Sorry, the version setting was wrong.\nThe bug occurred on xerces-J-1.4.1\nI also tried to upgrade to the toplevel CVS source, but the problem is still \nthere. So I am reopening the bug.\n\nI have created a testcase and appended that to the bug.\n", "id": 3532, "time": "2001-07-09T23:38:25Z", "creator": "bernd.eilers@sun.com", "creation_time": "2001-07-09T23:38:25Z", "is_private": false}, {"count": 4, "attachment_id": null, "bug_id": 2510, "is_private": false, "id": 3549, "time": "2001-07-10T09:20:38Z", "creator": "neilg@ca.ibm.com", "creation_time": "2001-07-10T09:20:38Z", "tags": [], "text": "Just had a look inside your com.sun.star.test1.test.java program.  In the run \nmethod, you build your EntityResolver and register it with an \norg.xml.sax.Parser object.  Then you create an org.xml.sax.XMLReader object and \nuse it to parse your XML document.  This new object has no idea about the \nEntityResolver you've created--since no EntityResolver has been registered with \nit--and so neither does Xerces or traverseImportDecl(...).  \n\nHope that helps. :-)"}, {"text": "No it does not help because:\n\nI got the XMLReader interface (not object !) from the same  SAXParser created \nbefore. OK i admit that setting the ErrorHandler and EntityResolver at the \nXMLParser is better but xerces WAS able to handle that and behaved correctly \nfor that not so nice written part of the test. \n\nBut changing it as suggested does not change the effect, it\u00b4s still there.\n\nIn both cases the EntityResolver is called by xerces for XMLSchema.xsd, \nXMLSchema.dtd, datatypes.dtd and xml.xsd. But is is than NOT called by the \nXMLSchema.dtd used in the xml.xsd. T\n\nYou didn\u00b4t even run the test before setting the bug to resolved invalid, did \nyou ?\n\nThe explaination for setting the bug to resolved invalid it is IMHO wrong. If  \nthe EntityResolver set at the parser object instead of at the XMLReader \ninterface would not have been honored than it would also not have been called \nfor the other 4 items.\n\n\n\n\n", "tags": [], "bug_id": 2510, "attachment_id": null, "count": 5, "id": 3584, "time": "2001-07-10T15:41:44Z", "creator": "bernd.eilers@sun.com", "creation_time": "2001-07-10T15:41:44Z", "is_private": false}, {"count": 6, "attachment_id": null, "bug_id": 2510, "is_private": false, "id": 3585, "time": "2001-07-10T16:25:08Z", "creator": "bernd.eilers@sun.com", "creation_time": "2001-07-10T16:25:08Z", "tags": [], "text": "Have a look at lines 1981 + 1982 of the traversImport method in \nTraverseSchema.java in the 1.4.1 version. That\u00b4s lines 2047 + 2048 in the cvs \ntolevel version of that file.\n\n         DOMParser parser = new IgnoreWhitespaceParser();\n         parser.setEntityResolver( new Resolver() );\n\nHere a new Parser and a new Resolver object are created, the new Parser and the \nnew Resolver get no knowledge about the EntityResolver set at the parser. I \ndon\u00b4t know much about this code yet but i think it should look like:\n\n         DOMParser parser = new IgnoreWhitespaceParser();\n         parser.setEntityResolver( new Resolver(fEntityResolver) );\n\nAnd the resolveEntity method at that internal class should than first try to \ncall this fEntityResolver and only if this returns null try to return any of \nit\u00b4s internally known resources.\n\nBye the way: the XMLSchema.xsd, XMLSchema.dtd, datatypes.dtd, xml.xsd and \nrelated files included in the testcase are more up to date and completer \nversions of XMLSchema schemas than the structures.dtd and datatypes.dtd in the \nsame package.\n\n"}, {"text": "XMLValidator.java in the same package uses such a inner Resolver class that is \ninitialized with the current parsers entityResolver.\n\nBut the code using that also fails to use the ErrorHandler of the current \nparser if one is available.\n", "tags": [], "bug_id": 2510, "attachment_id": null, "count": 7, "id": 3589, "time": "2001-07-10T16:41:38Z", "creator": "bernd.eilers@sun.com", "creation_time": "2001-07-10T16:41:38Z", "is_private": false}, {"attachment_id": null, "tags": [], "creator": "neilg@ca.ibm.com", "is_private": false, "count": 8, "id": 3633, "time": "2001-07-11T07:55:31Z", "bug_id": 2510, "creation_time": "2001-07-11T07:55:31Z", "text": "Lots to respond to:  \n\n1.  The reason your ErrorHandler was picked up by your parser object when \ndeclared on an XMLReader object (yes these are objects...) is that a SAX2 \nadapter is used to transform a pre-existing XMLReader into a Parser when the \ngetParser method is called.  This I must admit I did not know.  \n\n2.  The DOMParser used in traverseImportDecl isn't responsible for resolving \nschemas referred to by the schema it's parsing; this is why it gets a dummy \nentityResolver.  (you could argue ione should be set actually).  Basically the \nDOMParser simply parses the schema file into a DOM that the TraverseSchema \nclass then operates on; it's up to TraverseSchema to figure out what schemas it \nreferences and pull them in using the EntityResolver it has access to.  \n\n3.  Once I made all references relative (i.e., got rid of the vnd.sun.* names \nin your Test program and simply used a local file name, the fild-not-found \nwarning went away.  I don't know sufficiently well how Java uses these package \nnames to comment on why this might be the case.\n\n4.  That isn't to say the errors went away:  we have some problems with these \nfiles that relate to the xml namespace prefix.  \n\n5.  We don't actually use the structures.dtd and datatypes.dtd that are in the \nXerces package; we have custom facilities for validating schemas.  To validate \na schema, you simply write an instance document for it and feed that to the \nparser; if there are errors in the schema they will be detected then.  These \ntwo .dtd files should be removed from the parser package.\n\nSo there are some bugs to be pointed out here for sure, but they don't have to \ndo with the traverseImportDecl method directly.  \n\nCheers,\nNeil"}, {"count": 9, "tags": [], "text": "Lots to comment on too:\n\nfor 2.) The DOMParser used in traverseImport has the xerces parser feature \nhttp://xml.org/sax/features/external-parameter-entities set to it\u00b4s default \nvalue true. Thus for any schema with a doctype declaration eg.\n\n<!DOCTYPE xs:schema PUBLIC \"-//W3C//DTD XMLSCHEMA 200102//EN\" \"XMLSchema.dtd\" >\n\nit will try to load the DTD. The dummy Resolver set at that DOMparser isn\u00b4t \nable to provide the DTD as it only provides dtd\u00b4s of an older version of the \nXML Schema specification. Add the following statement at the begin of the \nresolveEntity in the TraverseSchema.java\u00b4s Resolver and you will see what i \nmean.\n\nSystem.err.println(\"TraverseSchema resolveEntity publicId=\"+publicId+\", \nsystemId=\"+systemId);\n\nIMHO it\u00b4s correct to load the DTD here (we are validating!) but the DOMParser \nshould use a resolving method that can provide it. Thus the dummy provider \nshould be modified to call the Resolver set at the parser if it can not provide \nit itself and additionally it would also be a good idea to update it to being \nable to provide the current DTD\u00b4s itself, of course.\n\nfor 3.) What happens if you do such modification is the following: The Resolver \nset at the DOMHandler is still not able to provide the DTD. Any Resolver set at \nthe parse in use is still not called. But as the Resolver set at the DOMParser \nreturned null now Xerces default entity resolving routines are called. Luckily \ndue to the modification the XML Schema that was traversed came from a location \nthose default routines can handle. Essentially after such modification a later \neffect of the problem is not visible because it is circumvented by the parsers \ndefault routines now loading the DTD. But the reported problem will still be \nshown: The Debug printout in the supplied EntityResolver is not there for this \nDTD. The supplied EntityResolver is not called for all entities that need to be \nresolved.\n\nWhat I want to stress here is that the traversed Schemas will be loaded by the \nentityResolver set at the current parser if it provides them while ANY(!) \nloading of external referenced entities used in that Schema will not use the \nentityResolver set at the parser. This includes but is not limited to the \nloading of a DTD used in a DOCTYPE declaration of a Schema.\n\nWhy would I want to be able to load Schemas and external entities they \nreference from locations not using the http:// scheme, that\u00b4s simple because \nit\u00b4s faster to cache them locally somehow.\n\nIs this allowed ? \n\nYes, the XML namespace specification and XMLSchema specification explicitly \nmention that the namespace must not necessarly be identical with the physical \nlocation of the resource. \n\nWhy can\u00b4t I always do this it by using file:// URL\u00b4s, because the parsing might \nbe done in an environment where access to java.io.File routines is prohibited. \nEg. the servlet Specification only guarantees access to one temporary directory \nfor everything other file access the webserver can throw a security exception. \nSimpilar things happen for java code executed in a J2EE Application server. \n\nXerces is one of today\u00b4s most advanced XML parser, the advanced features \nshouldn\u00b4t be limited to toy environments.\n\nThe setEntityResolver at the XMLReader allows we to customize the parser to use \nmy own method of providing resources. It\u00b4s not important that you understand \nhow the specific method used in my testcase to provide resources works (loading \nthem from java packages). I could as well have them load them from a database \nor using JNDI or whatever. What is important is that whenever resources \nreferenced by other resources are loaded this customized loading method should \nconsulted first and not ignored.\n\nfor 4.) OK, seems that those are different problems that ought to be reported \nas annother bug.\n\nfor 5.) No i don\u00b4t think they should be removed, they shoud be updated to the \nones included in my testcase ;-) As this would enable the Schema validator to \nbe able to handle schema documents that use a DOCTYPE declaration to declare \nthat they are schema documents, see above. \n\nSure fixing this problem would most likely also get the code a major step \nfurther in being able to validate Schemas, but the scope of the problem is \nbroder. The XML Schema Schema is just one in a dozen of Schemas that can not be \nvalidated in some situations. And the fact that there is a workaround for the \nsub-problem of validating schema documents does not solve the general problem.\n\nMisc.) One related bug that has been pointed out and has also to do with the \ntraverseImport method directly is that some errors during traversImport are \nprinted to stderr instead of calling the ErrorHandler supplied to the parser.\n\nMeta.) I am not very familar with the procedures used in the Xerces-J open \nsource community yet. Should we continue this discussion in the bugtracker or \nshould we move it to the developer mailing list ?\n\n\n", "is_private": false, "id": 3664, "creator": "bernd.eilers@sun.com", "time": "2001-07-12T00:34:31Z", "bug_id": 2510, "creation_time": "2001-07-12T00:34:31Z", "attachment_id": null}, {"count": 10, "attachment_id": null, "bug_id": 2510, "is_private": false, "id": 3692, "time": "2001-07-12T13:37:30Z", "creator": "neilg@ca.ibm.com", "creation_time": "2001-07-12T13:37:30Z", "tags": [], "text": "continuing the discussion on xerces-j-dev."}]