[{"attachment_id": null, "tags": [], "creator": "stefano.delsal@insiel.it", "text": "I'm trying to sign a document using the transform TRANSFORM_XPATH2FILTER, \nbut I get a bad signature if I try to use ONLY the filter\nXPath2FilterContainer.SUBTRACT\n\n1) Ex: \nString filters[][] = { \n   {XPath2FilterContainer.SUBTRACT, \"//NotToBeSigned\"} \n   };\ntransforms.addTransform(\n   Transforms.TRANSFORM_XPATH2FILTER,     \n   XPath2FilterContainer.newInstances(doc, filters)\n);\n\nWith this filter I always get the same DigestValue element inside SignedInfo,\neven with different xml sources.\nBut, if I try to add the filter XPath2FilterContainer.INTERSECT \nincluding all nodes, then I get the right DigestValue and signature\n\n2) Ex: \nString filters[][] = { { XPath2FilterContainer.INTERSECT, \"*\" },{\nXPath2FilterContainer.SUBTRACT,  \"//NotToBeSigned\"} };                         \ntransforms.addTransform(Transforms.TRANSFORM_XPATH2FILTER,\nXPath2FilterContainer.newInstances(doc, filters));\n\nThe second example works both with the 1.3 and  1.2 releases, while the first\none does not work with 1.3 release.", "count": 0, "id": 85190, "time": "2006-01-30T10:48:14Z", "bug_id": 38444, "creation_time": "2006-01-30T10:48:14Z", "is_private": false}, {"count": 1, "tags": [], "creator": "stefano.delsal@insiel.it", "attachment_id": 17534, "id": 85192, "time": "2006-01-30T10:58:28Z", "bug_id": 38444, "creation_time": "2006-01-30T10:58:28Z", "is_private": false, "text": "Created attachment 17534\nTest case\n\nTrying to sign 2 different docs, you have to get 2 different digest value.\nIn 1.3 version ,if you use Filters OK (row 57) it works, but if you use Filters\nKO (row 60)  it doensn't work.\nIn 1.2.1 version it works also with Filters KO."}, {"count": 2, "tags": [], "text": "I modify the source file\norg.apache.xml.security.transforms.implementations.TransformXPath2Filter\ninner class XPath2NodeFilter, method isNodeInclude :\n\npublic boolean isNodeInclude(Node currentNode) {\n   boolean notIncluded = false;\t\n   if (!substractNodes.isEmpty() && rooted(currentNode, substractNodes)) {\n      notIncluded = true;\n   } else \n   if (!intersectNodes.isEmpty() && !rooted(currentNode, intersectNodes)) {\n      notIncluded = true;\n   }\n   if (!unionNodes.isEmpty() && notIncluded && rooted(currentNode, unionNodes))\n      {\n   notIncluded = false;\n}\n return !notIncluded;\n}\n\nI add the 3 checks !isEmpty() for each ArrayList and now it seems to work.", "is_private": false, "bug_id": 38444, "id": 85208, "time": "2006-01-30T18:58:29Z", "creator": "stefano.delsal@insiel.it", "creation_time": "2006-01-30T18:58:29Z", "attachment_id": null}, {"count": 3, "tags": [], "bug_id": 38444, "is_private": false, "text": "Incorpareted fix in SVN, thanks for your findings.", "id": 86857, "time": "2006-03-15T14:00:02Z", "creator": "raul-info@r-bg.com", "creation_time": "2006-03-15T14:00:02Z", "attachment_id": null}, {"count": 4, "tags": [], "bug_id": 38444, "attachment_id": null, "id": 91976, "time": "2006-08-06T18:03:04Z", "creator": "raul-info@r-bg.com", "creation_time": "2006-08-06T18:03:04Z", "is_private": false, "text": "Closing old bugs."}]