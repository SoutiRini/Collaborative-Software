[{"count": 0, "tags": [], "creator": "david.crocker@nrel.gov", "text": "Created attachment 31282\nthis file has lots of hidden line breaks.\n\nOur spreadsheets have long formulas in them, so I spent some effort formatting them to be able to make sense out of them.  I used Shift+Enter to produce the soft line break.  See below for an example:\n\nIF(\n    INDEX('TRB Record'!C$2:C$61,ROW()*2-5,,1)=\"\",\n    \"\",\n    INDEX('TRB Record'!C$2:C$61,ROW()*2-5,,1)\n   )\n\nMicrosoft Excel handles the line breaks without any trouble, and they are easy to read and debug.  (Okay, I'm uptight.) But hidden in these formulae are the end of line characters ['\\n'].\n\nAnd unfortunately, the POI formula parser breaks when it reaches one of these special EOL characters.  I'm using Eclipse, and I can see the string array reporting the offending EOLs.  Here's the text of the Exception (with Eclipse using the formatting when it reports):\n\norg.apache.poi.ss.formula.FormulaParseException: Parse error near char 3 '\n' in specified formula 'IF(\n       INDEX('TRB Record'!C$2:C$61,ROW()*2-5,,1)=\"\",\n       \"\",\n       INDEX('TRB Record'!C$2:C$61,ROW()*2-5,,1)\n      )'. Expected cell ref or constant literal\n\nHere's a code snippet that produces the Exception:\n\n                XSSFSheet sheet = workbook.getSheet(worksheet);\n                XSSFFormulaEvaluator evaluator = workbook.getCreationHelper().createFormulaEvaluator();\n...\n                int ctype = 0;\n                Cell cell;\n...\n                        Row row = sheet.getRow(rowCtr);//rows.next();\n...\n                                        cell = row.getCell(col,Row.RETURN_BLANK_AS_NULL);\n...\n                                                ctype = evaluator.evaluateFormulaCell(cell);\n\n\nMy planned work-around for this is to wrap the call in a function that strips out the offending characters, builds a temporary cell with the new formula string, and return it.  Then I'll be able to run the evaluate() function against it for processing.", "id": 172890, "time": "2014-02-04T22:12:47Z", "bug_id": 56106, "creation_time": "2014-02-04T22:12:47Z", "is_private": false, "attachment_id": 31282}, {"count": 1, "tags": [], "text": "This starts evaluating on 'Digestion'!A3 and breaks at 'Average whole mass closure'!B3.", "attachment_id": null, "bug_id": 56106, "id": 172891, "time": "2014-02-04T22:21:22Z", "creator": "david.crocker@nrel.gov", "creation_time": "2014-02-04T22:21:22Z", "is_private": false}, {"count": 2, "tags": [], "creator": "david.crocker@nrel.gov", "attachment_id": 31286, "id": 172911, "time": "2014-02-05T16:01:43Z", "bug_id": 56106, "creation_time": "2014-02-05T16:01:43Z", "is_private": false, "text": "Created attachment 31286\nSimple .xlsx for testing bug 56106\n\nThis simple file has a formula with '\\n' EOL breaks.  Use it for building unit tests."}, {"count": 3, "tags": [], "creator": "apache@gagravarr.org", "attachment_id": null, "id": 172912, "time": "2014-02-05T16:05:31Z", "bug_id": 56106, "creation_time": "2014-02-05T16:05:31Z", "is_private": false, "text": "Are you able to create a .xls file with the line breaks in it too? Ideally the same .xlsx file, saved as .xls\n\n(Depending on if .xls supports it, and if so how, may affect the overall fix)"}, {"count": 4, "tags": [], "creator": "david.crocker@nrel.gov", "text": "Created attachment 31287\nPOIBug56106.xls\n\nUse this simple XLS file to test bug 56106.", "id": 172913, "time": "2014-02-05T16:09:14Z", "bug_id": 56106, "creation_time": "2014-02-05T16:09:14Z", "is_private": false, "attachment_id": 31287}, {"count": 5, "tags": [], "text": "Thanks for that!\n\nNext two questions:\n * Can POI parse the formula in the .xls version? Without error? And correctly?\n * Can you use BiffViewer to see how excel encoded the newline into the .xls file? (.xls doesn't store formulas as strings, but as Ptgs, while .xlsx stores the formula string)", "attachment_id": null, "bug_id": 56106, "id": 172914, "time": "2014-02-05T17:05:19Z", "creator": "apache@gagravarr.org", "creation_time": "2014-02-05T17:05:19Z", "is_private": false}, {"count": 6, "attachment_id": null, "bug_id": 56106, "text": "This might be vapor.  I discovered that tika was taking control of the evaluation and I had an older version referenced.  I updated to tika 1.4, and it still doesn't work, but for a different reason.  The exception, now, is \"Incomplete code - don't know how to support the 'area_num' parameter yet\".\n\nThe stack trace goes like this:\n\norg.apache.poi.ss.formula.functions.Index line 87\nIndex line 118\nOperationEvaluatorFactory line 132\nWorkbookEvaluator line 525\n...", "id": 172917, "time": "2014-02-05T19:23:30Z", "creator": "david.crocker@nrel.gov", "creation_time": "2014-02-05T19:23:30Z", "tags": [], "is_private": false}, {"count": 7, "text": "Here is the code for the incomplete function in Index:\n\n\tpublic ValueEval evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1,\n\t\t\tValueEval arg2, ValueEval arg3) {\n\t\tthrow new RuntimeException(\"Incomplete code\"\n\t\t\t\t+ \" - don't know how to support the 'area_num' parameter yet)\");\n\t\t// Excel expression might look like this \"INDEX( (A1:B4, C3:D6, D2:E5 ), 1, 2, 3)\n\t\t// In this example, the 3rd area would be used i.e. D2:E5, and the overall result would be E2\n\t\t// Token array might be encoded like this: MemAreaPtg, AreaPtg, AreaPtg, UnionPtg, UnionPtg, ParenthesesPtg\n\t\t// The formula parser doesn't seem to support this yet. Not sure if the evaluator does either\n\t}\n\nHere is some pseudocode that starts to address the problem:\n\nif arg3 is an integer {\n   ValueEval _arg0SubRange = arg0[arg3]\n   if arg1 not null and arg1 != 0 {\n      if arg2 is null or arg2 == 0 {\n         if row[arg1] not out of bounds in _arg0SubRange {\n            return cell range _arg0SubRange[row[arg1]]\n         } else {\n            return #REF\n         }\n      } else {\n         if cell[arg1,arg2] not out of bounds in _arg0SubRange {\n            return cell reference _arg0SubRange[arg1,arg2]\n         } else {\n            return #REF\n         }\n      }\n   } else {\n      if arg2 is null or arg2 == 0 {\n         return #REF\n      } else {\n         if col[arg2] not out of bounds in _arg0SubRange {\n            return cell range _arg0SubRange[col[arg2]]\n         } else {\n            return #REF\n         }\n      }\n   }\n} else {\n   return #REF\n}\n\nHere's the help detail from Excel:\n\nReference form\nDescription\nReturns the reference of the cell at the intersection of a particular row and column. If the reference is made up of nonadjacent selections, you can pick the selection to look in.\n\nSyntax\nINDEX(reference, row_num, [column_num], [area_num])The INDEX function syntax has the following arguments (argument: A value that provides information to an action, an event, a method, a property, a function, or a procedure.):\n\nReference  Required. A reference to one or more cell ranges.\nIf you are entering a nonadjacent range for the reference, enclose reference in parentheses.\n\nIf each area in reference contains only one row or column, the row_num or column_num argument, respectively, is optional. For example, for a single row reference, use INDEX(reference,,column_num).\nRow_num  Required. The number of the row in reference from which to return a reference.\nColumn_num  Optional. The number of the column in reference from which to return a reference.\nArea_num  Optional. Selects a range in reference from which to return the intersection of row_num and column_num. The first area selected or entered is numbered 1, the second is 2, and so on. If area_num is omitted, INDEX uses area 1.\nFor example, if reference describes the cells (A1:B4,D1:E4,G1:H4), then area_num 1 is the range A1:B4, area_num 2 is the range D1:E4, and area_num 3 is the range G1:H4.\nRemark\nAfter reference and area_num have selected a particular range, row_num and column_num select a particular cell: row_num 1 is the first row in the range, column_num 1 is the first column, and so on. The reference returned by INDEX is the intersection of row_num and column_num. \nIf you set row_num or column_num to 0 (zero), INDEX returns the reference for the entire column or row, respectively.\n\nRow_num, column_num, and area_num must point to a cell within reference; otherwise, INDEX returns the #REF! error value. If row_num and column_num are omitted, INDEX returns the area in reference specified by area_num. \nThe result of the INDEX function is a reference and is interpreted as such by other formulas. Depending on the formula, the return value of INDEX may be used as a reference or as a value. For example, the formula CELL(\"width\",INDEX(A1:B2,1,2)) is equivalent to CELL(\"width\",B1). The CELL function uses the return value of INDEX as a cell reference. On the other hand, a formula such as 2*INDEX(A1:B2,1,2) translates the return value of INDEX into the number in cell B1.", "bug_id": 56106, "attachment_id": null, "id": 172918, "time": "2014-02-05T20:38:28Z", "creator": "david.crocker@nrel.gov", "creation_time": "2014-02-05T20:38:28Z", "tags": [], "is_private": false}]