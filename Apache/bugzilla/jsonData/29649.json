[{"count": 0, "tags": [], "text": "In working with a client experiencing performance issues, I came across the \nfollowing issue. They use Apache to front end a large number of back end web \nappliactions such as CGI's, Websphere, Domino, Cold Fusion, Dynamo, Oracle, \nWebspeed, etc.\n\nWhen the back end servers would stop answering, or even worse would accept the \ntcp connection but never reply back, the main Apache web server would hold the \nconnection for the full server timeout period which was set (for good reason) \nat 5 minutes. Their fierwall, however, would terminate a connection after 40 \nseconds if no data was transferred. Users would get firewall errors, hit reload \nand effectively open lock up a number of Apache processes for up to 5 minutes. \nThe machine would hits its limit of apaches and the site would be inaccessible.\n\nThe obvious answer is to fix the back end systems. Unfortunately one was a \nDomino bug and they had to wait for IBM. I proposed a new architecture with a \nfront end machine capable of handling their transaction load. In the short \nterm, however, something had to be done (the client is a government adgency, \nand they never seem to move things fast enough through the buraceracy).\n\nI therefore made some modifications in mod_proxy by identifying the sticking \npoints, and created a new timeout value not based upon the server config that I \ncould configure within the conf file so they could adjust it whatever firewall \nchanges came down. This was an overwhelming success for the client and dropped \ntheir downtime on the main web server by over 95%.\n\nThis seemed to me to be a good idea to pass back into Apache.\n\nI asked for a configurable or variable timeout change for the core. Here is the \nchanges I made to mod_proxy. The changes are a bit ugly and  shoudl redo them \nto conform to the standards. What I am looking for at this moment is feedback \nas to the issue and solution. I'll make requierd changes to get this up to spec.\n\nmod_proxy.c\n\n81a82,83\n> char *proxyLogFile;\n>\n220a223,225\n> #ifdef EAPI\n>     int rc;\n> #endif /* EAPI */\n227a233,240\n> #ifdef EAPI\n>     if (ap_hook_use(\"ap::mod_proxy::canon\",\n>                     AP_HOOK_SIG3(int,ptr,ptr),\n>                     AP_HOOK_DECLINE(DECLINED),\n>                     &rc, r, url) && rc != DECLINED)\n>         return rc;\n>     else\n> #endif /* EAPI */\n241a255,257\n>     extern int proxyServerSocket;\n>     proxyServerSocket = 0;\n>\n242a259,262\n> #ifdef EAPI\n>     ap_hook_use(\"ap::mod_proxy::init\",\n>                 AP_HOOK_SIG3(void,ptr,ptr), AP_HOOK_ALL, r, p);\n> #endif\n244a265,272\n> #ifdef EAPI\n> static void proxy_addmod(module *m)\n> {\n>     /* export: ap_proxy_http_canon() as `ap::mod_proxy::http::canon' */\n>     ap_hook_configure(\"ap::mod_proxy::http::canon\",\n>                       AP_HOOK_SIG5(int,ptr,ptr,ptr,int), AP_HOOK_TOPMOST);\n>     ap_hook_register(\"ap::mod_proxy::http::canon\",\n>                      ap_proxy_http_canon, AP_HOOK_NOCTX);\n245a274,278\n>     /* export: ap_proxy_http_handler() as `ap::mod_proxy::http::handler' */\n>     ap_hook_configure(\"ap::mod_proxy::http::handler\",\n>                       AP_HOOK_SIG6(int,ptr,ptr,ptr,ptr,int), AP_HOOK_TOPMOST);\n>     ap_hook_register(\"ap::mod_proxy::http::handler\",\n>                      ap_proxy_http_handler, AP_HOOK_NOCTX);\n246a280,297\n>     /* export: ap_proxyerror() as `ap::mod_proxy::error' */\n>     ap_hook_configure(\"ap::mod_proxy::error\",\n>                       AP_HOOK_SIG3(int,ptr,ptr), AP_HOOK_TOPMOST);\n>     ap_hook_register(\"ap::mod_proxy::error\",\n>                      ap_proxyerror, AP_HOOK_NOCTX);\n>     return;\n> }\n>\n> static void proxy_remmod(module *m)\n> {\n>       /* remove the hook references */\n>     ap_hook_unregister(\"ap::mod_proxy::http::canon\", ap_proxy_http_canon);\n>     ap_hook_unregister(\"ap::mod_proxy::http::handler\", ap_proxy_http_handler);\n>     ap_hook_unregister(\"ap::mod_proxy::error\", ap_proxyerror);\n>     return;\n> }\n> #endif /* EAPI */\n>\n376a428,435\n> #ifdef EAPI\n>               if (!ap_hook_use(\"ap::mod_proxy::handler\",\n>                                AP_HOOK_SIG7(int,ptr,ptr,ptr,ptr,int,ptr),\n>                                AP_HOOK_DECLINE(DECLINED),\n>                                &rc, r, cr, url,\n>                                ents[i].hostname, ents[i].port,\n>                                ents[i].protocol) || rc == DECLINED) {\n> #endif /* EAPI */\n385a445,447\n> #ifdef EAPI\n>               }\n> #endif /* EAPI */\n399a462,469\n> #ifdef EAPI\n>     if (ap_hook_use(\"ap::mod_proxy::handler\",\n>                   AP_HOOK_SIG7(int,ptr,ptr,ptr,ptr,int,ptr),\n>                   AP_HOOK_DECLINE(DECLINED),\n>                   &rc, r, cr, url,\n>                     NULL, 0, scheme) && rc != DECLINED)\n>         return rc;\n> #endif /* EAPI */\n463a534,539\n>     ps->connectTimeout = 0;\n>     ps->headerTimeout = 0;\n>     ps->bodyTimeout = 0;\n>     ps->logFile = (char*) NULL;\n>\n>\n499a576,579\n>     ps->connectTimeout = (overrides->connectTimeout == 0) ? base-\n>connectTimeout : overrides->connectTimeout;\n>     ps->headerTimeout = (overrides->headerTimeout == 0) ? base-\n>headerTimeout : overrides->headerTimeout;\n>     ps->bodyTimeout = (overrides->bodyTimeout == 0) ? base->bodyTimeout : \noverrides->bodyTimeout;\n>\n922a1003,1040\n> static const char *\n>      set_connectTimeout(cmd_parms *parms, void *dummy, char *arg)\n> {\n>     proxy_server_conf *psf = ap_get_module_config(parms->server-\n>module_config, &proxy_module);\n>     psf->connectTimeout = atoi(arg);\n>     return NULL;\n> }\n>\n>\n> static const char *\n>      set_headerTimeout(cmd_parms *parms, void *dummy, char *arg)\n> {\n>     proxy_server_conf *psf = ap_get_module_config(parms->server-\n>module_config, &proxy_module);\n>     psf->headerTimeout = atoi(arg);\n>     return NULL;\n> }\n> static const char *\n>      set_bodyTimeout(cmd_parms *parms, void *dummy, char *arg)\n> {\n>     proxy_server_conf *psf = ap_get_module_config(parms->server-\n>module_config, &proxy_module);\n>     psf->bodyTimeout = atoi(arg);\n>     return NULL;\n> }\n>\n> static const char *\n>      set_proxy_error_log(cmd_parms *parms, void *dummy, char *arg)\n> {\n>     extern char *proxyLogFile;\n>     proxyLogFile = arg;\n>     return NULL;\n> }\n>\n>\n>\n>\n>\n>\n930a1049,1056\n>     {\"ProxyErrorLogFile\", set_proxy_error_log, NULL, RSRC_CONF, TAKE1,\n>     \"A Log file to write errors out to\"},\n>     {\"ProxyConnectTimeout\", set_connectTimeout, NULL, RSRC_CONF, TAKE1,\n>     \"A maximum time to allow for a connect to a proxy server\"},\n>     {\"ProxyHeaderTimeout\", set_headerTimeout, NULL, RSRC_CONF, TAKE1,\n>     \"A maximum time to allow for a header to be sent from a proxy server\"},\n>     {\"ProxyBodyTimeout\", set_bodyTimeout, NULL, RSRC_CONF, TAKE1,\n>     \"A maximum time to allow for a body to be sent from a proxy server\"},\n996a1123,1128\n> #ifdef EAPI\n>    ,proxy_addmod,             /* EAPI: add_module */\n>     proxy_remmod,             /* EAPI: remove_module */\n>     NULL,                     /* EAPI: rewrite_command */\n>     NULL                      /* EAPI: new_connection  */\n> #endif\n>\n> void\n> getCurrentDateTime(char *in)\n> {\n>         time_t tempTime;\n>         struct tm *theTime;\n>\n>         time(&tempTime);\n>         theTime = localtime(&tempTime);\n>\n>         sprintf(in, \"%04d/%02d/%02d %02d:%02d:%02d\", theTime->tm_year + 1900, \ntheTime->tm_mon + 1, theTime->tm_mday, theTime->tm_hour, theTime->tm_min, theTi\nme\n> ->tm_sec);\n>\n>         return;\n> }\n>\n> void\n> logIt(char *message)\n> {\n>       char theDate[1024];\n>       FILE *fp;\n>\n>       getCurrentDateTime(theDate);\n>\n>       fp = fopen(proxyLogFile, \"a\");\n>       if (fp)\n>       {\n>               fprintf(fp, \"[%s] %s failed to respond and has been \nterminated.\\n\", theDate, message);\n>               fclose(fp);\n>       }\n> }\n>\n>\n>\n> void\n> cancelProxy(request_rec *theRequest)\n> {\n>       extern int proxyServerSocket;\n>\n>       logIt(theRequest->unparsed_uri);\n>\n>       if (proxyServerSocket != 0)\n>       {\n>               close(proxyServerSocket);\n>       }\n>\n>       theRequest->status = HTTP_BAD_GATEWAY;\n>       ap_proxyerror(theRequest, HTTP_BAD_GATEWAY, \"Upstream Server \nUnavailable.\");\n>         ap_send_error_response(theRequest, 0);\n>\n>       return;\n> }\n>\n>\n>\n\n\nmod_proxy.h\n\n85a86,87\n> int proxyServerSocket;\n>\n205a208,211\n>     int connectTimeout;\n>     int headerTimeout;\n>     int bodyTimeout;\n>     char *logFile;\n344a351\n>\n\n\nproxy_http.c\n\n60a61,72\n> #include \"httpd.h\"\n> #include \"http_config.h\"        /* for read_config */\n> #include \"http_protocol.h\"      /* for read_request */\n> #include \"http_request.h\"       /* for process_request */\n> #include \"http_conf_globals.h\"\n> #include \"http_vhost.h\"\n> #include \"util_script.h\"        /* to force util_script.c linking */\n> #include \"util_uri.h\"\n> #include \"scoreboard.h\"\n> #include \"multithread.h\"\n>\n>\n172a185,189\n> #ifdef EAPI\n>     char *peer;\n> #endif\n>     extern int proxyServerSocket;\n>     proxyServerSocket = 0;\n193a211,216\n> #ifdef EAPI\n>     ap_hook_use(\"ap::mod_proxy::http::handler::set_destport\",\n>                 AP_HOOK_SIG2(int,ptr),\n>                 AP_HOOK_TOPMOST,\n>                 &destport, r);\n> #endif /* EAPI */\n230a254,256\n> #ifdef EAPI\n>       peer = ap_psprintf(p, \"%s:%u\", proxyhost, proxyport);\n> #endif\n236a263,265\n> #ifdef EAPI\n>       peer =  ap_psprintf(p, \"%s:%u\", desthost, destport);\n> #endif\n289c318\n<                                     \"Could not connect to remote machine: \",\n---\n>                                     \"Could not cconnect to remote machine: \",\n310a340,353\n>     proxyServerSocket = sock;\n>\n> #ifdef EAPI\n>     {\n>         char *errmsg = NULL;\n>         ap_hook_use(\"ap::mod_proxy::http::handler::new_connection\",\n>                     AP_HOOK_SIG4(ptr,ptr,ptr,ptr),\n>                     AP_HOOK_DECLINE(NULL),\n>                     &errmsg, r, f, peer);\n>         if (errmsg != NULL)\n>             return ap_proxyerror(r, HTTP_BAD_GATEWAY, errmsg);\n>     }\n> #endif /* EAPI */\n>\n313a357,371\n> #ifdef EAPI\n>     {\n>       int rc = DECLINED;\n>       ap_hook_use(\"ap::mod_proxy::http::handler::write_host_header\",\n>                   AP_HOOK_SIG6(int,ptr,ptr,ptr,int,ptr),\n>                   AP_HOOK_DECLINE(DECLINED),\n>                   &rc, r, f, desthost, destport, destportstr);\n>         if (rc == DECLINED) {\n>           if (destportstr != NULL && destport != DEFAULT_HTTP_PORT)\n>               ap_bvputs(f, \"Host: \", desthost, \":\", destportstr, CRLF, NULL);\n>           else\n>               ap_bvputs(f, \"Host: \", desthost, CRLF, NULL);\n>         }\n>     }\n> #else /* EAPI */\n318a377\n> #endif /* EAPI */\n436c495\n<         ap_hard_timeout(\"proxy receive response status line\", r);\n---\n>         ap_config_timeout(conf->connectTimeout, \"proxy receive response \nstatus line\", r);\n467c526\n<     ap_hard_timeout(\"proxy receive response headers\", r);\n---\n>     ap_config_timeout(conf->connectTimeout, \"proxy receive response headers\", \nr);  // JEFF\n617a677\n> fclose(fp);\n652a713,714\n>\n> // ap_variable_timeout\n\n\nproxy_util.c\n\n461a462,470\n>\n>     void *sconf;\n>     proxy_server_conf *conf;\n>     sconf = r->server->module_config;\n>     conf = (proxy_server_conf *)ap_get_module_config(sconf, &proxy_module);\n>\n>\n>\n>\n515c524\n<             ap_hard_timeout(\"proxy recv body from upstream server\", r);\n---\n>             ap_config_timeout(conf->headerTimeout, \"proxy recv body from \nupstream server\", r);\n1366c1375,1383\n<     ap_hard_timeout(\"proxy connect\", r);\n---\n>     void *sconf;\n>     proxy_server_conf *conf;\n>\n>     sconf = r->server->module_config;\n>     conf = (proxy_server_conf *)ap_get_module_config(sconf, &proxy_module);\n>\n>\n>\n>     ap_config_timeout(conf->headerTimeout, \"proxy connect\", r);", "is_private": false, "bug_id": 29649, "id": 59435, "time": "2004-06-17T18:11:50Z", "creator": "burgoyne@keenuh.com", "creation_time": "2004-06-17T18:11:50Z", "attachment_id": null}, {"count": 1, "text": "Please provide a context or unified diff file format for patches and perform them against the true ASF \nsource tree (not a mod_ssl patched one) for us to consider this. Thanks!!", "creator": "jim@apache.org", "attachment_id": null, "id": 67856, "time": "2004-12-03T02:04:46Z", "bug_id": 29649, "creation_time": "2004-12-03T02:04:46Z", "tags": [], "is_private": false}]