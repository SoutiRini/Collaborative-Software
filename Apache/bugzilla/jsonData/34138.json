[{"count": 0, "tags": [], "creator": "robilad@kaffe.org", "text": "Hi all,\n\nAnt gives an error message out of the box when its javac task is used, no\nbuild.compiler is set and the runtime environment doesn't have a com.sun Javac\nentry point.\n\nThat leads to people using such runtime enviroments patching build.xml files,\nsetting build.compiler in patched Ant shell scripts, and even writing their own\ncom.sun Javac wrappers (java-gcj-wrapper) and setting build.compiler to a known\ngood value in the VM itself (me in Kaffe a few days ago to make Tomcat4's\npristine tarball work unpatched on Kaffe from CVS head. The JSPs didn't compile\nbecause of no Javac being found by Ant).\n\nBefore I propose a solution, is there some specific way of dealing with this\nthat's 'blessed' by Ant developers, beside 'Run Sun!' ? ;)\n\nOtherwise, I'd suggest a 'test for Javac and jikes and gcj and  kjc and an\nexternal javac in java.home' before you abort' approach.\n\ncheers, \ndalibor topic", "id": 17033, "time": "2005-03-22T22:08:14Z", "bug_id": 34138, "creation_time": "2005-03-22T22:08:14Z", "is_private": false, "attachment_id": null}, {"count": 1, "text": "well, there is the environment variable ANT_OPTS that is options to the JVM; set\n\nANT_OPTS=-Dbuild.compiler=kaffe\n\nand every build uses kaffe. Is there some reason why this is inadequate?\n\nI am also thinking of having a well-known properties file that is read in\n*after* all command line stuff, something like\n${user.hom}/.ant/common.properties  ..things like compiler setting, or, more\nimportantly to me, proxy settings, could go in there.", "creator": "stevel@apache.org", "attachment_id": null, "id": 7494, "time": "2005-03-23T11:22:07Z", "bug_id": 34138, "creation_time": "2005-03-23T11:22:07Z", "tags": [], "is_private": false}, {"count": 2, "tags": [], "creator": "bodewig@apache.org", "text": "Test for JavaEnvUtils.getJDKExecutable(\"javac\") would work, for JVMs that come\nwith an executable named javac.  But if we used that, we'd also assume that it\nwas command line compatible with Sun's.\n\nTesting for jikes or gcj is more difficult, you'd have to code up OS specific\ndiagnostics to know the difference between \"command not found\" and \"compilation\nerror\".  Well, we could search for the executable in PATH (the functionality is\nalready there in ExecTask#resolveExecutable.\n\nBut what should be the order of preference?  Personally I'd prefer jikes over\nkjc, that much ist sure.  Steve might even prefer jikes over Sun's javac 8-)\n\nIt would be rather easy to say we use gcj if we detect we are running in libgcj.\nOr jvc when running in Microsoft's VM.\n\nWhat would be the best fit if we know Ant is running in Kaffe?\n", "id": 72779, "time": "2005-03-24T11:48:48Z", "bug_id": 34138, "creation_time": "2005-03-24T11:48:48Z", "is_private": false, "attachment_id": null}, {"count": 3, "tags": [], "text": "I dont think we should try and be clever and automatically do the right thing,\nas that can generate bad support calls. Example: javac & jikes pull in classes\nto compile on demand, kjc doesnt. If I write a build file that relys on this, it\nwill fail on kjc machines; the author of the build file gets a non-replicable\nsupport call. But if the runner of the failing build file had to set some switch\nto use kjc, they should know that and provide the info, maybe even a fix.\n\nBetter to make it easier for anyone to override the compiler, even if the author\nof the build file neglected any way to make this easy.\n\nAnd yes, jikes is my compiler of choice, 'cept for fancy Java1.5 stuff, and as\nsoon as jikes does templates, I move back there too.\n", "is_private": false, "id": 72783, "creator": "stevel@apache.org", "time": "2005-03-24T14:36:29Z", "bug_id": 34138, "creation_time": "2005-03-24T14:36:29Z", "attachment_id": null}, {"count": 4, "tags": [], "creator": "robilad@yahoo.com", "attachment_id": null, "id": 72803, "time": "2005-03-24T19:58:52Z", "bug_id": 34138, "creation_time": "2005-03-24T19:58:52Z", "is_private": false, "text": "thanks for the good, fast, catch steve! I had (conveniently :) forgotten about\nthe greedy/non-greedy compiler issues, that would crop up. :(\n\nOf course, there is another (enhancement-grade) fix: let's make the Depend task\ncompute the dependencies that need to be rebuilt, and pass them to the compiler.\n\nOn the other hand, different versions of compilers may have different dependency\nresolution algorithms (I believe I recall Jikes switched around a bit in the\nearly years), and that could lead to non-replicable support calls as well, if\nthe 'ant computed' and 'my compiler does this' dependency graphs don't match :(\n\nSo, I am still a bit uncertain how to make ant work well out of the box in the\n'best' way, without causing you headache with moving entry points and similar\nnonsense. Is the 'pre-set build.compiler' approach reasonable? In particular as\nKaffe is likely to switch compilers around some more in the future (possibly\nback to kjc for generics, and then possibly to gcjx for more generics, and\nbetter gcj integration).\n\ncheers,\ndalibor topic"}, {"count": 5, "tags": [], "bug_id": 34138, "is_private": false, "id": 72807, "attachment_id": null, "creator": "stevel@apache.org", "creation_time": "2005-03-24T23:36:25Z", "time": "2005-03-24T23:36:25Z", "text": "TO be honest, we dont get any complaints about kaffe's non greediness, except at\nbootstrap time, because we the shell scripts that boot ant arent kaffe-friendly.\nyou cant boot ant with kaffe, and its not something anyone is (currently)\nmotivated to fix.\n\nWe get a lot more complains about \"ant compiled files I excluded\", \"javac\nfilesets broken\", etc, etc, with compilers pulling in files that are needed, but\nexplicitly excluded. IMO, forced inclusion might actually be a good thing all\nround, as it stops you accidentally importing app.view.* into app.model.* and so\nbreak layering rules. \n\nI guess tomcat is a special issue, because it uses ant for javac, but isnt your\nnormal build file. other things may be similar (eg Axis).\n\nThis leads me to another thought. Could we have a new compiler adapter\n\"best-effort\" that does the right thing, perhaps with an ordered list of\npreferred tools: apt,modern javac, classic javac, jikes, kjc, ... ). So if\ntomcat and axis ask for the  best-effort compiler they get whatever is around,\nnot just classic javac.\n\nSo we would be putting the smartness into ant, but hiding it in a compiler\nadapter that could be switched in or out."}, {"count": 6, "tags": [], "bug_id": 34138, "is_private": false, "id": 74289, "attachment_id": null, "creator": "fitzsim@redhat.com", "creation_time": "2005-04-29T20:45:36Z", "time": "2005-04-29T20:45:36Z", "text": "I satisfied Ant's requirements in java-gcj-compat by using the Eclipse Compiler\nfor Java (which is very similar in behaviour to Sun's javac) and creating a\ntools.jar that contains a com.sun.tools.javac.Main wrapper around ecj. \nUnfortunately this class is not publicly-specified, so it's not really\nappropriate for inclusion in free runtimes.\n\nLong term, I'd like to see all free runtimes agree on a standard package for\nin-process tools instantiation.  For example, in GNU Classpath we could create a\ngnu.tools package and have all free runtime installations agree to implement\nthat.  Included in the specification of gnu.tools would be the behavior\ncharateristics that Ant expects of a Java compiler.\n\nIn the short term this would be one extra code path in ant's decision making\nprocess.  In the long term, I would hope that all free compilers aspire to match\nthe capabilities of Sun's javac, and in doing so eliminate the behavioral\ndifferences that Ant currently has to negotiate.\n"}]