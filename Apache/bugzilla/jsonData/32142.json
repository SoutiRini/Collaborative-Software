[{"count": 0, "text": "Add support for external public IDs and provide a new protocol such\nthat external system IDs may resolve to resources found in Ant's\nclasspath.\n\nPublic External IDs:\n--------------------\n\nThe project helper has been modified to accept a Jar service that\nprovides Ant's entity resolver.  Anyone wishing to provide a set of\nshared resources may extend the Ant entity resolver implementation to\nmap their custom public IDs to their resourses.  The details of how\nthe mapping is implemented is entirely deferred to the user.  One\npossible implementation puts all of the shared resources and the\nentity resolver service within the same jar file.  Deployment of these\nresources is then simply a matter of copying the jar file into Ant's\nclass path.\nPro: Public IDs can be mapped to any input stream.  Consequently, the\n     referenced resources may be deployed locally, to a common server,\n     or any combination thereof.\nCon: The entity resolver is deployed into the Ant installation so the\n     resolver must be shared by all projects built by that Ant\n     installation.\n\n\nSystem External IDs:\n--------------------\n\nThe Java URL framework provides for extensions based upon new protocol\nnames (i.e. ftp, http, file).  The introduction of the 'resource'\nprotocol provides for a URL similar to the jar protocol.  The\ndifference is that the 'resource' protocol does not require naming the\nactual jar file.  Therefore, the URL resource:foo/bar.ext is\nfunctionally equivalent to calling\nLoaderUtils.getContextClassLoader().getResourceAsStream(\"foo/bar.ext\").\nPro: Any number of jar files can be deployed to the ant classloader so\n     long as each uniquely scopes it own resource names.\nCon: All of the resources must be deployed into the Ant class path.\n\n\nJustification\n-------------\nThe rationale for these changes basically reflects on the fact that I\nuse Ant to manage a growing number of independent projects.  When I\nfirst started using Ant, my build scripts were quite simple.  With\neach new project, new features were added until I had a\nparameter-driven script that could easily be customized to most of my\nprojects.  The only problem was that I also had numerous older\nversions of the script associated with various legacy projects.  What\nwas obviously needed was a way to re-use large parts of a build script\nacross multiple projects.  So I moved most of my latest script into a\nshared file that I then included into each projects script.  An\nexample being:\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE project [\n<!ENTITY standard_rules SYSTEM \"file:../../rules.xml\">\n]>\n\n<project basedir=\".\" default=\"all\" name=\"Build this project\">\n  &standard_rules;\n</project>\n\nThis worked very well except that the relative path in the external\nentity declaration was a problem when I tried to clone an existing\nproject to a new location.  I then switched to using absolute paths in\nthe URLs but that was a problem for co-workers who used the same\nproject but didn't share my directory structures.  What was needed was\nan abstraction layer to hide the physical location of the shared\nresource from all of the scripts using it.\n\nThe two solutions where then identified, developed, and deployed to\nour local copy of Ant 1.5.  They have since been re-implemented for\nAnt 1.7.\n\nThe attached zip file contains:\n  All source to implement both solutions.\n  A new JDK1.3 service loader utility.\n  New unit tests to validate the new features.\n  Updates for the manual to document the new features.", "bug_id": 32142, "attachment_id": null, "id": 66654, "time": "2004-11-10T06:08:59Z", "creator": "kevin.greiner@compsol.cc", "creation_time": "2004-11-10T06:08:59Z", "tags": [], "is_private": false}, {"count": 1, "tags": [], "bug_id": 32142, "is_private": false, "text": "Created attachment 13368\nInstall using 'patch -p 0 -i patch.txt' in ant directory", "id": 66655, "time": "2004-11-10T06:10:15Z", "creator": "kevin.greiner@compsol.cc", "creation_time": "2004-11-10T06:10:15Z", "attachment_id": 13368}, {"count": 2, "text": "Why don\u00b4t you use <import>?", "bug_id": 32142, "attachment_id": null, "id": 66659, "time": "2004-11-10T08:41:37Z", "creator": "jan@materne.de", "creation_time": "2004-11-10T08:41:37Z", "tags": [], "is_private": false}, {"count": 3, "text": "I didn't use the import task for the following reasons:\n1) It uses a file path rather than a URL to identify the contents.  Right now,\nI'm actually packaging and distributing my shared files as a jar.  That makes it\neasy to think of the shared code as a single unit (which is how it was tested).\n2) Entities give me complete control over where they are inserted into my build\nfile.  As I understand it from various emails, the contents of an import task is\nappended to the input stream even though the import task may appear at the\nbeginning of the stream.\n", "bug_id": 32142, "attachment_id": null, "id": 66668, "time": "2004-11-10T12:46:06Z", "creator": "kevin.greiner@compsol.cc", "creation_time": "2004-11-10T12:46:06Z", "tags": [], "is_private": false}, {"count": 4, "text": "patching import to handle URI paths might be interesting, especially for that\nin-JAR use. It would complicate the model of knowing where things are; entity\nimports are less complex there as they are at the place of their inclusion.\n\nnote that <taskdef> does work in jars, and that now lets you import declarations of \n-tasks and types\n-macros and presets\n-scripts\nand anything else of a type that is allowed (extends AntlibDefinition)\n\n-steve", "creator": "stevel@apache.org", "is_private": false, "id": 66670, "time": "2004-11-10T13:28:37Z", "bug_id": 32142, "creation_time": "2004-11-10T13:28:37Z", "tags": [], "attachment_id": null}, {"count": 5, "tags": [], "bug_id": 32142, "is_private": false, "text": "Right, I spent a good deal of time considering whether antlib provided an\nalternative implementation.  I finally decided that they are orthoginal.  The\nmain point being that this patch simply provides streams to a wider range of\nURLs.  I use it to define external entities.  Other people may use those URLs\nwith any task that accepts a URL.\n\nI also thought that it would be interesting to modify import to accept a URL. \nIt's essentially a free-be as all that is needed is to add an new attribute to\nthe task and then open the URL provided by that attribute.\n\nAnother interesting idea is that if you embed Ant into another product, then\nthat product could provide an EntityResolver that resolves a set of public\nentity Ids.  If your ant task uses one of these Ids as a URL, you'd get a stream\nthat connects to the encapsulating product rather than a physical file.\n\nKevin\n\n", "id": 66698, "time": "2004-11-11T03:16:58Z", "creator": "kevin.greiner@compsol.cc", "creation_time": "2004-11-11T03:16:58Z", "attachment_id": null}]