[{"count": 0, "tags": [], "creator": "simone.bordet@gmail.com", "attachment_id": null, "id": 172438, "time": "2014-01-17T08:41:13Z", "bug_id": 56026, "creation_time": "2014-01-17T08:41:13Z", "is_private": false, "text": "If an application calls RemoteEndpoint.Async#sendText(String, SendHandler) concurrently from 2 (or more) threads, it gets the stack trace below.\n\nApplications should not worry about synchronizing or queuing concurrent calls to Async.sendText() (or similar methods).\n\nA simple chat application with 3 users chatting will result in concurrent calls to Async.sendText() when A and B both send a message that must be delivered to C, so the use case is pretty common.\n\nHaving application worry about synchronizing or queuing concurrent calls to Async.sendText() will put a huge burden to applications that perform concurrent writes, and I believe this was not the intent of JSR 356 (although the specification does not say anything about concurrency guarantees).\n\nThanks !\n\n~~~~~~~~\n\n2014-01-17 09:28:30,732 pool-1-thread-12 [ WARN][WebSocketTransport] \njava.lang.IllegalStateException: The remote endpoint was in state [TEXT_FULL_WRITING] which is an invalid state for called method\n\tat org.apache.tomcat.websocket.WsRemoteEndpointImplBase$StateMachine.checkState(WsRemoteEndpointImplBase.java:1049)\n\tat org.apache.tomcat.websocket.WsRemoteEndpointImplBase$StateMachine.textStart(WsRemoteEndpointImplBase.java:1012)\n\tat org.apache.tomcat.websocket.WsRemoteEndpointImplBase.sendStringByCompletion(WsRemoteEndpointImplBase.java:174)\n\tat org.apache.tomcat.websocket.WsRemoteEndpointAsync.sendText(WsRemoteEndpointAsync.java:47)"}, {"count": 1, "text": "I have some sympathy with this view. Given that the Javadoc for RemoteEndpoint.Basic explicitly states that concurrent attempts to send messages are not allowed and the Javadoc for RemoteEndpoint.Async doesn't, you'd be forgiven for thinking that meant that RemoteEndpoint.Async permitted concurrent attempts to send messages.\n\nUnfortunately, the (not very well documented) intention of the WebSocket EG was not to allow concurrent attempts to send messages. [1]\n\nI did take a quick look at adding an option to relax (i.e. ignoring) this but the change required to do this with the current Tomcat code would be far from trivial.\n\nI'm marking this as INVALID since the intention of the EG was to not allow this but WONTFIX is almost as appropriate if this is viewed as an enhancement request.\n\nAs an aside, one reason not to implement this particular enhancement is that apps that depended on it would not be portable between containers.\n\n[1] https://java.net/projects/websocket-spec/lists/jsr356-experts/archive/2013-02/message/1", "bug_id": 56026, "is_private": false, "id": 172445, "time": "2014-01-17T12:48:02Z", "creator": "markt@apache.org", "creation_time": "2014-01-17T12:48:02Z", "tags": [], "attachment_id": null}, {"count": 2, "tags": [], "bug_id": 56026, "attachment_id": null, "text": "Mark, thanks for your comments.\n\nI am frankly surprised that an expert group states that:\n\n\"[async writes] should not be permitted and an IllegalStateException be thrown.\nMy reasoning for this is that was allowed it would open up all sorts of\nbuffering requirements for the container that could get tricky to manage.\"\n\nNow those sorts of tricky buffering requirements must be managed by the application, with almost 100% chance that average joe websocket get them wrong.\nFor a simple chat application, an application developer must manage the buffering and possibly stack overflows due to callback invocations.\n\nContainers should solve those problems on behalf of the application writers, otherwise one could say that transaction management or ORM mapping are too tricky to manage and better left to JEE application writers.\n\nI hope you can change your mind on this issue :)\n\nI see this problem as a lack of detail in the specification rather than a real intent to put burden onto application developer's shoulders.\n\nThanks!", "id": 172446, "time": "2014-01-17T13:18:53Z", "creator": "simone.bordet@gmail.com", "creation_time": "2014-01-17T13:18:53Z", "is_private": false}, {"count": 3, "tags": [], "bug_id": 56026, "attachment_id": null, "is_private": false, "id": 172447, "time": "2014-01-17T13:28:41Z", "creator": "simone.bordet@gmail.com", "creation_time": "2014-01-17T13:28:41Z", "text": "Remy, can I have a comment from you too, since you re-closed this issue as invalid ?\n\nThanks!"}, {"count": 4, "tags": [], "creator": "remm@apache.org", "attachment_id": null, "id": 172450, "time": "2014-01-17T13:58:58Z", "bug_id": 56026, "creation_time": "2014-01-17T13:58:58Z", "is_private": false, "text": "Feedback and comments on the specification should be sent to the Websockets EG."}, {"count": 5, "tags": [], "creator": "kpreisser@apache.org", "attachment_id": null, "id": 172451, "time": "2014-01-17T14:08:44Z", "bug_id": 56026, "creation_time": "2014-01-17T14:08:44Z", "is_private": false, "text": "Hi Simone,\n\n(In reply to Simone Bordet from comment #2)\n> Mark, thanks for your comments.\n> \n> I am frankly surprised that an expert group states that:\n> \n> \"[async writes] should not be permitted and an IllegalStateException be\n> thrown.\n> My reasoning for this is that was allowed it would open up all sorts of\n> buffering requirements for the container that could get tricky to manage.\"\n> \n> Now those sorts of tricky buffering requirements must be managed by the\n> application, with almost 100% chance that average joe websocket get them\n> wrong.\n> For a simple chat application, an application developer must manage the\n> buffering and possibly stack overflows due to callback invocations.\n\nI'm not a Tomcat developer, but I have written a WebSocket example for Tomcat (\"Drawboard\") which uses the RemoteEndpoint.Async to send messages asynchronously.\n\nMark said the Javadoc of Async does not explicitely state that concurrent calls to this method are not allowed, but from a user's point of view, I would expect methods like Async#sendText(String, SendHandler) not to be callable until the previous Async operation has completed (when the SendHandler is invoked).\n\nStackOverflows due to Callbacks should not be possible as the SendHandler method is required to always be called from a different thread than the one that initiated the send - see bug 55715.\n\nCan you go into details with what you mean with \"tricky buffering requirements\"? For example, at the drawboard, I used a very simple buffering mechanism to ensure that concurrent send operations are serialized to the client, by using a LinkedList that stores messages that have yet to be sent to the client (and a bit synchronization).\n\n\n> \n> Containers should solve those problems on behalf of the application writers,\n> otherwise one could say that transaction management or ORM mapping are too\n> tricky to manage and better left to JEE application writers.\n> \n> I hope you can change your mind on this issue :)\n> \n> I see this problem as a lack of detail in the specification rather than a\n> real intent to put burden onto application developer's shoulders.\n> \n> Thanks!"}, {"count": 6, "tags": [], "bug_id": 56026, "attachment_id": null, "text": "Konstantin, thanks for your comments.\n\nThe \"tricky buffering requirements\" is actually a quote from the expert group.\n\nGiven how simply you have implemented these \"tricky buffering requirements\", it is even more surprising that this burden has been put by the EG onto the shoulders of application developers, while it could have been on the container's.\n\nThat is why I was hoping that this choice in Tomcat could have been reconsidered.\n\nAfter all, there is nothing in the specification that forbids an implementation to do this buffering, and this will - like Mark noted - make applications not portable (which is what happened to me - that's why I reported the bug).\n\nI'd prefer the container do the buffering for application developers, rather than having the application hardcode the buffering because the container implementers can perform optimizations or configure different policies for this buffering, easing up the job for application developers.\n\nThanks!", "id": 172452, "time": "2014-01-17T14:39:39Z", "creator": "simone.bordet@gmail.com", "creation_time": "2014-01-17T14:39:39Z", "is_private": false}, {"count": 7, "text": "You are equating the complexity of implementing buffering for a single application with known constraints and the complexity of implementing a general buffering solution appropriate for all applications where the constraints are unknown. They are not equivalent.", "bug_id": 56026, "is_private": false, "id": 172453, "time": "2014-01-17T15:22:22Z", "creator": "markt@apache.org", "creation_time": "2014-01-17T15:22:22Z", "tags": [], "attachment_id": null}, {"count": 8, "text": "(In reply to Mark Thomas from comment #1)\n> I have some sympathy with this view. Given that the Javadoc for\n> RemoteEndpoint.Basic explicitly states that concurrent attempts to send\n> messages are not allowed and the Javadoc for RemoteEndpoint.Async doesn't,\n> you'd be forgiven for thinking that meant that RemoteEndpoint.Async\n> permitted concurrent attempts to send messages.\n> \n> Unfortunately, the (not very well documented) intention of the WebSocket EG\n> was not to allow concurrent attempts to send messages. [1]\n\nWould it be worth updating the Javadoc to make this restriction explicit?", "bug_id": 56026, "is_private": false, "id": 172469, "time": "2014-01-17T20:08:05Z", "creator": "sebb@apache.org", "creation_time": "2014-01-17T20:08:05Z", "tags": [], "attachment_id": null}, {"count": 9, "text": "(In reply to Sebb from comment #8)\n> Would it be worth updating the Javadoc to make this restriction explicit?\n\nWould not that require a maintenance review of the specification via the JCP, since Javadocs are considered so ?\n\nAlso, other implementations may not have the need to have this restriction.", "bug_id": 56026, "attachment_id": null, "id": 172470, "time": "2014-01-17T20:44:23Z", "creator": "simone.bordet@gmail.com", "creation_time": "2014-01-17T20:44:23Z", "tags": [], "is_private": false}, {"count": 10, "tags": [], "creator": "mthornton@optrak.com", "attachment_id": null, "id": 174810, "time": "2014-04-23T14:24:59Z", "bug_id": 56026, "creation_time": "2014-04-23T14:24:59Z", "is_private": false, "text": "It may be worth noting that the Tyrus 1.5 implementation does appear to be thread safe. Even arbitrary mixtures of Basic and Async sends work as one might expect: all messages are delivered without error Jetty, on the other hand, behaves in the same way as Tomcat."}, {"count": 11, "tags": [], "creator": "mthornton@optrak.com", "attachment_id": null, "id": 174811, "time": "2014-04-23T14:38:03Z", "bug_id": 56026, "creation_time": "2014-04-23T14:38:03Z", "is_private": false, "text": "Some emails amongst the expert group doesn't constitute information of which users could be expected to be aware. Is this really the only place that the intent is described?"}, {"count": 12, "tags": [], "creator": "balusc@gmail.com", "attachment_id": null, "id": 191527, "time": "2016-06-10T14:33:58Z", "bug_id": 56026, "creation_time": "2016-06-10T14:33:58Z", "is_private": false, "text": "Just in case, I investigated this issue for JSF <f:websocket> and OmniFaces <o:socket> too. This threadsafety problem doesn't occur on Jetty, Undertow (WildFly) nor Tyrus (GlassFish/Payara). It occurs on Tomcat only.\n\nWork around was to synchronize session:\n\n    synchronized (session) {\n        results.add(session.getAsyncRemote().sendText(text));\n    }\n\nFrankly, this kind of contradicts the javax.websocket.Session javadoc http://docs.oracle.com/javaee/7/api/javax/websocket/Session.html:\n\n> Session objects may be called by multiple threads. Implementations must ensure the integrity of the mutable properties of the session under such circumstances."}, {"count": 13, "tags": [], "creator": "jywxoppb@emltmp.com", "attachment_id": null, "id": 191873, "time": "2016-06-21T17:10:35Z", "bug_id": 56026, "creation_time": "2016-06-21T17:10:35Z", "is_private": false, "text": "I've ran into this issue too and I must say that although tomcat's current behavior doesn't directly contradict the standard, it's very unexpected and goes against simple common sense. This is an async call, and Session must be thread safe according to the spec. I can accept that there could be some uncertainty if one mixes sync and async sends, especially in partial messages, but if all calls are async this *really* should never happen. \n\nWhat's worse, as others have mentioned, this goes against what other implementations are doing without as much as documenting this behavior. Neither \"Session\"'s nor \"RemoteEndpoint.Async\"'s Javadoc have anything to say about thread safety or specifically the lack thereof.\n\nDoes the race condition occur only during the call to sendText()/sendBinary()? i.e. Would synchronizing such calls on the session object (as balusc suggested) solve 100% of these cases?"}, {"count": 14, "text": "synchronizing on session as suggested doesn't appear to be sufficient to prevent the IllegalStateException, although it may help reduce the frequency. How is an API that can't be successfully used not broken?", "bug_id": 56026, "attachment_id": null, "id": 199297, "time": "2017-06-20T16:02:52Z", "creator": "jonathaz@gmail.com", "creation_time": "2017-06-20T16:02:52Z", "tags": [], "is_private": false}, {"count": 15, "tags": [], "creator": "markt@apache.org", "attachment_id": null, "id": 199326, "time": "2017-06-21T21:56:38Z", "bug_id": 56026, "creation_time": "2017-06-21T21:56:38Z", "is_private": false, "text": "You'll have to take up your concerns over the API with the WebSocket EG. Although given there has been no WebSocket activity at all for Java EE 8 that might be a slow process.\n\nTomcat's starting position is always going to be implementing the spec. Where there are ambiguities then the following priority order of sources is usually followed:\n- what is in the spec document\n- what is in the Javadoc\n- what was discussed by the EG\n\nNo, this isn't ideal but it is the best we have.\n\nThis isn't the first instance of a Java EE spec doing something that the user community thinks is just plain wrong. The coercion rules for EL comes to mind as an obvious example.\n\nWhat we have done in the past is to add on option to enable the desired behaviour. Depending on circumstances the option may be a system property (applies to all web apps) or per web app. The default behaviour also varies.\n\nIt is worth noting that in the thread that is no longer accessible from the java.net (and I can't find a new location) I also mentioned that some refactoring had made implementing this a lot easier in Tomcat. What hasn't changed is that a number of questions remain open such as how many messages to accept before starting to reject them?\n\nIf there is interest, I suggest re-opening this issue as an enhancement request to  optionally enable the desired behaviour. I'll note that enhancement requests with patches tend to get looked faster than those without."}]