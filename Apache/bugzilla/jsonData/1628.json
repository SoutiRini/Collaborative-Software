[{"count": 0, "tags": [], "text": "In ServletWrapper.handleReload, there is a syncronization problem.  If tomcat \nus under a load and a servlet class file or jsp is updated, there is a \npotential for multiple request to try and reload the servlet simultaneously and \nstep on each other causing a bad state.  The way it is currently coded, we've \nseen cases where when a class is updated, the first thread through checks to \nsee if a reload needs to take place and starts the destroy.  The next thread \ncomes in and also thinks it is supposed to do a reload and starts down the same \nbranch.  Meanwhile, the first thread continues and creates the new loader \n(loader.reload) and finishes handleReload (including setting servlet=null and \nservletClass=null).  The second thread then continues it's processing, and gets \nto creates a new loader.  While the second thread is creating the new loader, \nthe first thread runs the Handler.service method which runs the \nServletWrapper.init method which calls loadServlet where servlet and \nservletClass are set appropriately, and eventually calls ServletWrapper.doInit \nwhich sets initialized to true.  Then the second thread continues and nulls out \nservlet and servletClass, but since initialized is true, it doesn't run the \ninit method and from then on you get a null pointer exception trying to access \nthat particular servlet.  \n\nI've even tried just moving the lines that null out servlet and servletClass up \nto right after where initialized is set to false, but this causes another \nproblem where the first thread creates a new loader and calls loadServlet, then \nthe second thread creates a new loader but the servlet isn't reinitialized \n(since it doesn't need to be) and so the loader doesn't have it cached and \nalways reports false when its shouldReload method is called.  This means that  \nthe servlet never really gets reloaded because the loader doesn't have it \ncached.\n\nAnyways, attached is a patch that fixes this problem.  I synchronized before I \ncall load.shouldReload so that only the first thread will actually call \nloader.reload with subsequent threads getting a false back from the new loader \nso that they don't also try and create a new loader or null out the class \nvariables.  I've tested this on Windoze (Win2K) and NetWare against the Tomcat \nHTTP handler and via Apache/Tomcat.  It does slow performance during the \nactually reload, but is minimal otherwise and if the context is set to not \nreload, the syncronized call is bypassed altogether.  I would like to get this \nin to 3.2.2 if at all possible since it does affect us heavily in our \ndevelopment and testing on NetWare.  Even though the diff seems large, all that \nwas added was the synchronized call (and it's preceding comment).  The rest of \nthe differences are just indenting the existing code.\n\nPATCH\nIndex: ServletWrapper.java\n===================================================================\nRCS file: /home/cvspublic/jakarta-\ntomcat/src/share/org/apache/tomcat/core/Attic/ServletWrapper.java,v\nretrieving revision 1.60.2.5\ndiff -u -r1.60.2.5 ServletWrapper.java\n--- ServletWrapper.java\t2001/01/12 04:39:05\t1.60.2.5\n+++ ServletWrapper.java\t2001/05/02 22:42:27\n@@ -422,38 +422,44 @@\n \tif( isReloadable ) {// && ! \"invoker\".equals( getServletName())) {\n \t    ServletLoader loader=context.getServletLoader();\n \t    if( loader!=null) {\n-\t\t// XXX no need to check after we remove the old loader\n-\t\tif( loader.shouldReload() ) {\n-\t\t    // workaround for destroy \n-\t\t    try {\n-\t\t\tdestroy();\n-\t\t    } catch(Exception ex ) {\n-\t\t\tcontext.log( \"Error in destroy \", ex );\n-\t\t    }\n-\t\t    initialized=false;\n-\t\t    loader.reload();\n-\t\t    \n-\t\t    ContextManager cm=context.getContextManager();\n-\t\t    cm.doReload( req, context );\n-\t\t    \n-\t\t    servlet=null;\n-\t\t    servletClass=null;\n-\t\t    /* Initial attempt to shut down the context and sessions.\n-\t\t       \n-\t\t       String path=context.getPath();\n-\t\t       String docBase=context.getDocBase();\n-\t\t       // XXX all other properties need to be saved\n-\t\t       // or something else\n-\t\t       ContextManager cm=context.getContextManager();\n-\t\t       cm.removeContext(path);\n-\t\t       Context ctx=new Context();\n-\t\t       ctx.setPath( path );\n-\t\t       ctx.setDocBase( docBase );\n-\t\t       cm.addContext( ctx );\n-\t\t       context=ctx;\n-\t\t       // XXX shut down context, remove sessions, etc\n-\t\t    */\n-\t\t}\n+                // We need to syncronize here so that multiple threads don't\n+                // try and reload the class.  The first thread through will\n+                // create the new loader which will make shouldReload return\n+                // false for subsequent threads.\n+                synchronized(this) {\n+                    // XXX no need to check after we remove the old loader\n+                    if( loader.shouldReload() ) {\n+                        // workaround for destroy \n+                        try {\n+                            destroy();\n+                        } catch(Exception ex ) {\n+                            context.log( \"Error in destroy \", ex );\n+                        }\n+                        initialized=false;\n+                        loader.reload();\n+                        \n+                        ContextManager cm=context.getContextManager();\n+                        cm.doReload( req, context );\n+                        \n+                        servlet=null;\n+                        servletClass=null;\n+                        /* Initial attempt to shut down the context and \nsessions.\n+                           \n+                           String path=context.getPath();\n+                           String docBase=context.getDocBase();\n+                           // XXX all other properties need to be saved\n+                           // or something else\n+                           ContextManager cm=context.getContextManager();\n+                           cm.removeContext(path);\n+                           Context ctx=new Context();\n+                           ctx.setPath( path );\n+                           ctx.setDocBase( docBase );\n+                           cm.addContext( ctx );\n+                           context=ctx;\n+                           // XXX shut down context, remove sessions, etc\n+                        */\n+                    }\n+                }\n \t    }\n \t}\n     }", "is_private": false, "bug_id": 1628, "id": 2265, "time": "2001-05-04T15:59:04Z", "creator": "mmanders@novell.com", "creation_time": "2001-05-04T15:59:04Z", "attachment_id": null}]