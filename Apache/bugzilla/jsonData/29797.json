[{"attachment_id": null, "tags": [], "creator": "debic@epiphany.com", "text": "This is an enhancment request that should help folks who use Ant from their own\nJava applications. My example is simple: I have written a build java application\nthat uses Ant to drive the build portion of the build but uses java servlets to\ndrive other important build related processes that are important for my users. \n\nIn all previous versions of Ant, including Ant 1.5.x we copied the Main.java\nclass into an AntMain.java replaced system.exit(0)'s with returns and called\nthis class from our application. It works perfectly for us. We get to see all\nthe exceptions etc. \n\nSo my enhancement request here is to formalize a way to call java from other\njava apps (asumming that anything passed by the command line can be passed as\nwell) and make this an integral part of future releases. It means a lot to\ndevelopers like myself who like the tight integration this method provides,\nespecially the possibility to handle any exceptions that could possibly occur\nwhile running Ant build files.\n\nPlease feel free to contact me for any additional details at the cc email\nprovided with the req.", "count": 0, "id": 59859, "time": "2004-06-25T04:25:09Z", "bug_id": 29797, "creation_time": "2004-06-25T04:25:09Z", "is_private": false}, {"count": 1, "tags": [], "creator": "stevel@apache.org", "attachment_id": null, "id": 73163, "time": "2005-03-31T23:51:50Z", "bug_id": 29797, "creation_time": "2005-03-31T23:51:50Z", "is_private": false, "text": "hmmm.\n\nAnt is fairly well designed to be used from other apps, because even though Main\ncalls system.Exit(), it is the only place that does so. instead it provides a\ndetailed and stable API For low level project, task manipulation. \n\nHave a look at the \"Using tasks outside of Ant\" bit of the manual, to see these.\n\nIs the API that is introduced there not sufficient?"}, {"count": 2, "text": "Yes, the API is insufficient. Ant main should not do a System.exit(). I\nunderstand that nowdays it is not recommended to embed Ant into other\napplications by doing a call to Ant main directly because of unexpected behavior\nthat may result if one does so. See -\nhttp://www.manning-sandbox.com/thread.jspa?threadID=7567&tstart=45\n\nHowever let me argue for a design change then.\n\nAnt is a great piece of software that does an exceptionally good job as a build\ntool and make replacement. That being said, the world of software development is\nmuch more complex these days and folks who run production builds at some of the\ntop software comapnies need more than just a build tool. The solution is usually\none of the two, wrtite your own build system app or use a third party system,\nsomething like AntHill or Luntbuild. Such an application usually integrates\nseveral important build cycle aspects.\n\nNow the reason I selected Ant several years ago is that I knew I will need to\nwrite such an app beyond Ant (that drives and schedules builds on sveeral\ndifferent OS's at the same time, collects and manages the log files and\nbinaries, does resource house keeping, serializes important results into a\ndatabse and so forth) - the reason was that I wanted to finally move beyone the\nso 'make' world of spawning things and getting exit codes to try to figure out\nwhat went wrong. I created a new class in ant replaced system.exits() with\nreturns and voila I had a sleek way to do builds and see any problems IN DEPTH\nbecuase I could see and handle the exceptions.\n\nI still do this in Ant 1.6.2. but it became a little more involved from the\nsimple change in Ant 1.2. This is why I ask for future development on Ant to\nprovide a supported and documented venue (an API perhaps) on how to run Ant from\na calling java application. I am not interested in running some tasks and I will\nexplain why. \n\nWhen I work with developers our philosophy is if you ant build runs from the\ncommand line it will run from the buidl system as well because this is exactly\nwhat we do. Run the build.xml within the build system the same way ant would do\nfrom the command line. This is extremely important when you pitch sophisticated\nbuild system s to developers. And it's good practice too because you want to\nhave a safe fall back in case something goes wrong with the build system.\nForcing the app to deal with a separate API practically means that you need to\nmaintain 2 different sets of build files this in the end amounts to problems.\n\nOn the other hand you will argue, well just call Ant from your app as an\nexecutable i.e. spawn it. While this is obviously possible, it is a far more\ninferior solution for someone who uses java for his application as he loses the\nfine control and debuging venue that is given to him with a java method call. \n\nI am sure I am not the only one who deoes something like this with Ant, but taht\nbeing said I am sure there's not a bnig number of us out there either. However,\nhaving sauch an entry point to Ant will only work for it's benefit. it's not\nlike we are trying to steal Ant by plugging it into our apps, I don't mind Ant\nbanners or if you want to put them into logs and output. But I think it's better\nthat you guys maintain a System.exit()less entry point for those of use who want\nto use Ant this way rather then us 'fixing' Ant every time a new release comes out.\n\nFor some screen shots of the build App visit:\nhttp://debic.net/backstage/SuSE_gifs/\n\nThank you for considering this request.\nBoris Debic.\nFoster City, CA.", "bug_id": 29797, "is_private": false, "id": 75466, "time": "2005-05-27T00:25:51Z", "creator": "debic@epiphany.com", "creation_time": "2005-05-27T00:25:51Z", "tags": [], "attachment_id": null}, {"count": 3, "tags": [], "text": "Why do you have to \"fix\" Ant every time a new release comes out?  If you\ninstantiate a Project, configure it via ProjectHelper and a File object, and\nexecute the targets you want, that's basically all you have to do.  In other\nwords, you can clone what you need from oata.Main, package that as your own\nentry point to Ant, and it should simply work against new binary Ant distributions.", "attachment_id": null, "bug_id": 29797, "id": 75474, "time": "2005-05-27T00:36:47Z", "creator": "mbenson@apache.org", "creation_time": "2005-05-27T00:36:47Z", "is_private": false}, {"count": 4, "tags": [], "text": "Depending on your environment you may be able to trap the System.exit call.\n\nCheck out SecurityManager.checkExit", "is_private": false, "id": 75476, "creation_time": "2005-05-27T00:55:47Z", "time": "2005-05-27T00:55:47Z", "creator": "carej@us.ibm.com", "bug_id": 29797, "attachment_id": null}, {"count": 5, "tags": [], "bug_id": 29797, "attachment_id": null, "text": "Generally I have found embedding Ant to be feasible but not as simple as it\nprobably could be. There are a number of subtleties you need to figure out. And\nyou cannot use an embedded Ant for certain kinds of unforked <java> if you\nalready have a security manager (bug #34229).", "id": 75478, "time": "2005-05-27T02:33:08Z", "creator": "jglick@apache.org", "creation_time": "2005-05-27T02:33:08Z", "is_private": false}, {"count": 6, "text": "I hear the point of comments #3 and #4 but that's exactly what I am pointing at.\nToday there's no notion that Ant may be emmbedded and as such things can change\nin future releases. I am not contesting whether the solution already exists\ntoday, so it maybe only a documentation point (i.e. How to embed Ant into a Java\nApp). What I am trying to say this use case should be recognized, formalized and\nsupported, this way if things are redesigned in the future the maintainers will\nbe aware of this use case. \n\nAlso whichever method of support is chosen it should work the same way as if\nrunning ant against a build xml file from the command line, so the files used\nfor the embedded app and developer side testing on standalone Ant are the same.\n", "bug_id": 29797, "attachment_id": null, "id": 75480, "time": "2005-05-27T03:01:18Z", "creator": "debic@epiphany.com", "creation_time": "2005-05-27T03:01:18Z", "tags": [], "is_private": false}, {"count": 7, "tags": [], "creator": "mbenson@apache.org", "text": "Jesse, would you (and perhaps Darin) be able to draft up what a\nsmart/easy/versatile point-of-entry should look like?", "id": 75518, "time": "2005-05-27T15:34:53Z", "bug_id": 29797, "creation_time": "2005-05-27T15:34:53Z", "is_private": false, "attachment_id": null}, {"count": 8, "tags": [], "text": "*** Bug 34312 has been marked as a duplicate of this bug. ***", "attachment_id": null, "bug_id": 29797, "id": 75552, "time": "2005-05-28T00:28:46Z", "creator": "mbenson@apache.org", "creation_time": "2005-05-28T00:28:46Z", "is_private": false}, {"attachment_id": null, "tags": [], "creator": "Darin_Swanson@us.ibm.com", "text": "Of course the Eclipse Ant entry point(s) are available for all to see via the \nsource of the Ant Core and Ant UI plugins of Eclipse. See the InternalAntRunner \nclasses.\n\nThat said...we could argue smart and versatile...I would vote against easy :-)\n\nOne of my problems is that I have to maintain entry points that can work \nagainst \"any\" Ant (where any is defined as all Ants released since Eclipse \n1.0...this is my real pain point) and yet still expose the new functionality in \nthe latest Ant release. \nAs well there is the multi levels of configuration from those pesky GUI \nelements :-)", "count": 9, "id": 75558, "time": "2005-05-28T01:33:16Z", "bug_id": 29797, "creation_time": "2005-05-28T01:33:16Z", "is_private": false}, {"count": 10, "tags": [], "text": "Perhaps. The quickest answer I can give offhand is\n\nhttp://www.netbeans.org/source/browse/~checkout~/ant/src/org/apache/tools/ant/module/bridge/BridgeInterface.java\n\nbut there is a lot more to it than that (e.g. input handlers).", "attachment_id": null, "bug_id": 29797, "id": 75568, "time": "2005-05-28T18:00:00Z", "creator": "jglick@apache.org", "creation_time": "2005-05-28T18:00:00Z", "is_private": false}]