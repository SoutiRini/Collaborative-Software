[{"count": 0, "tags": [], "bug_id": 58525, "attachment_id": 33196, "id": 185877, "time": "2015-10-23T09:37:53Z", "creator": "richard.hart@nl.pwc.com", "creation_time": "2015-10-23T09:37:53Z", "is_private": false, "text": "Created attachment 33196\npatch file created with Git.\n\nIf a large number of named cells are used, a great deal of time is spent determining if the name is already used in a given sheet due to looking up the name by looping through an array of names.\n\nThis optimization adds a Map<Integer sheetNumber, Map<String name, NameRecord>> wherever the array of names exists. The NameRecord may be an HSSFName depending on which model is being used.\n\nThe duplicate test in HSSFName.setNameName() uses the map to find a duplicate if one exists rather than looping through the names array.\n\nAs far as I know this does not break any existing functionality. All unit tests executed in the ant build are successful although none of the unit tests have been modified to use the new getName(name, sheetNumber) method. \n\nThis change was prompted by a project that builds a large excel workbook of 58 sheets with about 3000 named cells per sheet. The time required to produce the workbook was 4:47 before the modification and 3:14 after, about a 30% improvement.\n\nThe change is based on poi-3.13. To my knowledge this is a release version.\n\nMy local project is named poi-3.13-pwc. The included patch references that project name."}, {"count": 1, "tags": [], "bug_id": 58525, "attachment_id": null, "text": "It looks like you're maintaining two data structures that contain essentially the same content, a List and a HashMap. In the interest of keeping POI's memory footprint down, would it be possible to use just one data structure? It might even be faster, since write operations wouldn't need to modify 2 data structures.\n\n> public LinkTable(int numberOfSheets, WorkbookRecordList workbookRecordList) {\n>   _workbookRecordList = workbookRecordList;\n>   _definedNames = new ArrayList<NameRecord>();\n>   _nameRecordMap = new HashMap<Integer, Map<String, NameRecord>>();\n>   ...\n>   while(true) {\n>     if (nextClass == NameRecord.class) {\n>       NameRecord nr = (NameRecord)rs.getNext();\n>       _definedNames.add(nr);\n>       addToNamesMap(nr);\n>     }\n>   }\n\n> public void removeBuiltinRecord(byte name, int sheetIndex) {\n>  NameRecord record = getSpecificBuiltinRecord(name, sheetIndex);\n>   if (record != null) {\n>    _definedNames.remove(record);\n>    removeFromNameRecordMap(record);\n>   }\n> }", "id": 185884, "time": "2015-10-23T11:25:07Z", "creator": "onealj@apache.org", "creation_time": "2015-10-23T11:25:07Z", "is_private": false}, {"count": 2, "tags": [], "creator": "richard.hart@nl.pwc.com", "text": "(In reply to Javen ONeal from comment #1)\n> It looks like you're maintaining two data structures that contain\n> essentially the same content, a List and a HashMap. In the interest of\n> keeping POI's memory footprint down, would it be possible to use just one\n> data structure? It might even be faster, since write operations wouldn't\n> need to modify 2 data structures.\n> \n> > public LinkTable(int numberOfSheets, WorkbookRecordList workbookRecordList) {\n> >   _workbookRecordList = workbookRecordList;\n> >   _definedNames = new ArrayList<NameRecord>();\n> >   _nameRecordMap = new HashMap<Integer, Map<String, NameRecord>>();\n> >   ...\n> >   while(true) {\n> >     if (nextClass == NameRecord.class) {\n> >       NameRecord nr = (NameRecord)rs.getNext();\n> >       _definedNames.add(nr);\n> >       addToNamesMap(nr);\n> >     }\n> >   }\n> \n> > public void removeBuiltinRecord(byte name, int sheetIndex) {\n> >  NameRecord record = getSpecificBuiltinRecord(name, sheetIndex);\n> >   if (record != null) {\n> >    _definedNames.remove(record);\n> >    removeFromNameRecordMap(record);\n> >   }\n> > }\n\nIndeed. I first tried to replace the names array with a map but as I got deeper, more and more would have to be changed. The issue is so many methods use the getName(index) method which is not only fast but cannot be done on a map. I did not want to break any existing functionality so I added the map.", "id": 185885, "time": "2015-10-23T11:40:14Z", "bug_id": 58525, "creation_time": "2015-10-23T11:40:14Z", "is_private": false, "attachment_id": null}, {"count": 3, "tags": [], "bug_id": 58525, "attachment_id": null, "text": "If I am not mistaken, the names array also contains names that are empty (\"\") such as when the cell is first created. Giving the cell a name is not required. The map can have only one empty name. So there is a difference between the two stores. The map contains only names whose length > 0.", "id": 185886, "time": "2015-10-23T11:54:48Z", "creator": "richard.hart@nl.pwc.com", "creation_time": "2015-10-23T11:54:48Z", "is_private": false}, {"count": 4, "tags": [], "text": "There might be some off-the-shelf solutions available for this, though the underlying implementation of MultiKeyMap would determine if this saves any memory over maintaining a List and a Map in parallel--at least a hybrid data structure would relieve the developers of touching twice as many data structures and twice as many functions.\nhttps://commons.apache.org/proper/commons-collections/javadocs/api-3.2.1/org/apache/commons/collections/map/MultiKeyMap.html\n\nAlternatively, if the performance hit is small enough, some type of SortedMap/TreeMap/LinkedHashMap might work here:\ngetName(int index) -> map.values().toArray()[index]\n\nIf those suggestions don't work, you could roll your own hybrid data structure to maintain two underlying data structures in parallel. Better encapsulation.\n\n> (In reply to Richard Hart from comment #3)\n> If I am not mistaken, the names array also contains names that are empty\n> (\"\") such as when the cell is first created. Giving the cell a name is not\n> required. The map can have only one empty name. So there is a difference\n> between the two stores. The map contains only names whose length > 0.\n\nHmm.. another wrinkle in the design. Let me think about this problem a bit more. It's starting to sound like a custom-built hybrid data structure will be needed here. Maybe that custom data structure is LinkTable.java.", "attachment_id": null, "id": 185888, "creator": "onealj@apache.org", "time": "2015-10-23T12:05:02Z", "bug_id": 58525, "creation_time": "2015-10-23T12:05:02Z", "is_private": false}]