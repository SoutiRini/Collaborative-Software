[{"count": 0, "tags": [], "bug_id": 45406, "attachment_id": null, "id": 118701, "time": "2008-07-16T03:22:51Z", "creator": "ran.rubinstein@gmail.com", "creation_time": "2008-07-16T03:22:51Z", "is_private": false, "text": "The request URL decoder component is not doing it's job correctly for UTF-16.\n\nURL encoding rules state that URLs are encoded in ASCII, while non-ascii characters and special characters are encoded using the % encoding, using a specified charset. \n\nThe problem is that the UDecode and ByteChunk classes used to decode request URLs in catalina do not work according to these rules:\n\nUDecode converts all the % encodings to bytes, and then ByteChunk.toString converts the whole buffer to a string according to the specified encoding.\n\nSo, a UTF-16-encoded URL that looks like this:\n\nhttp://a.com?utf16parameter=%D%7\n\nwhich is decoded properly with java's URLDecoder.decode() method, is not decoded properly by catalina, since the characters 'http://a.com?utf16parameter=' are not UTF-16 characters. UDecode convert %D%7 to bytes, but then ByteChunk chokes when trying to decode the whole string as UTF-16, while %D%7 are the only bytes it should have attempted to decode.\n\nDon't tell me to use UTF-8 in my pages so that the browsers will use UTF-8 to encode, I'm in a situation where this is impossible."}, {"count": 1, "tags": [], "creator": "wrowe@apache.org", "attachment_id": null, "id": 118705, "time": "2008-07-16T06:14:40Z", "bug_id": 45406, "creation_time": "2008-07-16T06:14:40Z", "is_private": false, "text": "If you are literally correct below in your observation, the request should\nreturn 400 invalid, because %D%7 is not valid.  2 hex digits are mandatory.\n"}, {"count": 2, "tags": [], "text": "(In reply to comment #1)\n> If you are literally correct below in your observation, the request should\n> return 400 invalid, because %D%7 is not valid.  2 hex digits are mandatory.\n> \n\nYou are correct, in the text, replace %D%7 with %D7%05. The correct URL is http://a.com?utf16parameter=%D7%05\n\n%D7%05 is the hebrew letter 'het' encoded in UTF-16LE.\n\n\n\n", "attachment_id": null, "bug_id": 45406, "id": 118706, "time": "2008-07-16T06:20:16Z", "creator": "ran.rubinstein@gmail.com", "creation_time": "2008-07-16T06:20:16Z", "is_private": false}, {"count": 3, "tags": [], "creator": "wrowe@apache.org", "attachment_id": null, "id": 118708, "time": "2008-07-16T06:30:55Z", "bug_id": 45406, "creation_time": "2008-07-16T06:30:55Z", "is_private": false, "text": "Marking Invalid.\n\nYou aren't able to use utf-16 or ucs-2.  Period.\n\nThe RFC2616 protocol clearly declares the input stream to be an ASCII superset\nstream of otherwise opaque octets.  You can use any representation which is a \nsuperset of ASCII and work out what character set you expect, such as UTF-8 or \nISO-8859-{any}.\n\nThe %xx syntax clearly defines one byte, and cannot express half a wchar.  If\nyou wish to interpret the bytestream in this way, you will have to recombine\nthem, but this would be ill advised, as \"your protocol\" can't necessarily be\nproxied at all.\n"}, {"count": 4, "tags": [], "creator": "ran.rubinstein@gmail.com", "is_private": false, "id": 118710, "attachment_id": null, "bug_id": 45406, "creation_time": "2008-07-16T06:57:15Z", "time": "2008-07-16T06:57:15Z", "text": "(In reply to comment #3)\n> Marking Invalid.\n> \n> You aren't able to use utf-16 or ucs-2.  Period.\n> \n> The RFC2616 protocol clearly declares the input stream to be an ASCII superset\n> stream of otherwise opaque octets.  You can use any representation which is a \n> superset of ASCII and work out what character set you expect, such as UTF-8 or \n> ISO-8859-{any}.\n> \n> The %xx syntax clearly defines one byte, and cannot express half a wchar.  If\n> you wish to interpret the bytestream in this way, you will have to recombine\n> them, but this would be ill advised, as \"your protocol\" can't necessarily be\n> proxied at all.\n> \n\nI accept the statement about RFC2616.\nThe sad fact is that I have 20,000+ Nokia phones deployed with a buggy browser that encodes the request parameters in UTF-16LE whatever the page encoding. Even if Nokia releases a fix, there's no way all of them will update their firmwares.\n\nMy idea was to work around this by using:\n\nrequest.setCharacterEncoding(\"UTF-16LE\");\n\nin a filter, after detecting the user-agent, and set useBodyEncodingForURI=\"true\". This doesn't work obviously because of the situation described above with UDecoder.\n\nMy only solution now is to parse the parameters myself and use URLDecoder.decode(param,\"UTF-16LE\"), which works correctly. This requires me to use a HttpServletRequest subclass and override its getParameter* methods.\n\nThanks for the quick reply, If this is a performance issue, then there's really no reason to degrade tomcat's general performance for a rare bug in a phone browser, still, I've seen URLs encoded with non-ascii encodings before.\n\nRan."}, {"count": 5, "tags": [], "bug_id": 45406, "is_private": false, "text": "(In reply to comment #3)\n> Marking Invalid.\n> \n> You aren't able to use utf-16 or ucs-2.  Period.\n> \n> The RFC2616 protocol clearly declares the input stream to be an ASCII superset\n> stream of otherwise opaque octets.  You can use any representation which is a \n> superset of ASCII and work out what character set you expect, such as UTF-8 or \n> ISO-8859-{any}.\n> ...\n\nDoes it? I don't think so. Details, please.\n\nJulian (wearing my hat as editor of RFC2616bis)", "id": 118713, "time": "2008-07-16T07:32:26Z", "creator": "julian.reschke@gmx.de", "creation_time": "2008-07-16T07:32:26Z", "attachment_id": null}, {"count": 6, "tags": [], "creator": "wrowe@apache.org", "attachment_id": null, "is_private": false, "id": 118718, "time": "2008-07-16T07:58:51Z", "bug_id": 45406, "creation_time": "2008-07-16T07:58:51Z", "text": "If we are to accept UTC-16, let's examine the bytestream of a GET request;\n\nGET \\0h\\0t\\0t\\0p\\0:\\0/\\0/\\0a\\0.\\0c\\0o\\0m\\0?\\0u\\0t\\0f\\0001\\0006\\0p\\0a\\0r\\0a\\0m\\0e\\0t\\0e\\0r\\0=\\0\\0%\\0D\\00007\\0%\\0000\\0005 HTTP/1.1\n\n*That* is utc-16 encoding.\n\nIt's clearly defined as OCTETs, and the 'GET' sp and sp \"HTTP/n.n\" are defined in \nASCII.\n\nI'm having a hard time coming to another conclusion, perhaps you can offer one?\n\nEspecially relevant are the definitions;\n\n       OCTET          = <any 8-bit sequence of data>\n       CHAR           = <any US-ASCII character (octets 0 - 127)>\n       CR             = <US-ASCII CR, carriage return (13)>\n       LF             = <US-ASCII LF, linefeed (10)>\n       SP             = <US-ASCII SP, space (32)>\n\nFurther, consider the statement;\n\n   Characters other than those in the \"reserved\" and \"unsafe\" sets (see\n   RFC 2396 [42]) are equivalent to their \"\"%\" HEX HEX\" encoding.\n\nwhich is nonsensical unless the ASCII definitions of reserved and unsafe\nare taken literally.\n"}, {"count": 7, "tags": [], "bug_id": 45406, "is_private": false, "id": 118722, "creation_time": "2008-07-16T08:09:21Z", "time": "2008-07-16T08:09:21Z", "creator": "ran.rubinstein@gmail.com", "text": "(In reply to comment #6)\n\nI was under the impression that only URL parameters that are part of the query string have to be encoded, and that when decoding, only %-encoded parts of the url are affected by the charset.\nThis is how the Java URLDecoder works:\n\nString s = \"http://a.com?utf16param=%D7%05\";\ns = URLDecoder.decode(s,\"UTF-16LE\");\nSystem.out.println(s);\n\nout:\nhttp://a.com?utf16param=\u05d7\n\n(", "attachment_id": null}, {"count": 8, "tags": [], "text": "I do(In reply to comment #6)\n> If we are to accept UTC-16, let's examine the bytestream of a GET request;\n> \n> GET\n> \\0h\\0t\\0t\\0p\\0:\\0/\\0/\\0a\\0.\\0c\\0o\\0m\\0?\\0u\\0t\\0f\\0001\\0006\\0p\\0a\\0r\\0a\\0m\\0e\\0t\\0e\\0r\\0=\\0\\0%\\0D\\00007\\0%\\0000\\0005\n> HTTP/1.1\n> \n> *That* is utc-16 encoding.\n> ...\n\nYes. That's not allowed. I didn't say that.\n\nHowever, from RFC2616's point of view it's totally legal to encode non-ASCII characters in the URL any way you want. There simply is no requirement that it needs to be a superset of ASCII.\n\nOf course, whether or not that is a good idea is another question.\n\nSo yes, if a server needs to support these kinds of URIs, it needs to workaround the limitations of the servlet engine (another way would be to use getRequestURI(), and parse that directly).\n\n", "attachment_id": null, "bug_id": 45406, "id": 118723, "time": "2008-07-16T08:12:02Z", "creator": "julian.reschke@gmx.de", "creation_time": "2008-07-16T08:12:02Z", "is_private": false}, {"count": 9, "tags": [], "text": "(In reply to comment #8)\n\n> Of course, whether or not that is a good idea is another question.\n> \n> So yes, if a server needs to support these kinds of URIs, it needs to\n> workaround the limitations of the servlet engine (another way would be to use\n> getRequestURI(), and parse that directly).\n> \n\nUsing getRequestURI() and parsing myself is the simple part. Since the parameter map in the HttpServletRequest is immutable, I need to use my own subclass for the request and use it throughout my application (and it can't be forwarded to external web applications). That solution is not very elegant.\n\nI'm not in a place to judge whether encoding URL's with non-ascii-superset encodings is legal or not, but:\n\nIf non-ascii-superset-encoded URIs are legal, I think tomcat should support them. Tomcat has the APIs to setCharacterEncoding() and useBodyEncodingForURI's, which don't limit the encoding to an ascii superset. It's looks like a simple matter of changing how URI's are decoded, to be compliant with the %-encoding rules.\n\nIf these URI's are illegal, perhaps tomcat should throw some kind of exception when when setCharacterEncoding is called with an 'illegal' encoding, and useBodyEncodingForURI is true.", "attachment_id": null, "bug_id": 45406, "id": 118746, "time": "2008-07-17T01:17:48Z", "creator": "ran.rubinstein@gmail.com", "creation_time": "2008-07-17T01:17:48Z", "is_private": false}, {"count": 10, "tags": [], "bug_id": 45406, "is_private": false, "text": "We might have lost sight of the issue here; this issue is not whether or not\nit's possible to encode utf-16-le, it's that the URI was not encoded in that\ncharacter set.\n\nAs I pointed out above, in the similar -be encoding, we need 16 bits to\ntransmit \neach character,  This particular browser sent 8 bit octets.  That is not\nutf-16.\n\nTwo escaped characters does not constitute a utf-16 request, it's a utf-16\nfragment within an ASCII/ISO-8859/UTF-8/whatever bytestream.  I would recommend\nno change whatsoever in Tomcat's URI parsing code on this issue, although you\ndo raise an interesting observation w.r.t. useBodyEncodingForURI.\n\nAs far as working around it, it might be nice if one could deploy a Valve that\nwas triggered based on User-Agent, that would probably be the most elegant hack\nfor you to work around this browser error.  Certainly not for core tomcat.\n", "id": 118764, "time": "2008-07-17T08:11:57Z", "creator": "wrowe@apache.org", "creation_time": "2008-07-17T08:11:57Z", "attachment_id": null}, {"count": 11, "tags": [], "creator": "ran.rubinstein@gmail.com", "is_private": false, "id": 118865, "attachment_id": null, "bug_id": 45406, "creation_time": "2008-07-21T03:41:16Z", "time": "2008-07-21T03:41:16Z", "text": "(In reply to comment #10)\n\nWill, I'm sorry to drag this on, but I want to understand fully where I'm wrong in this.\n\nAFAIK, an ascii URL with one character represented in %-encoding such as http://www.google.com/q=%D7%05 does represent a legal UTF-16 encoded URL.\n\nUTF-16 %-Encoding does not mean the client sends two bytes or a wchar for each letter in the URL, but rather that it sends the URL in ASCII, except for the parts of the query string are not ASCII and they are encoded using %-Encoding, with the bytes there determined by the selected encoding (usually UTF-8).\nThis is also the behavior of java's built-in URLEncoder.encode()/decode() functions.\n\nSo a UTF-16 encoded URL, can look like this:\n\nhttp://www.google.com/q=%D7%05\n\nand be legal.\n\nIs my concept completely off-base?\n\nIf this is true, I see no reason for tomcat not to support this (except of course that the architecture right now does not support it, since the %-decoding and string building classes are separate - byteChunk expects, well, a chunk of bytes, which it translates to a string according to the given encoding. UDecoder translates the URL to this chunk of bytes.\nI suggest that instead of this, when processing URLs/URI's tomcat will use a combined approach that is compatible with the %-encoding rule that only non-ascii characters are %-encoded."}]