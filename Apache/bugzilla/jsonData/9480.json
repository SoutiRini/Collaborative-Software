[{"count": 0, "tags": [], "bug_id": 9480, "attachment_id": null, "id": 16852, "time": "2002-05-29T06:43:49Z", "creator": "netcomindia@vsnl.com", "creation_time": "2002-05-29T06:43:49Z", "is_private": false, "text": "Our Java Web application is running on Tomcat 3.2.3 and once in every \nfew days,we are getting the following sort of error.\n\njava.lang.OutOfMemoryError: unable to create new native thread\n\tat java.lang.Thread.start(Native Method)\n\tat SeBase.DataConnection.createConnection(DataConnection.java:211)\n\tat SeBase.DataConnection.getConnection(DataConnection.java:191)\n\tat SeBase.CommonLogin.checkDatabase(CommonLogin.java:100)\n\tat SeBase.CommonLogin.setValues(CommonLogin.java:88)\n\tat \nsebase._0002fsebase_0002fcommon_0005floginaction_0002ejspcommon_0005floginactio\nn_jsp_0._jspService\n(_0002fsebase_0002fcommon_0005floginaction_0002ejspcommon_0005floginaction_jsp_\n0.java:211)\n\n\nThis happens only on pages which access the Database. Other JSPs are running \nfine even after the error has occurred. Because we are not creating threads in \nour application except for Database connection.\n\n\tFor Database connection, we are using a custom Data connection pooling \nmechanism (code given below). In that, while creating every new connection, we \nare creating a new thread which will check the usage of the connections after \nput to sleep for 2 minutes. If the connections are not in use for more than 1 \nminute, it will  close the connections and come out of run method. We have \nverified that the data connections are getting closed properly. But the \nthreads created during the process are not getting removed. \n\n\tIs it the right way? Or can we use one single thread which will check \nall the data connections every 2 minutes and will run from the starting of the \napplication server till it is closed? Can it lead us to any other problem?\n\n/**\n * Returns a JDCConnecton object if it is availabe in vector or creates a\n * new connection add it to vector and returns the same\n */\n   public synchronized Connection getConnection() throws Exception,SQLException\n   {\n      ConnectionPool f_obj_conn;   //for storing the connection pool object\n      for(int i = 0; i < f_obj_connections.size(); i++) //for loop for getting \nany free connection\n      {\n         f_obj_conn = (ConnectionPool)f_obj_connections.elementAt(i);\n         if (f_obj_conn.lease() && !f_obj_conn.isClosed())   //check for status\n         {\n\t\t\t\tSystem.out.print(\"\\nUsing Old Connection #\" +  \nf_int_total_conn + \"Connection name \" + f_obj_conn);\n            return f_obj_conn;\n         }   //end of if loop\n      }   //end of for loop\n      f_obj_conn = createConnection();\n      return f_obj_conn;\n   }\n\n\n/**\n * Creates a physical connection with the concerned database\n */\n   public synchronized ConnectionPool createConnection()throws Exception\n   {\n      ConnectionPool f_obj_conn_pool = null;   //for storing the pool object\n      if(f_obj_connections.size() < f_int_max_conn)   //check for max size\n      {\n        Class.forName(f_str_driver);\n        Connection f_obj_connection;   //for storing the connection\n        f_obj_connection = DriverManager.getConnection\n(f_str_url,f_str_user,f_str_password);\n        f_obj_conn_pool = new ConnectionPool(f_obj_connection, this);\n        f_obj_reaper = new ConnectionReaper(f_obj_conn_pool);\n  \t\t  f_int_total_conn = f_int_total_conn + 1;\t\n        f_obj_conn_pool.putThread(f_obj_reaper);\n        f_obj_conn_pool.lease();\n        f_obj_connections.addElement(f_obj_conn_pool);\n\t\t  f_obj_reaper.start();\t\n  \t\t  System.out.print(\"\\nNo Of Connection #\" +  f_int_total_conn \n+ \"New Connection Created \" + f_obj_connection);\n      }\n      if(f_obj_conn_pool == null)throw new Exception(\"SERVER TOO BUSY\");\n      return f_obj_conn_pool;\n   }\n\n\n/**\n * Closes all the stale connection as per specfied in vector size\n */\n\n   public synchronized void reapConnections()throws Exception\n   {\n      int f_int_index = 0;\n      long f_long_stale;   //for storing the stale or elapse time of connection\n      f_long_stale = System.currentTimeMillis() - f_long_timeout;\n      Enumeration f_obj_connlist;   //for getting the enumeration of connection\n      f_obj_connlist = f_obj_connections.elements();\n      //while loop for reaping connection\n      while((f_obj_connlist != null) && (f_obj_connlist.hasMoreElements()))\n      {\n         ConnectionPool f_obj_pool;   //for storing the connection pool object\n         f_obj_pool = (ConnectionPool)f_obj_connlist.nextElement();\n         //checking for status of connection\n         if(!f_obj_pool.inUse())\n         {\n            removeConnection(f_obj_pool.f_obj_conn);\n            Thread thread = f_obj_pool.getThread();\n            thread = null;\n\t\t\t\tf_int_removed_conn = f_int_removed_conn + 1;\n\t\t\t\tf_obj_connections.removeElement(f_obj_pool);\n     \t\t\tf_obj_connections.trimToSize();     \n         }\n         if((f_obj_pool.inUse()) && (f_long_stale > f_obj_pool.getLastUse()))\n         {\n            removeConnection(f_obj_pool.f_obj_conn);\n            Thread thread = f_obj_pool.getThread();\n            thread = null;\n  \t\t\t   f_int_removed_conn = f_int_removed_conn + 1;\n\t\t\t\tf_obj_connections.removeElement(f_obj_pool);\n     \t\t\tf_obj_connections.trimToSize();                 \n         }\n      }   //end of while loop\n   }\n\n\n\n/**\n * Removes the connecton object stored in the Connection vector\n * @param ConnectionPool\n */\n\n   private synchronized void removeConnection(Connection f_obj_conn)throws \nException\n   {\n      Connection connection = f_obj_conn;\n      connection.close();\n\t\tif(connection.isClosed())\n\t\t\tSystem.out.print(\"\\nConnection Closed  Connection Size \n#\" +  f_int_removed_conn + \"Connection \" + connection);\n\t\telse\n\t\t\tSystem.out.print(\"Connection not closed\");      \n   }\n\n/**\n * Run Method for a each  Thread of DataConnection object\n */\n   public void run()\n   {\n      while(true)   //while loop for invoking sleep method\n      {\n         try\n         {\n            //System.out.println(\"sleep called \" + this.f_obj_pool);\n              sleep(f_long_delay);\n         }\n         catch( InterruptedException e)\n         {\n\n         }\n         try\n         {\n         f_obj_pool.closeConnections();\n         }\n         catch(Exception e)\n         {}\n\n      }   //end of while loop\n   }\n}"}, {"count": 1, "tags": [], "text": "Marking as INVALID since this question is better asked elsewhere (on the Java\nJDBC forums, for e.g.). The user could also try using some contemporary\nconnection pooling libraries.", "is_private": false, "id": 93443, "creator": "sriramnrn@gmail.com", "time": "2006-09-12T17:46:23Z", "bug_id": 9480, "creation_time": "2006-09-12T17:46:23Z", "attachment_id": null}]