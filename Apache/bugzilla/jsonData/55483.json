[{"count": 0, "tags": [], "bug_id": 55483, "attachment_id": null, "id": 169707, "time": "2013-08-26T12:27:34Z", "creator": "dmikusa@gopivotal.com", "creation_time": "2013-08-26T12:27:34Z", "is_private": false, "text": "Included below are two test cases which fail.  The first calls an overloaded method on an object.  The second calls an overloaded constructor.  More details below.\n\n\n1.) Here's the first test.\n\n   @Test\n   public void test01() {\n       ELProcessor processor = new ELProcessor();\n       processor.defineBean(\"sb\", new StringBuilder());\n       Assert.assertEquals(\"a\", processor.eval(\"sb.append('a'); sb.toString()\"));\n   }\n\nThis fails with the following stack trace.\n\njavax.el.ELException: Cannot convert a of type class java.lang.String to long\n\tat org.apache.el.lang.ELSupport.coerceToNumber(ELSupport.java:349)\n\tat org.apache.el.lang.ELSupport.coerceToNumber(ELSupport.java:328)\n\tat org.apache.el.lang.ELSupport.coerceToType(ELSupport.java:450)\n\tat org.apache.el.ExpressionFactoryImpl.coerceToType(ExpressionFactoryImpl.java:48)\n\tat javax.el.Util.buildParameters(Util.java:351)\n\tat javax.el.BeanELResolver.invoke(BeanELResolver.java:173)\n\tat javax.el.CompositeELResolver.invoke(CompositeELResolver.java:84)\n\tat org.apache.el.parser.AstValue.getValue(AstValue.java:157)\n\tat org.apache.el.parser.AstSemicolon.getValue(AstSemicolon.java:35)\n\tat org.apache.el.ValueExpressionImpl.getValue(ValueExpressionImpl.java:188)\n\tat javax.el.ELProcessor.getValue(ELProcessor.java:45)\n\tat javax.el.ELProcessor.eval(ELProcessor.java:38)\n\tat org.apache.el.parser.TestAstMethodCalls.test01(TestAstMethodCalls.java:32)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:606)\n\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)\n\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)\n\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)\n\tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)\n\tat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:300)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)\n\nLooking into this, it appears that the EL is having trouble because StringBuilder's append method is overloaded.  It is instructed to call append with the character 'c', but instead is trying to coerce the character 'c' to a long and call append with the long.\n\nThis chain of events seems to be kicked off in AstValue.getValue() line #157, where it's calling resolver.invoke(..).  The call to resolver.invoke() is passing null as the paramTypes argument.  This trickles down to BeanELResolver.invoke(), which calls Util.findMethod().  Because paramTypes is null, Util.findMethod() selects the first method it finds with the expected number of arguments.  In the case above, it selects StringBuilder.append(long), which causes the problem above.\n\n\n\n2.) Here's the second test.\n\n   @Test\n   public void test02() {\n       ELProcessor processor = new ELProcessor();\n       processor.getELManager().importClass(\"java.util.Date\");\n       Date result = (Date) processor.eval(\"Date(86400)\");\n       Assert.assertEquals(86400, result.getTime());\n   }\n\nThis one fails intermittently with the following stack trace.\n\njavax.el.ELException: java.lang.IllegalArgumentException\n\tat javax.el.StaticFieldELResolver.invoke(StaticFieldELResolver.java:118)\n\tat javax.el.CompositeELResolver.invoke(CompositeELResolver.java:84)\n\tat org.apache.el.parser.AstFunction.getValue(AstFunction.java:138)\n\tat org.apache.el.ValueExpressionImpl.getValue(ValueExpressionImpl.java:188)\n\tat javax.el.ELProcessor.getValue(ELProcessor.java:45)\n\tat javax.el.ELProcessor.eval(ELProcessor.java:38)\n\tat org.apache.el.parser.TestAstMethodCalls.test02(TestAstMethodCalls.java:39)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:606)\n\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)\n\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)\n\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)\n\tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)\n\tat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:300)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)\nCaused by: java.lang.IllegalArgumentException\n\tat java.util.Date.parse(Date.java:615)\n\tat java.util.Date.<init>(Date.java:272)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57)\n\tat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n\tat java.lang.reflect.Constructor.newInstance(Constructor.java:526)\n\tat javax.el.StaticFieldELResolver.invoke(StaticFieldELResolver.java:111)\n\t... 29 more\n\nLooking into this error, it seems similar to #1.  The difference is that AstFunction.getValue() line #138 is calling invoke on the resolver and passing null as the paramTypes.  This trickles down to the StaticFieldELResolver.invoke() method, which calls Util.findConstructor().  Again, because paramTypes is null, Util.findConstructor() searches the available constructors for the one with the same number of arguments.  The reason that this intermittently fails is because on my system, the call to Class.getConstructors() returns the list of constructs in an arbitrary order. So it fails when Date(String) is listed first, but succeeds when Date(long) is listed first."}, {"count": 1, "tags": [], "bug_id": 55483, "attachment_id": 30764, "is_private": false, "id": 169716, "time": "2013-08-26T15:02:25Z", "creator": "dmikusa@gopivotal.com", "creation_time": "2013-08-26T15:02:25Z", "text": "Created attachment 30764\nUnit test\n\nAttaching a unit test to replicate the problem."}, {"count": 2, "tags": [], "text": "Thanks for the report and the unit tests. This has been fixed in trunk and will be included in 8.0.0-RC2 onwards.", "attachment_id": null, "id": 169783, "creator": "markt@apache.org", "time": "2013-08-28T20:50:41Z", "bug_id": 55483, "creation_time": "2013-08-28T20:50:41Z", "is_private": false}, {"count": 3, "tags": [], "creator": "markt@apache.org", "attachment_id": null, "text": "*** Bug 56147 has been marked as a duplicate of this bug. ***", "id": 173414, "time": "2014-02-21T12:03:33Z", "bug_id": 55483, "creation_time": "2014-02-21T12:03:33Z", "is_private": false}, {"count": 4, "tags": [], "bug_id": 55483, "attachment_id": null, "is_private": false, "id": 174210, "time": "2014-04-02T04:31:30Z", "creator": "bluewolf.chung@gmail.com", "creation_time": "2014-04-02T04:31:30Z", "text": "org.apache.el.util.ReflectionUtil#getMethod(java.lang.Object, java.lang.Object, java.lang.Class<?>[], java.lang.Object[])\n\n\n            // If a method is found where every parameter matches exactly,\n            // return it\n            if (exactMatch == paramCount) {\n                getMethod(base.getClass(), m);\n            }\n\n\nI haven't fully understand the recent patches but I think it should be \n\nreturn getMethod(base.getClass(), m);\n\nas the comment says."}, {"count": 5, "tags": [], "creator": "markt@apache.org", "is_private": false, "id": 174235, "creation_time": "2014-04-03T07:35:54Z", "time": "2014-04-03T07:35:54Z", "bug_id": 55483, "text": "Re-open to review comment #4.", "attachment_id": null}, {"count": 6, "tags": [], "text": "Thanks for the report.\n\nThe missing return didn't change the behaviour, it just meant that the exact match wasn't returned as quickly as it could have been.", "attachment_id": null, "id": 174519, "creator": "markt@apache.org", "time": "2014-04-12T20:59:24Z", "bug_id": 55483, "creation_time": "2014-04-12T20:59:24Z", "is_private": false}, {"count": 7, "tags": [], "bug_id": 55483, "attachment_id": null, "id": 174796, "time": "2014-04-23T10:05:42Z", "creator": "cng1067@gmail.com", "creation_time": "2014-04-23T10:05:42Z", "is_private": false, "text": "The fix for this has broken one of our EL expressions, we have an overloaded method like so:\n\ndoSomething(HttpServletRequest a, String b, String c, String d);\ndoSomething(String a, String b, String c, String d);\n\nand we end up with an error 'Unable to find unambiguous method'.  It is supposed to invoke the first method.\n\nFrom what I can tell it's because when it is assessing the suitability of each method, it doesn't find an exact match for either as the actual request object is a sub-class of HttpServletRequest, and can also be coerced into a String.\n\nPerhaps this can be fixed by prioritising sub-class matches over coercions?"}, {"count": 8, "attachment_id": null, "bug_id": 55483, "is_private": false, "id": 174888, "time": "2014-04-25T22:37:54Z", "creator": "knst.kolinko@gmail.com", "creation_time": "2014-04-25T22:37:54Z", "tags": [], "text": "(In reply to Christopher Ng from comment #7)\n> The fix for this has broken one of our EL expressions, we have an overloaded method like so:\n> \n> doSomething(HttpServletRequest a, String b, String c, String d);\n> doSomething(String a, String b, String c, String d);\n> ...\n\nThis issue has already been reported and is tracked as bug 56425.\n(It has been fixed in 8.0.x for 8.0.6 onwards and in 7.0.x for 7.0.54 onwards.)"}, {"count": 9, "tags": [], "text": "This changes added Tomcat 7.0 but It has no unit tests.\n\nDo Anyone have unit tests for Tomcat 7.0?", "attachment_id": null, "id": 177280, "creator": "gangsu_choi@tmax.co.kr", "time": "2014-08-20T09:24:29Z", "bug_id": 55483, "creation_time": "2014-08-20T09:24:29Z", "is_private": false}, {"count": 10, "tags": [], "creator": "housevenn@gmail.com", "attachment_id": null, "text": "This change broke our code. I pasted our code here\nhttp://stackoverflow.com/questions/38709068/argument-type-of-parameterized-method-call-in-el\n\nWe were able to call ${objectMapper.writeValueAsString(actionItems)} where actionItems is an ArrayList, while writeValueAsString takes an Object argument. \n\nAfter this change, method invocation in EL can only find the method with exact match of parameter types. And our method call is broken with NoSuchMethodException.\n\nIt makes sense to find the exact match when there are method overloads. But if there is no method overload, it should return the only matched method thus it is compatible with the old code like ours.", "id": 192794, "time": "2016-08-02T04:01:40Z", "bug_id": 55483, "creation_time": "2016-08-02T04:01:40Z", "is_private": false}, {"count": 11, "tags": [], "bug_id": 55483, "attachment_id": null, "is_private": false, "id": 192825, "time": "2016-08-02T17:03:37Z", "creator": "markt@apache.org", "creation_time": "2016-08-02T17:03:37Z", "text": "(In reply to Hao from comment #10)\n> This change broke our code.\n\nPlease open a new issue and attach a minimal test case that demonstrates the issue."}, {"count": 12, "tags": [], "bug_id": 55483, "attachment_id": null, "id": 192880, "time": "2016-08-04T15:28:52Z", "creator": "housevenn@gmail.com", "creation_time": "2016-08-04T15:28:52Z", "is_private": false, "text": "Hi Mark, I created a new issue yesterday\nhttps://bz.apache.org/bugzilla/show_bug.cgi?id=59939\n\nI believe it is related this this issue. Can you please have a look? Thanks."}]