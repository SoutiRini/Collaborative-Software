[{"count": 0, "tags": [], "text": "Created attachment 32731\npacket capture for failed session\n\nThe issue happens when pause between requests longer than server keep-alive timeout. See attached JMX for reproduction.\n\nTCP session is:\n\n1. JMeter establishes connection, makes first query and gets response\n2. after 60 seconds server closes the connection by timeout\n3. JMeter sleep time ends and it tries to make new request through old connection and predictably fails\n\nJMeter should re-establish connection, as socket has received FIN packet. Packet capture file attached.\n\nIt fails both on Linux and Windows. I tried to upgrade HTTPClient libs to 4.4.1, it does not help.", "is_private": false, "bug_id": 57921, "id": 182952, "time": "2015-05-12T09:23:21Z", "creator": "apc4@ya.ru", "creation_time": "2015-05-12T09:23:21Z", "attachment_id": 32731}, {"count": 1, "tags": [], "text": "Created attachment 32732\nReproduction test plan", "is_private": false, "bug_id": 57921, "id": 182953, "time": "2015-05-12T09:23:55Z", "creator": "apc4@ya.ru", "creation_time": "2015-05-12T09:23:55Z", "attachment_id": 32732}, {"count": 2, "tags": [], "bug_id": 57921, "is_private": false, "text": "Hi Andrey,\nI suggest asking question on httpclient user mailing list. \nOleg usually helps a lot.\nThanks", "id": 182964, "time": "2015-05-12T20:00:50Z", "creator": "p.mouawad@ubik-ingenierie.com", "creation_time": "2015-05-12T20:00:50Z", "attachment_id": null}, {"count": 3, "tags": [], "bug_id": 57921, "attachment_id": null, "text": "Are we sure this is HTTPClient issue? How can we verify this?", "id": 182965, "time": "2015-05-12T20:01:44Z", "creator": "apc4@ya.ru", "creation_time": "2015-05-12T20:01:44Z", "is_private": false}, {"count": 4, "tags": [], "creator": "p.mouawad@ubik-ingenierie.com", "text": "Maybe we should change retry defaults:\n- https://bugzilla.mozilla.org/show_bug.cgi?id=92224", "id": 183195, "time": "2015-05-29T21:23:14Z", "bug_id": 57921, "creation_time": "2015-05-29T21:23:14Z", "is_private": false, "attachment_id": null}, {"count": 5, "tags": [], "text": "Changing retry default will affect all other situations. I think this is not desired. For example, I personally would not like to have it as my default, because it will masq possible server-side issues when it sometimes refuses to accept the connection once, but succeeds on retry.", "is_private": false, "bug_id": 57921, "id": 183196, "time": "2015-05-29T22:16:07Z", "creator": "apc4@ya.ru", "creation_time": "2015-05-29T22:16:07Z", "attachment_id": null}, {"count": 6, "tags": [], "text": "Agreed, changing the default seems wrong", "is_private": false, "bug_id": 57921, "id": 183197, "time": "2015-05-30T00:11:57Z", "creator": "sebb@apache.org", "creation_time": "2015-05-30T00:11:57Z", "attachment_id": null}, {"count": 7, "tags": [], "bug_id": 57921, "attachment_id": null, "text": "(In reply to Philippe Mouawad from comment #4)\n> Maybe we should change retry defaults:\n> - https://bugzilla.mozilla.org/show_bug.cgi?id=92224\n\nThat is about a special situation for requests including a request body.\n\nThe problem here is about a request (with or without body) that tried to use a stale connection. Stale in the sense that the HTTP keepa-live timeout was reached or almost reached.\n\nIt is also not about general retries. It would be good, if we could fix the keep-alive timeout issue. To me it seems that HTTPClient should handle keep alives itself well. After the keep alive timeout happened, it should not resuse a connection. There's a DefaultConnectionKeepAliveStrategy that supports that. Maybe we have to activate it or so.\n\nBut there's always a small chance for a race condition (timeout not yet over when sending data but timeout reached before data arrives at server), it might be best to not reuse a keep alive connection if at the moment we want to use it the keep alive timeout is nearly over.\n\nIt seems that HTTPClient allows to define a ConnectionKeepAliveStrategy which can be derived from DefaultConnectionKeepAliveStrategy and would set the keep alive timeout e.g. to the one determined by DefaultConnectionKeepAliveStrategy from the server header minus e.g. 200 ms (configurable). Not perfect but should reduce those race conditions a lot.\n\nI think we first have to find out whether and why the general keep alive case is broken and then can tackle the rare race condition.", "id": 183198, "time": "2015-05-30T13:00:52Z", "creator": "rainer.jung@kippdata.de", "creation_time": "2015-05-30T13:00:52Z", "is_private": false}, {"attachment_id": null, "tags": [], "creator": "p.mouawad@ubik-ingenierie.com", "text": "(In reply to Rainer Jung from comment #7)\n> (In reply to Philippe Mouawad from comment #4)\n> > Maybe we should change retry defaults:\n> > - https://bugzilla.mozilla.org/show_bug.cgi?id=92224\n> \n> That is about a special situation for requests including a request body.\n> \n> The problem here is about a request (with or without body) that tried to use\n> a stale connection. Stale in the sense that the HTTP keepa-live timeout was\n> reached or almost reached.\n> \n> It is also not about general retries. It would be good, if we could fix the\n> keep-alive timeout issue. To me it seems that HTTPClient should handle keep\n> alives itself well. After the keep alive timeout happened, it should not\n> resuse a connection. There's a DefaultConnectionKeepAliveStrategy that\n> supports that. Maybe we have to activate it or so.\n> \n> But there's always a small chance for a race condition (timeout not yet over\n> when sending data but timeout reached before data arrives at server), it\n> might be best to not reuse a keep alive connection if at the moment we want\n> to use it the keep alive timeout is nearly over.\n> \n> It seems that HTTPClient allows to define a ConnectionKeepAliveStrategy\n> which can be derived from DefaultConnectionKeepAliveStrategy and would set\n> the keep alive timeout e.g. to the one determined by\n> DefaultConnectionKeepAliveStrategy from the server header minus e.g. 200 ms\n> (configurable). Not perfect but should reduce those race conditions a lot.\n> \n\nsebb implemented in 2.11 I think a httpclient4.idletimeout property that if > 0, would setup custom DefaultConnectionKeepAliveStrategy that would artificially set a default keep alive if server didn't set it correctly.\nMaybe we could enhance it\n> I think we first have to find out whether and why the general keep alive\n> case is broken and then can tackle the rare race condition.", "count": 8, "id": 183199, "time": "2015-05-30T13:20:16Z", "bug_id": 57921, "creation_time": "2015-05-30T13:20:16Z", "is_private": false}, {"count": 9, "tags": [], "bug_id": 57921, "is_private": false, "text": "The test case and the capture belong to different client server communications.\n\nFurthermore I couldn't reproduce with the test case, because at the time I tried the server seemed to use a much longer keep-alive timeout than the 60 seconds assumed in the test case (I observed 4 minutes timeout). Using the server from the original packet dump and increasing the timer sleep to 5 minutes, I could reproduce.\n\nIn this case the server uses HTTP/1.1 but does *not* send a Connection header in the reponse. The request contains one, but not the response.\n\nLooking at the HttpClient code this situation means, that the default reuse strategy decides to reuse the connection (since it is HTTTP/1.1) and asks the keep alive strategy for how long. The default keep alive strategy when called without a Connection header will return the value \"-1\" which will disable the keep alive. But our own IDLE_STRATEGY will overwrite any value <=0 with the value 0 by default. Value 0 for HttpClient does not mean 0 seconds, but infinite keep-alive. So IMHO IDLE_STRATEGY needs fixing for the default case (value 0 for \"httpclient4.idletimeout).\n\nI'm running out of time right now, but will come back to this if noone beats me to it. The likely fix is something like\n\n@@ -145,7 +145,7 @@\n         @Override\n         public long getKeepAliveDuration(HttpResponse response, HttpContext context) {\n             long duration = super.getKeepAliveDuration(response, context);\n-            if (duration <= 0) {// none found by the superclass\n+            if (duration <= 0 && IDLE_TIMEOUT > 0) {// none found by the superclass\n                 log.debug(\"Setting keepalive to \" + IDLE_TIMEOUT);\n                 return IDLE_TIMEOUT;\n             }", "id": 183203, "time": "2015-05-31T12:02:05Z", "creator": "rainer.jung@kippdata.de", "creation_time": "2015-05-31T12:02:05Z", "attachment_id": null}, {"count": 10, "tags": [], "text": "I've spenc several hours investigating the whole topic of closed keep-alive sockets with HTTPClient and I found:\n  0. There is no way to tell if server has closed socket in Java without reading from socket\n  1. HTTPClient throws NoHTTPResponse exception when it failed to read anything from server, most of the times this means server has closed the socket\n  2. It is suggested by HTTPClient authors to do one retry in case of NoHTTPResponse to make sure the problem persists\n  3. Since HTTPClient 4.3 there is special \"RetryExec\" class to cover this set of cases (JMeter using version 4.2)  \n\nI see no efficient steps here until we will upgrade HTTPClient. Maybe just catching and retrying once on NoHTTPResponse might mitigate the case and separate it from other exception cases.", "is_private": false, "bug_id": 57921, "id": 183204, "time": "2015-05-31T13:39:31Z", "creator": "apc4@ya.ru", "creation_time": "2015-05-31T13:39:31Z", "attachment_id": null}, {"count": 11, "tags": [], "text": "I'm going to change the title of this issue to describe more precisely the original problem. To discuss further optimizations we can use the dev list or another specific ticket.\n\nI don't think the problem is that big. The most common case that after applying the fix for this issue here (HTTP/1.1 with no Connection keep-alive header leads to infinite keep alive behavior) IMHO remains is the possible race between the client sending a followon request very shortly before the keep-alive ends and arriving at the server shortly after. This race could be made rare by subtracting a small delta from the keep-alive timeout determined by a connection header.\n\nAnother case would be a user who configures a fixed keep-alive timeout using IDLE_STRATEGY which is longer than what the server supports. That would then be a user error.\n\nFinally a server could announce some timeout but then due to increasing load decide to close a connection earlier than announced. That indeed could be a case for RetryExec.", "is_private": false, "bug_id": 57921, "id": 183208, "time": "2015-05-31T19:15:53Z", "creator": "rainer.jung@kippdata.de", "creation_time": "2015-05-31T19:15:53Z", "attachment_id": null}, {"attachment_id": null, "tags": [], "creator": "rainer.jung@kippdata.de", "text": "Author: rjung\nDate: Sun May 31 19:24:32 2015\nNew Revision: 1682775\n\nURL: http://svn.apache.org/r1682775\nLog:\nBug 57921 - HTTP/1.1 without keep-alive Connection response header uses infinite keep-alive and fails\nBugzilla Id: 57921\n\nModified:\n    jmeter/trunk/bin/jmeter.properties\n    jmeter/trunk/src/protocol/http/org/apache/jmeter/protocol/http/sampler/HTTPHC4Impl.java", "count": 12, "id": 183231, "time": "2015-06-01T10:10:34Z", "bug_id": 57921, "creation_time": "2015-06-01T10:10:34Z", "is_private": false}]