[{"count": 0, "tags": [], "bug_id": 11475, "attachment_id": null, "id": 20662, "time": "2002-08-05T16:52:45Z", "creator": "chrisd@apache.org", "creation_time": "2002-08-05T16:52:45Z", "is_private": false, "text": "If the CookieStyle configuration directive is set to Cookie2 or RFC2965, then\nmod_usertrack sets dcfg->style = CT_COOKIE2.  In turn, the spot_cookie()\nfunction will then parse the Cookie2: request header, looking for the Apache\ncookie:\n\n    cookie = apr_table_get(r->headers_in,\n        (dcfg->style == CT_COOKIE2 ? \"Cookie2\" : \"Cookie\"))\n\nHowever, reading the RFC 2965 specification, specifically section 3.3.5,\nit appears to me that the Cookie2: header is only used to indicate the\nhighest version of the cookie specification that the client understands.\nPer 3.3.4, the actual cookie values are still sent in the Cookie: header.\n(See also 9.1 and the examples under 4.1 and 4.2.)\n\nAs a further note, it seems to me -- I could be reading the spec or code\nincorrectly, of course -- that the cookie parsing code in spot_cookie()\nmay not really work with RFCs 2109 or 2965, because it doesn't accept\ncommas as cookie delimiters, nor the whitespace or double-quote (\")\nquoted-strings allowed by those RFCs.  See 10.1.3 in RFC 2109, as well\nas 4.1 and 4.3.4 in RFC 2109, and 3.1 and 3.3.4 in RFC 2965.\nMy apologies if I've misread something!"}, {"count": 1, "tags": [], "bug_id": 11475, "text": "Looking at the spot_cookie() code a bit more, I'm also suspicious that it may\nbe confused by both RFC 2965-style cookies (which can have quoted-string\nvalues, with escaped characters).\n\nFurther, I think it will also be confused just by old-style cookies where\nthe string \"Apache\" (or whatever the cookie name it's looking for is) appears\nin a cookie name or value somewhere before the actual cookie name/value pair\nin the header.  For example, I suspect \"Apache2=foo; Apache=bar\" or\n\"foo=Apache; Apache=bar\" would both cause the apr_strstr_c() call to find\nthe first, incorrect, occurance of \"Apache\".  Or, if the client has two valid\n\"Apache\" cookies for the server, with different paths, it may send them both,\nwith the more-specific path first ... but since we always set the path=/, our\ncookie will be the last one, not the first one.\n\nif ((value = ap_strstr_c(cookie, dcfg->cookie_name))) {\n    char *cookiebuf, *cookieend;\n\n    value += strlen(dcfg->cookie_name) + 1;  /* Skip over the '=' */\n    cookiebuf = apr_pstrdup(r->pool, value);\n    cookieend = strchr(cookiebuf, ';');\n    if (cookieend)\n        *cookieend = '\\0';      /* Ignore anything after a ; */\n\nI don't know if this helps or not, but since I don't have time right now to\nimplement a complete fix, I will attach a file that parses a Cookie: header\ninto an APR hash of cookies, where each hash value is an APR array of\n\"string\" structures.  The first structure in an array is the first cookie\nwe found with the given name (the name is the hash key that points to the\narray), which should be the most-specific cookie of that name, assuming the\nclient is working correctly.  The last structure in an array is the last\ncookie -- which is the one mod_usertrack would want, because it would have\nto be the path=/ cookie.\n\nThe \"string\" structure contains both the string itself, null-terminated, and\nthe string length, which is useful for avoiding additional strlen() calls.\nThe cookie_get() function returns the string of the first cookie, or NULL\nif there is more than one cookie with the same name.  This obviously isn't\nuseful for the mod_usertrack situation, where we want the last cookie in\nan array.  For that, you want to do something like (assuming you know\nthere's at each one element in the array):\n\n/**** DEBUG: watch out for nelts == 0 !! ****/\nstring = ((struct string*) val_arr->elts) + val_arr->nelts - 1;\nstr = string->ptr;\nstr_len = string->str_len;\n\nWhen parsing the Cookie: header, if a $Version=1 cookie is detected\nat the start (or some legal RFC 2965 variation), then the code parses\naccording to RFCs 2965 and 2616 (mostly); otherwise, it parses according\nto the old Netscape specification.\n\nWhen parsing in RFC 2965-mode, cookie names are flattened to lowercase,\nsince the spec calls for case-insensitive cookie names.  Quoted strings\nare de-quoted and escaped characters in quoted strings are un-escaped\n(except for some dubious values that RFC 2616 allows).  Unquoted cookie\nvalues must be RFC 2616 tokens, and all cookie names must be tokens as well.\nBoth commas and semicolons are legal delimiters.\n\nWhen parsing in Netscape-mode, cookie names and values are not altered,\nexcept that we ignore internal whitespace and commas, because the spec\ndoesn't allow those at all.  Only semicolons are legal delimiters.\n\nIn general, high-bit-set octets and ASCII control characters are\nstripped out, despite what RFC 2616 allows, because -- well, because\napplications really shouldn't be using such stuff in an HTTP header,\nshould they?\n\nThe code also imposes its own #defined limits on name and value lengths.\nThis probably overkill given that the header is normally limited to\nabout 8 Kb by the DEFAULT_LIMIT_REQUEST_FIELDSIZE #define, but this\ncode came from another application where we didn't have such external\nlimits.\n\nPlus, it's worth noting that both the Netscape and RFC 2965\nspecs allow clients to send 20 cookies where each one's name/value\npair is 4 Kb ... but any application that actually relied on that many\nlarge cookies would cause Apache errors for its clients, once they\nexceeded the 8 Kb header limit.  Maybe someday Cookie: headers should\nbe allowed to exceed the DEFAULT_LIMIT_REQUEST_FIELDSIZE?  Or else,\nat least a warning about this conflict with the specs should maybe go\nin the docs.\n\nThe code tries hard to avoid excess strlen()-type calls and multiple\npasses over the data.  Although it would be more elegant to allocate\nkey[] and val[] buffers off the stack for the maximum, dump characters\ninto them as we find them, and then apr_palloc() just enough space\nfor the resultant strings, that requires at least two passes over\nall the data.\n\nInstead, this code starts by allocating a small buf_size buffer\nfrom apr_palloc(), and then, once it's filled up, allocating double\nthat amount of space for the next buffer.  The doubling continues\nuntil a reasonable maximum is reached that can always contain the\nlargest string we need to handle (ideally, several large strings).\nThis does involve memcpy() calls when we have to reallocate in the\nmiddle of a name or value, and some wasted space, but we should\navoid a full 2* pass over all the data, and not waste too much more\nspace than we need.  Like I said, it's a bit of overkill just for\nthe Cookie: header, but I had the code on hand.\n\nThe attached code should compile, but it differs slightly from\nour actual implementation usage, so I can't guarantee that it's\nbug-free.\n\nPerhaps something like this might form part of an APR-util cookie\nlibrary?  Or not ...", "id": 20753, "time": "2002-08-07T15:59:22Z", "creator": "chrisd@apache.org", "creation_time": "2002-08-07T15:59:22Z", "is_private": false, "attachment_id": null}, {"count": 2, "tags": [], "bug_id": 11475, "text": "Created attachment 2624\nNetscape and RFC 2695 compliant cookie parser", "id": 20754, "time": "2002-08-07T16:01:06Z", "creator": "chrisd@apache.org", "creation_time": "2002-08-07T16:01:06Z", "is_private": false, "attachment_id": 2624}, {"count": 3, "tags": [], "bug_id": 11475, "text": "Oops, two extra comments: the last line of the cookie_parse_header() function\nshould \"return APR_SUCCESS\", not \"return OK\", and this code simply skips over\nany cookies whose names start with $ when parsing in RFC 2965-mode.\nAn enhancement would be to put those $name values into a fancier \"struct cookie\"\nthat contains the \"struct string\", and push those structures onto the APR\narrays.", "id": 20755, "time": "2002-08-07T16:07:50Z", "creator": "chrisd@apache.org", "creation_time": "2002-08-07T16:07:50Z", "is_private": false, "attachment_id": null}, {"attachment_id": null, "tags": [], "bug_id": 11475, "is_private": false, "count": 4, "id": 47793, "time": "2003-11-21T17:06:41Z", "creator": "trawick@apache.org", "creation_time": "2003-11-21T17:06:41Z", "text": "regarding the spotcookie problem misrecogonizing cookies: that was fixed\nrecently...  no comment from me on your rfc compliance comment"}, {"count": 5, "tags": [], "creator": "nd@perlig.de", "text": "RFC issue Fixed in 2.1 and proposed for backport into the 2.0 and 1.3 stable\nbranches.\n\nThanks for the report and thanks for using Apache.", "id": 50433, "time": "2004-01-13T00:34:31Z", "bug_id": 11475, "creation_time": "2004-01-13T00:34:31Z", "is_private": false, "attachment_id": null}]