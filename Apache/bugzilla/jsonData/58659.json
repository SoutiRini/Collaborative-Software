[{"count": 0, "tags": [], "bug_id": 58659, "attachment_id": null, "is_private": false, "id": 186584, "time": "2015-11-27T08:53:25Z", "creator": "knst.kolinko@gmail.com", "creation_time": "2015-11-27T08:53:25Z", "text": "Trunk at revision 1716783\n\nBuildbot run:\nhttps://ci.apache.org/builders/tomcat-trunk/builds/690\n\nLog file:\nhttps://ci.apache.org/projects/tomcat/tomcat9/logs/logs/1716783/TEST-org.apache.coyote.http2.TestHttp2Section_5_3.NIO.txt\n\nIn TestHttp2Section_5_3.java there is a comment on lines 127-144:\n\n// The loop below handles 0, 1 or 2 stream being blocked\n<...>\n// - If 2 streams are blocked the connection window will be set to one\n//   but one byte will be permitted for both streams (due to rounding in\n//   the allocation). The window size should be -1 (see below). Two\n//   frames (one for each stream will be written) one of which will be\n//   consumed by the client. The loop will start again and the Window\n//   size incremented to zero. No data will be written by the streams\n//   but the second data frame written in the last iteration of the loop\n//   will be read. The loop will then exit since frames from both\n//   streams will have been observed.\n\nThe sequence of events in while(!seen19 || !seen21) loop (line 147) on this test run was:\niteration 1: a body of stream 21 was read (\"21-Body-1\")\niteration 2: \"parser.readFrame(true);\" call blocks until it times out after waiting for 30 seconds\n\n[[[\nTestcase: testWeighting took 35.576 sec\n\tCaused an ERROR\nRead timed out\njava.net.SocketTimeoutException: Read timed out\n\tat java.net.SocketInputStream.socketRead0(Native Method)\n\tat java.net.SocketInputStream.socketRead(SocketInputStream.java:116)\n\tat java.net.SocketInputStream.read(SocketInputStream.java:170)\n\tat java.net.SocketInputStream.read(SocketInputStream.java:141)\n\tat org.apache.coyote.http2.Http2TestBase$TestInput.fill(Http2TestBase.java:720)\n\tat org.apache.coyote.http2.Http2Parser$Input.fill(Http2Parser.java:565)\n\tat org.apache.coyote.http2.Http2Parser.readFrame(Http2Parser.java:75)\n\tat org.apache.coyote.http2.Http2Parser.readFrame(Http2Parser.java:68)\n\tat org.apache.coyote.http2.TestHttp2Section_5_3.testWeighting(TestHttp2Section_5_3.java:149)\n]]]\n\nMy concern is implementation of Http2Parser.readFrame() method.\nIt starts with unconditionally calling \"input.fill(block, frameHeaderBuffer)\" regardless of whether the frame bytes have already been read. I think it shall check whether the blocking read is necessary or if enough the data have already been received.\n\nThe comment that I cited says \"but the second data frame written in the last iteration of the loop will be read\". I think that because of unconditional call to input.fill() the thread will block reading for data, regardless of whether the second data frame has already been received."}, {"count": 1, "tags": [], "bug_id": 58659, "attachment_id": null, "is_private": false, "id": 186864, "time": "2015-12-09T14:27:16Z", "creator": "markt@apache.org", "creation_time": "2015-12-09T14:27:16Z", "text": "The root cause analysis here is wrong.\n\nData is not buffered in the Http2Parser, it is buffered in the SocketWrapper so the call to input.fill() in parser.readFrame() is correct.\n\nFurther analysis is required to work out why this is failing."}, {"count": 2, "tags": [], "bug_id": 58659, "is_private": false, "text": "I've found the problem. There is a deadlock. I'm working on a fix.", "id": 186960, "time": "2015-12-15T11:11:33Z", "creator": "markt@apache.org", "creation_time": "2015-12-15T11:11:33Z", "attachment_id": null}, {"count": 3, "tags": [], "bug_id": 58659, "attachment_id": null, "text": "This is fixed in 9.0.x for 9.0.0.M2 onwards.", "id": 186962, "time": "2015-12-15T14:30:56Z", "creator": "markt@apache.org", "creation_time": "2015-12-15T14:30:56Z", "is_private": false}]