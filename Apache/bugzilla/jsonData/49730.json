[{"count": 0, "tags": [], "creator": "slaurent@apache.org", "attachment_id": null, "text": "In tomcat 6, I often configure an Executor with minSpareThreads=0 to work around memory leak issues upon redeployment.\n\nSometimes (especially in development), when I refresh a page of my webapp with Safari, Chrome or Firefox, some resources of the page take several seconds (>10s) to be served though they are static resources and should come in less than 50ms. For instance, over 15 requests for a page (1 for html, the others for resources like js, css, images...), I sometimes have 1 or 2 that take >10s. \n\nAfter analysis, I found that in org.apache.catalina.core.StandardThreadExecutor.TaskQueue.offer(Runnable) the statement \nif (parent.getActiveCount()<(parent.getPoolSize()))\nis sometimes true unexpectedly. Here is the scenario :\n\n- ThreadPoolExecutor is empty\n- the user refreshes the page (or accesses it with an empty cache) in his web browser for a page that uses a more than 10-15 resources\n- the browser establishes one TCP connection and a new Thread is created\n- after the browser receives the response, it decides to load as many resources as possible in parallel. For this it establishes up to 6 TCP connections (in my tests)\n- The Acceptor thread calls StandardThreadExecutor.execute to process each incoming connection.\n- For each call, StandardThreadExecutor.TaskQueue.offer(Runnable) is being called\n- if you study the sources of Java 6 ThreadPoolExecutor, you can see that there's a small delay between the time a new Thread is created (thus increasing poolSize) and the time it starts working on its first task (increasing the activeCount)\n- Since in my case connections are established in a rapid burst, the calls to TaskQueue.offer() are sometimes faster than this small delay, so that we do have parent.getActiveCount()<parent.getPoolSize() and thus the task is enqueued instead of forcing the creation of a thread to serve it.\n- Since Keep-Alive is enabled and tomcat 6 threads take care of only one TCP connection at a time, the requests in the queue must wait for the keep-alive timeout so that a Thread is returned to the pool to serve pending tasks.\n- With 25s keepAliveTimeOut, it means that some requests take more than 25s to be served eventhough the pool was never full and the server quite idle!!!\n\nOther facts about this issue :\n- Although my test case starts with an empty pool, it can occur even on a loaded server. The thing that triggers the issue is the burst of new TCP connections.\n- The problem is less severe with a lower keepAliveTimeout, or if keepalive is disabled. In any case, it also depends on the time taken to serve current requests.\n- The issue also affects tomcat 7 but is less severe because tc7 threads are returned to the pool after each http request, even if the TCP connection is kept alive. The impact would the same as with tc6 with keepAlive disabled.", "id": 139003, "time": "2010-08-09T16:16:04Z", "bug_id": 49730, "creation_time": "2010-08-09T16:16:04Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 49730, "attachment_id": 25865, "text": "Created attachment 25865\nPatch for Tomcat 6", "id": 139004, "time": "2010-08-09T16:38:11Z", "creator": "slaurent@apache.org", "creation_time": "2010-08-09T16:38:11Z", "is_private": false}, {"count": 2, "tags": [], "bug_id": 49730, "attachment_id": 25866, "id": 139005, "time": "2010-08-09T16:38:47Z", "creator": "slaurent@apache.org", "creation_time": "2010-08-09T16:38:47Z", "is_private": false, "text": "Created attachment 25866\nPatch for tomcat 7"}, {"count": 3, "attachment_id": null, "creator": "slaurent@apache.org", "text": "the proposed patch for tc6 tries to modify as few things as possible.\nIt would be cleaner to backport some stuff from tc7, but I don't know if we have to keep tc6 \"interface\" compatible with previous releases. Example : in tc7 TaskQueue is now a public class where it was an inner class of StandardThreadExecutor in tc6...", "id": 139006, "time": "2010-08-09T16:43:00Z", "bug_id": 49730, "creation_time": "2010-08-09T16:43:00Z", "tags": [], "is_private": false}, {"count": 4, "tags": [], "creator": "markt@apache.org", "text": "Thanks for the analysis and the patch.\n\nPatch applied to 7.0.x and will be in 7.0.3 onwards.\n\nPatch proposed for 6.0.x\n\nIn terms of compatibility, we try and aim for binary compatibility between point releases although we do sometimes break that rule.", "id": 140331, "time": "2010-09-30T14:05:30Z", "bug_id": 49730, "creation_time": "2010-09-30T14:05:30Z", "is_private": false, "attachment_id": null}, {"count": 5, "tags": [], "creator": "knst.kolinko@gmail.com", "text": "Regarding TC7:\n1) Why StandardThreadExecutor in TC7 was not patched? Can it be removed, or should it be patched by applying TC6 patch to TC7?\n\n2) (unrelated issue) Apparently there is a bug in catch (InterruptedException x) block in ThreadPoolExecutor.execute(..) in TC7:\n      s/Thread.interrupted()/Thread.currentThread().interrupt()\nFor reference:\nhttp://www.ibm.com/developerworks/java/library/j-jtp05236.html\n\nRegarding TC6 and TC7 patches:\n2) I would prefer using a finally block to decrement the counter on errors.", "id": 140389, "time": "2010-10-02T15:24:51Z", "bug_id": 49730, "creation_time": "2010-10-02T15:24:51Z", "is_private": false, "attachment_id": null}, {"count": 6, "tags": [], "bug_id": 49730, "attachment_id": null, "id": 140391, "time": "2010-10-02T17:36:49Z", "creator": "slaurent@apache.org", "creation_time": "2010-10-02T17:36:49Z", "is_private": false, "text": "(In reply to comment #5)\n> Regarding TC7:\n> 1) Why StandardThreadExecutor in TC7 was not patched? Can it be removed, or\n> should it be patched by applying TC6 patch to TC7?\n\nStandardThreadExecutor actually delegates to a org.apache.tomcat.util.threads.ThreadPoolExecutor which is the one that has been patched. \nBut then your question leads to this next : why the catch (RejectedExecutionException rx) in StandardThreadExecutor.execute ? it's already handled in org.apache.tomcat.util.threads.ThreadPoolExecutor.execute\n\nSome javadoc comments would also be useful to explain why we have 2 classes whereas there was only one in tc6 (I guess it's because of the Lifecycle refactoring and JMX things?)\n\n> Regarding TC6 and TC7 patches:\n> 2) I would prefer using a finally block to decrement the counter on errors.\n\nagreed, but it should not be decremented if the task can be forced into the queue after a RejectedExecutionException.\n\nDo you want a new patch to the current trunk ? for the interrupt() and the decrement in finally ?"}, {"text": "Fixed in 6.0.x for 6.0.30", "tags": [], "bug_id": 49730, "attachment_id": null, "count": 7, "id": 141400, "time": "2010-11-04T10:28:20Z", "creator": "markt@apache.org", "creation_time": "2010-11-04T10:28:20Z", "is_private": false}]