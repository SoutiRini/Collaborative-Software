[{"count": 0, "tags": [], "bug_id": 25967, "is_private": false, "text": "I understand that this need to be synchronized, but can it be handled differently?\n\nThe reason I ask is that we have pages that are calling this method over 5,000\nper user per request. I modified the class by creating a new method that puts\nthe evalutator in the map. That method is sync. I removed sync from the\ngetEvaluatorByName method. When testing this under heavy load it shows\nsignificant improvement in response time and load handling.\n\n***** The existing method\n\n public static synchronized\n\t    ExpressionEvaluator getEvaluatorByName(String name)\n            throws JspException {\n        try {\n\n            Object oEvaluator = nameMap.get(name);\n            if (oEvaluator == null) {\n                ExpressionEvaluator e = (ExpressionEvaluator)\n                    Class.forName(name).newInstance();\n                nameMap.put(name, e);\n                return (e);\n            } else\n                return ((ExpressionEvaluator) oEvaluator);\n\n\n***** My changes\n\n  private static synchronized void addEvaluatorByName (String name)\n    throws ClassNotFoundException, IllegalAccessException, InstantiationException\n  {\n    System.out.println( \"addEvaluatorCount: \"+getEvalCounter++);\n\n    ExpressionEvaluator e = (ExpressionEvaluator)\n            Class.forName(name).newInstance();\n        nameMap.put(name, e);\n\n  }\n    /**\n     * Gets an ExpressionEvaluator from the cache, or seeds the cache\n     * if we haven't seen a particular ExpressionEvaluator before.\n     *\n     * tperkins: removed synchronized from method. Movde adding of evaluator\n     * to separate sync method (addEvaluatorByName)\n     */\n    public static\n            ExpressionEvaluator getEvaluatorByName(String name)\n            throws JspException {\n        try {", "id": 50209, "time": "2004-01-07T21:25:49Z", "creator": "tony.perkins@sabre.com", "creation_time": "2004-01-07T21:25:49Z", "attachment_id": null}, {"count": 1, "tags": [], "bug_id": 25967, "attachment_id": null, "is_private": false, "id": 55528, "time": "2004-04-08T16:37:50Z", "creator": "rich_kraft@yahoo.com", "creation_time": "2004-04-08T16:37:50Z", "text": "*** Bug 28282 has been marked as a duplicate of this bug. ***"}, {"count": 2, "tags": [], "bug_id": 25967, "is_private": false, "text": "Created attachment 11186\nRemove synchronized from the getEvaluatorByName method", "id": 55529, "time": "2004-04-08T16:38:36Z", "creator": "rich_kraft@yahoo.com", "creation_time": "2004-04-08T16:38:36Z", "attachment_id": 11186}, {"count": 3, "tags": [], "creator": "justyna.horwat@sun.com", "text": "Created attachment 11516\nSource for applied patch", "id": 57237, "time": "2004-05-11T23:14:49Z", "bug_id": 25967, "creation_time": "2004-05-11T23:14:49Z", "is_private": false, "attachment_id": 11516}, {"count": 4, "tags": [], "text": "Thanks Tony & Richard for pointing this out.\n\nRemoved synchronization on getEvaluatorByName() method. Now synchronizing on nameMap and \nallowing reads to occur without blocking. Should be a performance improvement.\n\nAttached applied patch for reference. Patch applied to standard HEAD and available in nightly and will \nbe in next release: Standard 1.1.1.", "is_private": false, "id": 57238, "creator": "justyna.horwat@sun.com", "time": "2004-05-11T23:18:37Z", "bug_id": 25967, "creation_time": "2004-05-11T23:18:37Z", "attachment_id": null}, {"count": 5, "attachment_id": null, "bug_id": 25967, "text": "Gentlemen,\nif I understood correctly, you moved get() out of synchronized block while \nleft put() inside. I'm not a Java guru but to me this looks like bad solution. \nFirst of all, Sun's documentation:\n\n\"Note that this implementation is not synchronized. If multiple threads access \nthis map concurrently, and at least one of the threads modifies the map \nstructurally, it must be synchronized externally. (A structural modification \nis any operation that adds or deletes one or more mappings; merely changing \nthe value associated with a key that an instance already contains is not a \nstructural modification.)\"\n\nTo me this text does not say syncronization is needed between modifying \nthreads only. It clearly says if _at least one_ thread modifies hashmap, all \nthreads must be syncronized.\n\nAlthough recent JDKs should not have problems with your implementations, old \nones will. In JDK 1.2 rehash() changes 'table' attribute BEFORE it copies old \nvalues there. That means if get() from one thread arrives when another thread \nalready entered rehash() result is unpredictable.\n\nIf JDK 1.3 is the minimum required for JSTL everything should be Ok and I'm \nterribly sorry for disturbing you. But I din't found such a notices.", "id": 61281, "time": "2004-07-29T00:44:07Z", "creator": "apache@dima.spb.ru", "creation_time": "2004-07-29T00:44:07Z", "tags": [], "is_private": false}, {"count": 6, "tags": [], "bug_id": 25967, "is_private": false, "text": "There are two get's.  One inside the synchronized block, and another outside the\nblock.  This allows data to be retrieved for keys that are already inside the\nMap without blocking on the read.\n\nThe additional get inside the synchronized block will catch the case where two\nthreads request the same key.", "id": 61354, "time": "2004-07-30T03:14:17Z", "creator": "rich_kraft@yahoo.com", "creation_time": "2004-07-30T03:14:17Z", "attachment_id": null}]