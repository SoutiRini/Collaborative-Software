[{"count": 0, "tags": [], "creator": "costin@prodinf.ro", "attachment_id": null, "is_private": false, "id": 175558, "time": "2014-05-30T06:25:38Z", "bug_id": 56580, "creation_time": "2014-05-30T06:25:38Z", "text": "Hello I have identified a memory leak that shows in JSF Mojarra 2.1.21 and the Mojarra team said that it is your responsibility to fix it.\n\nThe Mojarra issue: https://java.net/jira/browse/JAVASERVERFACES-3291 .\nThe problem is that ELUtils stores a static instance of BeanELResolver. Both mojarra and el-api are stored in <tomcat_dir>\\lib dir. On redeploy the BeanELResolver will not refresh the stored classes inside.\nFor more please use the link above."}, {"count": 1, "tags": [], "bug_id": 56580, "attachment_id": null, "id": 175570, "time": "2014-05-31T01:11:49Z", "creator": "chris@christopherschultz.net", "creation_time": "2014-05-31T01:11:49Z", "is_private": false, "text": "There is no class ELUtils in Tomcat.\n\nCan you give more information?"}, {"count": 2, "tags": [], "text": "There is no Class in ELUtils  but there is BeanELResolver(in el-api.jar).\n\nThe ELUtils is in (JSF MOjarra https://github.com/bleathem/mojarra/blob/master/jsf-ri/src/main/java/com/sun/faces/el/ELUtils.java ). The problem is that Jsf jars  and el-api jar are stored in tomcat_dir\\lib directory (shared classloader) and \nafter a while BeanELResolver stores classes for the war classloader and never unloads them on war redeploy.\n\nThe issue is in line 142 from ELUtils.java .The guys from mojarra are saying that the BeanELResolver must be reimplemented so that after redeploy no references to the classes from the war classloader must be holded.\n\nI have analyzed this source code (http://svn.apache.org/repos/asf/tomcat/tc7.0.x/trunk/java/javax/el/BeanELResolver.java) and I think that if the member cache will hold SoftReferences everything will be unloaded . In my perspective I think that it will be ok if you redesign the inner class ConcurrentCache from ELResolver.\n\nThey say that this issue was fixed in Glassfish in their el-api implementation.\n\nIf you like we could talk by Skype and give you more information", "is_private": false, "bug_id": 56580, "id": 175586, "time": "2014-06-02T07:06:53Z", "creator": "costin@prodinf.ro", "creation_time": "2014-06-02T07:06:53Z", "attachment_id": null}, {"count": 3, "tags": [], "creator": "markt@apache.org", "attachment_id": null, "text": "Remove the NEEDINFO status. This report and the linked Mojarra issue has all the required information.\n\nI am wondering at this point if this is a Tomcat bug or not. The cache implementation can certainly be changed to avoid this issue but Mojarra using a static instance of BeanELResolver looks suspicious. I need to look into what - if any - guidance there is in the EL spec about this sort of usage.", "id": 175596, "time": "2014-06-02T13:00:40Z", "bug_id": 56580, "creation_time": "2014-06-02T13:00:40Z", "is_private": false}, {"count": 4, "text": "If you need some help do not hesitate to contact me.", "bug_id": 56580, "is_private": false, "id": 175615, "time": "2014-06-03T12:19:42Z", "creator": "costin@prodinf.ro", "creation_time": "2014-06-03T12:19:42Z", "tags": [], "attachment_id": null}, {"count": 5, "tags": [], "creator": "knst.kolinko@gmail.com", "attachment_id": null, "text": "My look at javax.el.BeanELResolver#cache is that a BeanELResolver that it would be bad to share such cache between web applications.\n\nThe cache keys BeanProperties instances by class name, and not by {class name, class loader}. This creates an ambiguity that is resolved by comparing class references in BeanELResolver#property(...)\n\n> if (props == null || type != props.getType()) {\n\nSharing the same BeanELResolver among applications also means that its cache is also shared, so you cache only 1000 classes globally, instead of 1000 per each.\n\nI may suggest you to apply either one the following work-arounds:\na) Put mojarra into your own WEB-INF/lib directory, instead of sharing those libs among web applications. This should provide you with better performance, as your static copy of BeanELReolver will have cache scoped to your web application.\n\nGenerally it is a bad idea to share libraries between web applications. (You are tied to a specific version of the library. You are more likely to see memory leak issues, such as this one.)\n\nb) Set system property \"org.apache.el.BeanELResolver.CACHE_SIZE\" to the value of \"0\". I think that would disable the cache.\n\n----------------\nRegarding a possible way to improve Tomcat's BeanELResolver, to both avoid a leak and to reduce clash of same class name between class loaders:\n\n- Use 2-level cache, with first level being WeakHashMap<ClassLoader, Cache>. That is if you want to cache 1000 classes per class loader as opposed to 1000 classes globally.\n\nI can say that it would have some negative effect on performance.\nIs it a valid use case to share EL classes such as BeanELResolver between web applications?", "id": 175622, "time": "2014-06-03T21:28:07Z", "bug_id": 56580, "creation_time": "2014-06-03T21:28:07Z", "is_private": false}, {"count": 6, "tags": [], "text": "I think that I will store in WEB-INF/lib all my jars for now", "is_private": false, "bug_id": 56580, "id": 175654, "time": "2014-06-05T09:20:57Z", "creator": "costin@prodinf.ro", "creation_time": "2014-06-05T09:20:57Z", "attachment_id": null}, {"count": 7, "tags": [], "bug_id": 56580, "attachment_id": null, "text": "Hmm. The specification is completely silent on this. There is the odd hint that caching may take place within the EL implementation but no details are provided as to what might be cached or how and, importantly, no API is provided to clear any cache that may exist.\n\nThe Glassfish solution was to use SoftReferences for the cache entries. That only sort of fixes the problem in that the web app class loader could remain in memory until long after the web application is reloaded. We have seen cases in the past where this behavior causes problems for some libraries (and is why we added closeMethod support to resources).\n\nIf the cache was static then we could add a method to clear the cache for a given class loader and call that via reflection when the web application stops. However, making the cache static is going to have all sorts of side-effects - some of which may well be unpleasant. The most obvious of these is a guaranteed memory leak unless you call the clear cache method which most clients won't do.\n\nThe other pure Tomcat solutions are don't cache or to place the Mojarra JARs in the web application rather than $CATALINA_BASE/lib.\n\nMojarra could use per web application instances of BeanELResolver rather than a single static instance. Mojarra should also have the necessary hooks to remove those instances when the web application stops (e.g. ServletContextListener).\n\nIn short, I don't see a way to fix this safely in Tomcat. I think it could be fixed in Mojarra but I don't know that code base so I might be completely wrong. There are a couple of work-arounds: disable the cache, move the Mojarra JARs to WEB=INF/lib.\n\nI agree that there is a problem here and I'd like to fix it in Tomcat if I could but I don't see a way to do that. Given that there are workarounds available I am going to resolve this as WONTFIX.", "id": 175698, "time": "2014-06-06T13:48:41Z", "creator": "markt@apache.org", "creation_time": "2014-06-06T13:48:41Z", "is_private": false}]