[{"count": 0, "tags": [], "bug_id": 43838, "attachment_id": null, "is_private": false, "id": 110402, "time": "2007-11-11T15:39:11Z", "creator": "alec@bdt.co.nz", "creation_time": "2007-11-11T15:39:11Z", "text": "Setup:\n  Apache2.2.3 setup as a reverse proxy, in a test environment ready to replace \na production box.\n\nProblem:\n  Excessive 'If-Modified-Since' traffic to upstream server.\n\nCause:\n   Every night htcacheclean is run.\n   A returning Client requests an object/file using 'If-Modifed-Since' in the \nheader, as the client has locally cached copy.\n\nSymptom:\n   Reverse proxy makes 'If-Modifed-Since' request to upstream server as object \nis not available in cache. Upstream server will reply with '304 Not-Modifed'. \nNote, Proxy still doesn't have a copy. \n\n   The expected action would be for the proxy to get the object, and \nreport '304 Not-Modifed' to the client, so that the next request is served out \nof cache, and no further traffic occurs between proxy and upstream server.\n\nObservation:\n  If the clients cache is cleared, the next request comes from the upstream \nserver, then subsequent requests come from the proxy's cache.\n\nHack:\nIn mod-proxy-http.c we have removed the test 'if r->main' check (snippet \nbelow), which appears to remove the \"If-*\" headers to the upstream server, but \nthis may have other side effects, but gives us the desired operation.\n\n        /* for sub-requests, ignore freshness/expiry headers */\n        // CJW - Ignore Freshness on requests\n        //if (r->main) {\n            if (    !strcasecmp(headers_in[counter].key, \"If-Match\")\n                 || !strcasecmp(headers_in[counter].key, \"If-Modified-Since\")\n                 || !strcasecmp(headers_in[counter].key, \"If-Range\")\n                 || !strcasecmp(headers_in[counter].key, \"If-Unmodified-Since\")\n                 || !strcasecmp(headers_in[counter].key, \"If-None-Match\")) {\n                continue;\n            }\n        //}\n\nHow should this senario really be fixed?"}, {"attachment_id": null, "tags": [], "bug_id": 43838, "is_private": false, "count": 1, "id": 112267, "time": "2007-12-28T18:22:26Z", "creator": "fielding@apache.org", "creation_time": "2007-12-28T18:22:26Z", "text": "The right fix is a configuration directive that tells us the\nproxy is supposed to remove conditionals on a GET when\nthe response is not already in the cache.  Not all sites are\nconcerned about reducing the number of 304 responses from the\nbackend. For example, your solution will mean that anything\nthat mod_cache has decided not to cache for other reasons, such\nas being a low hit potential or simply too big, will result\nin repeated full transfers from the backend instead of 304s.\n\n"}, {"count": 2, "tags": [], "creator": "alec@bdt.co.nz", "is_private": false, "text": "Referring to  http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html\nsection 10.3.5 304 Not Modified\n\n\"If a 304 response indicates an entity not currently cached, then the cache \nMUST disregard the response and repeat the request without the conditional\"\n\nReading the RFC, suggests that no matter what, if the image isn't in cache it \nshould be requested.\n\nOur deployment is an offsite image-cache, with 1Gb connection to internet.\n\nWith our hack, I tend to agree with the concerns of large files (wheter \nmodified or not) being repeatedly requested from the backend should the cache \nserver decide not to cache it due to CacheMaxFileSize or some other reason.\n\nThe sites that are reverse proxied don't have large image files and represent \n~95% of our traffic, the other remaining sites that may have large images are \nnot proxied - the traffic goes over our 10Mb link, versus 1Gb at ISP.\n\nIn general, the hack works for us, but don't want to be maintaining the code \non an on going basis.\n \nIs there any work being done on this?\n\nThanks Alec", "id": 113243, "time": "2008-01-28T17:24:55Z", "bug_id": 43838, "creation_time": "2008-01-28T17:24:55Z", "attachment_id": null}]