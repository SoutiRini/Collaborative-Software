[{"count": 0, "tags": [], "bug_id": 433, "is_private": false, "text": "I suggest that additional logging be added that specifically describes the mapping taking place within the Apache or IIS plugins by modifying the function map_uri_to_worker in jk_uri_worker_map.c.  My version of the function is given below and differs only in the addition of 4 jk_log statements and the removal of one jk_log statement which was made redundant.\r\n\r\n\r\n\r\n\r\nchar *map_uri_to_worker(jk_uri_worker_map_t *uw_map,\r\n                        const char *uri,\r\n                        jk_logger_t *l)\r\n{\r\n    jk_log(l, JK_LOG_DEBUG, \r\n           \"Into jk_uri_worker_map_t::map_uri_to_worker\\n\");    \r\n\r\n    if(uw_map && uri && '/' == uri[0]) {\r\n        unsigned i;\r\n        unsigned best_match = -1;\r\n        unsigned longest_match = 0;\r\n        char clean_uri[4096];\r\n        char *url_rewrite = strstr(uri, JK_PATH_SESSION_IDENTIFIER);\r\n        \r\n        if(url_rewrite) {\r\n            strcpy(clean_uri, uri);\r\n            url_rewrite = strstr(clean_uri, JK_PATH_SESSION_IDENTIFIER);\r\n            *url_rewrite = '\\0';\r\n            uri = clean_uri;\r\n        }\r\n\r\n\t\tjk_log(l, JK_LOG_DEBUG, \"Attempting to map URI %s\\n\", uri);\r\n        for(i = 0 ; i < uw_map->size ; i++) {\r\n\r\n            if(uw_map->maps[i].ctxt_len < longest_match) {\r\n                continue; /* can not be a best match anyway */\r\n            }\r\n\r\n            if(0 == strncmp(uw_map->maps[i].context, \r\n                            uri, \r\n                            uw_map->maps[i].ctxt_len)) {\r\n                if(MATCH_TYPE_EXACT == uw_map->maps[i].match_type) {\r\n                    if(strlen(uri) == uw_map->maps[i].ctxt_len) {\r\n\t\t\t            jk_log(\tl,\r\n\t\t\t            \t\tJK_LOG_DEBUG, \r\n\t\t\t\t\t\t\t\t\"jk_uri_worker_map_t::map_uri_to_worker, Found an exact match %s -> %s\\n\",\r\n\t\t\t\t\t\t\t\tuw_map->maps[i].worker_name,\r\n\t\t\t\t\t\t\t\tuw_map->maps[i].context );\r\n                        return uw_map->maps[i].worker_name;\r\n                    }\r\n                } else if(MATCH_TYPE_CONTEXT == uw_map->maps[i].match_type) {\r\n                    if(uw_map->maps[i].ctxt_len > longest_match) {\r\n\t\t\t            jk_log(\tl,\r\n\t\t\t            \t\tJK_LOG_DEBUG, \r\n\t\t\t\t\t\t\t\t\"jk_uri_worker_map_t::map_uri_to_worker, Found a context match %s -> %s\\n\",\r\n\t\t\t\t\t\t\t\tuw_map->maps[i].worker_name,\r\n\t\t\t\t\t\t\t\tuw_map->maps[i].context );\r\n                        longest_match = uw_map->maps[i].ctxt_len;\r\n                        best_match = i;\r\n                    }\r\n                } else /* suffix match */ {\r\n                    int suffix_start;\r\n                    \r\n                    for(suffix_start = strlen(uri) - 1 ; \r\n                        suffix_start > 0 && '.' != uri[suffix_start]; \r\n                        suffix_start--) \r\n                        ;\r\n                    if('.' == uri[suffix_start]) {\r\n                        const char *suffix = uri + suffix_start + 1;\r\n\r\n                        /* for WinXX, fix the JsP != jsp problems */\r\n#ifdef WIN32                        \r\n                        if(0 == strcasecmp(suffix, uw_map->maps[i].suffix))  {\r\n#else\r\n                        if(0 == strcmp(suffix, uw_map->maps[i].suffix)) {\r\n#endif\r\n                            if(uw_map->maps[i].ctxt_len >= longest_match) {\r\n\t\t\t\t\t            jk_log(\tl,\r\n\t\t\t\t\t            \t\tJK_LOG_DEBUG, \r\n\t\t\t\t\t\t\t\t\t\t\"jk_uri_worker_map_t::map_uri_to_worker, Found a suffix match %s -> *.%s\\n\",\r\n\t\t\t\t\t\t\t\t\t\tuw_map->maps[i].worker_name,\r\n\t\t\t\t\t\t\t\t\t\tuw_map->maps[i].suffix );\r\n                                longest_match = uw_map->maps[i].ctxt_len;\r\n                                best_match = i;\r\n                            }\r\n                        }\r\n                    }                                       \r\n                }\r\n            }\r\n        }\r\n\r\n        if(-1 != best_match) {\r\n            return uw_map->maps[best_match].worker_name;\r\n        } else {\r\n            /*\r\n             * We are now in a security nightmare, it maybe that somebody sent \r\n             * us a uri that looks like /top-secret.jsp. and the web server will \r\n             * fumble and return the jsp content. \r\n             *\r\n             * To solve that we will check for path info following the suffix, we \r\n             * will also check that the end of the uri is not .suffix.\r\n             */\r\n            int fraud = check_security_fraud(uw_map, uri, l);\r\n\r\n            if(fraud >= 0) {\r\n                jk_log(l, JK_LOG_EMERG, \r\n                       \"In jk_uri_worker_map_t::map_uri_to_worker, found a security fraud in [%s]\\n\",\r\n                       uri);    \r\n                return uw_map->maps[fraud].worker_name;\r\n            }\r\n       }        \r\n    } else {\r\n        jk_log(l, JK_LOG_ERROR, \r\n               \"In jk_uri_worker_map_t::map_uri_to_worker, wrong parameters\\n\");    \r\n    }\r\n\r\n    jk_log(l, JK_LOG_DEBUG, \r\n           \"jk_uri_worker_map_t::map_uri_to_worker, done without a match\\n\"); \r\n\r\n    return NULL;\r\n}\r\n", "id": 402, "time": "2001-01-11T14:09:21Z", "creator": "dev@tomcat.apache.org", "creation_time": "2001-01-11T14:09:21Z", "attachment_id": null}]