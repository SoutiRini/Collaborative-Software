[{"count": 0, "tags": [], "bug_id": 59001, "text": "My workspace contains an exclamation in the path, unfortunately when Tomcat tries to load the jar files, entire path is broken into pieces when the second exclamation mark is encountered.\n\nLet me know if you need more information.\n\nThis is the stacktrace -\n\nFeb 12, 2016 11:45:27 PM org.apache.catalina.startup.TldConfig tldScanJar\nWARNING: Failed to process JAR [jar:file:/G:/TEST!Maven!/.metadata/.plugins/org.eclipse.wst.server.core/tmp0/wtpwebapps/test/WEB-INF/lib/asm-3.3.1.jar!/] for TLD files\njava.io.FileNotFoundException: G:\\TEST!Maven (The system cannot find the file specified)\n\tat java.util.zip.ZipFile.open(Native Method)\n\tat java.util.zip.ZipFile.<init>(ZipFile.java:219)\n\tat java.util.zip.ZipFile.<init>(ZipFile.java:149)\n\tat java.util.jar.JarFile.<init>(JarFile.java:166)\n\tat java.util.jar.JarFile.<init>(JarFile.java:103)\n\tat sun.net.www.protocol.jar.URLJarFile.<init>(URLJarFile.java:93)\n\tat sun.net.www.protocol.jar.URLJarFile.getJarFile(URLJarFile.java:69)\n\tat sun.net.www.protocol.jar.JarFileFactory.get(JarFileFactory.java:109)\n\tat sun.net.www.protocol.jar.JarURLConnection.connect(JarURLConnection.java:122)\n\tat sun.net.www.protocol.jar.JarURLConnection.getJarFile(JarURLConnection.java:89)\n\tat org.apache.tomcat.util.scan.FileUrlJar.<init>(FileUrlJar.java:41)\n\tat org.apache.tomcat.util.scan.JarFactory.newInstance(JarFactory.java:34)\n\tat org.apache.catalina.startup.TldConfig.tldScanJar(TldConfig.java:489)\n\tat org.apache.catalina.startup.TldConfig.access$100(TldConfig.java:59)\n\tat org.apache.catalina.startup.TldConfig$TldJarScannerCallback.scan(TldConfig.java:305)\n\tat org.apache.tomcat.util.scan.StandardJarScanner.process(StandardJarScanner.java:259)\n\t at org.apache.tomcat.util.scan.StandardJarScanner.scan(StandardJarScanner.java:178)\n\tat org.apache.catalina.startup.TldConfig.execute(TldConfig.java:278)\n\tat org.apache.catalina.startup.TldConfig.lifecycleEvent(TldConfig.java:569)\n\tat org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119)\n\tat org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:90)\n\tat org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5322)\n\tat org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150)\n\tat org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1559)\n\tat org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1549)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n\tat java.lang.Thread.run(Thread.java:745)\n\nFeb 12, 2016 11:45:27 PM org.apache.catalina.core.StandardContext startInternal\nSEVERE: Error getConfigured\nFeb 12, 2016 11:45:27 PM org.apache.catalina.core.StandardContext startInternal\nSEVERE: Context [/test] startup failed due to previous errors", "id": 188405, "time": "2016-02-13T20:00:05Z", "creator": "prashu16k@gmail.com", "creation_time": "2016-02-13T20:00:05Z", "is_private": false, "attachment_id": null}, {"count": 1, "tags": [], "bug_id": 59001, "text": "Typically, the ! character means that the sought resource is actually inside of a JAR file. The URL you have has a ! after an on-disk path, but not one that (looks like it) is a JAR file (G:\\TEST).\n\nThat looks like an invalid JAR URL to me.\n\nOr has Tomcat built a bad URL out of some other path?\n\nOr, are you saying that your on-disk path is actually \"G:\\TEST!Maven!\"?\n\nThis may be a pathological use case, but neither NTFS nor any of the *NIX filesystems I checked have any prohibition against ! characters, which are special for JAR URLs. (None of those filesystems prohibit # marks, either, which could potentially be a problem.)", "id": 188474, "time": "2016-02-16T15:40:12Z", "creator": "chris@christopherschultz.net", "creation_time": "2016-02-16T15:40:12Z", "is_private": false, "attachment_id": null}, {"count": 2, "text": "My disk path is \"G:\\TEST!Maven!\\...\"\n\nIndeed, it is a corner use case. \nIs there any reason why tomcat is solely relying on \"!\" to identify end of the string? When we know that is the path to find specified resource, why \"!\" in the end?", "bug_id": 59001, "is_private": false, "id": 188484, "time": "2016-02-16T19:51:28Z", "creator": "prashu16k@gmail.com", "creation_time": "2016-02-16T19:51:28Z", "tags": [], "attachment_id": null}, {"count": 3, "tags": [], "bug_id": 59001, "is_private": false, "text": "Honestly, I'm surprised that it's failing where it is: I would have expected it to fail saying that \"G:\\TEST\" didn't exist.\n\nThis isn't Tomcat doing this; it's the combination of a large number of components all of which are using URLs for certain purposes. There are many many corner cases where the JRE itself will fall-over even if Tomcat wasn't involved.\n\nI don't believe Tomcat massages any of the URLs it's processing, so there may be an opportunity for Tomcat to escape the ! characters in an on-disk filename (i.e. \"!\" -> \"%21\"). But like I said, there's always more and more edge-cases and encoding once means possibly encoding multiple times (and sometimes having to decode a few times, too). It's just a giant mess.", "id": 188486, "time": "2016-02-16T22:09:19Z", "creator": "chris@christopherschultz.net", "creation_time": "2016-02-16T22:09:19Z", "attachment_id": null}, {"attachment_id": null, "tags": [], "bug_id": 59001, "is_private": false, "count": 4, "id": 188487, "time": "2016-02-16T22:59:52Z", "creator": "prashu16k@gmail.com", "creation_time": "2016-02-16T22:59:52Z", "text": "JarURLConnection is responsible for the mishap. As per java doc \"!/\" is a terminator for the jar file. That's the reason why it is failing at G:/TEST!Maven not G:/TEST\n\nAnd whatever comes after the \"!/\" becomes the context within the jar.\n\nJava doc link - https://docs.oracle.com/javase/7/docs/api/java/net/JarURLConnection.html\n\nSorry for the confusion.\n\n-Jay"}, {"attachment_id": null, "tags": [], "bug_id": 59001, "is_private": false, "count": 5, "id": 188519, "time": "2016-02-17T20:09:44Z", "creator": "chris@christopherschultz.net", "creation_time": "2016-02-17T20:09:44Z", "text": "No problem. The only question is whether or not Tomcat knows at the time that the URL it's building is a physical on-disk resource. If Tomcat does know this, it can escape special characters like \"!\"."}, {"count": 6, "tags": [], "bug_id": 59001, "text": "I really wanted to fix this but I'm not sure that supporting this use case is worth the cost.\n\nThere are two places I have found (so far) where changes would be required. The first is during start-up to ensure that the paths used to construct the URLs for the class loaders escape \"!/\" to \"%21/\".\n\nThe second is in the web resources implementation where FileResource.getURL() needs to escape \"!/\" to \"%21/\".\n\nThe problem stems from the fact that the only way to do this escaping (that I have been able to find) is URL -> toString() -> replaceAll() -> new URL(). And that is relatively expensive.\n\nI'm not concerned about startup. That is a one-off cost. What concerns me is the performance impact of adding this to FileResource.getURL(). That gets called a lot. I'm concerned that the impact of adding this escaping is going to be measurable for end users.\n\nThe other option is to take the position that anytime code constructs a jar URL, that code is responsible for ensuring that any !/ sequences in the path it uses to construct that URL are escaped. While we could do this in Tomcat (there are ~20 places we'd need to fix this), I suspect a whole bunch of third-party code won't handle this correctly. And this is before we get into the mess that is JARs in WARs.\n\nGiven that most users don't need this (I don't recall seeing this issue reported previously and that's going back to Tomcat 4.1.x) I'm leaning heavily towards WONTFIX. There is going to need to be a really good reason to fix this to change my mind.", "id": 188693, "time": "2016-02-22T22:28:28Z", "creator": "markt@apache.org", "creation_time": "2016-02-22T22:28:28Z", "is_private": false, "attachment_id": null}, {"count": 7, "text": "I'm having similar problem but with + sign. Our build system (gradle) creates executable war with Mercurial revision hash. Sometimes this hash can contain \"+\" as a last character ala \"kalkulaator-f83780e3571e+.war\"\n\n\nnow when we try to run this war (embedded tomcat 8.0.30) jps will not work. If I rename war to \"kalkulaator-f83780e3571e.war\" everything is ok.\n\n\"java -jar build\\libs\\kalkulaator-f83780e3571e+.war\"\n\n...\n\n\"\n...\n2016-02-23 18:00:00,466 WARN  UUID [o.a.t.u.s.StandardJarScanner] - Failed to scan JAR [jar:file:/C:/Users/desin/code/kalk/build/libs/kalkulaator-f83780e3571e+.war!/WEB-INF/lib/jstl-1.2.jar] from /WEB-INF/lib\njava.io.FileNotFoundException: JAR entry WEB-INF/lib-provided/tomcat-embed-core-8.0.30.jar!/javax/servlet/resources/web-jsptaglibrary_1_2.dtd not found in C:\\Users\\desin\\code\\kalk\\build\\libs\\kalkulaator-f83780e3571e+.war\n        at sun.net.www.protocol.jar.JarURLConnection.connect(JarURLConnection.java:142) ~[na:1.8.0_73]\n        at sun.net.www.protocol.jar.JarURLConnection.getInputStream(JarURLConnection.java:150) ~[na:1.8.0_73]\n        at com.sun.org.apache.xerces.internal.impl.XMLEntityManager.setupCurrentEntity(XMLEntityManager.java:623) ~[na:1.8.0_73]\n        at com.sun.org.apache.xerces.internal.impl.XMLEntityManager.startEntity(XMLEntityManager.java:1305) ~[na:1.8.0_73]\n        at com.sun.org.apache.xerces.internal.impl.XMLEntityManager.startDTDEntity(XMLEntityManager.java:1271) ~[na:1.8.0_73]\n        at com.sun.org.apache.xerces.internal.impl.XMLDTDScannerImpl.setInputSource(XMLDTDScannerImpl.java:263) ~[na:1.8.0_73]\n        at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl$DTDDriver.dispatch(XMLDocumentScannerImpl.java:1167) ~[na:1.8.0_73]\n        at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl$DTDDriver.next(XMLDocumentScannerImpl.java:1050) ~[na:1.8.0_73]\n        at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl$PrologDriver.next(XMLDocumentScannerImpl.java:964) ~[na:1.8.0_73]\n        at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl.next(XMLDocumentScannerImpl.java:606) ~[na:1.8.0_73]\n        at com.sun.org.apache.xerces.internal.impl.XMLNSDocumentScannerImpl.next(XMLNSDocumentScannerImpl.java:118) ~[na:1.8.0_73]\n        at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanDocument(XMLDocumentFragmentScannerImpl.java:510) ~[na:1.8.0_73]\n        at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:848) ~[na:1.8.0_73]\n        at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:777) ~[na:1.8.0_73]\n        at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:141) ~[na:1.8.0_73]\n        at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.parse(AbstractSAXParser.java:1213) ~[na:1.8.0_73]\n        at com.sun.org.apache.xerces.internal.jaxp.SAXParserImpl$JAXPSAXParser.parse(SAXParserImpl.java:643) ~[na:1.8.0_73]\n        at org.apache.tomcat.util.digester.Digester.parse(Digester.java:1451) ~[tomcat-embed-core-8.0.30.jar!/:8.0.30]\n        at org.apache.tomcat.util.descriptor.tld.TldParser.parse(TldParser.java:76) ~[tomcat-embed-core-8.0.30.jar!/:8.0.30]\n        at org.apache.jasper.servlet.TldScanner.parseTld(TldScanner.java:279) [tomcat-embed-jasper-8.0.30.jar!/:8.0.30]\n        at org.apache.jasper.servlet.TldScanner$TldScannerCallback.scan(TldScanner.java:315) ~[tomcat-embed-jasper-8.0.30.jar!/:8.0.30]\n        at org.apache.tomcat.util.scan.StandardJarScanner.process(StandardJarScanner.java:306) ~[tomcat-embed-core-8.0.30.jar!/:8.0.30]\n        at org.apache.tomcat.util.scan.StandardJarScanner.scan(StandardJarScanner.java:162) ~[tomcat-embed-core-8.0.30.jar!/:8.0.30]\n        at org.apache.jasper.servlet.TldScanner.scanJars(TldScanner.java:262) [tomcat-embed-jasper-8.0.30.jar!/:8.0.30]\n        at org.apache.jasper.servlet.TldScanner.scan(TldScanner.java:106) [tomcat-embed-jasper-8.0.30.jar!/:8.0.30]\n        at org.apache.jasper.servlet.JasperInitializer.onStartup(JasperInitializer.java:103) [tomcat-embed-jasper-8.0.30.jar!/:8.0.30]\n        at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5244) [tomcat-embed-core-8.0.30.jar!/:8.0.30]\n        at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150) [tomcat-embed-core-8.0.30.jar!/:8.0.30]\n        at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1408) [tomcat-embed-core-8.0.30.jar!/:8.0.30]\n        at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1398) [tomcat-embed-core-8.0.30.jar!/:8.0.30]\n        at java.util.concurrent.FutureTask.run(FutureTask.java:266) [na:1.8.0_73]\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_73]\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_73]\n        at java.lang.Thread.run(Thread.java:745) [na:1.8.0_73]\n\"", "bug_id": 59001, "is_private": false, "id": 188723, "time": "2016-02-23T16:22:16Z", "creator": "desinformatsioon@gmail.com", "creation_time": "2016-02-23T16:22:16Z", "tags": [], "attachment_id": null}, {"count": 8, "tags": [], "creator": "chris@christopherschultz.net", "text": "(In reply to Mark Thomas from comment #6)\n> I really wanted to fix this but I'm not sure that supporting this use case\n> is worth the cost.\n> \n> There are two places I have found (so far) where changes would be required.\n> The first is during start-up to ensure that the paths used to construct the\n> URLs for the class loaders escape \"!/\" to \"%21/\".\n> \n> The second is in the web resources implementation where\n> FileResource.getURL() needs to escape \"!/\" to \"%21/\".\n> \n> The problem stems from the fact that the only way to do this escaping (that\n> I have been able to find) is URL -> toString() -> replaceAll() -> new URL().\n> And that is relatively expensive.\n> \n> I'm not concerned about startup. That is a one-off cost. What concerns me is\n> the performance impact of adding this to FileResource.getURL(). That gets\n> called a lot. I'm concerned that the impact of adding this escaping is going\n> to be measurable for end users.\n\nWhat about mutating the \"classpath\" used by a ClassLoader when it's constructed? That way, we could take the hit of URL -> String -> URL maybe one time for a context. I don't understand the implications of the way the ClassLoader works, so I may be making an insane proposal ;)\n\n> The other option is to take the position that anytime code constructs a jar\n> URL, that code is responsible for ensuring that any !/ sequences in the path\n> it uses to construct that URL are escaped. While we could do this in Tomcat\n> (there are ~20 places we'd need to fix this), I suspect a whole bunch of\n> third-party code won't handle this correctly. And this is before we get into\n> the mess that is JARs in WARs.\n> \n> Given that most users don't need this (I don't recall seeing this issue\n> reported previously and that's going back to Tomcat 4.1.x) I'm leaning\n> heavily towards WONTFIX. There is going to need to be a really good reason\n> to fix this to change my mind.\n\nIf we expect external code to do its own URL-escaping, it doesn't really change the current behavior. I don't think that would be a horrible change, since it would make common cases work (where only Tomcat is involved), and it wouldn't break any of the other cases because they would already be broken (right?).", "id": 188788, "time": "2016-02-24T21:59:25Z", "bug_id": 59001, "creation_time": "2016-02-24T21:59:25Z", "is_private": false, "attachment_id": null}, {"count": 9, "tags": [], "creator": "markt@apache.org", "attachment_id": null, "text": "(In reply to Christopher Schultz from comment #8)\n> (In reply to Mark Thomas from comment #6)\n\n> > I'm not concerned about startup. That is a one-off cost. What concerns me is\n> > the performance impact of adding this to FileResource.getURL(). That gets\n> > called a lot. I'm concerned that the impact of adding this escaping is going\n> > to be measurable for end users.\n> \n> What about mutating the \"classpath\" used by a ClassLoader when it's\n> constructed? That way, we could take the hit of URL -> String -> URL maybe\n> one time for a context. I don't understand the implications of the way the\n> ClassLoader works, so I may be making an insane proposal ;)\n\nThat is exactly what I am proposing for start-up. It is a one-off cost so no big deal.\n\n> > The other option is to take the position that anytime code constructs a jar\n> > URL, that code is responsible for ensuring that any !/ sequences in the path\n> > it uses to construct that URL are escaped. While we could do this in Tomcat\n> > (there are ~20 places we'd need to fix this), I suspect a whole bunch of\n> > third-party code won't handle this correctly. And this is before we get into\n> > the mess that is JARs in WARs.\n> > \n> > Given that most users don't need this (I don't recall seeing this issue\n> > reported previously and that's going back to Tomcat 4.1.x) I'm leaning\n> > heavily towards WONTFIX. There is going to need to be a really good reason\n> > to fix this to change my mind.\n> \n> If we expect external code to do its own URL-escaping, it doesn't really\n> change the current behavior. I don't think that would be a horrible change,\n> since it would make common cases work (where only Tomcat is involved), and\n> it wouldn't break any of the other cases because they would already be\n> broken (right?).\n\nI'm still on the fence about this (and that is without looking at the JAR in WAR issue).\n\nI've thought of a few ways we could make FileResource.getURL() handle this without being horribly slow unless you have a path that includes a !/ sequence (in which case being slow is the price you pay for it working) but I'm becoming less convinced that this is the way to go.\n\nThe more I think about it, the more I am leaning towards the view that if you take a string and use it to construct a JAR URL then you are responsible for making sure any \"!/\" sequences are escaped. Before heading down that route I'd want to check how often the ~20 places we'd need to do this are called.", "id": 188791, "time": "2016-02-24T22:58:49Z", "bug_id": 59001, "creation_time": "2016-02-24T22:58:49Z", "is_private": false}, {"count": 10, "text": "Either it get's fixed in the next releases or not, I strongly feel there has to be some exception handling which doesn't trick developers to invest more energy on debugging possible root cause within their application.", "bug_id": 59001, "is_private": false, "id": 188984, "time": "2016-03-01T03:10:50Z", "creator": "prashu16k@gmail.com", "creation_time": "2016-03-01T03:10:50Z", "tags": [], "attachment_id": null}, {"count": 11, "text": "Having looked at where we construct Jar URLs (and URLs that may be used to later build Jar URLs) there were a handful of places where we needed to add appropriate escaping. I've implemented the escaping for 9.0.x (it will be in 9.0.0.M4 onwards) and I'm looking at back-porting it. Given the various refactorings I'm not sure how far back this fix will be back-ported.\n\nRegarding the use of '+' in file names (comment #7) that looks like a separate issue. Please open a separate BZ issue for that and provide s set of steps to reproduce the issue.", "bug_id": 59001, "is_private": false, "id": 188999, "time": "2016-03-01T14:26:35Z", "creator": "markt@apache.org", "creation_time": "2016-03-01T14:26:35Z", "tags": [], "attachment_id": null}, {"count": 12, "tags": [], "creator": "markt@apache.org", "attachment_id": null, "text": "The fix has been back-ported to 8.0.x for 8.0.33 onwards and to 7.0.x for 7.0.69 onwards.", "id": 189010, "time": "2016-03-01T23:05:18Z", "bug_id": 59001, "creation_time": "2016-03-01T23:05:18Z", "is_private": false}]