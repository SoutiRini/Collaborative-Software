[{"count": 0, "text": "SCRIPT_NAME is passed incorrectly to PHP depending on where you place\nthe mod_rewrite rule. If it is placed in .htaccess or under <Directory>, the \nSCRIPT_NAME is initialized correctly but when you place the same rule under \n<VirtualHost> it is an empty string (or any other bogus value).\n\nI wasn't sure if it was an Apache or PHP bug and I have posted it on PHP \nbugtracker first. They claim it's an Apache bug:\n\nhttp://bugs.php.net/bug.php?id=38141\n\nThe rule I'm using is:\n\n    RewriteEngine On\n    RewriteCond %{SCRIPT_FILENAME} !-f\n    RewriteCond %{SCRIPT_FILENAME} !-d\n    RewriteRule ^(.*)$ /index.php/$1\n\nOr (it's not relevant - both have the same result):\n\n    RewriteEngine On\n    RewriteRule !\\.(js|ico|gif|jpg|png|css|swf)$ index.php\n\nApache2 PHP SAPI. Apache version is 2.0.58 but I guess it may not be\nrelevant as it was reported by number of people (though I don't know what their \nsetups are). \n\nTested on Gentoo Linux.", "creator": "martel@post.pl", "attachment_id": null, "id": 91532, "time": "2006-07-24T11:08:23Z", "bug_id": 40102, "creation_time": "2006-07-24T11:08:23Z", "tags": [], "is_private": false}, {"count": 1, "text": "It seems that if you place the rules under VirtualHost more things are mangled \n- ie. PATH_INFO. \n\nFor example, for virtual host of test.nebula.intranet and root dir the \nvariables are initialized as follows:\n\n$_SERVER['DOCUMENT_ROOT'] = '/var/www/localhost/htdocs/test'\n$_SERVER['SCRIPT_FILENAME'] = '/var/www/localhost/htdocs/test/index.php'\n$_SERVER['REQUEST_URI'] = '/'\n$_SERVER['SCRIPT_NAME'] = ''\n$_SERVER['PATH_INFO'] = '/index.html' // OMG!\n\nAnd now with deeper URL where PATH_INFO should be initialized - (SCRIPT_NAME is \nstill wrong):\n\n$_SERVER['DOCUMENT_ROOT'] = '/var/www/localhost/htdocs/test'\n$_SERVER['SCRIPT_FILENAME'] = '/var/www/localhost/htdocs/test/index.php'\n$_SERVER['REQUEST_URI'] = '/archive/2006/05'\n$_SERVER['SCRIPT_NAME'] = ''\n$_SERVER['PATH_INFO'] = '/archive/2006/05'\n\nSCRIPT_NAME should be '/index.php' in both of those examples.", "creator": "martel@post.pl", "attachment_id": null, "id": 91847, "time": "2006-08-03T08:58:01Z", "bug_id": 40102, "creation_time": "2006-08-03T08:58:01Z", "tags": [], "is_private": false}, {"count": 2, "tags": [], "bug_id": 40102, "text": "It still doesn't work on apache 2.0.59.", "id": 91850, "time": "2006-08-03T09:38:01Z", "creator": "martel@post.pl", "creation_time": "2006-08-03T09:38:01Z", "is_private": false, "attachment_id": null}, {"count": 3, "tags": [], "bug_id": 40102, "attachment_id": null, "id": 91851, "time": "2006-08-03T09:48:07Z", "creator": "nick@webthing.com", "creation_time": "2006-08-03T09:48:07Z", "is_private": false, "text": "What happens if you run the PHP script as CGI?"}, {"attachment_id": null, "tags": [], "bug_id": 40102, "text": "As a CGI script for URL of: http://test.nebula.intranet/archive/2006/05 values \nare set to:\n\n$_SERVER['DOCUMENT_ROOT'] = string(0) \n$_SERVER['SCRIPT_FILENAME'] = string(40) /var/www/localhost/htdocs/test/\nindex.cgi\n$_SERVER['REQUEST_URI'] = string(16) /archive/2006/05\n$_SERVER['SCRIPT_NAME'] = string(40) /var/www/localhost/htdocs/test/index.cgi\n$_SERVER['PATH_INFO'] = string(16) /archive/2006/05\n\nShould document root be empty? I don't have much experience with PHP working as \na CGI script. I have added a handler to <VirtualHost> (AddHandler cgi-script\n .cgi), added ExecCGI to Options under <Directory> and changed RewriteRule to \n\"RewriteRule ^(.*)$ /index.cgi/$1\".", "count": 4, "id": 91853, "time": "2006-08-03T10:32:07Z", "creator": "martel@post.pl", "creation_time": "2006-08-03T10:32:07Z", "is_private": false}, {"count": 5, "tags": [], "text": "The values are the same in every case when run as a CGI. It does not matter if \nthe rule is placed under <VirtualHost>, <Directory> or in .htaccess file. It \nseems it's a SAPI problem.", "attachment_id": null, "id": 91856, "creator": "martel@post.pl", "time": "2006-08-03T11:32:50Z", "bug_id": 40102, "creation_time": "2006-08-03T11:32:50Z", "is_private": false}, {"count": 6, "tags": [], "text": "If CGI gets the expected SCRIPT_NAME, I infer the problem isn't in \nmod_rewrite, but somewhere within mod_php.  That is not an apache product.  \nPlease report the bug to its maintainers.", "attachment_id": null, "id": 91858, "creator": "nick@webthing.com", "time": "2006-08-03T12:21:32Z", "bug_id": 40102, "creation_time": "2006-08-03T12:21:32Z", "is_private": false}, {"count": 7, "tags": [], "bug_id": 40102, "text": "FWIW, if you want to tell the mod_php folks how to fix it, this is my guess:\n\n(1) SCRIPT_NAME is set by ap_add_cgi_vars in Apache's \"util_script\".\n(2) PHP presumably calls that somewhere - unless it's reinvented that wheel.\n(3) The bug *looks like* a case of PHP calling it too early - specifically \n*before* the rewrite happened - so of course there was no SCRIPT_NAME.\n(4) So a fix would be for mod_php to call it later.  Or maybe even call it \ntwice, if the early call is unavoidable.", "id": 91859, "time": "2006-08-03T13:04:23Z", "creator": "nick@webthing.com", "creation_time": "2006-08-03T13:04:23Z", "is_private": false, "attachment_id": null}, {"count": 8, "tags": [], "bug_id": 40102, "text": "Thank you, Nick. I will post your remarks on PHP bug tracker.", "id": 91860, "time": "2006-08-03T13:12:07Z", "creator": "martel@post.pl", "creation_time": "2006-08-03T13:12:07Z", "is_private": false, "attachment_id": null}, {"count": 9, "text": "Here is the way it works:\n1) ap_process_http_connection() is called when processing HTTP request;\n2) ap_process_http_connection() calls ap_read_request() in order to create request struct;\n3) ap_read_request() calls ap_getword_white(), which returns the original URI, not the file used to \nhandle the request (this is how it works here, with PHP 5.2 and Apache 2.0.55);\n4) ap_read_request() sets request->uri to the result of ap_getword_white();\n5) finally PHP request handler is called, which in turn calls ap_add_cgi_vars() to get the variables.\n\nThe way it works is the very same in both cases and it doesn't depend on the place where \nmod_rewrite directives were set, so I don't see how PHP could call ap_add_cgi_vars() too early or \ntoo late.", "creator": "tony2001@php.net", "attachment_id": null, "id": 91917, "time": "2006-08-05T19:35:23Z", "bug_id": 40102, "creation_time": "2006-08-05T19:35:23Z", "tags": [], "is_private": false}, {"count": 10, "tags": [], "creator": "arnaud.lb@gmail.com", "attachment_id": null, "text": "I can reproduce this bug with a simple shell script:\n\n----------\n#!/bin/sh\ncat <<HEADERS\nStatus: 200 Ok\nContent-Type: text/plain\n\nHEADERS\n\nexport\n----------\n\nI added the following the <VirtualHost> to test that:\n\nSetHandler cgi-script\n<Directory /var/www>\n Options +ExecCGI\n</Directory>\n\nAnd the rewrite rules:\n\nRewriteEngine On\nRewriteCond %{SCRIPT_FILENAME} !-f\nRewriteCond %{SCRIPT_FILENAME} !-d\nRewriteRule ^(.*)$ /test.sh/$1\n\n\nWhen the script is executed \"export\" shows that SCRIPT_NAME is empty. This appends only when the URL is rewritten to a one which has a path info component:\n\nTriggers the bug:\n\nRewriteRule ^(.*)$ /test.sh/$1\n\nDoes not bug:\n\nRewriteRule ^(.*)$ /test.sh\n", "id": 122855, "time": "2008-11-25T17:14:20Z", "bug_id": 40102, "creation_time": "2008-11-25T17:14:20Z", "is_private": false}, {"count": 11, "tags": [], "creator": "bobsiegen@googlemail.com", "attachment_id": null, "text": "(In reply to comment #0)\n> SCRIPT_NAME is passed incorrectly to PHP depending on where you place\n> the mod_rewrite rule. If it is placed in .htaccess or under <Directory>, the \n> SCRIPT_NAME is initialized correctly but when you place the same rule under \n> <VirtualHost> it is an empty string (or any other bogus value).\n[...]\n> The rule I'm using is:\n> \n>     RewriteEngine On\n>     RewriteCond %{SCRIPT_FILENAME} !-f\n>     RewriteCond %{SCRIPT_FILENAME} !-d\n>     RewriteRule ^(.*)$ /index.php/$1\n\nIn per-server context, mod_rewrite acts by default as an URI-to-filename translator. If you add the [PT] flag, mod_rewrite will copy the rewrite result back to r->uri and does not map the request to the filesystem, i.e. another URI-to-filename translator will map the request to the filesystem. In that case (if you use the PT-flag) SCRIPT_NAME seems to be set correctly.\n\nBTW: I'm wondering how your conditions will work in per-server context since w/o a URI-to-filename translation SCRIPT_FILENAME cannot contain the physical path of the request, which is needed in oder to check for existing files or dirs. See the docs bug 16402.\n\n\nUsing apache 2.2.10 (but I think this problem is in trunk, too):\n\n- If e.g. php is used as a module\nOriginal request_uri /bar ; rewrite result /foo.php \nIn that case (mod_php), and if there is no internal redirect, SCRIPT_NAME contains in my environment w/o the PT-flag the value of r->uri (/bar) and with the PT-flag /foo.php. ENV PATH_INFO - rewrite result /foo.php/path - is '/path' and works correct with and w/o the PT-flag.\n\n- If a directive is used which triggers an internal redirect - such as php cgi setup via the Action directive, SCRIPT_NAME will contain the value of the cgi prog.\nOriginal request_uri /bar ; rewrite result /foo.php ; the result of the Action directive is r->uri /php-script/php with path_info /bar:\n\nScriptAlias /php-script/ \"/path/to/php/\"\nAddHandler cgi-php .php\nAction cgi-php /php-script/php\n--> SCRIPT_NAME=/php-script/php (correct with and w/o PT-flag)\nW/o the PT-Flag, PATH_INFO contains /bar (a subrequest for /bar will pass /foo.php to the cgi prog), REDIRECT_URL contains the original request_uri /bar, too (IMHO correct, because mod_rewrite doesn't change r->uri w/o the PT-flag, the only way Aliases can work). But that means that there is no ENV which points to the result of mod_rewrite (/foo.php).\nWith the PT-flag set, PATH_INFO and REDIRECT_URL both contain /foo.php, which is correct.\n\n- Directly executed CGIs such as /cgi/printenv.pl with a config like (not Alias'd nor ScriptAlias'd in another way)\n<Directory \"/var/www/cgi\">\n  Options +ExecCGI\n  AddHandler cgi-script .pl\n</Directory>\nr->uri: /bar ; rewrite result /cgi/printenv.pl\n\nW/o the PT-flag: regardless if PATH_INFO was specified, SCRIPT_NAME contained /bar.\nWith the PT-flag: regardless if PATH_INFO was specified, SCRIPT_NAME contained /cgi/printenv.pl\n\n\nI tried to reproduce an empty SCRIPT_NAME with a rule in per-servr context, but that seems to fail in my environment, I don't know why. Instead, SCRIPT_NAME contained the unchanged r->uri of the initial request if there was no internal redirect or the PT-flag was not set. I think this is correct because mod_rewrite acts in per-server context w/o specifying the PT-flag like an Alias. To my understanding, SCRIPT_NAME represents the physical web view and if it's Alias'd it seems to me complicated if not impossible to get a physical web view.", "id": 123266, "time": "2008-12-12T10:14:45Z", "bug_id": 40102, "creation_time": "2008-12-12T10:14:45Z", "is_private": false}]