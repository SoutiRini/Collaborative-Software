[{"count": 0, "tags": [], "text": "ServletRequest implementor can be being referenced by multiple threads \nits easy to see that every attribute of the Request contains (including maps) can be and will be modified\nthis is unacceptable and must be corrected asap (by introducing synchronized blocks for any code modifying ServletRequest and or attributes of ServletRequest)\n\nOriginally reported by Jess Holle 10 April 2014", "attachment_id": null, "bug_id": 56381, "id": 174438, "time": "2014-04-10T11:48:11Z", "creator": "mgainty@hotmail.com", "creation_time": "2014-04-10T11:48:11Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 56381, "attachment_id": null, "text": "I am perfectly aware that the servlet API makes no guarantees about thread safety of the [Http]ServletRequest interface or implementations thereof.\n\nI also understand that providing general thread-safety in implementation would have performance and/or implementation complexity costs that may not be appropriate.\n\nAs such I've been calling getParameterMap() and the like in my first servlet filter -- thus allowing other threads to access this data after this point without issues up until the request thread completes work on the request.  There are some really good use cases for this sort of thing -- e.g. monitoring the state of all in-flight requests.\n\nThe real issue here, however, is what occurs if these APIs are invoked after the request thread completes its request work.  It was clear to me that the other threads could get bad data in such a case -- and I'm fine with that.  They should have made a copy of the data if the data acquisition is more than just a \"best effort\" affair.  What was not at all clear is that recycle behavior could allow any bit of code to toss ServletRequest objects to other threads, call methods against these objects too late and completely corrupt later servlet requests!  That's a real safety issue in a larger application.\n\nFor my own monitoring code I've added a read/write lock that ensures that there is no possible race condition between request completion and switching over to a copy of the ServletRequest data.  That's well and good.  What I can't do, however, is keep any other developer from doing something stupid and corrupting unrelated requests, which is a troubleshooting nightmare.\n\nI suppose I could change my servlet filter implementation to use a wrapped ServletRequest object with built-in read/write locking that switched the underlying ServletRequest object to null at the end of the request.  That's a lot of workaround code to avoid intrinsic recycle issues, though.", "id": 174441, "time": "2014-04-10T13:31:41Z", "creator": "jessh@ptc.com", "creation_time": "2014-04-10T13:31:41Z", "is_private": false}, {"count": 2, "tags": [], "bug_id": 56381, "attachment_id": null, "id": 174452, "time": "2014-04-10T15:57:41Z", "creator": "remm@apache.org", "creation_time": "2014-04-10T15:57:41Z", "is_private": false, "text": "Yes, sync if needed + clear the facade objects. This is a long running topic that is well suited for the user list."}]