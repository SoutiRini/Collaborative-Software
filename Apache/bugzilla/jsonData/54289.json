[{"count": 0, "text": "I am writing filter for Apache/2.2.11. \nIn the filter I want to read the POST data of the request. To achieve this I\nwritten a code to read the data from brigade/bucket.\nThe code is working fine if \"ap_get_brigade\" api is called in\n\"AP_MODE_READBYTES\" mode. I am able to read complete post data of the request.\nBut it is failing in case \"ap_get_brigade\" api is called in\n\"AP_MODE_SPECULATIVE\" mode. Actually after reading post data in the filter, post\ndata should not be cleared and it should be accessible to downstream application\nso I want to use AP_MODE_SPECULATIVE.\nI found that in the failure case \"ap_get_brigade\" is returning the same chunk of\ndata. \n\nHere pasting the code snippet:\n\n\nint printPost(request_rec* rqRec)\n{\n    apr_status_t retStatus;\n    apr_bucket_brigade *bb;\n    apr_bucket *bucket;\n    ap_input_mode_t read_mode;\n    int nread = 0;\n    bool seen_eos=false;\n    const char *data;\n    apr_size_t len;\n    int nBytes = 0;\n\t\t\n    const char *contentLengthStr = apr_table_get(rqRec->headers_in,\n\"Content-Length\");\n    nBytes = atoi(contentLengthStr);\n\t\n    fprintf(stderr,\"\\n URI:%s, content-length:%d\", rqRec->uri,nBytes);\n\t\n    char *  freep = (char *)malloc(nBytes + 1);\n    char * qstr = freep;\n    memset(qstr, 0, nBytes + 1);\n\t\n    // Create a bucket brigade to fill data from the input filter\n    bb = apr_brigade_create(rqRec->pool, rqRec->connection->bucket_alloc);\n\n    read_mode = AP_MODE_SPECULATIVE;  //AP_MODE_READBYTES\n    do\n    {\n    // Get the bucket brigade filled from the input filter\n    retStatus = ap_get_brigade(rqRec->input_filters, bb, read_mode,\nAPR_BLOCK_READ, nBytes);\n    if ( retStatus != APR_SUCCESS ){\n       fprintf(stderr,\"\\n Failed ap_get_brigade\");\n       goto endhere; \n    }\n\n    for (bucket = APR_BRIGADE_FIRST(bb);\n\tbucket != APR_BRIGADE_SENTINEL(bb);\n\tbucket = APR_BUCKET_NEXT(bucket)) \n     {\n\tdata = NULL;\n\tlen = 0;\n\tif (APR_BUCKET_IS_EOS(bucket)) {\n    \t    seen_eos = true;\n       \t    break;\n        }\n\n\tif (APR_BUCKET_IS_FLUSH(bucket)) {\n    \t\tcontinue;\n    \t}\n\n\t// bucket_read function sets the data pointer to its internal buffer and\nreturns the len field\n\tretStatus = apr_bucket_read(bucket, &data, &len, APR_BLOCK_READ);\n\tif ( retStatus != APR_SUCCESS) {\n\t   fprintf(stderr,\"\\n Failed apr_bucket_read\");\n\t   goto endhere; //return 0;\n\t}\n\t\t\n        fprintf(stderr,\"\\n bucket->length :%d\",bucket->length);\n        fprintf(stderr,\"\\n nread:%d  len :%d op:%d, retStatus:%d\", nread, (int\n)len, (nread + (int )len >nBytes),(int)retStatus);\n        char * tp = (char *)malloc((int )len + 1);\n        memset(tp, 0, len + 1);\n\tmemcpy(tp, data, len);\n\tfprintf(stderr,\"\\n DATA from the current bucket :%s\",tp);\n\tfree(tp);\n\t\t\n    \tif (nread + (int )len > nBytes) {\n\t\tfprintf(stderr,\"\\n Too much POST data: %s\", rqRec->uri);\t\t\t\t\t\t\n\t\tseen_eos = true;\n\t\tbreak;\n\t}\n\n\tmemcpy(qstr, data, len);\n\tqstr += len;\n\tnread += len;\n\n\tif (nread == nBytes)\n\t{\n\t   seen_eos = true;\n\t   break;\n\t}\n     }/* End of For loop*/\n    apr_brigade_cleanup(bb);\n    }\n    while (!seen_eos);\n\nendhere:\n\tfprintf(stderr,\"\\n FINAL POST DATA :%s\",freep);\n    free(freep);\n    return nread;\n}\n \n \nIf I post some data, output  looks like:\n\n URI:/test.cgi, content-length:5537\n bucket->length :764\n nread:0  len :764 op:0, retStatus:0\n DATA from the current bucket :post_data=start1111............................\n bucket->length :764\n nread:764  len :764 op:0, retStatus:0\n DATA from the current bucket :post_data=start1111............................\n bucket->length :764\n nread:1528  len :764 op:0, retStatus:0\n DATA from the current bucket :post_data=start1111............................\n bucket->length :764\n nread:2292  len :764 op:0, retStatus:0\n DATA from the current bucket :post_data=start1111............................\n bucket->length :764\n nread:3056  len :764 op:0, retStatus:0\n DATA from the current bucket :post_data=start1111............................\n bucket->length :764\n nread:3820  len :764 op:0, retStatus:0\n DATA from the current bucket :post_data=start1111............................\n bucket->length :764\n nread:4584  len :764 op:0, retStatus:0\n DATA from the current bucket :post_data=start1111............................\n bucket->length :764\n nread:5348  len :764 op:1, retStatus:0\n DATA from the current bucket :post_data=start1111............................\n Too much POST data: /test.cgi\n FINAL POST DATA\n:post_data=start1111....111post_data=start11111....1111post_data=start111111.\n...111post_data=start11111....1post_data=start111....111post_data=start11111.\n...1111post_data=start111111......\n \n \n In the above code, If I change the read_mode to AP_MODE_READBYTES and post the\nsame request, output looks like:\n \n URI:/test.cgi, content-length:5537\n bucket->length :2024\n nread:0  len :2024 op:0, retStatus:0\n DATA from the current bucket :post_data=start11111............................\n bucket->length :1260\n nread:2024  len :1260 op:0, retStatus:0\n DATA from the current bucket :111111111111111.............................\n bucket->length :2253\n nread:3284  len :2253 op:0, retStatus:0\n DATA from the current bucket :111111111.........................1111111End\n FINAL POST DATA\n:post_data=start11111111111111.........................1111111111111111End\n \n \nUsing same code and setting read_mode to AP_MODE_SPECULATIVE, on windows\nplatform issue is not seen.\nIssue is seen on Linux & Linux64 of RHEL4 version. Post data size need to be more than 5000 bytes.", "creator": "sandip.dongare@gmail.com", "is_private": false, "id": 164047, "time": "2012-12-13T06:18:30Z", "bug_id": 54289, "creation_time": "2012-12-13T06:18:30Z", "tags": [], "attachment_id": null}]