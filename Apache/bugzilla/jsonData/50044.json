[{"count": 0, "tags": [], "bug_id": 50044, "attachment_id": null, "is_private": false, "id": 140472, "time": "2010-10-04T21:39:54Z", "creator": "goberman@msn.com", "creation_time": "2010-10-04T21:39:54Z", "text": "I use NIO HTTP Tomcat connector org.apache.coyote.Http11NioProtocol to implement Comet streaming to Android phones. \nThe application opens 'primary' persistent Comet connection to receive data from the server. Server sends data to the client periodically. Client can terminate this GET by sending \"disconnect\" GET command to the server. The \"disconnect\" command completes server response and cleans up client connection state. Each client has a unique client Id to identify it.\n\nSo the \"connect\" GET looks like: \n/WebContentGateway/Controller?clientId=notimportant&command=connect\n\nAnd disconenct looks like:\n/WebContentGateway/Controller?clientId=notimportant&command=disconnect\nThe problem I uncovered is that \"disconnect\" GET somehow gets truncated and never invoked on the server side (looks like it is \"lost\"). I traced it with Wireshark and Tomcat does receive GET request, but just closes connection without invoking servlet/ sending GET response (the \u201cdisconnect\u201d GET socket connection is obviously different from the \u201cprimary\u201d connection).\nI have both client and servlet code and can provide any support to reproduce the problem.\nThis problem did not exist with build 6.0.16, but can be replicated with the latest Tomcat 6 and 7. It is very important for me to resolve it -  NIO HTTP Tomcat does not look solid it this point.\n\nClient code just send \u201cconnect\u201d command followed by \u201cdisconnect\u201d. There should not be any threading contention because I serialize sending commands in one thread. It hangs on readThread.join(); because \"primary\" thread does not terminate. Also, if I throttle the for loop by putting sleep, the problem does not occur, so it is some sort of a racing condition in Tomcat.\n\nCLIENT CODE:\n\npublic class Test extends AndroidTestCase {\n    private static final String CLIENT_ID_NOTIMPORTANT = \"clientId=notimportant\";\n\tprivate static String url = \"http://172.16.16.33/WebContentGateway/Controller?\";\n\tprivate static InputStream cometConnectionInputStream;\n\tprivate static Thread readThread;\n    \n    public void testConnectDisconnect() {\n\t\tfor (int i = 0; i < 100; i++) {\n\t        try {\n\t            URL cometUrl = new URL(url + CLIENT_ID_NOTIMPORTANT + \"&command=connect\");\n\t            \n\t            HttpURLConnection cometConnection = (HttpURLConnection) cometUrl.openConnection();\n\t            cometConnection.setRequestMethod(\"GET\");\n\t            cometConnection.setDoInput(true);\n\t            cometConnection.setUseCaches(false);\n\t            \n\t            cometConnection.setConnectTimeout(10000);\n\t            cometConnection.setReadTimeout(0);\n\t\n\t            cometConnectionInputStream = cometConnection.getInputStream();\n\t            final CountDownLatch readLatch = new CountDownLatch(1);\n\t            readThread = new Thread(new Runnable() {\n\t\t\t\t\t\n\t\t\t\t\tpublic void run() {\n\t\t\t\t        System.out.println(\"Started Connect GET thread.\");\n\t\t\t\t        readLatch.countDown();\n\t\t\t\t\t    byte[] readConnectionReadBuffer = new byte[10 * 1024];\n\t\t\t\t        try {\n\t\t\t\t            while ((cometConnectionInputStream.read(readConnectionReadBuffer, 0, readConnectionReadBuffer.length)) >= 0) {\n\t\t\t\t            }\n\t\t\t\t        } \n\t\t\t\t        catch (Throwable e) {\n\t\t\t\t        }\n\t\t\t\t        System.out.println(\"Connect GET finished.\");\n\t\t\t\t\t}\n\t\t\t\t});\n\t            readThread.start();\n\t            readLatch.await();\n\t            \n\t            URL disconnectUrl = new URL(url + CLIENT_ID_NOTIMPORTANT + \"&command=disconnect\");\n\t            \n\t\t        System.out.println(\"Sending disconnect\");\n\t            HttpURLConnection disconnectConnection = (HttpURLConnection) disconnectUrl.openConnection();\n\t            disconnectConnection.setRequestMethod(\"GET\");\n\t            disconnectConnection.setDoInput(true);\n\t            disconnectConnection.setUseCaches(false);\n\t            \n\t            disconnectConnection.setConnectTimeout(10000);\n\t            disconnectConnection.setReadTimeout(0);\n\t\t        InputStream disconnectConnectionInputStream = disconnectConnection.getInputStream();\n\t\t\t    byte[] writeConnectionReadBuffer = new byte[10 * 1024];\n\t\t\t\twhile ((disconnectConnectionInputStream.read(writeConnectionReadBuffer, 0, writeConnectionReadBuffer.length)) >= 0) {\n\t\t        }\n\t\t\n\t\t        disconnectConnectionInputStream.close();\n\t\t        \n\t\t        readThread.join();\n\t            \n\t        }\n\t        catch (Exception e) {\n\t        \te.printStackTrace();\n\t        }\n\t\t}\n\t}\n}\n\nSERVER CODE:\npublic class WebFrameworkServlet extends HttpServlet implements CometProcessor {\n\tprivate Map<String, CometClientInfo> cometClientsInfoMap = new ConcurrentHashMap<String, CometClientInfo>();\n\tprivate Map<HttpServletResponse, String> cometResponsesMap = new ConcurrentHashMap<HttpServletResponse, String>();\n\t\n\tpublic void event(CometEvent event) throws IOException, ServletException {\n\t\tHttpServletRequest request = event.getHttpServletRequest();\n\t\tHttpServletResponse response = event.getHttpServletResponse();\n\t\tif (event.getEventType() == CometEvent.EventType.BEGIN) {\n\t\t\tif (request.getParameter(ParamNames.IN_PARAM_COMMAND).equals(ParamNames.COMMAND_NAME_CONNECT)) {\n\t\t\t\t\n\t\t\t\tString clientId = request.getParameter(ParamNames.COMMAND_LOGIN_CLIENT_ID);\n\t\t\t\t\n\t\t\t\tresponse.setHeader(\"pragma\", \"no-cache,no-store\");\n\t\t\t\tresponse.setHeader(\"cache-control\", \"no-cache,no-store,max-age=0,max-stale=0\");\n\t\t\t\t\n\t\t\t\tevent.setTimeout(Integer.MAX_VALUE);\n\t\t\t\t\n\t\t\t\tClient client = new Client(clientId, null, null);\n\t\t\t\t\n\t\t\t\tCometClientInfo cometClientInfo = new CometClientInfo(client, response, 0, event);\n\t\t\t\tcometClientsInfoMap.put(client.getClientId(), cometClientInfo);\n\t\t\t\tcometResponsesMap.put(response, client.getClientId());\n\t\t\t\t\n\t\t\t\tPrintWriter out = response.getWriter();\n\t\t\t\tout.print(\"{\\\"statusCode\\\" : 0}\");\n\t\t\t\tout.flush();\n\t\t\t}\n\t\t\tif (request.getParameter(ParamNames.IN_PARAM_COMMAND).equals(ParamNames.COMMAND_NAME_DISCONNECT)) {\n\t\t\t\tString clientId = request.getParameter(ParamNames.COMMAND_LOGIN_CLIENT_ID);\n\t\t\t\tCometClientInfo existingClientInfo = cometClientsInfoMap.remove(clientId);\n\t\t\t\tresponse.setContentType(\"text/json\");\n\t\t\t\tPrintWriter out = response.getWriter();\n\t\t\t\tout.print(\"{\\\"statusCode\\\" : 0}\");\n\t\t\t\tout.close();\n\t\t\t\t\n\t\t\t\tif (existingClientInfo != null) {\n\t\t\t\t\tcometResponsesMap.remove(existingClientInfo.getResponse());\n\t\t\t\t\texistingClientInfo.getWriter().close();\n\t\t\t\t\texistingClientInfo.getEvent().close();\n\t\t\t\t}\n\t\t\t}\n\t\t} \n\t\telse if (event.getEventType() == CometEvent.EventType.ERROR) {\n\t\t\tevent.close();\n\t\t\t\n\t\t\tString clientId = cometResponsesMap.remove(response);\n\t\t\tif (clientId != null) {\n\t\t\t\tCometClientInfo cometClientInfo = cometClientsInfoMap.remove(clientId);\n\t\t\t\tif (cometClientInfo != null) {\n\t\t\t\t\tcometClientInfo.getClient().setDisconnectTime(System.currentTimeMillis());\n\t\t\t\t}\n\t\t\t}\n\t\t} \n\t\telse if (event.getEventType() == CometEvent.EventType.END) {\n\t\t\tevent.close();\n\t\t\t\n\t\t\tString clientId = cometResponsesMap.remove(response);\n\t\t\tif (clientId != null) {\n\t\t\t\tCometClientInfo cometClientInfo = cometClientsInfoMap.remove(clientId);\n\t\t\t\tif (cometClientInfo != null) {\n\t\t\t\t\tcometClientInfo.getClient().setDisconnectTime(System.currentTimeMillis());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"}, {"count": 1, "tags": [], "bug_id": 50044, "text": "The provided test case is incomplete. I had to reverse engineer a handful of support classes.\n\nTesting with the latest 7.0.x code shows no issues. I don't see any hanging on readThread.join(). The connectors in 7.0.x recently went through a major refactoring that addressed some async threading issues and may have fixed the root cause here too.\n\nNext up, testing with the latest 6.0.x...", "id": 140596, "time": "2010-10-08T11:01:14Z", "creator": "markt@apache.org", "creation_time": "2010-10-08T11:01:14Z", "is_private": false, "attachment_id": null}, {"count": 2, "attachment_id": null, "creator": "markt@apache.org", "is_private": false, "id": 140599, "time": "2010-10-08T11:15:30Z", "bug_id": 50044, "creation_time": "2010-10-08T11:15:30Z", "tags": [], "text": "I do see problems running this on Tomcat 6. Investigating now..."}, {"count": 3, "tags": [], "bug_id": 50044, "text": "No joy tracking this down yet.\n\nAlso, Tomcat 7 seems to be adding a 1s delay to each request.", "id": 140603, "attachment_id": null, "creator": "markt@apache.org", "creation_time": "2010-10-08T13:03:33Z", "time": "2010-10-08T13:03:33Z", "is_private": false}, {"count": 4, "tags": [], "bug_id": 50044, "text": "Similar issues with the APR connector in 6.0.x\n\nThe delay in Tomcat 7 is the selectorTimeout.\n\nStill investigating...", "id": 140646, "time": "2010-10-10T16:36:28Z", "creator": "markt@apache.org", "creation_time": "2010-10-10T16:36:28Z", "is_private": false, "attachment_id": null}, {"count": 5, "tags": [], "bug_id": 50044, "text": "I've tracked down and fixed the issue in the APR/native connector for Tomcat 7. The fix will be in 7.0.4 onwards.", "id": 140651, "time": "2010-10-10T18:11:05Z", "creator": "markt@apache.org", "creation_time": "2010-10-10T18:11:05Z", "is_private": false, "attachment_id": null}, {"count": 6, "tags": [], "creator": "markt@apache.org", "is_private": false, "text": "Best I can tell, the 'lost' GET is triggered by bug 50072. Therefore, I am resolving this as fixed. I'm not marked it as a duplicate as there were some 7.0.x issues that were fixed under this bug reference.", "id": 141884, "time": "2010-11-21T15:09:46Z", "bug_id": 50044, "creation_time": "2010-11-21T15:09:46Z", "attachment_id": null}]