[{"count": 0, "tags": [], "text": "The issue appears if the response has been set before startAsync:\n\nresponse.setStatus(HttpServletResponse.SC_BAD_REQUEST);\nAsyncContext asyncContext = request.startAsync(request, response);\nasyncContext.dispatch();\n\nYou might wonder why would anyone do that? The actual scenario is a bit more complex. It involves a separate thread that completes very fast, even before startAsync is called. \n \nThe resulting stack trace:\njava.lang.IllegalStateException: Calling [asyncComplete()] is not valid for a request with Async state [MUST_DISPATCH]\n\tat org.apache.coyote.AsyncStateMachine.asyncComplete(AsyncStateMachine.java:227)\n\tat org.apache.coyote.http11.Http11Processor.actionInternal(Http11Processor.java:358)\n\tat org.apache.coyote.http11.AbstractHttp11Processor.action(AbstractHttp11Processor.java:871)\n\tat org.apache.coyote.Request.action(Request.java:344)\n\tat org.apache.catalina.core.AsyncContextImpl.complete(AsyncContextImpl.java:92)\n\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:140)\n\tat org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:953)\n\tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:118)\n\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:409)\n\tat org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1044)\n\tat org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:607)\n\tat org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:313)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n\tat java.lang.Thread.run(Thread.java:744)\n\nThe Servlet spec says: \"It is illegal to call startAsync if ..., or if the response has been committed and closed, ...\". \n\nIf that is indeed the reason, a clear error should be raised, and startAsync not be allowed to proceed. Or perhaps it is an issue that can be fixed? For what it's worth it actually works in Jetty even though the spec says it is illegal.", "attachment_id": null, "bug_id": 56042, "id": 172580, "time": "2014-01-21T02:26:34Z", "creator": "rstoyanchev@yahoo.com", "creation_time": "2014-01-21T02:26:34Z", "is_private": false}, {"count": 1, "attachment_id": null, "bug_id": 56042, "is_private": false, "id": 172650, "time": "2014-01-23T22:49:14Z", "creator": "markt@apache.org", "creation_time": "2014-01-23T22:49:14Z", "tags": [], "text": "The problem was in the ErrorReportValve. It was taking over if the response had an error state and async had been started. As part of this it called complete().\n\nThe issue was that if dispatch had been called (e.g. to generate a custom error page in the app) the ErrorReportValve didn't let that happen. IN this case the ErrorReportValve no longer takes over so the dispatch() target can handle the error reporting. It will need to commit the response to stop the ErrorReportValve taking over after the dispatch."}, {"count": 2, "tags": [], "text": "Fixed in 8.0.x for 8.0.0 and 7.0.x for 7.0.51.", "is_private": false, "id": 172651, "creation_time": "2014-01-23T22:49:30Z", "time": "2014-01-23T22:49:30Z", "creator": "markt@apache.org", "bug_id": 56042, "attachment_id": null}]