[{"count": 0, "tags": [], "text": "We have several startup servlets that take a very long time to start (15\nminutes).  Tomcat binds the server socket before it's ready to process requests.\nThis causes all sorts of headaches for us. Ideally, the socket should be bound\nonly when tomcat is really ready to process requests. This can be achieved\nrelatively simply by changing org.apache.tomcat.util.net.PoolTcpEndpoint and\nmoving the server socket binding code from initEndpoint to startEndpoint:\n\n    public void initEndpoint() throws IOException, InstantiationException {\n\t    if(factory==null)\n\t\tfactory=ServerSocketFactory.getDefault();\n    }\n\n    public void startEndpoint() throws IOException, InstantiationException {\n        if (!initialized) {\n            initEndpoint();\n            if(serverSocket==null) {\n                    try {\n                        if (inet == null) {\n                            serverSocket = factory.createSocket(port, backlog);\n                        } else {\n                            serverSocket = factory.createSocket(port, backlog,\ninet);\n                        }\n                    } catch ( BindException be ) {\n                        throw new BindException(be.getMessage() + \":\" + port);\n                    }\n            }\n                if( serverTimeout >= 0 )\n            serverSocket.setSoTimeout( serverTimeout );\n            initialized = true;\n        }\n\tif(isPool) {\n\t    tp.start();\n\t}\n        ...\n\nA corresponding change should be made to the reinitialization code in\nacceptSocket. I'm not sure I understand the subtleties of the reinitialization\ncode, so I'll leave that for the experts. (To my uninitiated eyes,\nreinitializtion should be as simple as stopEndpoint(); startEndpoint();).\n\nThanks\nMoh", "attachment_id": null, "id": 58069, "creator": "mohammad.rezaei@gs.com", "time": "2004-05-25T17:36:31Z", "bug_id": 29208, "creation_time": "2004-05-25T17:36:31Z", "is_private": false}, {"count": 1, "tags": [], "creator": "mohammad.rezaei@gs.com", "attachment_id": 11663, "id": 58087, "creation_time": "2004-05-25T19:40:55Z", "time": "2004-05-25T19:40:55Z", "bug_id": 29208, "text": "Created attachment 11663\npatch file for PoolTcpEndpoint.java", "is_private": false}, {"count": 2, "tags": [], "creator": "mohammad.rezaei@gs.com", "attachment_id": null, "id": 58088, "creation_time": "2004-05-25T19:44:53Z", "time": "2004-05-25T19:44:53Z", "bug_id": 29208, "text": "I re-read the reinitialization part and I think I understand it now (it's more\ncomplicated that just stop/start because we don't want to restart the thread\npool). The patch above creates a new method \"createSocket()\" which is called\nappropriately. \n\nThanks\nMoh", "is_private": false}, {"count": 3, "tags": [], "creator": "remm@apache.org", "attachment_id": null, "id": 58091, "creation_time": "2004-05-25T20:26:16Z", "time": "2004-05-25T20:26:16Z", "bug_id": 29208, "text": "Sorry, I disagree with your proposed change.", "is_private": false}, {"count": 4, "tags": [], "creator": "mohammad.rezaei@gs.com", "attachment_id": null, "id": 58092, "creation_time": "2004-05-25T20:29:23Z", "time": "2004-05-25T20:29:23Z", "bug_id": 29208, "text": "What is the problem? Is the patch bad, or do you think tomcat should really\nstart listening before it can process any requests? \n\nThanks\nMoh", "is_private": false}, {"count": 5, "tags": [], "bug_id": 29208, "text": "I'm sorry to reopen this, but this is a serious production issue for us. Let me\ntry to explain this in more detail. The current behavior of Tomcat is to as follows:\n1) create a socket and bind to a port. This puts the socket in listen mode.\nPlease note that accept() is not called on this socket until step (3). The\nsocket is listening, but it's not processing any requests.\n2) Do a lot of initialization, some of which is under web application control\nvia load-on-startup. I can't find anything in the servlet spec that says a\nload-on-startup servlet must finish init() quickly. In fact, the spec says\n\"Initialization is provided so that a servlet can read persistent configuration\ndata, initialize costly resources (such as JDBC APIbased\nconnections), and perform other one-time activities.\"\n3) Finally start accpeting incoming connections on the socket.\n\nTomcat has no way of knowing how long step (2) will take. We have some servers\nthat take 5 minutes to initialize and some servers that take 2 hours (that's not\na typo). A listening socket that's not accepting will cause incoming connections\nto wait indefinitely (or until the *client* times out). The SO_TIMEOUT parameter\nto the server socket has no effect unless the socket is accepting. In other\nwords, a listening socket that's not accepting is violating the\n\"connectionTimeout\" parameter of the Connector configuration.\n\nA listening socket that's not accepting causes all sorts of problems. For\nexample, it makes it really difficult to monitor the status and health of the\nserver. Monitoring the health of servers is obviously very important for a\nproduction system. It is used, for example, to make high availability server\nfarms for load balancing. A good way of monitoring a server is to send a simple\nrequest and see if the expected answer is returned. If the socket is not open\nyet, the diagnosis is very simple: the server is down. If the socket is open and\naccepting, the expected result is relatively simple to check. If the socket is\nlistening but not accepting, the health monitor will be confused: how long\nshould it wait for the response? is the server down or initializing or just very\nbusy?\n\nThe proposed changes are fairly simple: do all initialization before binding to\nthe port. Tomcat can then guarantee that a properly initialized application can\nrespond in a timely manner to incoming requests.\n\nWe've spent a lot of effort converting from a commercial J2EE server to Tomcat.\nIt would be shame to have to go back because of this.\n\nIs there any downside to the proposal?\n\nThanks\nMoh", "id": 58135, "time": "2004-05-26T14:42:54Z", "creator": "mohammad.rezaei@gs.com", "creation_time": "2004-05-26T14:42:54Z", "is_private": false, "attachment_id": null}, {"count": 6, "tags": [], "bug_id": 29208, "text": "You're right that initialization can take a long time and is not bound by the \nspec.  But your patch has several flaws, and I agree with Remy in vetoing it.  \nThey include the following:\n\n- If one app initializes quickly, and another takes 2 hours, the quicker app is \nnot available until the longer app is done initializing.  This is not \nacceptable for most scenarios.\n\n- If the port is not available (e.g. another process is running on it), then \nall the initialization work is done for nothing.  The current behavior asserts \nthis quickly and doesn't waste time or processing cycles if the port is not \navailable or the JVM is not permitted to bind to it.\n\nI'd type more but I have to run to a meeting.  One suggestion off the top of my \nhead for your monitoring concerns is to run the long-initializaing webapp on \nits own server, and define different monitoring criteria for that server or its \ncluster.\n\nThe idea of binding and accepting requests on the port, instead of binding but \nnot accepting, is intriguing.  Discuss it further on the tomcat-dev list if you \nwill, but not here please.", "id": 58136, "time": "2004-05-26T14:51:11Z", "creator": "yoavs@computer.org", "creation_time": "2004-05-26T14:51:11Z", "is_private": false, "attachment_id": null}, {"count": 7, "tags": [], "creator": "mohammad.rezaei@gs.com", "attachment_id": null, "text": "> - If one app initializes quickly, and another takes 2 hours, the quicker app is \n> not available until the longer app is done initializing.  This is not \n> acceptable for most scenarios.\n\nIf I'm reading the code correctly, this is not true: the StandardService\nimplementation starts all it's containers (and therefore the contexts) before it\nstarts the connectors. see StandardService.start(). In other words, when a\nsingle app that takes 2 hours to initialize, *all* applications are waiting for it.\n\n> - If the port is not available (e.g. another process is running on it), then \n> all the initialization work is done for nothing.  The current behavior asserts \n> this quickly and doesn't waste time or processing cycles if the port is not \n> available or the JVM is not permitted to bind to it.\n\nThis is not a serious concern in a production environment. You can be sure that\nwhen a server takes 2 hours to load, a lot of checks and balances are in place\nto make sure it will boot properly. Besides, for servers that boot quickly, the\ntime difference is not a problem anyway.\n\n> One suggestion off the top of my \n> head for your monitoring concerns is to run the long-initializaing webapp on \n> its own server\n\nThat's already the case, but it still doesn't help the fact that the socket is\nbound and hangs every incoming call.\n\nWould it be alright if I changed this to a request for enhancement and we made\nthis a parameter to the connector?\n\nThanks\nMoh\n\n\n", "id": 58137, "time": "2004-05-26T15:16:29Z", "bug_id": 29208, "creation_time": "2004-05-26T15:16:29Z", "is_private": false}, {"count": 8, "tags": [], "bug_id": 29208, "text": "I agree with Remy and Yoav that tomcat should start responding to requests as\nsoon as possible - at least for tomcat standalone. The right solution for\nwebapps that take a long time to initialize or for webapps that are beeing\ndeployed at runtime and are in initialization state is to imediately send a temp\nerror code (app not ready) to the client. \n\nWhat tomcat is doing today is clearly broken - but the current patch is broken\ntoo. At least for load balancing cases the patch is less broken than tomcat -\nwhen you have 10 tomcats in working state and you restart one, you don't want\nthe restarting tomcat to hold requests until it is completely initialized,\nregardless of how long it take.\n\nMoh - a workaround for your servlets would be to have the init code spawn a\nthread and do the long-running operation in background. This will allow tomcat\nto start quick - and you can control what happens with requests received before\nthe init is ready - for example send \"try again later\" pages. I think this\nshould be the default behavior for tomcat, but patching this in tomcat is much\nmore difficult.\n\nFor load balancing - we need to make sure that the code is able to deal with\nthis situation, and the dispatcher will either fail to connect to a worker or\nwill get an error code \"initializing\" to tell it to try another worker that may\nbe ready. \n\n\n", "id": 59163, "time": "2004-06-13T15:18:58Z", "creator": "cmanolache@yahoo.com", "creation_time": "2004-06-13T15:18:58Z", "is_private": false, "attachment_id": null}]