[{"attachment_id": null, "tags": [], "creator": "gordon@idisagree.org", "text": "Component: JMS Point-to-Point sampler\n\nObserved from the JMeter GUI on Windows 7 and when run via jmeter-maven-plugin on Redhat 6.6. Observed in JMeter v2.13 most recently and have also noticed it in version 2.6 in the past.\n\nProblematic behavior:\n\nWhen run in \"Request Response\" mode and a value is not set for \"JNDI name Receive queue\" there is no effective way to deal with timeouts. If a reply message never arrives the test thread hangs forever. Per the Stackoverflow article linked below this sampler uses a JMS Temporary Queue to handle the replies and does not set any timeout when waiting for those replies.\n\nhttp://stackoverflow.com/questions/28609859/timeout-of-jms-point-to-point-requests-in-jmeter-does-not-result-in-an-error\n\nhttps://github.com/apache/jmeter/blob/dd30d6171d031d3288c7d31da303823dccee03c2/src/protocol/jms/org/apache/jmeter/protocol/jms/sampler/JMSSampler.java#L373\n\nExcerpt from the source linked immediately above:\n\n if (useTemporyQueue()) {\n   executor = new TemporaryQueueExecutor(session, sendQueue); // Timeout setting isn't applied!\n } else {\n   producer = session.createSender(sendQueue);\n  executor = new FixedQueueExecutor(producer, getTimeoutAsInt(), isUseReqMsgIdAsCorrelId());\n }\n\nAlso, the TemporaryQueueExecutor's sendAndReceive method is given a timeout value by the JMSSampler class BUT it doesn't use it per the source linked and excerpted immediately below:\n\nhttps://github.com/apache/jmeter/blob/5512162ec752b35378275711a9a03f4d003a664a/src/protocol/jms/org/apache/jmeter/protocol/jms/sampler/TemporaryQueueExecutor.java\n\n  @Override\n  public Message sendAndReceive(Message request, \n            int deliveryMode, \n            int priority, \n            long expiration) throws JMSException {\n        return requestor.request(request);\n  }\n\n\nHow to reproduce the behavior:\n\nCreate a JMS service that replies to any input message by sending a reply message to the destination found in the request message at \"javax.jms.Message.getJMSReplyTo()\". Then configure a JMeter job to use the \"JMS Point-to-Point\" sampler to send messages to the request queue for that \"dummy service\". Do not set the \"JNDI name Receive queue\" property on the sampler. Set the timeout to 5 seconds and observe that the test works. Now modify the service provider to not send any responses. Run the test again and observe that it never completes.\n\nDesired behavior:\n\nWhen a reply message does not arrive within the specified timeout window that sample should be marked as failed and the test should proceed to the next sample. It is acceptable for this to continue to work in a blocking manner where the next request doesn't go out until the reply arrives or (after this fix/enhancement is applied) the timeout is hit.\n\nThe implementation of \"TemporaryQueueExecutor\" reuses the same temporary queue for all requests issued by the thread and doesn't use any form of secondary reply message correlation technique to verify that the received message is a response to the request message. As such, when a timeout occurs the executor needs to handle it by marking this sample as a failure, deleting the temporary queue, creating a new temporary queue, and then allowing the next request to proceed. Deleting the temporary queue is necessary in case the provider sends a reply message after the timeout period; we don't want the next sample to receive that late reply as if it were the reply to some other issued-later request.\n\nTo implement this change you'll have to abandon the usage of JMS's QueueRequestor since it doesn't appear to let you set a timeout.", "count": 0, "id": 185798, "time": "2015-10-19T17:55:19Z", "bug_id": 58506, "creation_time": "2015-10-19T17:55:19Z", "is_private": false}, {"count": 1, "tags": [], "text": "Here's an alternative solution that preserves the configuration interface but significantly changes the test's behavior:\n\nWhen no \"JNDI name Receive queue\" is provided create a single temporary queue and internally use that queue name for that field.\n\nThis way the execution behavior would always be asynchronous with requests going out at a consistent rate regardless of how fast the replies are coming back. This has the advantage of avoiding the \"Coordinated Omission\" problem (search \"Gil Tene Coordinated Omission\" if you're not familiar with that concept). This solution keeps the configuration interface simple. The downside is that people that were using the TemporaryQueueExecutor approach would see new behavior when they upgrade; these more-accurate results are likely to show worse peformance numbers so we'd get some questions when people do that upgrade.", "attachment_id": null, "bug_id": 58506, "id": 186208, "time": "2015-11-02T22:31:36Z", "creator": "gordon@idisagree.org", "creation_time": "2015-11-02T22:31:36Z", "is_private": false}, {"count": 2, "tags": [], "creator": "gordon@idisagree.org", "is_private": false, "id": 188134, "attachment_id": null, "bug_id": 58506, "creation_time": "2016-02-01T23:06:04Z", "time": "2016-02-01T23:06:04Z", "text": "This is a request for feedback to guide our development effort on this one. We're considering taking the approach given in my last comment:\n\nWhen no \"JNDI name Receive queue\" is provided create a single temporary queue and act as if that temp queue's name was placed in the \"JNDI name Receive queue\" field. This will naturally cause receive timeouts to be applied AND will avoid the coordinated omission error in the metrics that JMeter collects.\n\nPlease respond by stating whether you have significant concerns about this approach. It'll keep the UI simple but will prevent JMeter from being able to generate a load using a limited number of threads each doing a blocking invocation.\n\nIf there are no objections to this approach we'll do it as-proposed to keep it simple. If you believe that users want to be able to generate load using a limited number of threads each doing a blocking invocation we can try to come up with an understandable way to present both options to users in the UI but I think it'll end up making the UI less understandable."}, {"count": 3, "attachment_id": null, "bug_id": 58506, "text": "(In reply to Gordon Daugherty from comment #1)\n> Here's an alternative solution that preserves the configuration interface\n> but significantly changes the test's behavior:\n> \n> When no \"JNDI name Receive queue\" is provided create a single temporary\n> queue and internally use that queue name for that field.\n> \n> This way the execution behavior would always be asynchronous with requests\n> going out at a consistent rate regardless of how fast the replies are coming\n> back. This has the advantage of avoiding the \"Coordinated Omission\" problem\n> (search \"Gil Tene Coordinated Omission\" if you're not familiar with that\n> concept). This solution keeps the configuration interface simple. The\n> downside is that people that were using the TemporaryQueueExecutor approach\n> would see new behavior when they upgrade; these more-accurate results are\n> likely to show worse peformance numbers so we'd get some questions when\n> people do that upgrade.\n\n(In reply to Gordon Daugherty from comment #0)\n> Component: JMS Point-to-Point sampler\n> \n> Observed from the JMeter GUI on Windows 7 and when run via\n> jmeter-maven-plugin on Redhat 6.6. Observed in JMeter v2.13 most recently\n> and have also noticed it in version 2.6 in the past.\n> \n> Problematic behavior:\n> \n> When run in \"Request Response\" mode and a value is not set for \"JNDI name\n> Receive queue\" there is no effective way to deal with timeouts. If a reply\n> message never arrives the test thread hangs forever. Per the Stackoverflow\n> article linked below this sampler uses a JMS Temporary Queue to handle the\n> replies and does not set any timeout when waiting for those replies.\n> \n> http://stackoverflow.com/questions/28609859/timeout-of-jms-point-to-point-\n> requests-in-jmeter-does-not-result-in-an-error\n> \n> https://github.com/apache/jmeter/blob/\n> dd30d6171d031d3288c7d31da303823dccee03c2/src/protocol/jms/org/apache/jmeter/\n> protocol/jms/sampler/JMSSampler.java#L373\n> \n> Excerpt from the source linked immediately above:\n> \n>  if (useTemporyQueue()) {\n>    executor = new TemporaryQueueExecutor(session, sendQueue); // Timeout\n> setting isn't applied!\n>  } else {\n>    producer = session.createSender(sendQueue);\n>   executor = new FixedQueueExecutor(producer, getTimeoutAsInt(),\n> isUseReqMsgIdAsCorrelId());\n>  }\n> \n> Also, the TemporaryQueueExecutor's sendAndReceive method is given a timeout\n> value by the JMSSampler class BUT it doesn't use it per the source linked\n> and excerpted immediately below:\n> \n> https://github.com/apache/jmeter/blob/\n> 5512162ec752b35378275711a9a03f4d003a664a/src/protocol/jms/org/apache/jmeter/\n> protocol/jms/sampler/TemporaryQueueExecutor.java\n> \n>   @Override\n>   public Message sendAndReceive(Message request, \n>             int deliveryMode, \n>             int priority, \n>             long expiration) throws JMSException {\n>         return requestor.request(request);\n>   }\n\nJust to be sure there is no confusion, expiration here is not a timeout in processing of message. It's an expiration of the message. \n\n> \n> \n> How to reproduce the behavior:\n> \n> Create a JMS service that replies to any input message by sending a reply\n> message to the destination found in the request message at\n> \"javax.jms.Message.getJMSReplyTo()\". Then configure a JMeter job to use the\n> \"JMS Point-to-Point\" sampler to send messages to the request queue for that\n> \"dummy service\". Do not set the \"JNDI name Receive queue\" property on the\n> sampler. Set the timeout to 5 seconds and observe that the test works. Now\n> modify the service provider to not send any responses. Run the test again\n> and observe that it never completes.\n> \n> Desired behavior:\n> \n> When a reply message does not arrive within the specified timeout window\n> that sample should be marked as failed and the test should proceed to the\n> next sample. It is acceptable for this to continue to work in a blocking\n> manner where the next request doesn't go out until the reply arrives or\n> (after this fix/enhancement is applied) the timeout is hit.\n> \n> The implementation of \"TemporaryQueueExecutor\" reuses the same temporary\n> queue for all requests issued by the thread and doesn't use any form of\n> secondary reply message correlation technique to verify that the received\n> message is a response to the request message. As such, when a timeout occurs\n> the executor needs to handle it by marking this sample as a failure,\n> deleting the temporary queue, creating a new temporary queue, and then\n> allowing the next request to proceed. Deleting the temporary queue is\n> necessary in case the provider sends a reply message after the timeout\n> period; we don't want the next sample to receive that late reply as if it\n> were the reply to some other issued-later request.\n> \n> To implement this change you'll have to abandon the usage of JMS's\n> QueueRequestor since it doesn't appear to let you set a timeout.", "id": 188169, "time": "2016-02-02T21:55:16Z", "creator": "p.mouawad@ubik-ingenierie.com", "creation_time": "2016-02-02T21:55:16Z", "tags": [], "is_private": false}, {"count": 4, "tags": [], "text": "(In reply to Gordon Daugherty from comment #2)\n> This is a request for feedback to guide our development effort on this one.\n> We're considering taking the approach given in my last comment:\n> \n> When no \"JNDI name Receive queue\" is provided create a single temporary\n> queue and act as if that temp queue's name was placed in the \"JNDI name\n> Receive queue\" field. This will naturally cause receive timeouts to be\n> applied AND will avoid the coordinated omission error in the metrics that\n> JMeter collects.\n> \n> Please respond by stating whether you have significant concerns about this\n> approach. It'll keep the UI simple but will prevent JMeter from being able\n> to generate a load using a limited number of threads each doing a blocking\n> invocation.\n> \n> If there are no objections to this approach we'll do it as-proposed to keep\n> it simple. If you believe that users want to be able to generate load using\n> a limited number of threads each doing a blocking invocation we can try to\n> come up with an understandable way to present both options to users in the\n> UI but I think it'll end up making the UI less understandable.\n\nFirst thanks for your contribution.\nSecond, if possible, I think you should keep the current possibility to generate load using a limited number of threads each doing a blocking invocation, unless this is absolutely stupid, which for now is not sure in my understanding.\n\nWhat would be the impact on UI of this ?", "attachment_id": null, "id": 188170, "creator": "p.mouawad@ubik-ingenierie.com", "time": "2016-02-02T22:04:39Z", "bug_id": 58506, "creation_time": "2016-02-02T22:04:39Z", "is_private": false}, {"count": 5, "tags": [], "creator": "gordon@idisagree.org", "is_private": false, "id": 192960, "attachment_id": null, "bug_id": 58506, "creation_time": "2016-08-09T13:26:53Z", "time": "2016-08-09T13:26:53Z", "text": "You asked about the impact to the UI. I'll added attachments in a moment that demonstrate how it might look if we preserve the availability of the old functionality, offer the new, and make the new the default. I'll attach screenshots and the source code used to mock this up."}, {"count": 6, "tags": [], "creator": "gordon@idisagree.org", "attachment_id": 34113, "id": 192961, "time": "2016-08-09T13:33:22Z", "bug_id": 58506, "creation_time": "2016-08-09T13:33:22Z", "is_private": false, "text": "Created attachment 34113\nPatchfile showing draft of proposed UI changes"}, {"count": 7, "tags": [], "creator": "gordon@idisagree.org", "text": "Created attachment 34114\nCompiled demo of proposed UI changes. Matches patchfile in attachment 34113.", "id": 192962, "attachment_id": 34114, "bug_id": 58506, "creation_time": "2016-08-09T13:35:37Z", "time": "2016-08-09T13:35:37Z", "is_private": false}, {"count": 8, "tags": [], "creator": "gordon@idisagree.org", "attachment_id": 34115, "id": 192963, "time": "2016-08-09T13:40:09Z", "bug_id": 58506, "creation_time": "2016-08-09T13:40:09Z", "is_private": false, "text": "Created attachment 34115\nScreenshot of proposed UI - showing settings for existing behavior"}, {"count": 9, "tags": [], "bug_id": 58506, "attachment_id": 34116, "text": "Created attachment 34116\nScreenshot of proposed UI - showing settings for new behavior (temp q mode)", "id": 192964, "time": "2016-08-09T13:40:34Z", "creator": "gordon@idisagree.org", "creation_time": "2016-08-09T13:40:34Z", "is_private": false}, {"attachment_id": 34117, "tags": [], "bug_id": 58506, "text": "Created attachment 34117\nScreenshot of proposed UI - showing settings for new behavior (permanent queue mode)", "count": 10, "id": 192965, "time": "2016-08-09T13:41:02Z", "creator": "gordon@idisagree.org", "creation_time": "2016-08-09T13:41:02Z", "is_private": false}]