[{"count": 0, "tags": [], "bug_id": 42728, "attachment_id": null, "id": 104661, "time": "2007-06-23T18:00:03Z", "creator": "beau.croteau@ca.com", "creation_time": "2007-06-23T18:00:03Z", "is_private": false, "text": "the mod_ssl module has the following code implmented:\nstatic unsigned long ssl_util_thr_id(void)\n{\n    /* OpenSSL needs this to return an unsigned long.  On OS/390, the pthread\n     * id is a structure twice that big.  Use the TCB pointer instead as a\n     * unique unsigned long.\n     */\n#ifdef __MVS__\n    struct PSA {\n        char unmapped[540];\n        unsigned long PSATOLD;\n    } *psaptr = 0;\n\n    return psaptr->PSATOLD;\n#else\n    return (unsigned long) apr_os_thread_current();\n#endif\n}\n\nAnd when the following code is called inside of openssl 0.9.8e:\n\tcase DLL_THREAD_DETACH:\n\t\tERR_remove_state(0);\n\t\tbreak;\n\nThis causes the CRYPTO_set_id_callback() to be called.  The problem is that\napr_os_thread_current() calls DuplicateHandle for the thread and this causes the\nthread HANDLE to leak for the detaching thread.\n\nThis can be reproduced by having an apache module that that does the following\nwith the mod_ssl module loaded:\nstatic void* APR_THREAD_FUNC testThread2(apr_thread_t *thd,void* input)\n{\n\tprintf(\"Sample module: Another thread being launching -\n%d\\n\",GetCurrentThreadId());\n\tapr_thread_exit(thd,APR_SUCCESS);\n\treturn NULL;\n}\n\nstatic void* APR_THREAD_FUNC testThread(apr_thread_t *thd,void* input)\n{\n\tapr_thread_t *thd_arr;\n\tapr_pool_t *mp;\n\tapr_threadattr_t *thd_attr;\n\t\n\tapr_pool_create(&mp, NULL);\n\tapr_threadattr_create (&thd_attr, mp);\n\tapr_threadattr_detach_set (thd_attr, 1);\n\n\twhile(1)\n\t{\n\t\tprintf(\"Sample module, launching thread.\\n\");\n\t\t//_beginthread(testThread2,0,NULL);\n\t\tapr_thread_create(&thd_arr, thd_attr, testThread2, NULL, mp);\n\t\tSleep(5000);\n\t}\n\tapr_thread_exit(thd,APR_SUCCESS);\n\treturn NULL;\n}\nstatic int helloworld_handler(request_rec *r) {\n\tapr_thread_t *thd_arr;\n\tapr_pool_t *mp;\n\tapr_threadattr_t *thd_attr;\n\n  /* First, some housekeeping. */\n  if (!r->handler || strcasecmp(r->handler, \"helloworld\") != 0) {\n    /* r->handler wasn't \"helloworld\", so it's none of our business */\n    return DECLINED;\n  }\n\n  if (r->method_number != M_GET) {\n    /* We only accept GET and HEAD requests.\n     * They are identical for the purposes of a content generator\n     * Returning an HTTP error code causes Apache to return an\n     * error page (ErrorDocument) to the client.\n     */\n    return HTTP_METHOD_NOT_ALLOWED;\n  }\n\n\t/* OK, we're happy with this request, so we'll return the response. */\n\n\tap_set_content_type(r, \"text/html\");\n\tap_rputs(\"<title>Hello World!</title> .... etc...starting threads...\", r);\n\n\tapr_pool_create(&mp, NULL);\n\tapr_threadattr_create (&thd_attr, mp);\n\tapr_threadattr_detach_set (thd_attr, 1);\n\tapr_thread_create(&thd_arr, thd_attr, testThread, NULL, mp);\n\n\n  /* we return OK to indicate that we have successfully processed\n   * the request.  No further processing is required.\n   */\n  return OK;\n}"}, {"count": 1, "tags": [], "text": "Calling apr_os_thread_current() should not cause a persistent memory leak; if it\ndoes, it's an APR bug.  (I'm not convinced it does, from reading the Win32 code;\nit looks like a once-per-thread allocation, and so harmless?)", "is_private": false, "bug_id": 42728, "id": 108318, "time": "2007-09-18T03:05:42Z", "creator": "jorton@redhat.com", "creation_time": "2007-09-18T03:05:42Z", "attachment_id": null}, {"count": 2, "tags": [], "bug_id": 42728, "attachment_id": null, "id": 108373, "time": "2007-09-19T07:57:41Z", "creator": "beau.croteau@ca.com", "creation_time": "2007-09-19T07:57:41Z", "is_private": false, "text": "Calling apr_os_thread_current() causes a duplication of the Handle, so when the\nthread detaches that handle turns in to a dangling pointer.\n\nThe problem is the mod_ssl code overwrites the default behavior for\nssl_util_thr_id which, when called in the case mentioned, will leak the handle.\n\nIt is not limited to APR thread creation/destruction, it can be any method you\nchoose to create/destroy threads and the leak will still occur.  If you use the\nstandard _beginthread API or CreateThread API, the same thing occurs.  It's\nbecause the thread is detaching and there's nothing to clean up the duplicate\nhandle after it's detached."}, {"count": 3, "tags": [], "text": "There is a race condition between apr_thread_create() and dummy_worker().  dummy_worker() could start and proceed past the access of thd->td before apr_thread_create() has had a chance to set (*new)->td.  This sets the TLS tls_apr_thread value to NULL.  So when the created thread calls apr_os_thread_current(), the current thread's handle is duplicated and placed in the tls_apr_thread TLS slot.  The tls_apr_thread recorded HANDLE is never closed.\n\nThe race condition and when the thread created as detached (attr->detach) as described in Comment 1 and Comment 2, leak a HANDLE if apr_os_thread_current() is called.", "attachment_id": null, "bug_id": 42728, "id": 118062, "time": "2008-06-27T05:27:19Z", "creator": "Joe.Mudd@sas.com", "creation_time": "2008-06-27T05:27:19Z", "is_private": false}]