[{"count": 0, "tags": [], "bug_id": 39691, "attachment_id": null, "text": "DBAppender contains scripts for creating tables with columns with maximal length\n - for example renderedmessage is VARCHAR2(4000). However while appending\nrecords length is not controlled, so if I try to append long log database throws\nexception and nothing is logged.\n\nThe same problem as with rendered message is with writing stack trace. So I\nextended your classes with mine, although I think this functionality should be\nin base classes.\n\n############## Repaired Log4JTrimmedLoggingEvent ################\n\npackage cz.corpus.f1.commons.log;\n\nimport org.apache.log4j.Level;\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.spi.LocationInfo;\nimport org.apache.log4j.spi.LoggingEvent;\nimport org.apache.log4j.spi.ThrowableInformation;\n\nimport java.util.Hashtable;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * @author Jan Novotn\u00fd\n */\npublic class Log4JTrimmedLoggingEvent extends LoggingEvent {\n    LoggingEvent original;\n\n    public Log4JTrimmedLoggingEvent(LoggingEvent original) {\n        this.original = original;\n    }\n\n    public boolean equals(Object rObject) {\n        return original.equals(rObject);\n    }\n\n    public String getFQNOfLoggerClass() {\n        return original.getFQNOfLoggerClass();\n    }\n\n    public Level getLevel() {\n        return original.getLevel();\n    }\n\n    public LocationInfo getLocationInformation() {\n        return original.getLocationInformation();\n    }\n\n    public Logger getLogger() {\n        return original.getLogger();\n    }\n\n    public String getLoggerName() {\n        return original.getLoggerName();\n    }\n\n    public Object getMDC(final String key) {\n        return original.getMDC(key);\n    }\n\n    public void getMDCCopy() {\n        original.getMDCCopy();\n    }\n\n    public Object getMessage() {\n        return original.getMessage();\n    }\n\n    public String getNDC() {\n        return original.getNDC();\n    }\n\n    public Map getProperties() {\n        return original.getProperties();\n    }\n\n    public String getProperty(String key) {\n        return original.getProperty(key);\n    }\n\n    public Set getPropertyKeySet() {\n        return original.getPropertyKeySet();\n    }\n\n    public String getRenderedMessage() {\n        String origMsg = original.getRenderedMessage();\n        if(origMsg.length() > 3800){\n        \treturn origMsg.substring(0, 3800) + \" ... msg too long - trimed \" +\n(origMsg.length() - 3800) + \" characters\";\n        }\t\n        return origMsg;\n    }\n\n    public long getSequenceNumber() {\n        return original.getSequenceNumber();\n    }\n\n    public String getThreadName() {\n        return original.getThreadName();\n    }\n\n    public ThrowableInformation getThrowableInformation() {\n        return new\nLog4JTrimmedThrowableInformation(original.getThrowableInformation());\n    }\n\n    public String[] getThrowableStrRep() {\n        return new\nLog4JTrimmedThrowableInformation(original.getThrowableInformation()).getThrowableStrRep();\n    }\n\n    public long getTimeStamp() {\n        return original.getTimeStamp();\n    }\n\n    public int hashCode() {\n        return original.hashCode();\n    }\n\n    public void initializeProperties() {\n        original.initializeProperties();\n    }\n\n    public boolean locationInformationExists() {\n        return original.locationInformationExists();\n    }\n\n    public void prepareForDeferredProcessing() {\n        original.prepareForDeferredProcessing();\n    }\n\n    public void setFQNOfLoggerClass(String fqnOfLoggerClass) {\n        original.setFQNOfLoggerClass(fqnOfLoggerClass);\n    }\n\n    public void setLevel(Level level) {\n        original.setLevel(level);\n    }\n\n    public void setLocationInformation(LocationInfo li) {\n        original.setLocationInformation(li);\n    }\n\n    public void setLogger(Logger logger) {\n        original.setLogger(logger);\n    }\n\n    public void setLoggerName(String loggerName)\n            throws IllegalStateException {\n        original.setLoggerName(loggerName);\n    }\n\n    public void setMessage(Object message) {\n        original.setMessage(message);\n    }\n\n    public void setNDC(String ndcString) {\n        original.setNDC(ndcString);\n    }\n\n    public void setProperties(Hashtable properties) {\n        original.setProperties(properties);\n    }\n\n    public void setProperty(String key, String value) {\n        original.setProperty(key, value);\n    }\n\n    public void setRenderedMessage(String renderedMessage)\n            throws IllegalStateException {\n        original.setRenderedMessage(renderedMessage);\n    }\n\n    public void setSequenceNumber(long sequenceNumber) {\n        original.setSequenceNumber(sequenceNumber);\n    }\n\n    public void setThreadName(String threadName)\n            throws IllegalStateException {\n        original.setThreadName(threadName);\n    }\n\n    public void setThrowableInformation(ThrowableInformation ti) {\n        original.setThrowableInformation(ti);\n    }\n\n    public void setTimeStamp(long timeStamp) {\n        original.setTimeStamp(timeStamp);\n    }\n}\n\n\n############## Repaired Log4JTrimmedThrowableInformation ###############\n\npackage cz.corpus.f1.commons.log;\n\nimport org.apache.log4j.spi.ThrowableInformation;\n\n/**\n * @author Jan Novotn\u00fd\n */\npublic class Log4JTrimmedThrowableInformation extends ThrowableInformation {\n    ThrowableInformation original;\n\n    public Log4JTrimmedThrowableInformation(ThrowableInformation ti) {\n        super(ti.getThrowableStrRep());\n        original = ti;\n    }\n\n    public boolean equals(Object o) {\n        return original.equals(o);\n    }\n\n    public Throwable getThrowable() {\n        return original.getThrowable();\n    }\n\n    public String[] getThrowableStrRep() {\n        String[] throwableStrRep = original.getThrowableStrRep();\n        String[] result = new String[throwableStrRep.length];\n        for (int i = 0; i < throwableStrRep.length; i++) {\n            String msg = throwableStrRep[i];\n            int lng = msg.length();\n            if (msg != null && lng > 254) {\n                msg = \"...\" + msg.substring(lng - 230, lng);\n            }\n            result[i] = msg;\n        }\n        return throwableStrRep;\n    }\n}", "id": 89613, "time": "2006-05-31T10:39:29Z", "creator": "jan.novotny@corpus.cz", "creation_time": "2006-05-31T10:39:29Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 39691, "attachment_id": null, "text": "\nTruncation should be the resposibility of the appender, since it has the domain\nknowledge on the length to trim at.\n\nIt also appears that the stack trace is now in separate table rows.\n\nAlthough trimming can be done in other places, I'm thinking of adding a \n\nsetMaxMessageLength\nor\nsetMaxRenderedMessageLength\n\nto DBAppender and truncating using this value.  By default, no truncation would\nbe done.", "id": 98705, "time": "2007-01-29T12:54:34Z", "creator": "genman@noderunner.net", "creation_time": "2007-01-29T12:54:34Z", "is_private": false}, {"count": 2, "tags": [], "bug_id": 39691, "attachment_id": null, "id": 118245, "time": "2008-07-03T12:50:23Z", "creator": "thorbjoern@gmail.com", "creation_time": "2008-07-03T12:50:23Z", "is_private": false, "text": "(In reply to comment #1)\n> Truncation should be the resposibility of the appender, since it has the domain\n> knowledge on the length to trim at.\n\nIt should be expected that the logger logs as much as it can of the data it gets, so I disagree with this.\n\nThe suggested code contains magical constants - 3800, 254 and 230 - which should be better documented.  Best would be if the creation scripts use the same values to create the needed tables, otherwise they may get out of synchronization later."}, {"count": 3, "tags": [], "bug_id": 39691, "attachment_id": null, "text": "(In reply to comment #2)\n> (In reply to comment #1)\n> > Truncation should be the resposibility of the appender, since it has the domain\n> > knowledge on the length to trim at.\n> \n> It should be expected that the logger logs as much as it can of the data it\n> gets, so I disagree with this.\n\nI was apparently thinking of the logger and not the appender when writing the above.  Please disregard.\n", "id": 118270, "time": "2008-07-03T16:40:30Z", "creator": "thorbjoern@gmail.com", "creation_time": "2008-07-03T16:40:30Z", "is_private": false}, {"count": 4, "tags": [], "bug_id": 39691, "attachment_id": null, "text": "Please provide testcase demonstrating the issue reported to verify that provided fix makes it go away :)\n\nIt would be best if it uses the Derby database as it can be easily used in Java unit tests.", "id": 119258, "time": "2008-08-02T10:06:01Z", "creator": "thorbjoern@gmail.com", "creation_time": "2008-08-02T10:06:01Z", "is_private": false}, {"count": 5, "tags": [], "bug_id": 39691, "attachment_id": null, "text": "NEEDINFO isn't appropriate for this bug since there is enough information for someone to deal with it.  It would be great if the submitter would provide a test case, but it isn't essential for problem resolution.  Marking a bug as NEEDINFO basically puts it at the bottom of the work queue since it should only be used when the issue is stalled due to lack of info.\n", "id": 119463, "time": "2008-08-05T20:21:03Z", "creator": "carnold@apache.org", "creation_time": "2008-08-05T20:21:03Z", "is_private": false}]