[{"count": 0, "tags": [], "text": "We're using Tomcat in our product and facing issues with a few HTTP requests under traffic. Basically what happens is that incoming HTTP connection is terminated by Tomcat (TCP FIN or TCP RST packet is sent) right after HTTPS handshake is finished.\n\nEach traffic iteration consists of the following:\n\n1) 2000 Websocket connections used to pass data between the clients.\n2) Some minor supporting HTTP traffic.\n\nIn the end of traffic iteration Websocket sessions are closing and, at the same time, some supporting HTTP traffic is processed by Tomcat. I was adding various logs to the Tomcat code and figured out that Tomcat attempts to process these failing HTTP requests with Upgrade processors (org.apache.coyote.http11.upgrade.NioProcessor).\n\nI added the following logs:\n1) AbstractProtocol.AbstractConnectionHandler.process right after processor is identified:\n\n                if (processor.isUpgrade()) {\n                   getLog().info(\"AbstractConnectionHandler.process got processor from \" + processorSource + \n                         \". status = \" + status.name() + \n                         \", processor.id = \" + processor.getId());\n                }\n\n2) Http11NioProtocol.Http11ConnectionHandler.release (both, right before processor is recycled)\n\n               if (processor.getId()  == -2) {\n                  getLog().info(\"Recycling upgrade processor in HTTP protocol.\\n\", new Exception());\n               }\n\nnote that I adde method getId to all processors. For regular HTTP processors it equals to request ID (which I also added). For upgrade processor (org.apache.coyote.http11.upgrade.NioProcessor) ID always equal to -2.\n\nand here is the output I got right before failed HTTP request:\n\nApr 08, 2016 CDT 08:26:09.686 AM http-nio-135.60.87.90-443-ClientPoller-1 org.apache.coyote.http11.Http11NioProtocol\nINFO: Recycling upgrade processor in HTTP protocol.\n\n\njava.lang.Exception\n\tat org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.release(Http11NioProtocol.java:200)\n\tat org.apache.tomcat.util.net.NioEndpoint$Poller.cancelledKey(NioEndpoint.java:953)\n\tat org.apache.tomcat.util.net.NioEndpoint$Poller.processKey(NioEndpoint.java:1135)\n\tat org.apache.tomcat.util.net.NioEndpoint$Poller.run(NioEndpoint.java:1071)\n\tat java.lang.Thread.run(Thread.java:745)\n\n....\n\nApr 08, 2016 CDT 08:26:09.710 AM http-nio-135.60.87.90-443-exec-106 org.apache.coyote.http11.Http11NioProtocol\nINFO: AbstractConnectionHandler.process got processor from recycledProcessors map. status = OPEN_READ, processor.id = -2\n\nSo, what happens is - Poller adds NioProcessor to recycledProcessors stack of Http11NioProtocol.Http11ConnectionHandler and next HTTP request to Tomcat which is coming in is failing because Tomcat attempts to process it with NioProcessor instead of regular Http11NioProcessor.\n\nIf any additional logs are required to reproduce the issue  - please let me know. It seems like during normal operation such NioProcessors are just removed from commections map, for example here in AbstractProtocol.AbstractConnectionHandler.process method:\n                    // Connection closed. OK to recycle the processor. Upgrade\n                    // processors are not recycled.\n                    connections.remove(socket);\n                    if (processor.isUpgrade()) {\n...\n\nand are never expected to be recycled. And in case CancelledKeyException is thrown in Poller there's no check for upgrade processors and upgrade processor can be recycled.", "attachment_id": null, "id": 190069, "creator": "anmalyshev@mail.ru", "time": "2016-04-08T14:23:10Z", "bug_id": 59289, "creation_time": "2016-04-08T14:23:10Z", "is_private": false}, {"count": 1, "tags": [], "bug_id": 59289, "attachment_id": null, "text": "This need to be verified, but I do notice some upgraded processors going into this code path when running the websockets portion of the testsuite. I added an extra check based on the upgraded flag.", "id": 190070, "time": "2016-04-08T15:59:02Z", "creator": "remm@apache.org", "creation_time": "2016-04-08T15:59:02Z", "is_private": false}, {"count": 2, "tags": [], "creator": "anmalyshev@mail.ru", "text": "Does that mean that you have a fix for this issue?\nLooking at the code it's not clean if it's enough to just skip recycling such Upgrade connectors or it's also needed to execute the code similar to the one executed in normal scenario:\n\n                        UpgradeToken upgradeToken = processor.getUpgradeToken();\n                        HttpUpgradeHandler httpUpgradeHandler = upgradeToken.getHttpUpgradeHandler();\n                        InstanceManager instanceManager = upgradeToken.getInstanceManager();\n                        if (instanceManager == null) {\n                            httpUpgradeHandler.destroy();\n                        } else {\n                            ClassLoader oldCL = upgradeToken.getContextBind().bind(false, null);\n                            try {\n                                httpUpgradeHandler.destroy();\n                                instanceManager.destroyInstance(httpUpgradeHandler);\n                            } finally {\n                                upgradeToken.getContextBind().unbind(false, oldCL);\n                            }\n                        }", "id": 190074, "time": "2016-04-08T18:18:29Z", "bug_id": 59289, "creation_time": "2016-04-08T18:18:29Z", "is_private": false, "attachment_id": null}, {"count": 3, "tags": [], "text": "If you have a patch I can apply it, build tomcat and test the fix.", "attachment_id": null, "id": 190075, "creator": "anmalyshev@mail.ru", "time": "2016-04-08T18:19:13Z", "bug_id": 59289, "creation_time": "2016-04-08T18:19:13Z", "is_private": false}, {"count": 4, "tags": [], "bug_id": 59289, "attachment_id": null, "id": 190077, "time": "2016-04-08T19:17:34Z", "creator": "mgrigorov@apache.org", "creation_time": "2016-04-08T19:17:34Z", "is_private": false, "text": "Please check http://svn.apache.org/viewvc?view=revision&revision=1738261"}, {"count": 5, "tags": [], "creator": "anmalyshev@mail.ru", "text": "The change you mentioned is for trunk. I'm using 8.0.33, and it's quite different. For example it does not have implemented release() method in AbstractProtocol class. I applied similar change to Http11NioProtocol class and will retest. But if you can provide actual diff for 8.0 (which will be eventually released) - it would be much better as I'll be able to make sure this change is actually fixing an issue.", "id": 190131, "time": "2016-04-11T12:33:08Z", "bug_id": 59289, "creation_time": "2016-04-11T12:33:08Z", "is_private": false, "attachment_id": null}, {"count": 6, "tags": [], "text": "Even 7 had the issue when adding a debug in the right release method and using the websocket portion of the testsuite. Oops.", "attachment_id": null, "id": 190137, "creator": "remm@apache.org", "time": "2016-04-11T16:13:42Z", "bug_id": 59289, "creation_time": "2016-04-11T16:13:42Z", "is_private": false}, {"count": 7, "tags": [], "bug_id": 59289, "attachment_id": null, "text": "Remy's patches should have fixed this.", "id": 190148, "time": "2016-04-11T20:53:15Z", "creator": "markt@apache.org", "creation_time": "2016-04-11T20:53:15Z", "is_private": false}, {"count": 8, "tags": [], "bug_id": 59289, "is_private": false, "text": "The fix will be in 9M5, 8.5.1, 8.0.34 and 7.0.70.", "id": 190165, "time": "2016-04-11T23:48:48Z", "creator": "remm@apache.org", "creation_time": "2016-04-11T23:48:48Z", "attachment_id": null}, {"count": 9, "tags": [], "text": "Applied the patch and tested - issue is fixed.", "attachment_id": null, "id": 190246, "creator": "anmalyshev@mail.ru", "time": "2016-04-14T15:26:40Z", "bug_id": 59289, "creation_time": "2016-04-14T15:26:40Z", "is_private": false}]