[{"count": 0, "tags": [], "bug_id": 40939, "attachment_id": null, "text": "Pools currently allocate memory in 8K chunks; the size is a hardcoded constant.\nThis is not ideal when using APR from C++ code; it's preferable not to pass\npools around between classes as it breaks encapsulation. Therefore those C++\nobjects that make APR calls should have their own dedicated pools. 8K in many\ncases is wasteful; it would be appropriate to use memory in smaller increments.\n\nThe attached patch adds a new function apr_allocator_create_ex() that accepts a\nmin_size parameter, which gets stored in the apr_allocator_t structure and\nreplaces the hardcoded MIN_SIZE value.", "id": 95632, "time": "2006-11-09T15:30:51Z", "creator": "mlindner@google.com", "creation_time": "2006-11-09T15:30:51Z", "is_private": false}, {"count": 1, "tags": [], "creator": "mlindner@google.com", "attachment_id": 19106, "id": 95633, "time": "2006-11-09T15:31:43Z", "bug_id": 40939, "creation_time": "2006-11-09T15:31:43Z", "is_private": false, "text": "Created attachment 19106\napr_allocator.h.diff\n\nfile 1 of 2"}, {"count": 2, "tags": [], "bug_id": 40939, "attachment_id": 19107, "text": "Created attachment 19107\napr_pools.c.diff\n\nfile 2 of 2", "id": 95634, "time": "2006-11-09T15:32:03Z", "creator": "mlindner@google.com", "creation_time": "2006-11-09T15:32:03Z", "is_private": false}, {"count": 3, "tags": [], "creator": "rooneg@electricjellyfish.net", "attachment_id": 19107, "id": 95636, "time": "2006-11-09T16:32:42Z", "bug_id": 40939, "creation_time": "2006-11-09T16:32:42Z", "is_private": false, "text": "Comment on attachment 19107\napr_pools.c.diff\n\nOk, just trying to think some of this through, so bear with me...\n\n>Index: memory/unix/apr_pools.c\n>===================================================================\n>--- memory/unix/apr_pools.c\t(revision 473132)\n>+++ memory/unix/apr_pools.c\t(working copy)\n>@@ -44,7 +44,8 @@\n>  * Magic numbers\n>  */\n> \n>-#define MIN_ALLOC 8192\n>+#define MIN_ALLOC  512\n>+#define DFL_ALLOC 8192\n> #define MAX_INDEX   20\n\nSo, first you declare a minimum allocation size and a default allocation\nsize...\n\n[ ...snip... ]\n\n>+APR_DECLARE(apr_status_t) apr_allocator_create_ex(apr_allocator_t **allocator,\n>+                                                  apr_size_t min_size)\n>+{\n>     apr_allocator_t *new_allocator;\n> \n>     *allocator = NULL;\n>@@ -94,6 +102,8 @@\n>     memset(new_allocator, 0, SIZEOF_ALLOCATOR_T);\n>     new_allocator->max_free_index = APR_ALLOCATOR_MAX_FREE_UNLIMITED;\n> \n>+    new_allocator->min_size = (min_size >= MIN_ALLOC ? min_size : DFL_ALLOC);\n>+\n\nThen here, if the min size passed in is bigger than the MIN_ALLOC you'll use\nit, otherwise you fall back to the default alloc size?\tSo if I pass in 511\nbytes you jump right back to 8K?  If anything I'd expect to go up to the\nminimum size...\n\n>     *allocator = new_allocator;\n> \n>     return APR_SUCCESS;\n>@@ -178,8 +188,8 @@\n>      * allocate at least a certain size (MIN_ALLOC).\n>      */\n>     size = APR_ALIGN(size + APR_MEMNODE_T_SIZE, BOUNDARY_SIZE);\n>-    if (size < MIN_ALLOC)\n>-        size = MIN_ALLOC;\n>+    if(size < allocator->min_size)\n>+        size = allocator->min_size;\n\nMissing a space before the paren there...\n\nMaybe more importantly though, I wonder how all of this stuff plays with the\nlogic later on in that function:\n\n    /* Find the index for this node size by\n     * dividing its size by the boundary size\n     */\n    index = (size >> BOUNDARY_INDEX) - 1;\n\nHow is that going to work if size is something smaller than 8K?  I haven't\nreally thought this through, so it's certainly possible that it will work, but\nI'd always assumed that the reason we hadn't done this sort of thing before was\nthat it was more complex than it looked..."}, {"count": 4, "tags": [], "bug_id": 40939, "attachment_id": null, "id": 95639, "creation_time": "2006-11-09T17:34:06Z", "time": "2006-11-09T17:34:06Z", "creator": "mlindner@google.com", "text": "Ok, so we'll need to make sure the supplied size is a power of 2...\n\n    if ((min_size & 1) || (min_size < MIN_ALLOC))\n        new_allocator->min_size = MIN_ALLOC;\n    else\n        new_allocator->min_size = min_size;\n\n...and instead of using hardcoded BOUNDARY_INDEX and BOUNDARY_SIZE we add them\nas fields in apr_allocator_t, calculated as:\n\nnew_allocator->boundary_size = new_allocator->min_size / 2;\nnew_allocator->boundary_index = 0;\nint x = new_allocator->boundary_size;\nwhile ((x >>= 1))\n    (new_allocator->boundary_index)++;\n\nMAX_INDEX would probably have to be supplied by caller instead of being a fixed\nvalue as it determines the number of buckets (and thus size of largest bucket).\n\nI think that should work...I'll flesh out the patch when I have time...\n\n", "is_private": false}, {"count": 5, "tags": [], "text": "When you rework the patch, please be sure to add some comments explaining how\nthe various values relate to each other...  It's kind of opaque now.  Obviously\nthis isn't a problem with your patch, but if we're already diving into the guts\nof this stuff we might as well make it easier to understand for the next guy.", "attachment_id": null, "bug_id": 40939, "id": 95641, "time": "2006-11-09T18:37:51Z", "creator": "rooneg@electricjellyfish.net", "creation_time": "2006-11-09T18:37:51Z", "is_private": false}, {"count": 6, "tags": [], "creator": "davi@apache.org", "attachment_id": null, "id": 103135, "time": "2007-05-12T11:11:27Z", "bug_id": 40939, "creation_time": "2007-05-12T11:11:27Z", "is_private": false, "text": "Are you going to pursue this further?"}]