[{"count": 0, "tags": [], "text": "When examining the code of WebappClassLoader#findResourceInternal() (http://grepcode.com/file/repo1.maven.org/maven2/org.apache.tomcat/tomcat-catalina/7.0.26/org/apache/catalina/loader/WebappClassLoader.java#3098) I came to the conclusion that findResourceInternal() always loads the binary content of the resource, however binary content is only used in e.g. findClassInternal() and obviously not needed in findResource(). In certain cases this can cause OutOfMemoryError, for example when a big media file is packaged with application.\n\nThe example of stack trace is given here:\nhttp://stackoverflow.com/questions/10100480\n\nSolution: the binary content should be loaded for certain types of resources (.classpath or .properties [only if fileNeedConvert is true]).", "is_private": false, "id": 158045, "creator": "dma_k@mail.ru", "time": "2012-04-13T21:46:53Z", "bug_id": 53081, "creation_time": "2012-04-13T21:46:53Z", "attachment_id": null}, {"count": 1, "tags": [], "creator": "chris@christopherschultz.net", "text": "Stack trace is:\n\njava.lang.OutOfMemoryError: Java heap space\n    at org.apache.catalina.loader.WebappClassLoader.findResourceInternal(WebappClassLoader.java:3098)\n    at org.apache.catalina.loader.WebappClassLoader.findResource(WebappClassLoader.java:1244)\n    at org.apache.catalina.loader.WebappClassLoader.getResource(WebappClassLoader.java:1407)\n    at org.springframework.core.io.ClassPathResource.exists(ClassPathResource.java:139)\n    at org.springframework.batch.item.file.FlatFileItemReader.doOpen(FlatFileItemReader.java:248)\n    at org.springframework.batch.item.support.AbstractItemCountingItemStreamItemReader.open(AbstractItemCountingItemStreamItemReader.java:134)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n    at java.lang.reflect.Method.invoke(Method.java:597)\n    at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:309)\n    at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:183)\n    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:150)\n    at org.springframework.aop.support.DelegatingIntroductionInterceptor.doProceed(DelegatingIntroductionInterceptor.java:131)\n    at org.springframework.aop.support.DelegatingIntroductionInterceptor.invoke(DelegatingIntroductionInterceptor.java:119)\n    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)\n    at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:202)\n    at $Proxy30.open(Unknown Source)\n    at org.springframework.batch.item.support.CompositeItemStream.open(CompositeItemStream.java:93)\n    at org.springframework.batch.core.step.item.ChunkMonitor.open(ChunkMonitor.java:105)\n    at org.springframework.batch.item.support.CompositeItemStream.open(CompositeItemStream.java:93)\n    at org.springframework.batch.core.step.tasklet.TaskletStep.open(TaskletStep.java:301)\n    at org.springframework.batch.core.step.AbstractStep.execute(AbstractStep.java:192)\n    at org.springframework.batch.core.job.SimpleStepHandler.handleStep(SimpleStepHandler.java:135)\n    at org.springframework.batch.core.job.flow.JobFlowExecutor.executeStep(JobFlowExecutor.java:61)\n    at org.springframework.batch.core.job.flow.support.state.StepState.handle(StepState.java:60)\n    at org.springframework.batch.core.job.flow.support.SimpleFlow.resume(SimpleFlow.java:144)\n    at org.springframework.batch.core.job.flow.support.SimpleFlow.start(SimpleFlow.java:124)\n    at org.springframework.batch.core.job.flow.FlowJob.doExecute(FlowJob.java:135)\n    at org.springframework.batch.core.job.AbstractJob.execute(AbstractJob.java:281)\n    at org.springframework.batch.core.launch.support.SimpleJobLauncher$1.run(SimpleJobLauncher.java:120)\n    at org.springframework.core.task.SyncTaskExecutor.execute(SyncTaskExecutor.java:48)    \nLine of code in 7.0.x/trunk and trunk is actually 3151:\n\n  byte[] binaryContent = new byte[contentLength];\n\nI would argue that instead of only loading certain types of resources (using what? magic number or other content-type-sniffing?), WebAppClassLoader could be configured never to load complete content for resources over a certain size.\n\nI'd be interested to hear why resources are loaded in their entirety in this way. Another flavor of findResourceInternal(File,String) only creates URI objects and does not access the disk at all.", "id": 158226, "time": "2012-04-20T15:44:19Z", "bug_id": 53081, "creation_time": "2012-04-20T15:44:19Z", "is_private": false, "attachment_id": null}, {"count": 2, "tags": [], "creator": "markt@apache.org", "attachment_id": null, "id": 159445, "time": "2012-05-29T13:15:44Z", "bug_id": 53081, "creation_time": "2012-05-29T13:15:44Z", "is_private": false, "text": "As far as I can tell, the full resource has always been cached going back to the original implementation of the WebappClassLoader back in Tomcat 4.\n\nThis has been fixed in trunk and 7.0.x so the only things cached are a) classes (only temporarily until they are defined) and b) properties files needing encoding conversion. Note that the class loading code has been fragile in the past and it is possible that the fix may introduce a regression. If this is the case, it is likely the fix will be reverted and the advice will then be \"don't load large static resources this way\".\n\nAssuming no problems emerge during testing, the fix will be in 7.0.28 onwards."}, {"count": 3, "tags": [], "bug_id": 53081, "text": "We are observing significant performance degradation caused by this fix. In our case, the DocumentBuilderFactory.newInstance() method looks for class path resources. Before that fix the WebAppClassloader cached resources it had found and only the first call was slow. Now it scans jars on the classpath in each call and reading a big signed jar takes quite long.\n\nWe should be able to solve our problem by using javax.xml.parsers.DocumentBuilderFactory system property, but this change in the WebAppClassloader can cause performance degradation at other places.\n\nIs there any better way to solve the mentioned OutOfMemoryError?", "id": 171091, "time": "2013-11-06T13:44:33Z", "creator": "vladk.dev@gmail.com", "creation_time": "2013-11-06T13:44:33Z", "is_private": false, "attachment_id": null}, {"count": 4, "tags": [], "bug_id": 53081, "is_private": false, "id": 171094, "creation_time": "2013-11-06T16:17:00Z", "time": "2013-11-06T16:17:00Z", "creator": "chris@christopherschultz.net", "text": "I think you should open a new bug report and reference this old one in that new report. Your report will get more visibility that way.", "attachment_id": null}]