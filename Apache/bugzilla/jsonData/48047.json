[{"count": 0, "tags": [], "creator": "qingyang.xu@qunar.com", "text": "Below is the source code of process() method:\n\npublic boolean process(Socket socket) {\n            Http11Processor processor = recycledProcessors.poll();\n            try {\n\n                if (processor == null) {\n                    processor = createProcessor();\n                }\n\n                if (processor instanceof ActionHook) {\n                    ((ActionHook) processor).action(ActionCode.ACTION_START, null);\n                }\n\n                if (proto.secure && (proto.sslImplementation != null)) {\n                    processor.setSSLSupport\n                        (proto.sslImplementation.getSSLSupport(socket));\n                } else {\n                    processor.setSSLSupport(null);\n                }\n                \n                processor.process(socket);\n                return false;\n\n            } catch(java.net.SocketException e) {\n                // SocketExceptions are normal\n                Http11Protocol.log.debug\n                    (sm.getString\n                     (\"http11protocol.proto.socketexception.debug\"), e);\n            } catch (java.io.IOException e) {\n                // IOExceptions are normal\n                Http11Protocol.log.debug\n                    (sm.getString\n                     (\"http11protocol.proto.ioexception.debug\"), e);\n            }\n            // Future developers: if you discover any other\n            // rare-but-nonfatal exceptions, catch them here, and log as\n            // above.\n            catch (Throwable e) {\n                // any other exception or error is odd. Here we log it\n                // with \"ERROR\" level, so it will show up even on\n                // less-than-verbose logs.\n                Http11Protocol.log.error\n                    (sm.getString(\"http11protocol.proto.error\"), e);\n            } finally {\n                //       if(proto.adapter != null) proto.adapter.recycle();\n                //                processor.recycle();\n\n                if (processor instanceof ActionHook) {\n                    ((ActionHook) processor).action(ActionCode.ACTION_STOP, null);\n                }\n                recycledProcessors.offer(processor);\n            }\n            return false;\n        }\n\nIt is easy to find out that the method always return the boolean value of 'false', which is pointless. It seems that it should return 'true' when process successfully, as such:\n\n          try {\n\n               ... ...\n                \n                processor.process(socket);\n                return true;\n\n            } catch(...)", "id": 131357, "time": "2009-10-24T04:29:07Z", "bug_id": 48047, "creation_time": "2009-10-24T04:29:07Z", "is_private": false, "attachment_id": null}, {"count": 1, "attachment_id": null, "bug_id": 48047, "text": "processor.process(socket) is a loop that continues until its time to release the socket. So the return value here has no meaning what-so-ever. \n\nIn trunk, you will see that the keep alive logic has been moved from the processor to the endpoint in order to accomodate async behavior, and there, the value is taken into consideration.\n\nSo for Tomcat 6, this will not likely change, since the return value is not really defined, when this method returns, the socket should close, regardless\n\nFilip", "id": 131387, "time": "2009-10-26T09:32:08Z", "creator": "fhanik@apache.org", "creation_time": "2009-10-26T09:32:08Z", "tags": [], "is_private": false}]