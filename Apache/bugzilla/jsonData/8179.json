[{"count": 0, "tags": [], "bug_id": 8179, "is_private": false, "text": "I have a Perl CGI which simply pulls data from a database and dumps it to a\ntable on a web page.  I was having a lot of trouble with the script hanging if\nit pulled more than X rows from the database, where X was usually some number\nbetween 15 and 25, but didn't seem to be a specific number, although the number\nwas always the same if I ran the same query.  Using the trace function of DBI\nidentified that the script was not hanging in DBI, but somewhere in the Perl\ncode between executions of $sth->fetchrow_array to retrieve data from the\ndatabase.  Running the script from the command line and redirecting output to a\nfile worked fine, it didn't hang, which seemed to implicate Apache as a\nmitigating factor in the problem.  Putting print statements to a separate\nlogfile between every line of code narrowed it down to a print statement OR a\nvariable assignment.  The root cause of the problem (and hence how I fixed it)\nwas NULL values in the database.  Checking those values first and converting\nthem to empty strings stopped the script from hanging.\n\nSo then I set off to find out why running the script as a CGI would cause an\nuninitialized value in a concatenation to hang when running it from the command\nline would not...   and the result is: when you have such an error, Perl outputs\na warning to STDERR.  This is trapped by Apache and written to the error log. \nApparently due to the sheer volume of the output to STDERR, Apache was getting\noverwhelmed by it or something.  The magic number seems to be right around 4K.\n\nI tested this with a script which did nothing but output data to STDERR, and\nindeed the script hung right about the point it hit the 4K mark.  When the\nscript hangs, nothing is actually written to the error log.  So Apache must be\ncaching the STDERR output in a 4K buffer and not flushing it frequently enough?\n\nThis is on Windows 2000 Professional running ApacheNT 1.3.24 as a service, with\nActivePerl 5.6.1 as the Perl environment.", "id": 13802, "time": "2002-04-16T22:36:45Z", "creator": "justdave@mozilla.com", "creation_time": "2002-04-16T22:36:45Z", "attachment_id": null}, {"attachment_id": null, "tags": [], "creator": "wrowe@apache.org", "is_private": false, "count": 1, "id": 14077, "time": "2002-04-19T19:00:48Z", "bug_id": 8179, "creation_time": "2002-04-19T19:00:48Z", "text": "This is a pipe race.  Pipes by default may be set anyhow Microsoft chooses, the\ndefault here is a 4KB pipe.  But Apache isn't attempting to consume the pipe\nuntil the output is read and flushed to the network.  There is a similar race\nif your CGI begins outputing before consuming all of it's input.\n\n-If- you can defer your stderr output until you undef STDOUT, the script \nshould work.  Please confirm.\n"}, {"attachment_id": null, "tags": [], "creator": "justdave@mozilla.com", "is_private": false, "count": 2, "id": 14913, "time": "2002-04-27T16:55:09Z", "bug_id": 8179, "creation_time": "2002-04-27T16:55:09Z", "text": "Just letting you know I haven't forgotten this yet...  we were quite busy this\nlast week and didn't get much chance to play with it.  I'll try again sometime\nthis next week.  On the other hand, I did upgrade to Apache 2.0 this last week,\nand the problem didn't go away.  Changing product accordingly."}, {"count": 3, "tags": [], "bug_id": 8179, "is_private": false, "text": "in the controlled test I was running, what you're asking should be possible to\ndo (I'll try it out and see what happens).  In the original circumstances that's\nnot exactly easy to do, since Perl can spew warnings whenever I screw up the\ncode.  And I don't know where I'm going to screw up ahead of time ;)", "id": 14915, "time": "2002-04-27T17:14:47Z", "creator": "justdave@mozilla.com", "creation_time": "2002-04-27T17:14:47Z", "attachment_id": null}, {"count": 4, "tags": [], "bug_id": 8179, "is_private": false, "text": "\n  Hope to incorporate this fix into the forthcoming 2.0.37 release, we will\n  now accept 64kb of output to stderr and 64kb of output to stdout while\n  still sending client body over stdin.  This matches Linux defaults, which\n  is as good as we will get without true polling between the connection and\n  all three cgi pipes.\n", "id": 16924, "time": "2002-05-30T05:34:18Z", "creator": "wrowe@apache.org", "creation_time": "2002-05-30T05:34:18Z", "attachment_id": null}]